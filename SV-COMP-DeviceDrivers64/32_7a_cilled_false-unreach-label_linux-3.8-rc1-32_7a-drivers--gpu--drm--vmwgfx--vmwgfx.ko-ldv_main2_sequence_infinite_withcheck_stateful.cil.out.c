extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 86 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 19 "include/linux/types.h"
typedef __u32 nlink_t;
#line 20 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 310 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 13 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 325
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 127 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 166 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 298 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 443
struct kmem_cache;
#line 444
struct perf_event;
#line 445 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 40 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint32_t uint32;
#line 42 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef int32_t int32;
#line 286 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestPtr {
   uint32 gmrId ;
   uint32 offset ;
};
#line 291 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestPtr SVGAGuestPtr;
#line 292 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_ldv_6384_32 {
   unsigned char bitsPerPixel ;
   unsigned char colorDepth ;
   unsigned short reserved ;
};
#line 292 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
union __anonunion_ldv_6386_31 {
   struct __anonstruct_ldv_6384_32 ldv_6384 ;
   uint32 value ;
};
#line 292 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGMRImageFormat {
   union __anonunion_ldv_6386_31 ldv_6386 ;
};
#line 325 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGMRImageFormat SVGAGMRImageFormat;
#line 370 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedRect {
   int32 left ;
   int32 top ;
   int32 right ;
   int32 bottom ;
};
#line 391 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedRect SVGASignedRect;
#line 1331 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 {
   SVGAGuestPtr ptr ;
   uint32 bytesPerLine ;
   SVGAGMRImageFormat format ;
};
#line 1331 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 SVGAFifoCmdDefineGMRFB;
#line 612 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_9121 {
    SVGA3D_RT_DEPTH = 0,
    SVGA3D_RT_STENCIL = 1,
    SVGA3D_RT_COLOR0 = 2,
    SVGA3D_RT_COLOR1 = 3,
    SVGA3D_RT_COLOR2 = 4,
    SVGA3D_RT_COLOR3 = 5,
    SVGA3D_RT_COLOR4 = 6,
    SVGA3D_RT_COLOR5 = 7,
    SVGA3D_RT_COLOR6 = 8,
    SVGA3D_RT_COLOR7 = 9,
    SVGA3D_RT_MAX = 10,
    SVGA3D_RT_INVALID = 4294967295U
} ;
#line 626 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9121 SVGA3dRenderTargetType;
#line 703 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTextureStateName;
#line 763 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTextureFilter;
#line 804
enum ldv_9146 {
    SVGA3D_DECLUSAGE_POSITION = 0,
    SVGA3D_DECLUSAGE_BLENDWEIGHT = 1,
    SVGA3D_DECLUSAGE_BLENDINDICES = 2,
    SVGA3D_DECLUSAGE_NORMAL = 3,
    SVGA3D_DECLUSAGE_PSIZE = 4,
    SVGA3D_DECLUSAGE_TEXCOORD = 5,
    SVGA3D_DECLUSAGE_TANGENT = 6,
    SVGA3D_DECLUSAGE_BINORMAL = 7,
    SVGA3D_DECLUSAGE_TESSFACTOR = 8,
    SVGA3D_DECLUSAGE_POSITIONT = 9,
    SVGA3D_DECLUSAGE_COLOR = 10,
    SVGA3D_DECLUSAGE_FOG = 11,
    SVGA3D_DECLUSAGE_DEPTH = 12,
    SVGA3D_DECLUSAGE_SAMPLE = 13,
    SVGA3D_DECLUSAGE_MAX = 14
} ;
#line 843 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9146 SVGA3dDeclUsage;
#line 844
enum ldv_9148 {
    SVGA3D_DECLMETHOD_DEFAULT = 0,
    SVGA3D_DECLMETHOD_PARTIALU = 1,
    SVGA3D_DECLMETHOD_PARTIALV = 2,
    SVGA3D_DECLMETHOD_CROSSUV = 3,
    SVGA3D_DECLMETHOD_UV = 4,
    SVGA3D_DECLMETHOD_LOOKUP = 5,
    SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED = 6
} ;
#line 853 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9148 SVGA3dDeclMethod;
#line 854
enum ldv_9150 {
    SVGA3D_DECLTYPE_FLOAT1 = 0,
    SVGA3D_DECLTYPE_FLOAT2 = 1,
    SVGA3D_DECLTYPE_FLOAT3 = 2,
    SVGA3D_DECLTYPE_FLOAT4 = 3,
    SVGA3D_DECLTYPE_D3DCOLOR = 4,
    SVGA3D_DECLTYPE_UBYTE4 = 5,
    SVGA3D_DECLTYPE_SHORT2 = 6,
    SVGA3D_DECLTYPE_SHORT4 = 7,
    SVGA3D_DECLTYPE_UBYTE4N = 8,
    SVGA3D_DECLTYPE_SHORT2N = 9,
    SVGA3D_DECLTYPE_SHORT4N = 10,
    SVGA3D_DECLTYPE_USHORT2N = 11,
    SVGA3D_DECLTYPE_USHORT4N = 12,
    SVGA3D_DECLTYPE_UDEC3 = 13,
    SVGA3D_DECLTYPE_DEC3N = 14,
    SVGA3D_DECLTYPE_FLOAT16_2 = 15,
    SVGA3D_DECLTYPE_FLOAT16_4 = 16,
    SVGA3D_DECLTYPE_MAX = 17
} ;
#line 874 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9150 SVGA3dDeclType;
#line 903
enum ldv_9156 {
    SVGA3D_PRIMITIVE_INVALID = 0,
    SVGA3D_PRIMITIVE_TRIANGLELIST = 1,
    SVGA3D_PRIMITIVE_POINTLIST = 2,
    SVGA3D_PRIMITIVE_LINELIST = 3,
    SVGA3D_PRIMITIVE_LINESTRIP = 4,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP = 5,
    SVGA3D_PRIMITIVE_TRIANGLEFAN = 6,
    SVGA3D_PRIMITIVE_MAX = 7
} ;
#line 913 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9156 SVGA3dPrimitiveType;
#line 958
enum ldv_9166 {
    SVGA3D_SHADERTYPE_VS = 1,
    SVGA3D_SHADERTYPE_PS = 2,
    SVGA3D_SHADERTYPE_MAX = 3
} ;
#line 963 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9166 SVGA3dShaderType;
#line 977 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dStretchBltMode;
#line 978
enum ldv_9172 {
    SVGA3D_QUERYTYPE_OCCLUSION = 0,
    SVGA3D_QUERYTYPE_MAX = 1
} ;
#line 982 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9172 SVGA3dQueryType;
#line 994 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTransferType;
#line 1077 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dSurfaceImageId {
   uint32 sid ;
   uint32 face ;
   uint32 mipmap ;
};
#line 1088 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dSurfaceImageId SVGA3dSurfaceImageId;
#line 1089 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 1110 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dGuestImage SVGA3dGuestImage;
#line 1124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdHeader_60 {
   uint32 id ;
   uint32 size ;
};
#line 1124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdHeader_60 SVGA3dCmdHeader;
#line 1269 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dBox_70 {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
};
#line 1269 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dBox_70 SVGA3dBox;
#line 1300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdPresent_73 {
   uint32 sid ;
};
#line 1300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdPresent_73 SVGA3dCmdPresent;
#line 1322 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetRenderTarget_77 {
   uint32 cid ;
   SVGA3dRenderTargetType type ;
   SVGA3dSurfaceImageId target ;
};
#line 1322 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetRenderTarget_77 SVGA3dCmdSetRenderTarget;
#line 1329 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceCopy_78 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
};
#line 1329 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceCopy_78 SVGA3dCmdSurfaceCopy;
#line 1338 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
   SVGA3dBox boxSrc ;
   SVGA3dBox boxDest ;
   SVGA3dStretchBltMode mode ;
};
#line 1338 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 SVGA3dCmdSurfaceStretchBlt;
#line 1378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMA_81 {
   SVGA3dGuestImage guest ;
   SVGA3dSurfaceImageId host ;
   SVGA3dTransferType transfer ;
};
#line 1378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMA_81 SVGA3dCmdSurfaceDMA;
#line 1444 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArrayRangeHint_83 {
   uint32 first ;
   uint32 last ;
};
#line 1444 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArrayRangeHint_83 SVGA3dArrayRangeHint;
#line 1462 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArray_84 {
   uint32 surfaceId ;
   uint32 offset ;
   uint32 stride ;
};
#line 1462 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArray_84 SVGA3dArray;
#line 1476 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexArrayIdentity_85 {
   SVGA3dDeclType type ;
   SVGA3dDeclMethod method ;
   SVGA3dDeclUsage usage ;
   uint32 usageIndex ;
};
#line 1476 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexArrayIdentity_85 SVGA3dVertexArrayIdentity;
#line 1483 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexDecl_86 {
   SVGA3dVertexArrayIdentity identity ;
   SVGA3dArray array ;
   SVGA3dArrayRangeHint rangeHint ;
};
#line 1483 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexDecl_86 SVGA3dVertexDecl;
#line 1533 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dPrimitiveRange_87 {
   SVGA3dPrimitiveType primType ;
   uint32 primitiveCount ;
   SVGA3dArray indexArray ;
   uint32 indexWidth ;
   int32 indexBias ;
};
#line 1533 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dPrimitiveRange_87 SVGA3dPrimitiveRange;
#line 1553 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDrawPrimitives_88 {
   uint32 cid ;
   uint32 numVertexDecls ;
   uint32 numRanges ;
};
#line 1553 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDrawPrimitives_88 SVGA3dCmdDrawPrimitives;
#line 1563 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_7466_90 {
   uint32 value ;
   float floatValue ;
};
#line 1563 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dTextureState_89 {
   uint32 stage ;
   SVGA3dTextureStateName name ;
   union __anonunion_ldv_7466_90 ldv_7466 ;
};
#line 1563 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dTextureState_89 SVGA3dTextureState;
#line 1668 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetShader_105 {
   uint32 cid ;
   SVGA3dShaderType type ;
   uint32 shid ;
};
#line 1668 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetShader_105 SVGA3dCmdSetShader;
#line 1674 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBeginQuery_106 {
   uint32 cid ;
   SVGA3dQueryType type ;
};
#line 1674 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBeginQuery_106 SVGA3dCmdBeginQuery;
#line 1681 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdEndQuery_107 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1681 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdEndQuery_107 SVGA3dCmdEndQuery;
#line 1688 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdWaitForQuery_108 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1688 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdWaitForQuery_108 SVGA3dCmdWaitForQuery;
#line 1743 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 {
   SVGA3dSurfaceImageId srcImage ;
   SVGASignedRect srcRect ;
   uint32 destScreenId ;
   SVGASignedRect destRect ;
};
#line 1743 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 SVGA3dCmdBlitSurfaceToScreen;
#line 65 "include/linux/miscdevice.h"
struct timespec;
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 214 "include/linux/rcupdate.h"
struct notifier_block;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_8887_120 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_8889_119 {
   struct __anonstruct_ldv_8887_120 ldv_8887 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_8889_119 ldv_8889 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct inode;
#line 87
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_121 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_121 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 411 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 133 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380 "include/linux/radix-tree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 83
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 90
struct pid_namespace;
#line 90 "include/linux/rbtree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 42
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 48
struct rw_semaphore;
#line 49 "include/linux/shrinker.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 96 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_187 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_187 nodemask_t;
#line 135 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_188 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_188 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct kobject;
#line 61
struct pipe_inode_info;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct cred;
#line 65
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_14132_215 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_14132_215 ldv_14132 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 409
struct address_space;
#line 410
struct writeback_control;
#line 340 "include/linux/fs.h"
union __anonunion_arg_217 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_216 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_217 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_216 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14568_218 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14588_219 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14604_220 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_14568_218 ldv_14568 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_14588_219 ldv_14588 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_14604_220 ldv_14604 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 726 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 734 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 757 "include/linux/fs.h"
union __anonunion_f_u_221 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 757 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_221 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 900
struct files_struct;
#line 900 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 901 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 906 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 923
struct nlm_lockowner;
#line 924 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_223 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_222 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_223 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_222 fl_u ;
};
#line 1010 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1216 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1232
struct file_system_type;
#line 1232
struct super_operations;
#line 1232
struct xattr_handler;
#line 1232
struct mtd_info;
#line 1232 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1469 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1508 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1545 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1588 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1801 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 303 "include/linux/srcu.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 398 "include/linux/gfp.h"
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_17546_225 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_17547_224 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_17546_225 ldv_17546 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_17547_224 ldv_17547 ;
};
#line 235
struct sock;
#line 236
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 242 "include/linux/slab.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 50 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 52 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
#line 53 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 125
struct tty_driver;
#line 261
struct nsproxy;
#line 24 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_226 {
   unsigned long sig[1U] ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_226 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_228 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_229 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_230 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_231 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_232 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_233 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_234 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_227 {
   int _pad[28U] ;
   struct __anonstruct__kill_228 _kill ;
   struct __anonstruct__timer_229 _timer ;
   struct __anonstruct__rt_230 _rt ;
   struct __anonstruct__sigchld_231 _sigchld ;
   struct __anonstruct__sigfault_232 _sigfault ;
   struct __anonstruct__sigpoll_233 _sigpoll ;
   struct __anonstruct__sigsys_234 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_227 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 11 "include/linux/signal.h"
struct user_struct;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 73 "include/linux/file.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184
struct of_device_id;
#line 184
struct acpi_device_id;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 191 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
#line 225 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 502 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 610
struct mfd_cell;
#line 611 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 95 "include/linux/pci.h"
typedef int pci_power_t;
#line 122 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 123
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 165 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 208
struct pcie_link_state;
#line 209
struct pci_vpd;
#line 210
struct pci_sriov;
#line 211
struct pci_ats;
#line 212
struct pci_driver;
#line 212 "include/linux/pci.h"
union __anonunion_ldv_20118_238 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 212 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_20118_238 ldv_20118 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 401
struct pci_ops;
#line 401 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 492 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 513 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 526 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 536 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 566 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1070 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 42 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21147_240 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21157_244 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21159_243 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_21157_244 ldv_21157 ;
   int units ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21161_242 {
   union __anonunion_ldv_21159_243 ldv_21159 ;
   atomic_t _count ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21162_241 {
   unsigned long counters ;
   struct __anonstruct_ldv_21161_242 ldv_21161 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21163_239 {
   union __anonunion_ldv_21147_240 ldv_21147 ;
   union __anonunion_ldv_21162_241 ldv_21162 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21170_246 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 112
struct slab;
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21174_245 {
   struct list_head lru ;
   struct __anonstruct_ldv_21170_246 ldv_21170 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21179_247 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 112 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_21163_239 ldv_21163 ;
   union __anonunion_ldv_21174_245 ldv_21174 ;
   union __anonunion_ldv_21179_247 ldv_21179 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_249 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_248 {
   struct __anonstruct_linear_249 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_248 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 273 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1843 "include/linux/pci.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 32 "include/linux/sem.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 44 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 460 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_26996_263 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27005_264 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_265 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_266 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_26996_263 ldv_26996 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_27005_264 ldv_27005 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_265 type_data ;
   union __anonunion_payload_266 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 357
struct kioctx;
#line 358 "include/linux/sched.h"
union __anonunion_ki_obj_267 {
   void *user ;
   struct task_struct *tsk ;
};
#line 358
struct eventfd_ctx;
#line 358 "include/linux/sched.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_267 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 161 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 181 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1051
struct rq;
#line 1052 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 39 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 275 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 279 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 106 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 111 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 44 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 58
struct agp_bridge_data;
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 75 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 110 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
#line 139 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
#line 173
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
#line 183
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
#line 234
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
#line 450 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
#line 575 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
#line 288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
};
#line 433 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 462 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 763 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_sarea.h"
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[64U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/idr.h"
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
#line 154
struct drm_file;
#line 155
struct drm_device;
#line 54 "include/linux/delay.h"
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
#line 46 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 63 "include/drm/drm_hashtab.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 173
struct drm_mm;
#line 173 "include/linux/seq_file.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long color ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
#line 58 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_color ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
   void (*color_adjust)(struct drm_mm_node * , unsigned long  , unsigned long * ,
                        unsigned long * ) ;
};
#line 296 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
#line 300 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
#line 346 "include/drm/drmP.h"
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   int list ;
   int dev_priv_size ;
   void *dev_private ;
};
#line 378 "include/drm/drmP.h"
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
#line 390 "include/drm/drmP.h"
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
#line 396 "include/drm/drmP.h"
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
#line 410 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
#line 420 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 426
struct drm_minor;
#line 426
struct drm_master;
#line 426 "include/drm/drmP.h"
struct drm_file {
   int authenticated ;
   struct pid *pid ;
   kuid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 474 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 496 "include/drm/drmP.h"
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   int flags ;
};
#line 521 "include/drm/drmP.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 539 "include/drm/drmP.h"
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
#line 550 "include/drm/drmP.h"
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 555 "include/drm/drmP.h"
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
#line 571 "include/drm/drmP.h"
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
#line 619
struct dma_buf;
#line 619
struct dma_buf_attachment;
#line 619 "include/drm/drmP.h"
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 41 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 6 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 27 "include/linux/export.h"
struct serial_icounter_struct;
#line 28 "include/linux/export.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 288 "include/linux/tty_driver.h"
struct tty_port;
#line 288 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 48 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 124 "include/linux/pps_kernel.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
#line 154 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
   wait_queue_head_t wq_idle ;
};
#line 160 "include/linux/tty_ldisc.h"
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
#line 42 "include/linux/tty.h"
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
#line 62 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 189 "include/linux/tty.h"
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned long iflags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 216 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned char closing : 1 ;
   unsigned short minimum_to_wake ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 91 "include/uapi/linux/serial.h"
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9U] ;
};
#line 779 "include/linux/fb.h"
struct drm_mode_set;
#line 780
struct drm_framebuffer;
#line 781
struct drm_object_properties;
#line 782 "include/linux/fb.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
#line 57 "include/drm/drm_crtc.h"
struct drm_object_properties {
   int count ;
   uint32_t ids[24U] ;
   uint64_t values[24U] ;
};
#line 64
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 105 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
#line 180
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 186
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 195 "include/drm/drm_crtc.h"
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
};
#line 220 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
#line 241 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 273 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
#line 286 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
#line 297
struct drm_crtc;
#line 298
struct drm_connector;
#line 299
struct drm_encoder;
#line 300
struct drm_pending_vblank_event;
#line 302 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
};
#line 362 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   bool invert_dimensions ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
   struct drm_object_properties properties ;
};
#line 425 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
#line 463 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
#line 475 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs  const  *funcs ;
   void *helper_private ;
};
#line 508
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 515 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
   unsigned int bad_edid_counter ;
};
#line 676 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 704 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
#line 719 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
#line 741 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   bool poll_running ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
#line 1076 "include/drm/drm_crtc.h"
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 705 "include/drm/drmP.h"
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device * ) ;
   char const   *(*get_name)(struct drm_device * ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   int (*set_unique)(struct drm_device * , struct drm_master * , struct drm_unique * ) ;
   int (*irq_by_busid)(struct drm_device * , struct drm_irq_busid * ) ;
   int (*agp_init)(struct drm_device * ) ;
};
#line 732
struct usb_driver;
#line 732 "include/drm/drmP.h"
union __anonunion_kdriver_286 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
#line 732 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , int * , int * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   void (*set_version)(struct drm_device * , struct drm_set_version * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   int (*gem_init_object)(struct drm_gem_object * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   union __anonunion_kdriver_286 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
#line 988 "include/drm/drmP.h"
struct drm_info_list {
   char const   *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
#line 999 "include/drm/drmP.h"
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
#line 1009 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
#line 1046 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 1053
struct usb_device;
#line 1053 "include/drm/drmP.h"
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15U] ;
   atomic_t counts[15U] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
#line 1619
enum drm_global_types {
    DRM_GLOBAL_TTM_MEM = 0,
    DRM_GLOBAL_TTM_BO = 1,
    DRM_GLOBAL_TTM_OBJECT = 2,
    DRM_GLOBAL_NUM = 3
} ;
#line 1626 "include/drm/drmP.h"
struct drm_global_reference {
   enum drm_global_types global_type ;
   size_t size ;
   void *object ;
   int (*init)(struct drm_global_reference * ) ;
   void (*release)(struct drm_global_reference * ) ;
};
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_size {
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
   uint32_t pad64 ;
};
#line 237 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_execbuf_arg {
   uint64_t commands ;
   uint32_t command_size ;
   uint32_t throttle_us ;
   uint64_t fence_rep ;
   uint32_t version ;
   uint32_t flags ;
};
#line 286 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_rep {
   uint32_t handle ;
   uint32_t mask ;
   uint32_t seqno ;
   uint32_t passed_seqno ;
   uint32_t pad64 ;
   int32_t error ;
};
#line 789 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "include/linux/prio_heap.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct cgroupfs_root;
#line 100
struct cgroup;
#line 101
struct css_id;
#line 62 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
#line 140 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   int id ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct callback_head callback_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
#line 214 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 108 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 116 "include/linux/swap.h"
struct swap_extent {
   struct list_head list ;
   unsigned long start_page ;
   unsigned long nr_pages ;
   sector_t start_block ;
};
#line 150 "include/linux/swap.h"
struct swap_info_struct {
   unsigned long flags ;
   short prio ;
   signed char type ;
   signed char next ;
   unsigned int max ;
   unsigned char *swap_map ;
   unsigned int lowest_bit ;
   unsigned int highest_bit ;
   unsigned int pages ;
   unsigned int inuse_pages ;
   unsigned int cluster_next ;
   unsigned int cluster_nr ;
   unsigned int lowest_alloc ;
   unsigned int highest_alloc ;
   struct swap_extent *curr_swap_extent ;
   struct swap_extent first_swap_extent ;
   struct block_device *bdev ;
   struct file *swap_file ;
   unsigned int old_block_size ;
   unsigned long *frontswap_map ;
   atomic_t frontswap_pages ;
};
#line 461 "include/linux/suspend.h"
struct ttm_bo_device;
#line 462 "include/linux/suspend.h"
struct ttm_placement {
   unsigned int fpfn ;
   unsigned int lpfn ;
   unsigned int num_placement ;
   uint32_t const   *placement ;
   unsigned int num_busy_placement ;
   uint32_t const   *busy_placement ;
};
#line 68 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bus_placement {
   void *addr ;
   unsigned long base ;
   unsigned long size ;
   unsigned long offset ;
   bool is_iomem ;
   bool io_reserved_vm ;
   uint64_t io_reserved_count ;
};
#line 91 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_reg {
   void *mm_node ;
   unsigned long start ;
   unsigned long size ;
   unsigned long num_pages ;
   uint32_t page_alignment ;
   uint32_t mem_type ;
   uint32_t placement ;
   struct ttm_bus_placement bus ;
};
#line 117
enum ttm_bo_type {
    ttm_bo_type_device = 0,
    ttm_bo_type_kernel = 1,
    ttm_bo_type_sg = 2
} ;
#line 123
struct ttm_tt;
#line 124
struct ttm_bo_global;
#line 124 "include/drm/ttm/ttm_bo_api.h"
struct ttm_buffer_object {
   struct ttm_bo_global *glob ;
   struct ttm_bo_device *bdev ;
   enum ttm_bo_type type ;
   void (*destroy)(struct ttm_buffer_object * ) ;
   unsigned long num_pages ;
   uint64_t addr_space_offset ;
   size_t acc_size ;
   struct kref kref ;
   struct kref list_kref ;
   wait_queue_head_t event_queue ;
   struct ttm_mem_reg mem ;
   struct file *persistent_swap_storage ;
   struct ttm_tt *ttm ;
   bool evicted ;
   atomic_t cpu_writers ;
   struct list_head lru ;
   struct list_head ddestroy ;
   struct list_head swap ;
   struct list_head io_reserve_lru ;
   uint32_t val_seq ;
   bool seq_valid ;
   atomic_t reserved ;
   void *sync_obj ;
   unsigned long priv_flags ;
   struct rb_node vm_rb ;
   struct drm_mm_node *vm_node ;
   unsigned long offset ;
   uint32_t cur_placement ;
   struct sg_table *sg ;
};
#line 741 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_shrink {
   int (*do_shrink)(struct ttm_mem_shrink * ) ;
};
#line 52 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_zone;
#line 53 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_global {
   struct kobject kobj ;
   struct ttm_mem_shrink *shrink ;
   struct workqueue_struct *swap_queue ;
   struct work_struct work ;
   spinlock_t lock ;
   struct ttm_mem_zone *zones[2U] ;
   unsigned int num_zones ;
   struct ttm_mem_zone *zone_kernel ;
   struct ttm_mem_zone *zone_dma32 ;
};
#line 39 "include/drm/ttm/ttm_module.h"
struct ttm_backend_func {
   int (*bind)(struct ttm_tt * , struct ttm_mem_reg * ) ;
   int (*unbind)(struct ttm_tt * ) ;
   void (*destroy)(struct ttm_tt * ) ;
};
#line 76 "include/drm/ttm/ttm_bo_driver.h"
enum ttm_caching_state {
    tt_uncached = 0,
    tt_wc = 1,
    tt_cached = 2
} ;
#line 88 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_tt {
   struct ttm_bo_device *bdev ;
   struct ttm_backend_func *func ;
   struct page *dummy_read_page ;
   struct page **pages ;
   uint32_t page_flags ;
   unsigned long num_pages ;
   struct sg_table *sg ;
   struct ttm_bo_global *glob ;
   struct file *swap_storage ;
   enum ttm_caching_state caching_state ;
   int state ;
};
#line 145
struct ttm_mem_type_manager;
#line 146 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager_func {
   int (*init)(struct ttm_mem_type_manager * , unsigned long  ) ;
   int (*takedown)(struct ttm_mem_type_manager * ) ;
   int (*get_node)(struct ttm_mem_type_manager * , struct ttm_buffer_object * , struct ttm_placement * ,
                   struct ttm_mem_reg * ) ;
   void (*put_node)(struct ttm_mem_type_manager * , struct ttm_mem_reg * ) ;
   void (*debug)(struct ttm_mem_type_manager * , char const   * ) ;
};
#line 233 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager {
   struct ttm_bo_device *bdev ;
   bool has_type ;
   bool use_type ;
   uint32_t flags ;
   unsigned long gpu_offset ;
   uint64_t size ;
   uint32_t available_caching ;
   uint32_t default_caching ;
   struct ttm_mem_type_manager_func  const  *func ;
   void *priv ;
   struct mutex io_reserve_mutex ;
   bool use_io_reserve_lru ;
   bool io_reserve_fastpath ;
   struct list_head io_reserve_lru ;
   struct list_head lru ;
};
#line 296 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_driver {
   struct ttm_tt *(*ttm_tt_create)(struct ttm_bo_device * , unsigned long  , uint32_t  ,
                                   struct page * ) ;
   int (*ttm_tt_populate)(struct ttm_tt * ) ;
   void (*ttm_tt_unpopulate)(struct ttm_tt * ) ;
   int (*invalidate_caches)(struct ttm_bo_device * , uint32_t  ) ;
   int (*init_mem_type)(struct ttm_bo_device * , uint32_t  , struct ttm_mem_type_manager * ) ;
   void (*evict_flags)(struct ttm_buffer_object * , struct ttm_placement * ) ;
   int (*move)(struct ttm_buffer_object * , bool  , bool  , bool  , struct ttm_mem_reg * ) ;
   int (*verify_access)(struct ttm_buffer_object * , struct file * ) ;
   bool (*sync_obj_signaled)(void * ) ;
   int (*sync_obj_wait)(void * , bool  , bool  ) ;
   int (*sync_obj_flush)(void * ) ;
   void (*sync_obj_unref)(void ** ) ;
   void *(*sync_obj_ref)(void * ) ;
   void (*move_notify)(struct ttm_buffer_object * , struct ttm_mem_reg * ) ;
   int (*fault_reserve_notify)(struct ttm_buffer_object * ) ;
   void (*swap_notify)(struct ttm_buffer_object * ) ;
   int (*io_mem_reserve)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
   void (*io_mem_free)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
};
#line 454 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global_ref {
   struct drm_global_reference ref ;
   struct ttm_mem_global *mem_glob ;
};
#line 463 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global {
   struct kobject kobj ;
   struct ttm_mem_global *mem_glob ;
   struct page *dummy_read_page ;
   struct ttm_mem_shrink shrink ;
   struct mutex device_list_mutex ;
   spinlock_t lru_lock ;
   struct list_head device_list ;
   struct list_head swap_lru ;
   atomic_t bo_count ;
};
#line 506 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_device {
   struct list_head device_list ;
   struct ttm_bo_global *glob ;
   struct ttm_bo_driver *driver ;
   rwlock_t vm_lock ;
   struct ttm_mem_type_manager man[8U] ;
   spinlock_t fence_lock ;
   struct rb_root addr_space_rb ;
   struct drm_mm addr_space_mm ;
   struct list_head ddestroy ;
   uint32_t val_seq ;
   struct address_space *dev_mapping ;
   struct delayed_work wq ;
   bool need_dma32 ;
};
#line 1009
enum ttm_ref_type {
    TTM_REF_USAGE = 0,
    TTM_REF_SYNCCPU_READ = 1,
    TTM_REF_SYNCCPU_WRITE = 2,
    TTM_REF_NUM = 3
} ;
#line 1016
enum ttm_object_type {
    ttm_fence_type = 0,
    ttm_buffer_type = 1,
    ttm_lock_type = 2,
    ttm_driver_type0 = 256,
    ttm_driver_type1 = 257,
    ttm_driver_type2 = 258,
    ttm_driver_type3 = 259,
    ttm_driver_type4 = 260,
    ttm_driver_type5 = 261
} ;
#line 1028
struct ttm_object_file;
#line 1029
struct ttm_object_device;
#line 1030 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_base_object {
   struct callback_head rhead ;
   struct drm_hash_item hash ;
   enum ttm_object_type object_type ;
   bool shareable ;
   struct ttm_object_file *tfile ;
   struct kref refcount ;
   void (*refcount_release)(struct ttm_base_object ** ) ;
   void (*ref_obj_release)(struct ttm_base_object * , enum ttm_ref_type  ) ;
};
#line 272 "include/drm/ttm/ttm_object.h"
struct ttm_lock {
   struct ttm_base_object base ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   int32_t rw ;
   uint32_t flags ;
   bool kill_takers ;
   int signal ;
   struct ttm_object_file *vt_holder ;
};
#line 246 "include/drm/ttm/ttm_lock.h"
struct ttm_validate_buffer {
   struct list_head head ;
   struct ttm_buffer_object *bo ;
   bool reserved ;
   bool removed ;
   int put_count ;
   void *old_sync_obj ;
};
#line 108 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_private;
#line 109
struct vmw_fence_manager;
#line 51 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj {
   struct kref kref ;
   u32 seqno ;
   struct vmw_fence_manager *fman ;
   struct list_head head ;
   uint32_t signaled ;
   uint32_t signal_mask ;
   struct list_head seq_passed_actions ;
   void (*destroy)(struct vmw_fence_obj * ) ;
   wait_queue_head_t queue ;
};
#line 115 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fpriv {
   struct drm_master *locked_master ;
   struct ttm_object_file *tfile ;
   struct list_head fence_events ;
};
#line 67 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_dma_buffer {
   struct ttm_buffer_object base ;
   struct list_head res_list ;
};
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_validate_buffer {
   struct ttm_validate_buffer base ;
   struct drm_hash_item hash ;
};
#line 86
struct vmw_res_func;
#line 87 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource {
   struct kref kref ;
   struct vmw_private *dev_priv ;
   int id ;
   bool avail ;
   unsigned long backup_size ;
   bool res_dirty ;
   bool backup_dirty ;
   struct vmw_dma_buffer *backup ;
   unsigned long backup_offset ;
   struct vmw_res_func  const  *func ;
   struct list_head lru_head ;
   struct list_head mob_head ;
   void (*res_free)(struct vmw_resource * ) ;
   void (*hw_destroy)(struct vmw_resource * ) ;
};
#line 104
enum vmw_res_type {
    vmw_res_context = 0,
    vmw_res_surface = 1,
    vmw_res_stream = 2,
    vmw_res_max = 3
} ;
#line 111 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_cursor_snooper {
   struct drm_crtc *crtc ;
   size_t age ;
   uint32_t *image ;
};
#line 118
struct vmw_surface_offset;
#line 119 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_surface {
   struct vmw_resource res ;
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   struct drm_vmw_size base_size ;
   struct drm_vmw_size *sizes ;
   uint32_t num_sizes ;
   bool scanout ;
   struct vmw_cursor_snooper snooper ;
   struct vmw_surface_offset *offsets ;
   SVGA3dTextureFilter autogen_filter ;
   uint32_t multisample_count ;
};
#line 136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker_queue {
   struct list_head head ;
   struct timespec lag ;
   struct timespec lag_time ;
   spinlock_t lock ;
};
#line 143 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fifo_state {
   unsigned long reserved_size ;
   __le32 *dynamic_buffer ;
   __le32 *static_buffer ;
   unsigned long static_buffer_size ;
   bool using_bounce_buffer ;
   uint32_t capabilities ;
   struct mutex fifo_mutex ;
   struct rw_semaphore rwsem ;
   struct vmw_marker_queue marker_queue ;
};
#line 155 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_relocation {
   SVGAGuestPtr *location ;
   uint32_t index ;
};
#line 160
struct vmw_resource_val_node;
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_res_cache_entry {
   bool valid ;
   uint32_t handle ;
   struct vmw_resource *res ;
   struct vmw_resource_val_node *node ;
};
#line 179 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_sw_context {
   struct drm_open_hash res_ht ;
   bool res_ht_initialized ;
   bool kernel ;
   struct ttm_object_file *tfile ;
   struct list_head validate_nodes ;
   struct vmw_relocation relocs[2048U] ;
   uint32_t cur_reloc ;
   struct vmw_validate_buffer val_bufs[2048U] ;
   uint32_t cur_val_buf ;
   uint32_t *cmd_bounce ;
   uint32_t cmd_bounce_size ;
   struct list_head resource_list ;
   uint32_t fence_flags ;
   struct ttm_buffer_object *cur_query_bo ;
   struct list_head res_relocations ;
   uint32_t *buf_start ;
   struct vmw_res_cache_entry res_cache[3U] ;
   struct vmw_resource *last_query_ctx ;
   bool needs_post_query_barrier ;
   struct vmw_resource *error_resource ;
};
#line 202
struct vmw_legacy_display;
#line 203
struct vmw_overlay;
#line 204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_master {
   struct ttm_lock lock ;
   struct mutex fb_surf_mutex ;
   struct list_head fb_surf ;
};
#line 211 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_vga_topology_state {
   uint32_t width ;
   uint32_t height ;
   uint32_t primary ;
   uint32_t pos_x ;
   uint32_t pos_y ;
};
#line 219
struct vmw_screen_object_display;
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_private {
   struct ttm_bo_device bdev ;
   struct ttm_bo_global_ref bo_global_ref ;
   struct drm_global_reference mem_global_ref ;
   struct vmw_fifo_state fifo ;
   struct drm_device *dev ;
   unsigned long vmw_chipset ;
   unsigned int io_start ;
   uint32_t vram_start ;
   uint32_t vram_size ;
   uint32_t mmio_start ;
   uint32_t mmio_size ;
   uint32_t fb_max_width ;
   uint32_t fb_max_height ;
   uint32_t initial_width ;
   uint32_t initial_height ;
   __le32 *mmio_virt ;
   int mmio_mtrr ;
   uint32_t capabilities ;
   uint32_t max_gmr_descriptors ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t memory_size ;
   bool has_gmr ;
   struct mutex hw_mutex ;
   struct vmw_vga_topology_state vga_save[16U] ;
   uint32_t vga_width ;
   uint32_t vga_height ;
   uint32_t vga_bpp ;
   uint32_t vga_bpl ;
   uint32_t vga_pitchlock ;
   uint32_t num_displays ;
   void *fb_info ;
   struct vmw_legacy_display *ldu_priv ;
   struct vmw_screen_object_display *sou_priv ;
   struct vmw_overlay *overlay_priv ;
   rwlock_t resource_lock ;
   struct idr res_idr[3U] ;
   struct mutex init_mutex ;
   struct ttm_object_device *tdev ;
   atomic_t marker_seq ;
   wait_queue_head_t fence_queue ;
   wait_queue_head_t fifo_queue ;
   int fence_queue_waiters ;
   int goal_queue_waiters ;
   atomic_t fifo_queue_waiters ;
   uint32_t last_read_seqno ;
   spinlock_t irq_lock ;
   struct vmw_fence_manager *fman ;
   uint32_t irq_mask ;
   uint32_t traces_state ;
   uint32_t enable_state ;
   uint32_t config_done_state ;
   struct vmw_sw_context ctx ;
   struct mutex cmdbuf_mutex ;
   bool stealth ;
   bool is_opened ;
   bool enable_fb ;
   struct vmw_master *active_master ;
   struct vmw_master fbdev_master ;
   struct notifier_block pm_nb ;
   bool suspended ;
   struct mutex release_mutex ;
   uint32_t num_3d_resources ;
   struct ttm_buffer_object *dummy_query_bo ;
   struct ttm_buffer_object *pinned_bo ;
   uint32_t query_cid ;
   uint32_t query_cid_valid ;
   bool dummy_query_bo_pinned ;
   struct list_head res_lru[3U] ;
   uint32_t used_memory_size ;
};
#line 413
struct vmw_user_resource_conv;
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource_relocation {
   struct list_head head ;
   struct vmw_resource  const  *res ;
   unsigned long offset ;
};
#line 151 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_resource_val_node {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct vmw_resource *res ;
   struct vmw_dma_buffer *new_backup ;
   unsigned long new_backup_offset ;
   bool first_usage ;
   bool no_buffer_needed ;
};
#line 539 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_cid_cmd {
   SVGA3dCmdHeader header ;
   __le32 cid ;
};
#line 553 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetRenderTarget body ;
};
#line 574 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceCopy body ;
};
#line 595 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceStretchBlt body ;
};
#line 616 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 637 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___3 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdPresent body ;
};
#line 846 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_begin_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBeginQuery q ;
};
#line 873 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdEndQuery q ;
};
#line 908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery q ;
};
#line 935 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_dma_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA dma ;
};
#line 968 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_draw_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDrawPrimitives body ;
};
#line 1063 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_cmd_291 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1063 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_294 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1086 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_set_shader_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetShader body ;
};
#line 1147 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int (*vmw_cmd_func)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * );
#line 1910 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___2;
#line 2022 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___13;
#line 233 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/special_insns.h"
struct exec_domain;
#line 26 "include/linux/personality.h"
struct map_segment;
#line 26 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 586 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 586 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
struct svga_guest_mem_descriptor {
   __le32 ppn ;
   __le32 num_pages ;
};
#line 1498 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMR2_45 {
   uint32 gmrId ;
   uint32 numPages ;
};
#line 1498 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMR2_45 SVGAFifoCmdDefineGMR2;
#line 1499
enum ldv_9066 {
    SVGA_REMAP_GMR2_PPN32 = 0,
    SVGA_REMAP_GMR2_VIA_GMR = 1,
    SVGA_REMAP_GMR2_PPN64 = 2,
    SVGA_REMAP_GMR2_SINGLE_PPN = 4
} ;
#line 1534 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef enum ldv_9066 SVGARemapGMR2Flags;
#line 1550 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdRemapGMR2_46 {
   uint32 gmrId ;
   SVGARemapGMR2Flags flags ;
   uint32 offsetPages ;
   uint32 numPages ;
};
#line 1550 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdRemapGMR2_46 SVGAFifoCmdRemapGMR2;
#line 66 "include/linux/miscdevice.h"
struct compat_timespec;
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_futex_115 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_nanosleep_116 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 67
struct pollfd;
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_poll_117 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 67 "include/linux/miscdevice.h"
union __anonunion_ldv_7701_114 {
   struct __anonstruct_futex_115 futex ;
   struct __anonstruct_nanosleep_116 nanosleep ;
   struct __anonstruct_poll_117 poll ;
};
#line 67 "include/linux/miscdevice.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_7701_114 ldv_7701 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 18 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 45 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 108 "include/linux/agp_backend.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 278 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
#line 392 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedPoint {
   int32 x ;
   int32 y ;
};
#line 397 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedPoint SVGASignedPoint;
#line 1028 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdUpdate {
   uint32 x ;
   uint32 y ;
   uint32 width ;
   uint32 height ;
};
#line 1066 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdUpdate SVGAFifoCmdUpdate;
#line 1117 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdDefineAlphaCursor {
   uint32 id ;
   uint32 hotspotX ;
   uint32 hotspotY ;
   uint32 width ;
   uint32 height ;
};
#line 1140 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdDefineAlphaCursor SVGAFifoCmdDefineAlphaCursor;
#line 1368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_214 {
   SVGASignedPoint srcOrigin ;
   SVGASignedRect destRect ;
   uint32 destScreenId ;
};
#line 1368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_214 SVGAFifoCmdBlitGMRFBToScreen;
#line 1416 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_215 {
   SVGASignedPoint destOrigin ;
   SVGASignedRect srcRect ;
   uint32 srcScreenId ;
};
#line 1416 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_215 SVGAFifoCmdBlitScreenToGMRFB;
#line 69 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum SVGA3dSurfaceFormat {
    SVGA3D_FORMAT_INVALID = 0,
    SVGA3D_X8R8G8B8 = 1,
    SVGA3D_A8R8G8B8 = 2,
    SVGA3D_R5G6B5 = 3,
    SVGA3D_X1R5G5B5 = 4,
    SVGA3D_A1R5G5B5 = 5,
    SVGA3D_A4R4G4B4 = 6,
    SVGA3D_Z_D32 = 7,
    SVGA3D_Z_D16 = 8,
    SVGA3D_Z_D24S8 = 9,
    SVGA3D_Z_D15S1 = 10,
    SVGA3D_LUMINANCE8 = 11,
    SVGA3D_LUMINANCE4_ALPHA4 = 12,
    SVGA3D_LUMINANCE16 = 13,
    SVGA3D_LUMINANCE8_ALPHA8 = 14,
    SVGA3D_DXT1 = 15,
    SVGA3D_DXT2 = 16,
    SVGA3D_DXT3 = 17,
    SVGA3D_DXT4 = 18,
    SVGA3D_DXT5 = 19,
    SVGA3D_BUMPU8V8 = 20,
    SVGA3D_BUMPL6V5U5 = 21,
    SVGA3D_BUMPX8L8V8U8 = 22,
    SVGA3D_BUMPL8V8U8 = 23,
    SVGA3D_ARGB_S10E5 = 24,
    SVGA3D_ARGB_S23E8 = 25,
    SVGA3D_A2R10G10B10 = 26,
    SVGA3D_V8U8 = 27,
    SVGA3D_Q8W8V8U8 = 28,
    SVGA3D_CxV8U8 = 29,
    SVGA3D_X8L8V8U8 = 30,
    SVGA3D_A2W10V10U10 = 31,
    SVGA3D_ALPHA8 = 32,
    SVGA3D_R_S10E5 = 33,
    SVGA3D_R_S23E8 = 34,
    SVGA3D_RG_S10E5 = 35,
    SVGA3D_RG_S23E8 = 36,
    SVGA3D_BUFFER = 37,
    SVGA3D_Z_D24X8 = 38,
    SVGA3D_V16U16 = 39,
    SVGA3D_G16R16 = 40,
    SVGA3D_A16B16G16R16 = 41,
    SVGA3D_UYVY = 42,
    SVGA3D_YUY2 = 43,
    SVGA3D_NV12 = 44,
    SVGA3D_AYUV = 45,
    SVGA3D_BC4_UNORM = 108,
    SVGA3D_BC5_UNORM = 111,
    SVGA3D_Z_DF16 = 118,
    SVGA3D_Z_DF24 = 119,
    SVGA3D_Z_D24S8_INT = 120,
    SVGA3D_FORMAT_MAX = 121
} ;
#line 1239 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dCopyBox {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
   uint32 srcx ;
   uint32 srcy ;
   uint32 srcz ;
};
#line 1251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dCopyBox SVGA3dCopyBox;
#line 406 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_rect {
   int32_t x ;
   int32_t y ;
   uint32_t w ;
   uint32_t h ;
};
#line 470 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_cursor_bypass_arg {
   uint32_t flags ;
   uint32_t crtc_id ;
   int32_t xpos ;
   int32_t ypos ;
   int32_t xhot ;
   int32_t yhot ;
};
#line 766 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_update_layout_arg {
   uint32_t num_outputs ;
   uint32_t pad64 ;
   uint64_t rects ;
};
#line 283 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bo_kmap_obj {
   void *virtual ;
   struct page *page ;
   int bo_kmap_type ;
   struct ttm_buffer_object *bo ;
};
#line 117 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer;
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer {
   struct drm_framebuffer base ;
   int (*pin)(struct vmw_framebuffer * ) ;
   int (*unpin)(struct vmw_framebuffer * ) ;
   bool dmabuf ;
   struct ttm_base_object *user_obj ;
   uint32_t user_handle ;
};
#line 71 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_display_unit {
   struct drm_crtc crtc ;
   struct drm_encoder encoder ;
   struct drm_connector connector ;
   struct vmw_surface *cursor_surface ;
   struct vmw_dma_buffer *cursor_dmabuf ;
   size_t cursor_age ;
   int cursor_x ;
   int cursor_y ;
   int hotspot_x ;
   int hotspot_y ;
   unsigned int unit ;
   unsigned int pref_width ;
   unsigned int pref_height ;
   bool pref_active ;
   struct drm_display_mode *pref_mode ;
   int gui_x ;
   int gui_y ;
   bool is_implicit ;
};
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_clip_rect {
   int x1 ;
   int x2 ;
   int y1 ;
   int y2 ;
};
#line 198 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_291___0 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 205 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_293 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 489 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_surface {
   struct vmw_framebuffer base ;
   struct vmw_surface *surface ;
   struct vmw_dma_buffer *buffer ;
   struct list_head head ;
   struct drm_master *master ;
};
#line 544 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_295 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 564 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_297 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 823 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_dmabuf {
   struct vmw_framebuffer base ;
   struct vmw_dma_buffer *buffer ;
};
#line 860 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_299 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 863 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_301 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 893 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_303 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 903 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_305 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 943 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_307 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 950 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_309 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 1308 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_311 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1328 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_313 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1442 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_315 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1446 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_317 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 1460 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_319 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1475 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_321 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 195 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 214 "include/linux/kobject.h"
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14086_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14086_134 ldv_14086 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 983 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_27185 {
    SVGA3D_QUERYSTATE_PENDING = 0,
    SVGA3D_QUERYSTATE_SUCCEEDED = 1,
    SVGA3D_QUERYSTATE_FAILED = 2,
    SVGA3D_QUERYSTATE_NEW = 3
} ;
#line 989 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_27185 SVGA3dQueryState;
#line 1697 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_38484_288 {
   uint32 result32 ;
};
#line 1697 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dQueryResult_287 {
   uint32 totalSize ;
   SVGA3dQueryState state ;
   union __anonunion_ldv_38484_288 ldv_38484 ;
};
#line 1697 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dQueryResult_287 SVGA3dQueryResult;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 322 "include/linux/kgdb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 176 "include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 192 "include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 279 "include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 335 "include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 348 "include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 357 "include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
#line 369 "include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 385 "include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 399
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 406
struct backlight_device;
#line 407
struct fb_info;
#line 408 "include/uapi/linux/fb.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 59 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 78 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
#line 145 "include/linux/backlight.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 58 "include/linux/fb.h"
struct fb_videomode;
#line 58 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 167 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 178 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
#line 207 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
#line 218 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
#line 306 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
#line 322 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 334 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 343 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 354 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 363 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
#line 382 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 501 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 502 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
#line 751 "include/linux/fb.h"
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct __anonstruct_dirty_290 {
   spinlock_t lock ;
   bool active ;
   unsigned int x1 ;
   unsigned int y1 ;
   unsigned int x2 ;
   unsigned int y2 ;
};
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fb_par {
   struct vmw_private *vmw_priv ;
   void *vmalloc ;
   struct vmw_dma_buffer *vmw_bo ;
   struct ttm_bo_kmap_obj map ;
   u32 pseudo_palette[17U] ;
   unsigned int depth ;
   unsigned int bpp ;
   unsigned int max_width ;
   unsigned int max_height ;
   void *bo_ptr ;
   unsigned int bo_size ;
   bool bo_iowrite ;
   struct __anonstruct_dirty_290 dirty ;
};
#line 323 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_cmd_292 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 350 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_294___0 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 1777 "include/drm/drmP.h"
struct drm_vmw_getparam_arg {
   uint64_t value ;
   uint32_t param ;
   uint32_t pad64 ;
};
#line 520 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_get_3d_cap_arg {
   uint64_t buffer ;
   uint32_t max_size ;
   uint32_t pad64 ;
};
#line 704 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_present_arg {
   uint32_t fb_id ;
   uint32_t sid ;
   int32_t dest_x ;
   int32_t dest_y ;
   uint64_t clips_ptr ;
   uint32_t num_clips ;
   uint32_t pad64 ;
};
#line 739 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_present_readback_arg {
   uint32_t fb_id ;
   uint32_t num_clips ;
   uint64_t clips_ptr ;
   uint64_t fence_rep ;
};
#line 605 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
typedef int ldv_func_ret_type___15;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 320 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_alloc_dmabuf_req {
   uint32_t size ;
   uint32_t pad64 ;
};
#line 351 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_dmabuf_rep {
   uint64_t map_handle ;
   uint32_t handle ;
   uint32_t cur_gmr_id ;
   uint32_t cur_gmr_offset ;
   uint32_t pad64 ;
};
#line 372 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_alloc_dmabuf_arg {
   struct drm_vmw_alloc_dmabuf_req req ;
   struct drm_vmw_dmabuf_rep rep ;
};
#line 386 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_unref_dmabuf_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 501 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_stream_arg {
   uint32_t stream_id ;
   uint32_t pad64 ;
};
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_user_resource_conv {
   enum ttm_object_type object_type ;
   struct vmw_resource *(*base_obj_to_res)(struct ttm_base_object * ) ;
   void (*res_free)(struct vmw_resource * ) ;
};
#line 43 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_res_func {
   enum vmw_res_type res_type ;
   bool needs_backup ;
   char const   *type_name ;
   struct ttm_placement *backup_placement ;
   bool may_evict ;
   int (*create)(struct vmw_resource * ) ;
   int (*destroy)(struct vmw_resource * ) ;
   int (*bind)(struct vmw_resource * , struct ttm_validate_buffer * ) ;
   int (*unbind)(struct vmw_resource * , bool  , struct ttm_validate_buffer * ) ;
};
#line 83 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_user_dma_buffer {
   struct ttm_base_object base ;
   struct vmw_dma_buffer dma ;
};
#line 148 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_stream {
   struct vmw_resource res ;
   uint32_t stream_id ;
};
#line 153 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_user_stream {
   struct ttm_base_object base ;
   struct vmw_stream stream ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 245 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct vmw_ttm_tt {
   struct ttm_tt ttm ;
   struct vmw_private *dev_priv ;
   int gmr_id ;
};
#line 45 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_reg.h"
struct svga_fifo_cmd_fence {
   __le32 fence ;
};
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 646 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_cmd_291___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 648 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_293___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_legacy_display {
   struct list_head active ;
   unsigned int num_active ;
   unsigned int last_num_active ;
   struct vmw_framebuffer *fb ;
};
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct vmw_legacy_display_unit {
   struct vmw_display_unit base ;
   struct list_head active ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 1210 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdEscape {
   uint32 nsid ;
   uint32 size ;
};
#line 1228 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdEscape SVGAFifoCmdEscape;
#line 432 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_control_stream_arg {
   uint32_t stream_id ;
   uint32_t enabled ;
   uint32_t flags ;
   uint32_t color_key ;
   uint32_t handle ;
   uint32_t offset ;
   int32_t format ;
   uint32_t size ;
   uint32_t width ;
   uint32_t height ;
   uint32_t pitch[3U] ;
   uint32_t pad64 ;
   struct drm_vmw_rect src ;
   struct drm_vmw_rect dst ;
};
#line 51 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_header_290 {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 51 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_items_291 {
   uint32 registerId ;
   uint32 value ;
};
#line 51 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoSetRegs {
   struct __anonstruct_header_290 header ;
   struct __anonstruct_items_291 items[1U] ;
};
#line 76 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoSetRegs SVGAEscapeVideoSetRegs;
#line 77 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoFlush {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 82 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoFlush SVGAEscapeVideoFlush;
#line 88 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_escape.h"
struct vmw_stream___0 {
   struct vmw_dma_buffer *buf ;
   bool claimed ;
   bool paused ;
   struct drm_vmw_control_stream_arg saved ;
};
#line 149 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_overlay {
   struct mutex mutex ;
   struct vmw_stream___0 stream[1U] ;
};
#line 166 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_header {
   uint32_t cmd ;
   SVGAFifoCmdEscape body ;
};
#line 171 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_video_flush {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoFlush flush ;
};
#line 216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_304 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_303 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_304 header ;
};
#line 220 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_items_306 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 230 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_310 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 230 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_309___0 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_310 header ;
};
#line 235 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_312 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 296 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_314 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_316 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker {
   struct list_head head ;
   uint32_t seqno ;
   struct timespec submitted ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 116 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 133 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmwgfx_gmrid_man {
   spinlock_t lock ;
   struct ida gmr_ida ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t used_gmr_pages ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 552 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_wait_arg {
   uint32_t handle ;
   int32_t cookie_valid ;
   uint64_t kernel_cookie ;
   uint64_t timeout_us ;
   int32_t lazy ;
   int32_t flags ;
   int32_t wait_options ;
   int32_t pad64 ;
};
#line 608 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_signaled_arg {
   uint32_t handle ;
   uint32_t flags ;
   int32_t signaled ;
   uint32_t passed_seqno ;
   uint32_t signaled_flags ;
   uint32_t pad64 ;
};
#line 637 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 659 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_event_fence {
   struct drm_event base ;
   uint64_t user_data ;
   uint32_t tv_sec ;
   uint32_t tv_usec ;
};
#line 682 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_event_arg {
   uint64_t fence_rep ;
   uint64_t user_data ;
   uint32_t handle ;
   uint32_t flags ;
};
#line 110 "include/drm/ttm/ttm_execbuf_util.h"
enum vmw_action_type {
    VMW_ACTION_EVENT = 0,
    VMW_ACTION_MAX = 1
} ;
#line 115 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_fence_action {
   struct list_head head ;
   enum vmw_action_type type ;
   void (*seq_passed)(struct vmw_fence_action * ) ;
   void (*cleanup)(struct vmw_fence_action * ) ;
};
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fence_manager {
   int num_fence_objects ;
   struct vmw_private *dev_priv ;
   spinlock_t lock ;
   struct list_head fence_list ;
   struct work_struct work ;
   u32 user_fence_size ;
   u32 fence_size ;
   u32 event_fence_action_size ;
   bool fifo_down ;
   struct list_head cleanup_list ;
   uint32_t pending_actions[1U] ;
   struct mutex goal_irq_mutex ;
   bool goal_irq_on ;
   bool seqno_valid ;
};
#line 152 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_user_fence {
   struct ttm_base_object base ;
   struct vmw_fence_obj fence ;
};
#line 158 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_action {
   struct vmw_fence_action action ;
   struct list_head fpriv_head ;
   struct drm_pending_event *event ;
   struct vmw_fence_obj *fence ;
   struct drm_device *dev ;
   uint32_t *tv_sec ;
   uint32_t *tv_usec ;
};
#line 1093 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_pending {
   struct drm_pending_event base ;
   struct drm_vmw_event_fence event ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 326 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 347 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestImage SVGAGuestImage;
#line 908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_size_208 {
   uint32 width ;
   uint32 height ;
};
#line 908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_root_209 {
   int32 x ;
   int32 y ;
};
#line 908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAScreenObject {
   uint32 structSize ;
   uint32 id ;
   uint32 flags ;
   struct __anonstruct_size_208 size ;
   struct __anonstruct_root_209 root ;
   SVGAGuestImage backingStore ;
   uint32 cloneCount ;
};
#line 987 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAScreenObject SVGAScreenObject;
#line 1276 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDestroyScreen_212 {
   uint32 screenId ;
};
#line 1276 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDestroyScreen_212 SVGAFifoCmdDestroyScreen;
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_screen_object_display {
   unsigned int num_implicit ;
   struct vmw_framebuffer *implicit_fb ;
};
#line 147 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct vmw_screen_object_unit {
   struct vmw_display_unit base ;
   unsigned long buffer_size ;
   struct vmw_dma_buffer *buffer ;
   bool defined ;
   bool active_implicit ;
};
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_294 {
   uint32_t cmdType ;
};
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_293 {
   struct __anonstruct_header_294 header ;
   SVGAScreenObject obj ;
};
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_298 {
   uint32_t cmdType ;
};
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_297___0 {
   struct __anonstruct_header_298 header ;
   SVGAScreenObject obj ;
};
#line 272 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_303 {
   uint32_t cmdType ;
};
#line 272 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_302 {
   struct __anonstruct_header_303 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_307 {
   uint32_t cmdType ;
};
#line 279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_306 {
   struct __anonstruct_header_307 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 1213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineContext_66 {
   uint32 cid ;
};
#line 1213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineContext_66 SVGA3dCmdDefineContext;
#line 1218 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroyContext_67 {
   uint32 cid ;
};
#line 1218 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroyContext_67 SVGA3dCmdDestroyContext;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 93 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_context_arg {
   int32_t cid ;
   uint32_t pad64 ;
};
#line 83 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_user_context {
   struct ttm_base_object base ;
   struct vmw_resource res ;
};
#line 180 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_cmd_291___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 184 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_293___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_cmd_295___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_297___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 41 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint8_t uint8;
#line 171 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum SVGA3dSurfaceFormat SVGA3dSurfaceFormat;
#line 1136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSize_61 {
   uint32 width ;
   uint32 height ;
   uint32 depth ;
};
#line 1136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSize_61 SVGA3dSize;
#line 1137
enum ldv_9184 {
    SVGA3D_SURFACE_CUBEMAP = 1,
    SVGA3D_SURFACE_HINT_STATIC = 2,
    SVGA3D_SURFACE_HINT_DYNAMIC = 4,
    SVGA3D_SURFACE_HINT_INDEXBUFFER = 8,
    SVGA3D_SURFACE_HINT_VERTEXBUFFER = 16,
    SVGA3D_SURFACE_HINT_TEXTURE = 32,
    SVGA3D_SURFACE_HINT_RENDERTARGET = 64,
    SVGA3D_SURFACE_HINT_DEPTHSTENCIL = 128,
    SVGA3D_SURFACE_HINT_WRITEONLY = 256,
    SVGA3D_SURFACE_MASKABLE_ANTIALIAS = 512,
    SVGA3D_SURFACE_AUTOGENMIPMAPS = 1024
} ;
#line 1150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9184 SVGA3dSurfaceFlags;
#line 1155 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceFace_62 {
   uint32 numMipLevels ;
};
#line 1155 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceFace_62 SVGA3dSurfaceFace;
#line 1178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineSurface_63 {
   uint32 sid ;
   SVGA3dSurfaceFlags surfaceFlags ;
   SVGA3dSurfaceFormat format ;
   SVGA3dSurfaceFace face[6U] ;
};
#line 1178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineSurface_63 SVGA3dCmdDefineSurface;
#line 1208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroySurface_65 {
   uint32 sid ;
};
#line 1208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroySurface_65 SVGA3dCmdDestroySurface;
#line 1360 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceDMAFlags_80 {
   unsigned char discard : 1 ;
   unsigned char unsynchronized : 1 ;
   unsigned int reserved : 30 ;
};
#line 1360 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceDMAFlags_80 SVGA3dSurfaceDMAFlags;
#line 1412 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 {
   uint32 suffixSize ;
   uint32 maximumOffset ;
   SVGA3dSurfaceDMAFlags flags ;
};
#line 1412 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 SVGA3dCmdSurfaceDMASuffix;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 115 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_surface_create_req {
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   uint64_t size_addr ;
   int32_t shareable ;
   int32_t scanout ;
};
#line 162 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_surface_arg {
   int32_t sid ;
   uint32_t pad64 ;
};
#line 195 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_surface_create_arg {
   struct drm_vmw_surface_arg rep ;
   struct drm_vmw_surface_create_req req ;
};
#line 209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_surface_reference_arg {
   struct drm_vmw_surface_create_req rep ;
   struct drm_vmw_surface_arg req ;
};
#line 83 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
enum svga3d_block_desc {
    SVGA3DBLOCKDESC_NONE = 0,
    SVGA3DBLOCKDESC_BLUE = 1,
    SVGA3DBLOCKDESC_U = 1,
    SVGA3DBLOCKDESC_UV_VIDEO = 128,
    SVGA3DBLOCKDESC_GREEN = 2,
    SVGA3DBLOCKDESC_V = 2,
    SVGA3DBLOCKDESC_STENCIL = 2,
    SVGA3DBLOCKDESC_RED = 4,
    SVGA3DBLOCKDESC_W = 4,
    SVGA3DBLOCKDESC_LUMINANCE = 4,
    SVGA3DBLOCKDESC_Y = 4,
    SVGA3DBLOCKDESC_DEPTH = 4,
    SVGA3DBLOCKDESC_ALPHA = 8,
    SVGA3DBLOCKDESC_Q = 8,
    SVGA3DBLOCKDESC_BUFFER = 16,
    SVGA3DBLOCKDESC_COMPRESSED = 32,
    SVGA3DBLOCKDESC_IEEE_FP = 64,
    SVGA3DBLOCKDESC_PLANAR_YUV = 256,
    SVGA3DBLOCKDESC_U_VIDEO = 512,
    SVGA3DBLOCKDESC_V_VIDEO = 1024,
    SVGA3DBLOCKDESC_EXP = 2048,
    SVGA3DBLOCKDESC_SRGB = 4096,
    SVGA3DBLOCKDESC_2PLANAR_YUV = 8192,
    SVGA3DBLOCKDESC_3PLANAR_YUV = 16384,
    SVGA3DBLOCKDESC_RG = 6,
    SVGA3DBLOCKDESC_RGB = 7,
    SVGA3DBLOCKDESC_RGB_SRGB = 4103,
    SVGA3DBLOCKDESC_RGBA = 15,
    SVGA3DBLOCKDESC_RGBA_SRGB = 4111,
    SVGA3DBLOCKDESC_UV = 3,
    SVGA3DBLOCKDESC_UVL = 7,
    SVGA3DBLOCKDESC_UVW = 7,
    SVGA3DBLOCKDESC_UVWA = 15,
    SVGA3DBLOCKDESC_UVWQ = 15,
    SVGA3DBLOCKDESC_LA = 12,
    SVGA3DBLOCKDESC_R_FP = 68,
    SVGA3DBLOCKDESC_RG_FP = 70,
    SVGA3DBLOCKDESC_RGB_FP = 71,
    SVGA3DBLOCKDESC_RGBA_FP = 79,
    SVGA3DBLOCKDESC_DS = 6,
    SVGA3DBLOCKDESC_YUV = 132,
    SVGA3DBLOCKDESC_AYUV = 1548,
    SVGA3DBLOCKDESC_RGBE = 2055,
    SVGA3DBLOCKDESC_COMPRESSED_SRGB = 4128,
    SVGA3DBLOCKDESC_NV12 = 8448,
    SVGA3DBLOCKDESC_YV12 = 16640
} ;
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40596_292 {
   uint8 blue ;
   uint8 u ;
   uint8 uv_video ;
   uint8 u_video ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40602_293 {
   uint8 green ;
   uint8 v ;
   uint8 stencil ;
   uint8 v_video ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40610_294 {
   uint8 red ;
   uint8 w ;
   uint8 luminance ;
   uint8 y ;
   uint8 depth ;
   uint8 data ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40615_295 {
   uint8 alpha ;
   uint8 q ;
   uint8 exp ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_ldv_40616_291 {
   union __anonunion_ldv_40596_292 ldv_40596 ;
   union __anonunion_ldv_40602_293 ldv_40602 ;
   union __anonunion_ldv_40610_294 ldv_40610 ;
   union __anonunion_ldv_40615_295 ldv_40615 ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_bit_depth_290 {
   u32 total ;
   struct __anonstruct_ldv_40616_291 ldv_40616 ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40625_298 {
   uint8 blue ;
   uint8 u ;
   uint8 uv_video ;
   uint8 u_video ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40631_299 {
   uint8 green ;
   uint8 v ;
   uint8 stencil ;
   uint8 v_video ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40639_300 {
   uint8 red ;
   uint8 w ;
   uint8 luminance ;
   uint8 y ;
   uint8 depth ;
   uint8 data ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40644_301 {
   uint8 alpha ;
   uint8 q ;
   uint8 exp ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_ldv_40645_297 {
   union __anonunion_ldv_40625_298 ldv_40625 ;
   union __anonunion_ldv_40631_299 ldv_40631 ;
   union __anonunion_ldv_40639_300 ldv_40639 ;
   union __anonunion_ldv_40644_301 ldv_40644 ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_bit_offset_296 {
   struct __anonstruct_ldv_40645_297 ldv_40645 ;
};
#line 132 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct svga3d_surface_desc {
   enum svga3d_block_desc block_desc ;
   struct drm_vmw_size block_size ;
   u32 bytes_per_block ;
   u32 pitch_bytes_per_block ;
   struct __anonstruct_bit_depth_290 bit_depth ;
   struct __anonstruct_bit_offset_296 bit_offset ;
};
#line 910 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
struct vmw_user_surface {
   struct ttm_base_object base ;
   struct vmw_surface srf ;
   uint32_t size ;
   uint32_t backup_handle ;
};
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_offset {
   uint32_t face ;
   uint32_t mip ;
   uint32_t bo_offset ;
};
#line 198 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_dma {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA body ;
   SVGA3dCopyBox cb ;
   SVGA3dCmdSurfaceDMASuffix suffix ;
};
#line 209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_define {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineSurface body ;
};
#line 217 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_destroy {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroySurface body ;
};
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 177
extern void dump_stack(void) ;
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 277
  first = list->next;
#line 278
  last = list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
#line 285
  return;
}
}
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
#line 321
  if (tmp == 0) {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
  } else {

  }
#line 325
  return;
}
}
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 93 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 168 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 173
extern void mutex_unlock(struct mutex * ) ;
#line 176
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 5 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 8
int ldv_mutex_lock_interruptible_15(struct mutex *ldv_func_arg1 ) ;
#line 11
extern void mutex_lock(struct mutex * ) ;
#line 14
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) ;
#line 40
int ldv_mutex_lock_interruptible_cmdbuf_mutex(struct mutex *lock ) ;
#line 43
void ldv_mutex_lock_cmdbuf_mutex(struct mutex *lock ) ;
#line 47
void ldv_mutex_unlock_cmdbuf_mutex(struct mutex *lock ) ;
#line 51
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) ;
#line 55
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) ;
#line 91
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 95
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 99
void ldv_mutex_lock_mutex(struct mutex *lock ) ;
#line 100
int ldv_mutex_trylock_mutex(struct mutex *lock ) ;
#line 103
void ldv_mutex_unlock_mutex(struct mutex *lock ) ;
#line 107
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) ;
#line 111
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) ;
#line 123
void ldv_mutex_lock_struct_mutex(struct mutex *lock ) ;
#line 127
void ldv_mutex_unlock_struct_mutex(struct mutex *lock ) ;
#line 131
void ldv_mutex_lock_update_lock(struct mutex *lock ) ;
#line 135
void ldv_mutex_unlock_update_lock(struct mutex *lock ) ;
#line 210 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 54 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 66
extern void vfree(void const   * ) ;
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 40 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 42
  tmp = atomic_read((atomic_t const   *)(& kref->refcount));
#line 42
  __ret_warn_on = tmp == 0;
#line 42
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 42
  if (tmp___0 != 0L) {
#line 42
    warn_slowpath_null("include/linux/kref.h", 42);
  } else {

  }
#line 42
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 43
  atomic_inc(& kref->refcount);
#line 44
  return;
}
}
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 49 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 52 "include/drm/drm_hashtab.h"
extern int drm_ht_create(struct drm_open_hash * , unsigned int  ) ;
#line 53
extern int drm_ht_insert_item(struct drm_open_hash * , struct drm_hash_item * ) ;
#line 57
extern int drm_ht_find_item(struct drm_open_hash * , unsigned long  , struct drm_hash_item ** ) ;
#line 61
extern int drm_ht_remove_item(struct drm_open_hash * , struct drm_hash_item * ) ;
#line 134 "include/drm/drmP.h"
extern int drm_err(char const   * , char const   *  , ...) ;
#line 312 "include/drm/ttm/ttm_bo_api.h"
__inline static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo ) 
{ 


  {
#line 314
  kref_get(& bo->kref);
#line 315
  return (bo);
}
}
#line 350
extern int ttm_bo_validate(struct ttm_buffer_object * , struct ttm_placement * , bool  ,
                           bool  ) ;
#line 362
extern void ttm_bo_unref(struct ttm_buffer_object ** ) ;
#line 218 "include/drm/ttm/ttm_object.h"
extern int ttm_ref_object_base_unref(struct ttm_object_file * , unsigned long  , enum ttm_ref_type  ) ;
#line 96 "include/drm/ttm/ttm_lock.h"
extern void ttm_read_unlock(struct ttm_lock * ) ;
#line 108
extern int ttm_read_lock(struct ttm_lock * , bool  ) ;
#line 66 "include/drm/ttm/ttm_execbuf_util.h"
extern void ttm_eu_backoff_reservation(struct list_head * ) ;
#line 93
extern int ttm_eu_reserve_buffers(struct list_head * ) ;
#line 107
extern void ttm_eu_fence_buffer_objects(struct list_head * , void * ) ;
#line 70 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) ;
#line 80
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) ;
#line 86
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) ;
#line 91
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) ;
#line 364 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_res_to_srf(struct vmw_resource *res ) 
{ 
  struct vmw_resource  const  *__mptr ;

  {
#line 366
  __mptr = (struct vmw_resource  const  *)res;
#line 366
  return ((struct vmw_surface *)__mptr);
}
}
#line 369 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_private *vmw_priv(struct drm_device *dev ) 
{ 


  {
#line 371
  return ((struct vmw_private *)dev->dev_private);
}
}
#line 374 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv ) 
{ 


  {
#line 376
  return ((struct vmw_fpriv *)file_priv->driver_priv);
}
}
#line 379 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_master *vmw_master(struct drm_master *master ) 
{ 


  {
#line 381
  return ((struct vmw_master *)master->driver_priv);
}
}
#line 418
struct vmw_user_resource_conv  const  *user_surface_converter ;
#line 419
struct vmw_user_resource_conv  const  *user_context_converter ;
#line 422
void vmw_resource_unreference(struct vmw_resource **p_res ) ;
#line 423
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) ;
#line 424
int vmw_resource_validate(struct vmw_resource *res ) ;
#line 425
int vmw_resource_reserve(struct vmw_resource *res , bool no_backup ) ;
#line 440
int vmw_user_resource_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                    uint32_t handle , struct vmw_user_resource_conv  const  *converter ,
                                    struct vmw_resource **p_res ) ;
#line 473
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) ;
#line 483
void vmw_resource_unreserve(struct vmw_resource *res , struct vmw_dma_buffer *new_backup ,
                            unsigned long new_backup_offset ) ;
#line 513
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) ;
#line 540
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 541
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 542
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) ;
#line 547
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) ;
#line 562
struct ttm_placement vmw_vram_placement ;
#line 565
struct ttm_placement vmw_vram_gmr_placement ;
#line 577
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 579
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) ;
#line 588
void __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , struct vmw_fence_obj *fence ) ;
#line 590
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv ) ;
#line 592
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) ;
#line 596
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) ;
#line 617
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) ;
#line 623
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) ;
#line 641
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) ;
#line 663
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) ;
#line 664
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) ;
#line 745 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf ) 
{ 
  struct vmw_dma_buffer *tmp_buf ;
  struct ttm_buffer_object *bo ;

  {
#line 747
  tmp_buf = *buf;
#line 749
  *buf = 0;
#line 750
  if ((unsigned long )tmp_buf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 751
    bo = & tmp_buf->base;
#line 753
    ttm_bo_unref(& bo);
  } else {

  }
#line 755
  return;
}
}
#line 183 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_list_unreserve(struct list_head *list , bool backoff ) 
{ 
  struct vmw_resource_val_node *val ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  struct vmw_dma_buffer *new_backup ;
  struct list_head  const  *__mptr___0 ;

  {
#line 188
  __mptr = (struct list_head  const  *)list->next;
#line 188
  val = (struct vmw_resource_val_node *)__mptr;
#line 188
  goto ldv_40535;
  ldv_40534: 
#line 189
  res = val->res;
#line 190
  new_backup = (int )backoff ? 0 : val->new_backup;
#line 193
  vmw_resource_unreserve(res, new_backup, val->new_backup_offset);
#line 195
  vmw_dmabuf_unreference(& val->new_backup);
#line 188
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 188
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40535: ;
#line 188
  if ((unsigned long )(& val->head) != (unsigned long )list) {
#line 189
    goto ldv_40534;
  } else {

  }

#line 193
  return;
}
}
#line 209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resource_val_add(struct vmw_sw_context *sw_context , struct vmw_resource *res ,
                                struct vmw_resource_val_node **p_node ) 
{ 
  struct vmw_resource_val_node *node ;
  struct drm_hash_item *hash ;
  int ret ;
  struct drm_hash_item  const  *__mptr ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 217
  tmp___0 = drm_ht_find_item(& sw_context->res_ht, (unsigned long )res, & hash);
#line 217
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 1L);
#line 217
  if (tmp___1 != 0L) {
#line 219
    __mptr = (struct drm_hash_item  const  *)hash;
#line 219
    node = (struct vmw_resource_val_node *)__mptr + 0xfffffffffffffff0UL;
#line 220
    node->first_usage = 0;
#line 221
    tmp = ldv__builtin_expect((unsigned long )p_node != (unsigned long )((struct vmw_resource_val_node **)0),
                           0L);
#line 221
    if (tmp != 0L) {
#line 222
      *p_node = node;
    } else {

    }
#line 223
    return (0);
  } else {

  }
#line 226
  tmp___2 = kzalloc(72UL, 208U);
#line 226
  node = (struct vmw_resource_val_node *)tmp___2;
#line 227
  tmp___3 = ldv__builtin_expect((unsigned long )node == (unsigned long )((struct vmw_resource_val_node *)0),
                             0L);
#line 227
  if (tmp___3 != 0L) {
#line 228
    drm_err("vmw_resource_val_add", "Failed to allocate a resource validation entry.\n");
#line 230
    return (-12);
  } else {

  }
#line 233
  node->hash.key = (unsigned long )res;
#line 234
  ret = drm_ht_insert_item(& sw_context->res_ht, & node->hash);
#line 235
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 235
  if (tmp___4 != 0L) {
#line 236
    drm_err("vmw_resource_val_add", "Failed to initialize a resource validation entry.\n");
#line 238
    kfree((void const   *)node);
#line 239
    return (ret);
  } else {

  }
#line 241
  list_add_tail(& node->head, & sw_context->resource_list);
#line 242
  node->res = vmw_resource_reference(res);
#line 243
  node->first_usage = 1;
#line 245
  tmp___5 = ldv__builtin_expect((unsigned long )p_node != (unsigned long )((struct vmw_resource_val_node **)0),
                             0L);
#line 245
  if (tmp___5 != 0L) {
#line 246
    *p_node = node;
  } else {

  }
#line 248
  return (0);
}
}
#line 259 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resource_relocation_add(struct list_head *list , struct vmw_resource  const  *res ,
                                       unsigned long offset ) 
{ 
  struct vmw_resource_relocation *rel ;
  void *tmp ;
  long tmp___0 ;

  {
#line 265
  tmp = kmalloc(32UL, 208U);
#line 265
  rel = (struct vmw_resource_relocation *)tmp;
#line 266
  tmp___0 = ldv__builtin_expect((unsigned long )rel == (unsigned long )((struct vmw_resource_relocation *)0),
                             0L);
#line 266
  if (tmp___0 != 0L) {
#line 267
    drm_err("vmw_resource_relocation_add", "Failed to allocate a resource relocation.\n");
#line 268
    return (-12);
  } else {

  }
#line 271
  rel->res = res;
#line 272
  rel->offset = offset;
#line 273
  list_add_tail(& rel->head, list);
#line 275
  return (0);
}
}
#line 283 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_relocations_free(struct list_head *list ) 
{ 
  struct vmw_resource_relocation *rel ;
  struct vmw_resource_relocation *n ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 287
  __mptr = (struct list_head  const  *)list->next;
#line 287
  rel = (struct vmw_resource_relocation *)__mptr;
#line 287
  __mptr___0 = (struct list_head  const  *)rel->head.next;
#line 287
  n = (struct vmw_resource_relocation *)__mptr___0;
#line 287
  goto ldv_40567;
  ldv_40566: 
#line 288
  list_del(& rel->head);
#line 289
  kfree((void const   *)rel);
#line 287
  rel = n;
#line 287
  __mptr___1 = (struct list_head  const  *)n->head.next;
#line 287
  n = (struct vmw_resource_relocation *)__mptr___1;
  ldv_40567: ;
#line 287
  if ((unsigned long )(& rel->head) != (unsigned long )list) {
#line 288
    goto ldv_40566;
  } else {

  }

#line 292
  return;
}
}
#line 302 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_relocations_apply(uint32_t *cb , struct list_head *list ) 
{ 
  struct vmw_resource_relocation *rel ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 307
  __mptr = (struct list_head  const  *)list->next;
#line 307
  rel = (struct vmw_resource_relocation *)__mptr;
#line 307
  goto ldv_40579;
  ldv_40578: 
#line 308
  *(cb + rel->offset) = (uint32_t )(rel->res)->id;
#line 307
  __mptr___0 = (struct list_head  const  *)rel->head.next;
#line 307
  rel = (struct vmw_resource_relocation *)__mptr___0;
  ldv_40579: ;
#line 307
  if ((unsigned long )(& rel->head) != (unsigned long )list) {
#line 308
    goto ldv_40578;
  } else {

  }

#line 312
  return;
}
}
#line 311 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_invalid(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                           SVGA3dCmdHeader *header ) 
{ 
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 315
  tmp___2 = capable(21);
#line 315
  if ((int )tmp___2 != 0) {
#line 315
    tmp___0 = capable(21);
#line 315
    tmp___1 = (int )tmp___0;
  } else {
#line 315
    tmp___1 = -22;
  }
#line 315
  return (tmp___1);
}
}
#line 318 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_ok(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                      SVGA3dCmdHeader *header ) 
{ 


  {
#line 322
  return (0);
}
}
#line 336 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_bo_to_validate_list(struct vmw_sw_context *sw_context , struct ttm_buffer_object *bo ,
                                   uint32_t *p_val_node ) 
{ 
  uint32_t val_node ;
  struct vmw_validate_buffer *vval_buf ;
  struct ttm_validate_buffer *val_buf ;
  struct drm_hash_item *hash ;
  int ret ;
  struct drm_hash_item  const  *__mptr ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 346
  tmp___1 = drm_ht_find_item(& sw_context->res_ht, (unsigned long )bo, & hash);
#line 346
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 1L);
#line 346
  if (tmp___2 != 0L) {
#line 348
    __mptr = (struct drm_hash_item  const  *)hash;
#line 348
    vval_buf = (struct vmw_validate_buffer *)__mptr + 0xffffffffffffffd8UL;
#line 350
    val_buf = & vval_buf->base;
#line 351
    val_node = (uint32_t )(((long )vval_buf - (long )(& sw_context->val_bufs)) / 64L);
  } else {
#line 353
    val_node = sw_context->cur_val_buf;
#line 354
    tmp = ldv__builtin_expect(val_node > 2047U, 0L);
#line 354
    if (tmp != 0L) {
#line 355
      drm_err("vmw_bo_to_validate_list", "Max number of DMA buffers per submission exceeded.\n");
#line 357
      return (-22);
    } else {

    }
#line 359
    vval_buf = (struct vmw_validate_buffer *)(& sw_context->val_bufs) + (unsigned long )val_node;
#line 360
    vval_buf->hash.key = (unsigned long )bo;
#line 361
    ret = drm_ht_insert_item(& sw_context->res_ht, & vval_buf->hash);
#line 362
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 362
    if (tmp___0 != 0L) {
#line 363
      drm_err("vmw_bo_to_validate_list", "Failed to initialize a buffer validation entry.\n");
#line 365
      return (ret);
    } else {

    }
#line 367
    sw_context->cur_val_buf = sw_context->cur_val_buf + 1U;
#line 368
    val_buf = & vval_buf->base;
#line 369
    val_buf->bo = ttm_bo_reference(bo);
#line 370
    val_buf->reserved = 0;
#line 371
    list_add_tail(& val_buf->head, & sw_context->validate_nodes);
  }
#line 374
  sw_context->fence_flags = sw_context->fence_flags | 1U;
#line 376
  if ((unsigned long )p_val_node != (unsigned long )((uint32_t *)0)) {
#line 377
    *p_val_node = val_node;
  } else {

  }
#line 379
  return (0);
}
}
#line 392 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resources_reserve(struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_resource_val_node *val ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  long tmp ;
  struct ttm_buffer_object *bo ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 397
  __mptr = (struct list_head  const  *)sw_context->resource_list.next;
#line 397
  val = (struct vmw_resource_val_node *)__mptr;
#line 397
  goto ldv_40616;
  ldv_40615: 
#line 398
  res = val->res;
#line 400
  ret = vmw_resource_reserve(res, (int )val->no_buffer_needed);
#line 401
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 401
  if (tmp != 0L) {
#line 402
    return (ret);
  } else {

  }
#line 404
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 405
    bo = & (res->backup)->base;
#line 407
    ret = vmw_bo_to_validate_list(sw_context, bo, 0);
#line 410
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 410
    if (tmp___0 != 0L) {
#line 411
      return (ret);
    } else {

    }
  } else {

  }
#line 397
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 397
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40616: ;
#line 397
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 398
    goto ldv_40615;
  } else {

  }

#line 414
  return (0);
}
}
#line 426 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resources_validate(struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_resource_val_node *val ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 431
  __mptr = (struct list_head  const  *)sw_context->resource_list.next;
#line 431
  val = (struct vmw_resource_val_node *)__mptr;
#line 431
  goto ldv_40630;
  ldv_40629: 
#line 432
  res = val->res;
#line 434
  ret = vmw_resource_validate(res);
#line 435
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 435
  if (tmp != 0L) {
#line 436
    if (ret != -512) {
#line 437
      drm_err("vmw_resources_validate", "Failed to validate resource.\n");
    } else {

    }
#line 438
    return (ret);
  } else {

  }
#line 431
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 431
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40630: ;
#line 431
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 432
    goto ldv_40629;
  } else {

  }

#line 441
  return (0);
}
}
#line 455 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_res_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             enum vmw_res_type res_type , struct vmw_user_resource_conv  const  *converter ,
                             uint32_t *id , struct vmw_resource_val_node **p_val ) 
{ 
  struct vmw_res_cache_entry *rcache ;
  struct vmw_resource *res ;
  struct vmw_resource_val_node *node ;
  int ret ;
  struct vmw_resource  const  *res___0 ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 462
  rcache = (struct vmw_res_cache_entry *)(& sw_context->res_cache) + (unsigned long )res_type;
#line 468
  if (*id == 4294967295U) {
#line 469
    return (0);
  } else {

  }
#line 476
  tmp___0 = ldv__builtin_expect((long )rcache->valid, 1L);
#line 476
  if (tmp___0 != 0L) {
#line 476
    tmp___1 = ldv__builtin_expect(*id == rcache->handle, 1L);
#line 476
    if (tmp___1 != 0L) {
#line 477
      res___0 = (struct vmw_resource  const  *)rcache->res;
#line 479
      (rcache->node)->first_usage = 0;
#line 480
      if ((unsigned long )p_val != (unsigned long )((struct vmw_resource_val_node **)0)) {
#line 481
        *p_val = rcache->node;
      } else {

      }
#line 483
      tmp = vmw_resource_relocation_add(& sw_context->res_relocations, res___0, (unsigned long )(((long )id - (long )sw_context->buf_start) / 4L));
#line 483
      return (tmp);
    } else {

    }
  } else {

  }
#line 488
  ret = vmw_user_resource_lookup_handle(dev_priv, sw_context->tfile, *id, converter,
                                        & res);
#line 493
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 493
  if (tmp___2 != 0L) {
#line 494
    drm_err("vmw_cmd_res_check", "Could not find or use resource 0x%08x.\n", *id);
#line 496
    dump_stack();
#line 497
    return (ret);
  } else {

  }
#line 500
  rcache->valid = 1;
#line 501
  rcache->res = res;
#line 502
  rcache->handle = *id;
#line 504
  ret = vmw_resource_relocation_add(& sw_context->res_relocations, (struct vmw_resource  const  *)res,
                                    (unsigned long )(((long )id - (long )sw_context->buf_start) / 4L));
#line 507
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 507
  if (tmp___3 != 0L) {
#line 508
    goto out_no_reloc;
  } else {

  }
#line 510
  ret = vmw_resource_val_add(sw_context, res, & node);
#line 511
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 511
  if (tmp___4 != 0L) {
#line 512
    goto out_no_reloc;
  } else {

  }
#line 514
  rcache->node = node;
#line 515
  if ((unsigned long )p_val != (unsigned long )((struct vmw_resource_val_node **)0)) {
#line 516
    *p_val = node;
  } else {

  }
#line 517
  vmw_resource_unreference(& res);
#line 518
  return (0);
  out_no_reloc: 
#line 521
  tmp___5 = ldv__builtin_expect((unsigned long )sw_context->error_resource != (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 521
  if (tmp___5 != 0L) {
#line 521
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (521), "i" (12UL));
    ldv_40647: ;
#line 521
    goto ldv_40647;
  } else {

  }
#line 522
  sw_context->error_resource = res;
#line 524
  return (ret);
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_cid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  struct vmw_cid_cmd *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  int tmp ;

  {
#line 546
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 546
  cmd = (struct vmw_cid_cmd *)__mptr;
#line 547
  tmp = vmw_cmd_res_check(dev_priv, sw_context, 0, user_context_converter, & cmd->cid,
                          0);
#line 547
  return (tmp);
}
}
#line 551 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                           SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd *cmd ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;

  {
#line 561
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 562
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 562
  if (tmp != 0L) {
#line 563
    return (ret);
  } else {

  }
#line 565
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 565
  cmd = (struct vmw_sid_cmd *)__mptr;
#line 566
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.target.sid,
                          0);
#line 569
  return (ret);
}
}
#line 572 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 582
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 582
  cmd = (struct vmw_sid_cmd___0 *)__mptr;
#line 583
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.src.sid,
                          0);
#line 586
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 586
  if (tmp != 0L) {
#line 587
    return (ret);
  } else {

  }
#line 588
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.dest.sid,
                              0);
#line 588
  return (tmp___0);
}
}
#line 593 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                     SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___1 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 603
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 603
  cmd = (struct vmw_sid_cmd___1 *)__mptr;
#line 604
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.src.sid,
                          0);
#line 607
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 607
  if (tmp != 0L) {
#line 608
    return (ret);
  } else {

  }
#line 609
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.dest.sid,
                              0);
#line 609
  return (tmp___0);
}
}
#line 614 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                         SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___2 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 623
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 623
  cmd = (struct vmw_sid_cmd___2 *)__mptr;
#line 625
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 625
  if (tmp != 0L) {
#line 626
    drm_err("vmw_cmd_blt_surf_screen_check", "Kernel only SVGA3d command: %u.\n",
            cmd->header.id);
#line 627
    return (-1);
  } else {

  }
#line 630
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.srcImage.sid,
                              0);
#line 630
  return (tmp___0);
}
}
#line 635 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_present_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                 SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___3 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 645
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 645
  cmd = (struct vmw_sid_cmd___3 *)__mptr;
#line 647
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 647
  if (tmp != 0L) {
#line 648
    drm_err("vmw_cmd_present_check", "Kernel only SVGA3d command: %u.\n", cmd->header.id);
#line 649
    return (-1);
  } else {

  }
#line 652
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.sid,
                              0);
#line 652
  return (tmp___0);
}
}
#line 670 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv , struct ttm_buffer_object *new_query_bo ,
                                       struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_res_cache_entry *ctx_entry ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 674
  ctx_entry = (struct vmw_res_cache_entry *)(& sw_context->res_cache);
#line 678
  tmp = ldv__builtin_expect((long )(! ctx_entry->valid), 0L);
#line 678
  if (tmp != 0L) {
#line 678
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (678), "i" (12UL));
    ldv_40726: ;
#line 678
    goto ldv_40726;
  } else {

  }
#line 679
  sw_context->last_query_ctx = ctx_entry->res;
#line 681
  tmp___4 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )new_query_bo,
                             0L);
#line 681
  if (tmp___4 != 0L) {
#line 683
    tmp___0 = ldv__builtin_expect(new_query_bo->num_pages > 4UL, 0L);
#line 683
    if (tmp___0 != 0L) {
#line 684
      drm_err("vmw_query_bo_switch_prepare", "Query buffer too large.\n");
#line 685
      return (-22);
    } else {

    }
#line 688
    tmp___2 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )((struct ttm_buffer_object *)0),
                               0L);
#line 688
    if (tmp___2 != 0L) {
#line 689
      sw_context->needs_post_query_barrier = 1;
#line 690
      ret = vmw_bo_to_validate_list(sw_context, sw_context->cur_query_bo, 0);
#line 693
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 693
      if (tmp___1 != 0L) {
#line 694
        return (ret);
      } else {

      }
    } else {

    }
#line 696
    sw_context->cur_query_bo = new_query_bo;
#line 698
    ret = vmw_bo_to_validate_list(sw_context, dev_priv->dummy_query_bo, 0);
#line 701
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 701
    if (tmp___3 != 0L) {
#line 702
      return (ret);
    } else {

    }
  } else {

  }
#line 706
  return (0);
}
}
#line 727 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_query_bo_switch_commit(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_res_cache_entry *ctx_entry ;
  struct vmw_resource *ctx ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 735
  if ((int )sw_context->needs_post_query_barrier) {
#line 736
    ctx_entry = (struct vmw_res_cache_entry *)(& sw_context->res_cache);
#line 741
    tmp = ldv__builtin_expect((long )(! ctx_entry->valid), 0L);
#line 741
    if (tmp != 0L) {
#line 741
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (741), "i" (12UL));
      ldv_40735: ;
#line 741
      goto ldv_40735;
    } else {

    }
#line 742
    ctx = ctx_entry->res;
#line 744
    ret = vmw_fifo_emit_dummy_query(dev_priv, (uint32_t )ctx->id);
#line 746
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 746
    if (tmp___0 != 0L) {
#line 747
      drm_err("vmw_query_bo_switch_commit", "Out of fifo space for dummy query.\n");
    } else {

    }
  } else {

  }
#line 750
  if ((unsigned long )dev_priv->pinned_bo != (unsigned long )sw_context->cur_query_bo) {
#line 751
    if ((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 752
      vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 753
      ttm_bo_unref(& dev_priv->pinned_bo);
    } else {

    }
#line 756
    if (! sw_context->needs_post_query_barrier) {
#line 757
      vmw_bo_pin(sw_context->cur_query_bo, 1);
#line 765
      vmw_bo_pin(dev_priv->dummy_query_bo, 1);
#line 766
      dev_priv->dummy_query_bo_pinned = 1;
#line 768
      tmp___1 = ldv__builtin_expect((unsigned long )sw_context->last_query_ctx == (unsigned long )((struct vmw_resource *)0),
                                 0L);
#line 768
      if (tmp___1 != 0L) {
#line 768
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                             "i" (768), "i" (12UL));
        ldv_40737: ;
#line 768
        goto ldv_40737;
      } else {

      }
#line 769
      dev_priv->query_cid = (uint32_t )(sw_context->last_query_ctx)->id;
#line 770
      dev_priv->query_cid_valid = 1U;
#line 771
      dev_priv->pinned_bo = ttm_bo_reference(sw_context->cur_query_bo);
    } else {

    }
  } else {

  }
#line 775
  return;
}
}
#line 796 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_translate_guest_ptr(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                   SVGAGuestPtr *ptr , struct vmw_dma_buffer **vmw_bo_p ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  uint32_t handle ;
  struct vmw_relocation *reloc ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 801
  vmw_bo = 0;
#line 803
  handle = ptr->gmrId;
#line 807
  ret = vmw_user_dmabuf_lookup(sw_context->tfile, handle, & vmw_bo);
#line 808
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 808
  if (tmp != 0L) {
#line 809
    drm_err("vmw_translate_guest_ptr", "Could not find or use GMR region.\n");
#line 810
    return (-22);
  } else {

  }
#line 812
  bo = & vmw_bo->base;
#line 814
  tmp___0 = ldv__builtin_expect(sw_context->cur_reloc > 2047U, 0L);
#line 814
  if (tmp___0 != 0L) {
#line 815
    drm_err("vmw_translate_guest_ptr", "Max number relocations per submission exceeded\n");
#line 817
    ret = -22;
#line 818
    goto out_no_reloc;
  } else {

  }
#line 821
  tmp___1 = sw_context->cur_reloc;
#line 821
  sw_context->cur_reloc = sw_context->cur_reloc + 1U;
#line 821
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )tmp___1;
#line 822
  reloc->location = ptr;
#line 824
  ret = vmw_bo_to_validate_list(sw_context, bo, & reloc->index);
#line 825
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 825
  if (tmp___2 != 0L) {
#line 826
    goto out_no_reloc;
  } else {

  }
#line 828
  *vmw_bo_p = vmw_bo;
#line 829
  return (0);
  out_no_reloc: 
#line 832
  vmw_dmabuf_unreference(& vmw_bo);
#line 833
  vmw_bo_p = 0;
#line 834
  return (ret);
}
}
#line 844 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_begin_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                               SVGA3dCmdHeader *header ) 
{ 
  struct vmw_begin_query_cmd *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  int tmp ;

  {
#line 853
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 853
  cmd = (struct vmw_begin_query_cmd *)__mptr;
#line 856
  tmp = vmw_cmd_res_check(dev_priv, sw_context, 0, user_context_converter, & cmd->q.cid,
                          0);
#line 856
  return (tmp);
}
}
#line 868 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_end_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 879
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 879
  cmd = (struct vmw_query_cmd *)__mptr;
#line 880
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 881
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 881
  if (tmp != 0L) {
#line 882
    return (ret);
  } else {

  }
#line 884
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 887
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 887
  if (tmp___0 != 0L) {
#line 888
    return (ret);
  } else {

  }
#line 890
  ret = vmw_query_bo_switch_prepare(dev_priv, & vmw_bo->base, sw_context);
#line 892
  vmw_dmabuf_unreference(& vmw_bo);
#line 893
  return (ret);
}
}
#line 903 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_wait_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 914
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 914
  cmd = (struct vmw_query_cmd___0 *)__mptr;
#line 915
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 916
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 916
  if (tmp != 0L) {
#line 917
    return (ret);
  } else {

  }
#line 919
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 922
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 922
  if (tmp___0 != 0L) {
#line 923
    return (ret);
  } else {

  }
#line 925
  vmw_dmabuf_unreference(& vmw_bo);
#line 926
  return (0);
}
}
#line 929 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_dma(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                       SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_surface *srf ;
  struct vmw_dma_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 933
  vmw_bo = 0;
#line 934
  srf = 0;
#line 941
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 941
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 942
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->dma.guest.ptr, & vmw_bo);
#line 945
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 945
  if (tmp != 0L) {
#line 946
    return (ret);
  } else {

  }
#line 948
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->dma.host.sid,
                          0);
#line 951
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 951
  if (tmp___1 != 0L) {
#line 952
    tmp___0 = ldv__builtin_expect(ret != -512, 0L);
#line 952
    if (tmp___0 != 0L) {
#line 953
      drm_err("vmw_cmd_dma", "could not find surface for DMA.\n");
    } else {

    }
#line 954
    goto out_no_surface;
  } else {

  }
#line 957
  srf = vmw_res_to_srf(sw_context->res_cache[1].res);
#line 959
  vmw_kms_cursor_snoop(srf, sw_context->tfile, & vmw_bo->base, header);
  out_no_surface: 
#line 962
  vmw_dmabuf_unreference(& vmw_bo);
#line 963
  return (ret);
}
}
#line 966 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_draw(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                        SVGA3dCmdHeader *header ) 
{ 
  struct vmw_draw_cmd *cmd ;
  SVGA3dVertexDecl *decl ;
  SVGA3dPrimitiveRange *range ;
  uint32_t i ;
  uint32_t maxnum ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 974
  decl = (SVGA3dVertexDecl *)((unsigned long )header + 20UL);
#line 981
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 982
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 982
  if (tmp != 0L) {
#line 983
    return (ret);
  } else {

  }
#line 985
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 985
  cmd = (struct vmw_draw_cmd *)__mptr;
#line 986
  maxnum = (uint32_t )(((unsigned long )header->size - 12UL) / 36UL);
#line 988
  tmp___0 = ldv__builtin_expect(cmd->body.numVertexDecls > maxnum, 0L);
#line 988
  if (tmp___0 != 0L) {
#line 989
    drm_err("vmw_cmd_draw", "Illegal number of vertex declarations.\n");
#line 990
    return (-22);
  } else {

  }
#line 993
  i = 0U;
#line 993
  goto ldv_40822;
  ldv_40821: 
#line 994
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & decl->array.surfaceId,
                          0);
#line 997
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 997
  if (tmp___1 != 0L) {
#line 998
    return (ret);
  } else {

  }
#line 993
  i = i + 1U;
#line 993
  decl = decl + 1;
  ldv_40822: ;
#line 993
  if (cmd->body.numVertexDecls > i) {
#line 994
    goto ldv_40821;
  } else {

  }
#line 1001
  maxnum = (uint32_t )((((unsigned long )header->size - (unsigned long )cmd->body.numVertexDecls * 36UL) - 12UL) / 28UL);
#line 1003
  tmp___2 = ldv__builtin_expect(cmd->body.numRanges > maxnum, 0L);
#line 1003
  if (tmp___2 != 0L) {
#line 1004
    drm_err("vmw_cmd_draw", "Illegal number of index ranges.\n");
#line 1005
    return (-22);
  } else {

  }
#line 1008
  range = (SVGA3dPrimitiveRange *)decl;
#line 1009
  i = 0U;
#line 1009
  goto ldv_40825;
  ldv_40824: 
#line 1010
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & range->indexArray.surfaceId,
                          0);
#line 1013
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1013
  if (tmp___3 != 0L) {
#line 1014
    return (ret);
  } else {

  }
#line 1009
  i = i + 1U;
#line 1009
  range = range + 1;
  ldv_40825: ;
#line 1009
  if (cmd->body.numRanges > i) {
#line 1010
    goto ldv_40824;
  } else {

  }

#line 1016
  return (0);
}
}
#line 1020 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_tex_state(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  SVGA3dTextureState *last_state ;
  SVGA3dTextureState *cur_state ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1029
  last_state = (SVGA3dTextureState *)(((unsigned long )header->size + (unsigned long )header) + 8UL);
#line 1031
  cur_state = (SVGA3dTextureState *)((unsigned long )header + 12UL);
#line 1035
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 1036
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1036
  if (tmp != 0L) {
#line 1037
    return (ret);
  } else {

  }
#line 1039
  goto ldv_40840;
  ldv_40839: 
#line 1040
  tmp___0 = ldv__builtin_expect((unsigned int )cur_state->name != 1U, 1L);
#line 1040
  if (tmp___0 != 0L) {
#line 1041
    goto ldv_40838;
  } else {

  }
#line 1043
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cur_state->ldv_7466.value,
                          0);
#line 1046
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1046
  if (tmp___1 != 0L) {
#line 1047
    return (ret);
  } else {

  }
  ldv_40838: 
#line 1039
  cur_state = cur_state + 1;
  ldv_40840: ;
#line 1039
  if ((unsigned long )cur_state < (unsigned long )last_state) {
#line 1040
    goto ldv_40839;
  } else {

  }

#line 1050
  return (0);
}
}
#line 1053 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      void *buf ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  int ret ;
  struct __anonstruct_cmd_291 *cmd ;
  long tmp ;

  {
#line 1063
  cmd = (struct __anonstruct_294 *)buf;
#line 1065
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->body.ptr, & vmw_bo);
#line 1068
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1068
  if (tmp != 0L) {
#line 1069
    return (ret);
  } else {

  }
#line 1071
  vmw_dmabuf_unreference(& vmw_bo);
#line 1073
  return (ret);
}
}
#line 1084 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_set_shader(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ 
  struct vmw_set_shader_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;

  {
#line 1094
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 1094
  cmd = (struct vmw_set_shader_cmd *)__mptr;
#line 1097
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 1098
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1098
  if (tmp != 0L) {
#line 1099
    return (ret);
  } else {

  }
#line 1101
  return (0);
}
}
#line 1104 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_not_3d(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                void *buf , uint32_t *size ) 
{ 
  uint32_t size_remaining ;
  uint32_t cmd_id ;
  long tmp ;
  int tmp___0 ;

  {
#line 1108
  size_remaining = *size;
#line 1111
  cmd_id = *((uint32_t *)buf);
#line 1112
  switch (cmd_id) {
  case 1U: 
#line 1114
  *size = 20U;
#line 1115
  goto ldv_40874;
  case 36U: 
#line 1117
  *size = 20U;
#line 1118
  goto ldv_40874;
  case 37U: 
#line 1120
  *size = 32U;
#line 1121
  goto ldv_40874;
  case 38U: 
#line 1123
  *size = 32U;
#line 1124
  goto ldv_40874;
  default: 
#line 1126
  drm_err("vmw_cmd_check_not_3d", "Unsupported SVGA command: %u.\n", cmd_id);
#line 1127
  return (-22);
  }
  ldv_40874: ;
#line 1130
  if (*size > size_remaining) {
#line 1131
    drm_err("vmw_cmd_check_not_3d", "Invalid SVGA command (size mismatch): %u.\n",
            cmd_id);
#line 1133
    return (-22);
  } else {

  }
#line 1136
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 1136
  if (tmp != 0L) {
#line 1137
    drm_err("vmw_cmd_check_not_3d", "Kernel only SVGA command: %u.\n", cmd_id);
#line 1138
    return (-1);
  } else {

  }
#line 1141
  if (cmd_id == 36U) {
#line 1142
    tmp___0 = vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);
#line 1142
    return (tmp___0);
  } else {

  }
#line 1144
  return (0);
}
}
#line 1154 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static vmw_cmd_func vmw_cmd_funcs[1082U]  = 
#line 1154
  {      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_surface_copy_check,      & vmw_cmd_stretch_blt_check, 
        & vmw_cmd_dma,      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_set_render_target_check,      & vmw_cmd_tex_state, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_present_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_set_shader,      & vmw_cmd_cid_check,      & vmw_cmd_draw, 
        & vmw_cmd_cid_check,      & vmw_cmd_begin_query,      & vmw_cmd_end_query,      & vmw_cmd_wait_query, 
        & vmw_cmd_ok,      & vmw_cmd_blt_surf_screen_check,      & vmw_cmd_invalid,      & vmw_cmd_invalid, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        & vmw_cmd_invalid,      & vmw_cmd_invalid};
#line 1193 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                         void *buf , uint32_t *size ) 
{ 
  uint32_t cmd_id ;
  uint32_t size_remaining ;
  SVGA3dCmdHeader *header ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1198
  size_remaining = *size;
#line 1199
  header = (SVGA3dCmdHeader *)buf;
#line 1202
  cmd_id = *((uint32_t *)buf);
#line 1204
  tmp___0 = ldv__builtin_expect(cmd_id <= 42U, 0L);
#line 1204
  if (tmp___0 != 0L) {
#line 1205
    tmp = vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);
#line 1205
    return (tmp);
  } else {

  }
#line 1208
  cmd_id = header->id;
#line 1209
  *size = header->size + 8U;
#line 1211
  cmd_id = cmd_id - 1040U;
#line 1212
  tmp___1 = ldv__builtin_expect(*size > size_remaining, 0L);
#line 1212
  if (tmp___1 != 0L) {
#line 1213
    goto out_err;
  } else {

  }
#line 1215
  tmp___2 = ldv__builtin_expect(cmd_id > 41U, 0L);
#line 1215
  if (tmp___2 != 0L) {
#line 1216
    goto out_err;
  } else {

  }
#line 1218
  ret = (*(vmw_cmd_funcs[cmd_id]))(dev_priv, sw_context, header);
#line 1219
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1219
  if (tmp___3 != 0L) {
#line 1220
    goto out_err;
  } else {

  }
#line 1222
  return (0);
  out_err: 
#line 1224
  drm_err("vmw_cmd_check", "Illegal / Invalid SVGA3D command: %d\n", cmd_id + 1040U);
#line 1226
  return (-22);
}
}
#line 1229 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_all(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             void *buf , uint32_t size ) 
{ 
  int32_t cur_size ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1234
  cur_size = (int32_t )size;
#line 1237
  sw_context->buf_start = (uint32_t *)buf;
#line 1239
  goto ldv_40906;
  ldv_40905: 
#line 1240
  size = (uint32_t )cur_size;
#line 1241
  ret = vmw_cmd_check(dev_priv, sw_context, buf, & size);
#line 1242
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1242
  if (tmp != 0L) {
#line 1243
    return (ret);
  } else {

  }
#line 1244
  buf = (void *)((unsigned long )size + (unsigned long )buf);
#line 1245
  cur_size = (int32_t )((uint32_t )cur_size - size);
  ldv_40906: ;
#line 1239
  if (cur_size > 0) {
#line 1240
    goto ldv_40905;
  } else {

  }
#line 1248
  tmp___0 = ldv__builtin_expect(cur_size != 0, 0L);
#line 1248
  if (tmp___0 != 0L) {
#line 1249
    drm_err("vmw_cmd_check_all", "Command verifier out of sync.\n");
#line 1250
    return (-22);
  } else {

  }
#line 1253
  return (0);
}
}
#line 1256 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_free_relocations(struct vmw_sw_context *sw_context ) 
{ 


  {
#line 1258
  sw_context->cur_reloc = 0U;
#line 1259
  return;
}
}
#line 1261 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_apply_relocations(struct vmw_sw_context *sw_context ) 
{ 
  uint32_t i ;
  struct vmw_relocation *reloc ;
  struct ttm_validate_buffer *validate ;
  struct ttm_buffer_object *bo ;

  {
#line 1268
  i = 0U;
#line 1268
  goto ldv_40925;
  ldv_40924: 
#line 1269
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )i;
#line 1270
  validate = & sw_context->val_bufs[reloc->index].base;
#line 1271
  bo = validate->bo;
#line 1272
  switch (bo->mem.mem_type) {
  case 2U: 
#line 1274
  (reloc->location)->offset = (reloc->location)->offset + (uint32 )bo->offset;
#line 1275
  (reloc->location)->gmrId = 4294967294U;
#line 1276
  goto ldv_40920;
  case 3U: 
#line 1278
  (reloc->location)->gmrId = (uint32 )bo->mem.start;
#line 1279
  goto ldv_40920;
  default: 
#line 1281
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                       "i" (1281), "i" (12UL));
  ldv_40923: ;
#line 1281
  goto ldv_40923;
  }
  ldv_40920: 
#line 1268
  i = i + 1U;
  ldv_40925: ;
#line 1268
  if (sw_context->cur_reloc > i) {
#line 1269
    goto ldv_40924;
  } else {

  }
#line 1284
  vmw_free_relocations(sw_context);
#line 1285
  return;
}
}
#line 1293 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_list_unreference(struct list_head *list ) 
{ 
  struct vmw_resource_val_node *val ;
  struct vmw_resource_val_node *val_next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1301
  __mptr = (struct list_head  const  *)list->next;
#line 1301
  val = (struct vmw_resource_val_node *)__mptr;
#line 1301
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 1301
  val_next = (struct vmw_resource_val_node *)__mptr___0;
#line 1301
  goto ldv_40939;
  ldv_40938: 
#line 1302
  list_del_init(& val->head);
#line 1303
  vmw_resource_unreference(& val->res);
#line 1304
  kfree((void const   *)val);
#line 1301
  val = val_next;
#line 1301
  __mptr___1 = (struct list_head  const  *)val_next->head.next;
#line 1301
  val_next = (struct vmw_resource_val_node *)__mptr___1;
  ldv_40939: ;
#line 1301
  if ((unsigned long )(& val->head) != (unsigned long )list) {
#line 1302
    goto ldv_40938;
  } else {

  }

#line 1306
  return;
}
}
#line 1308 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_clear_validations(struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_validate_buffer *entry ;
  struct vmw_validate_buffer *next ;
  struct vmw_resource_val_node *val ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 1316
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 1316
  entry = (struct vmw_validate_buffer *)__mptr;
#line 1316
  __mptr___0 = (struct list_head  const  *)entry->base.head.next;
#line 1316
  next = (struct vmw_validate_buffer *)__mptr___0;
#line 1316
  goto ldv_40954;
  ldv_40953: 
#line 1318
  list_del(& entry->base.head);
#line 1319
  ttm_bo_unref(& entry->base.bo);
#line 1320
  drm_ht_remove_item(& sw_context->res_ht, & entry->hash);
#line 1321
  sw_context->cur_val_buf = sw_context->cur_val_buf - 1U;
#line 1316
  entry = next;
#line 1316
  __mptr___1 = (struct list_head  const  *)next->base.head.next;
#line 1316
  next = (struct vmw_validate_buffer *)__mptr___1;
  ldv_40954: ;
#line 1316
  if ((unsigned long )(& entry->base.head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 1317
    goto ldv_40953;
  } else {

  }
#line 1323
  tmp = ldv__builtin_expect(sw_context->cur_val_buf != 0U, 0L);
#line 1323
  if (tmp != 0L) {
#line 1323
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (1323), "i" (12UL));
    ldv_40956: ;
#line 1323
    goto ldv_40956;
  } else {

  }
#line 1325
  __mptr___2 = (struct list_head  const  *)sw_context->resource_list.next;
#line 1325
  val = (struct vmw_resource_val_node *)__mptr___2;
#line 1325
  goto ldv_40962;
  ldv_40961: 
#line 1326
  drm_ht_remove_item(& sw_context->res_ht, & val->hash);
#line 1325
  __mptr___3 = (struct list_head  const  *)val->head.next;
#line 1325
  val = (struct vmw_resource_val_node *)__mptr___3;
  ldv_40962: ;
#line 1325
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 1326
    goto ldv_40961;
  } else {

  }

#line 1330
  return;
}
}
#line 1329 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_single_buffer(struct vmw_private *dev_priv , struct ttm_buffer_object *bo ) 
{ 
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1339
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )bo || ((unsigned long )dev_priv->dummy_query_bo == (unsigned long )bo && (int )dev_priv->dummy_query_bo_pinned)) {
#line 1342
    return (0);
  } else {

  }
#line 1351
  ret = ttm_bo_validate(bo, & vmw_vram_gmr_placement, 1, 0);
#line 1352
  tmp = ldv__builtin_expect(ret == 0, 1L);
#line 1352
  if (tmp != 0L) {
#line 1353
    return (ret);
  } else {
#line 1352
    tmp___0 = ldv__builtin_expect(ret == -512, 1L);
#line 1352
    if (tmp___0 != 0L) {
#line 1353
      return (ret);
    } else {

    }
  }
#line 1360
  printk("\016[drm] Falling through to VRAM.\n");
#line 1361
  ret = ttm_bo_validate(bo, & vmw_vram_placement, 1, 0);
#line 1362
  return (ret);
}
}
#line 1366 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_buffers(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_validate_buffer *entry ;
  int ret ;
  struct list_head  const  *__mptr ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1372
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 1372
  entry = (struct vmw_validate_buffer *)__mptr;
#line 1372
  goto ldv_40980;
  ldv_40979: 
#line 1373
  ret = vmw_validate_single_buffer(dev_priv, entry->base.bo);
#line 1374
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1374
  if (tmp != 0L) {
#line 1375
    return (ret);
  } else {

  }
#line 1372
  __mptr___0 = (struct list_head  const  *)entry->base.head.next;
#line 1372
  entry = (struct vmw_validate_buffer *)__mptr___0;
  ldv_40980: ;
#line 1372
  if ((unsigned long )(& entry->base.head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 1373
    goto ldv_40979;
  } else {

  }

#line 1377
  return (0);
}
}
#line 1380 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context , uint32_t size ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 1383
  tmp = ldv__builtin_expect(sw_context->cmd_bounce_size >= size, 1L);
#line 1383
  if (tmp != 0L) {
#line 1384
    return (0);
  } else {

  }
#line 1386
  if (sw_context->cmd_bounce_size == 0U) {
#line 1387
    sw_context->cmd_bounce_size = 32768U;
  } else {

  }
#line 1389
  goto ldv_40987;
  ldv_40986: 
#line 1390
  sw_context->cmd_bounce_size = ((sw_context->cmd_bounce_size + (sw_context->cmd_bounce_size >> 1)) + 4095U) & 4294963200U;
  ldv_40987: ;
#line 1389
  if (sw_context->cmd_bounce_size < size) {
#line 1390
    goto ldv_40986;
  } else {

  }

#line 1395
  if ((unsigned long )sw_context->cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 1396
    vfree((void const   *)sw_context->cmd_bounce);
  } else {

  }
#line 1398
  tmp___0 = vmalloc((unsigned long )sw_context->cmd_bounce_size);
#line 1398
  sw_context->cmd_bounce = (uint32_t *)tmp___0;
#line 1400
  if ((unsigned long )sw_context->cmd_bounce == (unsigned long )((uint32_t *)0)) {
#line 1401
    drm_err("vmw_resize_cmd_bounce", "Failed to allocate command bounce buffer.\n");
#line 1402
    sw_context->cmd_bounce_size = 0U;
#line 1403
    return (-12);
  } else {

  }
#line 1406
  return (0);
}
}
#line 1420 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) 
{ 
  uint32_t sequence ;
  int ret ;
  bool synced ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1427
  synced = 0;
#line 1430
  tmp = ldv__builtin_expect((unsigned long )p_handle != (unsigned long )((uint32_t *)0),
                         0L);
#line 1430
  if (tmp != 0L) {
#line 1430
    tmp___0 = ldv__builtin_expect((unsigned long )file_priv == (unsigned long )((struct drm_file *)0),
                               0L);
#line 1430
    if (tmp___0 != 0L) {
#line 1430
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1430), "i" (12UL));
      ldv_40999: ;
#line 1430
      goto ldv_40999;
    } else {

    }
  } else {

  }
#line 1432
  ret = vmw_fifo_send_fence(dev_priv, & sequence);
#line 1433
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1433
  if (tmp___1 != 0L) {
#line 1434
    drm_err("vmw_execbuf_fence_commands", "Fence submission error. Syncing.\n");
#line 1435
    synced = 1;
  } else {

  }
#line 1438
  if ((unsigned long )p_handle != (unsigned long )((uint32_t *)0)) {
#line 1439
    ret = vmw_user_fence_create(file_priv, dev_priv->fman, sequence, 1U, p_fence,
                                p_handle);
  } else {
#line 1444
    ret = vmw_fence_create(dev_priv->fman, sequence, 1U, p_fence);
  }
#line 1448
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1448
  if (tmp___2 != 0L) {
#line 1448
    tmp___3 = ldv__builtin_expect((long )(! synced), 0L);
#line 1448
    if (tmp___3 != 0L) {
#line 1449
      vmw_fallback_wait(dev_priv, 0, 0, sequence, 0, 1250UL);
#line 1452
      *p_fence = 0;
    } else {

    }
  } else {

  }
#line 1455
  return (0);
}
}
#line 1479 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) 
{ 
  struct drm_vmw_fence_rep fence_rep ;
  long tmp ;
  long tmp___0 ;

  {
#line 1488
  if ((unsigned long )user_fence_rep == (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1489
    return;
  } else {

  }
#line 1491
  memset((void *)(& fence_rep), 0, 24UL);
#line 1493
  fence_rep.error = ret;
#line 1494
  if (ret == 0) {
#line 1495
    tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                           0L);
#line 1495
    if (tmp != 0L) {
#line 1495
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1495), "i" (12UL));
      ldv_41010: ;
#line 1495
      goto ldv_41010;
    } else {

    }
#line 1497
    fence_rep.handle = fence_handle;
#line 1498
    fence_rep.seqno = fence->seqno;
#line 1499
    vmw_update_seqno(dev_priv, & dev_priv->fifo);
#line 1500
    fence_rep.passed_seqno = dev_priv->last_read_seqno;
  } else {

  }
#line 1508
  ret = copy_to_user((void *)user_fence_rep, (void const   *)(& fence_rep), 24U);
#line 1515
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1515
  if (tmp___0 != 0L && fence_rep.error == 0) {
#line 1516
    ttm_ref_object_base_unref(vmw_fp->tfile, (unsigned long )fence_handle, 0);
#line 1518
    drm_err("vmw_execbuf_copy_fence_user", "Fence copy error. Syncing.\n");
#line 1519
    vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
  } else {

  }
#line 1521
  return;
}
}
#line 1525 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_sw_context *sw_context ;
  struct vmw_fence_obj *fence ;
  struct vmw_resource *error_resource ;
  struct list_head resource_list ;
  uint32_t handle ;
  void *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;
  struct vmw_fpriv *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  size_t __len ;
  void *__ret ;
  long tmp___12 ;
  long tmp___13 ;
  struct vmw_fpriv *tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;

  {
#line 1534
  sw_context = & dev_priv->ctx;
#line 1535
  fence = 0;
#line 1542
  ret = ldv_mutex_lock_interruptible_15(& dev_priv->cmdbuf_mutex);
#line 1543
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1543
  if (tmp != 0L) {
#line 1544
    return (-512);
  } else {

  }
#line 1546
  if ((unsigned long )kernel_commands == (unsigned long )((void *)0)) {
#line 1547
    sw_context->kernel = 0;
#line 1549
    ret = vmw_resize_cmd_bounce(sw_context, command_size);
#line 1550
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1550
    if (tmp___0 != 0L) {
#line 1551
      goto out_unlock;
    } else {

    }
#line 1554
    tmp___1 = copy_from_user((void *)sw_context->cmd_bounce, (void const   *)user_commands,
                             (unsigned long )command_size);
#line 1554
    ret = (int )tmp___1;
#line 1557
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1557
    if (tmp___2 != 0L) {
#line 1558
      ret = -14;
#line 1559
      drm_err("vmw_execbuf_process", "Failed copying commands.\n");
#line 1560
      goto out_unlock;
    } else {

    }
#line 1562
    kernel_commands = (void *)sw_context->cmd_bounce;
  } else {
#line 1564
    sw_context->kernel = 1;
  }
#line 1566
  tmp___3 = vmw_fpriv(file_priv);
#line 1566
  sw_context->tfile = tmp___3->tfile;
#line 1567
  sw_context->cur_reloc = 0U;
#line 1568
  sw_context->cur_val_buf = 0U;
#line 1569
  sw_context->fence_flags = 0U;
#line 1570
  INIT_LIST_HEAD(& sw_context->resource_list);
#line 1571
  sw_context->cur_query_bo = dev_priv->pinned_bo;
#line 1572
  sw_context->last_query_ctx = 0;
#line 1573
  sw_context->needs_post_query_barrier = 0;
#line 1574
  memset((void *)(& sw_context->res_cache), 0, 72UL);
#line 1575
  INIT_LIST_HEAD(& sw_context->validate_nodes);
#line 1576
  INIT_LIST_HEAD(& sw_context->res_relocations);
#line 1577
  if (! sw_context->res_ht_initialized) {
#line 1578
    ret = drm_ht_create(& sw_context->res_ht, 12U);
#line 1579
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1579
    if (tmp___4 != 0L) {
#line 1580
      goto out_unlock;
    } else {

    }
#line 1581
    sw_context->res_ht_initialized = 1;
  } else {

  }
#line 1584
  INIT_LIST_HEAD(& resource_list);
#line 1585
  ret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands, command_size);
#line 1587
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1587
  if (tmp___5 != 0L) {
#line 1588
    goto out_err;
  } else {

  }
#line 1590
  ret = vmw_resources_reserve(sw_context);
#line 1591
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 1591
  if (tmp___6 != 0L) {
#line 1592
    goto out_err;
  } else {

  }
#line 1594
  ret = ttm_eu_reserve_buffers(& sw_context->validate_nodes);
#line 1595
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1595
  if (tmp___7 != 0L) {
#line 1596
    goto out_err;
  } else {

  }
#line 1598
  ret = vmw_validate_buffers(dev_priv, sw_context);
#line 1599
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 1599
  if (tmp___8 != 0L) {
#line 1600
    goto out_err;
  } else {

  }
#line 1602
  ret = vmw_resources_validate(sw_context);
#line 1603
  tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 1603
  if (tmp___9 != 0L) {
#line 1604
    goto out_err;
  } else {

  }
#line 1606
  if (throttle_us != 0ULL) {
#line 1607
    ret = vmw_wait_lag(dev_priv, & dev_priv->fifo.marker_queue, (uint32_t )throttle_us);
#line 1610
    tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 1610
    if (tmp___10 != 0L) {
#line 1611
      goto out_err;
    } else {

    }
  } else {

  }
#line 1614
  cmd = vmw_fifo_reserve(dev_priv, command_size);
#line 1615
  tmp___11 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0),
                              0L);
#line 1615
  if (tmp___11 != 0L) {
#line 1616
    drm_err("vmw_execbuf_process", "Failed reserving fifo space for commands.\n");
#line 1617
    ret = -12;
#line 1618
    goto out_err;
  } else {

  }
#line 1621
  vmw_apply_relocations(sw_context);
#line 1622
  __len = (size_t )command_size;
#line 1622
  __ret = __builtin_memcpy(cmd, (void const   *)kernel_commands, __len);
#line 1624
  vmw_resource_relocations_apply((uint32_t *)cmd, & sw_context->res_relocations);
#line 1625
  vmw_resource_relocations_free(& sw_context->res_relocations);
#line 1627
  vmw_fifo_commit(dev_priv, command_size);
#line 1629
  vmw_query_bo_switch_commit(dev_priv, sw_context);
#line 1630
  ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, (unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0) ? & handle : 0);
#line 1639
  if (ret != 0) {
#line 1640
    drm_err("vmw_execbuf_process", "Fence submission error. Syncing.\n");
  } else {

  }
#line 1642
  vmw_resource_list_unreserve(& sw_context->resource_list, 0);
#line 1643
  ttm_eu_fence_buffer_objects(& sw_context->validate_nodes, (void *)fence);
#line 1646
  tmp___12 = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                              0L);
#line 1646
  if (tmp___12 != 0L) {
#line 1646
    tmp___13 = ldv__builtin_expect(dev_priv->query_cid_valid == 0U, 0L);
#line 1646
    if (tmp___13 != 0L) {
#line 1648
      __vmw_execbuf_release_pinned_bo(dev_priv, fence);
    } else {

    }
  } else {

  }
#line 1650
  vmw_clear_validations(sw_context);
#line 1651
  tmp___14 = vmw_fpriv(file_priv);
#line 1651
  vmw_execbuf_copy_fence_user(dev_priv, tmp___14, ret, user_fence_rep, fence, handle);
#line 1655
  tmp___16 = ldv__builtin_expect((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0),
                              0L);
#line 1655
  if (tmp___16 != 0L) {
#line 1656
    *out_fence = fence;
#line 1657
    fence = 0;
  } else {
#line 1658
    tmp___15 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                                1L);
#line 1658
    if (tmp___15 != 0L) {
#line 1659
      vmw_fence_obj_unreference(& fence);
    } else {

    }
  }
#line 1662
  list_splice_init(& sw_context->resource_list, & resource_list);
#line 1663
  ldv_mutex_unlock_16(& dev_priv->cmdbuf_mutex);
#line 1669
  vmw_resource_list_unreference(& resource_list);
#line 1671
  return (0);
  out_err: 
#line 1674
  vmw_resource_relocations_free(& sw_context->res_relocations);
#line 1675
  vmw_free_relocations(sw_context);
#line 1676
  ttm_eu_backoff_reservation(& sw_context->validate_nodes);
#line 1677
  vmw_resource_list_unreserve(& sw_context->resource_list, 1);
#line 1678
  vmw_clear_validations(sw_context);
#line 1679
  tmp___17 = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                              0L);
#line 1679
  if (tmp___17 != 0L) {
#line 1679
    tmp___18 = ldv__builtin_expect(dev_priv->query_cid_valid == 0U, 0L);
#line 1679
    if (tmp___18 != 0L) {
#line 1681
      __vmw_execbuf_release_pinned_bo(dev_priv, 0);
    } else {

    }
  } else {

  }
  out_unlock: 
#line 1683
  list_splice_init(& sw_context->resource_list, & resource_list);
#line 1684
  error_resource = sw_context->error_resource;
#line 1685
  sw_context->error_resource = 0;
#line 1686
  ldv_mutex_unlock_17(& dev_priv->cmdbuf_mutex);
#line 1692
  vmw_resource_list_unreference(& resource_list);
#line 1693
  tmp___19 = ldv__builtin_expect((unsigned long )error_resource != (unsigned long )((struct vmw_resource *)0),
                              0L);
#line 1693
  if (tmp___19 != 0L) {
#line 1694
    vmw_resource_unreference(& error_resource);
  } else {

  }
#line 1696
  return (ret);
}
}
#line 1708 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv ) 
{ 


  {
#line 1710
  drm_err("vmw_execbuf_unpin_panic", "Can\'t unpin query buffer. Trying to recover.\n");
#line 1712
  vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
#line 1713
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1714
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1715
  dev_priv->dummy_query_bo_pinned = 0;
#line 1716
  return;
}
}
#line 1743 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , struct vmw_fence_obj *fence ) 
{ 
  int ret ;
  struct list_head validate_list ;
  struct ttm_validate_buffer pinned_val ;
  struct ttm_validate_buffer query_val ;
  struct vmw_fence_obj *lfence ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1746
  ret = 0;
#line 1749
  lfence = 0;
#line 1751
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1752
    goto out_unlock;
  } else {

  }
#line 1754
  INIT_LIST_HEAD(& validate_list);
#line 1756
  pinned_val.bo = ttm_bo_reference(dev_priv->pinned_bo);
#line 1757
  list_add_tail(& pinned_val.head, & validate_list);
#line 1759
  query_val.bo = ttm_bo_reference(dev_priv->dummy_query_bo);
#line 1760
  list_add_tail(& query_val.head, & validate_list);
  ldv_41049: 
#line 1763
  ret = ttm_eu_reserve_buffers(& validate_list);
#line 1764
  if (ret == -512) {
#line 1765
    goto ldv_41049;
  } else {

  }
#line 1766
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1766
  if (tmp != 0L) {
#line 1767
    vmw_execbuf_unpin_panic(dev_priv);
#line 1768
    goto out_no_reserve;
  } else {

  }
#line 1771
  if (dev_priv->query_cid_valid != 0U) {
#line 1772
    tmp___0 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                               0L);
#line 1772
    if (tmp___0 != 0L) {
#line 1772
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1772), "i" (12UL));
      ldv_41052: ;
#line 1772
      goto ldv_41052;
    } else {

    }
#line 1773
    ret = vmw_fifo_emit_dummy_query(dev_priv, dev_priv->query_cid);
#line 1774
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1774
    if (tmp___1 != 0L) {
#line 1775
      vmw_execbuf_unpin_panic(dev_priv);
#line 1776
      goto out_no_emit;
    } else {

    }
#line 1778
    dev_priv->query_cid_valid = 0U;
  } else {

  }
#line 1781
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1782
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1783
  dev_priv->dummy_query_bo_pinned = 0;
#line 1785
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1786
    vmw_execbuf_fence_commands(0, dev_priv, & lfence, 0);
#line 1788
    fence = lfence;
  } else {

  }
#line 1790
  ttm_eu_fence_buffer_objects(& validate_list, (void *)fence);
#line 1791
  if ((unsigned long )lfence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1792
    vmw_fence_obj_unreference(& lfence);
  } else {

  }
#line 1794
  ttm_bo_unref(& query_val.bo);
#line 1795
  ttm_bo_unref(& pinned_val.bo);
#line 1796
  ttm_bo_unref(& dev_priv->pinned_bo);
  out_unlock: ;
#line 1799
  return;
  out_no_emit: 
#line 1802
  ttm_eu_backoff_reservation(& validate_list);
  out_no_reserve: 
#line 1804
  ttm_bo_unref(& query_val.bo);
#line 1805
  ttm_bo_unref(& pinned_val.bo);
#line 1806
  ttm_bo_unref(& dev_priv->pinned_bo);
#line 1807
  return;
}
}
#line 1827 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv ) 
{ 


  {
#line 1829
  ldv_mutex_lock_18(& dev_priv->cmdbuf_mutex);
#line 1830
  if (dev_priv->query_cid_valid != 0U) {
#line 1831
    __vmw_execbuf_release_pinned_bo(dev_priv, 0);
  } else {

  }
#line 1832
  ldv_mutex_unlock_19(& dev_priv->cmdbuf_mutex);
#line 1833
  return;
}
}
#line 1836 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_execbuf_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  int ret ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1839
  tmp = vmw_priv(dev);
#line 1839
  dev_priv = tmp;
#line 1840
  arg = (struct drm_vmw_execbuf_arg *)data;
#line 1841
  tmp___0 = vmw_master(file_priv->master);
#line 1841
  vmaster = tmp___0;
#line 1851
  tmp___1 = ldv__builtin_expect(arg->version != 1U, 0L);
#line 1851
  if (tmp___1 != 0L) {
#line 1852
    drm_err("vmw_execbuf_ioctl", "Incorrect execbuf version.\n");
#line 1853
    drm_err("vmw_execbuf_ioctl", "You\'re running outdated experimental vmwgfx user-space drivers.");
#line 1855
    return (-22);
  } else {

  }
#line 1858
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1859
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1859
  if (tmp___2 != 0L) {
#line 1860
    return (ret);
  } else {

  }
#line 1862
  ret = vmw_execbuf_process(file_priv, dev_priv, (void *)arg->commands, 0, arg->command_size,
                            (uint64_t )arg->throttle_us, (struct drm_vmw_fence_rep *)arg->fence_rep,
                            0);
#line 1868
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1868
  if (tmp___3 != 0L) {
#line 1869
    goto out_unlock;
  } else {

  }
#line 1871
  vmw_kms_cursor_post_execbuf(dev_priv);
  out_unlock: 
#line 1874
  ttm_read_unlock(& vmaster->lock);
#line 1875
  return (ret);
}
}
#line 1878 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1883
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1885
  mutex_lock(ldv_func_arg1);
#line 1886
  return;
}
}
#line 1888 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1893
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1895
  mutex_unlock(ldv_func_arg1);
#line 1896
  return;
}
}
#line 1898 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1903
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1905
  mutex_lock(ldv_func_arg1);
#line 1906
  return;
}
}
#line 1908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1913
  tmp = mutex_trylock(ldv_func_arg1);
#line 1913
  ldv_func_res = tmp;
#line 1915
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1915
  return (tmp___0);
#line 1917
  return (ldv_func_res);
}
}
#line 1920 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1925
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1927
  mutex_unlock(ldv_func_arg1);
#line 1928
  return;
}
}
#line 1930 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1935
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1937
  mutex_lock(ldv_func_arg1);
#line 1938
  return;
}
}
#line 1940 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1945
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1947
  mutex_unlock(ldv_func_arg1);
#line 1948
  return;
}
}
#line 1950 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1955
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1957
  mutex_lock(ldv_func_arg1);
#line 1958
  return;
}
}
#line 1960 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1965
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1967
  mutex_unlock(ldv_func_arg1);
#line 1968
  return;
}
}
#line 1970 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1975
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1977
  mutex_unlock(ldv_func_arg1);
#line 1978
  return;
}
}
#line 1980 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1985
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1987
  mutex_lock(ldv_func_arg1);
#line 1988
  return;
}
}
#line 1990 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1995
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1997
  mutex_unlock(ldv_func_arg1);
#line 1998
  return;
}
}
#line 2000 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2005
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2007
  mutex_lock(ldv_func_arg1);
#line 2008
  return;
}
}
#line 2010 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2015
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2017
  mutex_unlock(ldv_func_arg1);
#line 2018
  return;
}
}
#line 2020 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_lock_interruptible_15(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2025
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 2025
  ldv_func_res = tmp;
#line 2027
  tmp___0 = ldv_mutex_lock_interruptible_cmdbuf_mutex(ldv_func_arg1);
#line 2027
  return (tmp___0);
#line 2029
  return (ldv_func_res);
}
}
#line 2032 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2037
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 2039
  mutex_unlock(ldv_func_arg1);
#line 2040
  return;
}
}
#line 2042 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2047
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 2049
  mutex_unlock(ldv_func_arg1);
#line 2050
  return;
}
}
#line 2052 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2057
  ldv_mutex_lock_cmdbuf_mutex(ldv_func_arg1);
#line 2059
  mutex_lock(ldv_func_arg1);
#line 2060
  return;
}
}
#line 2062 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2067
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 2069
  mutex_unlock(ldv_func_arg1);
#line 2070
  return;
}
}
#line 88 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_54(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_44(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_46(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_53(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) ;
#line 83
void ldv_mutex_lock_hw_mutex(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_hw_mutex(struct mutex *lock ) ;
#line 206 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 211
  switch (8UL) {
  case 1UL: 
#line 211
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7724;
  case 2UL: 
#line 211
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7724;
  case 4UL: 
#line 211
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7724;
  case 8UL: 
#line 211
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7724;
  default: 
#line 211
  __bad_percpu_size();
  }
  ldv_7724: 
#line 211
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 213
  return (ti);
}
}
#line 310 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 310
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 311
  return;
}
}
#line 329 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 332 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 334
  tmp = alloc_pages_current(gfp_mask, order);
#line 334
  return (tmp);
}
}
#line 365
extern void __free_pages(struct page * , unsigned int  ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 18
  tmp = current_thread_info();
#line 18
  tmp->preempt_count = tmp->preempt_count + 1;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  tmp = current_thread_info();
#line 33
  tmp->preempt_count = tmp->preempt_count + -1;
#line 37
  __asm__  volatile   ("": : : "memory");
#line 38
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  pagefault_disable();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
#line 69
  return (tmp);
}
}
#line 73 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 75
  pagefault_enable();
#line 76
  return;
}
}
#line 384 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value ) 
{ 


  {
#line 387
  outl(offset, (int )dev_priv->io_start);
#line 388
  outl(value, (int )(dev_priv->io_start + 1U));
#line 389
  return;
}
}
#line 408
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) ;
#line 412
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) ;
#line 137 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr2_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                         int gmr_id ) 
{ 
  SVGAFifoCmdDefineGMR2 define_cmd ;
  SVGAFifoCmdRemapGMR2 remap_cmd ;
  uint32_t define_size ;
  uint32_t remap_size ;
  uint32_t *cmd ;
  uint32_t *cmd_orig ;
  uint32_t i ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct page **tmp___4 ;

  {
#line 144
  define_size = 12U;
#line 145
  remap_size = (uint32_t )(num_pages + 2UL) * 8U + 4U;
#line 150
  tmp = vmw_fifo_reserve(dev_priv, define_size + remap_size);
#line 150
  cmd = (uint32_t *)tmp;
#line 150
  cmd_orig = cmd;
#line 151
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 151
  if (tmp___0 != 0L) {
#line 152
    return (-12);
  } else {

  }
#line 154
  define_cmd.gmrId = (uint32 )gmr_id;
#line 155
  define_cmd.numPages = (uint32 )num_pages;
#line 157
  remap_cmd.gmrId = (uint32 )gmr_id;
#line 158
  remap_cmd.flags = 2;
#line 160
  remap_cmd.offsetPages = 0U;
#line 161
  remap_cmd.numPages = (uint32 )num_pages;
#line 163
  tmp___1 = cmd;
#line 163
  cmd = cmd + 1;
#line 163
  *tmp___1 = 41U;
#line 164
  __len = 8UL;
#line 164
  if (__len > 63UL) {
#line 164
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 164
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 165
  cmd = cmd + 2UL;
#line 167
  tmp___2 = cmd;
#line 167
  cmd = cmd + 1;
#line 167
  *tmp___2 = 42U;
#line 168
  __len___0 = 16UL;
#line 168
  if (__len___0 > 63UL) {
#line 168
    __ret___0 = __memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  } else {
#line 168
    __ret___0 = __builtin_memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  }
#line 169
  cmd = cmd + 4UL;
#line 171
  i = 0U;
#line 171
  goto ldv_40528;
  ldv_40527: 
#line 175
  tmp___4 = pages;
#line 175
  pages = pages + 1;
#line 175
  *((uint64_t *)cmd) = (uint64_t )(((long )*tmp___4 + 24189255811072L) / 80L);
#line 177
  cmd = cmd + 2UL;
#line 171
  i = i + 1U;
  ldv_40528: ;
#line 171
  if ((unsigned long )i < num_pages) {
#line 172
    goto ldv_40527;
  } else {

  }
#line 180
  vmw_fifo_commit(dev_priv, define_size + remap_size);
#line 182
  return (0);
}
}
#line 185 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr2_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ 
  SVGAFifoCmdDefineGMR2 define_cmd ;
  uint32_t define_size ;
  uint32_t *cmd ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 189
  define_size = 12U;
#line 192
  tmp = vmw_fifo_reserve(dev_priv, define_size);
#line 192
  cmd = (uint32_t *)tmp;
#line 193
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 193
  if (tmp___0 != 0L) {
#line 194
    drm_err("vmw_gmr2_unbind", "GMR2 unbind failed.\n");
#line 195
    return;
  } else {

  }
#line 197
  define_cmd.gmrId = (uint32 )gmr_id;
#line 198
  define_cmd.numPages = 0U;
#line 200
  tmp___1 = cmd;
#line 200
  cmd = cmd + 1;
#line 200
  *tmp___1 = 41U;
#line 201
  __len = 8UL;
#line 201
  if (__len > 63UL) {
#line 201
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 201
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 203
  vmw_fifo_commit(dev_priv, define_size);
#line 204
  return;
}
}
#line 211 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr_build_descriptors(struct list_head *desc_pages , struct page **pages ,
                                     unsigned long num_pages ) 
{ 
  struct page *page ;
  struct page *next ;
  struct svga_guest_mem_descriptor *page_virtual ;
  struct svga_guest_mem_descriptor *desc_virtual ;
  unsigned int desc_per_page ;
  unsigned long prev_pfn ;
  unsigned long pfn ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 216
  page_virtual = 0;
#line 217
  desc_virtual = 0;
#line 223
  desc_per_page = 511U;
#line 226
  goto ldv_40560;
  ldv_40559: 
#line 227
  page = alloc_pages(2U, 0U);
#line 228
  tmp = ldv__builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                         0L);
#line 228
  if (tmp != 0L) {
#line 229
    ret = -12;
#line 230
    goto out_err;
  } else {

  }
#line 233
  list_add_tail(& page->ldv_21174.lru, desc_pages);
#line 240
  tmp___0 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 240
  if (tmp___0 != 0L) {
#line 241
    desc_virtual->ppn = (__le32 )(((long )page + 24189255811072L) / 80L);
#line 242
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 245
  tmp___1 = kmap_atomic(page);
#line 245
  page_virtual = (struct svga_guest_mem_descriptor *)tmp___1;
#line 246
  desc_virtual = page_virtual + 0xffffffffffffffffUL;
#line 247
  prev_pfn = 0xffffffffffffffffUL;
#line 249
  goto ldv_40558;
  ldv_40557: 
#line 250
  pfn = (unsigned long )(((long )*pages + 24189255811072L) / 80L);
#line 252
  if (prev_pfn + 1UL != pfn) {
#line 254
    if (((long )desc_virtual - (long )page_virtual) / 8L == (long )(desc_per_page - 1U)) {
#line 256
      goto ldv_40555;
    } else {

    }
#line 258
    desc_virtual = desc_virtual + 1;
#line 258
    desc_virtual->ppn = (unsigned int )pfn;
#line 259
    desc_virtual->num_pages = 1U;
  } else {
#line 261
    tmp___2 = desc_virtual->num_pages;
#line 263
    desc_virtual->num_pages = tmp___2 + 1U;
  }
#line 265
  prev_pfn = pfn;
#line 266
  num_pages = num_pages - 1UL;
#line 267
  pages = pages + 1;
  ldv_40558: 
#line 249
  tmp___3 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 249
  if (tmp___3 != 0L) {
#line 250
    goto ldv_40557;
  } else {

  }
  ldv_40555: 
#line 270
  desc_virtual = desc_virtual + 1;
#line 270
  desc_virtual->ppn = 0U;
#line 271
  desc_virtual->num_pages = 0U;
  ldv_40560: 
#line 226
  tmp___4 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 226
  if (tmp___4 != 0L) {
#line 227
    goto ldv_40559;
  } else {

  }
#line 274
  tmp___5 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 274
  if (tmp___5 != 0L) {
#line 275
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 277
  return (0);
  out_err: 
#line 279
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 279
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 279
  __mptr___0 = (struct list_head  const  *)page->ldv_21174.lru.next;
#line 279
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 279
  goto ldv_40569;
  ldv_40568: 
#line 280
  list_del_init(& page->ldv_21174.lru);
#line 281
  __free_pages(page, 0U);
#line 279
  page = next;
#line 279
  __mptr___1 = (struct list_head  const  *)next->ldv_21174.lru.next;
#line 279
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_40569: ;
#line 279
  if ((unsigned long )(& page->ldv_21174.lru) != (unsigned long )desc_pages) {
#line 280
    goto ldv_40568;
  } else {

  }

#line 283
  return (ret);
}
}
#line 286 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
__inline static void vmw_gmr_free_descriptors(struct list_head *desc_pages ) 
{ 
  struct page *page ;
  struct page *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 290
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 290
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 290
  __mptr___0 = (struct list_head  const  *)page->ldv_21174.lru.next;
#line 290
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 290
  goto ldv_40583;
  ldv_40582: 
#line 291
  list_del_init(& page->ldv_21174.lru);
#line 292
  __free_pages(page, 0U);
#line 290
  page = next;
#line 290
  __mptr___1 = (struct list_head  const  *)next->ldv_21174.lru.next;
#line 290
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_40583: ;
#line 290
  if ((unsigned long )(& page->ldv_21174.lru) != (unsigned long )desc_pages) {
#line 291
    goto ldv_40582;
  } else {

  }

#line 295
  return;
}
}
#line 296 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr_fire_descriptors(struct vmw_private *dev_priv , int gmr_id , struct list_head *desc_pages ) 
{ 
  struct page *page ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;

  {
#line 301
  tmp = list_empty((struct list_head  const  *)desc_pages);
#line 301
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 301
  if (tmp___0 != 0L) {
#line 302
    return;
  } else {

  }
#line 304
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 304
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 306
  ldv_mutex_lock_53(& dev_priv->hw_mutex);
#line 308
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 309
  __asm__  volatile   ("sfence": : : "memory");
#line 310
  vmw_write(dev_priv, 42U, (uint32_t )(((long )page + 24189255811072L) / 80L));
#line 311
  __asm__  volatile   ("mfence": : : "memory");
#line 313
  ldv_mutex_unlock_54(& dev_priv->hw_mutex);
#line 314
  return;
}
}
#line 322 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static unsigned long vmw_gmr_count_descriptors(struct page **pages , unsigned long num_pages ) 
{ 
  unsigned long prev_pfn ;
  unsigned long pfn ;
  unsigned long descriptors ;
  struct page **tmp ;
  unsigned long tmp___0 ;

  {
#line 325
  prev_pfn = 0xffffffffffffffffUL;
#line 327
  descriptors = 0UL;
#line 329
  goto ldv_40601;
  ldv_40600: 
#line 330
  tmp = pages;
#line 330
  pages = pages + 1;
#line 330
  pfn = (unsigned long )(((long )*tmp + 24189255811072L) / 80L);
#line 331
  if (prev_pfn + 1UL != pfn) {
#line 332
    descriptors = descriptors + 1UL;
  } else {

  }
#line 333
  prev_pfn = pfn;
  ldv_40601: 
#line 329
  tmp___0 = num_pages;
#line 329
  num_pages = num_pages - 1UL;
#line 329
  if (tmp___0 != 0UL) {
#line 330
    goto ldv_40600;
  } else {

  }

#line 336
  return (descriptors);
}
}
#line 339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) 
{ 
  struct list_head desc_pages ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;

  {
#line 347
  tmp___0 = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 347
  if (tmp___0 != 0L) {
#line 348
    tmp = vmw_gmr2_bind(dev_priv, pages, num_pages, gmr_id);
#line 348
    return (tmp);
  } else {

  }
#line 350
  tmp___1 = ldv__builtin_expect((dev_priv->capabilities & 1048576U) == 0U, 0L);
#line 350
  if (tmp___1 != 0L) {
#line 351
    return (-22);
  } else {

  }
#line 353
  tmp___2 = vmw_gmr_count_descriptors(pages, num_pages);
#line 353
  if (tmp___2 > (unsigned long )dev_priv->max_gmr_descriptors) {
#line 355
    return (-22);
  } else {

  }
#line 357
  INIT_LIST_HEAD(& desc_pages);
#line 359
  ret = vmw_gmr_build_descriptors(& desc_pages, pages, num_pages);
#line 360
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 360
  if (tmp___3 != 0L) {
#line 361
    return (ret);
  } else {

  }
#line 363
  vmw_gmr_fire_descriptors(dev_priv, gmr_id, & desc_pages);
#line 364
  vmw_gmr_free_descriptors(& desc_pages);
#line 366
  return (0);
}
}
#line 370 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ 
  long tmp ;

  {
#line 372
  tmp = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 372
  if (tmp != 0L) {
#line 373
    vmw_gmr2_unbind(dev_priv, gmr_id);
#line 374
    return;
  } else {

  }
#line 377
  ldv_mutex_lock_55(& dev_priv->hw_mutex);
#line 378
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 379
  __asm__  volatile   ("sfence": : : "memory");
#line 380
  vmw_write(dev_priv, 42U, 0U);
#line 381
  __asm__  volatile   ("mfence": : : "memory");
#line 382
  ldv_mutex_unlock_56(& dev_priv->hw_mutex);
#line 383
  return;
}
}
#line 385 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 390
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 392
  mutex_lock(ldv_func_arg1);
#line 393
  return;
}
}
#line 395 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 400
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 402
  mutex_unlock(ldv_func_arg1);
#line 403
  return;
}
}
#line 405 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 410
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 412
  mutex_lock(ldv_func_arg1);
#line 413
  return;
}
}
#line 415 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 420
  tmp = mutex_trylock(ldv_func_arg1);
#line 420
  ldv_func_res = tmp;
#line 422
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 422
  return (tmp___0);
#line 424
  return (ldv_func_res);
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 432
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 434
  mutex_unlock(ldv_func_arg1);
#line 435
  return;
}
}
#line 437 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_44(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 442
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 444
  mutex_lock(ldv_func_arg1);
#line 445
  return;
}
}
#line 447 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 452
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 454
  mutex_unlock(ldv_func_arg1);
#line 455
  return;
}
}
#line 457 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_46(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 462
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 464
  mutex_lock(ldv_func_arg1);
#line 465
  return;
}
}
#line 467 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 482
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 484
  mutex_unlock(ldv_func_arg1);
#line 485
  return;
}
}
#line 487 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 492
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 494
  mutex_lock(ldv_func_arg1);
#line 495
  return;
}
}
#line 497 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 502
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 504
  mutex_unlock(ldv_func_arg1);
#line 505
  return;
}
}
#line 507 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 522
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 524
  mutex_unlock(ldv_func_arg1);
#line 525
  return;
}
}
#line 527 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_53(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 532
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 534
  mutex_lock(ldv_func_arg1);
#line 535
  return;
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_54(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 544
  mutex_unlock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 552
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 554
  mutex_lock(ldv_func_arg1);
#line 555
  return;
}
}
#line 557 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 562
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 564
  mutex_unlock(ldv_func_arg1);
#line 565
  return;
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
#line 157
  return;
}
}
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 24
  return ((void *)error);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_78(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_80(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) ;
#line 75
void ldv_mutex_lock_fb_surf_mutex(struct mutex *lock ) ;
#line 79
void ldv_mutex_unlock_fb_surf_mutex(struct mutex *lock ) ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 310 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
#line 310
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 314 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 316
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 317
    return (0);
  } else {

  }
#line 318
  tmp = __kmalloc(n * size, flags);
#line 318
  return (tmp);
}
}
#line 327 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 329
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 329
  return (tmp);
}
}
#line 129 "include/drm/drmP.h"
extern void drm_ut_debug_printk(unsigned int  , char const   * , char const   * ,
                                char const   *  , ...) ;
#line 848 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
#line 855
extern void drm_connector_cleanup(struct drm_connector * ) ;
#line 872
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
#line 886
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
#line 889
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
#line 892
extern void drm_mode_config_init(struct drm_device * ) ;
#line 894
extern void drm_mode_config_cleanup(struct drm_device * ) ;
#line 907
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
#line 917
extern int drm_mode_vrefresh(struct drm_display_mode  const  * ) ;
#line 920
extern void drm_mode_connector_list_update(struct drm_connector * ) ;
#line 932
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
#line 938
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
#line 977
extern struct drm_mode_object *drm_mode_object_find(struct drm_device * , uint32_t  ,
                                                    uint32_t  ) ;
#line 1070
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
#line 1498 "include/drm/drmP.h"
extern struct drm_master *drm_master_get(struct drm_master * ) ;
#line 1499
extern void drm_master_put(struct drm_master ** ) ;
#line 636 "include/drm/ttm/ttm_bo_api.h"
__inline static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem ) 
{ 


  {
#line 639
  *is_iomem = ((unsigned int )map->bo_kmap_type & 128U) != 0U;
#line 640
  return (map->virtual);
}
}
#line 660
extern int ttm_bo_kmap(struct ttm_buffer_object * , unsigned long  , unsigned long  ,
                       struct ttm_bo_kmap_obj * ) ;
#line 671
extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj * ) ;
#line 829 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_reserve(struct ttm_buffer_object * , bool  , bool  , bool  , uint32_t  ) ;
#line 870
extern void ttm_bo_unreserve(struct ttm_buffer_object * ) ;
#line 171 "include/drm/ttm/ttm_object.h"
extern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file * , uint32_t  ) ;
#line 183
extern void ttm_base_object_unref(struct ttm_base_object ** ) ;
#line 114 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) ;
#line 391 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset ) 
{ 
  uint32_t val ;

  {
#line 396
  outl(offset, (int )dev_priv->io_start);
#line 397
  val = inl((int )(dev_priv->io_start + 1U));
#line 398
  return (val);
}
}
#line 435
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) ;
#line 505
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) ;
#line 508
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) ;
#line 546
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) ;
#line 657
int vmw_kms_init(struct vmw_private *dev_priv ) ;
#line 658
int vmw_kms_close(struct vmw_private *dev_priv ) ;
#line 659
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) ;
#line 660
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) ;
#line 661
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 668
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) ;
#line 672
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) ;
#line 675
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) ;
#line 676
int vmw_enable_vblank(struct drm_device *dev , int crtc ) ;
#line 677
void vmw_disable_vblank(struct drm_device *dev , int crtc ) ;
#line 678
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) ;
#line 685
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) ;
#line 691
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 713
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) ;
#line 714
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) ;
#line 730 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_surface_unreference(struct vmw_surface **srf ) 
{ 
  struct vmw_surface *tmp_srf ;
  struct vmw_resource *res ;

  {
#line 732
  tmp_srf = *srf;
#line 733
  res = & tmp_srf->res;
#line 734
  *srf = 0;
#line 736
  vmw_resource_unreference(& res);
#line 737
  return;
}
}
#line 739 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf ) 
{ 


  {
#line 741
  vmw_resource_reference(& srf->res);
#line 742
  return (srf);
}
}
#line 757 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf ) 
{ 
  struct ttm_buffer_object *tmp ;

  {
#line 759
  tmp = ttm_bo_reference(& buf->base);
#line 759
  if ((unsigned long )tmp != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 760
    return (buf);
  } else {

  }
#line 761
  return (0);
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 66
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 70
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) ;
#line 123
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) ;
#line 124
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
#line 127
void vmw_du_crtc_save(struct drm_crtc *crtc ) ;
#line 128
void vmw_du_crtc_restore(struct drm_crtc *crtc ) ;
#line 129
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) ;
#line 132
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) ;
#line 134
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 135
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) ;
#line 136
void vmw_du_connector_save(struct drm_connector *connector ) ;
#line 137
void vmw_du_connector_restore(struct drm_connector *connector ) ;
#line 139
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) ;
#line 140
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) ;
#line 142
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) ;
#line 150
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 151
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 156
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) ;
#line 157
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) ;
#line 160
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 162
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 147 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_clip_cliprects(struct drm_clip_rect *rects , int num_rects , struct vmw_clip_rect clip ,
                        SVGASignedRect *out_rects , int *out_num ) 
{ 
  int i ;
  int k ;
  int x1 ;
  int __max1 ;
  int __max2 ;
  int y1 ;
  int __max1___0 ;
  int __max2___0 ;
  int x2 ;
  int __min1 ;
  int __min2 ;
  int y2 ;
  int __min1___0 ;
  int __min2___0 ;

  {
#line 155
  i = 0;
#line 155
  k = 0;
#line 155
  goto ldv_40809;
  ldv_40808: 
#line 156
  __max1 = clip.x1;
#line 156
  __max2 = (int )(rects + (unsigned long )i)->x1;
#line 156
  x1 = __max1 > __max2 ? __max1 : __max2;
#line 157
  __max1___0 = clip.y1;
#line 157
  __max2___0 = (int )(rects + (unsigned long )i)->y1;
#line 157
  y1 = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 158
  __min1 = clip.x2;
#line 158
  __min2 = (int )(rects + (unsigned long )i)->x2;
#line 158
  x2 = __min1 < __min2 ? __min1 : __min2;
#line 159
  __min1___0 = clip.y2;
#line 159
  __min2___0 = (int )(rects + (unsigned long )i)->y2;
#line 159
  y2 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 161
  if (x1 >= x2) {
#line 162
    goto ldv_40807;
  } else {

  }
#line 163
  if (y1 >= y2) {
#line 164
    goto ldv_40807;
  } else {

  }
#line 166
  (out_rects + (unsigned long )k)->left = x1;
#line 167
  (out_rects + (unsigned long )k)->top = y1;
#line 168
  (out_rects + (unsigned long )k)->right = x2;
#line 169
  (out_rects + (unsigned long )k)->bottom = y2;
#line 170
  k = k + 1;
  ldv_40807: 
#line 155
  i = i + 1;
  ldv_40809: ;
#line 155
  if (i < num_rects) {
#line 156
    goto ldv_40808;
  } else {

  }
#line 173
  *out_num = k;
#line 174
  return;
}
}
#line 176 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) 
{ 


  {
#line 178
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 179
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 180
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 181
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 182
  drm_crtc_cleanup(& du->crtc);
#line 183
  drm_encoder_cleanup(& du->encoder);
#line 184
  drm_connector_cleanup(& du->connector);
#line 185
  return;
}
}
#line 191 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) 
{ 
  struct __anonstruct_cmd_291___0 *cmd ;
  u32 image_size ;
  u32 cmd_size ;
  void *tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 199
  image_size = (width * height) * 4U;
#line 200
  cmd_size = image_size + 24U;
#line 202
  if ((unsigned long )image == (unsigned long )((u32 *)0)) {
#line 203
    return (-22);
  } else {

  }
#line 205
  tmp = vmw_fifo_reserve(dev_priv, cmd_size);
#line 205
  cmd = (struct __anonstruct_293 *)tmp;
#line 206
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___0 *)0),
                             0L);
#line 206
  if (tmp___0 != 0L) {
#line 207
    drm_err("vmw_cursor_update_image", "Fifo reserve failed.\n");
#line 208
    return (-12);
  } else {

  }
#line 211
  memset((void *)cmd, 0, 24UL);
#line 213
  __len = (size_t )image_size;
#line 213
  __ret = __builtin_memcpy((void *)cmd + 1U, (void const   *)image, __len);
#line 215
  cmd->cmd = 22U;
#line 216
  cmd->cursor.id = 0U;
#line 217
  cmd->cursor.width = width;
#line 218
  cmd->cursor.height = height;
#line 219
  cmd->cursor.hotspotX = hotspotX;
#line 220
  cmd->cursor.hotspotY = hotspotY;
#line 222
  vmw_fifo_commit(dev_priv, cmd_size);
#line 224
  return (0);
}
}
#line 227 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) 
{ 
  struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  void *virtual ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 239
  kmap_offset = 0UL;
#line 240
  kmap_num = ((unsigned long )((width * height) * 4U) + 4095UL) >> 12;
#line 242
  ret = ttm_bo_reserve(& dmabuf->base, 1, 0, 0, 0U);
#line 243
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 243
  if (tmp != 0L) {
#line 244
    drm_err("vmw_cursor_update_dmabuf", "reserve failed\n");
#line 245
    return (-22);
  } else {

  }
#line 248
  ret = ttm_bo_kmap(& dmabuf->base, kmap_offset, kmap_num, & map);
#line 249
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 249
  if (tmp___0 != 0L) {
#line 250
    goto err_unreserve;
  } else {

  }
#line 252
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 253
  ret = vmw_cursor_update_image(dev_priv, (u32 *)virtual, width, height, hotspotX,
                                hotspotY);
#line 256
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 258
  ttm_bo_unreserve(& dmabuf->base);
#line 260
  return (ret);
}
}
#line 264 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) 
{ 
  __le32 *fifo_mem ;
  uint32_t count ;

  {
#line 267
  fifo_mem = dev_priv->mmio_virt;
#line 270
  iowrite32((u32 )show, (void *)fifo_mem + 9U);
#line 271
  iowrite32((u32 )x, (void *)fifo_mem + 10U);
#line 272
  iowrite32((u32 )y, (void *)fifo_mem + 11U);
#line 273
  count = ioread32((void *)fifo_mem + 12U);
#line 274
  count = count + 1U;
#line 274
  iowrite32(count, (void *)fifo_mem + 12U);
#line 275
  return;
}
}
#line 277 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *dmabuf ;
  int ret ;

  {
#line 280
  tmp = vmw_priv(crtc->dev);
#line 280
  dev_priv = tmp;
#line 281
  tmp___0 = vmw_fpriv(file_priv);
#line 281
  tfile = tmp___0->tfile;
#line 282
  __mptr = (struct drm_crtc  const  *)crtc;
#line 282
  du = (struct vmw_display_unit *)__mptr;
#line 283
  surface = 0;
#line 284
  dmabuf = 0;
#line 288
  if (handle != 0U && (width != 64U || height != 64U)) {
#line 289
    return (-22);
  } else {

  }
#line 291
  if (handle != 0U) {
#line 292
    ret = vmw_user_lookup_handle(dev_priv, tfile, handle, & surface, & dmabuf);
#line 294
    if (ret != 0) {
#line 295
      drm_err("vmw_du_crtc_cursor_set", "failed to find surface or dmabuf: %i\n",
              ret);
#line 296
      return (-22);
    } else {

    }
  } else {

  }
#line 301
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0) && (unsigned long )surface->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 302
    drm_err("vmw_du_crtc_cursor_set", "surface not suitable for cursor\n");
#line 303
    vmw_surface_unreference(& surface);
#line 304
    return (-22);
  } else {

  }
#line 308
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 309
    (du->cursor_surface)->snooper.crtc = 0;
#line 310
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 312
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 313
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 316
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 318
    du->cursor_surface = surface;
#line 320
    (du->cursor_surface)->snooper.crtc = crtc;
#line 321
    du->cursor_age = (du->cursor_surface)->snooper.age;
#line 322
    vmw_cursor_update_image(dev_priv, surface->snooper.image, 64U, 64U, (u32 )du->hotspot_x,
                            (u32 )du->hotspot_y);
  } else
#line 324
  if ((unsigned long )dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 326
    du->cursor_dmabuf = dmabuf;
#line 328
    ret = vmw_cursor_update_dmabuf(dev_priv, dmabuf, width, height, (u32 )du->hotspot_x,
                                   (u32 )du->hotspot_y);
  } else {
#line 331
    vmw_cursor_update_position(dev_priv, 0, 0, 0);
#line 332
    return (0);
  }
#line 335
  vmw_cursor_update_position(dev_priv, 1, du->cursor_x + du->hotspot_x, du->cursor_y + du->hotspot_y);
#line 339
  return (0);
}
}
#line 342 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  bool shown ;

  {
#line 344
  tmp = vmw_priv(crtc->dev);
#line 344
  dev_priv = tmp;
#line 345
  __mptr = (struct drm_crtc  const  *)crtc;
#line 345
  du = (struct vmw_display_unit *)__mptr;
#line 346
  shown = (bool )((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0) || (unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0));
#line 348
  du->cursor_x = crtc->x + x;
#line 349
  du->cursor_y = crtc->y + y;
#line 351
  vmw_cursor_update_position(dev_priv, (int )shown, du->cursor_x + du->hotspot_x,
                             du->cursor_y + du->hotspot_y);
#line 355
  return (0);
}
}
#line 358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) 
{ 
  struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  SVGA3dCopyBox *box ;
  unsigned int box_count ;
  void *virtual ;
  bool dummy ;
  struct vmw_dma_cmd *cmd ;
  int i ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 376
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 376
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 379
  if ((unsigned long )srf->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 380
    return;
  } else {

  }
#line 382
  if (cmd->dma.host.face != 0U || cmd->dma.host.mipmap != 0U) {
#line 383
    drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
#line 384
    return;
  } else {

  }
#line 387
  if (cmd->header.size <= 63U) {
#line 388
    drm_err("vmw_kms_cursor_snoop", "at least one full copy box must be given\n");
#line 389
    return;
  } else {

  }
#line 392
  box = (SVGA3dCopyBox *)cmd + 1U;
#line 393
  box_count = (unsigned int )(((unsigned long )cmd->header.size - 28UL) / 36UL);
#line 396
  if (((((((((cmd->dma.guest.ptr.offset & 4095U) != 0U || box->x != 0U) || box->y != 0U) || box->z != 0U) || box->srcx != 0U) || box->srcy != 0U) || box->srcz != 0U) || box->d != 1U) || box_count != 1U) {
#line 403
    drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 404
    drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
            box->srcx, box->srcy, box->srcz, box->x, box->y, box->z, box->w, box->h,
            box->d, box_count, cmd->dma.guest.ptr.offset);
#line 409
    return;
  } else {

  }
#line 412
  kmap_offset = (unsigned long )(cmd->dma.guest.ptr.offset >> 12);
#line 413
  kmap_num = 4UL;
#line 415
  ret = ttm_bo_reserve(bo, 1, 0, 0, 0U);
#line 416
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 416
  if (tmp != 0L) {
#line 417
    drm_err("vmw_kms_cursor_snoop", "reserve failed\n");
#line 418
    return;
  } else {

  }
#line 421
  ret = ttm_bo_kmap(bo, kmap_offset, kmap_num, & map);
#line 422
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 422
  if (tmp___0 != 0L) {
#line 423
    goto err_unreserve;
  } else {

  }
#line 425
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 427
  if (box->w == 64U && cmd->dma.guest.pitch == 256U) {
#line 428
    __len = 16384UL;
#line 428
    if (__len > 63UL) {
#line 428
      __ret = __memcpy((void *)srf->snooper.image, (void const   *)virtual, __len);
    } else {
#line 428
      __ret = __builtin_memcpy((void *)srf->snooper.image, (void const   *)virtual,
                               __len);
    }
  } else {
#line 431
    i = 0;
#line 431
    goto ldv_40912;
    ldv_40911: 
#line 432
    __len___0 = (size_t )(box->w * 4U);
#line 432
    __ret___0 = __builtin_memcpy((void *)srf->snooper.image + (unsigned long )(i * 64),
                                 (void const   *)virtual + (unsigned long )(cmd->dma.guest.pitch * (uint32 )i),
                                 __len___0);
#line 431
    i = i + 1;
    ldv_40912: ;
#line 431
    if ((uint32 )i < box->h) {
#line 432
      goto ldv_40911;
    } else {

    }

  }
#line 437
  srf->snooper.age = srf->snooper.age + 1UL;
#line 448
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 450
  ttm_bo_unreserve(bo);
#line 451
  return;
}
}
#line 453 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 455
  dev = dev_priv->dev;
#line 459
  ldv_mutex_lock_89(& dev->mode_config.mutex);
#line 461
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 461
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 461
  goto ldv_40928;
  ldv_40927: 
#line 462
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 462
  du = (struct vmw_display_unit *)__mptr___0;
#line 463
  if ((unsigned long )du->cursor_surface == (unsigned long )((struct vmw_surface *)0) || du->cursor_age == (du->cursor_surface)->snooper.age) {
#line 465
    goto ldv_40926;
  } else {

  }
#line 467
  du->cursor_age = (du->cursor_surface)->snooper.age;
#line 468
  vmw_cursor_update_image(dev_priv, (du->cursor_surface)->snooper.image, 64U, 64U,
                          (u32 )du->hotspot_x, (u32 )du->hotspot_y);
  ldv_40926: 
#line 461
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 461
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_40928: ;
#line 461
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 462
    goto ldv_40927;
  } else {

  }
#line 473
  ldv_mutex_unlock_90(& dev->mode_config.mutex);
#line 474
  return;
}
}
#line 480 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                  unsigned int *handle ) 
{ 


  {
#line 484
  if ((unsigned long )handle != (unsigned long )((unsigned int *)0)) {
#line 485
    *handle = 0U;
  } else {

  }
#line 487
  return (0);
}
}
#line 505 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer ) 
{ 
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 508
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 508
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 509
  tmp = vmw_master(vfbs->master);
#line 509
  vmaster = tmp;
#line 512
  ldv_mutex_lock_91(& vmaster->fb_surf_mutex);
#line 513
  list_del(& vfbs->head);
#line 514
  ldv_mutex_unlock_92(& vmaster->fb_surf_mutex);
#line 516
  drm_master_put(& vfbs->master);
#line 517
  drm_framebuffer_cleanup(framebuffer);
#line 518
  vmw_surface_unreference(& vfbs->surface);
#line 519
  ttm_base_object_unref(& vfbs->base.user_obj);
#line 521
  kfree((void const   *)vfbs);
#line 522
  return;
}
}
#line 524 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_surface_dirty_sou(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                struct vmw_framebuffer *framebuffer , unsigned int flags ,
                                unsigned int color , struct drm_clip_rect *clips ,
                                unsigned int num_clips , int inc , struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_295 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  int __min1 ;
  int __min2 ;
  int __max1 ;
  int __max2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __max1___0 ;
  int __max2___0 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___7 ;

  {
#line 538
  ret = 0;
#line 547
  num_units = 0;
#line 548
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 548
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 548
  goto ldv_40984;
  ldv_40983: ;
#line 550
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 551
    goto ldv_40980;
  } else {

  }
#line 552
  tmp___0 = num_units;
#line 552
  num_units = num_units + 1;
#line 552
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 552
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_40980: 
#line 548
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 548
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_40984: ;
#line 548
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 549
    goto ldv_40983;
  } else {

  }
#line 555
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 555
  if (tmp___1 != 0L) {
#line 555
    goto _L;
  } else {
#line 555
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 555
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 555
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (555), "i" (12UL));
      ldv_40986: ;
#line 555
      goto ldv_40986;
    } else {

    }
  }
#line 557
  tmp___3 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 557
  tmp = (struct drm_clip_rect *)tmp___3;
#line 558
  tmp___4 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 558
  if (tmp___4 != 0L) {
#line 559
    drm_err("do_surface_dirty_sou", "Temporary cliprect memory alloc failed.\n");
#line 560
    return (-12);
  } else {

  }
#line 563
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 564
  tmp___5 = kzalloc(fifo_size, 208U);
#line 564
  cmd = (struct __anonstruct_297 *)tmp___5;
#line 565
  tmp___6 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_295 *)0),
                             0L);
#line 565
  if (tmp___6 != 0L) {
#line 566
    drm_err("do_surface_dirty_sou", "Temporary fifo memory alloc failed.\n");
#line 567
    ret = -12;
#line 568
    goto out_free_tmp;
  } else {

  }
#line 572
  blits = (SVGASignedRect *)cmd + 1U;
#line 575
  left = (int )clips->x1;
#line 576
  right = (int )clips->x2;
#line 577
  top = (int )clips->y1;
#line 578
  bottom = (int )clips->y2;
#line 581
  i = 1;
#line 581
  clips_ptr = clips + (unsigned long )inc;
#line 581
  goto ldv_41002;
  ldv_41001: 
#line 583
  __min1 = left;
#line 583
  __min2 = (int )clips_ptr->x1;
#line 583
  left = __min1 < __min2 ? __min1 : __min2;
#line 584
  __max1 = right;
#line 584
  __max2 = (int )clips_ptr->x2;
#line 584
  right = __max1 > __max2 ? __max1 : __max2;
#line 585
  __min1___0 = top;
#line 585
  __min2___0 = (int )clips_ptr->y1;
#line 585
  top = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 586
  __max1___0 = bottom;
#line 586
  __max2___0 = (int )clips_ptr->y2;
#line 586
  bottom = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 582
  i = i + 1;
#line 582
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_41002: ;
#line 581
  if ((unsigned int )i < num_clips) {
#line 583
    goto ldv_41001;
  } else {

  }
#line 590
  cmd->header.id = 1069U;
#line 591
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 593
  cmd->body.srcRect.left = left;
#line 594
  cmd->body.srcRect.right = right;
#line 595
  cmd->body.srcRect.top = top;
#line 596
  cmd->body.srcRect.bottom = bottom;
#line 598
  clips_ptr = clips;
#line 599
  i = 0;
#line 599
  goto ldv_41005;
  ldv_41004: 
#line 600
  (tmp + (unsigned long )i)->x1 = (int )clips_ptr->x1 - (int )((unsigned short )left);
#line 601
  (tmp + (unsigned long )i)->x2 = (int )clips_ptr->x2 - (int )((unsigned short )left);
#line 602
  (tmp + (unsigned long )i)->y1 = (int )clips_ptr->y1 - (int )((unsigned short )top);
#line 603
  (tmp + (unsigned long )i)->y2 = (int )clips_ptr->y2 - (int )((unsigned short )top);
#line 599
  i = i + 1;
#line 599
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_41005: ;
#line 599
  if ((unsigned int )i < num_clips) {
#line 600
    goto ldv_41004;
  } else {

  }
#line 607
  i = 0;
#line 607
  goto ldv_41013;
  ldv_41012: 
#line 608
  unit = units[i];
#line 612
  clip.x1 = left - unit->crtc.x;
#line 613
  clip.y1 = top - unit->crtc.y;
#line 614
  clip.x2 = right - unit->crtc.x;
#line 615
  clip.y2 = bottom - unit->crtc.y;
#line 618
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 621
    goto ldv_41010;
  } else {

  }
#line 627
  cmd->body.destRect.left = clip.x1;
#line 628
  cmd->body.destRect.right = clip.x2;
#line 629
  cmd->body.destRect.top = clip.y1;
#line 630
  cmd->body.destRect.bottom = clip.y2;
#line 633
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 634
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 635
  clip.x1 = - clip.x1;
#line 636
  clip.y1 = - clip.y1;
#line 639
  cmd->body.srcImage.sid = framebuffer->user_handle;
#line 640
  cmd->body.destScreenId = unit->unit;
#line 643
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 646
  if (num == 0) {
#line 647
    goto ldv_41010;
  } else {

  }
#line 650
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 651
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 654
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 655
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 656
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 659
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 659
  if (tmp___7 != 0L) {
#line 660
    goto ldv_41011;
  } else {

  }
  ldv_41010: 
#line 607
  i = i + 1;
  ldv_41013: ;
#line 607
  if (i < num_units) {
#line 608
    goto ldv_41012;
  } else {

  }
  ldv_41011: 
#line 664
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 666
  kfree((void const   *)tmp);
#line 668
  return (ret);
}
}
#line 671 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                  unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                  unsigned int num_clips ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int inc ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 677
  tmp = vmw_priv(framebuffer->dev);
#line 677
  dev_priv = tmp;
#line 678
  tmp___0 = vmw_master(file_priv->master);
#line 678
  vmaster = tmp___0;
#line 680
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 680
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 682
  inc = 1;
#line 684
  tmp___1 = ldv__builtin_expect((unsigned long )vfbs->master != (unsigned long )file_priv->master,
                             0L);
#line 684
  if (tmp___1 != 0L) {
#line 685
    return (-22);
  } else {

  }
#line 688
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 689
    return (-22);
  } else {

  }
#line 691
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 692
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 692
  if (tmp___2 != 0L) {
#line 693
    return (ret);
  } else {

  }
#line 695
  if (num_clips == 0U) {
#line 696
    num_clips = 1U;
#line 697
    clips = & norect;
#line 698
    norect.y1 = 0U;
#line 698
    norect.x1 = norect.y1;
#line 699
    norect.x2 = (unsigned short )framebuffer->width;
#line 700
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 701
  if ((int )flags & 1) {
#line 702
    num_clips = num_clips / 2U;
#line 703
    inc = 2;
  } else {

  }
#line 706
  ret = do_surface_dirty_sou(dev_priv, file_priv, & vfbs->base, flags, color, clips,
                             num_clips, inc, 0);
#line 710
  ttm_read_unlock(& vmaster->lock);
#line 711
  return (0);
}
}
#line 714 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs  =    {& vmw_framebuffer_surface_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_surface_dirty};
#line 720 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                           struct vmw_surface *surface , struct vmw_framebuffer **out ,
                                           struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ 
  struct drm_device *dev ;
  struct vmw_framebuffer_surface *vfbs ;
  enum SVGA3dSurfaceFormat format ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  struct vmw_surface *tmp___11 ;

  {
#line 728
  dev = dev_priv->dev;
#line 731
  tmp = vmw_master(file_priv->master);
#line 731
  vmaster = tmp;
#line 735
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 736
    return (-38);
  } else {

  }
#line 743
  tmp___0 = ldv__builtin_expect((long )(! surface->scanout), 0L);
#line 743
  if (tmp___0 != 0L) {
#line 744
    return (-22);
  } else {

  }
#line 746
  tmp___1 = ldv__builtin_expect(surface->mip_levels[0] != 1U, 0L);
#line 746
  if (tmp___1 != 0L) {
#line 746
    tmp___3 = 1;
  } else {
#line 746
    tmp___2 = ldv__builtin_expect(surface->num_sizes != 1U, 0L);
#line 746
    if (tmp___2 != 0L) {
#line 746
      tmp___3 = 1;
    } else {
#line 746
      tmp___3 = 0;
    }
  }
#line 746
  if (tmp___3 != 0) {
#line 746
    tmp___5 = 1;
  } else {
#line 746
    tmp___4 = ldv__builtin_expect((surface->sizes)->width < (uint32_t )mode_cmd->width,
                               0L);
#line 746
    if (tmp___4 != 0L) {
#line 746
      tmp___5 = 1;
    } else {
#line 746
      tmp___5 = 0;
    }
  }
#line 746
  if (tmp___5 != 0) {
#line 746
    tmp___7 = 1;
  } else {
#line 746
    tmp___6 = ldv__builtin_expect((surface->sizes)->height < (uint32_t )mode_cmd->height,
                               0L);
#line 746
    if (tmp___6 != 0L) {
#line 746
      tmp___7 = 1;
    } else {
#line 746
      tmp___7 = 0;
    }
  }
#line 746
  if (tmp___7 != 0) {
#line 751
    drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 753
    return (-22);
  } else {
#line 746
    tmp___8 = ldv__builtin_expect((surface->sizes)->depth != 1U, 0L);
#line 746
    if (tmp___8 != 0L) {
#line 751
      drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 753
      return (-22);
    } else {

    }
  }
#line 756
  switch (mode_cmd->depth) {
  case 32U: 
#line 758
  format = 2;
#line 759
  goto ldv_41045;
  case 24U: 
#line 761
  format = 1;
#line 762
  goto ldv_41045;
  case 16U: 
#line 764
  format = 3;
#line 765
  goto ldv_41045;
  case 15U: 
#line 767
  format = 5;
#line 768
  goto ldv_41045;
  case 8U: 
#line 770
  format = 11;
#line 771
  goto ldv_41045;
  default: 
#line 773
  drm_err("vmw_kms_new_framebuffer_surface", "Invalid color depth: %d\n", mode_cmd->depth);
#line 774
  return (-22);
  }
  ldv_41045: 
#line 777
  tmp___9 = ldv__builtin_expect(surface->format != (unsigned int )format, 0L);
#line 777
  if (tmp___9 != 0L) {
#line 778
    drm_err("vmw_kms_new_framebuffer_surface", "Invalid surface format for requested mode.\n");
#line 779
    return (-22);
  } else {

  }
#line 782
  tmp___10 = kzalloc(216UL, 208U);
#line 782
  vfbs = (struct vmw_framebuffer_surface *)tmp___10;
#line 783
  if ((unsigned long )vfbs == (unsigned long )((struct vmw_framebuffer_surface *)0)) {
#line 784
    ret = -12;
#line 785
    goto out_err1;
  } else {

  }
#line 788
  ret = drm_framebuffer_init(dev, & vfbs->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_surface_funcs));
#line 790
  if (ret != 0) {
#line 791
    goto out_err2;
  } else {

  }
#line 793
  tmp___11 = vmw_surface_reference(surface);
#line 793
  if ((unsigned long )tmp___11 == (unsigned long )((struct vmw_surface *)0)) {
#line 794
    drm_err("vmw_kms_new_framebuffer_surface", "failed to reference surface %p\n",
            surface);
#line 795
    goto out_err3;
  } else {

  }
#line 799
  vfbs->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 800
  vfbs->base.base.pitches[0] = mode_cmd->pitch;
#line 801
  vfbs->base.base.depth = mode_cmd->depth;
#line 802
  vfbs->base.base.width = mode_cmd->width;
#line 803
  vfbs->base.base.height = mode_cmd->height;
#line 804
  vfbs->surface = surface;
#line 805
  vfbs->base.user_handle = mode_cmd->handle;
#line 806
  vfbs->master = drm_master_get(file_priv->master);
#line 808
  ldv_mutex_lock_93(& vmaster->fb_surf_mutex);
#line 809
  list_add_tail(& vfbs->head, & vmaster->fb_surf);
#line 810
  ldv_mutex_unlock_94(& vmaster->fb_surf_mutex);
#line 812
  *out = & vfbs->base;
#line 814
  return (0);
  out_err3: 
#line 817
  drm_framebuffer_cleanup(& vfbs->base.base);
  out_err2: 
#line 819
  kfree((void const   *)vfbs);
  out_err1: ;
#line 821
  return (ret);
}
}
#line 836 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer ) 
{ 
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;

  {
#line 839
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 839
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 841
  drm_framebuffer_cleanup(framebuffer);
#line 842
  vmw_dmabuf_unreference(& vfbd->buffer);
#line 843
  ttm_base_object_unref(& vfbd->base.user_obj);
#line 845
  kfree((void const   *)vfbd);
#line 846
  return;
}
}
#line 848 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv , struct vmw_framebuffer *framebuffer ,
                               unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment ) 
{ 
  size_t fifo_size ;
  int i ;
  struct __anonstruct_cmd_299 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 862
  fifo_size = (unsigned long )num_clips * 20UL;
#line 863
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 863
  cmd = (struct __anonstruct_301 *)tmp;
#line 864
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_299 *)0),
                             0L);
#line 864
  if (tmp___0 != 0L) {
#line 865
    drm_err("do_dmabuf_dirty_ldu", "Fifo reserve failed.\n");
#line 866
    return (-12);
  } else {

  }
#line 869
  memset((void *)cmd, 0, fifo_size);
#line 870
  i = 0;
#line 870
  goto ldv_41080;
  ldv_41079: 
#line 871
  (cmd + (unsigned long )i)->header = 1U;
#line 872
  (cmd + (unsigned long )i)->body.x = (unsigned int )clips->x1;
#line 873
  (cmd + (unsigned long )i)->body.y = (unsigned int )clips->y1;
#line 874
  (cmd + (unsigned long )i)->body.width = (unsigned int )((int )clips->x2 - (int )clips->x1);
#line 875
  (cmd + (unsigned long )i)->body.height = (unsigned int )((int )clips->y2 - (int )clips->y1);
#line 870
  i = i + 1;
#line 870
  clips = clips + (unsigned long )increment;
  ldv_41080: ;
#line 870
  if ((unsigned int )i < num_clips) {
#line 871
    goto ldv_41079;
  } else {

  }
#line 878
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 879
  return (0);
}
}
#line 882 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_define_gmrfb(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                                  struct vmw_framebuffer *framebuffer ) 
{ 
  int depth ;
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_303 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 886
  depth = (int )framebuffer->base.depth;
#line 899
  if (depth == 32) {
#line 900
    depth = 24;
  } else {

  }
#line 902
  fifo_size = 20UL;
#line 903
  tmp = kmalloc(fifo_size, 208U);
#line 903
  cmd = (struct __anonstruct_305 *)tmp;
#line 904
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_303 *)0),
                             0L);
#line 904
  if (tmp___0 != 0L) {
#line 905
    drm_err("do_dmabuf_define_gmrfb", "Failed to allocate temporary cmd buffer.\n");
#line 906
    return (-12);
  } else {

  }
#line 909
  memset((void *)cmd, 0, fifo_size);
#line 910
  cmd->header = 36U;
#line 911
  cmd->body.format.ldv_6386.ldv_6384.bitsPerPixel = (unsigned char )framebuffer->base.bits_per_pixel;
#line 912
  cmd->body.format.ldv_6386.ldv_6384.colorDepth = (unsigned char )depth;
#line 913
  cmd->body.format.ldv_6386.ldv_6384.reserved = 0U;
#line 914
  cmd->body.bytesPerLine = framebuffer->base.pitches[0];
#line 915
  cmd->body.ptr.gmrId = framebuffer->user_handle;
#line 916
  cmd->body.ptr.offset = 0U;
#line 918
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 921
  kfree((void const   *)cmd);
#line 923
  return (ret);
}
}
#line 926 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_sou(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_framebuffer *framebuffer , unsigned int flags ,
                               unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment , struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  struct __anonstruct_blits_307 *blits ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  int tmp___2 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct vmw_display_unit *unit ;
  int hit_num ;
  int clip_x1 ;
  int clip_y1 ;
  int clip_x2 ;
  int clip_y2 ;
  int move_x ;
  int move_y ;
  int __min1 ;
  int __min2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __min1___1 ;
  int __min2___1 ;
  int __min1___2 ;
  int __min2___2 ;
  long tmp___3 ;

  {
#line 945
  ret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);
#line 946
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 946
  if (tmp != 0L) {
#line 947
    return (ret);
  } else {

  }
#line 949
  fifo_size = (unsigned long )num_clips * 32UL;
#line 950
  tmp___0 = kmalloc(fifo_size, 208U);
#line 950
  blits = (struct __anonstruct_309 *)tmp___0;
#line 951
  tmp___1 = ldv__builtin_expect((unsigned long )blits == (unsigned long )((struct __anonstruct_blits_307 *)0),
                             0L);
#line 951
  if (tmp___1 != 0L) {
#line 952
    drm_err("do_dmabuf_dirty_sou", "Failed to allocate temporary cmd buffer.\n");
#line 953
    return (-12);
  } else {

  }
#line 956
  num_units = 0;
#line 957
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 957
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 957
  goto ldv_41127;
  ldv_41126: ;
#line 958
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 959
    goto ldv_41123;
  } else {

  }
#line 960
  tmp___2 = num_units;
#line 960
  num_units = num_units + 1;
#line 960
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 960
  units[tmp___2] = (struct vmw_display_unit *)__mptr___0;
  ldv_41123: 
#line 957
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 957
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41127: ;
#line 957
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 958
    goto ldv_41126;
  } else {

  }
#line 963
  k = 0;
#line 963
  goto ldv_41156;
  ldv_41155: 
#line 964
  unit = units[k];
#line 965
  hit_num = 0;
#line 967
  clips_ptr = clips;
#line 968
  i = 0;
#line 968
  goto ldv_41151;
  ldv_41150: 
#line 969
  clip_x1 = (int )clips_ptr->x1 - unit->crtc.x;
#line 970
  clip_y1 = (int )clips_ptr->y1 - unit->crtc.y;
#line 971
  clip_x2 = (int )clips_ptr->x2 - unit->crtc.x;
#line 972
  clip_y2 = (int )clips_ptr->y2 - unit->crtc.y;
#line 976
  if (((unit->crtc.mode.hdisplay <= clip_x1 || unit->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 979
    goto ldv_41137;
  } else {

  }
#line 982
  __min1 = clip_x2;
#line 982
  __min2 = unit->crtc.mode.hdisplay;
#line 982
  clip_x2 = __min1 < __min2 ? __min1 : __min2;
#line 983
  __min1___0 = clip_y2;
#line 983
  __min2___0 = unit->crtc.mode.vdisplay;
#line 983
  clip_y2 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 986
  __min1___1 = clip_x1;
#line 986
  __min2___1 = 0;
#line 986
  move_x = __min1___1 < __min2___1 ? __min1___1 : __min2___1;
#line 987
  __min1___2 = clip_y1;
#line 987
  __min2___2 = 0;
#line 987
  move_y = __min1___2 < __min2___2 ? __min1___2 : __min2___2;
#line 990
  (blits + (unsigned long )hit_num)->header = 37U;
#line 991
  (blits + (unsigned long )hit_num)->body.destScreenId = unit->unit;
#line 992
  (blits + (unsigned long )hit_num)->body.srcOrigin.x = (int )clips_ptr->x1 - move_x;
#line 993
  (blits + (unsigned long )hit_num)->body.srcOrigin.y = (int )clips_ptr->y1 - move_y;
#line 994
  (blits + (unsigned long )hit_num)->body.destRect.left = clip_x1 - move_x;
#line 995
  (blits + (unsigned long )hit_num)->body.destRect.top = clip_y1 - move_y;
#line 996
  (blits + (unsigned long )hit_num)->body.destRect.right = clip_x2;
#line 997
  (blits + (unsigned long )hit_num)->body.destRect.bottom = clip_y2;
#line 998
  hit_num = hit_num + 1;
  ldv_41137: 
#line 968
  i = i + 1;
#line 968
  clips_ptr = clips_ptr + (unsigned long )increment;
  ldv_41151: ;
#line 968
  if ((unsigned int )i < num_clips) {
#line 969
    goto ldv_41150;
  } else {

  }

#line 1002
  if (hit_num == 0) {
#line 1003
    goto ldv_41153;
  } else {

  }
#line 1006
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1007
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 1009
  fifo_size = (unsigned long )hit_num * 32UL;
#line 1010
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)blits, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 1013
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1013
  if (tmp___3 != 0L) {
#line 1014
    goto ldv_41154;
  } else {

  }
  ldv_41153: 
#line 963
  k = k + 1;
  ldv_41156: ;
#line 963
  if (k < num_units) {
#line 964
    goto ldv_41155;
  } else {

  }
  ldv_41154: 
#line 1017
  kfree((void const   *)blits);
#line 1019
  return (ret);
}
}
#line 1022 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                 unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                 unsigned int num_clips ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int increment ;
  long tmp___1 ;

  {
#line 1028
  tmp = vmw_priv(framebuffer->dev);
#line 1028
  dev_priv = tmp;
#line 1029
  tmp___0 = vmw_master(file_priv->master);
#line 1029
  vmaster = tmp___0;
#line 1031
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 1031
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1033
  increment = 1;
#line 1035
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1036
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1036
  if (tmp___1 != 0L) {
#line 1037
    return (ret);
  } else {

  }
#line 1039
  if (num_clips == 0U) {
#line 1040
    num_clips = 1U;
#line 1041
    clips = & norect;
#line 1042
    norect.y1 = 0U;
#line 1042
    norect.x1 = norect.y1;
#line 1043
    norect.x2 = (unsigned short )framebuffer->width;
#line 1044
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 1045
  if ((int )flags & 1) {
#line 1046
    num_clips = num_clips / 2U;
#line 1047
    increment = 2;
  } else {

  }
#line 1050
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 1051
    ret = do_dmabuf_dirty_ldu(dev_priv, & vfbd->base, flags, color, clips, num_clips,
                              increment);
  } else {
#line 1055
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, & vfbd->base, flags, color, clips,
                              num_clips, increment, 0);
  }
#line 1060
  ttm_read_unlock(& vmaster->lock);
#line 1061
  return (ret);
}
}
#line 1064 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_dmabuf_funcs  =    {& vmw_framebuffer_dmabuf_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_dmabuf_dirty};
#line 1073 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int ret ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 1075
  tmp = vmw_priv(vfb->base.dev);
#line 1075
  dev_priv = tmp;
#line 1077
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1077
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1081
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 1081
  if (tmp___0 != 0L) {
#line 1081
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1081), "i" (12UL));
    ldv_41182: ;
#line 1081
    goto ldv_41182;
  } else {

  }
#line 1083
  vmw_overlay_pause_all(dev_priv);
#line 1085
  ret = vmw_dmabuf_to_start_of_vram(dev_priv, vfbd->buffer, 1, 0);
#line 1087
  vmw_overlay_resume_all(dev_priv);
#line 1089
  __ret_warn_on = ret != 0;
#line 1089
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1089
  if (tmp___1 != 0L) {
#line 1089
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                       1089);
  } else {

  }
#line 1089
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1091
  return (0);
}
}
#line 1094 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1096
  tmp = vmw_priv(vfb->base.dev);
#line 1096
  dev_priv = tmp;
#line 1098
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1098
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1100
  if ((unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1101
    __ret_warn_on = (unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0);
#line 1101
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1101
    if (tmp___0 != 0L) {
#line 1101
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                         1101);
    } else {

    }
#line 1101
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1102
    return (0);
  } else {

  }
#line 1105
  tmp___1 = vmw_dmabuf_unpin(dev_priv, vfbd->buffer, 0);
#line 1105
  return (tmp___1);
}
}
#line 1108 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                                          struct vmw_framebuffer **out , struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ 
  struct drm_device *dev ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  unsigned int requested_size ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  struct vmw_dma_buffer *tmp___1 ;

  {
#line 1115
  dev = dev_priv->dev;
#line 1120
  requested_size = (unsigned int )mode_cmd->height * (unsigned int )mode_cmd->pitch;
#line 1121
  tmp = ldv__builtin_expect((unsigned long )requested_size > dmabuf->base.num_pages * 4096UL,
                         0L);
#line 1121
  if (tmp != 0L) {
#line 1122
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Screen buffer object size is too small for requested mode.\n");
#line 1124
    return (-22);
  } else {

  }
#line 1128
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1129
    switch (mode_cmd->depth) {
    case 32U: ;
    case 24U: ;
#line 1133
    if ((unsigned int )mode_cmd->bpp == 32U) {
#line 1134
      goto ldv_41207;
    } else {

    }
#line 1136
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1138
    return (-22);
    case 16U: ;
    case 15U: ;
#line 1142
    if ((unsigned int )mode_cmd->bpp == 16U) {
#line 1143
      goto ldv_41207;
    } else {

    }
#line 1145
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1147
    return (-22);
    default: 
#line 1149
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth: %d\n", mode_cmd->depth);
#line 1150
    return (-22);
    }
    ldv_41207: ;
  } else {

  }
#line 1154
  tmp___0 = kzalloc(184UL, 208U);
#line 1154
  vfbd = (struct vmw_framebuffer_dmabuf *)tmp___0;
#line 1155
  if ((unsigned long )vfbd == (unsigned long )((struct vmw_framebuffer_dmabuf *)0)) {
#line 1156
    ret = -12;
#line 1157
    goto out_err1;
  } else {

  }
#line 1160
  ret = drm_framebuffer_init(dev, & vfbd->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_dmabuf_funcs));
#line 1162
  if (ret != 0) {
#line 1163
    goto out_err2;
  } else {

  }
#line 1165
  tmp___1 = vmw_dmabuf_reference(dmabuf);
#line 1165
  if ((unsigned long )tmp___1 == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1166
    drm_err("vmw_kms_new_framebuffer_dmabuf", "failed to reference dmabuf %p\n", dmabuf);
#line 1167
    goto out_err3;
  } else {

  }
#line 1170
  vfbd->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 1171
  vfbd->base.base.pitches[0] = mode_cmd->pitch;
#line 1172
  vfbd->base.base.depth = mode_cmd->depth;
#line 1173
  vfbd->base.base.width = mode_cmd->width;
#line 1174
  vfbd->base.base.height = mode_cmd->height;
#line 1175
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1176
    vfbd->base.pin = & vmw_framebuffer_dmabuf_pin;
#line 1177
    vfbd->base.unpin = & vmw_framebuffer_dmabuf_unpin;
  } else {

  }
#line 1179
  vfbd->base.dmabuf = 1;
#line 1180
  vfbd->buffer = dmabuf;
#line 1181
  vfbd->base.user_handle = mode_cmd->handle;
#line 1182
  *out = & vfbd->base;
#line 1184
  return (0);
  out_err3: 
#line 1187
  drm_framebuffer_cleanup(& vfbd->base.base);
  out_err2: 
#line 1189
  kfree((void const   *)vfbd);
  out_err1: ;
#line 1191
  return (ret);
}
}
#line 1198 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev , struct drm_file *file_priv ,
                                                 struct drm_mode_fb_cmd2 *mode_cmd2 ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_framebuffer *vfb ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *bo ;
  struct ttm_base_object *user_obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  int ret ;
  void *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;

  {
#line 1202
  tmp = vmw_priv(dev);
#line 1202
  dev_priv = tmp;
#line 1203
  tmp___0 = vmw_fpriv(file_priv);
#line 1203
  tfile = tmp___0->tfile;
#line 1204
  vfb = 0;
#line 1205
  surface = 0;
#line 1206
  bo = 0;
#line 1211
  mode_cmd.width = mode_cmd2->width;
#line 1212
  mode_cmd.height = mode_cmd2->height;
#line 1213
  mode_cmd.pitch = mode_cmd2->pitches[0];
#line 1214
  mode_cmd.handle = mode_cmd2->handles[0];
#line 1215
  drm_fb_get_bpp_depth(mode_cmd2->pixel_format, & mode_cmd.depth, (int *)(& mode_cmd.bpp));
#line 1224
  tmp___2 = vmw_kms_validate_mode_vram(dev_priv, mode_cmd.pitch, mode_cmd.height);
#line 1224
  if (tmp___2) {
#line 1224
    tmp___3 = 0;
  } else {
#line 1224
    tmp___3 = 1;
  }
#line 1224
  if (tmp___3) {
#line 1227
    drm_err("vmw_kms_fb_create", "VRAM size is too small for requested mode.\n");
#line 1228
    tmp___1 = ERR_PTR(-12L);
#line 1228
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
#line 1240
  user_obj = ttm_base_object_lookup(tfile, mode_cmd.handle);
#line 1241
  tmp___5 = ldv__builtin_expect((unsigned long )user_obj == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 1241
  if (tmp___5 != 0L) {
#line 1242
    drm_err("vmw_kms_fb_create", "Could not locate requested kms frame buffer.\n");
#line 1243
    tmp___4 = ERR_PTR(-2L);
#line 1243
    return ((struct drm_framebuffer *)tmp___4);
  } else {

  }
#line 1251
  ret = vmw_user_lookup_handle(dev_priv, tfile, mode_cmd.handle, & surface, & bo);
#line 1254
  if (ret != 0) {
#line 1255
    goto err_out;
  } else {

  }
#line 1258
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1259
    ret = vmw_kms_new_framebuffer_dmabuf(dev_priv, bo, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else
#line 1261
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1262
    ret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, surface, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else {
#line 1265
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1265), "i" (12UL));
    ldv_41229: ;
#line 1265
    goto ldv_41229;
  }
  err_out: ;
#line 1269
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1270
    vmw_dmabuf_unreference(& bo);
  } else {

  }
#line 1271
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1272
    vmw_surface_unreference(& surface);
  } else {

  }
#line 1274
  if (ret != 0) {
#line 1275
    drm_err("vmw_kms_fb_create", "failed to create vmw_framebuffer: %i\n", ret);
#line 1276
    ttm_base_object_unref(& user_obj);
#line 1277
    tmp___6 = ERR_PTR((long )ret);
#line 1277
    return ((struct drm_framebuffer *)tmp___6);
  } else {
#line 1279
    vfb->user_obj = user_obj;
  }
#line 1281
  return (& vfb->base);
}
}
#line 1284 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_mode_config_funcs  const  vmw_kms_funcs  =    {& vmw_kms_fb_create, 0};
#line 1288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_311 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int __min1 ;
  int __min2 ;
  int __max1 ;
  int __max2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __max1___0 ;
  int __max2___0 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___8 ;

  {
#line 1302
  ret = 0;
#line 1311
  num_units = 0;
#line 1312
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1312
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1312
  goto ldv_41267;
  ldv_41266: ;
#line 1313
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1314
    goto ldv_41263;
  } else {

  }
#line 1315
  tmp___0 = num_units;
#line 1315
  num_units = num_units + 1;
#line 1315
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1315
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_41263: 
#line 1312
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1312
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41267: ;
#line 1312
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1313
    goto ldv_41266;
  } else {

  }
#line 1318
  tmp___1 = ldv__builtin_expect((unsigned long )surface == (unsigned long )((struct vmw_surface *)0),
                             0L);
#line 1318
  if (tmp___1 != 0L) {
#line 1318
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1318), "i" (12UL));
    ldv_41269: ;
#line 1318
    goto ldv_41269;
  } else {

  }
#line 1319
  tmp___2 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1319
  if (tmp___2 != 0L) {
#line 1319
    goto _L;
  } else {
#line 1319
    tmp___3 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1319
    if (tmp___3 != 0L) {
      _L: /* CIL Label */ 
#line 1319
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1319), "i" (12UL));
      ldv_41270: ;
#line 1319
      goto ldv_41270;
    } else {

    }
  }
#line 1321
  tmp___4 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 1321
  tmp = (struct drm_clip_rect *)tmp___4;
#line 1322
  tmp___5 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 1322
  if (tmp___5 != 0L) {
#line 1323
    drm_err("vmw_kms_present", "Temporary cliprect memory alloc failed.\n");
#line 1324
    return (-12);
  } else {

  }
#line 1327
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 1328
  tmp___6 = kmalloc(fifo_size, 208U);
#line 1328
  cmd = (struct __anonstruct_313 *)tmp___6;
#line 1329
  tmp___7 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_311 *)0),
                             0L);
#line 1329
  if (tmp___7 != 0L) {
#line 1330
    drm_err("vmw_kms_present", "Failed to allocate temporary fifo memory.\n");
#line 1331
    ret = -12;
#line 1332
    goto out_free_tmp;
  } else {

  }
#line 1335
  left = clips->x;
#line 1336
  right = (int )((uint32_t )clips->x + clips->w);
#line 1337
  top = clips->y;
#line 1338
  bottom = (int )((uint32_t )clips->y + clips->h);
#line 1340
  i = 1;
#line 1340
  goto ldv_41286;
  ldv_41285: 
#line 1341
  __min1 = left;
#line 1341
  __min2 = (clips + (unsigned long )i)->x;
#line 1341
  left = __min1 < __min2 ? __min1 : __min2;
#line 1342
  __max1 = right;
#line 1342
  __max2 = (int )((uint32_t )(clips + (unsigned long )i)->x + (clips + (unsigned long )i)->w);
#line 1342
  right = __max1 > __max2 ? __max1 : __max2;
#line 1343
  __min1___0 = top;
#line 1343
  __min2___0 = (clips + (unsigned long )i)->y;
#line 1343
  top = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 1344
  __max1___0 = bottom;
#line 1344
  __max2___0 = (int )((uint32_t )(clips + (unsigned long )i)->y + (clips + (unsigned long )i)->h);
#line 1344
  bottom = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 1340
  i = i + 1;
  ldv_41286: ;
#line 1340
  if ((uint32_t )i < num_clips) {
#line 1341
    goto ldv_41285;
  } else {

  }
#line 1348
  memset((void *)cmd, 0, fifo_size);
#line 1349
  cmd->header.id = 1069U;
#line 1351
  blits = (SVGASignedRect *)cmd + 1U;
#line 1353
  cmd->body.srcRect.left = left;
#line 1354
  cmd->body.srcRect.right = right;
#line 1355
  cmd->body.srcRect.top = top;
#line 1356
  cmd->body.srcRect.bottom = bottom;
#line 1358
  i = 0;
#line 1358
  goto ldv_41289;
  ldv_41288: 
#line 1359
  (tmp + (unsigned long )i)->x1 = (int )((unsigned short )(clips + (unsigned long )i)->x) - (int )((unsigned short )left);
#line 1360
  (tmp + (unsigned long )i)->x2 = ((int )((unsigned short )(clips + (unsigned long )i)->x) + (int )((unsigned short )(clips + (unsigned long )i)->w)) - (int )((unsigned short )left);
#line 1361
  (tmp + (unsigned long )i)->y1 = (int )((unsigned short )(clips + (unsigned long )i)->y) - (int )((unsigned short )top);
#line 1362
  (tmp + (unsigned long )i)->y2 = ((int )((unsigned short )(clips + (unsigned long )i)->y) + (int )((unsigned short )(clips + (unsigned long )i)->h)) - (int )((unsigned short )top);
#line 1358
  i = i + 1;
  ldv_41289: ;
#line 1358
  if ((uint32_t )i < num_clips) {
#line 1359
    goto ldv_41288;
  } else {

  }
#line 1365
  k = 0;
#line 1365
  goto ldv_41297;
  ldv_41296: 
#line 1366
  unit = units[k];
#line 1370
  clip.x1 = (left + destX) - unit->crtc.x;
#line 1371
  clip.y1 = (top + destY) - unit->crtc.y;
#line 1372
  clip.x2 = (right + destX) - unit->crtc.x;
#line 1373
  clip.y2 = (bottom + destY) - unit->crtc.y;
#line 1376
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 1379
    goto ldv_41294;
  } else {

  }
#line 1385
  cmd->body.destRect.left = clip.x1;
#line 1386
  cmd->body.destRect.right = clip.x2;
#line 1387
  cmd->body.destRect.top = clip.y1;
#line 1388
  cmd->body.destRect.bottom = clip.y2;
#line 1391
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 1392
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 1393
  clip.x1 = - clip.x1;
#line 1394
  clip.y1 = - clip.y1;
#line 1397
  cmd->body.srcImage.sid = sid;
#line 1398
  cmd->body.destScreenId = unit->unit;
#line 1401
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 1404
  if (num == 0) {
#line 1405
    goto ldv_41294;
  } else {

  }
#line 1408
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 1409
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 1410
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 1413
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 1413
  if (tmp___8 != 0L) {
#line 1414
    goto ldv_41295;
  } else {

  }
  ldv_41294: 
#line 1365
  k = k + 1;
  ldv_41297: ;
#line 1365
  if (k < num_units) {
#line 1366
    goto ldv_41296;
  } else {

  }
  ldv_41295: 
#line 1417
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 1419
  kfree((void const   *)tmp);
#line 1421
  return (ret);
}
}
#line 1424 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) 
{ 
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_dma_buffer *dmabuf ;
  struct vmw_display_unit *units[8U] ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int ret ;
  int num_units ;
  int blits_pos ;
  struct __anonstruct_cmd_315 *cmd ;
  struct __anonstruct_blits_317 *blits ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct drm_crtc  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  struct drm_vmw_rect *c ;
  int clip_x1 ;
  int clip_x2 ;
  int clip_y1 ;
  int clip_y2 ;
  int dest_x ;
  int dest_y ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int _min1 ;
  int _min2 ;
  int _min1___0 ;
  int _min2___0 ;

  {
#line 1432
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1432
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1433
  dmabuf = vfbd->buffer;
#line 1448
  num_units = 0;
#line 1449
  __mptr___0 = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1449
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
#line 1449
  goto ldv_41334;
  ldv_41333: ;
#line 1450
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1451
    goto ldv_41330;
  } else {

  }
#line 1452
  tmp = num_units;
#line 1452
  num_units = num_units + 1;
#line 1452
  __mptr___1 = (struct drm_crtc  const  *)crtc;
#line 1452
  units[tmp] = (struct vmw_display_unit *)__mptr___1;
  ldv_41330: 
#line 1449
  __mptr___2 = (struct list_head  const  *)crtc->head.next;
#line 1449
  crtc = (struct drm_crtc *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_41334: ;
#line 1449
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1450
    goto ldv_41333;
  } else {

  }
#line 1455
  tmp___0 = ldv__builtin_expect((unsigned long )dmabuf == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1455
  if (tmp___0 != 0L) {
#line 1455
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1455), "i" (12UL));
    ldv_41336: ;
#line 1455
    goto ldv_41336;
  } else {

  }
#line 1456
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1456
  if (tmp___1 != 0L) {
#line 1456
    goto _L;
  } else {
#line 1456
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1456
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 1456
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1456), "i" (12UL));
      ldv_41337: ;
#line 1456
      goto ldv_41337;
    } else {

    }
  }
#line 1459
  fifo_size = ((unsigned long )num_clips * (unsigned long )num_units) * 32UL + 20UL;
#line 1460
  tmp___3 = kmalloc(fifo_size, 208U);
#line 1460
  cmd = (struct __anonstruct_319 *)tmp___3;
#line 1461
  tmp___4 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_315 *)0),
                             0L);
#line 1461
  if (tmp___4 != 0L) {
#line 1462
    drm_err("vmw_kms_readback", "Failed to allocate temporary fifo memory.\n");
#line 1463
    return (-12);
  } else {

  }
#line 1466
  memset((void *)cmd, 0, fifo_size);
#line 1467
  cmd->header = 36U;
#line 1468
  cmd->body.format.ldv_6386.ldv_6384.bitsPerPixel = (unsigned char )vfb->base.bits_per_pixel;
#line 1469
  cmd->body.format.ldv_6386.ldv_6384.colorDepth = (unsigned char )vfb->base.depth;
#line 1470
  cmd->body.format.ldv_6386.ldv_6384.reserved = 0U;
#line 1471
  cmd->body.bytesPerLine = vfb->base.pitches[0];
#line 1472
  cmd->body.ptr.gmrId = vfb->user_handle;
#line 1473
  cmd->body.ptr.offset = 0U;
#line 1475
  blits = (struct __anonstruct_321 *)cmd + 1U;
#line 1476
  blits_pos = 0;
#line 1477
  i = 0;
#line 1477
  goto ldv_41363;
  ldv_41362: 
#line 1478
  c = clips;
#line 1479
  k = 0;
#line 1479
  goto ldv_41360;
  ldv_41359: 
#line 1481
  clip_x1 = c->x - (units[i])->crtc.x;
#line 1482
  clip_x2 = (int )((uint32_t )(c->x - (units[i])->crtc.x) + c->w);
#line 1483
  clip_y1 = c->y - (units[i])->crtc.y;
#line 1484
  clip_y2 = (int )((uint32_t )(c->y - (units[i])->crtc.y) + c->h);
#line 1485
  dest_x = c->x;
#line 1486
  dest_y = c->y;
#line 1491
  if (clip_x1 < 0) {
#line 1492
    dest_x = dest_x - clip_x1;
  } else {

  }
#line 1493
  if (clip_y1 < 0) {
#line 1494
    dest_y = dest_y - clip_y1;
  } else {

  }
#line 1497
  _max1 = clip_x1;
#line 1497
  _max2 = 0;
#line 1497
  clip_x1 = _max1 > _max2 ? _max1 : _max2;
#line 1498
  _max1___0 = clip_y1;
#line 1498
  _max2___0 = 0;
#line 1498
  clip_y1 = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 1499
  _min1 = clip_x2;
#line 1499
  _min2 = (units[i])->crtc.mode.hdisplay;
#line 1499
  clip_x2 = _min1 < _min2 ? _min1 : _min2;
#line 1500
  _min1___0 = clip_y2;
#line 1500
  _min2___0 = (units[i])->crtc.mode.vdisplay;
#line 1500
  clip_y2 = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 1503
  if ((((units[i])->crtc.mode.hdisplay <= clip_x1 || (units[i])->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 1506
    goto ldv_41358;
  } else {

  }
#line 1508
  (blits + (unsigned long )blits_pos)->header = 38U;
#line 1509
  (blits + (unsigned long )blits_pos)->body.srcScreenId = (units[i])->unit;
#line 1510
  (blits + (unsigned long )blits_pos)->body.destOrigin.x = dest_x;
#line 1511
  (blits + (unsigned long )blits_pos)->body.destOrigin.y = dest_y;
#line 1513
  (blits + (unsigned long )blits_pos)->body.srcRect.left = clip_x1;
#line 1514
  (blits + (unsigned long )blits_pos)->body.srcRect.top = clip_y1;
#line 1515
  (blits + (unsigned long )blits_pos)->body.srcRect.right = clip_x2;
#line 1516
  (blits + (unsigned long )blits_pos)->body.srcRect.bottom = clip_y2;
#line 1517
  blits_pos = blits_pos + 1;
  ldv_41358: 
#line 1479
  k = k + 1;
#line 1479
  c = c + 1;
  ldv_41360: ;
#line 1479
  if ((uint32_t )k < num_clips) {
#line 1480
    goto ldv_41359;
  } else {

  }
#line 1477
  i = i + 1;
  ldv_41363: ;
#line 1477
  if (i < num_units) {
#line 1478
    goto ldv_41362;
  } else {

  }
#line 1521
  fifo_size = (unsigned long )blits_pos * 32UL + 20UL;
#line 1523
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, user_fence_rep, 0);
#line 1526
  kfree((void const   *)cmd);
#line 1528
  return (ret);
}
}
#line 1531 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_init(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int ret ;

  {
#line 1533
  dev = dev_priv->dev;
#line 1536
  drm_mode_config_init(dev);
#line 1537
  dev->mode_config.funcs = & vmw_kms_funcs;
#line 1538
  dev->mode_config.min_width = 1;
#line 1539
  dev->mode_config.min_height = 1;
#line 1541
  dev->mode_config.max_width = 8192;
#line 1542
  dev->mode_config.max_height = 8192;
#line 1544
  ret = vmw_kms_init_screen_object_display(dev_priv);
#line 1545
  if (ret != 0) {
#line 1546
    vmw_kms_init_legacy_display_system(dev_priv);
  } else {

  }
#line 1548
  return (0);
}
}
#line 1551 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_close(struct vmw_private *dev_priv ) 
{ 


  {
#line 1558
  drm_mode_config_cleanup(dev_priv->dev);
#line 1559
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1560
    vmw_kms_close_screen_object_display(dev_priv);
  } else {
#line 1562
    vmw_kms_close_legacy_display_system(dev_priv);
  }
#line 1563
  return (0);
}
}
#line 1566 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_cursor_bypass_arg *arg ;
  struct vmw_display_unit *du ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct drm_mode_object  const  *__mptr___2 ;
  struct drm_crtc  const  *__mptr___3 ;

  {
#line 1569
  arg = (struct drm_vmw_cursor_bypass_arg *)data;
#line 1573
  ret = 0;
#line 1576
  ldv_mutex_lock_95(& dev->mode_config.mutex);
#line 1577
  if ((int )arg->flags & 1) {
#line 1579
    __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 1579
    crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1579
    goto ldv_41390;
    ldv_41389: 
#line 1580
    __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1580
    du = (struct vmw_display_unit *)__mptr___0;
#line 1581
    du->hotspot_x = arg->xhot;
#line 1582
    du->hotspot_y = arg->yhot;
#line 1579
    __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1579
    crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
    ldv_41390: ;
#line 1579
    if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 1580
      goto ldv_41389;
    } else {

    }
#line 1585
    ldv_mutex_unlock_96(& dev->mode_config.mutex);
#line 1586
    return (0);
  } else {

  }
#line 1589
  obj = drm_mode_object_find(dev, arg->crtc_id, 3435973836U);
#line 1590
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 1591
    ret = -22;
#line 1592
    goto out;
  } else {

  }
#line 1595
  __mptr___2 = (struct drm_mode_object  const  *)obj;
#line 1595
  crtc = (struct drm_crtc *)__mptr___2 + 0xffffffffffffffe8UL;
#line 1596
  __mptr___3 = (struct drm_crtc  const  *)crtc;
#line 1596
  du = (struct vmw_display_unit *)__mptr___3;
#line 1598
  du->hotspot_x = arg->xhot;
#line 1599
  du->hotspot_y = arg->yhot;
  out: 
#line 1602
  ldv_mutex_unlock_97(& dev->mode_config.mutex);
#line 1604
  return (ret);
}
}
#line 1607 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) 
{ 
  bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1611
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1612
    vmw_write(vmw_priv___0, 32U, pitch);
  } else {
#line 1613
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1613
    if ((int )tmp) {
#line 1614
      iowrite32(pitch, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1615
  vmw_write(vmw_priv___0, 2U, width);
#line 1616
  vmw_write(vmw_priv___0, 3U, height);
#line 1617
  vmw_write(vmw_priv___0, 7U, bpp);
#line 1619
  tmp___1 = vmw_read(vmw_priv___0, 6U);
#line 1619
  if (tmp___1 != depth) {
#line 1620
    tmp___0 = vmw_read(vmw_priv___0, 6U);
#line 1620
    drm_err("vmw_kms_write_svga", "Invalid depth %u for %u bpp, host expects %u\n",
            depth, bpp, tmp___0);
#line 1622
    return (-22);
  } else {

  }
#line 1625
  return (0);
}
}
#line 1628 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) 
{ 
  struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1633
  vmw_priv___0->vga_width = vmw_read(vmw_priv___0, 2U);
#line 1634
  vmw_priv___0->vga_height = vmw_read(vmw_priv___0, 3U);
#line 1635
  vmw_priv___0->vga_bpp = vmw_read(vmw_priv___0, 7U);
#line 1636
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1637
    vmw_priv___0->vga_pitchlock = vmw_read(vmw_priv___0, 32U);
  } else {
#line 1639
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1639
    if ((int )tmp) {
#line 1640
      vmw_priv___0->vga_pitchlock = ioread32((void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1643
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1644
    return (0);
  } else {

  }
#line 1646
  vmw_priv___0->num_displays = vmw_read(vmw_priv___0, 34U);
#line 1649
  if (vmw_priv___0->num_displays == 0U) {
#line 1650
    vmw_priv___0->num_displays = 1U;
  } else {

  }
#line 1652
  i = 0U;
#line 1652
  goto ldv_41412;
  ldv_41411: 
#line 1653
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1654
  vmw_write(vmw_priv___0, 35U, i);
#line 1655
  save->primary = vmw_read(vmw_priv___0, 36U);
#line 1656
  save->pos_x = vmw_read(vmw_priv___0, 37U);
#line 1657
  save->pos_y = vmw_read(vmw_priv___0, 38U);
#line 1658
  save->width = vmw_read(vmw_priv___0, 39U);
#line 1659
  save->height = vmw_read(vmw_priv___0, 40U);
#line 1660
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1661
  if (((i == 0U && vmw_priv___0->num_displays == 1U) && save->width == 0U) && save->height == 0U) {
#line 1669
    save->width = vmw_priv___0->vga_width - save->pos_x;
#line 1670
    save->height = vmw_priv___0->vga_height - save->pos_y;
  } else {

  }
#line 1652
  i = i + 1U;
  ldv_41412: ;
#line 1652
  if (vmw_priv___0->num_displays > i) {
#line 1653
    goto ldv_41411;
  } else {

  }

#line 1674
  return (0);
}
}
#line 1677 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) 
{ 
  struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1682
  vmw_write(vmw_priv___0, 2U, vmw_priv___0->vga_width);
#line 1683
  vmw_write(vmw_priv___0, 3U, vmw_priv___0->vga_height);
#line 1684
  vmw_write(vmw_priv___0, 7U, vmw_priv___0->vga_bpp);
#line 1685
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1686
    vmw_write(vmw_priv___0, 32U, vmw_priv___0->vga_pitchlock);
  } else {
#line 1688
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1688
    if ((int )tmp) {
#line 1689
      iowrite32(vmw_priv___0->vga_pitchlock, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1692
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1693
    return (0);
  } else {

  }
#line 1695
  i = 0U;
#line 1695
  goto ldv_41420;
  ldv_41419: 
#line 1696
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1697
  vmw_write(vmw_priv___0, 35U, i);
#line 1698
  vmw_write(vmw_priv___0, 36U, save->primary);
#line 1699
  vmw_write(vmw_priv___0, 37U, save->pos_x);
#line 1700
  vmw_write(vmw_priv___0, 38U, save->pos_y);
#line 1701
  vmw_write(vmw_priv___0, 39U, save->width);
#line 1702
  vmw_write(vmw_priv___0, 40U, save->height);
#line 1703
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1695
  i = i + 1U;
  ldv_41420: ;
#line 1695
  if (vmw_priv___0->num_displays > i) {
#line 1696
    goto ldv_41419;
  } else {

  }

#line 1706
  return (0);
}
}
#line 1709 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) 
{ 


  {
#line 1713
  return ((unsigned long long )pitch * (unsigned long long )height < (unsigned long long )dev_priv->vram_size);
}
}
#line 1720 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1722
  return (0U);
}
}
#line 1728 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_enable_vblank(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1730
  return (-38);
}
}
#line 1736 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_disable_vblank(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1738
  return;
}
}
#line 1745 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_update_layout(struct vmw_private *dev_priv , unsigned int num , struct drm_vmw_rect *rects ) 
{ 
  struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_connector *con ;
  struct list_head  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1748
  dev = dev_priv->dev;
#line 1752
  ldv_mutex_lock_98(& dev->mode_config.mutex);
#line 1766
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 1766
  con = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
#line 1766
  goto ldv_41454;
  ldv_41453: 
#line 1767
  __mptr___0 = (struct drm_connector  const  *)con;
#line 1767
  du = (struct vmw_display_unit *)__mptr___0 + 0xfffffffffffffc58UL;
#line 1768
  if (du->unit < num) {
#line 1769
    du->pref_width = (rects + (unsigned long )du->unit)->w;
#line 1770
    du->pref_height = (rects + (unsigned long )du->unit)->h;
#line 1771
    du->pref_active = 1;
#line 1772
    du->gui_x = (rects + (unsigned long )du->unit)->x;
#line 1773
    du->gui_y = (rects + (unsigned long )du->unit)->y;
  } else {
#line 1775
    du->pref_width = 800U;
#line 1776
    du->pref_height = 600U;
#line 1777
    du->pref_active = 0;
  }
#line 1779
  con->status = vmw_du_connector_detect(con, 1);
#line 1766
  __mptr___1 = (struct list_head  const  *)con->head.next;
#line 1766
  con = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_41454: ;
#line 1766
  if ((unsigned long )(& con->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 1767
    goto ldv_41453;
  } else {

  }
#line 1782
  ldv_mutex_unlock_99(& dev->mode_config.mutex);
#line 1784
  return (0);
}
}
#line 1787 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_framebuffer *old_fb ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_file *file_priv ;
  struct vmw_fence_obj *fence ;
  struct drm_clip_rect clips ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  struct drm_crtc  const  *__mptr___0 ;

  {
#line 1791
  tmp = vmw_priv(crtc->dev);
#line 1791
  dev_priv = tmp;
#line 1792
  old_fb = crtc->fb;
#line 1793
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 1793
  vfb = (struct vmw_framebuffer *)__mptr;
#line 1795
  fence = 0;
#line 1799
  if ((unsigned long )event == (unsigned long )((struct drm_pending_vblank_event *)0)) {
#line 1800
    return (-22);
  } else {

  }
#line 1803
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1804
    return (-38);
  } else {

  }
#line 1806
  file_priv = event->base.file_priv;
#line 1807
  tmp___0 = vmw_kms_screen_object_flippable(dev_priv, crtc);
#line 1807
  if (tmp___0) {
#line 1807
    tmp___1 = 0;
  } else {
#line 1807
    tmp___1 = 1;
  }
#line 1807
  if (tmp___1) {
#line 1808
    return (-22);
  } else {

  }
#line 1810
  crtc->fb = fb;
#line 1813
  clips.y1 = 0U;
#line 1813
  clips.x1 = clips.y1;
#line 1814
  clips.x2 = (unsigned short )fb->width;
#line 1815
  clips.y2 = (unsigned short )fb->height;
#line 1817
  if ((int )vfb->dmabuf) {
#line 1818
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  } else {
#line 1821
    ret = do_surface_dirty_sou(dev_priv, file_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  }
#line 1825
  if (ret != 0) {
#line 1826
    goto out_no_fence;
  } else {

  }
#line 1827
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1828
    ret = -22;
#line 1829
    goto out_no_fence;
  } else {

  }
#line 1832
  ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                     & event->event.tv_usec, 1);
#line 1842
  vmw_fence_obj_unreference(& fence);
#line 1844
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1844
  if ((int )((struct vmw_display_unit *)__mptr___0)->is_implicit) {
#line 1845
    vmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);
  } else {

  }
#line 1847
  return (ret);
  out_no_fence: 
#line 1850
  crtc->fb = old_fb;
#line 1851
  return (ret);
}
}
#line 1855 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_save(struct drm_crtc *crtc ) 
{ 


  {
#line 1857
  return;
}
}
#line 1859 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_restore(struct drm_crtc *crtc ) 
{ 


  {
#line 1861
  return;
}
}
#line 1863 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  int i ;

  {
#line 1867
  tmp = vmw_priv(crtc->dev);
#line 1867
  dev_priv = tmp;
#line 1870
  i = 0;
#line 1870
  goto ldv_41491;
  ldv_41490: 
#line 1871
  drm_ut_debug_printk(1U, "drm", "vmw_du_crtc_gamma_set", "%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n",
                      i, (int )*(r + (unsigned long )i), (int )*(g + (unsigned long )i),
                      (int )*(b + (unsigned long )i));
#line 1873
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1024), (uint32_t )((int )*(r + (unsigned long )i) >> 8));
#line 1874
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1025), (uint32_t )((int )*(g + (unsigned long )i) >> 8));
#line 1875
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1026), (uint32_t )((int )*(b + (unsigned long )i) >> 8));
#line 1870
  i = i + 1;
  ldv_41491: ;
#line 1870
  if ((uint32_t )i < size) {
#line 1871
    goto ldv_41490;
  } else {

  }

#line 1875
  return;
}
}
#line 1879 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) 
{ 


  {
#line 1881
  return;
}
}
#line 1883 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_save(struct drm_connector *connector ) 
{ 


  {
#line 1885
  return;
}
}
#line 1887 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_restore(struct drm_connector *connector ) 
{ 


  {
#line 1889
  return;
}
}
#line 1892 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) 
{ 
  uint32_t num_displays ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;

  {
#line 1895
  dev = connector->dev;
#line 1896
  tmp = vmw_priv(dev);
#line 1896
  dev_priv = tmp;
#line 1897
  __mptr = (struct drm_connector  const  *)connector;
#line 1897
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc58UL;
#line 1899
  ldv_mutex_lock_100(& dev_priv->hw_mutex);
#line 1900
  num_displays = vmw_read(dev_priv, 31U);
#line 1901
  ldv_mutex_unlock_101(& dev_priv->hw_mutex);
#line 1903
  __mptr___0 = (struct drm_connector  const  *)connector;
#line 1903
  return (((struct vmw_display_unit *)__mptr___0 + 0xfffffffffffffc58UL)->unit < num_displays && (int )du->pref_active ? 1 : 2);
}
}
#line 1908 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_display_mode vmw_kms_connector_builtin[19U]  = 
#line 1908
  {      {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 25175, 640, 656, 752, 800, 0, 480, 489, 492, 525, 0, 10U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0,
      64U, 40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, 10U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '1', '5', '2', 'x', '8', '6', '4', '\000'},
      0, 64U, 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900, 0, 5U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '7', '6', '8', '\000'},
      0, 64U, 79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798, 0, 6U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '8', '0', '0', '\000'},
      0, 64U, 83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831, 0, 9U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '9', '6', '0', '\000'},
      0, 64U, 108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000, 0, 5U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4',
                                     '\000'}, 0, 64U, 108000, 1280, 1328, 1440, 1688,
      0, 1024, 1025, 1028, 1066, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '3', '6', '0', 'x', '7', '6', '8', '\000'},
      0, 64U, 85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795, 0, 5U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '4', '0', '0', 'x', '1', '0', '5', '0',
                                     '\000'}, 0, 64U, 121750, 1400, 1488, 1632, 1864,
      0, 1050, 1053, 1057, 1089, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '4', '4', '0', 'x', '9', '0', '0', '\000'},
      0, 64U, 106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934, 0, 6U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '6', '0', '0', 'x', '1', '2', '0', '0',
                                     '\000'}, 0, 64U, 162000, 1600, 1664, 1856, 2160,
      0, 1200, 1201, 1204, 1250, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '6', '8', '0', 'x', '1', '0', '5', '0',
                                     '\000'}, 0, 64U, 146250, 1680, 1784, 1960, 2240,
      0, 1050, 1053, 1059, 1089, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '7', '9', '2', 'x', '1', '3', '4', '4',
                                     '\000'}, 0, 64U, 204750, 1792, 1920, 2120, 2448,
      0, 1344, 1345, 1348, 1394, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '8', '5', '6', 'x', '1', '3', '9', '2',
                                     '\000'}, 0, 64U, 218250, 1856, 1952, 2176, 2528,
      0, 1392, 1393, 1396, 1439, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '9', '2', '0', 'x', '1', '2', '0', '0',
                                     '\000'}, 0, 64U, 193250, 1920, 2056, 2256, 2592,
      0, 1200, 1203, 1209, 1245, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '9', '2', '0', 'x', '1', '4', '4', '0',
                                     '\000'}, 0, 64U, 234000, 1920, 2048, 2256, 2600,
      0, 1440, 1441, 1444, 1500, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'2', '5', '6', '0', 'x', '1', '6', '0', '0',
                                     '\000'}, 0, 64U, 348500, 2560, 2752, 3032, 3504,
      0, 1600, 1603, 1609, 1658, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'\000'}, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
#line 1992 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static void vmw_guess_mode_timing(struct drm_display_mode *mode ) 
{ 


  {
#line 1994
  mode->hsync_start = mode->hdisplay + 50;
#line 1995
  mode->hsync_end = mode->hsync_start + 50;
#line 1996
  mode->htotal = mode->hsync_end + 50;
#line 1998
  mode->vsync_start = mode->vdisplay + 50;
#line 1999
  mode->vsync_end = mode->vsync_start + 50;
#line 2000
  mode->vtotal = mode->vsync_end + 50;
#line 2002
  mode->clock = (int )((((unsigned int )mode->htotal * (unsigned int )mode->vtotal) / 100U) * 6U);
#line 2003
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2004
  return;
}
}
#line 2007 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) 
{ 
  struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *bmode ;
  struct drm_display_mode prefmode ;
  unsigned int tmp___0 ;
  int i ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2010
  __mptr = (struct drm_connector  const  *)connector;
#line 2010
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc58UL;
#line 2011
  dev = connector->dev;
#line 2012
  tmp = vmw_priv(dev);
#line 2012
  dev_priv = tmp;
#line 2013
  mode = 0;
#line 2015
  prefmode.head.next = 0;
#line 2015
  prefmode.head.prev = 0;
#line 2015
  prefmode.base.id = 0U;
#line 2015
  prefmode.base.type = 3739147998U;
#line 2015
  prefmode.base.properties = 0;
#line 2015
  prefmode.name[0] = 'p';
#line 2015
  prefmode.name[1] = 'r';
#line 2015
  prefmode.name[2] = 'e';
#line 2015
  prefmode.name[3] = 'f';
#line 2015
  prefmode.name[4] = 'e';
#line 2015
  prefmode.name[5] = 'r';
#line 2015
  prefmode.name[6] = 'r';
#line 2015
  prefmode.name[7] = 'e';
#line 2015
  prefmode.name[8] = 'd';
#line 2015
  prefmode.name[9] = '\000';
#line 2015
  tmp___0 = 10U;
#line 2015
  while (1) {
#line 2015
    if (tmp___0 >= 32U) {
#line 2015
      break;
    } else {

    }
#line 2015
    prefmode.name[tmp___0] = (char)0;
#line 2015
    tmp___0 = tmp___0 + 1U;
  }
#line 2015
  prefmode.status = 0;
#line 2015
  prefmode.type = 72U;
#line 2015
  prefmode.clock = 0;
#line 2015
  prefmode.hdisplay = 0;
#line 2015
  prefmode.hsync_start = 0;
#line 2015
  prefmode.hsync_end = 0;
#line 2015
  prefmode.htotal = 0;
#line 2015
  prefmode.hskew = 0;
#line 2015
  prefmode.vdisplay = 0;
#line 2015
  prefmode.vsync_start = 0;
#line 2015
  prefmode.vsync_end = 0;
#line 2015
  prefmode.vtotal = 0;
#line 2015
  prefmode.vscan = 0;
#line 2015
  prefmode.flags = 6U;
#line 2015
  prefmode.width_mm = 0;
#line 2015
  prefmode.height_mm = 0;
#line 2015
  prefmode.clock_index = 0;
#line 2015
  prefmode.synth_clock = 0;
#line 2015
  prefmode.crtc_hdisplay = 0;
#line 2015
  prefmode.crtc_hblank_start = 0;
#line 2015
  prefmode.crtc_hblank_end = 0;
#line 2015
  prefmode.crtc_hsync_start = 0;
#line 2015
  prefmode.crtc_hsync_end = 0;
#line 2015
  prefmode.crtc_htotal = 0;
#line 2015
  prefmode.crtc_hskew = 0;
#line 2015
  prefmode.crtc_vdisplay = 0;
#line 2015
  prefmode.crtc_vblank_start = 0;
#line 2015
  prefmode.crtc_vblank_end = 0;
#line 2015
  prefmode.crtc_vsync_start = 0;
#line 2015
  prefmode.crtc_vsync_end = 0;
#line 2015
  prefmode.crtc_vtotal = 0;
#line 2015
  prefmode.private_size = 0;
#line 2015
  prefmode.private = 0;
#line 2015
  prefmode.private_flags = 0;
#line 2015
  prefmode.vrefresh = 0;
#line 2015
  prefmode.hsync = 0;
#line 2024
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)(& prefmode));
#line 2025
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2026
    return (0);
  } else {

  }
#line 2027
  mode->hdisplay = (int )du->pref_width;
#line 2028
  mode->vdisplay = (int )du->pref_height;
#line 2029
  vmw_guess_mode_timing(mode);
#line 2031
  tmp___1 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(mode->hdisplay * 2),
                                       (uint32_t )mode->vdisplay);
#line 2031
  if ((int )tmp___1) {
#line 2033
    drm_mode_probed_add(connector, mode);
  } else {
#line 2035
    drm_mode_destroy(dev, mode);
#line 2036
    mode = 0;
  }
#line 2039
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2040
    list_del_init(& (du->pref_mode)->head);
#line 2041
    drm_mode_destroy(dev, du->pref_mode);
  } else {

  }
#line 2045
  du->pref_mode = mode;
#line 2048
  i = 0;
#line 2048
  goto ldv_41535;
  ldv_41534: 
#line 2049
  bmode = (struct drm_display_mode *)(& vmw_kms_connector_builtin) + (unsigned long )i;
#line 2050
  if ((uint32_t )bmode->hdisplay > max_width || (uint32_t )bmode->vdisplay > max_height) {
#line 2052
    goto ldv_41533;
  } else {

  }
#line 2054
  tmp___2 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(bmode->hdisplay * 2),
                                       (uint32_t )bmode->vdisplay);
#line 2054
  if (tmp___2) {
#line 2054
    tmp___3 = 0;
  } else {
#line 2054
    tmp___3 = 1;
  }
#line 2054
  if (tmp___3) {
#line 2056
    goto ldv_41533;
  } else {

  }
#line 2058
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)bmode);
#line 2059
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2060
    return (0);
  } else {

  }
#line 2061
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2063
  drm_mode_probed_add(connector, mode);
  ldv_41533: 
#line 2048
  i = i + 1;
  ldv_41535: ;
#line 2048
  if (vmw_kms_connector_builtin[i].type != 0U) {
#line 2049
    goto ldv_41534;
  } else {

  }

#line 2067
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2068
    list_move(& (du->pref_mode)->head, & connector->probed_modes);
  } else {

  }
#line 2070
  drm_mode_connector_list_update(connector);
#line 2072
  return (1);
}
}
#line 2075 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) 
{ 


  {
#line 2079
  return (0);
}
}
#line 2083 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_update_layout_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  void *user_rects ;
  struct drm_vmw_rect *rects ;
  unsigned int rects_size ;
  int ret ;
  int i ;
  struct drm_mode_config *mode_config ;
  long tmp___1 ;
  struct drm_vmw_rect def_rect ;
  void *tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;

  {
#line 2086
  tmp = vmw_priv(dev);
#line 2086
  dev_priv = tmp;
#line 2087
  arg = (struct drm_vmw_update_layout_arg *)data;
#line 2089
  tmp___0 = vmw_master(file_priv->master);
#line 2089
  vmaster = tmp___0;
#line 2095
  mode_config = & dev->mode_config;
#line 2097
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 2098
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 2098
  if (tmp___1 != 0L) {
#line 2099
    return (ret);
  } else {

  }
#line 2101
  if (arg->num_outputs == 0U) {
#line 2102
    def_rect.x = 0;
#line 2102
    def_rect.y = 0;
#line 2102
    def_rect.w = 800U;
#line 2102
    def_rect.h = 600U;
#line 2103
    vmw_du_update_layout(dev_priv, 1U, & def_rect);
#line 2104
    goto out_unlock;
  } else {

  }
#line 2107
  rects_size = arg->num_outputs * 16U;
#line 2108
  tmp___2 = kcalloc((size_t )arg->num_outputs, 16UL, 208U);
#line 2108
  rects = (struct drm_vmw_rect *)tmp___2;
#line 2110
  tmp___3 = ldv__builtin_expect((unsigned long )rects == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 2110
  if (tmp___3 != 0L) {
#line 2111
    ret = -12;
#line 2112
    goto out_unlock;
  } else {

  }
#line 2115
  user_rects = (void *)arg->rects;
#line 2116
  tmp___4 = copy_from_user((void *)rects, (void const   *)user_rects, (unsigned long )rects_size);
#line 2116
  ret = (int )tmp___4;
#line 2117
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 2117
  if (tmp___5 != 0L) {
#line 2118
    drm_err("vmw_kms_update_layout_ioctl", "Failed to get rects.\n");
#line 2119
    ret = -14;
#line 2120
    goto out_free;
  } else {

  }
#line 2123
  i = 0;
#line 2123
  goto ldv_41561;
  ldv_41560: ;
#line 2124
  if ((((rects + (unsigned long )i)->x < 0 || (rects + (unsigned long )i)->y < 0) || (uint32_t )(rects + (unsigned long )i)->x + (rects + (unsigned long )i)->w > (uint32_t )mode_config->max_width) || (uint32_t )(rects + (unsigned long )i)->y + (rects + (unsigned long )i)->h > (uint32_t )mode_config->max_height) {
#line 2128
    drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2129
    ret = -22;
#line 2130
    goto out_free;
  } else {

  }
#line 2123
  i = i + 1;
  ldv_41561: ;
#line 2123
  if ((uint32_t )i < arg->num_outputs) {
#line 2124
    goto ldv_41560;
  } else {

  }
#line 2134
  vmw_du_update_layout(dev_priv, arg->num_outputs, rects);
  out_free: 
#line 2137
  kfree((void const   *)rects);
  out_unlock: 
#line 2139
  ttm_read_unlock(& vmaster->lock);
#line 2140
  return (ret);
}
}
#line 2159
void ldv_check_final_state(void) ;
#line 2168
void ldv_initialize(void) ;
#line 2171
extern void ldv_handler_precall(void) ;
#line 2174
extern int __VERIFIER_nondet_int(void) ;
#line 2177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 2180 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void main(void) 
{ 
  struct drm_framebuffer *var_group1 ;
  struct drm_file *var_group2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_surface_dirty_12_p4 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p5 ;
  unsigned int *var_vmw_framebuffer_create_handle_9_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_dmabuf_dirty_18_p4 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p5 ;
  struct drm_device *var_group3 ;
  struct drm_mode_fb_cmd2 *var_vmw_kms_fb_create_22_p2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2308
  LDV_IN_INTERRUPT = 1;
#line 2317
  ldv_initialize();
#line 2325
  goto ldv_41602;
  ldv_41601: 
#line 2328
  tmp = __VERIFIER_nondet_int();
#line 2328
  switch (tmp) {
  case 0: 
#line 2342
  ldv_handler_precall();
#line 2343
  vmw_framebuffer_surface_destroy(var_group1);
#line 2356
  goto ldv_41593;
  case 1: 
#line 2369
  ldv_handler_precall();
#line 2370
  vmw_framebuffer_surface_dirty(var_group1, var_group2, var_vmw_framebuffer_surface_dirty_12_p2,
                                var_vmw_framebuffer_surface_dirty_12_p3, var_vmw_framebuffer_surface_dirty_12_p4,
                                var_vmw_framebuffer_surface_dirty_12_p5);
#line 2383
  goto ldv_41593;
  case 2: 
#line 2394
  ldv_handler_precall();
#line 2395
  vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
#line 2410
  goto ldv_41593;
  case 3: 
#line 2425
  ldv_handler_precall();
#line 2426
  vmw_framebuffer_dmabuf_destroy(var_group1);
#line 2437
  goto ldv_41593;
  case 4: 
#line 2452
  ldv_handler_precall();
#line 2453
  vmw_framebuffer_dmabuf_dirty(var_group1, var_group2, var_vmw_framebuffer_dmabuf_dirty_18_p2,
                               var_vmw_framebuffer_dmabuf_dirty_18_p3, var_vmw_framebuffer_dmabuf_dirty_18_p4,
                               var_vmw_framebuffer_dmabuf_dirty_18_p5);
#line 2464
  goto ldv_41593;
  case 5: 
#line 2475
  ldv_handler_precall();
#line 2476
  vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
#line 2491
  goto ldv_41593;
  case 6: 
#line 2506
  ldv_handler_precall();
#line 2507
  vmw_kms_fb_create(var_group3, var_group2, var_vmw_kms_fb_create_22_p2);
#line 2518
  goto ldv_41593;
  default: ;
#line 2519
  goto ldv_41593;
  }
  ldv_41593: ;
  ldv_41602: 
#line 2325
  tmp___0 = __VERIFIER_nondet_int();
#line 2325
  if (tmp___0 != 0) {
#line 2326
    goto ldv_41601;
  } else {

  }


#line 2528
  ldv_check_final_state();
#line 2531
  return;
}
}
#line 2535 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2540
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2542
  mutex_lock(ldv_func_arg1);
#line 2543
  return;
}
}
#line 2545 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2550
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2552
  mutex_unlock(ldv_func_arg1);
#line 2553
  return;
}
}
#line 2555 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2560
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2562
  mutex_lock(ldv_func_arg1);
#line 2563
  return;
}
}
#line 2565 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int ldv_mutex_trylock_78(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2570
  tmp = mutex_trylock(ldv_func_arg1);
#line 2570
  ldv_func_res = tmp;
#line 2572
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 2572
  return (tmp___0);
#line 2574
  return (ldv_func_res);
}
}
#line 2577 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2582
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2584
  mutex_unlock(ldv_func_arg1);
#line 2585
  return;
}
}
#line 2587 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_80(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2592
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2594
  mutex_lock(ldv_func_arg1);
#line 2595
  return;
}
}
#line 2597 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2602
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2604
  mutex_unlock(ldv_func_arg1);
#line 2605
  return;
}
}
#line 2607 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2612
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 2614
  mutex_lock(ldv_func_arg1);
#line 2615
  return;
}
}
#line 2617 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2622
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 2624
  mutex_unlock(ldv_func_arg1);
#line 2625
  return;
}
}
#line 2627 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2632
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2634
  mutex_unlock(ldv_func_arg1);
#line 2635
  return;
}
}
#line 2637 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2642
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 2644
  mutex_lock(ldv_func_arg1);
#line 2645
  return;
}
}
#line 2647 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2652
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 2654
  mutex_unlock(ldv_func_arg1);
#line 2655
  return;
}
}
#line 2657 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2662
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2664
  mutex_lock(ldv_func_arg1);
#line 2665
  return;
}
}
#line 2667 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2672
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2674
  mutex_unlock(ldv_func_arg1);
#line 2675
  return;
}
}
#line 2677 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2682
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2684
  mutex_lock(ldv_func_arg1);
#line 2685
  return;
}
}
#line 2687 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2692
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2694
  mutex_unlock(ldv_func_arg1);
#line 2695
  return;
}
}
#line 2697 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2702
  ldv_mutex_lock_fb_surf_mutex(ldv_func_arg1);
#line 2704
  mutex_lock(ldv_func_arg1);
#line 2705
  return;
}
}
#line 2707 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2712
  ldv_mutex_unlock_fb_surf_mutex(ldv_func_arg1);
#line 2714
  mutex_unlock(ldv_func_arg1);
#line 2715
  return;
}
}
#line 2717 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2722
  ldv_mutex_lock_fb_surf_mutex(ldv_func_arg1);
#line 2724
  mutex_lock(ldv_func_arg1);
#line 2725
  return;
}
}
#line 2727 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2732
  ldv_mutex_unlock_fb_surf_mutex(ldv_func_arg1);
#line 2734
  mutex_unlock(ldv_func_arg1);
#line 2735
  return;
}
}
#line 2737 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2742
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2744
  mutex_lock(ldv_func_arg1);
#line 2745
  return;
}
}
#line 2747 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2752
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2754
  mutex_unlock(ldv_func_arg1);
#line 2755
  return;
}
}
#line 2757 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2762
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2764
  mutex_unlock(ldv_func_arg1);
#line 2765
  return;
}
}
#line 2767 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2772
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2774
  mutex_lock(ldv_func_arg1);
#line 2775
  return;
}
}
#line 2777 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2782
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2784
  mutex_unlock(ldv_func_arg1);
#line 2785
  return;
}
}
#line 2787 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2792
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 2794
  mutex_lock(ldv_func_arg1);
#line 2795
  return;
}
}
#line 2797 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2802
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 2804
  mutex_unlock(ldv_func_arg1);
#line 2805
  return;
}
}
#line 35 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 171
int ldv_mutex_trylock_132(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) ;
#line 236
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) ;
#line 240
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) ;
#line 62
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) ;
#line 66
void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) ;
#line 143
void ldv_mutex_lock_release_mutex(struct mutex *lock ) ;
#line 147
void ldv_mutex_unlock_release_mutex(struct mutex *lock ) ;
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 285
  _raw_spin_lock(& lock->ldv_5961.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 325
  _raw_spin_unlock(& lock->ldv_5961.rlock);
#line 326
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
extern void iounmap(void volatile   * ) ;
#line 317
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 2397 "include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 845 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 858 "include/linux/pci.h"
extern int pci_enable_device(struct pci_dev * ) ;
#line 875
extern void pci_disable_device(struct pci_dev * ) ;
#line 878
extern void pci_set_master(struct pci_dev * ) ;
#line 917
extern int pci_save_state(struct pci_dev * ) ;
#line 918
extern void pci_restore_state(struct pci_dev * ) ;
#line 924
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 987
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 989
extern void pci_release_regions(struct pci_dev * ) ;
#line 990
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
#line 992
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 1445 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1447
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1447
  return (tmp);
}
}
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
extern int mtrr_add(unsigned long  , unsigned long  , unsigned int  , bool  ) ;
#line 38
extern int mtrr_del(int  , unsigned long  , unsigned long  ) ;
#line 114 "include/linux/idr.h"
extern void idr_destroy(struct idr * ) ;
#line 115
extern void idr_init(struct idr * ) ;
#line 62 "include/drm/drm_hashtab.h"
extern void drm_ht_remove(struct drm_open_hash * ) ;
#line 1236 "include/drm/drmP.h"
__inline static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags ) 
{ 
  int tmp ;

  {
#line 1239
  tmp = mtrr_add(offset, size, flags, 1);
#line 1239
  return (tmp);
}
}
#line 1242 "include/drm/drmP.h"
__inline static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags ) 
{ 
  int tmp ;

  {
#line 1245
  tmp = mtrr_del(handle, offset, size);
#line 1245
  return (tmp);
}
}
#line 1284
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1286
extern long drm_compat_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1292
extern int drm_open(struct inode * , struct file * ) ;
#line 1294
extern int drm_fasync(int  , struct file * , int  ) ;
#line 1297
extern int drm_release(struct inode * , struct file * ) ;
#line 1424
extern int drm_irq_install(struct drm_device * ) ;
#line 1425
extern int drm_irq_uninstall(struct drm_device * ) ;
#line 1501
extern void drm_put_dev(struct drm_device * ) ;
#line 1751
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
#line 1752
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
#line 1753
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
#line 346 "include/linux/suspend.h"
extern int register_pm_notifier(struct notifier_block * ) ;
#line 347
extern int unregister_pm_notifier(struct notifier_block * ) ;
#line 332 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_wait(struct ttm_buffer_object * , bool  , bool  , bool  ) ;
#line 533
extern int ttm_bo_create(struct ttm_bo_device * , unsigned long  , enum ttm_bo_type  ,
                         struct ttm_placement * , uint32_t  , bool  , struct file * ,
                         struct ttm_buffer_object ** ) ;
#line 572
extern int ttm_bo_init_mm(struct ttm_bo_device * , unsigned int  , unsigned long  ) ;
#line 601
extern int ttm_bo_clean_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 622
extern int ttm_bo_evict_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 726
extern void ttm_bo_swapout_all(struct ttm_bo_device * ) ;
#line 731 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_device_release(struct ttm_bo_device * ) ;
#line 747
extern int ttm_bo_device_init(struct ttm_bo_device * , struct ttm_bo_global * , struct ttm_bo_driver * ,
                              uint64_t  , bool  ) ;
#line 231 "include/drm/ttm/ttm_object.h"
extern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device * , unsigned int  ) ;
#line 246
extern void ttm_object_file_release(struct ttm_object_file ** ) ;
#line 257
extern struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global * ,
                                                        unsigned int  ) ;
#line 271
extern void ttm_object_device_release(struct ttm_object_device ** ) ;
#line 87 "include/drm/ttm/ttm_lock.h"
extern void ttm_lock_init(struct ttm_lock * ) ;
#line 164
extern void ttm_suspend_lock(struct ttm_lock * ) ;
#line 173
extern void ttm_suspend_unlock(struct ttm_lock * ) ;
#line 187
extern int ttm_vt_lock(struct ttm_lock * , bool  , struct ttm_object_file * ) ;
#line 199
extern int ttm_vt_unlock(struct ttm_lock * ) ;
#line 239 "include/drm/ttm/ttm_lock.h"
__inline static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal ) 
{ 


  {
#line 242
  lock->kill_takers = val;
#line 243
  if ((int )val) {
#line 244
    lock->signal = signal;
  } else {

  }
#line 245
  return;
}
}
#line 66 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) ;
#line 68
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) ;
#line 98
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) ;
#line 100
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) ;
#line 102
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 105
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 108
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 110
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 112
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) ;
#line 401 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) ;
#line 402
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) ;
#line 427
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 429
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 447
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 449
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 451
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 466
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 468
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 475
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 477
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 490
void vmw_resource_evict_all(struct vmw_private *dev_priv ) ;
#line 519
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 521
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 523
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 525
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 527
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) ;
#line 529
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
#line 536
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 538
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 554
int vmw_ttm_global_init(struct vmw_private *dev_priv ) ;
#line 555
void vmw_ttm_global_release(struct vmw_private *dev_priv ) ;
#line 556
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) ;
#line 564
struct ttm_placement vmw_vram_sys_placement ;
#line 570
struct ttm_bo_driver vmw_bo_driver ;
#line 608
irqreturn_t vmw_irq_handler(int irq , void *arg ) ;
#line 612
void vmw_irq_preinstall(struct drm_device *dev ) ;
#line 613
int vmw_irq_postinstall(struct drm_device *dev ) ;
#line 614
void vmw_irq_uninstall(struct drm_device *dev ) ;
#line 648
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) ;
#line 649
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) ;
#line 651
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) ;
#line 694
int vmw_dumb_create(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
#line 698
int vmw_dumb_map_offset(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                        uint64_t *offset ) ;
#line 701
int vmw_dumb_destroy(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) ;
#line 708
int vmw_overlay_init(struct vmw_private *dev_priv ) ;
#line 709
int vmw_overlay_close(struct vmw_private *dev_priv ) ;
#line 710
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 231 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_ioctl_desc vmw_ioctls[21U]  = 
#line 231 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
  {      {0U, 17, & vmw_getparam_ioctl, 3222299712U}, 
        {1U, 17, & vmw_dmabuf_alloc_ioctl, 3222824001U}, 
        {2U, 17, & vmw_dmabuf_unref_ioctl, 1074291778U}, 
        {3U, 26, & vmw_kms_cursor_bypass_ioctl, 1075340355U}, 
        {4U, 26, & vmw_overlay_ioctl, 1079534660U}, 
        {5U, 26, & vmw_stream_claim_ioctl, 2148033605U}, 
        {6U, 26, & vmw_stream_unref_ioctl, 1074291782U}, 
        {7U, 17, & vmw_context_define_ioctl, 2148033607U}, 
        {8U, 17, & vmw_context_destroy_ioctl, 1074291784U}, 
        {9U, 17, & vmw_surface_define_ioctl, 3224396873U}, 
        {10U, 17, & vmw_surface_destroy_ioctl, 1074291786U}, 
        {11U, 17, & vmw_surface_reference_ioctl, 3224396875U}, 
        {12U, 17, & vmw_execbuf_ioctl, 1075864652U}, 
        {13U, 17, & vmw_get_cap_3d_ioctl, 1074816077U}, 
        {14U, 17, & vmw_fence_obj_wait_ioctl, 3223872590U}, 
        {15U, 17, & vmw_fence_obj_signaled_ioctl, 3222824015U}, 
        {16U, 17, & vmw_fence_obj_unref_ioctl, 1074291792U}, 
        {17U, 17, & vmw_fence_event_ioctl, 1075340369U}, 
        {18U, 19, & vmw_present_ioctl, 1075864658U}, 
        {19U, 19, & vmw_present_readback_ioctl, 1075340371U}, 
        {20U, 18, & vmw_kms_update_layout_ioctl, 1074816084U}};
#line 285 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_device_id vmw_pci_id_list[2U]  = {      {5549U, 1029U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 289 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 291 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int enable_fbdev  =    1;
#line 293
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
#line 294
static void vmw_master_init(struct vmw_master *vmaster ) ;
#line 295
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) ;
#line 301 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_print_capabilities(uint32_t capabilities ) 
{ 


  {
#line 303
  printk("\016[drm] Capabilities:\n");
#line 304
  if ((capabilities & 2U) != 0U) {
#line 305
    printk("\016[drm]   Rect copy.\n");
  } else {

  }
#line 306
  if ((capabilities & 32U) != 0U) {
#line 307
    printk("\016[drm]   Cursor.\n");
  } else {

  }
#line 308
  if ((capabilities & 64U) != 0U) {
#line 309
    printk("\016[drm]   Cursor bypass.\n");
  } else {

  }
#line 310
  if ((capabilities & 128U) != 0U) {
#line 311
    printk("\016[drm]   Cursor bypass 2.\n");
  } else {

  }
#line 312
  if ((capabilities & 256U) != 0U) {
#line 313
    printk("\016[drm]   8bit emulation.\n");
  } else {

  }
#line 314
  if ((capabilities & 512U) != 0U) {
#line 315
    printk("\016[drm]   Alpha cursor.\n");
  } else {

  }
#line 316
  if ((capabilities & 16384U) != 0U) {
#line 317
    printk("\016[drm]   3D.\n");
  } else {

  }
#line 318
  if ((capabilities & 32768U) != 0U) {
#line 319
    printk("\016[drm]   Extended Fifo.\n");
  } else {

  }
#line 320
  if ((capabilities & 65536U) != 0U) {
#line 321
    printk("\016[drm]   Multimon.\n");
  } else {

  }
#line 322
  if ((capabilities & 131072U) != 0U) {
#line 323
    printk("\016[drm]   Pitchlock.\n");
  } else {

  }
#line 324
  if ((capabilities & 262144U) != 0U) {
#line 325
    printk("\016[drm]   Irq mask.\n");
  } else {

  }
#line 326
  if ((capabilities & 524288U) != 0U) {
#line 327
    printk("\016[drm]   Display Topology.\n");
  } else {

  }
#line 328
  if ((capabilities & 1048576U) != 0U) {
#line 329
    printk("\016[drm]   GMR.\n");
  } else {

  }
#line 330
  if ((capabilities & 2097152U) != 0U) {
#line 331
    printk("\016[drm]   Traces.\n");
  } else {

  }
#line 332
  if ((capabilities & 4194304U) != 0U) {
#line 333
    printk("\016[drm]   GMR2.\n");
  } else {

  }
#line 334
  if ((capabilities & 8388608U) != 0U) {
#line 335
    printk("\016[drm]   Screen Object 2.\n");
  } else {

  }
#line 336
  return;
}
}
#line 352 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_dummy_query_bo_prepare(struct vmw_private *dev_priv ) 
{ 
  struct ttm_bo_kmap_obj map ;
  SVGA3dQueryResult volatile   *result ;
  bool dummy ;
  int ret ;
  struct ttm_bo_device *bdev ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 358
  bdev = & dev_priv->bdev;
#line 359
  bo = dev_priv->dummy_query_bo;
#line 361
  ttm_bo_reserve(bo, 0, 0, 0, 0U);
#line 362
  spin_lock(& bdev->fence_lock);
#line 363
  ret = ttm_bo_wait(bo, 0, 0, 0);
#line 364
  spin_unlock(& bdev->fence_lock);
#line 365
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 365
  if (tmp != 0L) {
#line 366
    vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
  } else {

  }
#line 369
  ret = ttm_bo_kmap(bo, 0UL, 1UL, & map);
#line 370
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 370
  if (tmp___1 != 0L) {
#line 371
    tmp___0 = ttm_kmap_obj_virtual(& map, & dummy);
#line 371
    result = (SVGA3dQueryResult volatile   *)tmp___0;
#line 372
    result->totalSize = 12U;
#line 373
    result->state = 0;
#line 374
    result->ldv_38484.result32 = 255U;
#line 375
    ttm_bo_kunmap(& map);
  } else {
#line 377
    drm_err("vmw_dummy_query_bo_prepare", "Dummy query buffer map failed.\n");
  }
#line 378
  ttm_bo_unreserve(bo);
#line 379
  return;
}
}
#line 393 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_dummy_query_bo_create(struct vmw_private *dev_priv ) 
{ 
  int tmp ;

  {
#line 395
  tmp = ttm_bo_create(& dev_priv->bdev, 4096UL, 0, & vmw_vram_sys_placement, 0U, 0,
                      0, & dev_priv->dummy_query_bo);
#line 395
  return (tmp);
}
}
#line 404 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_request_device(struct vmw_private *dev_priv ) 
{ 
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 408
  ret = vmw_fifo_init(dev_priv, & dev_priv->fifo);
#line 409
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 409
  if (tmp != 0L) {
#line 410
    drm_err("vmw_request_device", "Unable to initialize FIFO.\n");
#line 411
    return (ret);
  } else {

  }
#line 413
  vmw_fence_fifo_up(dev_priv->fman);
#line 414
  ret = vmw_dummy_query_bo_create(dev_priv);
#line 415
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 415
  if (tmp___0 != 0L) {
#line 416
    goto out_no_query_bo;
  } else {

  }
#line 417
  vmw_dummy_query_bo_prepare(dev_priv);
#line 419
  return (0);
  out_no_query_bo: 
#line 422
  vmw_fence_fifo_down(dev_priv->fman);
#line 423
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 424
  return (ret);
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_release_device(struct vmw_private *dev_priv ) 
{ 
  long tmp ;

  {
#line 434
  tmp = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                         0L);
#line 434
  if (tmp != 0L) {
#line 434
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (434), "i" (12UL));
    ldv_41404: ;
#line 434
    goto ldv_41404;
  } else {

  }
#line 436
  ttm_bo_unref(& dev_priv->dummy_query_bo);
#line 437
  vmw_fence_fifo_down(dev_priv->fman);
#line 438
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 439
  return;
}
}
#line 447 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) 
{ 
  int ret ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 450
  ret = 0;
#line 452
  ldv_mutex_lock_143(& dev_priv->release_mutex);
#line 453
  tmp___1 = dev_priv->num_3d_resources;
#line 453
  dev_priv->num_3d_resources = dev_priv->num_3d_resources + 1U;
#line 453
  tmp___2 = ldv__builtin_expect(tmp___1 == 0U, 0L);
#line 453
  if (tmp___2 != 0L) {
#line 454
    ret = vmw_request_device(dev_priv);
#line 455
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 455
    if (tmp != 0L) {
#line 456
      dev_priv->num_3d_resources = dev_priv->num_3d_resources - 1U;
    } else {

    }
  } else
#line 457
  if ((int )unhide_svga) {
#line 458
    ldv_mutex_lock_144(& dev_priv->hw_mutex);
#line 459
    tmp___0 = vmw_read(dev_priv, 1U);
#line 459
    vmw_write(dev_priv, 1U, tmp___0 & 4294967293U);
#line 462
    ldv_mutex_unlock_145(& dev_priv->hw_mutex);
  } else {

  }
#line 465
  ldv_mutex_unlock_146(& dev_priv->release_mutex);
#line 466
  return (ret);
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) 
{ 
  int32_t n3d ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 482
  ldv_mutex_lock_147(& dev_priv->release_mutex);
#line 483
  dev_priv->num_3d_resources = dev_priv->num_3d_resources - 1U;
#line 483
  tmp___0 = ldv__builtin_expect(dev_priv->num_3d_resources == 0U, 0L);
#line 483
  if (tmp___0 != 0L) {
#line 484
    vmw_release_device(dev_priv);
  } else
#line 485
  if ((int )hide_svga) {
#line 486
    ldv_mutex_lock_148(& dev_priv->hw_mutex);
#line 487
    tmp = vmw_read(dev_priv, 1U);
#line 487
    vmw_write(dev_priv, 1U, tmp | 2U);
#line 490
    ldv_mutex_unlock_149(& dev_priv->hw_mutex);
  } else {

  }
#line 493
  n3d = (int )dev_priv->num_3d_resources;
#line 494
  ldv_mutex_unlock_150(& dev_priv->release_mutex);
#line 496
  tmp___1 = ldv__builtin_expect(n3d < 0, 0L);
#line 496
  if (tmp___1 != 0L) {
#line 496
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (496), "i" (12UL));
    ldv_41415: ;
#line 496
    goto ldv_41415;
  } else {

  }
#line 498
  return;
}
}
#line 508 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_get_initial_size(struct vmw_private *dev_priv ) 
{ 
  uint32_t width ;
  uint32_t height ;
  uint32_t __max1 ;
  uint32_t __max2 ;
  uint32_t __max1___0 ;
  uint32_t __max2___0 ;

  {
#line 513
  width = vmw_read(dev_priv, 2U);
#line 514
  height = vmw_read(dev_priv, 3U);
#line 516
  __max1 = width;
#line 516
  __max2 = 800U;
#line 516
  width = __max1 > __max2 ? __max1 : __max2;
#line 517
  __max1___0 = height;
#line 517
  __max2___0 = 600U;
#line 517
  height = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 519
  if (dev_priv->fb_max_width < width || dev_priv->fb_max_height < height) {
#line 526
    width = 800U;
#line 527
    height = 600U;
  } else {

  }
#line 530
  dev_priv->initial_width = width;
#line 531
  dev_priv->initial_height = height;
#line 532
  return;
}
}
#line 534 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ 
  struct vmw_private *dev_priv ;
  int ret ;
  uint32_t svga_id ;
  enum vmw_res_type i ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
#line 541
  tmp = kzalloc(169840UL, 208U);
#line 541
  dev_priv = (struct vmw_private *)tmp;
#line 542
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv == (unsigned long )((struct vmw_private *)0),
                             0L);
#line 542
  if (tmp___0 != 0L) {
#line 543
    drm_err("vmw_driver_load", "Failed allocating a device private struct.\n");
#line 544
    return (-12);
  } else {

  }
#line 547
  pci_set_master(dev->pdev);
#line 549
  dev_priv->dev = dev;
#line 550
  dev_priv->vmw_chipset = chipset;
#line 551
  dev_priv->last_read_seqno = 4294967196U;
#line 552
  __mutex_init(& dev_priv->hw_mutex, "&dev_priv->hw_mutex", & __key);
#line 553
  __mutex_init(& dev_priv->cmdbuf_mutex, "&dev_priv->cmdbuf_mutex", & __key___0);
#line 554
  __mutex_init(& dev_priv->release_mutex, "&dev_priv->release_mutex", & __key___1);
#line 555
  __rwlock_init(& dev_priv->resource_lock, "&dev_priv->resource_lock", & __key___2);
#line 557
  i = 0;
#line 557
  goto ldv_41441;
  ldv_41440: 
#line 558
  idr_init((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 559
  INIT_LIST_HEAD((struct list_head *)(& dev_priv->res_lru) + (unsigned long )i);
#line 557
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41441: ;
#line 557
  if ((unsigned int )i <= 2U) {
#line 558
    goto ldv_41440;
  } else {

  }
#line 562
  __mutex_init(& dev_priv->init_mutex, "&dev_priv->init_mutex", & __key___3);
#line 563
  __init_waitqueue_head(& dev_priv->fence_queue, "&dev_priv->fence_queue", & __key___4);
#line 564
  __init_waitqueue_head(& dev_priv->fifo_queue, "&dev_priv->fifo_queue", & __key___5);
#line 565
  dev_priv->fence_queue_waiters = 0;
#line 566
  atomic_set(& dev_priv->fifo_queue_waiters, 0);
#line 568
  dev_priv->used_memory_size = 0U;
#line 570
  dev_priv->io_start = (unsigned int )(dev->pdev)->resource[0].start;
#line 571
  dev_priv->vram_start = (uint32_t )(dev->pdev)->resource[1].start;
#line 572
  dev_priv->mmio_start = (uint32_t )(dev->pdev)->resource[2].start;
#line 574
  dev_priv->enable_fb = enable_fbdev != 0;
#line 576
  ldv_mutex_lock_151(& dev_priv->hw_mutex);
#line 578
  vmw_write(dev_priv, 0U, 2415919106U);
#line 579
  svga_id = vmw_read(dev_priv, 0U);
#line 580
  if (svga_id != 2415919106U) {
#line 581
    ret = -38;
#line 582
    drm_err("vmw_driver_load", "Unsupported SVGA ID 0x%x\n", svga_id);
#line 583
    ldv_mutex_unlock_152(& dev_priv->hw_mutex);
#line 584
    goto out_err0;
  } else {

  }
#line 587
  dev_priv->capabilities = vmw_read(dev_priv, 17U);
#line 589
  dev_priv->vram_size = vmw_read(dev_priv, 15U);
#line 590
  dev_priv->mmio_size = vmw_read(dev_priv, 19U);
#line 591
  dev_priv->fb_max_width = vmw_read(dev_priv, 4U);
#line 592
  dev_priv->fb_max_height = vmw_read(dev_priv, 5U);
#line 594
  vmw_get_initial_size(dev_priv);
#line 596
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 597
    dev_priv->max_gmr_descriptors = vmw_read(dev_priv, 44U);
#line 600
    dev_priv->max_gmr_ids = vmw_read(dev_priv, 43U);
  } else {

  }
#line 603
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 604
    dev_priv->max_gmr_pages = vmw_read(dev_priv, 46U);
#line 606
    dev_priv->memory_size = vmw_read(dev_priv, 47U);
#line 608
    dev_priv->memory_size = dev_priv->memory_size - dev_priv->vram_size;
  } else {
#line 614
    dev_priv->memory_size = 536870912U;
  }
#line 617
  ldv_mutex_unlock_153(& dev_priv->hw_mutex);
#line 619
  vmw_print_capabilities(dev_priv->capabilities);
#line 621
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 622
    printk("\016[drm] Max GMR ids is %u\n", dev_priv->max_gmr_ids);
#line 624
    printk("\016[drm] Max GMR descriptors is %u\n", dev_priv->max_gmr_descriptors);
  } else {

  }
#line 627
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 628
    printk("\016[drm] Max number of GMR pages is %u\n", dev_priv->max_gmr_pages);
#line 630
    printk("\016[drm] Max dedicated hypervisor surface memory is %u kiB\n", dev_priv->memory_size / 1024U);
  } else {

  }
#line 633
  printk("\016[drm] VRAM at 0x%08x size is %u kiB\n", dev_priv->vram_start, dev_priv->vram_size / 1024U);
#line 635
  printk("\016[drm] MMIO at 0x%08x size is %u kiB\n", dev_priv->mmio_start, dev_priv->mmio_size / 1024U);
#line 638
  ret = vmw_ttm_global_init(dev_priv);
#line 639
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 639
  if (tmp___1 != 0L) {
#line 640
    goto out_err0;
  } else {

  }
#line 643
  vmw_master_init(& dev_priv->fbdev_master);
#line 644
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 645
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 648
  ret = ttm_bo_device_init(& dev_priv->bdev, (struct ttm_bo_global *)dev_priv->bo_global_ref.ref.object,
                           & vmw_bo_driver, 1048576ULL, 0);
#line 652
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 652
  if (tmp___2 != 0L) {
#line 653
    drm_err("vmw_driver_load", "Failed initializing TTM buffer object driver.\n");
#line 654
    goto out_err1;
  } else {

  }
#line 657
  ret = ttm_bo_init_mm(& dev_priv->bdev, 2U, (unsigned long )(dev_priv->vram_size >> 12));
#line 659
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 659
  if (tmp___3 != 0L) {
#line 660
    drm_err("vmw_driver_load", "Failed initializing memory manager for VRAM.\n");
#line 661
    goto out_err2;
  } else {

  }
#line 664
  dev_priv->has_gmr = 1;
#line 665
  tmp___4 = ttm_bo_init_mm(& dev_priv->bdev, 3U, (unsigned long )dev_priv->max_gmr_ids);
#line 665
  if (tmp___4 != 0) {
#line 667
    printk("\016[drm] No GMR memory available. Graphics memory resources are very limited.\n");
#line 669
    dev_priv->has_gmr = 0;
  } else {

  }
#line 672
  dev_priv->mmio_mtrr = drm_mtrr_add((unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
                                     1U);
#line 675
  tmp___5 = ioremap_wc((resource_size_t )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size);
#line 675
  dev_priv->mmio_virt = (__le32 *)tmp___5;
#line 678
  tmp___6 = ldv__builtin_expect((unsigned long )dev_priv->mmio_virt == (unsigned long )((__le32 *)0),
                             0L);
#line 678
  if (tmp___6 != 0L) {
#line 679
    ret = -12;
#line 680
    drm_err("vmw_driver_load", "Failed mapping MMIO.\n");
#line 681
    goto out_err3;
  } else {

  }
#line 685
  if ((dev_priv->capabilities & 524288U) == 0U && (dev_priv->capabilities & 131072U) == 0U) {
#line 685
    tmp___7 = vmw_fifo_have_pitchlock(dev_priv);
#line 685
    if (tmp___7) {
#line 685
      tmp___8 = 0;
    } else {
#line 685
      tmp___8 = 1;
    }
#line 685
    if (tmp___8) {
#line 688
      ret = -38;
#line 689
      drm_err("vmw_driver_load", "Hardware has no pitchlock\n");
#line 690
      goto out_err4;
    } else {

    }
  } else {

  }
#line 693
  dev_priv->tdev = ttm_object_device_init((struct ttm_mem_global *)dev_priv->mem_global_ref.object,
                                          12U);
#line 696
  tmp___9 = ldv__builtin_expect((unsigned long )dev_priv->tdev == (unsigned long )((struct ttm_object_device *)0),
                             0L);
#line 696
  if (tmp___9 != 0L) {
#line 697
    drm_err("vmw_driver_load", "Unable to initialize TTM object management.\n");
#line 698
    ret = -12;
#line 699
    goto out_err4;
  } else {

  }
#line 702
  dev->dev_private = (void *)dev_priv;
#line 704
  ret = pci_request_regions(dev->pdev, "vmwgfx probe");
#line 705
  dev_priv->stealth = ret != 0;
#line 706
  if ((int )dev_priv->stealth) {
#line 711
    printk("\016[drm] It appears like vesafb is loaded. Ignore above error if any.\n");
#line 713
    ret = pci_request_region(dev->pdev, 2, "vmwgfx stealth probe");
#line 714
    tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 714
    if (tmp___10 != 0L) {
#line 715
      drm_err("vmw_driver_load", "Failed reserving the SVGA MMIO resource.\n");
#line 716
      goto out_no_device;
    } else {

    }
  } else {

  }
#line 720
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 721
    ret = drm_irq_install(dev);
#line 722
    if (ret != 0) {
#line 723
      drm_err("vmw_driver_load", "Failed installing irq: %d\n", ret);
#line 724
      goto out_no_irq;
    } else {

    }
  } else {

  }
#line 728
  dev_priv->fman = vmw_fence_manager_init(dev_priv);
#line 729
  tmp___11 = ldv__builtin_expect((unsigned long )dev_priv->fman == (unsigned long )((struct vmw_fence_manager *)0),
                              0L);
#line 729
  if (tmp___11 != 0L) {
#line 730
    goto out_no_fman;
  } else {

  }
#line 732
  vmw_kms_save_vga(dev_priv);
#line 735
  ret = vmw_kms_init(dev_priv);
#line 736
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 736
  if (tmp___12 != 0L) {
#line 737
    goto out_no_kms;
  } else {

  }
#line 738
  vmw_overlay_init(dev_priv);
#line 740
  if ((int )dev_priv->enable_fb) {
#line 741
    ret = vmw_3d_resource_inc(dev_priv, 1);
#line 742
    tmp___13 = ldv__builtin_expect(ret != 0, 0L);
#line 742
    if (tmp___13 != 0L) {
#line 743
      goto out_no_fifo;
    } else {

    }
#line 744
    vmw_fb_init(dev_priv);
  } else {

  }
#line 747
  dev_priv->pm_nb.notifier_call = & vmwgfx_pm_notifier;
#line 748
  register_pm_notifier(& dev_priv->pm_nb);
#line 750
  return (0);
  out_no_fifo: 
#line 753
  vmw_overlay_close(dev_priv);
#line 754
  vmw_kms_close(dev_priv);
  out_no_kms: 
#line 756
  vmw_kms_restore_vga(dev_priv);
#line 757
  vmw_fence_manager_takedown(dev_priv->fman);
  out_no_fman: ;
#line 759
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 760
    drm_irq_uninstall(dev_priv->dev);
  } else {

  }
  out_no_irq: ;
#line 762
  if ((int )dev_priv->stealth) {
#line 763
    pci_release_region(dev->pdev, 2);
  } else {
#line 765
    pci_release_regions(dev->pdev);
  }
  out_no_device: 
#line 767
  ttm_object_device_release(& dev_priv->tdev);
  out_err4: 
#line 769
  iounmap((void volatile   *)dev_priv->mmio_virt);
  out_err3: 
#line 771
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 773
  if ((int )dev_priv->has_gmr) {
#line 774
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 775
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
  out_err2: 
#line 777
  ttm_bo_device_release(& dev_priv->bdev);
  out_err1: 
#line 779
  vmw_ttm_global_release(dev_priv);
  out_err0: 
#line 781
  i = 0;
#line 781
  goto ldv_41457;
  ldv_41456: 
#line 782
  idr_destroy((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 781
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41457: ;
#line 781
  if ((unsigned int )i <= 2U) {
#line 782
    goto ldv_41456;
  } else {

  }
#line 784
  kfree((void const   *)dev_priv);
#line 785
  return (ret);
}
}
#line 788 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_unload(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  enum vmw_res_type i ;

  {
#line 790
  tmp = vmw_priv(dev);
#line 790
  dev_priv = tmp;
#line 793
  unregister_pm_notifier(& dev_priv->pm_nb);
#line 795
  if ((int )dev_priv->ctx.res_ht_initialized) {
#line 796
    drm_ht_remove(& dev_priv->ctx.res_ht);
  } else {

  }
#line 797
  if ((unsigned long )dev_priv->ctx.cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 798
    vfree((void const   *)dev_priv->ctx.cmd_bounce);
  } else {

  }
#line 799
  if ((int )dev_priv->enable_fb) {
#line 800
    vmw_fb_close(dev_priv);
#line 801
    vmw_kms_restore_vga(dev_priv);
#line 802
    vmw_3d_resource_dec(dev_priv, 0);
  } else {

  }
#line 804
  vmw_kms_close(dev_priv);
#line 805
  vmw_overlay_close(dev_priv);
#line 806
  vmw_fence_manager_takedown(dev_priv->fman);
#line 807
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 808
    drm_irq_uninstall(dev_priv->dev);
  } else {

  }
#line 809
  if ((int )dev_priv->stealth) {
#line 810
    pci_release_region(dev->pdev, 2);
  } else {
#line 812
    pci_release_regions(dev->pdev);
  }
#line 814
  ttm_object_device_release(& dev_priv->tdev);
#line 815
  iounmap((void volatile   *)dev_priv->mmio_virt);
#line 816
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 818
  if ((int )dev_priv->has_gmr) {
#line 819
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 820
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
#line 821
  ttm_bo_device_release(& dev_priv->bdev);
#line 822
  vmw_ttm_global_release(dev_priv);
#line 824
  i = 0;
#line 824
  goto ldv_41465;
  ldv_41464: 
#line 825
  idr_destroy((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 824
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41465: ;
#line 824
  if ((unsigned int )i <= 2U) {
#line 825
    goto ldv_41464;
  } else {

  }
#line 827
  kfree((void const   *)dev_priv);
#line 829
  return (0);
}
}
#line 832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_preclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 835
  tmp = vmw_fpriv(file_priv);
#line 835
  vmw_fp = tmp;
#line 836
  tmp___0 = vmw_priv(dev);
#line 836
  dev_priv = tmp___0;
#line 838
  vmw_event_fence_fpriv_gone(dev_priv->fman, & vmw_fp->fence_events);
#line 839
  return;
}
}
#line 841 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_postclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_fpriv *vmw_fp ;

  {
#line 846
  vmw_fp = vmw_fpriv(file_priv);
#line 847
  ttm_object_file_release(& vmw_fp->tfile);
#line 848
  if ((unsigned long )vmw_fp->locked_master != (unsigned long )((struct drm_master *)0)) {
#line 849
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 850
  kfree((void const   *)vmw_fp);
#line 851
  return;
}
}
#line 853 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_open(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 855
  tmp = vmw_priv(dev);
#line 855
  dev_priv = tmp;
#line 857
  ret = -12;
#line 859
  tmp___0 = kzalloc(32UL, 208U);
#line 859
  vmw_fp = (struct vmw_fpriv *)tmp___0;
#line 860
  tmp___1 = ldv__builtin_expect((unsigned long )vmw_fp == (unsigned long )((struct vmw_fpriv *)0),
                             0L);
#line 860
  if (tmp___1 != 0L) {
#line 861
    return (ret);
  } else {

  }
#line 863
  INIT_LIST_HEAD(& vmw_fp->fence_events);
#line 864
  vmw_fp->tfile = ttm_object_file_init(dev_priv->tdev, 10U);
#line 865
  tmp___2 = ldv__builtin_expect((unsigned long )vmw_fp->tfile == (unsigned long )((struct ttm_object_file *)0),
                             0L);
#line 865
  if (tmp___2 != 0L) {
#line 866
    goto out_no_tfile;
  } else {

  }
#line 868
  file_priv->driver_priv = (void *)vmw_fp;
#line 869
  dev_priv->bdev.dev_mapping = dev->dev_mapping;
#line 871
  return (0);
  out_no_tfile: 
#line 874
  kfree((void const   *)vmw_fp);
#line 875
  return (ret);
}
}
#line 878 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static long vmw_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ 
  struct drm_file *file_priv ;
  struct drm_device *dev ;
  unsigned int nr ;
  struct drm_ioctl_desc *ioctl ;
  long tmp ;
  long tmp___0 ;

  {
#line 881
  file_priv = (struct drm_file *)filp->private_data;
#line 882
  dev = (file_priv->minor)->dev;
#line 883
  nr = cmd & 255U;
#line 889
  if ((nr > 63U && nr <= 159U) && (unsigned int )((dev->driver)->num_ioctls + 64) > nr) {
#line 891
    ioctl = (struct drm_ioctl_desc *)(& vmw_ioctls) + (unsigned long )(nr - 64U);
#line 894
    tmp = ldv__builtin_expect(ioctl->cmd_drv != cmd, 0L);
#line 894
    if (tmp != 0L) {
#line 895
      drm_err("vmw_unlocked_ioctl", "Invalid command format, ioctl %d\n", nr - 64U);
#line 897
      return (-22L);
    } else {

    }
  } else {

  }
#line 901
  tmp___0 = drm_ioctl(filp, cmd, arg);
#line 901
  return (tmp___0);
}
}
#line 904 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_firstopen(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;

  {
#line 906
  tmp = vmw_priv(dev);
#line 906
  dev_priv = tmp;
#line 907
  dev_priv->is_opened = 1;
#line 909
  return (0);
}
}
#line 912 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_lastclose(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_crtc *crtc ;
  struct drm_mode_set set ;
  int ret ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 914
  tmp = vmw_priv(dev);
#line 914
  dev_priv = tmp;
#line 923
  if (! dev_priv->is_opened) {
#line 924
    return;
  } else {

  }
#line 926
  dev_priv->is_opened = 0;
#line 927
  set.x = 0U;
#line 928
  set.y = 0U;
#line 929
  set.fb = 0;
#line 930
  set.mode = 0;
#line 931
  set.connectors = 0;
#line 932
  set.num_connectors = 0UL;
#line 934
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 934
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 934
  goto ldv_41514;
  ldv_41513: 
#line 935
  set.crtc = crtc;
#line 936
  ret = (*((crtc->funcs)->set_config))(& set);
#line 937
  __ret_warn_on = ret != 0;
#line 937
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 937
  if (tmp___0 != 0L) {
#line 937
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared",
                       937);
  } else {

  }
#line 937
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 934
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 934
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_41514: ;
#line 934
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 935
    goto ldv_41513;
  } else {

  }

#line 939
  return;
}
}
#line 942 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_init(struct vmw_master *vmaster ) 
{ 
  struct lock_class_key __key ;

  {
#line 944
  ttm_lock_init(& vmaster->lock);
#line 945
  INIT_LIST_HEAD(& vmaster->fb_surf);
#line 946
  __mutex_init(& vmaster->fb_surf_mutex, "&vmaster->fb_surf_mutex", & __key);
#line 948
  return;
}
}
#line 949 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_create(struct drm_device *dev , struct drm_master *master ) 
{ 
  struct vmw_master *vmaster ;
  void *tmp ;
  long tmp___0 ;

  {
#line 954
  tmp = kzalloc(448UL, 208U);
#line 954
  vmaster = (struct vmw_master *)tmp;
#line 955
  tmp___0 = ldv__builtin_expect((unsigned long )vmaster == (unsigned long )((struct vmw_master *)0),
                             0L);
#line 955
  if (tmp___0 != 0L) {
#line 956
    return (-12);
  } else {

  }
#line 958
  vmw_master_init(vmaster);
#line 959
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 960
  master->driver_priv = (void *)vmaster;
#line 962
  return (0);
}
}
#line 965 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_destroy(struct drm_device *dev , struct drm_master *master ) 
{ 
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 968
  tmp = vmw_master(master);
#line 968
  vmaster = tmp;
#line 970
  master->driver_priv = 0;
#line 971
  kfree((void const   *)vmaster);
#line 972
  return;
}
}
#line 975 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_set(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *active ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 979
  tmp = vmw_priv(dev);
#line 979
  dev_priv = tmp;
#line 980
  tmp___0 = vmw_fpriv(file_priv);
#line 980
  vmw_fp = tmp___0;
#line 981
  active = dev_priv->active_master;
#line 982
  tmp___1 = vmw_master(file_priv->master);
#line 982
  vmaster = tmp___1;
#line 983
  ret = 0;
#line 985
  if (! dev_priv->enable_fb) {
#line 986
    ret = vmw_3d_resource_inc(dev_priv, 1);
#line 987
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 987
    if (tmp___2 != 0L) {
#line 988
      return (ret);
    } else {

    }
#line 989
    vmw_kms_save_vga(dev_priv);
#line 990
    ldv_mutex_lock_154(& dev_priv->hw_mutex);
#line 991
    vmw_write(dev_priv, 45U, 0U);
#line 992
    ldv_mutex_unlock_155(& dev_priv->hw_mutex);
  } else {

  }
#line 995
  if ((unsigned long )active != (unsigned long )((struct vmw_master *)0)) {
#line 996
    tmp___3 = ldv__builtin_expect((unsigned long )(& dev_priv->fbdev_master) != (unsigned long )active,
                               0L);
#line 996
    if (tmp___3 != 0L) {
#line 996
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (996), "i" (12UL));
      ldv_41540: ;
#line 996
      goto ldv_41540;
    } else {

    }
#line 997
    ret = ttm_vt_lock(& active->lock, 0, vmw_fp->tfile);
#line 998
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 998
    if (tmp___4 != 0L) {
#line 999
      goto out_no_active_lock;
    } else {

    }
#line 1001
    ttm_lock_set_kill(& active->lock, 1, 15);
#line 1002
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1003
    tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1003
    if (tmp___5 != 0L) {
#line 1004
      drm_err("vmw_master_set", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1008
    dev_priv->active_master = 0;
  } else {

  }
#line 1011
  ttm_lock_set_kill(& vmaster->lock, 0, 15);
#line 1012
  if (! from_open) {
#line 1013
    ttm_vt_unlock(& vmaster->lock);
#line 1014
    tmp___6 = ldv__builtin_expect((unsigned long )vmw_fp->locked_master != (unsigned long )file_priv->master,
                               0L);
#line 1014
    if (tmp___6 != 0L) {
#line 1014
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (1014), "i" (12UL));
      ldv_41543: ;
#line 1014
      goto ldv_41543;
    } else {

    }
#line 1015
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1018
  dev_priv->active_master = vmaster;
#line 1020
  return (0);
  out_no_active_lock: ;
#line 1023
  if (! dev_priv->enable_fb) {
#line 1024
    vmw_kms_restore_vga(dev_priv);
#line 1025
    vmw_3d_resource_dec(dev_priv, 1);
#line 1026
    ldv_mutex_lock_156(& dev_priv->hw_mutex);
#line 1027
    vmw_write(dev_priv, 45U, 1U);
#line 1028
    ldv_mutex_unlock_157(& dev_priv->hw_mutex);
  } else {

  }
#line 1030
  return (ret);
}
}
#line 1033 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_drop(struct drm_device *dev , struct drm_file *file_priv ,
                            bool from_release ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1037
  tmp = vmw_priv(dev);
#line 1037
  dev_priv = tmp;
#line 1038
  tmp___0 = vmw_fpriv(file_priv);
#line 1038
  vmw_fp = tmp___0;
#line 1039
  tmp___1 = vmw_master(file_priv->master);
#line 1039
  vmaster = tmp___1;
#line 1047
  vmw_fp->locked_master = drm_master_get(file_priv->master);
#line 1048
  ret = ttm_vt_lock(& vmaster->lock, 0, vmw_fp->tfile);
#line 1049
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 1051
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1051
  if (tmp___2 != 0L) {
#line 1052
    drm_err("vmw_master_drop", "Unable to lock TTM at VT switch.\n");
#line 1053
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1056
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 1058
  if (! dev_priv->enable_fb) {
#line 1059
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1060
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1060
    if (tmp___3 != 0L) {
#line 1061
      drm_err("vmw_master_drop", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1062
    vmw_kms_restore_vga(dev_priv);
#line 1063
    vmw_3d_resource_dec(dev_priv, 1);
#line 1064
    ldv_mutex_lock_158(& dev_priv->hw_mutex);
#line 1065
    vmw_write(dev_priv, 45U, 1U);
#line 1066
    ldv_mutex_unlock_159(& dev_priv->hw_mutex);
  } else {

  }
#line 1069
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 1070
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 1071
  ttm_vt_unlock(& dev_priv->fbdev_master.lock);
#line 1073
  if ((int )dev_priv->enable_fb) {
#line 1074
    vmw_fb_on(dev_priv);
  } else {

  }
#line 1075
  return;
}
}
#line 1078 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_remove(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;

  {
#line 1080
  tmp = pci_get_drvdata(pdev);
#line 1080
  dev = (struct drm_device *)tmp;
#line 1082
  drm_put_dev(dev);
#line 1083
  return;
}
}
#line 1085 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) 
{ 
  struct vmw_private *dev_priv ;
  struct notifier_block  const  *__mptr ;
  struct vmw_master *vmaster ;

  {
#line 1089
  __mptr = (struct notifier_block  const  *)nb;
#line 1089
  dev_priv = (struct vmw_private *)__mptr + 0xfffffffffffd69b8UL;
#line 1090
  vmaster = dev_priv->active_master;
#line 1092
  switch (val) {
  case 1UL: ;
  case 3UL: 
#line 1095
  ttm_suspend_lock(& vmaster->lock);
#line 1101
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 1102
  vmw_resource_evict_all(dev_priv);
#line 1103
  ttm_bo_swapout_all(& dev_priv->bdev);
#line 1105
  goto ldv_41569;
  case 2UL: ;
  case 4UL: ;
  case 6UL: 
#line 1109
  ttm_suspend_unlock(& vmaster->lock);
#line 1111
  goto ldv_41569;
  case 5UL: ;
#line 1113
  goto ldv_41569;
  default: ;
#line 1115
  goto ldv_41569;
  }
  ldv_41569: ;
#line 1117
  return (0);
}
}
#line 1124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1126
  tmp = pci_get_drvdata(pdev);
#line 1126
  dev = (struct drm_device *)tmp;
#line 1127
  tmp___0 = vmw_priv(dev);
#line 1127
  dev_priv = tmp___0;
#line 1129
  if (dev_priv->num_3d_resources != 0U) {
#line 1130
    printk("\016[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1132
    return (-16);
  } else {

  }
#line 1135
  pci_save_state(pdev);
#line 1136
  pci_disable_device(pdev);
#line 1137
  pci_set_power_state(pdev, 3);
#line 1138
  return (0);
}
}
#line 1141 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_resume(struct pci_dev *pdev ) 
{ 
  int tmp ;

  {
#line 1143
  pci_set_power_state(pdev, 0);
#line 1144
  pci_restore_state(pdev);
#line 1145
  tmp = pci_enable_device(pdev);
#line 1145
  return (tmp);
}
}
#line 1148 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_suspend(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct pm_message dummy ;
  int tmp ;

  {
#line 1150
  __mptr = (struct device  const  *)kdev;
#line 1150
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1153
  dummy.event = 0;
#line 1155
  tmp = vmw_pci_suspend(pdev, dummy);
#line 1155
  return (tmp);
}
}
#line 1158 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_resume(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1160
  __mptr = (struct device  const  *)kdev;
#line 1160
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1162
  tmp = vmw_pci_resume(pdev);
#line 1162
  return (tmp);
}
}
#line 1165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_prepare(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1167
  __mptr = (struct device  const  *)kdev;
#line 1167
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1168
  tmp = pci_get_drvdata(pdev);
#line 1168
  dev = (struct drm_device *)tmp;
#line 1169
  tmp___0 = vmw_priv(dev);
#line 1169
  dev_priv = tmp___0;
#line 1175
  dev_priv->suspended = 1;
#line 1176
  if ((int )dev_priv->enable_fb) {
#line 1177
    vmw_3d_resource_dec(dev_priv, 1);
  } else {

  }
#line 1179
  if (dev_priv->num_3d_resources != 0U) {
#line 1181
    printk("\016[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1184
    if ((int )dev_priv->enable_fb) {
#line 1185
      vmw_3d_resource_inc(dev_priv, 1);
    } else {

    }
#line 1186
    dev_priv->suspended = 0;
#line 1187
    return (-16);
  } else {

  }
#line 1190
  return (0);
}
}
#line 1193 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_pm_complete(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1195
  __mptr = (struct device  const  *)kdev;
#line 1195
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1196
  tmp = pci_get_drvdata(pdev);
#line 1196
  dev = (struct drm_device *)tmp;
#line 1197
  tmp___0 = vmw_priv(dev);
#line 1197
  dev_priv = tmp___0;
#line 1199
  ldv_mutex_lock_160(& dev_priv->hw_mutex);
#line 1200
  vmw_write(dev_priv, 0U, 2415919106U);
#line 1201
  vmw_read(dev_priv, 0U);
#line 1202
  ldv_mutex_unlock_161(& dev_priv->hw_mutex);
#line 1208
  if ((int )dev_priv->enable_fb) {
#line 1209
    vmw_3d_resource_inc(dev_priv, 0);
  } else {

  }
#line 1211
  dev_priv->suspended = 0;
#line 1212
  return;
}
}
#line 1214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct dev_pm_ops  const  vmw_pm_ops  = 
#line 1214
     {& vmw_pm_prepare, & vmw_pm_complete, & vmw_pm_suspend, & vmw_pm_resume, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1221 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct file_operations  const  vmwgfx_driver_fops  = 
#line 1221
     {& __this_module, & noop_llseek, & vmw_fops_read, 0, 0, 0, 0, & vmw_fops_poll,
    & vmw_unlocked_ioctl, & drm_compat_ioctl, & vmw_mmap, & drm_open, 0, & drm_release,
    0, 0, & drm_fasync, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1236 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_driver driver  = 
#line 1236
     {& vmw_driver_load, & vmw_firstopen, & vmw_driver_open, & vmw_preclose, & vmw_postclose,
    & vmw_lastclose, & vmw_driver_unload, 0, 0, 0, 0, 0, & vmw_get_vblank_counter,
    & vmw_enable_vblank, & vmw_disable_vblank, 0, 0, 0, & vmw_irq_handler, & vmw_irq_preinstall,
    & vmw_irq_postinstall, & vmw_irq_uninstall, 0, & vmw_master_create, & vmw_master_destroy,
    & vmw_master_set, & vmw_master_drop, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vmw_dumb_create,
    & vmw_dumb_map_offset, & vmw_dumb_destroy, 0, 2, 4, 0, (char *)"vmwgfx", (char *)"Linux drm driver for VMware graphics devices",
    (char *)"20120209", 8384U, 0, (struct drm_ioctl_desc *)(& vmw_ioctls), 21, & vmwgfx_driver_fops,
    {0}, 0, {0, 0}};
#line 1274 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_driver vmw_pci_driver  = 
#line 1274
     {{0, 0}, "vmwgfx", (struct pci_device_id  const  *)(& vmw_pci_id_list), & vmw_probe,
    & vmw_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                        0, & vmw_pm_ops, 0}, {{{{{{0U}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
#line 1284 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  int tmp ;

  {
#line 1286
  tmp = drm_get_pci_dev(pdev, ent, & driver);
#line 1286
  return (tmp);
}
}
#line 1289 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_init(void) 
{ 
  int ret ;

  {
#line 1292
  ret = drm_pci_init(& driver, & vmw_pci_driver);
#line 1293
  if (ret != 0) {
#line 1294
    drm_err("vmwgfx_init", "Failed initializing DRM.\n");
  } else {

  }
#line 1295
  return (ret);
}
}
#line 1298 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmwgfx_exit(void) 
{ 


  {
#line 1300
  drm_pci_exit(& driver, & vmw_pci_driver);
#line 1301
  return;
}
}
#line 1333
extern void ldv_check_return_value(int  ) ;
#line 1336
extern void ldv_check_return_value_probe(int  ) ;
#line 1351 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_main3_sequence_infinite_withcheck_stateful(void) 
{ 
  struct device *var_group1 ;
  struct file *var_group2 ;
  unsigned int var_vmw_unlocked_ioctl_13_p1 ;
  unsigned long var_vmw_unlocked_ioctl_13_p2 ;
  struct drm_device *var_group3 ;
  unsigned long var_vmw_driver_load_8_p1 ;
  struct drm_master *var_group4 ;
  struct drm_file *var_group5 ;
  bool var_vmw_master_set_19_p2 ;
  bool var_vmw_master_drop_20_p2 ;
  int res_vmw_driver_open_12 ;
  struct pci_dev *var_group6 ;
  struct pci_device_id  const  *var_vmw_probe_29_p1 ;
  int res_vmw_probe_29 ;
  int ldv_s_driver_drm_driver ;
  int ldv_s_vmw_pci_driver_pci_driver ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2897
  ldv_s_driver_drm_driver = 0;
#line 2900
  ldv_s_vmw_pci_driver_pci_driver = 0;
#line 2801
  LDV_IN_INTERRUPT = 1;
#line 2810
  ldv_initialize();
#line 2890
  ldv_handler_precall();
#line 2891
  tmp = vmwgfx_init();
#line 2891
  if (tmp != 0) {
#line 2892
    goto ldv_final;
  } else {

  }
#line 2903
  goto ldv_41700;
  ldv_41699: 
#line 2908
  tmp___0 = __VERIFIER_nondet_int();
#line 2908
  switch (tmp___0) {
  case 0: 
#line 2990
  ldv_handler_precall();
#line 2991
  vmw_pm_prepare(var_group1);
#line 3002
  goto ldv_41679;
  case 1: 
#line 3083
  ldv_handler_precall();
#line 3084
  vmw_pm_complete(var_group1);
#line 3095
  goto ldv_41679;
  case 2: 
#line 3176
  ldv_handler_precall();
#line 3177
  vmw_pm_suspend(var_group1);
#line 3188
  goto ldv_41679;
  case 3: 
#line 3269
  ldv_handler_precall();
#line 3270
  vmw_pm_resume(var_group1);
#line 3281
  goto ldv_41679;
  case 4: 
#line 3362
  ldv_handler_precall();
#line 3363
  vmw_unlocked_ioctl(var_group2, var_vmw_unlocked_ioctl_13_p1, var_vmw_unlocked_ioctl_13_p2);
#line 3374
  goto ldv_41679;
  case 5: ;
#line 3378
  if (ldv_s_driver_drm_driver == 0) {
#line 3455
    ldv_handler_precall();
#line 3456
    res_vmw_driver_open_12 = vmw_driver_open(var_group3, var_group5);
#line 3457
    ldv_check_return_value(res_vmw_driver_open_12);
#line 3458
    if (res_vmw_driver_open_12 != 0) {
#line 3459
      goto ldv_module_exit;
    } else {

    }
#line 3464
    ldv_s_driver_drm_driver = 0;
  } else {

  }
#line 3470
  goto ldv_41679;
  case 6: 
#line 3551
  ldv_handler_precall();
#line 3552
  vmw_driver_load(var_group3, var_vmw_driver_load_8_p1);
#line 3563
  goto ldv_41679;
  case 7: 
#line 3644
  ldv_handler_precall();
#line 3645
  vmw_driver_unload(var_group3);
#line 3656
  goto ldv_41679;
  case 8: 
#line 3737
  ldv_handler_precall();
#line 3738
  vmw_firstopen(var_group3);
#line 3749
  goto ldv_41679;
  case 9: 
#line 3830
  ldv_handler_precall();
#line 3831
  vmw_lastclose(var_group3);
#line 3842
  goto ldv_41679;
  case 10: 
#line 3923
  ldv_handler_precall();
#line 3924
  vmw_master_create(var_group3, var_group4);
#line 3935
  goto ldv_41679;
  case 11: 
#line 4016
  ldv_handler_precall();
#line 4017
  vmw_master_destroy(var_group3, var_group4);
#line 4028
  goto ldv_41679;
  case 12: 
#line 4109
  ldv_handler_precall();
#line 4110
  vmw_master_set(var_group3, var_group5, (int )var_vmw_master_set_19_p2);
#line 4121
  goto ldv_41679;
  case 13: 
#line 4202
  ldv_handler_precall();
#line 4203
  vmw_master_drop(var_group3, var_group5, (int )var_vmw_master_drop_20_p2);
#line 4214
  goto ldv_41679;
  case 14: 
#line 4295
  ldv_handler_precall();
#line 4296
  vmw_preclose(var_group3, var_group5);
#line 4307
  goto ldv_41679;
  case 15: 
#line 4388
  ldv_handler_precall();
#line 4389
  vmw_postclose(var_group3, var_group5);
#line 4400
  goto ldv_41679;
  case 16: ;
#line 4404
  if (ldv_s_vmw_pci_driver_pci_driver == 0) {
#line 4483
    res_vmw_probe_29 = vmw_probe(var_group6, var_vmw_probe_29_p1);
#line 4484
    ldv_check_return_value(res_vmw_probe_29);
#line 4485
    ldv_check_return_value_probe(res_vmw_probe_29);
#line 4486
    if (res_vmw_probe_29 != 0) {
#line 4487
      goto ldv_module_exit;
    } else {

    }
#line 4488
    ldv_s_vmw_pci_driver_pci_driver = ldv_s_vmw_pci_driver_pci_driver + 1;
  } else {

  }
#line 4494
  goto ldv_41679;
  case 17: ;
#line 4498
  if (ldv_s_vmw_pci_driver_pci_driver == 1) {
#line 4575
    ldv_handler_precall();
#line 4576
    vmw_remove(var_group6);
#line 4581
    ldv_s_vmw_pci_driver_pci_driver = 0;
  } else {

  }
#line 4587
  goto ldv_41679;
  default: ;
#line 4588
  goto ldv_41679;
  }
  ldv_41679: ;
  ldv_41700: 
#line 2903
  tmp___1 = __VERIFIER_nondet_int();
#line 2903
  if ((tmp___1 != 0 || ldv_s_driver_drm_driver != 0) || ldv_s_vmw_pci_driver_pci_driver != 0) {
#line 2906
    goto ldv_41699;
  } else {

  }

  ldv_module_exit: 
#line 4674
  ldv_handler_precall();
#line 4675
  vmwgfx_exit();
  ldv_final: 
#line 4678
  ldv_check_final_state();
#line 4681
  return;
}
}
#line 4685 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4690
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 4692
  mutex_lock(ldv_func_arg1);
#line 4693
  return;
}
}
#line 4695 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4700
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 4702
  mutex_unlock(ldv_func_arg1);
#line 4703
  return;
}
}
#line 4705 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4710
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 4712
  mutex_lock(ldv_func_arg1);
#line 4713
  return;
}
}
#line 4715 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_mutex_trylock_132(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 4720
  tmp = mutex_trylock(ldv_func_arg1);
#line 4720
  ldv_func_res = tmp;
#line 4722
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 4722
  return (tmp___0);
#line 4724
  return (ldv_func_res);
}
}
#line 4727 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4732
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 4734
  mutex_unlock(ldv_func_arg1);
#line 4735
  return;
}
}
#line 4737 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4742
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 4744
  mutex_lock(ldv_func_arg1);
#line 4745
  return;
}
}
#line 4747 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4752
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 4754
  mutex_unlock(ldv_func_arg1);
#line 4755
  return;
}
}
#line 4757 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4762
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 4764
  mutex_lock(ldv_func_arg1);
#line 4765
  return;
}
}
#line 4767 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4772
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 4774
  mutex_unlock(ldv_func_arg1);
#line 4775
  return;
}
}
#line 4777 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4782
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 4784
  mutex_unlock(ldv_func_arg1);
#line 4785
  return;
}
}
#line 4787 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4792
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 4794
  mutex_lock(ldv_func_arg1);
#line 4795
  return;
}
}
#line 4797 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4802
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 4804
  mutex_unlock(ldv_func_arg1);
#line 4805
  return;
}
}
#line 4807 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4812
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 4814
  mutex_lock(ldv_func_arg1);
#line 4815
  return;
}
}
#line 4817 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4822
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 4824
  mutex_unlock(ldv_func_arg1);
#line 4825
  return;
}
}
#line 4827 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4832
  ldv_mutex_lock_release_mutex(ldv_func_arg1);
#line 4834
  mutex_lock(ldv_func_arg1);
#line 4835
  return;
}
}
#line 4837 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4842
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4844
  mutex_lock(ldv_func_arg1);
#line 4845
  return;
}
}
#line 4847 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4852
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4854
  mutex_unlock(ldv_func_arg1);
#line 4855
  return;
}
}
#line 4857 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4862
  ldv_mutex_unlock_release_mutex(ldv_func_arg1);
#line 4864
  mutex_unlock(ldv_func_arg1);
#line 4865
  return;
}
}
#line 4867 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4872
  ldv_mutex_lock_release_mutex(ldv_func_arg1);
#line 4874
  mutex_lock(ldv_func_arg1);
#line 4875
  return;
}
}
#line 4877 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4882
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4884
  mutex_lock(ldv_func_arg1);
#line 4885
  return;
}
}
#line 4887 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4892
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4894
  mutex_unlock(ldv_func_arg1);
#line 4895
  return;
}
}
#line 4897 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4902
  ldv_mutex_unlock_release_mutex(ldv_func_arg1);
#line 4904
  mutex_unlock(ldv_func_arg1);
#line 4905
  return;
}
}
#line 4907 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4912
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4914
  mutex_lock(ldv_func_arg1);
#line 4915
  return;
}
}
#line 4917 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4922
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4924
  mutex_unlock(ldv_func_arg1);
#line 4925
  return;
}
}
#line 4927 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4932
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4934
  mutex_unlock(ldv_func_arg1);
#line 4935
  return;
}
}
#line 4937 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4942
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4944
  mutex_lock(ldv_func_arg1);
#line 4945
  return;
}
}
#line 4947 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4952
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4954
  mutex_unlock(ldv_func_arg1);
#line 4955
  return;
}
}
#line 4957 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4962
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4964
  mutex_lock(ldv_func_arg1);
#line 4965
  return;
}
}
#line 4967 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4972
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4974
  mutex_unlock(ldv_func_arg1);
#line 4975
  return;
}
}
#line 4977 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4982
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4984
  mutex_lock(ldv_func_arg1);
#line 4985
  return;
}
}
#line 4987 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4992
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4994
  mutex_unlock(ldv_func_arg1);
#line 4995
  return;
}
}
#line 4997 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 5002
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 5004
  mutex_lock(ldv_func_arg1);
#line 5005
  return;
}
}
#line 5007 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 5012
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 5014
  mutex_unlock(ldv_func_arg1);
#line 5015
  return;
}
}
#line 62 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->ldv_5961.rlock);
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
#line 341
  return;
}
}
#line 412 "include/linux/workqueue.h"
extern bool schedule_delayed_work(struct delayed_work * , unsigned long  ) ;
#line 422
extern bool flush_delayed_work(struct delayed_work * ) ;
#line 504 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ 
  struct apertures_struct *a ;
  void *tmp ;

  {
#line 505
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
#line 505
  a = (struct apertures_struct *)tmp;
#line 507
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
#line 508
    return (0);
  } else {

  }
#line 509
  a->count = max_num;
#line 510
  return (a);
}
}
#line 594
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
#line 595
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
#line 596
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
#line 609
extern int register_framebuffer(struct fb_info * ) ;
#line 610
extern int unregister_framebuffer(struct fb_info * ) ;
#line 653
extern void fb_deferred_io_init(struct fb_info * ) ;
#line 657
extern void fb_deferred_io_cleanup(struct fb_info * ) ;
#line 681
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
#line 682
extern void framebuffer_release(struct fb_info * ) ;
#line 134 "include/drm/ttm/ttm_lock.h"
extern void ttm_write_unlock(struct ttm_lock * ) ;
#line 146
extern int ttm_write_lock(struct ttm_lock * , bool  ) ;
#line 458 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) ;
#line 459
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) ;
#line 563
struct ttm_placement vmw_vram_ne_placement ;
#line 650
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) ;
#line 712
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) ;
#line 172 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                            unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ 
  struct vmw_fb_par *par ;
  u32 *pal ;

  {
#line 176
  par = (struct vmw_fb_par *)info->par;
#line 177
  pal = (u32 *)(& par->pseudo_palette);
#line 179
  if (regno > 15U) {
#line 180
    drm_err("vmw_fb_setcolreg", "Bad regno %u.\n", regno);
#line 181
    return (1);
  } else {

  }
#line 184
  switch (par->depth) {
  case 24U: ;
  case 32U: 
#line 187
  *(pal + (unsigned long )regno) = (((red & 65280U) << 8) | (green & 65280U)) | ((blue & 65280U) >> 8);
#line 190
  goto ldv_40526;
  default: 
#line 192
  drm_err("vmw_fb_setcolreg", "Bad depth %u, bpp %u.\n", par->depth, par->bpp);
#line 193
  return (1);
  }
  ldv_40526: ;
#line 196
  return (0);
}
}
#line 199 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_check_var(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 
  int depth ;
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 202
  depth = (int )var->bits_per_pixel;
#line 203
  par = (struct vmw_fb_par *)info->par;
#line 204
  vmw_priv___0 = par->vmw_priv;
#line 206
  switch (var->bits_per_pixel) {
  case 32U: 
#line 208
  depth = var->transp.length != 0U ? 32 : 24;
#line 209
  goto ldv_40536;
  default: 
#line 211
  drm_err("vmw_fb_check_var", "Bad bpp %u.\n", var->bits_per_pixel);
#line 212
  return (-22);
  }
  ldv_40536: ;
#line 215
  switch (depth) {
  case 24: 
#line 217
  var->red.offset = 16U;
#line 218
  var->green.offset = 8U;
#line 219
  var->blue.offset = 0U;
#line 220
  var->red.length = 8U;
#line 221
  var->green.length = 8U;
#line 222
  var->blue.length = 8U;
#line 223
  var->transp.length = 0U;
#line 224
  var->transp.offset = 0U;
#line 225
  goto ldv_40540;
  case 32: 
#line 227
  var->red.offset = 16U;
#line 228
  var->green.offset = 8U;
#line 229
  var->blue.offset = 0U;
#line 230
  var->red.length = 8U;
#line 231
  var->green.length = 8U;
#line 232
  var->blue.length = 8U;
#line 233
  var->transp.length = 8U;
#line 234
  var->transp.offset = 24U;
#line 235
  goto ldv_40540;
  default: 
#line 237
  drm_err("vmw_fb_check_var", "Bad depth %u.\n", depth);
#line 238
  return (-22);
  }
  ldv_40540: ;
#line 241
  if ((vmw_priv___0->capabilities & 524288U) == 0U && (var->xoffset != 0U || var->yoffset != 0U)) {
#line 243
    drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
#line 244
    return (-22);
  } else {

  }
#line 247
  if (var->xoffset + var->xres > par->max_width || var->yoffset + var->yres > par->max_height) {
#line 249
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 250
    return (-22);
  } else {

  }
#line 253
  tmp = vmw_kms_validate_mode_vram(vmw_priv___0, info->fix.line_length, var->yoffset + var->yres);
#line 253
  if (tmp) {
#line 253
    tmp___0 = 0;
  } else {
#line 253
    tmp___0 = 1;
  }
#line 253
  if (tmp___0) {
#line 256
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 257
    return (-22);
  } else {

  }
#line 260
  return (0);
}
}
#line 263 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_set_par(struct fb_info *info ) 
{ 
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  int ret ;
  int __ret_warn_on ;
  uint32_t tmp ;
  long tmp___0 ;

  {
#line 265
  par = (struct vmw_fb_par *)info->par;
#line 266
  vmw_priv___0 = par->vmw_priv;
#line 269
  ret = vmw_kms_write_svga(vmw_priv___0, info->var.xres, info->var.yres, info->fix.line_length,
                           par->bpp, par->depth);
#line 272
  if (ret != 0) {
#line 273
    return (ret);
  } else {

  }
#line 275
  if ((vmw_priv___0->capabilities & 524288U) != 0U) {
#line 277
    vmw_write(vmw_priv___0, 34U, 1U);
#line 278
    vmw_write(vmw_priv___0, 35U, 0U);
#line 279
    vmw_write(vmw_priv___0, 36U, 1U);
#line 280
    vmw_write(vmw_priv___0, 37U, info->var.xoffset);
#line 281
    vmw_write(vmw_priv___0, 38U, info->var.yoffset);
#line 282
    vmw_write(vmw_priv___0, 39U, info->var.xres);
#line 283
    vmw_write(vmw_priv___0, 40U, info->var.yres);
#line 284
    vmw_write(vmw_priv___0, 35U, 4294967295U);
  } else {

  }
#line 290
  tmp = vmw_read(vmw_priv___0, 14U);
#line 290
  __ret_warn_on = tmp != 0U;
#line 290
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 290
  if (tmp___0 != 0L) {
#line 290
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared",
                       290);
  } else {

  }
#line 290
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 292
  return (0);
}
}
#line 295 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_pan_display(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 


  {
#line 298
  return (0);
}
}
#line 301 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_blank(int blank , struct fb_info *info ) 
{ 


  {
#line 303
  return (0);
}
}
#line 310 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_flush(struct vmw_fb_par *par ) 
{ 
  struct vmw_private *vmw_priv___0 ;
  struct fb_info *info ;
  int stride ;
  int *src ;
  __le32 *vram_mem ;
  unsigned long flags ;
  unsigned int x ;
  unsigned int y ;
  unsigned int w ;
  unsigned int h ;
  int i ;
  int k ;
  struct __anonstruct_cmd_292 *cmd ;
  raw_spinlock_t *tmp ;
  unsigned int _min1 ;
  __u32 _min2 ;
  unsigned int _min1___0 ;
  __u32 _min2___0 ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 312
  vmw_priv___0 = par->vmw_priv;
#line 313
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 314
  stride = (int )(info->fix.line_length / 4U);
#line 315
  src = (int *)info->screen_base;
#line 316
  vram_mem = (__le32 *)par->bo_ptr;
#line 325
  if ((int )vmw_priv___0->suspended) {
#line 326
    return;
  } else {

  }
#line 328
  tmp = spinlock_check(& par->dirty.lock);
#line 328
  flags = _raw_spin_lock_irqsave(tmp);
#line 329
  if (! par->dirty.active) {
#line 330
    spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 331
    return;
  } else {

  }
#line 333
  x = par->dirty.x1;
#line 334
  y = par->dirty.y1;
#line 335
  _min1 = par->dirty.x2;
#line 335
  _min2 = info->var.xres;
#line 335
  w = (_min1 < _min2 ? _min1 : _min2) - x;
#line 336
  _min1___0 = par->dirty.y2;
#line 336
  _min2___0 = info->var.yres;
#line 336
  h = (_min1___0 < _min2___0 ? _min1___0 : _min2___0) - y;
#line 337
  tmp___0 = 0U;
#line 337
  par->dirty.x2 = tmp___0;
#line 337
  par->dirty.x1 = tmp___0;
#line 338
  tmp___1 = 0U;
#line 338
  par->dirty.y2 = tmp___1;
#line 338
  par->dirty.y1 = tmp___1;
#line 339
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 341
  i = (int )(y * (unsigned int )stride);
#line 341
  goto ldv_40591;
  ldv_40590: 
#line 342
  k = (int )((unsigned int )i + x);
#line 342
  goto ldv_40588;
  ldv_40587: 
#line 343
  iowrite32((u32 )*(src + (unsigned long )k), (void *)vram_mem + (unsigned long )k);
#line 342
  k = k + 1;
  ldv_40588: ;
#line 342
  if ((unsigned int )k < ((unsigned int )i + x) + w && (__u32 )k < info->fix.smem_len / 4U) {
#line 343
    goto ldv_40587;
  } else {

  }
#line 341
  i = i + stride;
  ldv_40591: ;
#line 341
  if ((__u32 )i < info->fix.smem_len / 4U) {
#line 342
    goto ldv_40590;
  } else {

  }
#line 350
  tmp___2 = vmw_fifo_reserve(vmw_priv___0, 20U);
#line 350
  cmd = (struct __anonstruct_294___0 *)tmp___2;
#line 351
  tmp___3 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_292 *)0),
                             0L);
#line 351
  if (tmp___3 != 0L) {
#line 352
    drm_err("vmw_fb_dirty_flush", "Fifo reserve failed.\n");
#line 353
    return;
  } else {

  }
#line 356
  cmd->header = 1U;
#line 357
  cmd->body.x = x;
#line 358
  cmd->body.y = y;
#line 359
  cmd->body.width = w;
#line 360
  cmd->body.height = h;
#line 361
  vmw_fifo_commit(vmw_priv___0, 20U);
#line 362
  return;
}
}
#line 364 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_mark(struct vmw_fb_par *par , unsigned int x1 , unsigned int y1 ,
                              unsigned int width , unsigned int height ) 
{ 
  struct fb_info *info ;
  unsigned long flags ;
  unsigned int x2 ;
  unsigned int y2 ;
  raw_spinlock_t *tmp ;

  {
#line 368
  info = (struct fb_info *)(par->vmw_priv)->fb_info;
#line 370
  x2 = x1 + width;
#line 371
  y2 = y1 + height;
#line 373
  tmp = spinlock_check(& par->dirty.lock);
#line 373
  flags = _raw_spin_lock_irqsave(tmp);
#line 374
  if (par->dirty.x1 == par->dirty.x2) {
#line 375
    par->dirty.x1 = x1;
#line 376
    par->dirty.y1 = y1;
#line 377
    par->dirty.x2 = x2;
#line 378
    par->dirty.y2 = y2;
#line 381
    if ((int )par->dirty.active) {
#line 382
      schedule_delayed_work(& info->deferred_work, 8UL);
    } else {

    }
  } else {
#line 384
    if (par->dirty.x1 > x1) {
#line 385
      par->dirty.x1 = x1;
    } else {

    }
#line 386
    if (par->dirty.y1 > y1) {
#line 387
      par->dirty.y1 = y1;
    } else {

    }
#line 388
    if (par->dirty.x2 < x2) {
#line 389
      par->dirty.x2 = x2;
    } else {

    }
#line 390
    if (par->dirty.y2 < y2) {
#line 391
      par->dirty.y2 = y2;
    } else {

    }
  }
#line 393
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 394
  return;
}
}
#line 396 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_deferred_io(struct fb_info *info , struct list_head *pagelist ) 
{ 
  struct vmw_fb_par *par ;
  unsigned long start ;
  unsigned long end ;
  unsigned long min ;
  unsigned long max ;
  unsigned long flags ;
  struct page *page ;
  int y1 ;
  int y2 ;
  struct list_head  const  *__mptr ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp ;

  {
#line 399
  par = (struct vmw_fb_par *)info->par;
#line 405
  min = 0xffffffffffffffffUL;
#line 406
  max = 0UL;
#line 407
  __mptr = (struct list_head  const  *)pagelist->next;
#line 407
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 407
  goto ldv_40632;
  ldv_40631: 
#line 408
  start = page->ldv_21163.ldv_21147.index << 12;
#line 409
  end = start + 4095UL;
#line 410
  _min1 = min;
#line 410
  _min2 = start;
#line 410
  min = _min1 < _min2 ? _min1 : _min2;
#line 411
  _max1 = max;
#line 411
  _max2 = end;
#line 411
  max = _max1 > _max2 ? _max1 : _max2;
#line 407
  __mptr___0 = (struct list_head  const  *)page->ldv_21174.lru.next;
#line 407
  page = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
  ldv_40632: ;
#line 407
  if ((unsigned long )(& page->ldv_21174.lru) != (unsigned long )pagelist) {
#line 408
    goto ldv_40631;
  } else {

  }

#line 414
  if (min < max) {
#line 415
    y1 = (int )(min / (unsigned long )info->fix.line_length);
#line 416
    y2 = (int )((unsigned int )(max / (unsigned long )info->fix.line_length) + 1U);
#line 418
    tmp = spinlock_check(& par->dirty.lock);
#line 418
    flags = _raw_spin_lock_irqsave(tmp);
#line 419
    par->dirty.x1 = 0U;
#line 420
    par->dirty.y1 = (unsigned int )y1;
#line 421
    par->dirty.x2 = info->var.xres;
#line 422
    par->dirty.y2 = (unsigned int )y2;
#line 423
    spin_unlock_irqrestore(& par->dirty.lock, flags);
  } else {

  }
#line 426
  vmw_fb_dirty_flush(par);
#line 427
  return;
}
}
#line 429 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_deferred_io vmw_defio  =    {8UL, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
    {0, 0}, 0, & vmw_deferred_io};
#line 438 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_fillrect(struct fb_info *info , struct fb_fillrect  const  *rect ) 
{ 


  {
#line 440
  cfb_fillrect(info, rect);
#line 441
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, rect->dx, rect->dy, rect->width,
                    rect->height);
#line 443
  return;
}
}
#line 445 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ 


  {
#line 447
  cfb_copyarea(info, region);
#line 448
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, region->dx, region->dy, region->width,
                    region->height);
#line 450
  return;
}
}
#line 452 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_imageblit(struct fb_info *info , struct fb_image  const  *image ) 
{ 


  {
#line 454
  cfb_imageblit(info, image);
#line 455
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, image->dx, image->dy, image->width,
                    image->height);
#line 457
  return;
}
}
#line 463 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static struct fb_ops vmw_fb_ops  = 
#line 463
     {& __this_module, 0, 0, 0, 0, & vmw_fb_check_var, & vmw_fb_set_par, & vmw_fb_setcolreg,
    0, & vmw_fb_blank, & vmw_fb_pan_display, & vmw_fb_fillrect, & vmw_fb_copyarea,
    & vmw_fb_imageblit, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 475 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_create_bo(struct vmw_private *vmw_priv___0 , size_t size , struct vmw_dma_buffer **out ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct ttm_placement ne_placement ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 479
  ne_placement = vmw_vram_ne_placement;
#line 482
  ne_placement.lpfn = (unsigned int )((size + 4095UL) >> 12);
#line 485
  ret = ttm_write_lock(& vmw_priv___0->fbdev_master.lock, 0);
#line 486
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 486
  if (tmp != 0L) {
#line 487
    return (ret);
  } else {

  }
#line 489
  tmp___0 = kmalloc(440UL, 208U);
#line 489
  vmw_bo = (struct vmw_dma_buffer *)tmp___0;
#line 490
  if ((unsigned long )vmw_bo == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 491
    goto err_unlock;
  } else {

  }
#line 493
  ret = vmw_dmabuf_init(vmw_priv___0, vmw_bo, size, & ne_placement, 0, & vmw_dmabuf_bo_free);
#line 497
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 497
  if (tmp___1 != 0L) {
#line 498
    goto err_unlock;
  } else {

  }
#line 500
  *out = vmw_bo;
#line 502
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 504
  return (0);
  err_unlock: 
#line 507
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 508
  return (ret);
}
}
#line 511 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) 
{ 
  struct device *device ;
  struct vmw_fb_par *par ;
  struct fb_info *info ;
  unsigned int initial_width ;
  unsigned int initial_height ;
  unsigned int fb_width ;
  unsigned int fb_height ;
  unsigned int fb_bpp ;
  unsigned int fb_depth ;
  unsigned int fb_offset ;
  unsigned int fb_pitch ;
  unsigned int fb_size ;
  int ret ;
  uint32_t _min1 ;
  unsigned int _min2 ;
  uint32_t _min1___0 ;
  unsigned int _min2___0 ;
  uint32_t _min1___1 ;
  unsigned int _min2___1 ;
  uint32_t _min1___2 ;
  unsigned int _min2___2 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  struct lock_class_key __key ;
  long tmp___4 ;

  {
#line 513
  device = & ((vmw_priv___0->dev)->pdev)->dev;
#line 521
  fb_bpp = 32U;
#line 522
  fb_depth = 24U;
#line 525
  _min1 = vmw_priv___0->fb_max_width;
#line 525
  _min2 = 2048U;
#line 525
  fb_width = _min1 < _min2 ? _min1 : _min2;
#line 526
  _min1___0 = vmw_priv___0->fb_max_height;
#line 526
  _min2___0 = 2048U;
#line 526
  fb_height = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 528
  _min1___1 = vmw_priv___0->initial_width;
#line 528
  _min2___1 = fb_width;
#line 528
  initial_width = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 529
  _min1___2 = vmw_priv___0->initial_height;
#line 529
  _min2___2 = fb_height;
#line 529
  initial_height = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
#line 531
  fb_pitch = (fb_width * fb_bpp) / 8U;
#line 532
  fb_size = fb_pitch * fb_height;
#line 533
  fb_offset = vmw_read(vmw_priv___0, 14U);
#line 535
  info = framebuffer_alloc(256UL, device);
#line 536
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
#line 537
    return (-12);
  } else {

  }
#line 542
  vmw_priv___0->fb_info = (void *)info;
#line 543
  par = (struct vmw_fb_par *)info->par;
#line 544
  par->vmw_priv = vmw_priv___0;
#line 545
  par->depth = fb_depth;
#line 546
  par->bpp = fb_bpp;
#line 547
  par->vmalloc = 0;
#line 548
  par->max_width = fb_width;
#line 549
  par->max_height = fb_height;
#line 554
  par->vmalloc = vmalloc((unsigned long )fb_size);
#line 555
  tmp = ldv__builtin_expect((unsigned long )par->vmalloc == (unsigned long )((void *)0),
                         0L);
#line 555
  if (tmp != 0L) {
#line 556
    ret = -12;
#line 557
    goto err_free;
  } else {

  }
#line 560
  ret = vmw_fb_create_bo(vmw_priv___0, (size_t )fb_size, & par->vmw_bo);
#line 561
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 561
  if (tmp___0 != 0L) {
#line 562
    goto err_free;
  } else {

  }
#line 564
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 568
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 568
  if (tmp___1 != 0L) {
#line 569
    goto err_unref;
  } else {

  }
#line 570
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & par->bo_iowrite);
#line 571
  par->bo_size = fb_size;
#line 576
  strcpy((char *)(& info->fix.id), "svgadrmfb");
#line 577
  info->fix.type = 0U;
#line 578
  info->fix.visual = 2U;
#line 579
  info->fix.type_aux = 0U;
#line 580
  info->fix.xpanstep = 1U;
#line 581
  info->fix.ypanstep = 1U;
#line 582
  info->fix.ywrapstep = 0U;
#line 583
  info->fix.accel = 0U;
#line 584
  info->fix.line_length = fb_pitch;
#line 586
  info->fix.smem_start = 0UL;
#line 587
  info->fix.smem_len = fb_size;
#line 589
  info->pseudo_palette = (void *)(& par->pseudo_palette);
#line 590
  info->screen_base = (char *)par->vmalloc;
#line 591
  info->screen_size = (unsigned long )fb_size;
#line 593
  info->flags = 1;
#line 594
  info->fbops = & vmw_fb_ops;
#line 597
  info->var.red.offset = 16U;
#line 598
  info->var.green.offset = 8U;
#line 599
  info->var.blue.offset = 0U;
#line 600
  info->var.red.length = 8U;
#line 601
  info->var.green.length = 8U;
#line 602
  info->var.blue.length = 8U;
#line 603
  info->var.transp.offset = 0U;
#line 604
  info->var.transp.length = 0U;
#line 606
  info->var.xres_virtual = fb_width;
#line 607
  info->var.yres_virtual = fb_height;
#line 608
  info->var.bits_per_pixel = par->bpp;
#line 609
  info->var.xoffset = 0U;
#line 610
  info->var.yoffset = 0U;
#line 611
  info->var.activate = 0U;
#line 612
  info->var.height = 4294967295U;
#line 613
  info->var.width = 4294967295U;
#line 615
  info->var.xres = initial_width;
#line 616
  info->var.yres = initial_height;
#line 620
  info->apertures = alloc_apertures(1U);
#line 621
  if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
#line 622
    ret = -12;
#line 623
    goto err_aper;
  } else {

  }
#line 625
  (info->apertures)->ranges[0].base = (resource_size_t )vmw_priv___0->vram_start;
#line 626
  (info->apertures)->ranges[0].size = (resource_size_t )vmw_priv___0->vram_size;
#line 631
  tmp___2 = 0U;
#line 631
  par->dirty.x2 = tmp___2;
#line 631
  par->dirty.x1 = tmp___2;
#line 632
  tmp___3 = 0U;
#line 632
  par->dirty.y2 = tmp___3;
#line 632
  par->dirty.y1 = tmp___3;
#line 633
  par->dirty.active = 1;
#line 634
  spinlock_check(& par->dirty.lock);
#line 634
  __raw_spin_lock_init(& par->dirty.lock.ldv_5961.rlock, "&(&par->dirty.lock)->rlock",
                       & __key);
#line 635
  info->fbdefio = & vmw_defio;
#line 636
  fb_deferred_io_init(info);
#line 638
  ret = register_framebuffer(info);
#line 639
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 639
  if (tmp___4 != 0L) {
#line 640
    goto err_defio;
  } else {

  }
#line 642
  return (0);
  err_defio: 
#line 645
  fb_deferred_io_cleanup(info);
  err_aper: 
#line 647
  ttm_bo_kunmap(& par->map);
  err_unref: 
#line 649
  ttm_bo_unref((struct ttm_buffer_object **)(& par->vmw_bo));
  err_free: 
#line 651
  vfree((void const   *)par->vmalloc);
#line 652
  framebuffer_release(info);
#line 653
  vmw_priv___0->fb_info = 0;
#line 655
  return (ret);
}
}
#line 658 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  struct ttm_buffer_object *bo ;

  {
#line 664
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 665
    return (0);
  } else {

  }
#line 667
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 668
  par = (struct vmw_fb_par *)info->par;
#line 669
  bo = & (par->vmw_bo)->base;
#line 670
  par->vmw_bo = 0;
#line 673
  fb_deferred_io_cleanup(info);
#line 674
  unregister_framebuffer(info);
#line 676
  ttm_bo_kunmap(& par->map);
#line 677
  ttm_bo_unref(& bo);
#line 679
  vfree((void const   *)par->vmalloc);
#line 680
  framebuffer_release(info);
#line 682
  return (0);
}
}
#line 685 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 691
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 692
    return (-22);
  } else {

  }
#line 694
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 695
  par = (struct vmw_fb_par *)info->par;
#line 697
  tmp = spinlock_check(& par->dirty.lock);
#line 697
  flags = _raw_spin_lock_irqsave(tmp);
#line 698
  par->dirty.active = 0;
#line 699
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 701
  flush_delayed_work(& info->deferred_work);
#line 703
  par->bo_ptr = 0;
#line 704
  ttm_bo_kunmap(& par->map);
#line 706
  vmw_dmabuf_unpin(vmw_priv___0, par->vmw_bo, 0);
#line 708
  return (0);
}
}
#line 711 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 719
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 720
    return (-22);
  } else {

  }
#line 722
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 723
  par = (struct vmw_fb_par *)info->par;
#line 726
  if ((unsigned long )par->bo_ptr != (unsigned long )((void *)0)) {
#line 727
    return (0);
  } else {

  }
#line 730
  vmw_overlay_stop_all(vmw_priv___0);
#line 732
  ret = vmw_dmabuf_to_start_of_vram(vmw_priv___0, par->vmw_bo, 1, 0);
#line 733
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 733
  if (tmp != 0L) {
#line 734
    drm_err("vmw_fb_on", "could not move buffer to start of VRAM\n");
#line 735
    goto err_no_buffer;
  } else {

  }
#line 738
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 742
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 742
  if (tmp___0 != 0L) {
#line 742
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"),
                         "i" (742), "i" (12UL));
    ldv_40718: ;
#line 742
    goto ldv_40718;
  } else {

  }
#line 743
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & dummy);
#line 745
  tmp___1 = spinlock_check(& par->dirty.lock);
#line 745
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 746
  par->dirty.active = 1;
#line 747
  spin_unlock_irqrestore(& par->dirty.lock, flags);
  err_no_buffer: 
#line 750
  vmw_fb_set_par(info);
#line 752
  vmw_fb_dirty_mark(par, 0U, 0U, info->var.xres, info->var.yres);
#line 756
  schedule_delayed_work(& info->deferred_work, 0UL);
#line 758
  return (0);
}
}
#line 798 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_main4_sequence_infinite_withcheck_stateful(void) 
{ 
  struct fb_info *var_group1 ;
  struct list_head *var_group2 ;
  struct fb_var_screeninfo *var_group3 ;
  unsigned int var_vmw_fb_setcolreg_0_p0 ;
  unsigned int var_vmw_fb_setcolreg_0_p1 ;
  unsigned int var_vmw_fb_setcolreg_0_p2 ;
  unsigned int var_vmw_fb_setcolreg_0_p3 ;
  unsigned int var_vmw_fb_setcolreg_0_p4 ;
  struct fb_info *var_vmw_fb_setcolreg_0_p5 ;
  struct fb_fillrect  const  *var_vmw_fb_fillrect_8_p1 ;
  struct fb_copyarea  const  *var_vmw_fb_copyarea_9_p1 ;
  struct fb_image  const  *var_vmw_fb_imageblit_10_p1 ;
  int var_vmw_fb_blank_4_p0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 904
  LDV_IN_INTERRUPT = 1;
#line 913
  ldv_initialize();
#line 919
  goto ldv_40763;
  ldv_40762: 
#line 922
  tmp = __VERIFIER_nondet_int();
#line 922
  switch (tmp) {
  case 0: 
#line 936
  ldv_handler_precall();
#line 937
  vmw_deferred_io(var_group1, var_group2);
#line 944
  goto ldv_40752;
  case 1: 
#line 955
  ldv_handler_precall();
#line 956
  vmw_fb_check_var(var_group3, var_group1);
#line 967
  goto ldv_40752;
  case 2: 
#line 978
  ldv_handler_precall();
#line 979
  vmw_fb_set_par(var_group1);
#line 990
  goto ldv_40752;
  case 3: 
#line 1001
  ldv_handler_precall();
#line 1002
  vmw_fb_setcolreg(var_vmw_fb_setcolreg_0_p0, var_vmw_fb_setcolreg_0_p1, var_vmw_fb_setcolreg_0_p2,
                   var_vmw_fb_setcolreg_0_p3, var_vmw_fb_setcolreg_0_p4, var_vmw_fb_setcolreg_0_p5);
#line 1013
  goto ldv_40752;
  case 4: 
#line 1026
  ldv_handler_precall();
#line 1027
  vmw_fb_fillrect(var_group1, var_vmw_fb_fillrect_8_p1);
#line 1034
  goto ldv_40752;
  case 5: 
#line 1047
  ldv_handler_precall();
#line 1048
  vmw_fb_copyarea(var_group1, var_vmw_fb_copyarea_9_p1);
#line 1055
  goto ldv_40752;
  case 6: 
#line 1068
  ldv_handler_precall();
#line 1069
  vmw_fb_imageblit(var_group1, var_vmw_fb_imageblit_10_p1);
#line 1076
  goto ldv_40752;
  case 7: 
#line 1087
  ldv_handler_precall();
#line 1088
  vmw_fb_pan_display(var_group3, var_group1);
#line 1099
  goto ldv_40752;
  case 8: 
#line 1110
  ldv_handler_precall();
#line 1111
  vmw_fb_blank(var_vmw_fb_blank_4_p0, var_group1);
#line 1122
  goto ldv_40752;
  default: ;
#line 1123
  goto ldv_40752;
  }
  ldv_40752: ;
  ldv_40763: 
#line 919
  tmp___0 = __VERIFIER_nondet_int();
#line 919
  if (tmp___0 != 0) {
#line 920
    goto ldv_40762;
  } else {

  }


#line 1132
  ldv_check_final_state();
#line 1135
  return;
}
}
#line 1139 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1144
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1146
  mutex_lock(ldv_func_arg1);
#line 1147
  return;
}
}
#line 1149 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1154
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1156
  mutex_unlock(ldv_func_arg1);
#line 1157
  return;
}
}
#line 1159 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1164
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1166
  mutex_lock(ldv_func_arg1);
#line 1167
  return;
}
}
#line 1169 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1174
  tmp = mutex_trylock(ldv_func_arg1);
#line 1174
  ldv_func_res = tmp;
#line 1176
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1176
  return (tmp___0);
#line 1178
  return (ldv_func_res);
}
}
#line 1181 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1186
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1188
  mutex_unlock(ldv_func_arg1);
#line 1189
  return;
}
}
#line 1191 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1196
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1198
  mutex_lock(ldv_func_arg1);
#line 1199
  return;
}
}
#line 1201 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1206
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1208
  mutex_unlock(ldv_func_arg1);
#line 1209
  return;
}
}
#line 1211 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1216
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1218
  mutex_lock(ldv_func_arg1);
#line 1219
  return;
}
}
#line 1221 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1226
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1228
  mutex_unlock(ldv_func_arg1);
#line 1229
  return;
}
}
#line 1231 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1236
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1238
  mutex_unlock(ldv_func_arg1);
#line 1239
  return;
}
}
#line 1241 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1246
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1248
  mutex_lock(ldv_func_arg1);
#line 1249
  return;
}
}
#line 1251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1256
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1258
  mutex_unlock(ldv_func_arg1);
#line 1259
  return;
}
}
#line 1261 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1266
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1268
  mutex_lock(ldv_func_arg1);
#line 1269
  return;
}
}
#line 1271 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1276
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1278
  mutex_unlock(ldv_func_arg1);
#line 1279
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_226(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_224(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_232(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) ;
#line 8 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_237(struct mutex *ldv_func_arg1 ) ;
#line 12
int ldv_mutex_lock_interruptible_239(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_225(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) ;
#line 96
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) ;
#line 209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 211
  __len = count;
#line 211
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 213
  return;
}
}
#line 1295 "include/drm/drmP.h"
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1304
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
#line 544 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) ;
#line 545
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) ;
#line 717
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) ;
#line 718
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) ;
#line 135 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_getparam_arg *param ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  __le32 *fifo_mem ;
  struct vmw_fifo_state  const  *fifo ;
  unsigned int tmp___3 ;

  {
#line 138
  tmp = vmw_priv(dev);
#line 138
  dev_priv = tmp;
#line 139
  param = (struct drm_vmw_getparam_arg *)data;
#line 142
  switch (param->param) {
  case 0U: 
#line 144
  tmp___0 = vmw_overlay_num_overlays(dev_priv);
#line 144
  param->value = (uint64_t )tmp___0;
#line 145
  goto ldv_40749;
  case 1U: 
#line 147
  tmp___1 = vmw_overlay_num_free_overlays(dev_priv);
#line 147
  param->value = (uint64_t )tmp___1;
#line 148
  goto ldv_40749;
  case 2U: 
#line 150
  tmp___2 = vmw_fifo_have_3d(dev_priv);
#line 150
  param->value = (uint64_t )tmp___2;
#line 151
  goto ldv_40749;
  case 3U: 
#line 153
  param->value = (uint64_t )dev_priv->capabilities;
#line 154
  goto ldv_40749;
  case 4U: 
#line 156
  param->value = (uint64_t )dev_priv->fifo.capabilities;
#line 157
  goto ldv_40749;
  case 5U: 
#line 159
  param->value = (uint64_t )dev_priv->vram_size;
#line 160
  goto ldv_40749;
  case 6U: 
#line 163
  fifo_mem = dev_priv->mmio_virt;
#line 164
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 166
  tmp___3 = ioread32((void *)(fifo_mem + (((unsigned int )fifo->capabilities & 256U) != 0U ? 17UL : 7UL)));
#line 166
  param->value = (uint64_t )tmp___3;
#line 172
  goto ldv_40749;
  default: 
#line 175
  drm_err("vmw_getparam_ioctl", "Illegal vmwgfx get param request: %d\n", param->param);
#line 177
  return (-22);
  }
  ldv_40749: ;
#line 180
  return (0);
}
}
#line 184 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_get_3d_cap_arg *arg ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t size ;
  __le32 *fifo_mem ;
  void *buffer ;
  void *bounce ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 187
  arg = (struct drm_vmw_get_3d_cap_arg *)data;
#line 189
  tmp = vmw_priv(dev);
#line 189
  dev_priv = tmp;
#line 192
  buffer = (void *)arg->buffer;
#line 196
  tmp___0 = ldv__builtin_expect(arg->pad64 != 0U, 0L);
#line 196
  if (tmp___0 != 0L) {
#line 197
    drm_err("vmw_get_cap_3d_ioctl", "Illegal GET_3D_CAP argument.\n");
#line 198
    return (-22);
  } else {

  }
#line 201
  size = 1024U;
#line 203
  if (arg->max_size < size) {
#line 204
    size = arg->max_size;
  } else {

  }
#line 206
  bounce = vmalloc((unsigned long )size);
#line 207
  tmp___1 = ldv__builtin_expect((unsigned long )bounce == (unsigned long )((void *)0),
                             0L);
#line 207
  if (tmp___1 != 0L) {
#line 208
    drm_err("vmw_get_cap_3d_ioctl", "Failed to allocate bounce buffer for 3D caps.\n");
#line 209
    return (-12);
  } else {

  }
#line 212
  fifo_mem = dev_priv->mmio_virt;
#line 213
  memcpy_fromio(bounce, (void const volatile   *)fifo_mem + 32U, (size_t )size);
#line 215
  ret = copy_to_user(buffer, (void const   *)bounce, size);
#line 216
  if (ret != 0) {
#line 217
    ret = -14;
  } else {

  }
#line 218
  vfree((void const   *)bounce);
#line 220
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 220
  if (tmp___2 != 0L) {
#line 221
    drm_err("vmw_get_cap_3d_ioctl", "Failed to report 3D caps info.\n");
  } else {

  }
#line 223
  return (ret);
}
}
#line 226 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct drm_vmw_present_arg *arg ;
  struct vmw_surface *surface ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  struct vmw_resource *res ;
  uint32_t num_clips ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___6 ;

  {
#line 229
  tmp = vmw_fpriv(file_priv);
#line 229
  tfile = tmp->tfile;
#line 230
  tmp___0 = vmw_priv(dev);
#line 230
  dev_priv = tmp___0;
#line 231
  arg = (struct drm_vmw_present_arg *)data;
#line 234
  tmp___1 = vmw_master(file_priv->master);
#line 234
  vmaster = tmp___1;
#line 236
  clips = 0;
#line 243
  num_clips = arg->num_clips;
#line 244
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 246
  tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 246
  if (tmp___2 != 0L) {
#line 247
    return (0);
  } else {

  }
#line 249
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 250
    drm_err("vmw_present_ioctl", "Variable clips_ptr must be specified.\n");
#line 251
    ret = -22;
#line 252
    goto out_clips;
  } else {

  }
#line 255
  tmp___3 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 255
  clips = (struct drm_vmw_rect *)tmp___3;
#line 256
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 257
    drm_err("vmw_present_ioctl", "Failed to allocate clip rect list.\n");
#line 258
    ret = -12;
#line 259
    goto out_clips;
  } else {

  }
#line 262
  tmp___4 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 262
  ret = (int )tmp___4;
#line 263
  if (ret != 0) {
#line 264
    drm_err("vmw_present_ioctl", "Failed to copy clip rects from userspace.\n");
#line 265
    ret = -14;
#line 266
    goto out_no_copy;
  } else {

  }
#line 269
  ret = ldv_mutex_lock_interruptible_237(& dev->mode_config.mutex);
#line 270
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 270
  if (tmp___5 != 0L) {
#line 271
    ret = -512;
#line 272
    goto out_no_mode_mutex;
  } else {

  }
#line 275
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 276
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 277
    drm_err("vmw_present_ioctl", "Invalid framebuffer id.\n");
#line 278
    ret = -22;
#line 279
    goto out_no_fb;
  } else {

  }
#line 281
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 281
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe0UL);
#line 281
  vfb = (struct vmw_framebuffer *)__mptr;
#line 283
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 284
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 284
  if (tmp___6 != 0L) {
#line 285
    goto out_no_ttm_lock;
  } else {

  }
#line 287
  ret = vmw_user_resource_lookup_handle(dev_priv, tfile, arg->sid, user_surface_converter,
                                        & res);
#line 290
  if (ret != 0) {
#line 291
    goto out_no_surface;
  } else {

  }
#line 293
  surface = vmw_res_to_srf(res);
#line 294
  ret = vmw_kms_present(dev_priv, file_priv, vfb, surface, arg->sid, arg->dest_x,
                        arg->dest_y, clips, num_clips);
#line 300
  vmw_surface_unreference(& surface);
  out_no_surface: 
#line 303
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 306
  ldv_mutex_unlock_238(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 309
  kfree((void const   *)clips);
  out_clips: ;
#line 311
  return (ret);
}
}
#line 314 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_present_readback_arg *arg ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  long tmp___4 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___5 ;

  {
#line 317
  tmp = vmw_priv(dev);
#line 317
  dev_priv = tmp;
#line 318
  arg = (struct drm_vmw_present_readback_arg *)data;
#line 320
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 323
  tmp___0 = vmw_master(file_priv->master);
#line 323
  vmaster = tmp___0;
#line 325
  clips = 0;
#line 331
  num_clips = arg->num_clips;
#line 332
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 334
  tmp___1 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 334
  if (tmp___1 != 0L) {
#line 335
    return (0);
  } else {

  }
#line 337
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 338
    drm_err("vmw_present_readback_ioctl", "Argument clips_ptr must be specified.\n");
#line 339
    ret = -22;
#line 340
    goto out_clips;
  } else {

  }
#line 343
  tmp___2 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 343
  clips = (struct drm_vmw_rect *)tmp___2;
#line 344
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 345
    drm_err("vmw_present_readback_ioctl", "Failed to allocate clip rect list.\n");
#line 346
    ret = -12;
#line 347
    goto out_clips;
  } else {

  }
#line 350
  tmp___3 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 350
  ret = (int )tmp___3;
#line 351
  if (ret != 0) {
#line 352
    drm_err("vmw_present_readback_ioctl", "Failed to copy clip rects from userspace.\n");
#line 353
    ret = -14;
#line 354
    goto out_no_copy;
  } else {

  }
#line 357
  ret = ldv_mutex_lock_interruptible_239(& dev->mode_config.mutex);
#line 358
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 358
  if (tmp___4 != 0L) {
#line 359
    ret = -512;
#line 360
    goto out_no_mode_mutex;
  } else {

  }
#line 363
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 364
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 365
    drm_err("vmw_present_readback_ioctl", "Invalid framebuffer id.\n");
#line 366
    ret = -22;
#line 367
    goto out_no_fb;
  } else {

  }
#line 370
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 370
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe0UL);
#line 370
  vfb = (struct vmw_framebuffer *)__mptr;
#line 371
  if (! vfb->dmabuf) {
#line 372
    drm_err("vmw_present_readback_ioctl", "Framebuffer not dmabuf backed.\n");
#line 373
    ret = -22;
#line 374
    goto out_no_fb;
  } else {

  }
#line 377
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 378
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 378
  if (tmp___5 != 0L) {
#line 379
    goto out_no_ttm_lock;
  } else {

  }
#line 381
  ret = vmw_kms_readback(dev_priv, file_priv, vfb, user_fence_rep, clips, num_clips);
#line 385
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 388
  ldv_mutex_unlock_240(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 391
  kfree((void const   *)clips);
  out_clips: ;
#line 393
  return (ret);
}
}
#line 406 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  unsigned int tmp___0 ;

  {
#line 408
  file_priv = (struct drm_file *)filp->private_data;
#line 409
  tmp = vmw_priv((file_priv->minor)->dev);
#line 409
  dev_priv = tmp;
#line 412
  vmw_fifo_ping_host(dev_priv, 1U);
#line 413
  tmp___0 = drm_poll(filp, wait);
#line 413
  return (tmp___0);
}
}
#line 428 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  ssize_t tmp___0 ;

  {
#line 431
  file_priv = (struct drm_file *)filp->private_data;
#line 432
  tmp = vmw_priv((file_priv->minor)->dev);
#line 432
  dev_priv = tmp;
#line 435
  vmw_fifo_ping_host(dev_priv, 1U);
#line 436
  tmp___0 = drm_read(filp, buffer, count, offset);
#line 436
  return (tmp___0);
}
}
#line 439 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 444
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 446
  mutex_lock(ldv_func_arg1);
#line 447
  return;
}
}
#line 449 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_224(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 454
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 456
  mutex_unlock(ldv_func_arg1);
#line 457
  return;
}
}
#line 459 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_225(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_trylock_226(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 474
  tmp = mutex_trylock(ldv_func_arg1);
#line 474
  ldv_func_res = tmp;
#line 476
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 476
  return (tmp___0);
#line 478
  return (ldv_func_res);
}
}
#line 481 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 486
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 488
  mutex_unlock(ldv_func_arg1);
#line 489
  return;
}
}
#line 491 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 498
  mutex_lock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 506
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 508
  mutex_unlock(ldv_func_arg1);
#line 509
  return;
}
}
#line 511 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 516
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 518
  mutex_lock(ldv_func_arg1);
#line 519
  return;
}
}
#line 521 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_232(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 536
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 538
  mutex_unlock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 546
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 548
  mutex_lock(ldv_func_arg1);
#line 549
  return;
}
}
#line 551 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 556
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 558
  mutex_unlock(ldv_func_arg1);
#line 559
  return;
}
}
#line 561 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 578
  mutex_unlock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_237(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 586
  ldv_func_res = tmp;
#line 588
  tmp___0 = ldv_mutex_lock_interruptible_mutex(ldv_func_arg1);
#line 588
  return (tmp___0);
#line 590
  return (ldv_func_res);
}
}
#line 593 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 598
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 600
  mutex_unlock(ldv_func_arg1);
#line 601
  return;
}
}
#line 603 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_239(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 608
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 608
  ldv_func_res = tmp;
#line 610
  tmp___0 = ldv_mutex_lock_interruptible_mutex(ldv_func_arg1);
#line 610
  return (tmp___0);
#line 612
  return (ldv_func_res);
}
}
#line 615 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 620
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 622
  mutex_unlock(ldv_func_arg1);
#line 623
  return;
}
}
#line 77 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2,%0; sete %1": "+m" (v->counter),
                       "=qm" (c): "ir" (i): "memory");
#line 84
  return ((int )c);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) ;
#line 18 "include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t * ) ;
#line 19
extern void _raw_write_lock(rwlock_t * ) ;
#line 30
extern void _raw_read_unlock(rwlock_t * ) ;
#line 31
extern void _raw_write_unlock(rwlock_t * ) ;
#line 52 "include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 31 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 33
  atomic_set(& kref->refcount, 1);
#line 34
  return;
}
}
#line 64 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 67
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 67
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 67
  if (tmp != 0L) {
#line 67
    warn_slowpath_null("include/linux/kref.h", 67);
  } else {

  }
#line 67
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 69
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 69
  if (tmp___0 != 0) {
#line 70
    (*release)(kref);
#line 71
    return (1);
  } else {

  }
#line 73
  return (0);
}
}
#line 93 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 95
  tmp = kref_sub(kref, 1U, release);
#line 95
  return (tmp);
}
}
#line 104 "include/linux/idr.h"
extern void *idr_find(struct idr * , int  ) ;
#line 105
extern int idr_pre_get(struct idr * , gfp_t  ) ;
#line 107
extern int idr_get_new_above(struct idr * , void * , int  , int * ) ;
#line 112
extern void idr_remove(struct idr * , int  ) ;
#line 454 "include/drm/ttm/ttm_bo_api.h"
extern size_t ttm_bo_acc_size(struct ttm_bo_device * , unsigned long  , unsigned int  ) ;
#line 495
extern int ttm_bo_init(struct ttm_bo_device * , struct ttm_buffer_object * , unsigned long  ,
                       enum ttm_bo_type  , struct ttm_placement * , uint32_t  , bool  ,
                       struct file * , size_t  , struct sg_table * , void (*)(struct ttm_buffer_object * ) ) ;
#line 148 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_alloc(struct ttm_mem_global * , uint64_t  , bool  , bool  ) ;
#line 150
extern void ttm_mem_global_free(struct ttm_mem_global * , uint64_t  ) ;
#line 157
extern size_t ttm_round_pot(size_t  ) ;
#line 149 "include/drm/ttm/ttm_object.h"
extern int ttm_base_object_init(struct ttm_object_file * , struct ttm_base_object * ,
                                bool  , enum ttm_object_type  , void (*)(struct ttm_base_object ** ) ,
                                void (*)(struct ttm_base_object * , enum ttm_ref_type  ) ) ;
#line 204
extern int ttm_ref_object_add(struct ttm_object_file * , struct ttm_base_object * ,
                              enum ttm_ref_type  , bool * ) ;
#line 426 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
bool vmw_resource_needs_backup(struct vmw_resource  const  *res ) ;
#line 464
int vmw_user_dmabuf_verify_access(struct ttm_buffer_object *bo , struct ttm_object_file *tfile ) ;
#line 479
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) ;
#line 486
void vmw_resource_move_notify(struct ttm_buffer_object *bo , struct ttm_mem_reg *mem ) ;
#line 488
void vmw_fence_single_bo(struct ttm_buffer_object *bo , struct vmw_fence_obj *fence ) ;
#line 715
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) ;
#line 716
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) ;
#line 764 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv ) 
{ 


  {
#line 766
  return ((struct ttm_mem_global *)dev_priv->mem_global_ref.object);
}
}
#line 76 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
int vmw_resource_alloc_id(struct vmw_resource *res ) ;
#line 77
void vmw_resource_release_id(struct vmw_resource *res ) ;
#line 78
int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res , bool delay_id ,
                      void (*res_free)(struct vmw_resource * ) , struct vmw_res_func  const  *func ) ;
#line 82
void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) ;
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static uint64_t vmw_user_stream_size  ;
#line 162 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static struct vmw_res_func  const  vmw_stream_func  = 
#line 162
     {2, 0, "video streams", 0, 0, 0, 0, 0, 0};
#line 175 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo ) 
{ 
  struct ttm_buffer_object  const  *__mptr ;

  {
#line 177
  __mptr = (struct ttm_buffer_object  const  *)bo;
#line 177
  return ((struct vmw_dma_buffer *)__mptr);
}
}
#line 181 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;
  struct vmw_dma_buffer  const  *__mptr ;

  {
#line 183
  tmp = vmw_dma_buffer(bo);
#line 183
  vmw_bo = tmp;
#line 184
  __mptr = (struct vmw_dma_buffer  const  *)vmw_bo;
#line 184
  return ((struct vmw_user_dma_buffer *)__mptr + 0xffffffffffffffb0UL);
}
}
#line 187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) 
{ 


  {
#line 189
  kref_get(& res->kref);
#line 190
  return (res);
}
}
#line 201 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_release_id(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct idr *idr ;

  {
#line 203
  dev_priv = res->dev_priv;
#line 204
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 206
  _raw_write_lock(& dev_priv->resource_lock);
#line 207
  if (res->id != -1) {
#line 208
    idr_remove(idr, res->id);
  } else {

  }
#line 209
  res->id = -1;
#line 210
  _raw_write_unlock(& dev_priv->resource_lock);
#line 211
  return;
}
}
#line 213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_release(struct kref *kref ) 
{ 
  struct vmw_resource *res ;
  struct kref  const  *__mptr ;
  struct vmw_private *dev_priv ;
  int id ;
  struct idr *idr ;
  struct ttm_buffer_object *bo ;
  struct ttm_validate_buffer val_buf ;
  int tmp ;
  long tmp___0 ;

  {
#line 216
  __mptr = (struct kref  const  *)kref;
#line 216
  res = (struct vmw_resource *)__mptr;
#line 217
  dev_priv = res->dev_priv;
#line 219
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 221
  res->avail = 0;
#line 222
  list_del_init(& res->lru_head);
#line 223
  _raw_write_unlock(& dev_priv->resource_lock);
#line 224
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 225
    bo = & (res->backup)->base;
#line 227
    ttm_bo_reserve(bo, 0, 0, 0, 0U);
#line 228
    tmp = list_empty((struct list_head  const  *)(& res->mob_head));
#line 228
    if (tmp == 0 && (unsigned long )(res->func)->unbind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                                                 bool  ,
                                                                                                 struct ttm_validate_buffer * ))0)) {
#line 232
      val_buf.bo = bo;
#line 233
      (*((res->func)->unbind))(res, 0, & val_buf);
    } else {

    }
#line 235
    res->backup_dirty = 0;
#line 236
    list_del_init(& res->mob_head);
#line 237
    ttm_bo_unreserve(bo);
#line 238
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 241
  tmp___0 = ldv__builtin_expect((unsigned long )res->hw_destroy != (unsigned long )((void (*)(struct vmw_resource * ))0),
                             1L);
#line 241
  if (tmp___0 != 0L) {
#line 242
    (*(res->hw_destroy))(res);
  } else {

  }
#line 244
  id = res->id;
#line 245
  if ((unsigned long )res->res_free != (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 246
    (*(res->res_free))(res);
  } else {
#line 248
    kfree((void const   *)res);
  }
#line 250
  _raw_write_lock(& dev_priv->resource_lock);
#line 252
  if (id != -1) {
#line 253
    idr_remove(idr, id);
  } else {

  }
#line 254
  return;
}
}
#line 256 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreference(struct vmw_resource **p_res ) 
{ 
  struct vmw_resource *res ;
  struct vmw_private *dev_priv ;

  {
#line 258
  res = *p_res;
#line 259
  dev_priv = res->dev_priv;
#line 261
  *p_res = 0;
#line 262
  _raw_write_lock(& dev_priv->resource_lock);
#line 263
  kref_put(& res->kref, & vmw_resource_release);
#line 264
  _raw_write_unlock(& dev_priv->resource_lock);
#line 265
  return;
}
}
#line 276 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_alloc_id(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  int ret ;
  struct idr *idr ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 278
  dev_priv = res->dev_priv;
#line 280
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 282
  tmp = ldv__builtin_expect(res->id != -1, 0L);
#line 282
  if (tmp != 0L) {
#line 282
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (282), "i" (12UL));
    ldv_40591: ;
#line 282
    goto ldv_40591;
  } else {

  }
  ldv_40592: 
#line 285
  tmp___0 = idr_pre_get(idr, 208U);
#line 285
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 285
  if (tmp___1 != 0L) {
#line 286
    return (-12);
  } else {

  }
#line 288
  _raw_write_lock(& dev_priv->resource_lock);
#line 289
  ret = idr_get_new_above(idr, (void *)res, 1, & res->id);
#line 290
  _raw_write_unlock(& dev_priv->resource_lock);
#line 292
  if (ret == -11) {
#line 293
    goto ldv_40592;
  } else {

  }

#line 294
  return (ret);
}
}
#line 308 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res , bool delay_id ,
                      void (*res_free)(struct vmw_resource * ) , struct vmw_res_func  const  *func ) 
{ 
  int tmp ;

  {
#line 313
  kref_init(& res->kref);
#line 314
  res->hw_destroy = 0;
#line 315
  res->res_free = res_free;
#line 316
  res->avail = 0;
#line 317
  res->dev_priv = dev_priv;
#line 318
  res->func = func;
#line 319
  INIT_LIST_HEAD(& res->lru_head);
#line 320
  INIT_LIST_HEAD(& res->mob_head);
#line 321
  res->id = -1;
#line 322
  res->backup = 0;
#line 323
  res->backup_offset = 0UL;
#line 324
  res->backup_dirty = 0;
#line 325
  res->res_dirty = 0;
#line 326
  if ((int )delay_id) {
#line 327
    return (0);
  } else {
#line 329
    tmp = vmw_resource_alloc_id(res);
#line 329
    return (tmp);
  }
}
}
#line 344 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) 
{ 
  struct vmw_private *dev_priv ;

  {
#line 347
  dev_priv = res->dev_priv;
#line 349
  _raw_write_lock(& dev_priv->resource_lock);
#line 350
  res->avail = 1;
#line 351
  res->hw_destroy = hw_destroy;
#line 352
  _raw_write_unlock(& dev_priv->resource_lock);
#line 353
  return;
}
}
#line 355 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv , struct idr *idr ,
                                         int id ) 
{ 
  struct vmw_resource *res ;
  void *tmp ;
  long tmp___0 ;

  {
#line 360
  _raw_read_lock(& dev_priv->resource_lock);
#line 361
  tmp = idr_find(idr, id);
#line 361
  res = (struct vmw_resource *)tmp;
#line 362
  if ((unsigned long )res != (unsigned long )((struct vmw_resource *)0) && (int )res->avail) {
#line 363
    kref_get(& res->kref);
  } else {
#line 365
    res = 0;
  }
#line 366
  _raw_read_unlock(& dev_priv->resource_lock);
#line 368
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 368
  if (tmp___0 != 0L) {
#line 369
    return (0);
  } else {

  }
#line 371
  return (res);
}
}
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_resource_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                    uint32_t handle , struct vmw_user_resource_conv  const  *converter ,
                                    struct vmw_resource **p_res ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 397
  ret = -22;
#line 399
  base = ttm_base_object_lookup(tfile, handle);
#line 400
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 400
  if (tmp != 0L) {
#line 401
    return (-22);
  } else {

  }
#line 403
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != (unsigned int )converter->object_type,
                             0L);
#line 403
  if (tmp___0 != 0L) {
#line 404
    goto out_bad_resource;
  } else {

  }
#line 406
  res = (*(converter->base_obj_to_res))(base);
#line 408
  _raw_read_lock(& dev_priv->resource_lock);
#line 409
  if (! res->avail || (unsigned long )res->res_free != (unsigned long )((void (*)(struct vmw_resource * ))converter->res_free)) {
#line 410
    _raw_read_unlock(& dev_priv->resource_lock);
#line 411
    goto out_bad_resource;
  } else {

  }
#line 414
  kref_get(& res->kref);
#line 415
  _raw_read_unlock(& dev_priv->resource_lock);
#line 417
  *p_res = res;
#line 418
  ret = 0;
  out_bad_resource: 
#line 421
  ttm_base_object_unref(& base);
#line 423
  return (ret);
}
}
#line 431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) 
{ 
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 440
  tmp = ldv__builtin_expect((unsigned long )*out_surf != (unsigned long )((struct vmw_surface *)0),
                         0L);
#line 440
  if (tmp != 0L) {
#line 440
    goto _L;
  } else {
#line 440
    tmp___0 = ldv__builtin_expect((unsigned long )*out_buf != (unsigned long )((struct vmw_dma_buffer *)0),
                               0L);
#line 440
    if (tmp___0 != 0L) {
      _L: /* CIL Label */ 
#line 440
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (440), "i" (12UL));
      ldv_40634: ;
#line 440
      goto ldv_40634;
    } else {

    }
  }
#line 442
  ret = vmw_user_resource_lookup_handle(dev_priv, tfile, handle, user_surface_converter,
                                        & res);
#line 445
  if (ret == 0) {
#line 446
    *out_surf = vmw_res_to_srf(res);
#line 447
    return (0);
  } else {

  }
#line 450
  *out_surf = 0;
#line 451
  ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);
#line 452
  return (ret);
}
}
#line 458 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;

  {
#line 460
  tmp = vmw_dma_buffer(bo);
#line 460
  vmw_bo = tmp;
#line 462
  kfree((void const   *)vmw_bo);
#line 463
  return;
}
}
#line 465 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) 
{ 
  struct ttm_bo_device *bdev ;
  size_t acc_size ;
  int ret ;
  long tmp ;

  {
#line 471
  bdev = & dev_priv->bdev;
#line 475
  tmp = ldv__builtin_expect((unsigned long )bo_free == (unsigned long )((void (*)(struct ttm_buffer_object * ))0),
                         0L);
#line 475
  if (tmp != 0L) {
#line 475
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (475), "i" (12UL));
    ldv_40651: ;
#line 475
    goto ldv_40651;
  } else {

  }
#line 477
  acc_size = ttm_bo_acc_size(bdev, size, 440U);
#line 478
  memset((void *)vmw_bo, 0, 440UL);
#line 480
  INIT_LIST_HEAD(& vmw_bo->res_list);
#line 482
  ret = ttm_bo_init(bdev, & vmw_bo->base, size, 0, placement, 0U, (int )interruptible,
                    0, acc_size, 0, bo_free);
#line 486
  return (ret);
}
}
#line 489 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct vmw_user_dma_buffer *tmp ;

  {
#line 491
  tmp = vmw_user_dma_buffer(bo);
#line 491
  vmw_user_bo = tmp;
#line 493
  kfree_call_rcu(& vmw_user_bo->base.rhead, 0);
#line 494
  return;
}
}
#line 496 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_release(struct ttm_base_object **p_base ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 499
  base = *p_base;
#line 502
  *p_base = 0;
#line 504
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 504
  if (tmp != 0L) {
#line 505
    return;
  } else {

  }
#line 507
  __mptr = (struct ttm_base_object  const  *)base;
#line 507
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 508
  bo = & vmw_user_bo->dma.base;
#line 509
  ttm_bo_unref(& bo);
#line 510
  return;
}
}
#line 524 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                          uint32_t size , bool shareable , uint32_t *handle , struct vmw_dma_buffer **p_dma_buf ) 
{ 
  struct vmw_user_dma_buffer *user_bo ;
  struct ttm_buffer_object *tmp ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 535
  tmp___0 = kzalloc(520UL, 208U);
#line 535
  user_bo = (struct vmw_user_dma_buffer *)tmp___0;
#line 536
  tmp___1 = ldv__builtin_expect((unsigned long )user_bo == (unsigned long )((struct vmw_user_dma_buffer *)0),
                             0L);
#line 536
  if (tmp___1 != 0L) {
#line 537
    drm_err("vmw_user_dmabuf_alloc", "Failed to allocate a buffer.\n");
#line 538
    return (-12);
  } else {

  }
#line 541
  ret = vmw_dmabuf_init(dev_priv, & user_bo->dma, (size_t )size, & vmw_vram_sys_placement,
                        1, & vmw_user_dmabuf_destroy);
#line 544
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 544
  if (tmp___2 != 0L) {
#line 545
    return (ret);
  } else {

  }
#line 547
  tmp = ttm_bo_reference(& user_bo->dma.base);
#line 548
  ret = ttm_base_object_init(tfile, & user_bo->base, (int )shareable, 1, & vmw_user_dmabuf_release,
                             0);
#line 553
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 553
  if (tmp___3 != 0L) {
#line 554
    ttm_bo_unref(& tmp);
#line 555
    goto out_no_base_object;
  } else {

  }
#line 558
  *p_dma_buf = & user_bo->dma;
#line 559
  *handle = (uint32_t )user_bo->base.hash.key;
  out_no_base_object: ;
#line 562
  return (ret);
}
}
#line 572 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_verify_access(struct ttm_buffer_object *bo , struct ttm_object_file *tfile ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  long tmp ;

  {
#line 577
  tmp = ldv__builtin_expect((unsigned long )bo->destroy != (unsigned long )(& vmw_user_dmabuf_destroy),
                         0L);
#line 577
  if (tmp != 0L) {
#line 578
    return (-1);
  } else {

  }
#line 580
  vmw_user_bo = vmw_user_dma_buffer(bo);
#line 581
  return ((unsigned long )vmw_user_bo->base.tfile == (unsigned long )tfile || (int )vmw_user_bo->base.shareable ? 0 : -1);
}
}
#line 585 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  union drm_vmw_alloc_dmabuf_arg *arg ;
  struct drm_vmw_alloc_dmabuf_req *req ;
  struct drm_vmw_dmabuf_rep *rep ;
  struct vmw_dma_buffer *dma_buf ;
  uint32_t handle ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  int ret ;
  long tmp___1 ;
  struct vmw_fpriv *tmp___2 ;
  long tmp___3 ;

  {
#line 588
  tmp = vmw_priv(dev);
#line 588
  dev_priv = tmp;
#line 589
  arg = (union drm_vmw_alloc_dmabuf_arg *)data;
#line 591
  req = & arg->req;
#line 592
  rep = & arg->rep;
#line 595
  tmp___0 = vmw_master(file_priv->master);
#line 595
  vmaster = tmp___0;
#line 598
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 599
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 599
  if (tmp___1 != 0L) {
#line 600
    return (ret);
  } else {

  }
#line 602
  tmp___2 = vmw_fpriv(file_priv);
#line 602
  ret = vmw_user_dmabuf_alloc(dev_priv, tmp___2->tfile, req->size, 0, & handle, & dma_buf);
#line 604
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 604
  if (tmp___3 != 0L) {
#line 605
    goto out_no_dmabuf;
  } else {

  }
#line 607
  rep->handle = handle;
#line 608
  rep->map_handle = dma_buf->base.addr_space_offset;
#line 609
  rep->cur_gmr_id = handle;
#line 610
  rep->cur_gmr_offset = 0U;
#line 612
  vmw_dmabuf_unreference(& dma_buf);
  out_no_dmabuf: 
#line 615
  ttm_read_unlock(& vmaster->lock);
#line 617
  return (ret);
}
}
#line 620 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_unref_dmabuf_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 623
  arg = (struct drm_vmw_unref_dmabuf_arg *)data;
#line 626
  tmp = vmw_fpriv(file_priv);
#line 626
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, 0);
#line 626
  return (tmp___0);
}
}
#line 631 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  long tmp ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 637
  base = ttm_base_object_lookup(tfile, handle);
#line 638
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 638
  if (tmp != 0L) {
#line 639
    printk("\vInvalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 641
    return (-3);
  } else {

  }
#line 644
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != 1U, 0L);
#line 644
  if (tmp___0 != 0L) {
#line 645
    ttm_base_object_unref(& base);
#line 646
    printk("\vInvalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 648
    return (-22);
  } else {

  }
#line 651
  __mptr = (struct ttm_base_object  const  *)base;
#line 651
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 652
  ttm_bo_reference(& vmw_user_bo->dma.base);
#line 653
  ttm_base_object_unref(& base);
#line 654
  *out = & vmw_user_bo->dma;
#line 656
  return (0);
}
}
#line 659 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_reference(struct ttm_object_file *tfile , struct vmw_dma_buffer *dma_buf ) 
{ 
  struct vmw_user_dma_buffer *user_bo ;
  struct vmw_dma_buffer  const  *__mptr ;
  int tmp ;

  {
#line 664
  if ((unsigned long )dma_buf->base.destroy != (unsigned long )(& vmw_user_dmabuf_destroy)) {
#line 665
    return (-22);
  } else {

  }
#line 667
  __mptr = (struct vmw_dma_buffer  const  *)dma_buf;
#line 667
  user_bo = (struct vmw_user_dma_buffer *)__mptr + 0xffffffffffffffb0UL;
#line 668
  tmp = ttm_ref_object_add(tfile, & user_bo->base, 0, 0);
#line 668
  return (tmp);
}
}
#line 675 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_stream_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_stream *stream ;
  int ret ;
  struct vmw_resource  const  *__mptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 677
  dev_priv = res->dev_priv;
#line 681
  printk("\016[drm] %s: unref\n", "vmw_stream_destroy");
#line 682
  __mptr = (struct vmw_resource  const  *)res;
#line 682
  stream = (struct vmw_stream *)__mptr;
#line 684
  ret = vmw_overlay_unref(dev_priv, stream->stream_id);
#line 685
  __ret_warn_on = ret != 0;
#line 685
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 685
  if (tmp != 0L) {
#line 685
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared",
                       685);
  } else {

  }
#line 685
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 687
  return;
}
}
#line 688 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_stream_init(struct vmw_private *dev_priv , struct vmw_stream *stream ,
                           void (*res_free)(struct vmw_resource * ) ) 
{ 
  struct vmw_resource *res ;
  int ret ;
  long tmp ;

  {
#line 692
  res = & stream->res;
#line 695
  ret = vmw_resource_init(dev_priv, res, 0, res_free, & vmw_stream_func);
#line 698
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 698
  if (tmp != 0L) {
#line 699
    if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 700
      kfree((void const   *)stream);
    } else {
#line 702
      (*res_free)(& stream->res);
    }
#line 703
    return (ret);
  } else {

  }
#line 706
  ret = vmw_overlay_claim(dev_priv, & stream->stream_id);
#line 707
  if (ret != 0) {
#line 708
    vmw_resource_unreference(& res);
#line 709
    return (ret);
  } else {

  }
#line 712
  printk("\016[drm] %s: claimed\n", "vmw_stream_init");
#line 714
  vmw_resource_activate(& stream->res, & vmw_stream_destroy);
#line 715
  return (0);
}
}
#line 718 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_free(struct vmw_resource *res ) 
{ 
  struct vmw_user_stream *stream ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 721
  __mptr = (struct vmw_resource  const  *)res;
#line 721
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 722
  dev_priv = res->dev_priv;
#line 724
  kfree_call_rcu(& stream->base.rhead, 0);
#line 725
  tmp = vmw_mem_glob(dev_priv);
#line 725
  ttm_mem_global_free(tmp, vmw_user_stream_size);
#line 726
  return;
}
}
#line 734 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_stream *stream ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 736
  base = *p_base;
#line 738
  __mptr = (struct ttm_base_object  const  *)base;
#line 738
  stream = (struct vmw_user_stream *)__mptr;
#line 739
  res = & stream->stream.res;
#line 741
  *p_base = 0;
#line 742
  vmw_resource_unreference(& res);
#line 743
  return;
}
}
#line 745 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_resource *res ;
  struct vmw_user_stream *stream ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct idr *idr ;
  int ret ;
  long tmp___1 ;
  struct vmw_resource  const  *__mptr ;

  {
#line 748
  tmp = vmw_priv(dev);
#line 748
  dev_priv = tmp;
#line 751
  arg = (struct drm_vmw_stream_arg *)data;
#line 752
  tmp___0 = vmw_fpriv(file_priv);
#line 752
  tfile = tmp___0->tfile;
#line 753
  idr = (struct idr *)(& dev_priv->res_idr) + 2UL;
#line 754
  ret = 0;
#line 757
  res = vmw_resource_lookup(dev_priv, idr, (int )arg->stream_id);
#line 758
  tmp___1 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 758
  if (tmp___1 != 0L) {
#line 759
    return (-22);
  } else {

  }
#line 761
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 762
    ret = -22;
#line 763
    goto out;
  } else {

  }
#line 766
  __mptr = (struct vmw_resource  const  *)res;
#line 766
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 767
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 768
    ret = -22;
#line 769
    goto out;
  } else {

  }
#line 772
  ttm_ref_object_base_unref(tfile, stream->base.hash.key, 0);
  out: 
#line 774
  vmw_resource_unreference(& res);
#line 775
  return (ret);
}
}
#line 778 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 781
  tmp = vmw_priv(dev);
#line 781
  dev_priv = tmp;
#line 785
  arg = (struct drm_vmw_stream_arg *)data;
#line 786
  tmp___1 = vmw_fpriv(file_priv);
#line 786
  tfile = tmp___1->tfile;
#line 787
  tmp___2 = vmw_master(file_priv->master);
#line 787
  vmaster = tmp___2;
#line 795
  tmp___4 = ldv__builtin_expect(vmw_user_stream_size == 0ULL, 0L);
#line 795
  if (tmp___4 != 0L) {
#line 796
    tmp___3 = ttm_round_pot(200UL);
#line 796
    vmw_user_stream_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 798
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 799
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 799
  if (tmp___5 != 0L) {
#line 800
    return (ret);
  } else {

  }
#line 802
  tmp___6 = vmw_mem_glob(dev_priv);
#line 802
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_stream_size, 0, 1);
#line 805
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 805
  if (tmp___7 != 0L) {
#line 806
    if (ret != -512) {
#line 807
      drm_err("vmw_stream_claim_ioctl", "Out of graphics memory for stream creation.\n");
    } else {

    }
#line 809
    goto out_unlock;
  } else {

  }
#line 813
  tmp___8 = kmalloc(200UL, 208U);
#line 813
  stream = (struct vmw_user_stream *)tmp___8;
#line 814
  tmp___10 = ldv__builtin_expect((unsigned long )stream == (unsigned long )((struct vmw_user_stream *)0),
                              0L);
#line 814
  if (tmp___10 != 0L) {
#line 815
    tmp___9 = vmw_mem_glob(dev_priv);
#line 815
    ttm_mem_global_free(tmp___9, vmw_user_stream_size);
#line 817
    ret = -12;
#line 818
    goto out_unlock;
  } else {

  }
#line 821
  res = & stream->stream.res;
#line 822
  stream->base.shareable = 0;
#line 823
  stream->base.tfile = 0;
#line 829
  ret = vmw_stream_init(dev_priv, & stream->stream, & vmw_user_stream_free);
#line 830
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 830
  if (tmp___11 != 0L) {
#line 831
    goto out_unlock;
  } else {

  }
#line 833
  tmp___0 = vmw_resource_reference(res);
#line 834
  ret = ttm_base_object_init(tfile, & stream->base, 0, 258, & vmw_user_stream_base_release,
                             0);
#line 837
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 837
  if (tmp___12 != 0L) {
#line 838
    vmw_resource_unreference(& tmp___0);
#line 839
    goto out_err;
  } else {

  }
#line 842
  arg->stream_id = (uint32_t )res->id;
  out_err: 
#line 844
  vmw_resource_unreference(& res);
  out_unlock: 
#line 846
  ttm_read_unlock(& vmaster->lock);
#line 847
  return (ret);
}
}
#line 850 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) 
{ 
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  struct vmw_resource  const  *__mptr ;

  {
#line 858
  res = vmw_resource_lookup(dev_priv, (struct idr *)(& dev_priv->res_idr) + 2UL, (int )*inout_id);
#line 860
  tmp = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                         0L);
#line 860
  if (tmp != 0L) {
#line 861
    return (-22);
  } else {

  }
#line 863
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 864
    ret = -22;
#line 865
    goto err_ref;
  } else {

  }
#line 868
  __mptr = (struct vmw_resource  const  *)res;
#line 868
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 869
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 870
    ret = -1;
#line 871
    goto err_ref;
  } else {

  }
#line 874
  *inout_id = stream->stream.stream_id;
#line 875
  *out = res;
#line 876
  return (0);
  err_ref: 
#line 878
  vmw_resource_unreference(& res);
#line 879
  return (ret);
}
}
#line 883 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_create(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_buffer_object *tmp___1 ;
  int ret ;
  void *tmp___2 ;
  struct vmw_fpriv *tmp___3 ;
  long tmp___4 ;

  {
#line 887
  tmp = vmw_priv(dev);
#line 887
  dev_priv = tmp;
#line 888
  tmp___0 = vmw_master(file_priv->master);
#line 888
  vmaster = tmp___0;
#line 893
  args->pitch = args->width * ((args->bpp + 7U) / 8U);
#line 894
  args->size = (uint64_t )(args->pitch * args->height);
#line 896
  tmp___2 = kzalloc(520UL, 208U);
#line 896
  vmw_user_bo = (struct vmw_user_dma_buffer *)tmp___2;
#line 897
  if ((unsigned long )vmw_user_bo == (unsigned long )((struct vmw_user_dma_buffer *)0)) {
#line 898
    return (-12);
  } else {

  }
#line 900
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 901
  if (ret != 0) {
#line 902
    kfree((void const   *)vmw_user_bo);
#line 903
    return (ret);
  } else {

  }
#line 906
  ret = vmw_dmabuf_init(dev_priv, & vmw_user_bo->dma, (size_t )args->size, & vmw_vram_sys_placement,
                        1, & vmw_user_dmabuf_destroy);
#line 909
  if (ret != 0) {
#line 910
    goto out_no_dmabuf;
  } else {

  }
#line 912
  tmp___1 = ttm_bo_reference(& vmw_user_bo->dma.base);
#line 913
  tmp___3 = vmw_fpriv(file_priv);
#line 913
  ret = ttm_base_object_init(tmp___3->tfile, & vmw_user_bo->base, 0, 1, & vmw_user_dmabuf_release,
                             0);
#line 918
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 918
  if (tmp___4 != 0L) {
#line 919
    goto out_no_base_object;
  } else {

  }
#line 921
  args->handle = (uint32_t )vmw_user_bo->base.hash.key;
  out_no_base_object: 
#line 924
  ttm_bo_unref(& tmp___1);
  out_no_dmabuf: 
#line 926
  ttm_read_unlock(& vmaster->lock);
#line 927
  return (ret);
}
}
#line 930 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_map_offset(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                        uint64_t *offset ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_dma_buffer *out_buf ;
  int ret ;

  {
#line 934
  tmp = vmw_fpriv(file_priv);
#line 934
  tfile = tmp->tfile;
#line 938
  ret = vmw_user_dmabuf_lookup(tfile, handle, & out_buf);
#line 939
  if (ret != 0) {
#line 940
    return (-22);
  } else {

  }
#line 942
  *offset = out_buf->base.addr_space_offset;
#line 943
  vmw_dmabuf_unreference(& out_buf);
#line 944
  return (0);
}
}
#line 947 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_destroy(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) 
{ 
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 951
  tmp = vmw_fpriv(file_priv);
#line 951
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )handle, 0);
#line 951
  return (tmp___0);
}
}
#line 962 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_buf_alloc(struct vmw_resource *res , bool interruptible ) 
{ 
  unsigned long size ;
  struct vmw_dma_buffer *backup ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 965
  size = (res->backup_size + 4095UL) & 0xfffffffffffff000UL;
#line 970
  tmp___0 = ldv__builtin_expect((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0),
                             1L);
#line 970
  if (tmp___0 != 0L) {
#line 971
    tmp = ldv__builtin_expect((res->backup)->base.num_pages * 4096UL < size, 0L);
#line 971
    if (tmp != 0L) {
#line 971
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (971), "i" (12UL));
      ldv_40831: ;
#line 971
      goto ldv_40831;
    } else {

    }
#line 972
    return (0);
  } else {

  }
#line 975
  tmp___1 = kzalloc(440UL, 208U);
#line 975
  backup = (struct vmw_dma_buffer *)tmp___1;
#line 976
  tmp___2 = ldv__builtin_expect((unsigned long )backup == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 976
  if (tmp___2 != 0L) {
#line 977
    return (-12);
  } else {

  }
#line 979
  ret = vmw_dmabuf_init(res->dev_priv, backup, res->backup_size, (res->func)->backup_placement,
                        (int )interruptible, & vmw_dmabuf_bo_free);
#line 983
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 983
  if (tmp___3 != 0L) {
#line 984
    goto out_no_dmabuf;
  } else {

  }
#line 986
  res->backup = backup;
  out_no_dmabuf: ;
#line 989
  return (ret);
}
}
#line 1003 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_do_validate(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) 
{ 
  int ret ;
  struct vmw_res_func  const  *func ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1006
  ret = 0;
#line 1007
  func = res->func;
#line 1009
  tmp___0 = ldv__builtin_expect(res->id == -1, 0L);
#line 1009
  if (tmp___0 != 0L) {
#line 1010
    ret = (*(func->create))(res);
#line 1011
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1011
    if (tmp != 0L) {
#line 1012
      return (ret);
    } else {

    }
  } else {

  }
#line 1015
  if ((unsigned long )func->bind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                          struct ttm_validate_buffer * ))0)) {
#line 1015
    if ((int )func->needs_backup) {
#line 1015
      tmp___2 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1015
      if (tmp___2 != 0) {
#line 1015
        if ((unsigned long )val_buf->bo != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1015
          goto _L;
        } else {
#line 1015
          goto _L___1;
        }
      } else {
#line 1015
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1015
    if (! ((_Bool )func->needs_backup) && (unsigned long )val_buf->bo != (unsigned long )((struct ttm_buffer_object *)0)) {
      _L: /* CIL Label */ 
#line 1019
      ret = (*(func->bind))(res, val_buf);
#line 1020
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1020
      if (tmp___1 != 0L) {
#line 1021
        goto out_bind_failed;
      } else {

      }
#line 1022
      if ((int )func->needs_backup) {
#line 1023
        list_add_tail(& res->mob_head, & (res->backup)->res_list);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1032
  res->res_dirty = 1;
#line 1034
  return (0);
  out_bind_failed: 
#line 1037
  (*(func->destroy))(res);
#line 1039
  return (ret);
}
}
#line 1054 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreserve(struct vmw_resource *res , struct vmw_dma_buffer *new_backup ,
                            unsigned long new_backup_offset ) 
{ 
  struct vmw_private *dev_priv ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1058
  dev_priv = res->dev_priv;
#line 1060
  tmp = list_empty((struct list_head  const  *)(& res->lru_head));
#line 1060
  if (tmp == 0) {
#line 1061
    return;
  } else {

  }
#line 1063
  if ((unsigned long )new_backup != (unsigned long )((struct vmw_dma_buffer *)0) && (unsigned long )res->backup != (unsigned long )new_backup) {
#line 1065
    if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1066
      tmp___0 = atomic_read((atomic_t const   *)(& (res->backup)->base.reserved));
#line 1066
      tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 1066
      if (tmp___1 != 0L) {
#line 1066
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                             "i" (1066), "i" (12UL));
        ldv_40846: ;
#line 1066
        goto ldv_40846;
      } else {

      }
#line 1067
      list_del_init(& res->mob_head);
#line 1068
      vmw_dmabuf_unreference(& res->backup);
    } else {

    }
#line 1071
    res->backup = vmw_dmabuf_reference(new_backup);
#line 1072
    tmp___2 = atomic_read((atomic_t const   *)(& new_backup->base.reserved));
#line 1072
    tmp___3 = ldv__builtin_expect(tmp___2 == 0, 0L);
#line 1072
    if (tmp___3 != 0L) {
#line 1072
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (1072), "i" (12UL));
      ldv_40847: ;
#line 1072
      goto ldv_40847;
    } else {

    }
#line 1073
    list_add_tail(& res->mob_head, & new_backup->res_list);
  } else {

  }
#line 1075
  if ((unsigned long )new_backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1076
    res->backup_offset = new_backup_offset;
  } else {

  }
#line 1078
  if (! ((_Bool )(res->func)->may_evict)) {
#line 1079
    return;
  } else {

  }
#line 1081
  _raw_write_lock(& dev_priv->resource_lock);
#line 1082
  list_add_tail(& res->lru_head, (struct list_head *)(& (res->dev_priv)->res_lru) + (unsigned long )(res->func)->res_type);
#line 1084
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1085
  return;
}
}
#line 1098 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_check_buffer(struct vmw_resource *res , bool interruptible , struct ttm_validate_buffer *val_buf ) 
{ 
  struct list_head val_list ;
  bool backup_dirty ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1103
  backup_dirty = 0;
#line 1106
  tmp___0 = ldv__builtin_expect((unsigned long )res->backup == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1106
  if (tmp___0 != 0L) {
#line 1107
    ret = vmw_resource_buf_alloc(res, (int )interruptible);
#line 1108
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1108
    if (tmp != 0L) {
#line 1109
      return (ret);
    } else {

    }
  } else {

  }
#line 1112
  INIT_LIST_HEAD(& val_list);
#line 1113
  val_buf->bo = ttm_bo_reference(& (res->backup)->base);
#line 1114
  list_add_tail(& val_buf->head, & val_list);
#line 1115
  ret = ttm_eu_reserve_buffers(& val_list);
#line 1116
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1116
  if (tmp___1 != 0L) {
#line 1117
    goto out_no_reserve;
  } else {

  }
#line 1119
  if ((int )(res->func)->needs_backup) {
#line 1119
    tmp___2 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1119
    if (tmp___2 != 0) {
#line 1120
      return (0);
    } else {

    }
  } else {

  }
#line 1122
  backup_dirty = res->backup_dirty;
#line 1123
  ret = ttm_bo_validate(& (res->backup)->base, (res->func)->backup_placement, 1, 0);
#line 1127
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1127
  if (tmp___3 != 0L) {
#line 1128
    goto out_no_validate;
  } else {

  }
#line 1130
  return (0);
  out_no_validate: 
#line 1133
  ttm_eu_backoff_reservation(& val_list);
  out_no_reserve: 
#line 1135
  ttm_bo_unref(& val_buf->bo);
#line 1136
  if ((int )backup_dirty) {
#line 1137
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 1139
  return (ret);
}
}
#line 1152 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_reserve(struct vmw_resource *res , bool no_backup ) 
{ 
  struct vmw_private *dev_priv ;
  int ret ;
  long tmp ;

  {
#line 1154
  dev_priv = res->dev_priv;
#line 1157
  _raw_write_lock(& dev_priv->resource_lock);
#line 1158
  list_del_init(& res->lru_head);
#line 1159
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1161
  if (((int )(res->func)->needs_backup && (unsigned long )res->backup == (unsigned long )((struct vmw_dma_buffer *)0)) && ! no_backup) {
#line 1163
    ret = vmw_resource_buf_alloc(res, 1);
#line 1164
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1164
    if (tmp != 0L) {
#line 1165
      return (ret);
    } else {

    }
  } else {

  }
#line 1168
  return (0);
}
}
#line 1177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_backoff_reservation(struct ttm_validate_buffer *val_buf ) 
{ 
  struct list_head val_list ;
  long tmp ;

  {
#line 1181
  tmp = ldv__builtin_expect((unsigned long )val_buf->bo == (unsigned long )((struct ttm_buffer_object *)0),
                         1L);
#line 1181
  if (tmp != 0L) {
#line 1182
    return;
  } else {

  }
#line 1184
  INIT_LIST_HEAD(& val_list);
#line 1185
  list_add_tail(& val_buf->head, & val_list);
#line 1186
  ttm_eu_backoff_reservation(& val_list);
#line 1187
  ttm_bo_unref(& val_buf->bo);
#line 1188
  return;
}
}
#line 1196 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_do_evict(struct vmw_resource *res ) 
{ 
  struct ttm_validate_buffer val_buf ;
  struct vmw_res_func  const  *func ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
#line 1199
  func = res->func;
#line 1202
  tmp = ldv__builtin_expect((long )(! ((_Bool )func->may_evict)), 0L);
#line 1202
  if (tmp != 0L) {
#line 1202
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (1202), "i" (12UL));
    ldv_40874: ;
#line 1202
    goto ldv_40874;
  } else {

  }
#line 1204
  val_buf.bo = 0;
#line 1205
  ret = vmw_resource_check_buffer(res, 1, & val_buf);
#line 1206
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1206
  if (tmp___0 != 0L) {
#line 1207
    return (ret);
  } else {

  }
#line 1209
  tmp___2 = ldv__builtin_expect((unsigned long )func->unbind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                                                   bool  ,
                                                                                                   struct ttm_validate_buffer * ))0),
                             0L);
#line 1209
  if (tmp___2 != 0L) {
#line 1209
    tmp___3 = ldv__builtin_expect((long )(! ((_Bool )func->needs_backup)), 0L);
#line 1209
    if (tmp___3 != 0L) {
#line 1209
      tmp___6 = 1;
    } else {
#line 1209
      tmp___4 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1209
      tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
#line 1209
      if (tmp___5 != 0L) {
#line 1209
        tmp___6 = 1;
      } else {
#line 1209
        tmp___6 = 0;
      }
    }
#line 1209
    if (tmp___6 != 0) {
#line 1211
      ret = (*(func->unbind))(res, (int )res->res_dirty, & val_buf);
#line 1212
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1212
      if (tmp___1 != 0L) {
#line 1213
        goto out_no_unbind;
      } else {

      }
#line 1214
      list_del_init(& res->mob_head);
    } else {

    }
  } else {

  }
#line 1216
  ret = (*(func->destroy))(res);
#line 1217
  res->backup_dirty = 1;
#line 1218
  res->res_dirty = 0;
  out_no_unbind: 
#line 1220
  vmw_resource_backoff_reservation(& val_buf);
#line 1222
  return (ret);
}
}
#line 1237 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_validate(struct vmw_resource *res ) 
{ 
  int ret ;
  struct vmw_resource *evict_res ;
  struct vmw_private *dev_priv ;
  struct list_head *lru_list ;
  struct ttm_validate_buffer val_buf ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  long tmp___2 ;

  {
#line 1241
  dev_priv = res->dev_priv;
#line 1242
  lru_list = (struct list_head *)(& dev_priv->res_lru) + (unsigned long )(res->func)->res_type;
#line 1245
  tmp = ldv__builtin_expect((long )(! ((_Bool )(res->func)->may_evict)), 1L);
#line 1245
  if (tmp != 0L) {
#line 1246
    return (0);
  } else {

  }
#line 1248
  val_buf.bo = 0;
#line 1249
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1250
    val_buf.bo = & (res->backup)->base;
  } else {

  }
  ldv_40888: 
#line 1252
  ret = vmw_resource_do_validate(res, & val_buf);
#line 1253
  tmp___0 = ldv__builtin_expect(ret != -16, 1L);
#line 1253
  if (tmp___0 != 0L) {
#line 1254
    goto ldv_40884;
  } else {

  }
#line 1256
  _raw_write_lock(& dev_priv->resource_lock);
#line 1257
  tmp___1 = list_empty((struct list_head  const  *)lru_list);
#line 1257
  if (tmp___1 != 0 || ! ((_Bool )(res->func)->may_evict)) {
#line 1258
    drm_err("vmw_resource_validate", "Out of device device id entries for %s.\n",
            (res->func)->type_name);
#line 1260
    ret = -16;
#line 1261
    _raw_write_unlock(& dev_priv->resource_lock);
#line 1262
    goto ldv_40884;
  } else {

  }
#line 1266
  __mptr = (struct list_head  const  *)lru_list->next;
#line 1266
  evict_res = vmw_resource_reference((struct vmw_resource *)__mptr + 0xffffffffffffffc0UL);
#line 1268
  list_del_init(& evict_res->lru_head);
#line 1270
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1271
  vmw_resource_do_evict(evict_res);
#line 1272
  vmw_resource_unreference(& evict_res);
#line 1273
  goto ldv_40888;
  ldv_40884: 
#line 1275
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1275
  if (tmp___2 != 0L) {
#line 1276
    goto out_no_validate;
  } else
#line 1277
  if (! ((_Bool )(res->func)->needs_backup) && (unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1278
    list_del_init(& res->mob_head);
#line 1279
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 1282
  return (0);
  out_no_validate: ;
#line 1285
  return (ret);
}
}
#line 1300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_fence_single_bo(struct ttm_buffer_object *bo , struct vmw_fence_obj *fence ) 
{ 
  struct ttm_bo_device *bdev ;
  struct ttm_bo_driver *driver___0 ;
  struct vmw_fence_obj *old_fence_obj ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;

  {
#line 1303
  bdev = bo->bdev;
#line 1304
  driver___0 = bdev->driver;
#line 1307
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 1307
  dev_priv = (struct vmw_private *)__mptr;
#line 1309
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1310
    vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
  } else {
#line 1312
    (*(driver___0->sync_obj_ref))((void *)fence);
  }
#line 1314
  spin_lock(& bdev->fence_lock);
#line 1316
  old_fence_obj = (struct vmw_fence_obj *)bo->sync_obj;
#line 1317
  bo->sync_obj = (void *)fence;
#line 1319
  spin_unlock(& bdev->fence_lock);
#line 1321
  if ((unsigned long )old_fence_obj != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1322
    vmw_fence_obj_unreference(& old_fence_obj);
  } else {

  }
#line 1323
  return;
}
}
#line 1334 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_move_notify(struct ttm_buffer_object *bo , struct ttm_mem_reg *mem ) 
{ 


  {
#line 1336
  return;
}
}
#line 1344 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
bool vmw_resource_needs_backup(struct vmw_resource  const  *res ) 
{ 


  {
#line 1346
  return ((bool )(res->func)->needs_backup);
}
}
#line 1358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_evict_type(struct vmw_private *dev_priv , enum vmw_res_type type ) 
{ 
  struct list_head *lru_list ;
  struct vmw_resource *evict_res ;
  int tmp ;
  struct list_head  const  *__mptr ;

  {
#line 1361
  lru_list = (struct list_head *)(& dev_priv->res_lru) + (unsigned long )type;
  ldv_40916: 
#line 1365
  _raw_write_lock(& dev_priv->resource_lock);
#line 1367
  tmp = list_empty((struct list_head  const  *)lru_list);
#line 1367
  if (tmp != 0) {
#line 1368
    goto out_unlock;
  } else {

  }
#line 1371
  __mptr = (struct list_head  const  *)lru_list->next;
#line 1371
  evict_res = vmw_resource_reference((struct vmw_resource *)__mptr + 0xffffffffffffffc0UL);
#line 1373
  list_del_init(& evict_res->lru_head);
#line 1374
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1375
  vmw_resource_do_evict(evict_res);
#line 1376
  vmw_resource_unreference(& evict_res);
#line 1377
  goto ldv_40916;
  out_unlock: 
#line 1380
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1381
  return;
}
}
#line 1393 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_evict_all(struct vmw_private *dev_priv ) 
{ 
  enum vmw_res_type type ;

  {
#line 1397
  ldv_mutex_lock_273(& dev_priv->cmdbuf_mutex);
#line 1399
  type = 0;
#line 1399
  goto ldv_40922;
  ldv_40921: 
#line 1400
  vmw_resource_evict_type(dev_priv, type);
#line 1399
  type = (enum vmw_res_type )((unsigned int )type + 1U);
  ldv_40922: ;
#line 1399
  if ((unsigned int )type <= 2U) {
#line 1400
    goto ldv_40921;
  } else {

  }
#line 1402
  ldv_mutex_unlock_274(& dev_priv->cmdbuf_mutex);
#line 1403
  return;
}
}
#line 1442 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_main6_sequence_infinite_withcheck_stateful(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1454
  LDV_IN_INTERRUPT = 1;
#line 1463
  ldv_initialize();
#line 1465
  goto ldv_40943;
  ldv_40942: 
#line 1468
  tmp = __VERIFIER_nondet_int();
#line 1468
  switch (tmp) {
  default: ;
#line 1470
  goto ldv_40941;
  }
  ldv_40941: ;
  ldv_40943: 
#line 1465
  tmp___0 = __VERIFIER_nondet_int();
#line 1465
  if (tmp___0 != 0) {
#line 1466
    goto ldv_40942;
  } else {

  }


#line 1479
  ldv_check_final_state();
#line 1482
  return;
}
}
#line 1486 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1491
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1493
  mutex_lock(ldv_func_arg1);
#line 1494
  return;
}
}
#line 1496 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1501
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1503
  mutex_unlock(ldv_func_arg1);
#line 1504
  return;
}
}
#line 1506 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1511
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1513
  mutex_lock(ldv_func_arg1);
#line 1514
  return;
}
}
#line 1516 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1521
  tmp = mutex_trylock(ldv_func_arg1);
#line 1521
  ldv_func_res = tmp;
#line 1523
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1523
  return (tmp___0);
#line 1525
  return (ldv_func_res);
}
}
#line 1528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1533
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1535
  mutex_unlock(ldv_func_arg1);
#line 1536
  return;
}
}
#line 1538 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1543
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1545
  mutex_lock(ldv_func_arg1);
#line 1546
  return;
}
}
#line 1548 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1553
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1555
  mutex_unlock(ldv_func_arg1);
#line 1556
  return;
}
}
#line 1558 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1563
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1565
  mutex_lock(ldv_func_arg1);
#line 1566
  return;
}
}
#line 1568 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1573
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1575
  mutex_unlock(ldv_func_arg1);
#line 1576
  return;
}
}
#line 1578 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1583
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1585
  mutex_unlock(ldv_func_arg1);
#line 1586
  return;
}
}
#line 1588 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1593
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1595
  mutex_lock(ldv_func_arg1);
#line 1596
  return;
}
}
#line 1598 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1603
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1605
  mutex_unlock(ldv_func_arg1);
#line 1606
  return;
}
}
#line 1608 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1613
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1615
  mutex_lock(ldv_func_arg1);
#line 1616
  return;
}
}
#line 1618 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1623
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1625
  mutex_unlock(ldv_func_arg1);
#line 1626
  return;
}
}
#line 1628 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1633
  ldv_mutex_lock_cmdbuf_mutex(ldv_func_arg1);
#line 1635
  mutex_lock(ldv_func_arg1);
#line 1636
  return;
}
}
#line 1638 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1643
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1645
  mutex_unlock(ldv_func_arg1);
#line 1646
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_294(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_295(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_297(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_299(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_291(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_296(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_298(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) ;
#line 599 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_tt_init(struct ttm_tt * , struct ttm_bo_device * , unsigned long  ,
                       uint32_t  , struct page * ) ;
#line 613
extern void ttm_tt_fini(struct ttm_tt * ) ;
#line 983
extern struct ttm_mem_type_manager_func  const  ttm_bo_manager_func ;
#line 73 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) ;
#line 77
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) ;
#line 84
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) ;
#line 566 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct ttm_placement vmw_vram_gmr_ne_placement ;
#line 567
struct ttm_placement vmw_sys_placement ;
#line 568
struct ttm_placement vmw_evictable_placement ;
#line 569
struct ttm_placement vmw_srf_placement ;
#line 724
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func ;
#line 48 "include/drm/ttm/ttm_page_alloc.h"
extern int ttm_pool_populate(struct ttm_tt * ) ;
#line 57
extern void ttm_pool_unpopulate(struct ttm_tt * ) ;
#line 137 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_placement_flags  =    65540U;
#line 140 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_ne_placement_flags  =    2162692U;
#line 144 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t sys_placement_flags  =    65537U;
#line 147 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_placement_flags  =    65544U;
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_ne_placement_flags  =    2162696U;
#line 154 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& vram_placement_flags)};
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_placement_flags[2U]  = {      65540U,      65544U};
#line 168 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_vram_placement_flags[2U]  = {      65544U,      65540U};
#line 173 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_placement_flags), 1U, (uint32_t const   *)(& gmr_placement_flags)};
#line 182 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_ne_placement_flags[2U]  = {      2162692U,      2162696U};
#line 187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_ne_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_ne_placement_flags), 1U, (uint32_t const   *)(& gmr_ne_placement_flags)};
#line 196 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 205 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_ne_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_ne_placement_flags), 1U, (uint32_t const   *)(& vram_ne_placement_flags)};
#line 214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& sys_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 223 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t evictable_placement_flags[3U]  = {      65537U,      65540U,      65544U};
#line 229 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_evictable_placement  =    {0U, 0U, 3U, (uint32_t const   *)(& evictable_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 238 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_srf_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& gmr_placement_flags), 2U, (uint32_t const   *)(& gmr_vram_placement_flags)};
#line 253 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_bind(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;
  int tmp ;

  {
#line 255
  __mptr = (struct ttm_tt  const  *)ttm;
#line 255
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 257
  vmw_be->gmr_id = (int )bo_mem->start;
#line 259
  tmp = vmw_gmr_bind(vmw_be->dev_priv, ttm->pages, ttm->num_pages, vmw_be->gmr_id);
#line 259
  return (tmp);
}
}
#line 263 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_unbind(struct ttm_tt *ttm ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 265
  __mptr = (struct ttm_tt  const  *)ttm;
#line 265
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 267
  vmw_gmr_unbind(vmw_be->dev_priv, vmw_be->gmr_id);
#line 268
  return (0);
}
}
#line 271 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_destroy(struct ttm_tt *ttm ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 273
  __mptr = (struct ttm_tt  const  *)ttm;
#line 273
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 275
  ttm_tt_fini(ttm);
#line 276
  kfree((void const   *)vmw_be);
#line 277
  return;
}
}
#line 279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static struct ttm_backend_func vmw_ttm_func  =    {& vmw_ttm_bind, & vmw_ttm_unbind, & vmw_ttm_destroy};
#line 285 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_tt *vmw_ttm_tt_create(struct ttm_bo_device *bdev , unsigned long size ,
                                 uint32_t page_flags , struct page *dummy_read_page ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  void *tmp ;
  struct ttm_bo_device  const  *__mptr ;
  int tmp___0 ;

  {
#line 291
  tmp = kmalloc(96UL, 208U);
#line 291
  vmw_be = (struct vmw_ttm_tt *)tmp;
#line 292
  if ((unsigned long )vmw_be == (unsigned long )((struct vmw_ttm_tt *)0)) {
#line 293
    return (0);
  } else {

  }
#line 295
  vmw_be->ttm.func = & vmw_ttm_func;
#line 296
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 296
  vmw_be->dev_priv = (struct vmw_private *)__mptr;
#line 298
  tmp___0 = ttm_tt_init(& vmw_be->ttm, bdev, size, page_flags, dummy_read_page);
#line 298
  if (tmp___0 != 0) {
#line 299
    kfree((void const   *)vmw_be);
#line 300
    return (0);
  } else {

  }
#line 303
  return (& vmw_be->ttm);
}
}
#line 306 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_invalidate_caches(struct ttm_bo_device *bdev , uint32_t flags ) 
{ 


  {
#line 308
  return (0);
}
}
#line 311 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_init_mem_type(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) 
{ 


  {
#line 314
  switch (type) {
  case 0U: 
#line 318
  man->flags = 2U;
#line 319
  man->available_caching = 65536U;
#line 320
  man->default_caching = 65536U;
#line 321
  goto ldv_40578;
  case 2U: 
#line 324
  man->func = & ttm_bo_manager_func;
#line 325
  man->gpu_offset = 0UL;
#line 326
  man->flags = 3U;
#line 327
  man->available_caching = 65536U;
#line 328
  man->default_caching = 65536U;
#line 329
  goto ldv_40578;
  case 3U: 
#line 336
  man->func = & vmw_gmrid_manager_func;
#line 337
  man->gpu_offset = 0UL;
#line 338
  man->flags = 10U;
#line 339
  man->available_caching = 65536U;
#line 340
  man->default_caching = 65536U;
#line 341
  goto ldv_40578;
  default: 
#line 343
  drm_err("vmw_init_mem_type", "Unsupported memory type %u\n", type);
#line 344
  return (-22);
  }
  ldv_40578: ;
#line 346
  return (0);
}
}
#line 349 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void vmw_evict_flags(struct ttm_buffer_object *bo , struct ttm_placement *placement ) 
{ 


  {
#line 352
  *placement = vmw_sys_placement;
#line 353
  return;
}
}
#line 355 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_verify_access(struct ttm_buffer_object *bo , struct file *filp ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 357
  tmp = vmw_fpriv((struct drm_file *)filp->private_data);
#line 357
  tfile = tmp->tfile;
#line 360
  tmp___0 = vmw_user_dmabuf_verify_access(bo, tfile);
#line 360
  return (tmp___0);
}
}
#line 363 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_io_mem_reserve(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 
  struct ttm_mem_type_manager *man ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;

  {
#line 365
  man = (struct ttm_mem_type_manager *)(& bdev->man) + (unsigned long )mem->mem_type;
#line 366
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 366
  dev_priv = (struct vmw_private *)__mptr;
#line 368
  mem->bus.addr = 0;
#line 369
  mem->bus.is_iomem = 0;
#line 370
  mem->bus.offset = 0UL;
#line 371
  mem->bus.size = mem->num_pages << 12;
#line 372
  mem->bus.base = 0UL;
#line 373
  if ((man->flags & 2U) == 0U) {
#line 374
    return (-22);
  } else {

  }
#line 375
  switch (mem->mem_type) {
  case 0U: ;
  case 3U: ;
#line 378
  return (0);
  case 2U: 
#line 380
  mem->bus.offset = mem->start << 12;
#line 381
  mem->bus.base = (unsigned long )dev_priv->vram_start;
#line 382
  mem->bus.is_iomem = 1;
#line 383
  goto ldv_40603;
  default: ;
#line 385
  return (-22);
  }
  ldv_40603: ;
#line 387
  return (0);
}
}
#line 390 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_io_mem_free(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 


  {
#line 392
  return;
}
}
#line 394 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_fault_reserve_notify(struct ttm_buffer_object *bo ) 
{ 


  {
#line 396
  return (0);
}
}
#line 404 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void *vmw_sync_obj_ref(void *sync_obj ) 
{ 
  struct vmw_fence_obj *tmp ;

  {
#line 407
  tmp = vmw_fence_obj_reference((struct vmw_fence_obj *)sync_obj);
#line 407
  return ((void *)tmp);
}
}
#line 411 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_sync_obj_unref(void **sync_obj ) 
{ 


  {
#line 413
  vmw_fence_obj_unreference((struct vmw_fence_obj **)sync_obj);
#line 414
  return;
}
}
#line 416 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_flush(void *sync_obj ) 
{ 


  {
#line 418
  vmw_fence_obj_flush((struct vmw_fence_obj *)sync_obj);
#line 419
  return (0);
}
}
#line 422 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static bool vmw_sync_obj_signaled(void *sync_obj ) 
{ 
  bool tmp ;

  {
#line 424
  tmp = vmw_fence_obj_signaled((struct vmw_fence_obj *)sync_obj, 1U);
#line 424
  return (tmp);
}
}
#line 429 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_wait(void *sync_obj , bool lazy , bool interruptible ) 
{ 
  int tmp ;

  {
#line 431
  tmp = vmw_fence_obj_wait((struct vmw_fence_obj *)sync_obj, 1U, (int )lazy, (int )interruptible,
                           1250UL);
#line 431
  return (tmp);
}
}
#line 437 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_bo_driver vmw_bo_driver  = 
#line 437
     {& vmw_ttm_tt_create, & ttm_pool_populate, & ttm_pool_unpopulate, & vmw_invalidate_caches,
    & vmw_init_mem_type, & vmw_evict_flags, 0, & vmw_verify_access, & vmw_sync_obj_signaled,
    & vmw_sync_obj_wait, & vmw_sync_obj_flush, & vmw_sync_obj_unref, & vmw_sync_obj_ref,
    0, & vmw_ttm_fault_reserve_notify, 0, & vmw_ttm_io_mem_reserve, & vmw_ttm_io_mem_free};
#line 495 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_main7_sequence_infinite_withcheck_stateful(void) 
{ 
  struct ttm_tt *var_group1 ;
  struct ttm_mem_reg *var_group2 ;
  struct ttm_bo_device *var_group3 ;
  uint32_t var_vmw_invalidate_caches_4_p1 ;
  uint32_t var_vmw_init_mem_type_5_p1 ;
  struct ttm_mem_type_manager *var_vmw_init_mem_type_5_p2 ;
  struct ttm_buffer_object *var_group4 ;
  struct ttm_placement *var_group5 ;
  struct file *var_group6 ;
  void *var_vmw_sync_obj_signaled_14_p0 ;
  void *var_vmw_sync_obj_wait_15_p0 ;
  bool var_vmw_sync_obj_wait_15_p1 ;
  bool var_vmw_sync_obj_wait_15_p2 ;
  void *var_vmw_sync_obj_flush_13_p0 ;
  void **var_vmw_sync_obj_unref_12_p0 ;
  void *var_vmw_sync_obj_ref_11_p0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 567
  LDV_IN_INTERRUPT = 1;
#line 576
  ldv_initialize();
#line 582
  goto ldv_40677;
  ldv_40676: 
#line 585
  tmp = __VERIFIER_nondet_int();
#line 585
  switch (tmp) {
  case 0: 
#line 595
  ldv_handler_precall();
#line 596
  vmw_ttm_bind(var_group1, var_group2);
#line 603
  goto ldv_40663;
  case 1: 
#line 612
  ldv_handler_precall();
#line 613
  vmw_ttm_unbind(var_group1);
#line 620
  goto ldv_40663;
  case 2: 
#line 629
  ldv_handler_precall();
#line 630
  vmw_ttm_destroy(var_group1);
#line 637
  goto ldv_40663;
  case 3: 
#line 646
  ldv_handler_precall();
#line 647
  vmw_invalidate_caches(var_group3, var_vmw_invalidate_caches_4_p1);
#line 654
  goto ldv_40663;
  case 4: 
#line 663
  ldv_handler_precall();
#line 664
  vmw_init_mem_type(var_group3, var_vmw_init_mem_type_5_p1, var_vmw_init_mem_type_5_p2);
#line 671
  goto ldv_40663;
  case 5: 
#line 680
  ldv_handler_precall();
#line 681
  vmw_evict_flags(var_group4, var_group5);
#line 688
  goto ldv_40663;
  case 6: 
#line 697
  ldv_handler_precall();
#line 698
  vmw_verify_access(var_group4, var_group6);
#line 705
  goto ldv_40663;
  case 7: 
#line 714
  ldv_handler_precall();
#line 715
  vmw_sync_obj_signaled(var_vmw_sync_obj_signaled_14_p0);
#line 722
  goto ldv_40663;
  case 8: 
#line 731
  ldv_handler_precall();
#line 732
  vmw_sync_obj_wait(var_vmw_sync_obj_wait_15_p0, (int )var_vmw_sync_obj_wait_15_p1,
                    (int )var_vmw_sync_obj_wait_15_p2);
#line 739
  goto ldv_40663;
  case 9: 
#line 748
  ldv_handler_precall();
#line 749
  vmw_sync_obj_flush(var_vmw_sync_obj_flush_13_p0);
#line 756
  goto ldv_40663;
  case 10: 
#line 765
  ldv_handler_precall();
#line 766
  vmw_sync_obj_unref(var_vmw_sync_obj_unref_12_p0);
#line 773
  goto ldv_40663;
  case 11: 
#line 782
  ldv_handler_precall();
#line 783
  vmw_sync_obj_ref(var_vmw_sync_obj_ref_11_p0);
#line 790
  goto ldv_40663;
  default: ;
#line 791
  goto ldv_40663;
  }
  ldv_40663: ;
  ldv_40677: 
#line 582
  tmp___0 = __VERIFIER_nondet_int();
#line 582
  if (tmp___0 != 0) {
#line 583
    goto ldv_40676;
  } else {

  }


#line 800
  ldv_check_final_state();
#line 803
  return;
}
}
#line 807 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_291(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 812
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 814
  mutex_lock(ldv_func_arg1);
#line 815
  return;
}
}
#line 817 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 822
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 824
  mutex_unlock(ldv_func_arg1);
#line 825
  return;
}
}
#line 827 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 832
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 834
  mutex_lock(ldv_func_arg1);
#line 835
  return;
}
}
#line 837 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int ldv_mutex_trylock_294(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 842
  tmp = mutex_trylock(ldv_func_arg1);
#line 842
  ldv_func_res = tmp;
#line 844
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 844
  return (tmp___0);
#line 846
  return (ldv_func_res);
}
}
#line 849 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_295(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 854
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 856
  mutex_unlock(ldv_func_arg1);
#line 857
  return;
}
}
#line 859 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_296(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 864
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 866
  mutex_lock(ldv_func_arg1);
#line 867
  return;
}
}
#line 869 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_297(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 874
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 876
  mutex_unlock(ldv_func_arg1);
#line 877
  return;
}
}
#line 879 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_298(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 884
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 886
  mutex_lock(ldv_func_arg1);
#line 887
  return;
}
}
#line 889 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_299(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 894
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 896
  mutex_unlock(ldv_func_arg1);
#line 897
  return;
}
}
#line 899 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 904
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 906
  mutex_unlock(ldv_func_arg1);
#line 907
  return;
}
}
#line 909 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 914
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 916
  mutex_lock(ldv_func_arg1);
#line 917
  return;
}
}
#line 919 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 924
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 926
  mutex_unlock(ldv_func_arg1);
#line 927
  return;
}
}
#line 929 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 934
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 936
  mutex_lock(ldv_func_arg1);
#line 937
  return;
}
}
#line 939 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 944
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 946
  mutex_unlock(ldv_func_arg1);
#line 947
  return;
}
}
#line 324 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 328
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 333
  return (oldbit);
}
}
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 119 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 123
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 126
  return ((unsigned int )c != 0U);
}
}
#line 173 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 175
  __ret = i;
#line 175
  switch (4UL) {
  case 1UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 2UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 4UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 8UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  default: 
#line 175
  __xadd_wrong_size();
  }
  ldv_5474: ;
#line 175
  return (__ret + i);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_323(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_332(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_334(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_324(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_333(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_337(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_341(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) ;
#line 83
void ldv_mutex_lock_fifo_mutex(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_fifo_mutex(struct mutex *lock ) ;
#line 91 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 93
  tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
#line 93
  return (tmp);
}
}
#line 139 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 732
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 734
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 737
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 67 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 90
extern void down_write(struct rw_semaphore * ) ;
#line 105
extern void up_write(struct rw_semaphore * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 215 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 217
  __len = count;
#line 217
  __ret = __builtin_memcpy((void *)dst, src, __len);
#line 219
  return;
}
}
#line 330 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 2592 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2594
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2594
  return (tmp);
}
}
#line 2618 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2620
  tmp = test_tsk_thread_flag(p, 2);
#line 2620
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2620
  return ((int )tmp___0);
}
}
#line 635 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) ;
#line 636
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) ;
#line 637
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) ;
#line 135 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) 
{ 
  __le32 *fifo_mem ;
  uint32_t fifo_min ;
  uint32_t hwversion ;
  struct vmw_fifo_state  const  *fifo ;

  {
#line 137
  fifo_mem = dev_priv->mmio_virt;
#line 139
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 141
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 142
    return (0);
  } else {

  }
#line 144
  fifo_min = ioread32((void *)fifo_mem);
#line 145
  if (fifo_min <= 28U) {
#line 146
    return (0);
  } else {

  }
#line 148
  hwversion = ioread32((void *)(fifo_mem + (((unsigned int )fifo->capabilities & 256U) != 0U ? 17UL : 7UL)));
#line 154
  if (hwversion == 0U) {
#line 155
    return (0);
  } else {

  }
#line 157
  if (hwversion <= 131072U) {
#line 158
    return (0);
  } else {

  }
#line 161
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 162
    return (0);
  } else {

  }
#line 164
  return (1);
}
}
#line 167 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) 
{ 
  __le32 *fifo_mem ;
  uint32_t caps ;

  {
#line 169
  fifo_mem = dev_priv->mmio_virt;
#line 172
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 173
    return (0);
  } else {

  }
#line 175
  caps = ioread32((void *)fifo_mem + 4U);
#line 176
  if ((caps & 4U) != 0U) {
#line 177
    return (1);
  } else {

  }
#line 179
  return (0);
}
}
#line 182 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ 
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t dummy ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 184
  fifo_mem = dev_priv->mmio_virt;
#line 189
  fifo->static_buffer_size = 1048576UL;
#line 190
  tmp = vmalloc(fifo->static_buffer_size);
#line 190
  fifo->static_buffer = (__le32 *)tmp;
#line 191
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer == (unsigned long )((__le32 *)0),
                             0L);
#line 191
  if (tmp___0 != 0L) {
#line 192
    return (-12);
  } else {

  }
#line 194
  fifo->dynamic_buffer = 0;
#line 195
  fifo->reserved_size = 0UL;
#line 196
  fifo->using_bounce_buffer = 0;
#line 198
  __mutex_init(& fifo->fifo_mutex, "&fifo->fifo_mutex", & __key);
#line 199
  __init_rwsem(& fifo->rwsem, "&fifo->rwsem", & __key___0);
#line 205
  tmp___1 = vmw_read(dev_priv, 2U);
#line 205
  printk("\016[drm] width %d\n", tmp___1);
#line 206
  tmp___2 = vmw_read(dev_priv, 3U);
#line 206
  printk("\016[drm] height %d\n", tmp___2);
#line 207
  tmp___3 = vmw_read(dev_priv, 7U);
#line 207
  printk("\016[drm] bpp %d\n", tmp___3);
#line 209
  ldv_mutex_lock_333(& dev_priv->hw_mutex);
#line 210
  dev_priv->enable_state = vmw_read(dev_priv, 1U);
#line 211
  dev_priv->config_done_state = vmw_read(dev_priv, 20U);
#line 212
  dev_priv->traces_state = vmw_read(dev_priv, 45U);
#line 213
  vmw_write(dev_priv, 1U, 1U);
#line 215
  min = 4U;
#line 216
  if ((dev_priv->capabilities & 32768U) != 0U) {
#line 217
    min = vmw_read(dev_priv, 30U);
  } else {

  }
#line 218
  min = min << 2;
#line 220
  if (min <= 4095U) {
#line 221
    min = 4096U;
  } else {

  }
#line 223
  iowrite32(min, (void *)fifo_mem);
#line 224
  iowrite32(dev_priv->mmio_size, (void *)fifo_mem + 1U);
#line 225
  __asm__  volatile   ("sfence": : : "memory");
#line 226
  iowrite32(min, (void *)fifo_mem + 2U);
#line 227
  iowrite32(min, (void *)fifo_mem + 3U);
#line 228
  iowrite32(0U, (void *)fifo_mem + 290U);
#line 229
  __asm__  volatile   ("mfence": : : "memory");
#line 231
  vmw_write(dev_priv, 20U, 1U);
#line 232
  ldv_mutex_unlock_334(& dev_priv->hw_mutex);
#line 234
  max = ioread32((void *)fifo_mem + 1U);
#line 235
  min = ioread32((void *)fifo_mem);
#line 236
  fifo->capabilities = ioread32((void *)fifo_mem + 4U);
#line 238
  printk("\016[drm] Fifo max 0x%08x min 0x%08x cap 0x%08x\n", max, min, fifo->capabilities);
#line 243
  atomic_set(& dev_priv->marker_seq, (int )dev_priv->last_read_seqno);
#line 244
  iowrite32(dev_priv->last_read_seqno, (void *)fifo_mem + 6U);
#line 245
  vmw_marker_queue_init(& fifo->marker_queue);
#line 246
  tmp___4 = vmw_fifo_send_fence(dev_priv, & dummy);
#line 246
  return (tmp___4);
}
}
#line 249 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) 
{ 
  __le32 *fifo_mem ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 251
  fifo_mem = dev_priv->mmio_virt;
#line 253
  ldv_mutex_lock_335(& dev_priv->hw_mutex);
#line 255
  tmp = ioread32((void *)fifo_mem + 290U);
#line 255
  tmp___0 = ldv__builtin_expect(tmp == 0U, 0L);
#line 255
  if (tmp___0 != 0L) {
#line 256
    iowrite32(1U, (void *)fifo_mem + 290U);
#line 257
    vmw_write(dev_priv, 21U, reason);
  } else {

  }
#line 260
  ldv_mutex_unlock_336(& dev_priv->hw_mutex);
#line 261
  return;
}
}
#line 263 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ 
  __le32 *fifo_mem ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 265
  fifo_mem = dev_priv->mmio_virt;
#line 267
  ldv_mutex_lock_337(& dev_priv->hw_mutex);
#line 269
  goto ldv_40577;
  ldv_40576: 
#line 270
  vmw_write(dev_priv, 21U, 1U);
  ldv_40577: 
#line 269
  tmp = vmw_read(dev_priv, 22U);
#line 269
  if (tmp != 0U) {
#line 270
    goto ldv_40576;
  } else {

  }
#line 272
  dev_priv->last_read_seqno = ioread32((void *)fifo_mem + 6U);
#line 274
  vmw_write(dev_priv, 20U, dev_priv->config_done_state);
#line 276
  vmw_write(dev_priv, 1U, dev_priv->enable_state);
#line 278
  vmw_write(dev_priv, 45U, dev_priv->traces_state);
#line 281
  ldv_mutex_unlock_338(& dev_priv->hw_mutex);
#line 282
  vmw_marker_queue_takedown(& fifo->marker_queue);
#line 284
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 284
  if (tmp___0 != 0L) {
#line 285
    vfree((void const   *)fifo->static_buffer);
#line 286
    fifo->static_buffer = 0;
  } else {

  }
#line 289
  tmp___1 = ldv__builtin_expect((unsigned long )fifo->dynamic_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 289
  if (tmp___1 != 0L) {
#line 290
    vfree((void const   *)fifo->dynamic_buffer);
#line 291
    fifo->dynamic_buffer = 0;
  } else {

  }
#line 293
  return;
}
}
#line 295 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static bool vmw_fifo_is_full(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  __le32 *fifo_mem ;
  uint32_t max ;
  unsigned int tmp ;
  uint32_t next_cmd ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;

  {
#line 297
  fifo_mem = dev_priv->mmio_virt;
#line 298
  tmp = ioread32((void *)fifo_mem + 1U);
#line 298
  max = tmp;
#line 299
  tmp___0 = ioread32((void *)fifo_mem + 2U);
#line 299
  next_cmd = tmp___0;
#line 300
  tmp___1 = ioread32((void *)fifo_mem);
#line 300
  min = tmp___1;
#line 301
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 301
  stop = tmp___2;
#line 303
  return ((max - next_cmd) + (stop - min) <= bytes);
}
}
#line 306 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                               unsigned long timeout ) 
{ 
  int ret ;
  unsigned long end_jiffies ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;

  {
#line 310
  ret = 0;
#line 311
  end_jiffies = (unsigned long )jiffies + timeout;
#line 312
  tmp = get_current();
#line 312
  __wait.flags = 0U;
#line 312
  __wait.private = (void *)tmp;
#line 312
  __wait.func = & autoremove_wake_function;
#line 312
  __wait.task_list.next = & __wait.task_list;
#line 312
  __wait.task_list.prev = & __wait.task_list;
#line 314
  printk("\016[drm] Fifo wait noirq.\n");
  ldv_40605: 
#line 317
  prepare_to_wait(& dev_priv->fifo_queue, & __wait, (int )interruptible ? 1 : 2);
#line 320
  tmp___0 = vmw_fifo_is_full(dev_priv, bytes);
#line 320
  if (tmp___0) {
#line 320
    tmp___1 = 0;
  } else {
#line 320
    tmp___1 = 1;
  }
#line 320
  if (tmp___1) {
#line 321
    goto ldv_40597;
  } else {

  }
#line 322
  if ((long )jiffies - (long )end_jiffies >= 0L) {
#line 323
    ret = -16;
#line 324
    drm_err("vmw_fifo_wait_noirq", "SVGA device lockup.\n");
#line 325
    goto ldv_40597;
  } else {

  }
#line 327
  schedule_timeout(1L);
#line 328
  if ((int )interruptible) {
#line 328
    tmp___2 = get_current();
#line 328
    tmp___3 = signal_pending(tmp___2);
#line 328
    if (tmp___3 != 0) {
#line 329
      ret = -512;
#line 330
      goto ldv_40597;
    } else {

    }
  } else {

  }
#line 332
  goto ldv_40605;
  ldv_40597: 
#line 333
  finish_wait(& dev_priv->fifo_queue, & __wait);
#line 334
  __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
#line 335
  printk("\016[drm] Fifo noirq exit.\n");
#line 336
  return (ret);
}
}
#line 339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                         unsigned long timeout ) 
{ 
  long ret ;
  unsigned long irq_flags ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  int tmp___4 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct task_struct *tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  raw_spinlock_t *tmp___17 ;
  int tmp___18 ;

  {
#line 343
  ret = 1L;
#line 346
  tmp = vmw_fifo_is_full(dev_priv, bytes);
#line 346
  if (tmp) {
#line 346
    tmp___0 = 0;
  } else {
#line 346
    tmp___0 = 1;
  }
#line 346
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 346
  if (tmp___1 != 0L) {
#line 347
    return (0);
  } else {

  }
#line 349
  vmw_fifo_ping_host(dev_priv, 2U);
#line 350
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 351
    tmp___2 = vmw_fifo_wait_noirq(dev_priv, bytes, (int )interruptible, timeout);
#line 351
    return (tmp___2);
  } else {

  }
#line 354
  ldv_mutex_lock_339(& dev_priv->hw_mutex);
#line 355
  tmp___4 = atomic_add_return(1, & dev_priv->fifo_queue_waiters);
#line 355
  if (tmp___4 > 0) {
#line 356
    tmp___3 = spinlock_check(& dev_priv->irq_lock);
#line 356
    irq_flags = _raw_spin_lock_irqsave(tmp___3);
#line 357
    outl(2U, (int )(dev_priv->io_start + 8U));
#line 359
    dev_priv->irq_mask = dev_priv->irq_mask | 2U;
#line 360
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 361
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 363
  ldv_mutex_unlock_340(& dev_priv->hw_mutex);
#line 365
  if ((int )interruptible) {
#line 366
    __ret = (long )timeout;
#line 366
    tmp___10 = vmw_fifo_is_full(dev_priv, bytes);
#line 366
    if ((int )tmp___10) {
#line 366
      tmp___5 = get_current();
#line 366
      __wait.flags = 0U;
#line 366
      __wait.private = (void *)tmp___5;
#line 366
      __wait.func = & autoremove_wake_function;
#line 366
      __wait.task_list.next = & __wait.task_list;
#line 366
      __wait.task_list.prev = & __wait.task_list;
      ldv_40621: 
#line 366
      prepare_to_wait(& dev_priv->fifo_queue, & __wait, 1);
#line 366
      tmp___6 = vmw_fifo_is_full(dev_priv, bytes);
#line 366
      if (tmp___6) {
#line 366
        tmp___7 = 0;
      } else {
#line 366
        tmp___7 = 1;
      }
#line 366
      if (tmp___7) {
#line 366
        goto ldv_40619;
      } else {

      }
#line 366
      tmp___8 = get_current();
#line 366
      tmp___9 = signal_pending(tmp___8);
#line 366
      if (tmp___9 == 0) {
#line 366
        __ret = schedule_timeout(__ret);
#line 366
        if (__ret == 0L) {
#line 366
          goto ldv_40619;
        } else {

        }
#line 366
        goto ldv_40620;
      } else {

      }
#line 366
      __ret = -512L;
#line 366
      goto ldv_40619;
      ldv_40620: ;
#line 366
      goto ldv_40621;
      ldv_40619: 
#line 366
      finish_wait(& dev_priv->fifo_queue, & __wait);
    } else {

    }
#line 366
    ret = __ret;
  } else {
#line 370
    __ret___0 = (long )timeout;
#line 370
    tmp___14 = vmw_fifo_is_full(dev_priv, bytes);
#line 370
    if ((int )tmp___14) {
#line 370
      tmp___11 = get_current();
#line 370
      __wait___0.flags = 0U;
#line 370
      __wait___0.private = (void *)tmp___11;
#line 370
      __wait___0.func = & autoremove_wake_function;
#line 370
      __wait___0.task_list.next = & __wait___0.task_list;
#line 370
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40626: 
#line 370
      prepare_to_wait(& dev_priv->fifo_queue, & __wait___0, 2);
#line 370
      tmp___12 = vmw_fifo_is_full(dev_priv, bytes);
#line 370
      if (tmp___12) {
#line 370
        tmp___13 = 0;
      } else {
#line 370
        tmp___13 = 1;
      }
#line 370
      if (tmp___13) {
#line 370
        goto ldv_40625;
      } else {

      }
#line 370
      __ret___0 = schedule_timeout(__ret___0);
#line 370
      if (__ret___0 == 0L) {
#line 370
        goto ldv_40625;
      } else {

      }
#line 370
      goto ldv_40626;
      ldv_40625: 
#line 370
      finish_wait(& dev_priv->fifo_queue, & __wait___0);
    } else {

    }
#line 370
    ret = __ret___0;
  }
#line 374
  tmp___16 = ldv__builtin_expect(ret == 0L, 0L);
#line 374
  if (tmp___16 != 0L) {
#line 375
    ret = -16L;
  } else {
#line 376
    tmp___15 = ldv__builtin_expect(ret > 0L, 1L);
#line 376
    if (tmp___15 != 0L) {
#line 377
      ret = 0L;
    } else {

    }
  }
#line 379
  ldv_mutex_lock_341(& dev_priv->hw_mutex);
#line 380
  tmp___18 = atomic_dec_and_test(& dev_priv->fifo_queue_waiters);
#line 380
  if (tmp___18 != 0) {
#line 381
    tmp___17 = spinlock_check(& dev_priv->irq_lock);
#line 381
    irq_flags = _raw_spin_lock_irqsave(tmp___17);
#line 382
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967293U;
#line 383
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 384
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 386
  ldv_mutex_unlock_342(& dev_priv->hw_mutex);
#line 388
  return ((int )ret);
}
}
#line 401 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t next_cmd ;
  uint32_t reserveable ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;
  bool need_bounce ;
  bool reserve_in_place ;
  long tmp___3 ;
  bool tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;

  {
#line 403
  fifo_state = & dev_priv->fifo;
#line 404
  fifo_mem = dev_priv->mmio_virt;
#line 408
  reserveable = fifo_state->capabilities & 64U;
#line 411
  ldv_mutex_lock_343(& fifo_state->fifo_mutex);
#line 412
  max = ioread32((void *)fifo_mem + 1U);
#line 413
  min = ioread32((void *)fifo_mem);
#line 414
  next_cmd = ioread32((void *)fifo_mem + 2U);
#line 416
  tmp = ldv__builtin_expect(max - min <= bytes, 0L);
#line 416
  if (tmp != 0L) {
#line 417
    goto out_err;
  } else {

  }
#line 419
  tmp___0 = ldv__builtin_expect(fifo_state->reserved_size != 0UL, 0L);
#line 419
  if (tmp___0 != 0L) {
#line 419
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (419), "i" (12UL));
    ldv_40643: ;
#line 419
    goto ldv_40643;
  } else {

  }
#line 420
  tmp___1 = ldv__builtin_expect((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0),
                             0L);
#line 420
  if (tmp___1 != 0L) {
#line 420
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (420), "i" (12UL));
    ldv_40644: ;
#line 420
    goto ldv_40644;
  } else {

  }
#line 422
  fifo_state->reserved_size = (unsigned long )bytes;
  ldv_40648: 
#line 425
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 425
  stop = tmp___2;
#line 426
  need_bounce = 0;
#line 427
  reserve_in_place = 0;
#line 429
  if (next_cmd >= stop) {
#line 430
    tmp___5 = ldv__builtin_expect(next_cmd + bytes < max, 1L);
#line 430
    if (tmp___5 != 0L) {
#line 432
      reserve_in_place = 1;
    } else {
#line 430
      tmp___6 = ldv__builtin_expect(next_cmd + bytes == max, 1L);
#line 430
      if (tmp___6 != 0L) {
#line 430
        tmp___7 = ldv__builtin_expect(stop > min, 1L);
#line 430
        if (tmp___7 != 0L) {
#line 430
          tmp___8 = 1;
        } else {
#line 430
          tmp___8 = 0;
        }
      } else {
#line 430
        tmp___8 = 0;
      }
#line 430
      if (tmp___8 != 0) {
#line 432
        reserve_in_place = 1;
      } else {
#line 434
        tmp___4 = vmw_fifo_is_full(dev_priv, bytes);
#line 434
        if ((int )tmp___4) {
#line 435
          ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 437
          tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 437
          if (tmp___3 != 0L) {
#line 438
            goto out_err;
          } else {

          }
        } else {
#line 440
          need_bounce = 1;
        }
      }
    }
  } else {
#line 444
    tmp___10 = ldv__builtin_expect(next_cmd + bytes < stop, 1L);
#line 444
    if (tmp___10 != 0L) {
#line 445
      reserve_in_place = 1;
    } else {
#line 447
      ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 449
      tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 449
      if (tmp___9 != 0L) {
#line 450
        goto out_err;
      } else {

      }
    }
  }
#line 454
  if ((int )reserve_in_place) {
#line 455
    if (reserveable != 0U || bytes <= 4U) {
#line 456
      fifo_state->using_bounce_buffer = 0;
#line 458
      if (reserveable != 0U) {
#line 459
        iowrite32(bytes, (void *)fifo_mem + 14U);
      } else {

      }
#line 461
      return ((void *)fifo_mem + (unsigned long )(next_cmd >> 2));
    } else {
#line 463
      need_bounce = 1;
    }
  } else {

  }
#line 467
  if ((int )need_bounce) {
#line 468
    fifo_state->using_bounce_buffer = 1;
#line 469
    if ((unsigned long )bytes < fifo_state->static_buffer_size) {
#line 470
      return ((void *)fifo_state->static_buffer);
    } else {
#line 472
      tmp___11 = vmalloc((unsigned long )bytes);
#line 472
      fifo_state->dynamic_buffer = (__le32 *)tmp___11;
#line 473
      return ((void *)fifo_state->dynamic_buffer);
    }
  } else {

  }
#line 476
  goto ldv_40648;
  out_err: 
#line 478
  fifo_state->reserved_size = 0UL;
#line 479
  ldv_mutex_unlock_344(& fifo_state->fifo_mutex);
#line 480
  return (0);
}
}
#line 483 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                              uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ 
  uint32_t chunk_size ;
  uint32_t rest ;
  uint32_t *buffer ;

  {
#line 488
  chunk_size = max - next_cmd;
#line 490
  buffer = (unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0) ? fifo_state->dynamic_buffer : fifo_state->static_buffer;
#line 493
  if (bytes < chunk_size) {
#line 494
    chunk_size = bytes;
  } else {

  }
#line 496
  iowrite32(bytes, (void *)fifo_mem + 14U);
#line 497
  __asm__  volatile   ("mfence": : : "memory");
#line 498
  memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(next_cmd >> 2), (void const   *)buffer,
              (size_t )chunk_size);
#line 499
  rest = bytes - chunk_size;
#line 500
  if (rest != 0U) {
#line 501
    memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(min >> 2), (void const   *)buffer + (unsigned long )(chunk_size >> 2),
                (size_t )rest);
  } else {

  }
#line 502
  return;
}
}
#line 505 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                               uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ 
  uint32_t *buffer ;
  uint32_t *tmp ;
  long tmp___0 ;

  {
#line 510
  buffer = (unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0) ? fifo_state->dynamic_buffer : fifo_state->static_buffer;
#line 513
  goto ldv_40670;
  ldv_40669: 
#line 514
  tmp = buffer;
#line 514
  buffer = buffer + 1;
#line 514
  iowrite32(*tmp, (void *)fifo_mem + (unsigned long )(next_cmd >> 2));
#line 515
  next_cmd = next_cmd + 4U;
#line 516
  tmp___0 = ldv__builtin_expect(next_cmd == max, 0L);
#line 516
  if (tmp___0 != 0L) {
#line 517
    next_cmd = min;
  } else {

  }
#line 518
  __asm__  volatile   ("mfence": : : "memory");
#line 519
  iowrite32(next_cmd, (void *)fifo_mem + 2U);
#line 520
  __asm__  volatile   ("mfence": : : "memory");
#line 521
  bytes = bytes - 4U;
  ldv_40670: ;
#line 513
  if (bytes != 0U) {
#line 514
    goto ldv_40669;
  } else {

  }

#line 518
  return;
}
}
#line 525 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t next_cmd ;
  unsigned int tmp ;
  uint32_t max ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  bool reserveable ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 527
  fifo_state = & dev_priv->fifo;
#line 528
  fifo_mem = dev_priv->mmio_virt;
#line 529
  tmp = ioread32((void *)fifo_mem + 2U);
#line 529
  next_cmd = tmp;
#line 530
  tmp___0 = ioread32((void *)fifo_mem + 1U);
#line 530
  max = tmp___0;
#line 531
  tmp___1 = ioread32((void *)fifo_mem);
#line 531
  min = tmp___1;
#line 532
  reserveable = (fifo_state->capabilities & 64U) != 0U;
#line 534
  tmp___2 = ldv__builtin_expect((bytes & 3U) != 0U, 0L);
#line 534
  if (tmp___2 != 0L) {
#line 534
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (534), "i" (12UL));
    ldv_40682: ;
#line 534
    goto ldv_40682;
  } else {

  }
#line 535
  tmp___3 = ldv__builtin_expect((unsigned long )bytes > fifo_state->reserved_size, 0L);
#line 535
  if (tmp___3 != 0L) {
#line 535
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (535), "i" (12UL));
    ldv_40683: ;
#line 535
    goto ldv_40683;
  } else {

  }
#line 537
  fifo_state->reserved_size = 0UL;
#line 539
  if ((int )fifo_state->using_bounce_buffer) {
#line 540
    if ((int )reserveable) {
#line 541
      vmw_fifo_res_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    } else {
#line 544
      vmw_fifo_slow_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    }
#line 547
    if ((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0)) {
#line 548
      vfree((void const   *)fifo_state->dynamic_buffer);
#line 549
      fifo_state->dynamic_buffer = 0;
    } else {

    }
  } else {

  }
#line 554
  down_write(& fifo_state->rwsem);
#line 555
  if ((int )fifo_state->using_bounce_buffer || (int )reserveable) {
#line 556
    next_cmd = next_cmd + bytes;
#line 557
    if (next_cmd >= max) {
#line 558
      next_cmd = (min - max) + next_cmd;
    } else {

    }
#line 559
    __asm__  volatile   ("mfence": : : "memory");
#line 560
    iowrite32(next_cmd, (void *)fifo_mem + 2U);
  } else {

  }
#line 563
  if ((int )reserveable) {
#line 564
    iowrite32(0U, (void *)fifo_mem + 14U);
  } else {

  }
#line 565
  __asm__  volatile   ("mfence": : : "memory");
#line 566
  up_write(& fifo_state->rwsem);
#line 567
  vmw_fifo_ping_host(dev_priv, 1U);
#line 568
  ldv_mutex_unlock_345(& fifo_state->fifo_mutex);
#line 569
  return;
}
}
#line 571 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  struct svga_fifo_cmd_fence *cmd_fence ;
  void *fm ;
  int ret ;
  uint32_t bytes ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 573
  fifo_state = & dev_priv->fifo;
#line 576
  ret = 0;
#line 577
  bytes = 8U;
#line 579
  fm = vmw_fifo_reserve(dev_priv, bytes);
#line 580
  tmp___0 = ldv__builtin_expect((unsigned long )fm == (unsigned long )((void *)0), 0L);
#line 580
  if (tmp___0 != 0L) {
#line 581
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 581
    *seqno = (uint32_t )tmp;
#line 582
    ret = -12;
#line 583
    vmw_fallback_wait(dev_priv, 0, 1, *seqno, 0, 750UL);
#line 585
    goto out_err;
  } else {

  }
  ldv_40694: 
#line 589
  tmp___1 = atomic_add_return(1, & dev_priv->marker_seq);
#line 589
  *seqno = (uint32_t )tmp___1;
#line 590
  if (*seqno == 0U) {
#line 591
    goto ldv_40694;
  } else {

  }

#line 592
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 599
    vmw_fifo_commit(dev_priv, 0U);
#line 600
    return (0);
  } else {

  }
#line 603
  *((__le32 *)fm) = 30U;
#line 604
  cmd_fence = (struct svga_fifo_cmd_fence *)((unsigned long )fm + 4UL);
#line 607
  iowrite32(*seqno, (void *)(& cmd_fence->fence));
#line 608
  vmw_fifo_commit(dev_priv, bytes);
#line 609
  vmw_marker_push(& fifo_state->marker_queue, *seqno);
#line 610
  vmw_update_seqno(dev_priv, fifo_state);
  out_err: ;
#line 613
  return (ret);
}
}
#line 633 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) 
{ 
  struct ttm_buffer_object *bo ;
  struct __anonstruct_cmd_291___1 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 642
  bo = dev_priv->dummy_query_bo;
#line 648
  tmp = vmw_fifo_reserve(dev_priv, 24U);
#line 648
  cmd = (struct __anonstruct_293___0 *)tmp;
#line 650
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___1 *)0),
                             0L);
#line 650
  if (tmp___0 != 0L) {
#line 651
    drm_err("vmw_fifo_emit_dummy_query", "Out of fifo space for dummy query.\n");
#line 652
    return (-12);
  } else {

  }
#line 655
  cmd->header.id = 1067U;
#line 656
  cmd->header.size = 16U;
#line 657
  cmd->body.cid = cid;
#line 658
  cmd->body.type = 0;
#line 660
  if (bo->mem.mem_type == 2U) {
#line 661
    cmd->body.guestResult.gmrId = 4294967294U;
#line 662
    cmd->body.guestResult.offset = (uint32 )bo->offset;
  } else {
#line 664
    cmd->body.guestResult.gmrId = (uint32 )bo->mem.start;
#line 665
    cmd->body.guestResult.offset = 0U;
  }
#line 668
  vmw_fifo_commit(dev_priv, 24U);
#line 670
  return (0);
}
}
#line 673 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 678
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 680
  mutex_lock(ldv_func_arg1);
#line 681
  return;
}
}
#line 683 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 688
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 690
  mutex_unlock(ldv_func_arg1);
#line 691
  return;
}
}
#line 693 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 698
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 700
  mutex_lock(ldv_func_arg1);
#line 701
  return;
}
}
#line 703 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 708
  tmp = mutex_trylock(ldv_func_arg1);
#line 708
  ldv_func_res = tmp;
#line 710
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 710
  return (tmp___0);
#line 712
  return (ldv_func_res);
}
}
#line 715 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_323(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 720
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 722
  mutex_unlock(ldv_func_arg1);
#line 723
  return;
}
}
#line 725 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_324(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 730
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 732
  mutex_lock(ldv_func_arg1);
#line 733
  return;
}
}
#line 735 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 740
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 742
  mutex_unlock(ldv_func_arg1);
#line 743
  return;
}
}
#line 745 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 750
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 752
  mutex_lock(ldv_func_arg1);
#line 753
  return;
}
}
#line 755 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 760
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 762
  mutex_unlock(ldv_func_arg1);
#line 763
  return;
}
}
#line 765 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 770
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 772
  mutex_unlock(ldv_func_arg1);
#line 773
  return;
}
}
#line 775 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 780
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 782
  mutex_lock(ldv_func_arg1);
#line 783
  return;
}
}
#line 785 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 790
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 792
  mutex_unlock(ldv_func_arg1);
#line 793
  return;
}
}
#line 795 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 800
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 802
  mutex_lock(ldv_func_arg1);
#line 803
  return;
}
}
#line 805 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_332(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 810
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 812
  mutex_unlock(ldv_func_arg1);
#line 813
  return;
}
}
#line 815 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_333(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 820
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 822
  mutex_lock(ldv_func_arg1);
#line 823
  return;
}
}
#line 825 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_334(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 830
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 832
  mutex_unlock(ldv_func_arg1);
#line 833
  return;
}
}
#line 835 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 842
  mutex_lock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 850
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 852
  mutex_unlock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_337(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 860
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 862
  mutex_lock(ldv_func_arg1);
#line 863
  return;
}
}
#line 865 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 870
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 872
  mutex_unlock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 880
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 882
  mutex_lock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 890
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 892
  mutex_unlock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_341(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 900
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 902
  mutex_lock(ldv_func_arg1);
#line 903
  return;
}
}
#line 905 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 910
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 912
  mutex_unlock(ldv_func_arg1);
#line 913
  return;
}
}
#line 915 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 920
  ldv_mutex_lock_fifo_mutex(ldv_func_arg1);
#line 922
  mutex_lock(ldv_func_arg1);
#line 923
  return;
}
}
#line 925 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 930
  ldv_mutex_unlock_fifo_mutex(ldv_func_arg1);
#line 932
  mutex_unlock(ldv_func_arg1);
#line 933
  return;
}
}
#line 935 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 940
  ldv_mutex_unlock_fifo_mutex(ldv_func_arg1);
#line 942
  mutex_unlock(ldv_func_arg1);
#line 943
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_376(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_374(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_377(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_379(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_382(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_384(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_373(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_375(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_378(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_380(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_385(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_389(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_395(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) ;
#line 80 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 100
extern void up_read(struct rw_semaphore * ) ;
#line 334 "include/linux/sched.h"
extern void schedule(void) ;
#line 75 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fences_update(struct vmw_fence_manager *fman ) ;
#line 609 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) ;
#line 615
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) ;
#line 625
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) ;
#line 626
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) ;
#line 627
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) ;
#line 628
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) ;
#line 639
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) ;
#line 136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
irqreturn_t vmw_irq_handler(int irq , void *arg ) 
{ 
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  uint32_t masked_status ;
  long tmp___0 ;

  {
#line 138
  dev = (struct drm_device *)arg;
#line 139
  tmp = vmw_priv(dev);
#line 139
  dev_priv = tmp;
#line 142
  spin_lock(& dev_priv->irq_lock);
#line 143
  status = inl((int )(dev_priv->io_start + 8U));
#line 144
  masked_status = dev_priv->irq_mask & status;
#line 145
  spin_unlock(& dev_priv->irq_lock);
#line 147
  tmp___0 = ldv__builtin_expect(status != 0U, 1L);
#line 147
  if (tmp___0 != 0L) {
#line 148
    outl(status, (int )(dev_priv->io_start + 8U));
  } else {

  }
#line 150
  if (masked_status == 0U) {
#line 151
    return (0);
  } else {

  }
#line 153
  if ((masked_status & 5U) != 0U) {
#line 155
    vmw_fences_update(dev_priv->fman);
#line 156
    __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
  } else {

  }
#line 159
  if ((masked_status & 2U) != 0U) {
#line 160
    __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
  } else {

  }
#line 163
  return (1);
}
}
#line 166 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
static bool vmw_fifo_idle(struct vmw_private *dev_priv , uint32_t seqno ) 
{ 
  uint32_t busy ;

  {
#line 170
  ldv_mutex_lock_387(& dev_priv->hw_mutex);
#line 171
  busy = vmw_read(dev_priv, 22U);
#line 172
  ldv_mutex_unlock_388(& dev_priv->hw_mutex);
#line 174
  return (busy == 0U);
}
}
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) 
{ 
  __le32 *fifo_mem ;
  uint32_t seqno ;
  unsigned int tmp ;

  {
#line 180
  fifo_mem = dev_priv->mmio_virt;
#line 181
  tmp = ioread32((void *)fifo_mem + 6U);
#line 181
  seqno = tmp;
#line 183
  if (dev_priv->last_read_seqno != seqno) {
#line 184
    dev_priv->last_read_seqno = seqno;
#line 185
    vmw_marker_pull(& fifo_state->marker_queue, seqno);
#line 186
    vmw_fences_update(dev_priv->fman);
  } else {

  }
#line 188
  return;
}
}
#line 190 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  bool ret ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 196
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 196
  if (tmp != 0L) {
#line 197
    return (1);
  } else {

  }
#line 199
  fifo_state = & dev_priv->fifo;
#line 200
  vmw_update_seqno(dev_priv, fifo_state);
#line 201
  tmp___0 = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 201
  if (tmp___0 != 0L) {
#line 202
    return (1);
  } else {

  }
#line 204
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 204
    tmp___1 = vmw_fifo_idle(dev_priv, seqno);
#line 204
    if ((int )tmp___1) {
#line 206
      return (1);
    } else {

    }
  } else {

  }
#line 213
  tmp___2 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 213
  ret = (uint32_t )tmp___2 - seqno > 16777216U;
#line 216
  return (ret);
}
}
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  uint32_t count ;
  uint32_t signal_seq ;
  int ret ;
  unsigned long end_jiffies ;
  bool (*wait_condition)(struct vmw_private * , uint32_t  ) ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  __le32 *fifo_mem ;

  {
#line 226
  fifo_state = & dev_priv->fifo;
#line 228
  count = 0U;
#line 231
  end_jiffies = (unsigned long )jiffies + timeout;
#line 233
  tmp = get_current();
#line 233
  __wait.flags = 0U;
#line 233
  __wait.private = (void *)tmp;
#line 233
  __wait.func = & autoremove_wake_function;
#line 233
  __wait.task_list.next = & __wait.task_list;
#line 233
  __wait.task_list.prev = & __wait.task_list;
#line 235
  wait_condition = (int )fifo_idle ? & vmw_fifo_idle : & vmw_seqno_passed;
#line 242
  if ((int )fifo_idle) {
#line 243
    down_read(& fifo_state->rwsem);
  } else {

  }
#line 244
  tmp___0 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 244
  signal_seq = (uint32_t )tmp___0;
#line 245
  ret = 0;
  ldv_40590: 
#line 248
  prepare_to_wait(& dev_priv->fence_queue, & __wait, (int )interruptible ? 1 : 2);
#line 251
  tmp___1 = (*wait_condition)(dev_priv, seqno);
#line 251
  if ((int )tmp___1) {
#line 252
    goto ldv_40582;
  } else {

  }
#line 253
  if ((long )jiffies - (long )end_jiffies >= 0L) {
#line 254
    drm_err("vmw_fallback_wait", "SVGA device lockup.\n");
#line 255
    goto ldv_40582;
  } else {

  }
#line 257
  if ((int )lazy) {
#line 258
    schedule_timeout(1L);
  } else {
#line 259
    count = count + 1U;
#line 259
    if ((count & 15U) == 0U) {
#line 265
      tmp___2 = get_current();
#line 265
      tmp___2->state = 0L;
#line 266
      schedule();
#line 267
      tmp___3 = get_current();
#line 267
      tmp___3->state = (int )interruptible ? 1L : 2L;
    } else {

    }
  }
#line 271
  if ((int )interruptible) {
#line 271
    tmp___4 = get_current();
#line 271
    tmp___5 = signal_pending(tmp___4);
#line 271
    if (tmp___5 != 0) {
#line 272
      ret = -512;
#line 273
      goto ldv_40582;
    } else {

    }
  } else {

  }
#line 275
  goto ldv_40590;
  ldv_40582: 
#line 276
  finish_wait(& dev_priv->fence_queue, & __wait);
#line 277
  if (ret == 0 && (int )fifo_idle) {
#line 278
    fifo_mem = dev_priv->mmio_virt;
#line 279
    iowrite32(signal_seq, (void *)fifo_mem + 6U);
  } else {

  }
#line 281
  __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
#line 282
  if ((int )fifo_idle) {
#line 283
    up_read(& fifo_state->rwsem);
  } else {

  }
#line 285
  return (ret);
}
}
#line 288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 290
  ldv_mutex_lock_389(& dev_priv->hw_mutex);
#line 291
  tmp___0 = dev_priv->fence_queue_waiters;
#line 291
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters + 1;
#line 291
  if (tmp___0 == 0) {
#line 294
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 294
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 295
    outl(1U, (int )(dev_priv->io_start + 8U));
#line 297
    dev_priv->irq_mask = dev_priv->irq_mask | 1U;
#line 298
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 299
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 301
  ldv_mutex_unlock_390(& dev_priv->hw_mutex);
#line 302
  return;
}
}
#line 304 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 306
  ldv_mutex_lock_391(& dev_priv->hw_mutex);
#line 307
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters - 1;
#line 307
  if (dev_priv->fence_queue_waiters == 0) {
#line 310
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 310
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 311
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967294U;
#line 312
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 313
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 315
  ldv_mutex_unlock_392(& dev_priv->hw_mutex);
#line 316
  return;
}
}
#line 319 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 321
  ldv_mutex_lock_393(& dev_priv->hw_mutex);
#line 322
  tmp___0 = dev_priv->goal_queue_waiters;
#line 322
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters + 1;
#line 322
  if (tmp___0 == 0) {
#line 325
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 325
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 326
    outl(4U, (int )(dev_priv->io_start + 8U));
#line 328
    dev_priv->irq_mask = dev_priv->irq_mask | 4U;
#line 329
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 330
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 332
  ldv_mutex_unlock_394(& dev_priv->hw_mutex);
#line 333
  return;
}
}
#line 335 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 337
  ldv_mutex_lock_395(& dev_priv->hw_mutex);
#line 338
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters - 1;
#line 338
  if (dev_priv->goal_queue_waiters == 0) {
#line 341
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 341
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 342
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967291U;
#line 343
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 344
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 346
  ldv_mutex_unlock_396(& dev_priv->hw_mutex);
#line 347
  return;
}
}
#line 349 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) 
{ 
  long ret ;
  struct vmw_fifo_state *fifo ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 354
  fifo = & dev_priv->fifo;
#line 356
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 356
  if (tmp != 0L) {
#line 357
    return (0);
  } else {

  }
#line 359
  tmp___0 = vmw_seqno_passed(dev_priv, seqno);
#line 359
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 359
  if (tmp___1 != 0L) {
#line 360
    return (0);
  } else {

  }
#line 362
  vmw_fifo_ping_host(dev_priv, 1U);
#line 364
  if ((fifo->capabilities & 1U) == 0U) {
#line 365
    tmp___2 = vmw_fallback_wait(dev_priv, (int )lazy, 1, seqno, (int )interruptible,
                                timeout);
#line 365
    return (tmp___2);
  } else {

  }
#line 368
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 369
    tmp___3 = vmw_fallback_wait(dev_priv, (int )lazy, 0, seqno, (int )interruptible,
                                timeout);
#line 369
    return (tmp___3);
  } else {

  }
#line 372
  vmw_seqno_waiter_add(dev_priv);
#line 374
  if ((int )interruptible) {
#line 375
    __ret = (long )timeout;
#line 375
    tmp___8 = vmw_seqno_passed(dev_priv, seqno);
#line 375
    if (tmp___8) {
#line 375
      tmp___9 = 0;
    } else {
#line 375
      tmp___9 = 1;
    }
#line 375
    if (tmp___9) {
#line 375
      tmp___4 = get_current();
#line 375
      __wait.flags = 0U;
#line 375
      __wait.private = (void *)tmp___4;
#line 375
      __wait.func = & autoremove_wake_function;
#line 375
      __wait.task_list.next = & __wait.task_list;
#line 375
      __wait.task_list.prev = & __wait.task_list;
      ldv_40633: 
#line 375
      prepare_to_wait(& dev_priv->fence_queue, & __wait, 1);
#line 375
      tmp___5 = vmw_seqno_passed(dev_priv, seqno);
#line 375
      if ((int )tmp___5) {
#line 375
        goto ldv_40631;
      } else {

      }
#line 375
      tmp___6 = get_current();
#line 375
      tmp___7 = signal_pending(tmp___6);
#line 375
      if (tmp___7 == 0) {
#line 375
        __ret = schedule_timeout(__ret);
#line 375
        if (__ret == 0L) {
#line 375
          goto ldv_40631;
        } else {

        }
#line 375
        goto ldv_40632;
      } else {

      }
#line 375
      __ret = -512L;
#line 375
      goto ldv_40631;
      ldv_40632: ;
#line 375
      goto ldv_40633;
      ldv_40631: 
#line 375
      finish_wait(& dev_priv->fence_queue, & __wait);
    } else {

    }
#line 375
    ret = __ret;
  } else {
#line 380
    __ret___0 = (long )timeout;
#line 380
    tmp___12 = vmw_seqno_passed(dev_priv, seqno);
#line 380
    if (tmp___12) {
#line 380
      tmp___13 = 0;
    } else {
#line 380
      tmp___13 = 1;
    }
#line 380
    if (tmp___13) {
#line 380
      tmp___10 = get_current();
#line 380
      __wait___0.flags = 0U;
#line 380
      __wait___0.private = (void *)tmp___10;
#line 380
      __wait___0.func = & autoremove_wake_function;
#line 380
      __wait___0.task_list.next = & __wait___0.task_list;
#line 380
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40638: 
#line 380
      prepare_to_wait(& dev_priv->fence_queue, & __wait___0, 2);
#line 380
      tmp___11 = vmw_seqno_passed(dev_priv, seqno);
#line 380
      if ((int )tmp___11) {
#line 380
        goto ldv_40637;
      } else {

      }
#line 380
      __ret___0 = schedule_timeout(__ret___0);
#line 380
      if (__ret___0 == 0L) {
#line 380
        goto ldv_40637;
      } else {

      }
#line 380
      goto ldv_40638;
      ldv_40637: 
#line 380
      finish_wait(& dev_priv->fence_queue, & __wait___0);
    } else {

    }
#line 380
    ret = __ret___0;
  }
#line 385
  vmw_seqno_waiter_remove(dev_priv);
#line 387
  tmp___15 = ldv__builtin_expect(ret == 0L, 0L);
#line 387
  if (tmp___15 != 0L) {
#line 388
    ret = -16L;
  } else {
#line 389
    tmp___14 = ldv__builtin_expect(ret > 0L, 1L);
#line 389
    if (tmp___14 != 0L) {
#line 390
      ret = 0L;
    } else {

    }
  }
#line 392
  return ((int )ret);
}
}
#line 395 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_preinstall(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  struct lock_class_key __key ;

  {
#line 397
  tmp = vmw_priv(dev);
#line 397
  dev_priv = tmp;
#line 400
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 401
    return;
  } else {

  }
#line 403
  spinlock_check(& dev_priv->irq_lock);
#line 403
  __raw_spin_lock_init(& dev_priv->irq_lock.ldv_5961.rlock, "&(&dev_priv->irq_lock)->rlock",
                       & __key);
#line 404
  status = inl((int )(dev_priv->io_start + 8U));
#line 405
  outl(status, (int )(dev_priv->io_start + 8U));
#line 406
  return;
}
}
#line 408 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_irq_postinstall(struct drm_device *dev ) 
{ 


  {
#line 410
  return (0);
}
}
#line 413 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_uninstall(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;

  {
#line 415
  tmp = vmw_priv(dev);
#line 415
  dev_priv = tmp;
#line 418
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 419
    return;
  } else {

  }
#line 421
  ldv_mutex_lock_397(& dev_priv->hw_mutex);
#line 422
  vmw_write(dev_priv, 33U, 0U);
#line 423
  ldv_mutex_unlock_398(& dev_priv->hw_mutex);
#line 425
  status = inl((int )(dev_priv->io_start + 8U));
#line 426
  outl(status, (int )(dev_priv->io_start + 8U));
#line 427
  return;
}
}
#line 429 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_373(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 434
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 436
  mutex_lock(ldv_func_arg1);
#line 437
  return;
}
}
#line 439 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_374(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 444
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 446
  mutex_unlock(ldv_func_arg1);
#line 447
  return;
}
}
#line 449 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_375(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 454
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 456
  mutex_lock(ldv_func_arg1);
#line 457
  return;
}
}
#line 459 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int ldv_mutex_trylock_376(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 464
  tmp = mutex_trylock(ldv_func_arg1);
#line 464
  ldv_func_res = tmp;
#line 466
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 466
  return (tmp___0);
#line 468
  return (ldv_func_res);
}
}
#line 471 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_377(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 476
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 478
  mutex_unlock(ldv_func_arg1);
#line 479
  return;
}
}
#line 481 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_378(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 486
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 488
  mutex_lock(ldv_func_arg1);
#line 489
  return;
}
}
#line 491 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_379(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 498
  mutex_unlock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_380(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 506
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 508
  mutex_lock(ldv_func_arg1);
#line 509
  return;
}
}
#line 511 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 516
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 518
  mutex_unlock(ldv_func_arg1);
#line 519
  return;
}
}
#line 521 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_382(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 536
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 538
  mutex_lock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_384(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 546
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 548
  mutex_unlock(ldv_func_arg1);
#line 549
  return;
}
}
#line 551 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_385(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 556
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 558
  mutex_lock(ldv_func_arg1);
#line 559
  return;
}
}
#line 561 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 568
  mutex_unlock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 578
  mutex_lock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 586
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 588
  mutex_unlock(ldv_func_arg1);
#line 589
  return;
}
}
#line 591 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_389(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 596
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 598
  mutex_lock(ldv_func_arg1);
#line 599
  return;
}
}
#line 601 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 606
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 608
  mutex_unlock(ldv_func_arg1);
#line 609
  return;
}
}
#line 611 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 616
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 618
  mutex_lock(ldv_func_arg1);
#line 619
  return;
}
}
#line 621 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 626
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 628
  mutex_unlock(ldv_func_arg1);
#line 629
  return;
}
}
#line 631 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 638
  mutex_lock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 646
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 648
  mutex_unlock(ldv_func_arg1);
#line 649
  return;
}
}
#line 651 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_395(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 656
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 658
  mutex_lock(ldv_func_arg1);
#line 659
  return;
}
}
#line 661 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 666
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 668
  mutex_unlock(ldv_func_arg1);
#line 669
  return;
}
}
#line 671 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 676
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 678
  mutex_lock(ldv_func_arg1);
#line 679
  return;
}
}
#line 681 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 686
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 688
  mutex_unlock(ldv_func_arg1);
#line 689
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_437(struct mutex *ldv_func_arg1 ) ;
#line 845 "include/drm/drm_crtc.h"
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
#line 850
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
#line 859
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
#line 944
extern void drm_object_attach_property(struct drm_mode_object * , struct drm_property * ,
                                       uint64_t  ) ;
#line 968
extern int drm_mode_create_dirty_info_property(struct drm_device * ) ;
#line 971
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
#line 975
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
#line 1427 "include/drm/drmP.h"
extern int drm_vblank_init(struct drm_device * , int  ) ;
#line 1440
extern void drm_vblank_cleanup(struct drm_device * ) ;
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu ) 
{ 


  {
#line 162
  list_del_init(& ldu->active);
#line 163
  vmw_display_unit_cleanup(& ldu->base);
#line 164
  kfree((void const   *)ldu);
#line 165
  return;
}
}
#line 172 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc  const  *__mptr ;

  {
#line 174
  __mptr = (struct drm_crtc  const  *)crtc;
#line 174
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr);
#line 176
  return;
}
}
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_commit_list(struct vmw_private *dev_priv ) 
{ 
  struct vmw_legacy_display *lds ;
  struct vmw_legacy_display_unit *entry ;
  struct vmw_display_unit *du ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int i ;
  int ret ;
  int w ;
  int h ;
  struct list_head  const  *__mptr ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  long tmp___1 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;

  {
#line 179
  lds = dev_priv->ldu_priv;
#line 181
  du = 0;
#line 182
  fb = 0;
#line 183
  crtc = 0;
#line 184
  i = 0;
#line 189
  if ((dev_priv->capabilities & 524288U) == 0U) {
#line 190
    w = 0;
#line 190
    h = 0;
#line 191
    __mptr = (struct list_head  const  *)lds->active.next;
#line 191
    entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c8UL;
#line 191
    goto ldv_40763;
    ldv_40762: 
#line 192
    crtc = & entry->base.crtc;
#line 193
    _max1 = w;
#line 193
    _max2 = crtc->x + crtc->mode.hdisplay;
#line 193
    w = _max1 > _max2 ? _max1 : _max2;
#line 194
    _max1___0 = h;
#line 194
    _max2___0 = crtc->y + crtc->mode.vdisplay;
#line 194
    h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 195
    i = i + 1;
#line 191
    __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 191
    entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c8UL;
    ldv_40763: ;
#line 191
    if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 192
      goto ldv_40762;
    } else {

    }

#line 198
    if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 199
      return (0);
    } else {

    }
#line 200
    fb = entry->base.crtc.fb;
#line 202
    tmp = vmw_kms_write_svga(dev_priv, (unsigned int )w, (unsigned int )h, fb->pitches[0],
                             (unsigned int )fb->bits_per_pixel, fb->depth);
#line 202
    return (tmp);
  } else {

  }
#line 206
  tmp___0 = list_empty((struct list_head  const  *)(& lds->active));
#line 206
  if (tmp___0 == 0) {
#line 207
    __mptr___1 = (struct list_head  const  *)lds->active.next;
#line 207
    entry = (struct vmw_legacy_display_unit *)__mptr___1 + 0xfffffffffffff4c8UL;
#line 208
    fb = entry->base.crtc.fb;
#line 210
    vmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitches[0], (unsigned int )fb->bits_per_pixel,
                       fb->depth);
  } else {

  }
#line 215
  vmw_write(dev_priv, 34U, lds->num_active != 0U ? lds->num_active : 1U);
#line 218
  i = 0;
#line 219
  __mptr___2 = (struct list_head  const  *)lds->active.next;
#line 219
  entry = (struct vmw_legacy_display_unit *)__mptr___2 + 0xfffffffffffff4c8UL;
#line 219
  goto ldv_40772;
  ldv_40771: 
#line 220
  crtc = & entry->base.crtc;
#line 222
  vmw_write(dev_priv, 35U, (uint32_t )i);
#line 223
  vmw_write(dev_priv, 36U, i == 0);
#line 224
  vmw_write(dev_priv, 37U, (uint32_t )crtc->x);
#line 225
  vmw_write(dev_priv, 38U, (uint32_t )crtc->y);
#line 226
  vmw_write(dev_priv, 39U, (uint32_t )crtc->mode.hdisplay);
#line 227
  vmw_write(dev_priv, 40U, (uint32_t )crtc->mode.vdisplay);
#line 228
  vmw_write(dev_priv, 35U, 4294967295U);
#line 230
  i = i + 1;
#line 219
  __mptr___3 = (struct list_head  const  *)entry->active.next;
#line 219
  entry = (struct vmw_legacy_display_unit *)__mptr___3 + 0xfffffffffffff4c8UL;
  ldv_40772: ;
#line 219
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 220
    goto ldv_40771;
  } else {

  }
#line 233
  tmp___1 = ldv__builtin_expect((unsigned int )i != lds->num_active, 0L);
#line 233
  if (tmp___1 != 0L) {
#line 233
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (233), "i" (12UL));
    ldv_40774: ;
#line 233
    goto ldv_40774;
  } else {

  }
#line 235
  lds->last_num_active = lds->num_active;
#line 239
  __mptr___4 = (struct list_head  const  *)lds->active.next;
#line 239
  entry = (struct vmw_legacy_display_unit *)__mptr___4 + 0xfffffffffffff4c8UL;
#line 239
  goto ldv_40783;
  ldv_40782: 
#line 240
  du = & entry->base;
#line 242
  if ((unsigned long )du->cursor_dmabuf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 243
    goto ldv_40779;
  } else {

  }
#line 245
  ret = vmw_cursor_update_dmabuf(dev_priv, du->cursor_dmabuf, 64U, 64U, (u32 )du->hotspot_x,
                                 (u32 )du->hotspot_y);
#line 250
  if (ret == 0) {
#line 251
    goto ldv_40780;
  } else {

  }
#line 253
  drm_err("vmw_ldu_commit_list", "Could not update cursor image\n");
  ldv_40779: 
#line 239
  __mptr___5 = (struct list_head  const  *)entry->active.next;
#line 239
  entry = (struct vmw_legacy_display_unit *)__mptr___5 + 0xfffffffffffff4c8UL;
  ldv_40783: ;
#line 239
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 240
    goto ldv_40782;
  } else {

  }
  ldv_40780: ;
#line 256
  return (0);
}
}
#line 259 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_del_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ) 
{ 
  struct vmw_legacy_display *ld ;
  int tmp ;
  long tmp___0 ;

  {
#line 262
  ld = vmw_priv___0->ldu_priv;
#line 263
  tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 263
  if (tmp != 0) {
#line 264
    return (0);
  } else {

  }
#line 267
  list_del_init(& ldu->active);
#line 268
  ld->num_active = ld->num_active - 1U;
#line 268
  if (ld->num_active == 0U) {
#line 269
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb == (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 269
    if (tmp___0 != 0L) {
#line 269
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (269), "i" (12UL));
      ldv_40789: ;
#line 269
      goto ldv_40789;
    } else {

    }
#line 270
    if ((unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 271
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 272
    ld->fb = 0;
  } else {

  }
#line 275
  return (0);
}
}
#line 278 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_add_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ,
                              struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_legacy_display *ld ;
  struct vmw_legacy_display_unit *entry ;
  struct list_head *at ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 282
  ld = vmw_priv___0->ldu_priv;
#line 286
  tmp = ldv__builtin_expect(ld->num_active == 0U, 0L);
#line 286
  if (tmp != 0L) {
#line 286
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 286
    if (tmp___0 != 0L) {
#line 286
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (286), "i" (12UL));
      ldv_40798: ;
#line 286
      goto ldv_40798;
    } else {

    }
  } else {

  }
#line 287
  if ((unsigned long )ld->fb != (unsigned long )vfb) {
#line 288
    if ((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 289
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 290
    if ((unsigned long )vfb->pin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 291
      (*(vfb->pin))(vfb);
    } else {

    }
#line 292
    ld->fb = vfb;
  } else {

  }
#line 295
  tmp___1 = list_empty((struct list_head  const  *)(& ldu->active));
#line 295
  if (tmp___1 == 0) {
#line 296
    return (0);
  } else {

  }
#line 298
  at = & ld->active;
#line 299
  __mptr = (struct list_head  const  *)ld->active.next;
#line 299
  entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c8UL;
#line 299
  goto ldv_40805;
  ldv_40804: ;
#line 300
  if (entry->base.unit > ldu->base.unit) {
#line 301
    goto ldv_40803;
  } else {

  }
#line 303
  at = & entry->active;
#line 299
  __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 299
  entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c8UL;
  ldv_40805: ;
#line 299
  if ((unsigned long )(& entry->active) != (unsigned long )(& ld->active)) {
#line 300
    goto ldv_40804;
  } else {

  }
  ldv_40803: 
#line 306
  list_add(& ldu->active, at);
#line 308
  ld->num_active = ld->num_active + 1U;
#line 310
  return (0);
}
}
#line 313 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_legacy_display_unit *ldu ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 324
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 325
    return (-22);
  } else {

  }
#line 327
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 328
    return (-22);
  } else {

  }
#line 331
  crtc = set->crtc;
#line 332
  __mptr = (struct drm_crtc  const  *)crtc;
#line 332
  ldu = (struct vmw_legacy_display_unit *)__mptr;
#line 333
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 333
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 333
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 333
    vfb = 0;
  }
#line 334
  dev_priv = vmw_priv(crtc->dev);
#line 336
  if (set->num_connectors > 1UL) {
#line 337
    drm_err("vmw_ldu_crtc_set_config", "to many connectors\n");
#line 338
    return (-22);
  } else {

  }
#line 341
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& ldu->base.connector)) {
#line 343
    drm_err("vmw_ldu_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & ldu->base.connector);
#line 345
    return (-22);
  } else {

  }
#line 349
  if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) {
#line 349
    if ((dev_priv->ldu_priv)->num_active != 1U) {
#line 349
      goto _L;
    } else {
#line 349
      tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 349
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 349
        if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )vfb) {
#line 353
          drm_err("vmw_ldu_crtc_set_config", "Multiple framebuffers not supported\n");
#line 354
          return (-22);
        } else {

        }
      } else {

      }
    }
  } else {

  }
#line 358
  connector = & ldu->base.connector;
#line 359
  encoder = & ldu->base.encoder;
#line 362
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 364
    connector->encoder = 0;
#line 365
    encoder->crtc = 0;
#line 366
    crtc->fb = 0;
#line 368
    vmw_ldu_del_active(dev_priv, ldu);
#line 370
    tmp___0 = vmw_ldu_commit_list(dev_priv);
#line 370
    return (tmp___0);
  } else {

  }
#line 375
  mode = set->mode;
#line 376
  fb = set->fb;
#line 378
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 380
    drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
#line 381
    return (-22);
  } else {

  }
#line 384
  vmw_fb_off(dev_priv);
#line 386
  crtc->fb = fb;
#line 387
  encoder->crtc = crtc;
#line 388
  connector->encoder = encoder;
#line 389
  crtc->x = (int )set->x;
#line 390
  crtc->y = (int )set->y;
#line 391
  crtc->mode = *mode;
#line 393
  vmw_ldu_add_active(dev_priv, ldu, vfb);
#line 395
  tmp___1 = vmw_ldu_commit_list(dev_priv);
#line 395
  return (tmp___1);
}
}
#line 398 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_crtc_funcs vmw_legacy_crtc_funcs  = 
#line 398
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_ldu_crtc_destroy, & vmw_ldu_crtc_set_config, 0,
    0};
#line 413 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 415
  __mptr = (struct drm_encoder  const  *)encoder;
#line 415
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffca8UL);
#line 417
  return;
}
}
#line 418 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_encoder_funcs vmw_legacy_encoder_funcs  =    {0, & vmw_ldu_encoder_destroy};
#line 426 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_connector_destroy(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 428
  __mptr = (struct drm_connector  const  *)connector;
#line 428
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffc58UL);
#line 430
  return;
}
}
#line 431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs  = 
#line 431
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_ldu_connector_destroy, 0};
#line 441 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ 
  struct vmw_legacy_display_unit *ldu ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 444
  dev = dev_priv->dev;
#line 449
  tmp = kzalloc(2888UL, 208U);
#line 449
  ldu = (struct vmw_legacy_display_unit *)tmp;
#line 450
  if ((unsigned long )ldu == (unsigned long )((struct vmw_legacy_display_unit *)0)) {
#line 451
    return (-12);
  } else {

  }
#line 453
  ldu->base.unit = unit;
#line 454
  crtc = & ldu->base.crtc;
#line 455
  encoder = & ldu->base.encoder;
#line 456
  connector = & ldu->base.connector;
#line 458
  INIT_LIST_HEAD(& ldu->active);
#line 460
  ldu->base.pref_active = unit == 0U;
#line 461
  ldu->base.pref_width = dev_priv->initial_width;
#line 462
  ldu->base.pref_height = dev_priv->initial_height;
#line 463
  ldu->base.pref_mode = 0;
#line 464
  ldu->base.is_implicit = 1;
#line 466
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs),
                     15);
#line 468
  connector->status = vmw_du_connector_detect(connector, 1);
#line 470
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_legacy_encoder_funcs),
                   5);
#line 472
  drm_mode_connector_attach_encoder(connector, encoder);
#line 473
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 474
  encoder->possible_clones = 0U;
#line 476
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_legacy_crtc_funcs));
#line 478
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 480
  drm_object_attach_property(& connector->base, dev->mode_config.dirty_info_property,
                             1ULL);
#line 484
  return (0);
}
}
#line 487 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;

  {
#line 489
  dev = dev_priv->dev;
#line 492
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 493
    printk("\016[drm] ldu system already on\n");
#line 494
    return (-22);
  } else {

  }
#line 497
  tmp = kmalloc(32UL, 208U);
#line 497
  dev_priv->ldu_priv = (struct vmw_legacy_display *)tmp;
#line 498
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 499
    return (-12);
  } else {

  }
#line 501
  INIT_LIST_HEAD(& (dev_priv->ldu_priv)->active);
#line 502
  (dev_priv->ldu_priv)->num_active = 0U;
#line 503
  (dev_priv->ldu_priv)->last_num_active = 0U;
#line 504
  (dev_priv->ldu_priv)->fb = 0;
#line 507
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 508
    ret = drm_vblank_init(dev, 8);
  } else {
#line 510
    ret = drm_vblank_init(dev, 1);
  }
#line 511
  if (ret != 0) {
#line 512
    goto err_free;
  } else {

  }
#line 514
  ret = drm_mode_create_dirty_info_property(dev);
#line 515
  if (ret != 0) {
#line 516
    goto err_vblank_cleanup;
  } else {

  }
#line 518
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 519
    i = 0;
#line 519
    goto ldv_40853;
    ldv_40852: 
#line 520
    vmw_ldu_init(dev_priv, (unsigned int )i);
#line 519
    i = i + 1;
    ldv_40853: ;
#line 519
    if (i <= 7) {
#line 520
      goto ldv_40852;
    } else {

    }

  } else {
#line 522
    vmw_ldu_init(dev_priv, 0U);
  }
#line 524
  return (0);
  err_vblank_cleanup: 
#line 527
  drm_vblank_cleanup(dev);
  err_free: 
#line 529
  kfree((void const   *)dev_priv->ldu_priv);
#line 530
  dev_priv->ldu_priv = 0;
#line 531
  return (ret);
}
}
#line 534 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int tmp ;
  long tmp___0 ;

  {
#line 536
  dev = dev_priv->dev;
#line 538
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 539
    return (-38);
  } else {

  }
#line 541
  drm_vblank_cleanup(dev);
#line 543
  tmp = list_empty((struct list_head  const  *)(& (dev_priv->ldu_priv)->active));
#line 543
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 543
  if (tmp___0 != 0L) {
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (543), "i" (12UL));
    ldv_40859: ;
#line 543
    goto ldv_40859;
  } else {

  }
#line 545
  kfree((void const   *)dev_priv->ldu_priv);
#line 547
  return (0);
}
}
#line 587 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_main10_sequence_infinite_withcheck_stateful(void) 
{ 
  struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp ;
  int tmp___0 ;

  {
#line 649
  LDV_IN_INTERRUPT = 1;
#line 658
  ldv_initialize();
#line 666
  goto ldv_40887;
  ldv_40886: 
#line 669
  tmp = __VERIFIER_nondet_int();
#line 669
  switch (tmp) {
  case 0: 
#line 686
  ldv_handler_precall();
#line 687
  vmw_ldu_crtc_destroy(var_group1);
#line 694
  goto ldv_40881;
  case 1: 
#line 710
  ldv_handler_precall();
#line 711
  vmw_ldu_crtc_set_config(var_group2);
#line 718
  goto ldv_40881;
  case 2: 
#line 734
  ldv_handler_precall();
#line 735
  vmw_ldu_encoder_destroy(var_group3);
#line 742
  goto ldv_40881;
  case 3: 
#line 758
  ldv_handler_precall();
#line 759
  vmw_ldu_connector_destroy(var_group4);
#line 766
  goto ldv_40881;
  default: ;
#line 767
  goto ldv_40881;
  }
  ldv_40881: ;
  ldv_40887: 
#line 666
  tmp___0 = __VERIFIER_nondet_int();
#line 666
  if (tmp___0 != 0) {
#line 667
    goto ldv_40886;
  } else {

  }


#line 776
  ldv_check_final_state();
#line 779
  return;
}
}
#line 783 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 788
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 790
  mutex_lock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 798
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 800
  mutex_unlock(ldv_func_arg1);
#line 801
  return;
}
}
#line 803 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 808
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 810
  mutex_lock(ldv_func_arg1);
#line 811
  return;
}
}
#line 813 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 818
  tmp = mutex_trylock(ldv_func_arg1);
#line 818
  ldv_func_res = tmp;
#line 820
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 820
  return (tmp___0);
#line 822
  return (ldv_func_res);
}
}
#line 825 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 830
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 832
  mutex_unlock(ldv_func_arg1);
#line 833
  return;
}
}
#line 835 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 842
  mutex_lock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 850
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 852
  mutex_unlock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 860
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 862
  mutex_lock(ldv_func_arg1);
#line 863
  return;
}
}
#line 865 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 870
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 872
  mutex_unlock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 880
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 882
  mutex_unlock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 890
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 892
  mutex_lock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 900
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 902
  mutex_unlock(ldv_func_arg1);
#line 903
  return;
}
}
#line 905 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_437(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 910
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 912
  mutex_lock(ldv_func_arg1);
#line 913
  return;
}
}
#line 915 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 920
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 922
  mutex_unlock(ldv_func_arg1);
#line 923
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_456(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_459(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_466(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_460(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_465(struct mutex *ldv_func_arg1 ) ;
#line 50 "include/drm/drm_global.h"
extern int drm_global_item_ref(struct drm_global_reference * ) ;
#line 51
extern void drm_global_item_unref(struct drm_global_reference * ) ;
#line 698 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_mmap(struct file * , struct vm_area_struct * , struct ttm_bo_device * ) ;
#line 146 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_init(struct ttm_mem_global * ) ;
#line 147
extern void ttm_mem_global_release(struct ttm_mem_global * ) ;
#line 728 "include/drm/ttm/ttm_bo_driver.h"
extern void ttm_bo_global_release(struct drm_global_reference * ) ;
#line 729
extern int ttm_bo_global_init(struct drm_global_reference * ) ;
#line 134 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  long tmp ;
  int tmp___0 ;

  {
#line 139
  tmp = ldv__builtin_expect(vma->vm_pgoff <= 1048575UL, 0L);
#line 139
  if (tmp != 0L) {
#line 140
    drm_err("vmw_mmap", "Illegal attempt to mmap old fifo space.\n");
#line 141
    return (-22);
  } else {

  }
#line 144
  file_priv = (struct drm_file *)filp->private_data;
#line 145
  dev_priv = vmw_priv((file_priv->minor)->dev);
#line 146
  tmp___0 = ttm_bo_mmap(filp, vma, & dev_priv->bdev);
#line 146
  return (tmp___0);
}
}
#line 149 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static int vmw_ttm_mem_global_init(struct drm_global_reference *ref ) 
{ 
  int tmp ;

  {
#line 151
  printk("\016[drm] global init.\n");
#line 152
  tmp = ttm_mem_global_init((struct ttm_mem_global *)ref->object);
#line 152
  return (tmp);
}
}
#line 155 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static void vmw_ttm_mem_global_release(struct drm_global_reference *ref ) 
{ 


  {
#line 157
  ttm_mem_global_release((struct ttm_mem_global *)ref->object);
#line 158
  return;
}
}
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_ttm_global_init(struct vmw_private *dev_priv ) 
{ 
  struct drm_global_reference *global_ref ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 165
  global_ref = & dev_priv->mem_global_ref;
#line 166
  global_ref->global_type = 0;
#line 167
  global_ref->size = 272UL;
#line 168
  global_ref->init = & vmw_ttm_mem_global_init;
#line 169
  global_ref->release = & vmw_ttm_mem_global_release;
#line 171
  ret = drm_global_item_ref(global_ref);
#line 172
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 172
  if (tmp != 0L) {
#line 173
    drm_err("vmw_ttm_global_init", "Failed setting up TTM memory accounting.\n");
#line 174
    return (ret);
  } else {

  }
#line 177
  dev_priv->bo_global_ref.mem_glob = (struct ttm_mem_global *)dev_priv->mem_global_ref.object;
#line 179
  global_ref = & dev_priv->bo_global_ref.ref;
#line 180
  global_ref->global_type = 1;
#line 181
  global_ref->size = 368UL;
#line 182
  global_ref->init = & ttm_bo_global_init;
#line 183
  global_ref->release = & ttm_bo_global_release;
#line 184
  ret = drm_global_item_ref(global_ref);
#line 186
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 186
  if (tmp___0 != 0L) {
#line 187
    drm_err("vmw_ttm_global_init", "Failed setting up TTM buffer objects.\n");
#line 188
    goto out_no_bo;
  } else {

  }
#line 191
  return (0);
  out_no_bo: 
#line 193
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 194
  return (ret);
}
}
#line 197 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void vmw_ttm_global_release(struct vmw_private *dev_priv ) 
{ 


  {
#line 199
  drm_global_item_unref(& dev_priv->bo_global_ref.ref);
#line 200
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 201
  return;
}
}
#line 203 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 208
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 210
  mutex_lock(ldv_func_arg1);
#line 211
  return;
}
}
#line 213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 218
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 220
  mutex_unlock(ldv_func_arg1);
#line 221
  return;
}
}
#line 223 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 228
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 230
  mutex_lock(ldv_func_arg1);
#line 231
  return;
}
}
#line 233 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int ldv_mutex_trylock_456(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 238
  tmp = mutex_trylock(ldv_func_arg1);
#line 238
  ldv_func_res = tmp;
#line 240
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 240
  return (tmp___0);
#line 242
  return (ldv_func_res);
}
}
#line 245 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 250
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 252
  mutex_unlock(ldv_func_arg1);
#line 253
  return;
}
}
#line 255 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 260
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 262
  mutex_lock(ldv_func_arg1);
#line 263
  return;
}
}
#line 265 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_459(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 270
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 272
  mutex_unlock(ldv_func_arg1);
#line 273
  return;
}
}
#line 275 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_460(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 280
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 282
  mutex_lock(ldv_func_arg1);
#line 283
  return;
}
}
#line 285 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 290
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 292
  mutex_unlock(ldv_func_arg1);
#line 293
  return;
}
}
#line 295 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 300
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 302
  mutex_unlock(ldv_func_arg1);
#line 303
  return;
}
}
#line 305 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 310
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 312
  mutex_lock(ldv_func_arg1);
#line 313
  return;
}
}
#line 315 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 320
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 322
  mutex_unlock(ldv_func_arg1);
#line 323
  return;
}
}
#line 325 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_465(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 330
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 332
  mutex_lock(ldv_func_arg1);
#line 333
  return;
}
}
#line 335 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_466(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 340
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 342
  mutex_unlock(ldv_func_arg1);
#line 343
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_502(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_504(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_501(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_503(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) ;
#line 499 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) ;
#line 502
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) ;
#line 511
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) ;
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_escape(struct vmw_escape_header *header , uint32_t size ) 
{ 


  {
#line 180
  header->cmd = 33U;
#line 181
  header->body.nsid = 0U;
#line 182
  header->body.size = size;
#line 183
  return;
}
}
#line 185 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id ) 
{ 


  {
#line 188
  fill_escape(& cmd->escape, 8U);
#line 189
  cmd->flush.cmdType = 131074U;
#line 190
  cmd->flush.streamId = stream_id;
#line 191
  return;
}
}
#line 199 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_put(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ 
  struct vmw_escape_video_flush *flush ;
  size_t fifo_size ;
  bool have_so ;
  int i ;
  int num_items ;
  SVGAGuestPtr ptr ;
  struct __anonstruct_cmds_303 *cmds ;
  struct __anonstruct_items_306 *items ;
  void *tmp ;

  {
#line 206
  have_so = (unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0);
#line 223
  if ((int )have_so) {
#line 224
    num_items = 21;
  } else {
#line 226
    num_items = 19;
  }
#line 228
  fifo_size = ((unsigned long )num_items + 5UL) * 8UL;
#line 230
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 230
  cmds = (struct __anonstruct_309___0 *)tmp;
#line 232
  if ((unsigned long )cmds == (unsigned long )((struct __anonstruct_cmds_303 *)0)) {
#line 233
    return (-12);
  } else {

  }
#line 235
  items = (struct __anonstruct_312 *)cmds + 1U;
#line 236
  flush = (struct vmw_escape_video_flush *)items + (unsigned long )num_items;
#line 239
  fill_escape(& cmds->escape, (uint32_t )((unsigned long )(num_items + 1)) * 8U);
#line 241
  cmds->header.cmdType = 131073U;
#line 242
  cmds->header.streamId = arg->stream_id;
#line 245
  i = 0;
#line 245
  goto ldv_40664;
  ldv_40663: 
#line 246
  (items + (unsigned long )i)->registerId = (uint32_t )i;
#line 245
  i = i + 1;
  ldv_40664: ;
#line 245
  if (i < num_items) {
#line 246
    goto ldv_40663;
  } else {

  }
#line 248
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& buf->base), & ptr);
#line 249
  ptr.offset = ptr.offset + arg->offset;
#line 251
  items->value = 1U;
#line 252
  (items + 1UL)->value = arg->flags;
#line 253
  (items + 2UL)->value = ptr.offset;
#line 254
  (items + 3UL)->value = (uint32_t )arg->format;
#line 255
  (items + 4UL)->value = arg->color_key;
#line 256
  (items + 5UL)->value = arg->size;
#line 257
  (items + 6UL)->value = arg->width;
#line 258
  (items + 7UL)->value = arg->height;
#line 259
  (items + 8UL)->value = (uint32_t )arg->src.x;
#line 260
  (items + 9UL)->value = (uint32_t )arg->src.y;
#line 261
  (items + 10UL)->value = arg->src.w;
#line 262
  (items + 11UL)->value = arg->src.h;
#line 263
  (items + 12UL)->value = (uint32_t )arg->dst.x;
#line 264
  (items + 13UL)->value = (uint32_t )arg->dst.y;
#line 265
  (items + 14UL)->value = arg->dst.w;
#line 266
  (items + 15UL)->value = arg->dst.h;
#line 267
  (items + 16UL)->value = arg->pitch[0];
#line 268
  (items + 17UL)->value = arg->pitch[1];
#line 269
  (items + 18UL)->value = arg->pitch[2];
#line 270
  if ((int )have_so) {
#line 271
    (items + 19UL)->value = ptr.gmrId;
#line 272
    (items + 20UL)->value = 4294967295U;
  } else {

  }
#line 275
  fill_flush(flush, arg->stream_id);
#line 277
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 279
  return (0);
}
}
#line 288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_stop(struct vmw_private *dev_priv , uint32_t stream_id ,
                                 bool interruptible ) 
{ 
  struct __anonstruct_cmds_314 *cmds ;
  int ret ;
  void *tmp ;
  long tmp___0 ;

  {
  ldv_40679: 
#line 300
  tmp = vmw_fifo_reserve(dev_priv, 48U);
#line 300
  cmds = (struct __anonstruct_316 *)tmp;
#line 301
  if ((unsigned long )cmds != (unsigned long )((struct __anonstruct_cmds_314 *)0)) {
#line 302
    goto ldv_40677;
  } else {

  }
#line 304
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, (int )interruptible, 750UL);
#line 306
  if ((int )interruptible && ret == -512) {
#line 307
    return (ret);
  } else {
#line 309
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 309
    if (tmp___0 != 0L) {
#line 309
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (309), "i" (12UL));
      ldv_40678: ;
#line 309
      goto ldv_40678;
    } else {

    }
  }
#line 310
  goto ldv_40679;
  ldv_40677: 
#line 312
  fill_escape(& cmds->escape, 16U);
#line 313
  cmds->body.header.cmdType = 131073U;
#line 314
  cmds->body.header.streamId = stream_id;
#line 315
  cmds->body.items[0].registerId = 0U;
#line 316
  cmds->body.items[0].value = 0U;
#line 317
  fill_flush(& cmds->flush, stream_id);
#line 319
  vmw_fifo_commit(dev_priv, 48U);
#line 321
  return (0);
}
}
#line 330 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_move_buffer(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                   bool pin , bool inter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 334
  if (! pin) {
#line 335
    tmp = vmw_dmabuf_unpin(dev_priv, buf, (int )inter);
#line 335
    return (tmp);
  } else {

  }
#line 337
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 338
    tmp___0 = vmw_dmabuf_to_vram(dev_priv, buf, 1, (int )inter);
#line 338
    return (tmp___0);
  } else {

  }
#line 340
  tmp___1 = vmw_dmabuf_to_vram_or_gmr(dev_priv, buf, 1, (int )inter);
#line 340
  return (tmp___1);
}
}
#line 355 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_stop(struct vmw_private *dev_priv , uint32_t stream_id , bool pause ,
                            bool interruptible ) 
{ 
  struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp ;

  {
#line 359
  overlay = dev_priv->overlay_priv;
#line 360
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )stream_id;
#line 364
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 365
    return (0);
  } else {

  }
#line 368
  if (! stream->paused) {
#line 369
    ret = vmw_overlay_send_stop(dev_priv, stream_id, (int )interruptible);
#line 371
    if (ret != 0) {
#line 372
      return (ret);
    } else {

    }
#line 375
    ret = vmw_overlay_move_buffer(dev_priv, stream->buf, 0, (int )interruptible);
#line 377
    if ((int )interruptible && ret == -512) {
#line 378
      return (ret);
    } else {
#line 380
      tmp = ldv__builtin_expect(ret != 0, 0L);
#line 380
      if (tmp != 0L) {
#line 380
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (380), "i" (12UL));
        ldv_40695: ;
#line 380
        goto ldv_40695;
      } else {

      }
    }
  } else {

  }
#line 383
  if (! pause) {
#line 384
    vmw_dmabuf_unreference(& stream->buf);
#line 385
    stream->paused = 0;
  } else {
#line 387
    stream->paused = 1;
  }
#line 390
  return (0);
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_update_stream(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                     struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ 
  struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 407
  overlay = dev_priv->overlay_priv;
#line 408
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )arg->stream_id;
#line 409
  ret = 0;
#line 411
  if ((unsigned long )buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 412
    return (-22);
  } else {

  }
#line 414
  drm_ut_debug_printk(1U, "drm", "vmw_overlay_update_stream", "   %s: old %p, new %p, %spaused\n",
                      "vmw_overlay_update_stream", stream->buf, buf, (int )stream->paused ? (char *)"" : (char *)"not ");
#line 417
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 418
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, (int )interruptible);
#line 420
    if (ret != 0) {
#line 421
      return (ret);
    } else {

    }
  } else
#line 422
  if (! stream->paused) {
#line 426
    ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 427
    if (ret == 0) {
#line 428
      stream->saved = *arg;
    } else {
#line 430
      tmp = ldv__builtin_expect((long )(! interruptible), 0L);
#line 430
      if (tmp != 0L) {
#line 430
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (430), "i" (12UL));
        ldv_40706: ;
#line 430
        goto ldv_40706;
      } else {

      }
    }
#line 432
    return (ret);
  } else {

  }
#line 438
  ret = vmw_overlay_move_buffer(dev_priv, buf, 1, (int )interruptible);
#line 439
  if (ret != 0) {
#line 440
    return (ret);
  } else {

  }
#line 442
  ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 443
  if (ret != 0) {
#line 447
    tmp___0 = vmw_overlay_move_buffer(dev_priv, buf, 0, 0);
#line 447
    tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 447
    if (tmp___1 != 0L) {
#line 447
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (448), "i" (12UL));
      ldv_40707: ;
#line 447
      goto ldv_40707;
    } else {

    }
#line 449
    return (ret);
  } else {

  }
#line 452
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 453
    stream->buf = vmw_dmabuf_reference(buf);
  } else {

  }
#line 454
  stream->saved = *arg;
#line 456
  stream->paused = 0;
#line 458
  return (0);
}
}
#line 468 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 470
  overlay = dev_priv->overlay_priv;
#line 473
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 474
    return (0);
  } else {

  }
#line 476
  ldv_mutex_lock_495(& overlay->mutex);
#line 478
  i = 0;
#line 478
  goto ldv_40719;
  ldv_40718: 
#line 479
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 480
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 481
    goto ldv_40715;
  } else {

  }
#line 483
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
#line 484
  __ret_warn_on = ret != 0;
#line 484
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 484
  if (tmp != 0L) {
#line 484
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       484);
  } else {

  }
#line 484
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ldv_40715: 
#line 478
  i = i + 1;
  ldv_40719: ;
#line 478
  if (i <= 0) {
#line 479
    goto ldv_40718;
  } else {

  }
#line 487
  ldv_mutex_unlock_496(& overlay->mutex);
#line 489
  return (0);
}
}
#line 499 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;

  {
#line 501
  overlay = dev_priv->overlay_priv;
#line 504
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 505
    return (0);
  } else {

  }
#line 507
  ldv_mutex_lock_497(& overlay->mutex);
#line 509
  i = 0;
#line 509
  goto ldv_40731;
  ldv_40730: 
#line 510
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 511
  if (! stream->paused) {
#line 512
    goto ldv_40728;
  } else {

  }
#line 514
  ret = vmw_overlay_update_stream(dev_priv, stream->buf, & stream->saved, 0);
#line 516
  if (ret != 0) {
#line 517
    printk("\016[drm] %s: *warning* failed to resume stream %i\n", "vmw_overlay_resume_all",
           i);
  } else {

  }
  ldv_40728: 
#line 509
  i = i + 1;
  ldv_40731: ;
#line 509
  if (i <= 0) {
#line 510
    goto ldv_40730;
  } else {

  }
#line 521
  ldv_mutex_unlock_498(& overlay->mutex);
#line 523
  return (0);
}
}
#line 533 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 535
  overlay = dev_priv->overlay_priv;
#line 538
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 539
    return (0);
  } else {

  }
#line 541
  ldv_mutex_lock_499(& overlay->mutex);
#line 543
  i = 0;
#line 543
  goto ldv_40743;
  ldv_40742: ;
#line 544
  if ((int )overlay->stream[i].paused) {
#line 545
    printk("\016[drm] %s: *warning* stream %i already paused\n", "vmw_overlay_pause_all",
           i);
  } else {

  }
#line 547
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 1, 0);
#line 548
  __ret_warn_on = ret != 0;
#line 548
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 548
  if (tmp != 0L) {
#line 548
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       548);
  } else {

  }
#line 548
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 543
  i = i + 1;
  ldv_40743: ;
#line 543
  if (i <= 0) {
#line 544
    goto ldv_40742;
  } else {

  }
#line 551
  ldv_mutex_unlock_500(& overlay->mutex);
#line 553
  return (0);
}
}
#line 557 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static bool vmw_overlay_available(struct vmw_private  const  *dev_priv ) 
{ 


  {
#line 559
  return ((bool )((unsigned long )dev_priv->overlay_priv != (unsigned long )((struct vmw_overlay */* const  */)0) && ((unsigned int )dev_priv->fifo.capabilities & 40U) == 40U));
}
}
#line 564 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct vmw_overlay *overlay ;
  struct drm_vmw_control_stream_arg *arg ;
  struct vmw_dma_buffer *buf ;
  struct vmw_resource *res ;
  int ret ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 567
  tmp = vmw_fpriv(file_priv);
#line 567
  tfile = tmp->tfile;
#line 568
  tmp___0 = vmw_priv(dev);
#line 568
  dev_priv = tmp___0;
#line 569
  overlay = dev_priv->overlay_priv;
#line 570
  arg = (struct drm_vmw_control_stream_arg *)data;
#line 576
  tmp___1 = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 576
  if (tmp___1) {
#line 576
    tmp___2 = 0;
  } else {
#line 576
    tmp___2 = 1;
  }
#line 576
  if (tmp___2) {
#line 577
    return (-38);
  } else {

  }
#line 579
  ret = vmw_user_stream_lookup(dev_priv, tfile, & arg->stream_id, & res);
#line 580
  if (ret != 0) {
#line 581
    return (ret);
  } else {

  }
#line 583
  ldv_mutex_lock_501(& overlay->mutex);
#line 585
  if (arg->enabled == 0U) {
#line 586
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, 1);
#line 587
    goto out_unlock;
  } else {

  }
#line 590
  ret = vmw_user_dmabuf_lookup(tfile, arg->handle, & buf);
#line 591
  if (ret != 0) {
#line 592
    goto out_unlock;
  } else {

  }
#line 594
  ret = vmw_overlay_update_stream(dev_priv, buf, arg, 1);
#line 596
  vmw_dmabuf_unreference(& buf);
  out_unlock: 
#line 599
  ldv_mutex_unlock_502(& overlay->mutex);
#line 600
  vmw_resource_unreference(& res);
#line 602
  return (ret);
}
}
#line 605 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 607
  tmp = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 607
  if (tmp) {
#line 607
    tmp___0 = 0;
  } else {
#line 607
    tmp___0 = 1;
  }
#line 607
  if (tmp___0) {
#line 608
    return (0);
  } else {

  }
#line 610
  return (1);
}
}
#line 613 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int k ;
  bool tmp ;
  int tmp___0 ;

  {
#line 615
  overlay = dev_priv->overlay_priv;
#line 618
  tmp = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 618
  if (tmp) {
#line 618
    tmp___0 = 0;
  } else {
#line 618
    tmp___0 = 1;
  }
#line 618
  if (tmp___0) {
#line 619
    return (0);
  } else {

  }
#line 621
  ldv_mutex_lock_503(& overlay->mutex);
#line 623
  i = 0;
#line 623
  k = 0;
#line 623
  goto ldv_40771;
  ldv_40770: ;
#line 624
  if (! overlay->stream[i].claimed) {
#line 625
    k = k + 1;
  } else {

  }
#line 623
  i = i + 1;
  ldv_40771: ;
#line 623
  if (i <= 0) {
#line 624
    goto ldv_40770;
  } else {

  }
#line 627
  ldv_mutex_unlock_504(& overlay->mutex);
#line 629
  return (k);
}
}
#line 632 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;

  {
#line 634
  overlay = dev_priv->overlay_priv;
#line 637
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 638
    return (-38);
  } else {

  }
#line 640
  ldv_mutex_lock_505(& overlay->mutex);
#line 642
  i = 0;
#line 642
  goto ldv_40781;
  ldv_40780: ;
#line 644
  if ((int )overlay->stream[i].claimed) {
#line 645
    goto ldv_40779;
  } else {

  }
#line 647
  overlay->stream[i].claimed = 1;
#line 648
  *out = (uint32_t )i;
#line 649
  ldv_mutex_unlock_506(& overlay->mutex);
#line 650
  return (0);
  ldv_40779: 
#line 642
  i = i + 1;
  ldv_40781: ;
#line 642
  if (i <= 0) {
#line 643
    goto ldv_40780;
  } else {

  }
#line 653
  ldv_mutex_unlock_507(& overlay->mutex);
#line 654
  return (-3);
}
}
#line 657 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) 
{ 
  struct vmw_overlay *overlay ;
  long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 659
  overlay = dev_priv->overlay_priv;
#line 661
  tmp = ldv__builtin_expect(stream_id != 0U, 0L);
#line 661
  if (tmp != 0L) {
#line 661
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                         "i" (661), "i" (12UL));
    ldv_40788: ;
#line 661
    goto ldv_40788;
  } else {

  }
#line 663
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 664
    return (-38);
  } else {

  }
#line 666
  ldv_mutex_lock_508(& overlay->mutex);
#line 668
  __ret_warn_on = ! overlay->stream[stream_id].claimed;
#line 668
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 668
  if (tmp___0 != 0L) {
#line 668
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       668);
  } else {

  }
#line 668
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 669
  vmw_overlay_stop(dev_priv, stream_id, 0, 0);
#line 670
  overlay->stream[stream_id].claimed = 0;
#line 672
  ldv_mutex_unlock_509(& overlay->mutex);
#line 673
  return (0);
}
}
#line 676 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_init(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 681
  if ((unsigned long )dev_priv->overlay_priv != (unsigned long )((struct vmw_overlay *)0)) {
#line 682
    return (-22);
  } else {

  }
#line 684
  tmp = kzalloc(272UL, 208U);
#line 684
  overlay = (struct vmw_overlay *)tmp;
#line 685
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 686
    return (-12);
  } else {

  }
#line 688
  __mutex_init(& overlay->mutex, "&overlay->mutex", & __key);
#line 689
  i = 0;
#line 689
  goto ldv_40798;
  ldv_40797: 
#line 690
  overlay->stream[i].buf = 0;
#line 691
  overlay->stream[i].paused = 0;
#line 692
  overlay->stream[i].claimed = 0;
#line 689
  i = i + 1;
  ldv_40798: ;
#line 689
  if (i <= 0) {
#line 690
    goto ldv_40797;
  } else {

  }
#line 695
  dev_priv->overlay_priv = overlay;
#line 697
  return (0);
}
}
#line 700 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_close(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  bool forgotten_buffer ;
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 702
  overlay = dev_priv->overlay_priv;
#line 703
  forgotten_buffer = 0;
#line 706
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 707
    return (-38);
  } else {

  }
#line 709
  i = 0;
#line 709
  goto ldv_40807;
  ldv_40806: ;
#line 710
  if ((unsigned long )overlay->stream[i].buf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 711
    forgotten_buffer = 1;
#line 712
    vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
  } else {

  }
#line 709
  i = i + 1;
  ldv_40807: ;
#line 709
  if (i <= 0) {
#line 710
    goto ldv_40806;
  } else {

  }
#line 716
  __ret_warn_on = (int )forgotten_buffer;
#line 716
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 716
  if (tmp != 0L) {
#line 716
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       716);
  } else {

  }
#line 716
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 718
  dev_priv->overlay_priv = 0;
#line 719
  kfree((void const   *)overlay);
#line 721
  return (0);
}
}
#line 724 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 729
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 731
  mutex_lock(ldv_func_arg1);
#line 732
  return;
}
}
#line 734 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 739
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 741
  mutex_unlock(ldv_func_arg1);
#line 742
  return;
}
}
#line 744 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 749
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 751
  mutex_lock(ldv_func_arg1);
#line 752
  return;
}
}
#line 754 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 759
  tmp = mutex_trylock(ldv_func_arg1);
#line 759
  ldv_func_res = tmp;
#line 761
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 761
  return (tmp___0);
#line 763
  return (ldv_func_res);
}
}
#line 766 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 771
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 773
  mutex_unlock(ldv_func_arg1);
#line 774
  return;
}
}
#line 776 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 781
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 783
  mutex_lock(ldv_func_arg1);
#line 784
  return;
}
}
#line 786 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 791
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 793
  mutex_unlock(ldv_func_arg1);
#line 794
  return;
}
}
#line 796 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 801
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 803
  mutex_lock(ldv_func_arg1);
#line 804
  return;
}
}
#line 806 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 811
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 813
  mutex_unlock(ldv_func_arg1);
#line 814
  return;
}
}
#line 816 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 821
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 823
  mutex_unlock(ldv_func_arg1);
#line 824
  return;
}
}
#line 826 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 831
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 833
  mutex_lock(ldv_func_arg1);
#line 834
  return;
}
}
#line 836 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 841
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 843
  mutex_unlock(ldv_func_arg1);
#line 844
  return;
}
}
#line 846 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 851
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 853
  mutex_lock(ldv_func_arg1);
#line 854
  return;
}
}
#line 856 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 861
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 863
  mutex_unlock(ldv_func_arg1);
#line 864
  return;
}
}
#line 866 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 871
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 873
  mutex_lock(ldv_func_arg1);
#line 874
  return;
}
}
#line 876 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 881
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 883
  mutex_unlock(ldv_func_arg1);
#line 884
  return;
}
}
#line 886 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 891
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 893
  mutex_lock(ldv_func_arg1);
#line 894
  return;
}
}
#line 896 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 901
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 903
  mutex_unlock(ldv_func_arg1);
#line 904
  return;
}
}
#line 906 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 911
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 913
  mutex_lock(ldv_func_arg1);
#line 914
  return;
}
}
#line 916 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 921
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 923
  mutex_unlock(ldv_func_arg1);
#line 924
  return;
}
}
#line 926 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_501(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 931
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 933
  mutex_lock(ldv_func_arg1);
#line 934
  return;
}
}
#line 936 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_502(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 941
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 943
  mutex_unlock(ldv_func_arg1);
#line 944
  return;
}
}
#line 946 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_503(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 951
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 953
  mutex_lock(ldv_func_arg1);
#line 954
  return;
}
}
#line 956 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_504(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 961
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 963
  mutex_unlock(ldv_func_arg1);
#line 964
  return;
}
}
#line 966 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 971
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 973
  mutex_lock(ldv_func_arg1);
#line 974
  return;
}
}
#line 976 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 981
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 983
  mutex_unlock(ldv_func_arg1);
#line 984
  return;
}
}
#line 986 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 991
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 993
  mutex_unlock(ldv_func_arg1);
#line 994
  return;
}
}
#line 996 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1001
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1003
  mutex_lock(ldv_func_arg1);
#line 1004
  return;
}
}
#line 1006 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1011
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1013
  mutex_unlock(ldv_func_arg1);
#line 1014
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_542(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_549(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) ;
#line 33 "include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 


  {
#line 35
  if ((long )lhs->tv_sec < (long )rhs->tv_sec) {
#line 36
    return (-1);
  } else {

  }
#line 37
  if ((long )lhs->tv_sec > (long )rhs->tv_sec) {
#line 38
    return (1);
  } else {

  }
#line 39
  return ((int )((unsigned int )lhs->tv_nsec - (unsigned int )rhs->tv_nsec));
}
}
#line 55
extern void set_normalized_timespec(struct timespec * , time_t  , s64  ) ;
#line 78 "include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ 
  struct timespec ts_delta ;

  {
#line 82
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, (s64 )(lhs.tv_nsec - rhs.tv_nsec));
#line 84
  return (ts_delta);
}
}
#line 162
extern void getrawmonotonic(struct timespec * ) ;
#line 236
extern struct timespec ns_to_timespec(s64 const    ) ;
#line 140 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) 
{ 
  struct lock_class_key __key ;

  {
#line 142
  INIT_LIST_HEAD(& queue->head);
#line 143
  queue->lag = ns_to_timespec(0LL);
#line 144
  getrawmonotonic(& queue->lag_time);
#line 145
  spinlock_check(& queue->lock);
#line 145
  __raw_spin_lock_init(& queue->lock.ldv_5961.rlock, "&(&queue->lock)->rlock", & __key);
#line 147
  return;
}
}
#line 148 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) 
{ 
  struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 152
  spin_lock(& queue->lock);
#line 153
  __mptr = (struct list_head  const  *)queue->head.next;
#line 153
  marker = (struct vmw_marker *)__mptr;
#line 153
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 153
  next = (struct vmw_marker *)__mptr___0;
#line 153
  goto ldv_40512;
  ldv_40511: 
#line 154
  kfree((void const   *)marker);
#line 153
  marker = next;
#line 153
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 153
  next = (struct vmw_marker *)__mptr___1;
  ldv_40512: ;
#line 153
  if ((unsigned long )marker != (unsigned long )queue) {
#line 154
    goto ldv_40511;
  } else {

  }
#line 156
  spin_unlock(& queue->lock);
#line 157
  return;
}
}
#line 159 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) 
{ 
  struct vmw_marker *marker ;
  void *tmp ;
  long tmp___0 ;

  {
#line 162
  tmp = kmalloc(40UL, 208U);
#line 162
  marker = (struct vmw_marker *)tmp;
#line 164
  tmp___0 = ldv__builtin_expect((unsigned long )marker == (unsigned long )((struct vmw_marker *)0),
                             0L);
#line 164
  if (tmp___0 != 0L) {
#line 165
    return (-12);
  } else {

  }
#line 167
  marker->seqno = seqno;
#line 168
  getrawmonotonic(& marker->submitted);
#line 169
  spin_lock(& queue->lock);
#line 170
  list_add_tail(& marker->head, & queue->head);
#line 171
  spin_unlock(& queue->lock);
#line 173
  return (0);
}
}
#line 176 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) 
{ 
  struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct timespec now ;
  bool updated ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 181
  updated = 0;
#line 183
  spin_lock(& queue->lock);
#line 184
  getrawmonotonic(& now);
#line 186
  tmp = list_empty((struct list_head  const  *)(& queue->head));
#line 186
  if (tmp != 0) {
#line 187
    queue->lag = ns_to_timespec(0LL);
#line 188
    queue->lag_time = now;
#line 189
    updated = 1;
#line 190
    goto out_unlock;
  } else {

  }
#line 193
  __mptr = (struct list_head  const  *)queue->head.next;
#line 193
  marker = (struct vmw_marker *)__mptr;
#line 193
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 193
  next = (struct vmw_marker *)__mptr___0;
#line 193
  goto ldv_40536;
  ldv_40535: ;
#line 194
  if (signaled_seqno - marker->seqno > 1073741824U) {
#line 195
    goto ldv_40534;
  } else {

  }
#line 197
  queue->lag = timespec_sub(now, marker->submitted);
#line 198
  queue->lag_time = now;
#line 199
  updated = 1;
#line 200
  list_del(& marker->head);
#line 201
  kfree((void const   *)marker);
  ldv_40534: 
#line 193
  marker = next;
#line 193
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 193
  next = (struct vmw_marker *)__mptr___1;
  ldv_40536: ;
#line 193
  if ((unsigned long )marker != (unsigned long )queue) {
#line 194
    goto ldv_40535;
  } else {

  }

  out_unlock: 
#line 205
  spin_unlock(& queue->lock);
#line 207
  return ((int )updated ? 0 : -16);
}
}
#line 210 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_timespec_add(struct timespec t1 , struct timespec t2 ) 
{ 


  {
#line 213
  t1.tv_sec = t1.tv_sec + t2.tv_sec;
#line 214
  t1.tv_nsec = t1.tv_nsec + t2.tv_nsec;
#line 215
  if (t1.tv_nsec > 999999999L) {
#line 216
    t1.tv_sec = t1.tv_sec + 1L;
#line 217
    t1.tv_nsec = t1.tv_nsec + -1000000000L;
  } else {

  }
#line 220
  return (t1);
}
}
#line 223 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue ) 
{ 
  struct timespec now ;
  struct timespec tmp ;

  {
#line 227
  spin_lock(& queue->lock);
#line 228
  getrawmonotonic(& now);
#line 229
  tmp = timespec_sub(now, queue->lag_time);
#line 229
  queue->lag = vmw_timespec_add(queue->lag, tmp);
#line 231
  queue->lag_time = now;
#line 232
  spin_unlock(& queue->lock);
#line 233
  return (queue->lag);
}
}
#line 237 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static bool vmw_lag_lt(struct vmw_marker_queue *queue , uint32_t us ) 
{ 
  struct timespec lag ;
  struct timespec cond ;
  int tmp ;

  {
#line 242
  cond = ns_to_timespec((long long )us * 1000LL);
#line 243
  lag = vmw_fifo_lag(queue);
#line 244
  tmp = timespec_compare((struct timespec  const  *)(& lag), (struct timespec  const  *)(& cond));
#line 244
  return (tmp <= 0);
}
}
#line 247 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) 
{ 
  struct vmw_marker *marker ;
  uint32_t seqno ;
  int ret ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 254
  goto ldv_40563;
  ldv_40562: 
#line 255
  spin_lock(& queue->lock);
#line 256
  tmp___0 = list_empty((struct list_head  const  *)(& queue->head));
#line 256
  if (tmp___0 != 0) {
#line 257
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 257
    seqno = (uint32_t )tmp;
  } else {
#line 259
    __mptr = (struct list_head  const  *)queue->head.next;
#line 259
    marker = (struct vmw_marker *)__mptr;
#line 261
    seqno = marker->seqno;
  }
#line 263
  spin_unlock(& queue->lock);
#line 265
  ret = vmw_wait_seqno(dev_priv, 0, seqno, 1, 750UL);
#line 268
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 268
  if (tmp___1 != 0L) {
#line 269
    return (ret);
  } else {

  }
#line 271
  vmw_marker_pull(queue, seqno);
  ldv_40563: 
#line 254
  tmp___2 = vmw_lag_lt(queue, us);
#line 254
  if (tmp___2) {
#line 254
    tmp___3 = 0;
  } else {
#line 254
    tmp___3 = 1;
  }
#line 254
  if (tmp___3) {
#line 255
    goto ldv_40562;
  } else {

  }

#line 273
  return (0);
}
}
#line 276 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 281
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 283
  mutex_lock(ldv_func_arg1);
#line 284
  return;
}
}
#line 286 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 291
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 293
  mutex_unlock(ldv_func_arg1);
#line 294
  return;
}
}
#line 296 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 301
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 303
  mutex_lock(ldv_func_arg1);
#line 304
  return;
}
}
#line 306 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int ldv_mutex_trylock_542(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 311
  tmp = mutex_trylock(ldv_func_arg1);
#line 311
  ldv_func_res = tmp;
#line 313
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 313
  return (tmp___0);
#line 315
  return (ldv_func_res);
}
}
#line 318 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 323
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 325
  mutex_unlock(ldv_func_arg1);
#line 326
  return;
}
}
#line 328 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 333
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 335
  mutex_lock(ldv_func_arg1);
#line 336
  return;
}
}
#line 338 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 343
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 345
  mutex_unlock(ldv_func_arg1);
#line 346
  return;
}
}
#line 348 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 353
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 355
  mutex_lock(ldv_func_arg1);
#line 356
  return;
}
}
#line 358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 363
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 365
  mutex_unlock(ldv_func_arg1);
#line 366
  return;
}
}
#line 368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 373
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 375
  mutex_unlock(ldv_func_arg1);
#line 376
  return;
}
}
#line 378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_549(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 383
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 385
  mutex_lock(ldv_func_arg1);
#line 386
  return;
}
}
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 393
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 395
  mutex_unlock(ldv_func_arg1);
#line 396
  return;
}
}
#line 398 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 403
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 405
  mutex_lock(ldv_func_arg1);
#line 406
  return;
}
}
#line 408 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_570(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_568(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_575(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_580(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_567(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_569(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) ;
#line 142 "include/linux/idr.h"
extern int ida_pre_get(struct ida * , gfp_t  ) ;
#line 144
extern int ida_get_new(struct ida * , int * ) ;
#line 145
extern void ida_remove(struct ida * , int  ) ;
#line 146
extern void ida_destroy(struct ida * ) ;
#line 147
extern void ida_init(struct ida * ) ;
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                                  struct ttm_placement *placement , struct ttm_mem_reg *mem ) 
{ 
  struct vmwgfx_gmrid_man *gman ;
  int ret ;
  int id ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 155
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 157
  ret = 0;
#line 160
  mem->mm_node = 0;
#line 162
  spin_lock(& gman->lock);
#line 164
  if (gman->max_gmr_pages != 0U) {
#line 165
    gman->used_gmr_pages = gman->used_gmr_pages + (uint32_t )bo->num_pages;
#line 166
    tmp = ldv__builtin_expect(gman->used_gmr_pages > gman->max_gmr_pages, 0L);
#line 166
    if (tmp != 0L) {
#line 167
      goto out_err_locked;
    } else {

    }
  } else {

  }
  ldv_40509: 
#line 171
  spin_unlock(& gman->lock);
#line 172
  tmp___0 = ida_pre_get(& gman->gmr_ida, 208U);
#line 172
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 172
  if (tmp___1 != 0L) {
#line 173
    ret = -12;
#line 174
    goto out_err;
  } else {

  }
#line 176
  spin_lock(& gman->lock);
#line 178
  ret = ida_get_new(& gman->gmr_ida, & id);
#line 179
  tmp___2 = ldv__builtin_expect(ret == 0, 0L);
#line 179
  if (tmp___2 != 0L) {
#line 179
    tmp___3 = ldv__builtin_expect((uint32_t )id >= gman->max_gmr_ids, 0L);
#line 179
    if (tmp___3 != 0L) {
#line 180
      ida_remove(& gman->gmr_ida, id);
#line 181
      ret = 0;
#line 182
      goto out_err_locked;
    } else {

    }
  } else {

  }
#line 184
  if (ret == -11) {
#line 185
    goto ldv_40509;
  } else {

  }
#line 186
  tmp___4 = ldv__builtin_expect(ret == 0, 1L);
#line 186
  if (tmp___4 != 0L) {
#line 187
    mem->mm_node = (void *)gman;
#line 188
    mem->start = (unsigned long )id;
#line 189
    mem->num_pages = bo->num_pages;
  } else {
#line 191
    goto out_err_locked;
  }
#line 193
  spin_unlock(& gman->lock);
#line 194
  return (0);
  out_err: 
#line 197
  spin_lock(& gman->lock);
  out_err_locked: 
#line 199
  gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )bo->num_pages;
#line 200
  spin_unlock(& gman->lock);
#line 201
  return (ret);
}
}
#line 204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) 
{ 
  struct vmwgfx_gmrid_man *gman ;

  {
#line 207
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 210
  if ((unsigned long )mem->mm_node != (unsigned long )((void *)0)) {
#line 211
    spin_lock(& gman->lock);
#line 212
    ida_remove(& gman->gmr_ida, (int )mem->start);
#line 213
    gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )mem->num_pages;
#line 214
    spin_unlock(& gman->lock);
#line 215
    mem->mm_node = 0;
  } else {

  }
#line 217
  return;
}
}
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_init(struct ttm_mem_type_manager *man , unsigned long p_size ) 
{ 
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;
  struct vmwgfx_gmrid_man *gman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;

  {
#line 223
  __mptr = (struct ttm_bo_device  const  *)man->bdev;
#line 223
  dev_priv = (struct vmw_private *)__mptr;
#line 224
  tmp = kzalloc(192UL, 208U);
#line 224
  gman = (struct vmwgfx_gmrid_man *)tmp;
#line 227
  tmp___0 = ldv__builtin_expect((unsigned long )gman == (unsigned long )((struct vmwgfx_gmrid_man *)0),
                             0L);
#line 227
  if (tmp___0 != 0L) {
#line 228
    return (-12);
  } else {

  }
#line 230
  spinlock_check(& gman->lock);
#line 230
  __raw_spin_lock_init(& gman->lock.ldv_5961.rlock, "&(&gman->lock)->rlock", & __key);
#line 231
  gman->max_gmr_pages = dev_priv->max_gmr_pages;
#line 232
  gman->used_gmr_pages = 0U;
#line 233
  ida_init(& gman->gmr_ida);
#line 234
  gman->max_gmr_ids = (uint32_t )p_size;
#line 235
  man->priv = (void *)gman;
#line 236
  return (0);
}
}
#line 239 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man ) 
{ 
  struct vmwgfx_gmrid_man *gman ;

  {
#line 241
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 244
  if ((unsigned long )gman != (unsigned long )((struct vmwgfx_gmrid_man *)0)) {
#line 245
    ida_destroy(& gman->gmr_ida);
#line 246
    kfree((void const   *)gman);
  } else {

  }
#line 248
  return (0);
}
}
#line 251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man , char const   *prefix ) 
{ 


  {
#line 254
  printk("\016%s: No debug info available for the GMR id manager.\n", prefix);
#line 255
  return;
}
}
#line 258 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func  =    {& vmw_gmrid_man_init, & vmw_gmrid_man_takedown, & vmw_gmrid_man_get_node, & vmw_gmrid_man_put_node,
    & vmw_gmrid_man_debug};
#line 266 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_567(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 271
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 273
  mutex_lock(ldv_func_arg1);
#line 274
  return;
}
}
#line 276 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_568(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 281
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 283
  mutex_unlock(ldv_func_arg1);
#line 284
  return;
}
}
#line 286 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_569(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 291
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 293
  mutex_lock(ldv_func_arg1);
#line 294
  return;
}
}
#line 296 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
int ldv_mutex_trylock_570(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 301
  tmp = mutex_trylock(ldv_func_arg1);
#line 301
  ldv_func_res = tmp;
#line 303
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 303
  return (tmp___0);
#line 305
  return (ldv_func_res);
}
}
#line 308 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 313
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 315
  mutex_unlock(ldv_func_arg1);
#line 316
  return;
}
}
#line 318 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 323
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 325
  mutex_lock(ldv_func_arg1);
#line 326
  return;
}
}
#line 328 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 333
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 335
  mutex_unlock(ldv_func_arg1);
#line 336
  return;
}
}
#line 338 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 343
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 345
  mutex_lock(ldv_func_arg1);
#line 346
  return;
}
}
#line 348 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_575(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 353
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 355
  mutex_unlock(ldv_func_arg1);
#line 356
  return;
}
}
#line 358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 363
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 365
  mutex_unlock(ldv_func_arg1);
#line 366
  return;
}
}
#line 368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 373
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 375
  mutex_lock(ldv_func_arg1);
#line 376
  return;
}
}
#line 378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 383
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 385
  mutex_unlock(ldv_func_arg1);
#line 386
  return;
}
}
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 393
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 395
  mutex_lock(ldv_func_arg1);
#line 396
  return;
}
}
#line 398 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_580(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 403
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 405
  mutex_unlock(ldv_func_arg1);
#line 406
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_598(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_604(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_608(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_605(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_607(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_609(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) ;
#line 75
void ldv_mutex_lock_goal_irq_mutex(struct mutex *lock ) ;
#line 79
void ldv_mutex_unlock_goal_irq_mutex(struct mutex *lock ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5961.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5961.rlock);
#line 336
  return;
}
}
#line 150 "include/linux/time.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 164 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 409
extern bool schedule_work(struct work_struct * ) ;
#line 420
extern bool cancel_work_sync(struct work_struct * ) ;
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_obj_destroy_locked(struct kref *kref ) 
{ 
  struct vmw_fence_obj *fence ;
  struct kref  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned int num_fences ;

  {
#line 211
  __mptr = (struct kref  const  *)kref;
#line 211
  fence = (struct vmw_fence_obj *)__mptr;
#line 213
  fman = fence->fman;
#line 216
  list_del_init(& fence->head);
#line 217
  fman->num_fence_objects = fman->num_fence_objects - 1;
#line 217
  num_fences = (unsigned int )fman->num_fence_objects;
#line 218
  spin_unlock_irq(& fman->lock);
#line 219
  if ((unsigned long )fence->destroy != (unsigned long )((void (*)(struct vmw_fence_obj * ))0)) {
#line 220
    (*(fence->destroy))(fence);
  } else {
#line 222
    kfree((void const   *)fence);
  }
#line 224
  spin_lock_irq(& fman->lock);
#line 225
  return;
}
}
#line 234 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_work_func(struct work_struct *work ) 
{ 
  struct vmw_fence_manager *fman ;
  struct work_struct  const  *__mptr ;
  struct list_head list ;
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  bool seqno_valid ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 237
  __mptr = (struct work_struct  const  *)work;
#line 237
  fman = (struct vmw_fence_manager *)__mptr + 0xffffffffffffff98UL;
  ldv_40560: 
#line 243
  INIT_LIST_HEAD(& list);
#line 244
  ldv_mutex_lock_609(& fman->goal_irq_mutex);
#line 246
  spin_lock_irq(& fman->lock);
#line 247
  list_splice_init(& fman->cleanup_list, & list);
#line 248
  seqno_valid = fman->seqno_valid;
#line 249
  spin_unlock_irq(& fman->lock);
#line 251
  if (! seqno_valid && (int )fman->goal_irq_on) {
#line 252
    fman->goal_irq_on = 0;
#line 253
    vmw_goal_waiter_remove(fman->dev_priv);
  } else {

  }
#line 255
  ldv_mutex_unlock_610(& fman->goal_irq_mutex);
#line 257
  tmp = list_empty((struct list_head  const  *)(& list));
#line 257
  if (tmp != 0) {
#line 258
    return;
  } else {

  }
#line 266
  __mptr___0 = (struct list_head  const  *)list.next;
#line 266
  action = (struct vmw_fence_action *)__mptr___0;
#line 266
  __mptr___1 = (struct list_head  const  *)action->head.next;
#line 266
  next_action = (struct vmw_fence_action *)__mptr___1;
#line 266
  goto ldv_40558;
  ldv_40557: 
#line 267
  list_del_init(& action->head);
#line 268
  if ((unsigned long )action->cleanup != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 269
    (*(action->cleanup))(action);
  } else {

  }
#line 266
  action = next_action;
#line 266
  __mptr___2 = (struct list_head  const  *)next_action->head.next;
#line 266
  next_action = (struct vmw_fence_action *)__mptr___2;
  ldv_40558: ;
#line 266
  if ((unsigned long )(& action->head) != (unsigned long )(& list)) {
#line 267
    goto ldv_40557;
  } else {

  }

#line 271
  goto ldv_40560;
}
}
#line 274 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) 
{ 
  struct vmw_fence_manager *fman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct lock_class_key __key___1 ;

  {
#line 276
  tmp = kzalloc(400UL, 208U);
#line 276
  fman = (struct vmw_fence_manager *)tmp;
#line 278
  tmp___0 = ldv__builtin_expect((unsigned long )fman == (unsigned long )((struct vmw_fence_manager *)0),
                             0L);
#line 278
  if (tmp___0 != 0L) {
#line 279
    return (0);
  } else {

  }
#line 281
  fman->dev_priv = dev_priv;
#line 282
  spinlock_check(& fman->lock);
#line 282
  __raw_spin_lock_init(& fman->lock.ldv_5961.rlock, "&(&fman->lock)->rlock", & __key);
#line 283
  INIT_LIST_HEAD(& fman->fence_list);
#line 284
  INIT_LIST_HEAD(& fman->cleanup_list);
#line 285
  __init_work(& fman->work, 0);
#line 285
  __constr_expr_0.counter = 4195328L;
#line 285
  fman->work.data = __constr_expr_0;
#line 285
  lockdep_init_map(& fman->work.lockdep_map, "(&fman->work)", & __key___0, 0);
#line 285
  INIT_LIST_HEAD(& fman->work.entry);
#line 285
  fman->work.func = & vmw_fence_work_func;
#line 286
  fman->fifo_down = 1;
#line 287
  tmp___1 = ttm_round_pot(232UL);
#line 287
  fman->user_fence_size = (u32 )tmp___1;
#line 288
  tmp___2 = ttm_round_pot(152UL);
#line 288
  fman->fence_size = (u32 )tmp___2;
#line 289
  tmp___3 = ttm_round_pot(96UL);
#line 289
  fman->event_fence_action_size = (u32 )tmp___3;
#line 291
  __mutex_init(& fman->goal_irq_mutex, "&fman->goal_irq_mutex", & __key___1);
#line 293
  return (fman);
}
}
#line 296 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  bool lists_empty ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 301
  cancel_work_sync(& fman->work);
#line 303
  tmp = spinlock_check(& fman->lock);
#line 303
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 304
  tmp___0 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 304
  if (tmp___0 != 0) {
#line 304
    tmp___1 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 304
    if (tmp___1 != 0) {
#line 304
      tmp___2 = 1;
    } else {
#line 304
      tmp___2 = 0;
    }
  } else {
#line 304
    tmp___2 = 0;
  }
#line 304
  lists_empty = (bool )tmp___2;
#line 306
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 308
  tmp___3 = ldv__builtin_expect((long )(! lists_empty), 0L);
#line 308
  if (tmp___3 != 0L) {
#line 308
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (308), "i" (12UL));
    ldv_40577: ;
#line 308
    goto ldv_40577;
  } else {

  }
#line 309
  kfree((void const   *)fman);
#line 310
  return;
}
}
#line 312 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static int vmw_fence_obj_init(struct vmw_fence_manager *fman , struct vmw_fence_obj *fence ,
                              u32 seqno , uint32_t mask , void (*destroy)(struct vmw_fence_obj * ) ) 
{ 
  unsigned long irq_flags ;
  unsigned int num_fences ;
  int ret ;
  struct lock_class_key __key ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;

  {
#line 320
  ret = 0;
#line 322
  fence->seqno = seqno;
#line 323
  INIT_LIST_HEAD(& fence->seq_passed_actions);
#line 324
  fence->fman = fman;
#line 325
  fence->signaled = 0U;
#line 326
  fence->signal_mask = mask;
#line 327
  kref_init(& fence->kref);
#line 328
  fence->destroy = destroy;
#line 329
  __init_waitqueue_head(& fence->queue, "&fence->queue", & __key);
#line 331
  tmp = spinlock_check(& fman->lock);
#line 331
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 332
  tmp___0 = ldv__builtin_expect((long )fman->fifo_down, 0L);
#line 332
  if (tmp___0 != 0L) {
#line 333
    ret = -16;
#line 334
    goto out_unlock;
  } else {

  }
#line 336
  list_add_tail(& fence->head, & fman->fence_list);
#line 337
  fman->num_fence_objects = fman->num_fence_objects + 1;
#line 337
  num_fences = (unsigned int )fman->num_fence_objects;
  out_unlock: 
#line 340
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 341
  return (ret);
}
}
#line 345 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) 
{ 
  long tmp ;

  {
#line 347
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 347
  if (tmp != 0L) {
#line 348
    return (0);
  } else {

  }
#line 350
  kref_get(& fence->kref);
#line 351
  return (fence);
}
}
#line 361 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) 
{ 
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 363
  fence = *fence_p;
#line 366
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 366
  if (tmp != 0L) {
#line 367
    return;
  } else {

  }
#line 369
  fman = fence->fman;
#line 370
  *fence_p = 0;
#line 371
  spin_lock_irq(& fman->lock);
#line 372
  tmp___0 = atomic_read((atomic_t const   *)(& fence->kref.refcount));
#line 372
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 372
  if (tmp___1 != 0L) {
#line 372
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (372), "i" (12UL));
    ldv_40602: ;
#line 372
    goto ldv_40602;
  } else {

  }
#line 373
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
#line 374
  spin_unlock_irq(& fman->lock);
#line 375
  return;
}
}
#line 377 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_perform_actions(struct vmw_fence_manager *fman , struct list_head *list ) 
{ 
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 382
  __mptr = (struct list_head  const  *)list->next;
#line 382
  action = (struct vmw_fence_action *)__mptr;
#line 382
  __mptr___0 = (struct list_head  const  *)action->head.next;
#line 382
  next_action = (struct vmw_fence_action *)__mptr___0;
#line 382
  goto ldv_40616;
  ldv_40615: 
#line 383
  list_del_init(& action->head);
#line 384
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] - 1U;
#line 385
  if ((unsigned long )action->seq_passed != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 386
    (*(action->seq_passed))(action);
  } else {

  }
#line 393
  list_add_tail(& action->head, & fman->cleanup_list);
#line 382
  action = next_action;
#line 382
  __mptr___1 = (struct list_head  const  *)next_action->head.next;
#line 382
  next_action = (struct vmw_fence_action *)__mptr___1;
  ldv_40616: ;
#line 382
  if ((unsigned long )(& action->head) != (unsigned long )list) {
#line 383
    goto ldv_40615;
  } else {

  }

#line 387
  return;
}
}
#line 413 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_new_locked(struct vmw_fence_manager *fman , u32 passed_seqno ) 
{ 
  u32 goal_seqno ;
  __le32 *fifo_mem ;
  struct vmw_fence_obj *fence ;
  long tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 420
  tmp = ldv__builtin_expect((long )(! fman->seqno_valid), 1L);
#line 420
  if (tmp != 0L) {
#line 421
    return (0);
  } else {

  }
#line 423
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 424
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 425
  tmp___0 = ldv__builtin_expect((int )(passed_seqno - goal_seqno) < 0, 1L);
#line 425
  if (tmp___0 != 0L) {
#line 426
    return (0);
  } else {

  }
#line 428
  fman->seqno_valid = 0;
#line 429
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 429
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 429
  goto ldv_40631;
  ldv_40630: 
#line 430
  tmp___1 = list_empty((struct list_head  const  *)(& fence->seq_passed_actions));
#line 430
  if (tmp___1 == 0) {
#line 431
    fman->seqno_valid = 1;
#line 432
    iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 434
    goto ldv_40629;
  } else {

  }
#line 429
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 429
  fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_40631: ;
#line 429
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 430
    goto ldv_40630;
  } else {

  }
  ldv_40629: ;
#line 438
  return (1);
}
}
#line 457 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_check_locked(struct vmw_fence_obj *fence ) 
{ 
  u32 goal_seqno ;
  __le32 *fifo_mem ;
  long tmp ;
  long tmp___0 ;

  {
#line 462
  if ((int )fence->signaled & 1) {
#line 463
    return (0);
  } else {

  }
#line 465
  fifo_mem = ((fence->fman)->dev_priv)->mmio_virt;
#line 466
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 467
  tmp = ldv__builtin_expect((long )(fence->fman)->seqno_valid, 1L);
#line 467
  if (tmp != 0L) {
#line 467
    tmp___0 = ldv__builtin_expect((int )(goal_seqno - fence->seqno) >= 0, 1L);
#line 467
    if (tmp___0 != 0L) {
#line 469
      return (0);
    } else {

    }
  } else {

  }
#line 471
  iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 472
  (fence->fman)->seqno_valid = 1;
#line 474
  return (1);
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_update(struct vmw_fence_manager *fman ) 
{ 
  unsigned long flags ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_obj *next_fence ;
  struct list_head action_list ;
  bool needs_rerun ;
  uint32_t seqno ;
  uint32_t new_seqno ;
  __le32 *fifo_mem ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 484
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 486
  seqno = ioread32((void *)fifo_mem + 6U);
  rerun: 
#line 488
  tmp = spinlock_check(& fman->lock);
#line 488
  flags = _raw_spin_lock_irqsave(tmp);
#line 489
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 489
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 489
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 489
  next_fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
#line 489
  goto ldv_40660;
  ldv_40659: ;
#line 490
  if ((int )(seqno - fence->seqno) >= 0) {
#line 491
    list_del_init(& fence->head);
#line 492
    fence->signaled = fence->signaled | 1U;
#line 493
    INIT_LIST_HEAD(& action_list);
#line 494
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 496
    vmw_fences_perform_actions(fman, & action_list);
#line 497
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {
#line 499
    goto ldv_40658;
  }
#line 489
  fence = next_fence;
#line 489
  __mptr___1 = (struct list_head  const  *)next_fence->head.next;
#line 489
  next_fence = (struct vmw_fence_obj *)__mptr___1 + 0xfffffffffffffff0UL;
  ldv_40660: ;
#line 489
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 490
    goto ldv_40659;
  } else {

  }
  ldv_40658: 
#line 502
  needs_rerun = vmw_fence_goal_new_locked(fman, seqno);
#line 504
  tmp___0 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 504
  if (tmp___0 == 0) {
#line 505
    schedule_work(& fman->work);
  } else {

  }
#line 506
  spin_unlock_irqrestore(& fman->lock, flags);
#line 514
  tmp___1 = ldv__builtin_expect((long )needs_rerun, 0L);
#line 514
  if (tmp___1 != 0L) {
#line 515
    new_seqno = ioread32((void *)fifo_mem + 6U);
#line 516
    if (new_seqno != seqno) {
#line 517
      seqno = new_seqno;
#line 518
      goto rerun;
    } else {

    }
  } else {

  }
#line 521
  return;
}
}
#line 523 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) 
{ 
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  uint32_t signaled ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 526
  fman = fence->fman;
#line 530
  tmp = spinlock_check(& fman->lock);
#line 530
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 531
  signaled = fence->signaled;
#line 532
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 534
  flags = fence->signal_mask & flags;
#line 535
  if ((signaled & flags) == flags) {
#line 536
    return (1);
  } else {

  }
#line 538
  if ((signaled & 1U) == 0U) {
#line 539
    vmw_fences_update(fman);
  } else {

  }
#line 541
  tmp___0 = spinlock_check(& fman->lock);
#line 541
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 542
  signaled = fence->signaled;
#line 543
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 545
  return ((signaled & flags) == flags);
}
}
#line 548 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) 
{ 
  struct vmw_private *dev_priv ;
  long ret ;
  bool tmp ;
  long tmp___0 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 552
  dev_priv = (fence->fman)->dev_priv;
#line 555
  tmp = vmw_fence_obj_signaled(fence, flags);
#line 555
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 555
  if (tmp___0 != 0L) {
#line 556
    return (0);
  } else {

  }
#line 558
  vmw_fifo_ping_host(dev_priv, 1U);
#line 559
  vmw_seqno_waiter_add(dev_priv);
#line 561
  if ((int )interruptible) {
#line 562
    __ret = (long )timeout;
#line 562
    tmp___5 = vmw_fence_obj_signaled(fence, flags);
#line 562
    if (tmp___5) {
#line 562
      tmp___6 = 0;
    } else {
#line 562
      tmp___6 = 1;
    }
#line 562
    if (tmp___6) {
#line 562
      tmp___1 = get_current();
#line 562
      __wait.flags = 0U;
#line 562
      __wait.private = (void *)tmp___1;
#line 562
      __wait.func = & autoremove_wake_function;
#line 562
      __wait.task_list.next = & __wait.task_list;
#line 562
      __wait.task_list.prev = & __wait.task_list;
      ldv_40687: 
#line 562
      prepare_to_wait(& fence->queue, & __wait, 1);
#line 562
      tmp___2 = vmw_fence_obj_signaled(fence, flags);
#line 562
      if ((int )tmp___2) {
#line 562
        goto ldv_40685;
      } else {

      }
#line 562
      tmp___3 = get_current();
#line 562
      tmp___4 = signal_pending(tmp___3);
#line 562
      if (tmp___4 == 0) {
#line 562
        __ret = schedule_timeout(__ret);
#line 562
        if (__ret == 0L) {
#line 562
          goto ldv_40685;
        } else {

        }
#line 562
        goto ldv_40686;
      } else {

      }
#line 562
      __ret = -512L;
#line 562
      goto ldv_40685;
      ldv_40686: ;
#line 562
      goto ldv_40687;
      ldv_40685: 
#line 562
      finish_wait(& fence->queue, & __wait);
    } else {

    }
#line 562
    ret = __ret;
  } else {
#line 567
    __ret___0 = (long )timeout;
#line 567
    tmp___9 = vmw_fence_obj_signaled(fence, flags);
#line 567
    if (tmp___9) {
#line 567
      tmp___10 = 0;
    } else {
#line 567
      tmp___10 = 1;
    }
#line 567
    if (tmp___10) {
#line 567
      tmp___7 = get_current();
#line 567
      __wait___0.flags = 0U;
#line 567
      __wait___0.private = (void *)tmp___7;
#line 567
      __wait___0.func = & autoremove_wake_function;
#line 567
      __wait___0.task_list.next = & __wait___0.task_list;
#line 567
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40692: 
#line 567
      prepare_to_wait(& fence->queue, & __wait___0, 2);
#line 567
      tmp___8 = vmw_fence_obj_signaled(fence, flags);
#line 567
      if ((int )tmp___8) {
#line 567
        goto ldv_40691;
      } else {

      }
#line 567
      __ret___0 = schedule_timeout(__ret___0);
#line 567
      if (__ret___0 == 0L) {
#line 567
        goto ldv_40691;
      } else {

      }
#line 567
      goto ldv_40692;
      ldv_40691: 
#line 567
      finish_wait(& fence->queue, & __wait___0);
    } else {

    }
#line 567
    ret = __ret___0;
  }
#line 572
  vmw_seqno_waiter_remove(dev_priv);
#line 574
  tmp___12 = ldv__builtin_expect(ret == 0L, 0L);
#line 574
  if (tmp___12 != 0L) {
#line 575
    ret = -16L;
  } else {
#line 576
    tmp___11 = ldv__builtin_expect(ret > 0L, 1L);
#line 576
    if (tmp___11 != 0L) {
#line 577
      ret = 0L;
    } else {

    }
  }
#line 579
  return ((int )ret);
}
}
#line 582 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_private *dev_priv ;

  {
#line 584
  dev_priv = (fence->fman)->dev_priv;
#line 586
  vmw_fifo_ping_host(dev_priv, 1U);
#line 587
  return;
}
}
#line 589 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_destroy(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 591
  fman = fence->fman;
#line 593
  kfree((void const   *)fence);
#line 597
  tmp = vmw_mem_glob(fman->dev_priv);
#line 597
  ttm_mem_global_free(tmp, (uint64_t )fman->fence_size);
#line 599
  return;
}
}
#line 601 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) 
{ 
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp ;
  struct vmw_fence_obj *fence ;
  int ret ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 606
  tmp = vmw_mem_glob(fman->dev_priv);
#line 606
  mem_glob = tmp;
#line 610
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->fence_size, 0, 0);
#line 612
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 612
  if (tmp___0 != 0L) {
#line 613
    return (ret);
  } else {

  }
#line 615
  tmp___1 = kzalloc(152UL, 208U);
#line 615
  fence = (struct vmw_fence_obj *)tmp___1;
#line 616
  tmp___2 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 616
  if (tmp___2 != 0L) {
#line 617
    ret = -12;
#line 618
    goto out_no_object;
  } else {

  }
#line 621
  ret = vmw_fence_obj_init(fman, fence, seqno, mask, & vmw_fence_destroy);
#line 623
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 623
  if (tmp___3 != 0L) {
#line 624
    goto out_err_init;
  } else {

  }
#line 626
  *p_fence = fence;
#line 627
  return (0);
  out_err_init: 
#line 630
  kfree((void const   *)fence);
  out_no_object: 
#line 632
  ttm_mem_global_free(mem_glob, (uint64_t )fman->fence_size);
#line 633
  return (ret);
}
}
#line 637 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_destroy(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 640
  __mptr = (struct vmw_fence_obj  const  *)fence;
#line 640
  ufence = (struct vmw_user_fence *)__mptr + 0xffffffffffffffb0UL;
#line 641
  fman = fence->fman;
#line 643
  kfree_call_rcu(& ufence->base.rhead, 0);
#line 647
  tmp = vmw_mem_glob(fman->dev_priv);
#line 647
  ttm_mem_global_free(tmp, (uint64_t )fman->user_fence_size);
#line 649
  return;
}
}
#line 651 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_fence *ufence ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_fence_obj *fence ;

  {
#line 653
  base = *p_base;
#line 655
  __mptr = (struct ttm_base_object  const  *)base;
#line 655
  ufence = (struct vmw_user_fence *)__mptr;
#line 656
  fence = & ufence->fence;
#line 658
  *p_base = 0;
#line 659
  vmw_fence_obj_unreference(& fence);
#line 660
  return;
}
}
#line 662 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *tmp___0 ;
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___1 ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 669
  tmp = vmw_fpriv(file_priv);
#line 669
  tfile = tmp->tfile;
#line 672
  tmp___1 = vmw_mem_glob(fman->dev_priv);
#line 672
  mem_glob = tmp___1;
#line 680
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->user_fence_size, 0, 0);
#line 682
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 682
  if (tmp___2 != 0L) {
#line 683
    return (ret);
  } else {

  }
#line 685
  tmp___3 = kzalloc(232UL, 208U);
#line 685
  ufence = (struct vmw_user_fence *)tmp___3;
#line 686
  tmp___4 = ldv__builtin_expect((unsigned long )ufence == (unsigned long )((struct vmw_user_fence *)0),
                             0L);
#line 686
  if (tmp___4 != 0L) {
#line 687
    ret = -12;
#line 688
    goto out_no_object;
  } else {

  }
#line 691
  ret = vmw_fence_obj_init(fman, & ufence->fence, seqno, mask, & vmw_user_fence_destroy);
#line 693
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 693
  if (tmp___5 != 0L) {
#line 694
    kfree((void const   *)ufence);
#line 695
    goto out_no_object;
  } else {

  }
#line 702
  tmp___0 = vmw_fence_obj_reference(& ufence->fence);
#line 703
  ret = ttm_base_object_init(tfile, & ufence->base, 0, 259, & vmw_user_fence_base_release,
                             0);
#line 708
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 708
  if (tmp___6 != 0L) {
#line 712
    vmw_fence_obj_unreference(& tmp___0);
#line 713
    goto out_err;
  } else {

  }
#line 716
  *p_fence = & ufence->fence;
#line 717
  *p_handle = (uint32_t )ufence->base.hash.key;
#line 719
  return (0);
  out_err: 
#line 721
  tmp___0 = & ufence->fence;
#line 722
  vmw_fence_obj_unreference(& tmp___0);
  out_no_object: 
#line 724
  ttm_mem_global_free(mem_glob, (uint64_t )fman->user_fence_size);
#line 725
  return (ret);
}
}
#line 733 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  struct list_head action_list ;
  int ret ;
  raw_spinlock_t *tmp ;
  struct vmw_fence_obj *fence ;
  struct list_head  const  *__mptr ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 744
  tmp = spinlock_check(& fman->lock);
#line 744
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 745
  fman->fifo_down = 1;
#line 746
  goto ldv_40758;
  ldv_40757: 
#line 748
  __mptr = (struct list_head  const  *)fman->fence_list.prev;
#line 748
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 750
  kref_get(& fence->kref);
#line 751
  spin_unlock_irq(& fman->lock);
#line 753
  ret = vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
#line 757
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 757
  if (tmp___0 != 0L) {
#line 758
    list_del_init(& fence->head);
#line 759
    fence->signaled = fence->signaled | 1U;
#line 760
    INIT_LIST_HEAD(& action_list);
#line 761
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 763
    vmw_fences_perform_actions(fman, & action_list);
#line 764
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {

  }
#line 767
  spin_lock_irq(& fman->lock);
#line 769
  tmp___1 = list_empty((struct list_head  const  *)(& fence->head));
#line 769
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 769
  if (tmp___2 != 0L) {
#line 769
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (769), "i" (12UL));
    ldv_40756: ;
#line 769
    goto ldv_40756;
  } else {

  }
#line 770
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
  ldv_40758: 
#line 746
  tmp___3 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 746
  if (tmp___3 == 0) {
#line 747
    goto ldv_40757;
  } else {

  }
#line 772
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 773
  return;
}
}
#line 775 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 779
  tmp = spinlock_check(& fman->lock);
#line 779
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 780
  fman->fifo_down = 0;
#line 781
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 782
  return;
}
}
#line 785 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_wait_arg *arg ;
  unsigned long timeout ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int ret ;
  uint64_t wait_timeout ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 788
  arg = (struct drm_vmw_fence_wait_arg *)data;
#line 793
  tmp = vmw_fpriv(file_priv);
#line 793
  tfile = tmp->tfile;
#line 795
  wait_timeout = arg->timeout_us * 250ULL;
#line 802
  wait_timeout = ((wait_timeout >> 20) + (wait_timeout >> 24)) - (wait_timeout >> 26);
#line 805
  if (arg->cookie_valid == 0) {
#line 806
    arg->cookie_valid = 1;
#line 807
    arg->kernel_cookie = (unsigned long long )jiffies + wait_timeout;
  } else {

  }
#line 810
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 811
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 811
  if (tmp___0 != 0L) {
#line 812
    printk("\vWait invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 815
    return (-22);
  } else {

  }
#line 818
  __mptr = (struct ttm_base_object  const  *)base;
#line 818
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 820
  timeout = jiffies;
#line 821
  if ((long )timeout - (long )arg->kernel_cookie >= 0L) {
#line 822
    tmp___1 = vmw_fence_obj_signaled(fence, (uint32_t )arg->flags);
#line 822
    ret = (int )tmp___1 ? 0 : -16;
#line 824
    goto out;
  } else {

  }
#line 827
  timeout = (unsigned long )arg->kernel_cookie - timeout;
#line 829
  ret = vmw_fence_obj_wait(fence, (uint32_t )arg->flags, arg->lazy != 0, 1, timeout);
  out: 
#line 832
  ttm_base_object_unref(& base);
#line 838
  if (ret == 0 && arg->wait_options & 1) {
#line 839
    tmp___2 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->handle, 0);
#line 839
    return (tmp___2);
  } else {

  }
#line 841
  return (ret);
}
}
#line 844 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_signaled_arg *arg ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___2 ;

  {
#line 847
  arg = (struct drm_vmw_fence_signaled_arg *)data;
#line 852
  tmp = vmw_fpriv(file_priv);
#line 852
  tfile = tmp->tfile;
#line 853
  tmp___0 = vmw_priv(dev);
#line 853
  dev_priv = tmp___0;
#line 855
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 856
  tmp___1 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 856
  if (tmp___1 != 0L) {
#line 857
    printk("\vFence signaled invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 860
    return (-22);
  } else {

  }
#line 863
  __mptr = (struct ttm_base_object  const  *)base;
#line 863
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 864
  fman = fence->fman;
#line 866
  tmp___2 = vmw_fence_obj_signaled(fence, arg->flags);
#line 866
  arg->signaled = (int32_t )tmp___2;
#line 867
  spin_lock_irq(& fman->lock);
#line 869
  arg->signaled_flags = fence->signaled;
#line 870
  arg->passed_seqno = dev_priv->last_read_seqno;
#line 871
  spin_unlock_irq(& fman->lock);
#line 873
  ttm_base_object_unref(& base);
#line 875
  return (0);
}
}
#line 879 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 882
  arg = (struct drm_vmw_fence_arg *)data;
#line 885
  tmp = vmw_fpriv(file_priv);
#line 885
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, 0);
#line 885
  return (tmp___0);
}
}
#line 903 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct drm_pending_event *event ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;

  {
  ldv_40820: 
#line 911
  tmp = spinlock_check(& fman->lock);
#line 911
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 912
  tmp___0 = list_empty((struct list_head  const  *)event_list);
#line 912
  if (tmp___0 != 0) {
#line 913
    goto out_unlock;
  } else {

  }
#line 914
  __mptr = (struct list_head  const  *)event_list->next;
#line 914
  eaction = (struct vmw_event_fence_action *)__mptr + 0xffffffffffffffd8UL;
#line 917
  list_del_init(& eaction->fpriv_head);
#line 918
  event = eaction->event;
#line 919
  eaction->event = 0;
#line 920
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 921
  (*(event->destroy))(event);
#line 922
  goto ldv_40820;
  out_unlock: 
#line 924
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 925
  return;
}
}
#line 939 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_seq_passed(struct vmw_fence_action *action ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct drm_device *dev ;
  struct drm_pending_event *event ;
  struct drm_file *file_priv ;
  unsigned long irq_flags ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  struct timeval tv ;
  long tmp___1 ;

  {
#line 942
  __mptr = (struct vmw_fence_action  const  *)action;
#line 942
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 943
  dev = eaction->dev;
#line 944
  event = eaction->event;
#line 948
  tmp = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct drm_pending_event *)0),
                         0L);
#line 948
  if (tmp != 0L) {
#line 949
    return;
  } else {

  }
#line 951
  file_priv = event->file_priv;
#line 952
  tmp___0 = spinlock_check(& dev->event_lock);
#line 952
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 954
  tmp___1 = ldv__builtin_expect((unsigned long )eaction->tv_sec != (unsigned long )((uint32_t *)0),
                             1L);
#line 954
  if (tmp___1 != 0L) {
#line 957
    do_gettimeofday(& tv);
#line 958
    *(eaction->tv_sec) = (uint32_t )tv.tv_sec;
#line 959
    *(eaction->tv_usec) = (uint32_t )tv.tv_usec;
  } else {

  }
#line 962
  list_del_init(& eaction->fpriv_head);
#line 963
  list_add_tail(& (eaction->event)->link, & file_priv->event_list);
#line 964
  eaction->event = 0;
#line 965
  __wake_up(& file_priv->event_wait, 3U, 0, 0);
#line 966
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 967
  return;
}
}
#line 978 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_cleanup(struct vmw_fence_action *action ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 981
  __mptr = (struct vmw_fence_action  const  *)action;
#line 981
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 982
  fman = (eaction->fence)->fman;
#line 985
  tmp = spinlock_check(& fman->lock);
#line 985
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 986
  list_del(& eaction->fpriv_head);
#line 987
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 989
  vmw_fence_obj_unreference(& eaction->fence);
#line 990
  kfree((void const   *)eaction);
#line 991
  return;
}
}
#line 1003 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_add_action(struct vmw_fence_obj *fence , struct vmw_fence_action *action ) 
{ 
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  bool run_update ;
  raw_spinlock_t *tmp ;
  struct list_head action_list ;

  {
#line 1006
  fman = fence->fman;
#line 1008
  run_update = 0;
#line 1010
  ldv_mutex_lock_611(& fman->goal_irq_mutex);
#line 1011
  tmp = spinlock_check(& fman->lock);
#line 1011
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1013
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] + 1U;
#line 1014
  if ((int )fence->signaled & 1) {
#line 1017
    INIT_LIST_HEAD(& action_list);
#line 1018
    list_add_tail(& action->head, & action_list);
#line 1019
    vmw_fences_perform_actions(fman, & action_list);
  } else {
#line 1021
    list_add_tail(& action->head, & fence->seq_passed_actions);
#line 1027
    run_update = vmw_fence_goal_check_locked(fence);
  }
#line 1030
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1032
  if ((int )run_update) {
#line 1033
    if (! fman->goal_irq_on) {
#line 1034
      fman->goal_irq_on = 1;
#line 1035
      vmw_goal_waiter_add(fman->dev_priv);
    } else {

    }
#line 1037
    vmw_fences_update(fman);
  } else {

  }
#line 1039
  ldv_mutex_unlock_612(& fman->goal_irq_mutex);
#line 1040
  return;
}
}
#line 1058 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_manager *fman ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  unsigned long irq_flags ;
  void *tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 1066
  fman = fence->fman;
#line 1067
  tmp = vmw_fpriv(file_priv);
#line 1067
  vmw_fp = tmp;
#line 1070
  tmp___0 = kzalloc(96UL, 208U);
#line 1070
  eaction = (struct vmw_event_fence_action *)tmp___0;
#line 1071
  tmp___1 = ldv__builtin_expect((unsigned long )eaction == (unsigned long )((struct vmw_event_fence_action *)0),
                             0L);
#line 1071
  if (tmp___1 != 0L) {
#line 1072
    return (-12);
  } else {

  }
#line 1074
  eaction->event = event;
#line 1076
  eaction->action.seq_passed = & vmw_event_fence_action_seq_passed;
#line 1077
  eaction->action.cleanup = & vmw_event_fence_action_cleanup;
#line 1078
  eaction->action.type = 0;
#line 1080
  eaction->fence = vmw_fence_obj_reference(fence);
#line 1081
  eaction->dev = (fman->dev_priv)->dev;
#line 1082
  eaction->tv_sec = tv_sec;
#line 1083
  eaction->tv_usec = tv_usec;
#line 1085
  tmp___2 = spinlock_check(& fman->lock);
#line 1085
  irq_flags = _raw_spin_lock_irqsave(tmp___2);
#line 1086
  list_add_tail(& eaction->fpriv_head, & vmw_fp->fence_events);
#line 1087
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1089
  vmw_fence_obj_add_action(fence, & eaction->action);
#line 1091
  return (0);
}
}
#line 1099 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_create(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                  uint32_t flags , uint64_t user_data , bool interruptible ) 
{ 
  struct vmw_event_fence_pending *event ;
  struct drm_device *dev ;
  unsigned long irq_flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  raw_spinlock_t *tmp___4 ;

  {
#line 1106
  dev = ((fence->fman)->dev_priv)->dev;
#line 1110
  tmp = spinlock_check(& dev->event_lock);
#line 1110
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1112
  ret = (unsigned int )file_priv->event_space <= 23U ? -16 : 0;
#line 1113
  tmp___0 = ldv__builtin_expect(ret == 0, 1L);
#line 1113
  if (tmp___0 != 0L) {
#line 1114
    file_priv->event_space = (int )((unsigned int )file_priv->event_space - 24U);
  } else {

  }
#line 1116
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 1118
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1118
  if (tmp___1 != 0L) {
#line 1119
    drm_err("vmw_event_fence_action_create", "Failed to allocate event space for this file.\n");
#line 1120
    goto out_no_space;
  } else {

  }
#line 1124
  tmp___2 = kzalloc(72UL, 208U);
#line 1124
  event = (struct vmw_event_fence_pending *)tmp___2;
#line 1125
  tmp___3 = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct vmw_event_fence_pending *)0),
                             0L);
#line 1125
  if (tmp___3 != 0L) {
#line 1126
    drm_err("vmw_event_fence_action_create", "Failed to allocate an event.\n");
#line 1127
    ret = -12;
#line 1128
    goto out_no_event;
  } else {

  }
#line 1131
  event->event.base.type = 2147483648U;
#line 1132
  event->event.base.length = 72U;
#line 1133
  event->event.user_data = user_data;
#line 1135
  event->base.event = & event->event.base;
#line 1136
  event->base.file_priv = file_priv;
#line 1137
  event->base.destroy = (void (*)(struct drm_pending_event * ))(& kfree);
#line 1140
  if ((int )flags & 1) {
#line 1141
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                       & event->event.tv_usec, (int )interruptible);
  } else {
#line 1147
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, 0, 0, (int )interruptible);
  }
#line 1152
  if (ret != 0) {

  } else {

  }
#line 1156
  (*(event->base.destroy))(& event->base);
  out_no_event: 
#line 1158
  tmp___4 = spinlock_check(& dev->event_lock);
#line 1158
  irq_flags = _raw_spin_lock_irqsave(tmp___4);
#line 1159
  file_priv->event_space = (int )((unsigned int )file_priv->event_space + 72U);
#line 1160
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
  out_no_space: ;
#line 1162
  return (ret);
}
}
#line 1165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_fence_event_arg *arg ;
  struct vmw_fence_obj *fence ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  uint32_t handle ;
  int ret ;
  struct ttm_base_object *base ;
  struct ttm_base_object *tmp___1 ;
  long tmp___2 ;
  struct ttm_base_object  const  *__mptr ;
  bool existed ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  struct vmw_fpriv *tmp___7 ;

  {
#line 1168
  tmp = vmw_priv(dev);
#line 1168
  dev_priv = tmp;
#line 1169
  arg = (struct drm_vmw_fence_event_arg *)data;
#line 1171
  fence = 0;
#line 1172
  tmp___0 = vmw_fpriv(file_priv);
#line 1172
  vmw_fp = tmp___0;
#line 1173
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 1184
  if (arg->handle != 0U) {
#line 1185
    tmp___1 = ttm_base_object_lookup(vmw_fp->tfile, arg->handle);
#line 1185
    base = tmp___1;
#line 1188
    tmp___2 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                               0L);
#line 1188
    if (tmp___2 != 0L) {
#line 1189
      drm_err("vmw_fence_event_ioctl", "Fence event invalid fence object handle 0x%08lx.\n",
              (unsigned long )arg->handle);
#line 1192
      return (-22);
    } else {

    }
#line 1194
    __mptr = (struct ttm_base_object  const  *)base;
#line 1194
    fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 1196
    vmw_fence_obj_reference(fence);
#line 1198
    if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1201
      ret = ttm_ref_object_add(vmw_fp->tfile, base, 0, & existed);
#line 1203
      tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1203
      if (tmp___3 != 0L) {
#line 1204
        drm_err("vmw_fence_event_ioctl", "Failed to reference a fence object.\n");
#line 1206
        goto out_no_ref_obj;
      } else {

      }
#line 1208
      handle = (uint32_t )base->hash.key;
    } else {

    }
#line 1210
    ttm_base_object_unref(& base);
  } else {

  }
#line 1216
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1217
    ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, (unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0) ? & handle : 0);
#line 1221
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1221
    if (tmp___4 != 0L) {
#line 1222
      drm_err("vmw_fence_event_ioctl", "Fence event failed to create fence.\n");
#line 1223
      return (ret);
    } else {

    }
  } else {

  }
#line 1227
  tmp___5 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 1227
  if (tmp___5 != 0L) {
#line 1227
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (1227), "i" (12UL));
    ldv_40915: ;
#line 1227
    goto ldv_40915;
  } else {

  }
#line 1229
  if ((int )arg->flags & 1) {
#line 1230
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  } else {
#line 1235
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  }
#line 1240
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 1240
  if (tmp___6 != 0L) {
#line 1241
    if (ret != -512) {
#line 1242
      drm_err("vmw_fence_event_ioctl", "Failed to attach event to fence.\n");
    } else {

    }
#line 1243
    goto out_no_create;
  } else {

  }
#line 1246
  vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, fence, handle);
#line 1248
  vmw_fence_obj_unreference(& fence);
#line 1249
  return (0);
  out_no_create: ;
#line 1251
  if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1252
    tmp___7 = vmw_fpriv(file_priv);
#line 1252
    ttm_ref_object_base_unref(tmp___7->tfile, (unsigned long )handle, 0);
  } else {

  }
  out_no_ref_obj: 
#line 1255
  vmw_fence_obj_unreference(& fence);
#line 1256
  return (ret);
}
}
#line 1259 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1264
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1266
  mutex_lock(ldv_func_arg1);
#line 1267
  return;
}
}
#line 1269 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1274
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1276
  mutex_unlock(ldv_func_arg1);
#line 1277
  return;
}
}
#line 1279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1284
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1286
  mutex_lock(ldv_func_arg1);
#line 1287
  return;
}
}
#line 1289 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int ldv_mutex_trylock_598(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1294
  tmp = mutex_trylock(ldv_func_arg1);
#line 1294
  ldv_func_res = tmp;
#line 1296
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1296
  return (tmp___0);
#line 1298
  return (ldv_func_res);
}
}
#line 1301 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1306
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1308
  mutex_unlock(ldv_func_arg1);
#line 1309
  return;
}
}
#line 1311 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1316
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1318
  mutex_lock(ldv_func_arg1);
#line 1319
  return;
}
}
#line 1321 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1326
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1328
  mutex_unlock(ldv_func_arg1);
#line 1329
  return;
}
}
#line 1331 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1336
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1338
  mutex_lock(ldv_func_arg1);
#line 1339
  return;
}
}
#line 1341 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1346
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1348
  mutex_unlock(ldv_func_arg1);
#line 1349
  return;
}
}
#line 1351 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_604(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1356
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1358
  mutex_unlock(ldv_func_arg1);
#line 1359
  return;
}
}
#line 1361 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_605(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1366
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1368
  mutex_lock(ldv_func_arg1);
#line 1369
  return;
}
}
#line 1371 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1376
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1378
  mutex_unlock(ldv_func_arg1);
#line 1379
  return;
}
}
#line 1381 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_607(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1386
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1388
  mutex_lock(ldv_func_arg1);
#line 1389
  return;
}
}
#line 1391 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_608(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1396
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1398
  mutex_unlock(ldv_func_arg1);
#line 1399
  return;
}
}
#line 1401 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_609(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1406
  ldv_mutex_lock_goal_irq_mutex(ldv_func_arg1);
#line 1408
  mutex_lock(ldv_func_arg1);
#line 1409
  return;
}
}
#line 1411 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1416
  ldv_mutex_unlock_goal_irq_mutex(ldv_func_arg1);
#line 1418
  mutex_unlock(ldv_func_arg1);
#line 1419
  return;
}
}
#line 1421 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1426
  ldv_mutex_lock_goal_irq_mutex(ldv_func_arg1);
#line 1428
  mutex_lock(ldv_func_arg1);
#line 1429
  return;
}
}
#line 1431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1436
  ldv_mutex_unlock_goal_irq_mutex(ldv_func_arg1);
#line 1438
  mutex_unlock(ldv_func_arg1);
#line 1439
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_634(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_635(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_639(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_640(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_644(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_636(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_641(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) ;
#line 737 "include/drm/ttm/ttm_bo_api.h"
__inline static bool ttm_bo_is_reserved(struct ttm_buffer_object *bo ) 
{ 
  int tmp ;

  {
#line 739
  tmp = atomic_read((atomic_t const   *)(& bo->reserved));
#line 739
  return (tmp != 0);
}
}
#line 495 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) ;
#line 153 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 158
  vmaster = dev_priv->active_master;
#line 159
  bo = & buf->base;
#line 162
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 163
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 163
  if (tmp != 0L) {
#line 164
    return (ret);
  } else {

  }
#line 166
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 168
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 169
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 169
  if (tmp___0 != 0L) {
#line 170
    goto err;
  } else {

  }
#line 172
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
#line 174
  ttm_bo_unreserve(bo);
  err: 
#line 177
  ttm_write_unlock(& vmaster->lock);
#line 178
  return (ret);
}
}
#line 197 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement *placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 201
  vmaster = dev_priv->active_master;
#line 202
  bo = & buf->base;
#line 206
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 207
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 207
  if (tmp != 0L) {
#line 208
    return (ret);
  } else {

  }
#line 210
  if ((int )pin) {
#line 211
    vmw_execbuf_release_pinned_bo(dev_priv);
  } else {

  }
#line 213
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 214
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 214
  if (tmp___0 != 0L) {
#line 215
    goto err;
  } else {

  }
#line 224
  if ((int )pin) {
#line 225
    placement = & vmw_vram_gmr_ne_placement;
  } else {
#line 227
    placement = & vmw_vram_gmr_placement;
  }
#line 229
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
#line 230
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 230
  if (tmp___1 != 0L || ret == -512) {
#line 231
    goto err_unreserve;
  } else {

  }
#line 239
  if ((int )pin) {
#line 240
    placement = & vmw_vram_ne_placement;
  } else {
#line 242
    placement = & vmw_vram_placement;
  }
#line 244
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
  err_unreserve: 
#line 247
  ttm_bo_unreserve(bo);
  err: 
#line 249
  ttm_write_unlock(& vmaster->lock);
#line 250
  return (ret);
}
}
#line 268 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) 
{ 
  struct ttm_placement *placement ;
  int tmp ;

  {
#line 274
  if ((int )pin) {
#line 275
    placement = & vmw_vram_ne_placement;
  } else {
#line 277
    placement = & vmw_vram_placement;
  }
#line 279
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, placement, (int )interruptible);
#line 279
  return (tmp);
}
}
#line 300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 304
  vmaster = dev_priv->active_master;
#line 305
  bo = & buf->base;
#line 307
  ret = 0;
#line 309
  if ((int )pin) {
#line 310
    placement = vmw_vram_ne_placement;
  } else {
#line 312
    placement = vmw_vram_placement;
  }
#line 313
  placement.lpfn = (unsigned int )bo->num_pages;
#line 315
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 316
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 316
  if (tmp != 0L) {
#line 317
    return (ret);
  } else {

  }
#line 319
  if ((int )pin) {
#line 320
    vmw_execbuf_release_pinned_bo(dev_priv);
  } else {

  }
#line 321
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 322
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 322
  if (tmp___0 != 0L) {
#line 323
    goto err_unlock;
  } else {

  }
#line 326
  if ((bo->mem.mem_type == 2U && bo->mem.start < bo->num_pages) && bo->mem.start != 0UL) {
#line 329
    ttm_bo_validate(bo, & vmw_sys_placement, 0, 0);
  } else {

  }
#line 331
  ret = ttm_bo_validate(bo, & placement, (int )interruptible, 0);
#line 334
  __ret_warn_on = ret == 0 && bo->offset != 0UL;
#line 334
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 334
  if (tmp___1 != 0L) {
#line 334
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared",
                       334);
  } else {

  }
#line 334
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 336
  ttm_bo_unreserve(bo);
  err_unlock: 
#line 338
  ttm_write_unlock(& vmaster->lock);
#line 340
  return (ret);
}
}
#line 358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) 
{ 
  int tmp ;

  {
#line 367
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, & vmw_evictable_placement, (int )interruptible);
#line 367
  return (tmp);
}
}
#line 380 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) 
{ 


  {
#line 383
  if ((unsigned int )bo->mem.mem_type == 2U) {
#line 384
    ptr->gmrId = 4294967294U;
#line 385
    ptr->offset = (uint32 )bo->offset;
  } else {
#line 387
    ptr->gmrId = (uint32 )bo->mem.start;
#line 388
    ptr->offset = 0U;
  }
#line 390
  return;
}
}
#line 401 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) 
{ 
  uint32_t pl_flags ;
  struct ttm_placement placement ;
  uint32_t old_mem_type ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 405
  old_mem_type = bo->mem.mem_type;
#line 408
  tmp = ttm_bo_is_reserved(bo);
#line 408
  if (tmp) {
#line 408
    tmp___0 = 0;
  } else {
#line 408
    tmp___0 = 1;
  }
#line 408
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 408
  if (tmp___1 != 0L) {
#line 408
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                         "i" (408), "i" (12UL));
    ldv_40551: ;
#line 408
    goto ldv_40551;
  } else {

  }
#line 409
  tmp___2 = ldv__builtin_expect(old_mem_type != 2U, 0L);
#line 409
  if (tmp___2 != 0L) {
#line 409
    tmp___3 = ldv__builtin_expect(old_mem_type != 3U, 0L);
#line 409
    if (tmp___3 != 0L) {
#line 409
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (410), "i" (12UL));
      ldv_40552: ;
#line 409
      goto ldv_40552;
    } else {

    }
  } else {

  }
#line 412
  pl_flags = 65548U;
#line 413
  if ((int )pin) {
#line 414
    pl_flags = pl_flags | 2097152U;
  } else {

  }
#line 416
  memset((void *)(& placement), 0, 40UL);
#line 417
  placement.num_placement = 1U;
#line 418
  placement.placement = (uint32_t const   *)(& pl_flags);
#line 420
  ret = ttm_bo_validate(bo, & placement, 0, 1);
#line 422
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 422
  if (tmp___4 != 0L) {
#line 422
    goto _L;
  } else {
#line 422
    tmp___5 = ldv__builtin_expect(bo->mem.mem_type != old_mem_type, 0L);
#line 422
    if (tmp___5 != 0L) {
      _L: /* CIL Label */ 
#line 422
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (422), "i" (12UL));
      ldv_40553: ;
#line 422
      goto ldv_40553;
    } else {

    }
  }
#line 424
  return;
}
}
#line 425 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 430
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 432
  mutex_lock(ldv_func_arg1);
#line 433
  return;
}
}
#line 435 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 450
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 452
  mutex_lock(ldv_func_arg1);
#line 453
  return;
}
}
#line 455 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int ldv_mutex_trylock_634(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 460
  tmp = mutex_trylock(ldv_func_arg1);
#line 460
  ldv_func_res = tmp;
#line 462
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 462
  return (tmp___0);
#line 464
  return (ldv_func_res);
}
}
#line 467 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_635(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_636(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 482
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 484
  mutex_lock(ldv_func_arg1);
#line 485
  return;
}
}
#line 487 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 492
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 494
  mutex_unlock(ldv_func_arg1);
#line 495
  return;
}
}
#line 497 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 502
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 504
  mutex_lock(ldv_func_arg1);
#line 505
  return;
}
}
#line 507 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_639(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 514
  mutex_unlock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_640(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 522
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 524
  mutex_unlock(ldv_func_arg1);
#line 525
  return;
}
}
#line 527 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_641(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 532
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 534
  mutex_lock(ldv_func_arg1);
#line 535
  return;
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 544
  mutex_unlock(ldv_func_arg1);
#line 545
  return;
}
}
#line 547 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 552
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 554
  mutex_lock(ldv_func_arg1);
#line 555
  return;
}
}
#line 557 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_644(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 562
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 564
  mutex_unlock(ldv_func_arg1);
#line 565
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_662(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_663(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_665(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_667(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_672(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_661(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_666(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_671(struct mutex *ldv_func_arg1 ) ;
#line 161 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_destroy(struct vmw_screen_object_unit *sou ) 
{ 


  {
#line 163
  vmw_display_unit_cleanup(& sou->base);
#line 164
  kfree((void const   *)sou);
#line 165
  return;
}
}
#line 172 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc  const  *__mptr ;

  {
#line 174
  __mptr = (struct drm_crtc  const  *)crtc;
#line 174
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr);
#line 176
  return;
}
}
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_del_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ) 
{ 
  struct vmw_screen_object_display *ld ;

  {
#line 180
  ld = vmw_priv___0->sou_priv;
#line 182
  if ((int )sou->active_implicit) {
#line 183
    ld->num_implicit = ld->num_implicit - 1U;
#line 183
    if (ld->num_implicit == 0U) {
#line 184
      ld->implicit_fb = 0;
    } else {

    }
#line 185
    sou->active_implicit = 0;
  } else {

  }
#line 187
  return;
}
}
#line 189 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_add_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ,
                               struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_screen_object_display *ld ;
  long tmp ;
  long tmp___0 ;

  {
#line 193
  ld = vmw_priv___0->sou_priv;
#line 195
  tmp = ldv__builtin_expect(ld->num_implicit == 0U, 0L);
#line 195
  if (tmp != 0L) {
#line 195
    tmp___0 = ldv__builtin_expect((unsigned long )ld->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 195
    if (tmp___0 != 0L) {
#line 195
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                           "i" (195), "i" (12UL));
      ldv_40752: ;
#line 195
      goto ldv_40752;
    } else {

    }
  } else {

  }
#line 197
  if (! sou->active_implicit && (int )sou->base.is_implicit) {
#line 198
    ld->implicit_fb = vfb;
#line 199
    sou->active_implicit = 1;
#line 200
    ld->num_implicit = ld->num_implicit + 1U;
  } else {

  }
#line 202
  return;
}
}
#line 207 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_create(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                               uint32_t x , uint32_t y , struct drm_display_mode *mode ) 
{ 
  size_t fifo_size ;
  struct __anonstruct_cmd_293 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 221
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 221
  if (tmp != 0L) {
#line 221
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (221), "i" (12UL));
    ldv_40767: ;
#line 221
    goto ldv_40767;
  } else {

  }
#line 223
  fifo_size = 48UL;
#line 224
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 224
  cmd = (struct __anonstruct_297___0 *)tmp___0;
#line 226
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_293 *)0),
                             0L);
#line 226
  if (tmp___1 != 0L) {
#line 227
    drm_err("vmw_sou_fifo_create", "Fifo reserve failed.\n");
#line 228
    return (-12);
  } else {

  }
#line 231
  memset((void *)cmd, 0, fifo_size);
#line 232
  cmd->header.cmdType = 34U;
#line 233
  cmd->obj.structSize = 44U;
#line 234
  cmd->obj.id = sou->base.unit;
#line 235
  cmd->obj.flags = sou->base.unit == 0U ? 3U : 1U;
#line 237
  cmd->obj.size.width = (uint32 )mode->hdisplay;
#line 238
  cmd->obj.size.height = (uint32 )mode->vdisplay;
#line 239
  if ((int )sou->base.is_implicit) {
#line 240
    cmd->obj.root.x = (int32 )x;
#line 241
    cmd->obj.root.y = (int32 )y;
  } else {
#line 243
    cmd->obj.root.x = sou->base.gui_x;
#line 244
    cmd->obj.root.y = sou->base.gui_y;
  }
#line 248
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& (sou->buffer)->base),
                       & cmd->obj.backingStore.ptr);
#line 249
  cmd->obj.backingStore.pitch = (uint32 )(mode->hdisplay * 4);
#line 251
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 253
  sou->defined = 1;
#line 255
  return (0);
}
}
#line 261 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_destroy(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ 
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_302 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 275
  tmp = ldv__builtin_expect((long )(! sou->defined), 0L);
#line 275
  if (tmp != 0L) {
#line 276
    return (0);
  } else {

  }
#line 278
  fifo_size = 8UL;
#line 279
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 279
  cmd = (struct __anonstruct_306 *)tmp___0;
#line 281
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_302 *)0),
                             0L);
#line 281
  if (tmp___1 != 0L) {
#line 282
    drm_err("vmw_sou_fifo_destroy", "Fifo reserve failed.\n");
#line 283
    return (-12);
  } else {

  }
#line 286
  memset((void *)cmd, 0, fifo_size);
#line 287
  cmd->header.cmdType = 35U;
#line 288
  cmd->body.screenId = sou->base.unit;
#line 290
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 293
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 750UL);
#line 294
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 294
  if (tmp___2 != 0L) {
#line 295
    drm_err("vmw_sou_fifo_destroy", "Failed to sync with HW");
  } else {
#line 297
    sou->defined = 0;
  }
#line 299
  return (ret);
}
}
#line 305 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_backing_free(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ 
  struct ttm_buffer_object *bo ;
  long tmp ;

  {
#line 310
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 310
  if (tmp != 0L) {
#line 311
    return;
  } else {

  }
#line 313
  bo = & (sou->buffer)->base;
#line 314
  ttm_bo_unref(& bo);
#line 315
  sou->buffer = 0;
#line 316
  sou->buffer_size = 0UL;
#line 317
  return;
}
}
#line 322 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_backing_alloc(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                                 unsigned long size ) 
{ 
  int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 328
  if (sou->buffer_size == size) {
#line 329
    return (0);
  } else {

  }
#line 331
  if ((unsigned long )sou->buffer != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 332
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 334
  tmp = kzalloc(440UL, 208U);
#line 334
  sou->buffer = (struct vmw_dma_buffer *)tmp;
#line 335
  tmp___0 = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 335
  if (tmp___0 != 0L) {
#line 336
    return (-12);
  } else {

  }
#line 341
  vmw_overlay_pause_all(dev_priv);
#line 342
  ret = vmw_dmabuf_init(dev_priv, sou->buffer, size, & vmw_vram_ne_placement, 0, & vmw_dmabuf_bo_free);
#line 345
  vmw_overlay_resume_all(dev_priv);
#line 347
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 347
  if (tmp___1 != 0L) {
#line 348
    sou->buffer = 0;
  } else {
#line 350
    sou->buffer_size = size;
  }
#line 352
  return (ret);
}
}
#line 355 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_screen_object_unit *sou ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int ret ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  long tmp ;
  long tmp___0 ;
  size_t size ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 365
  ret = 0;
#line 367
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 368
    return (-22);
  } else {

  }
#line 370
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 371
    return (-22);
  } else {

  }
#line 374
  crtc = set->crtc;
#line 375
  __mptr = (struct drm_crtc  const  *)crtc;
#line 375
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 376
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 376
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 376
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 376
    vfb = 0;
  }
#line 377
  dev_priv = vmw_priv(crtc->dev);
#line 379
  if (set->num_connectors > 1UL) {
#line 380
    drm_err("vmw_sou_crtc_set_config", "to many connectors\n");
#line 381
    return (-22);
  } else {

  }
#line 384
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& sou->base.connector)) {
#line 386
    drm_err("vmw_sou_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & sou->base.connector);
#line 388
    return (-22);
  } else {

  }
#line 392
  if (((((int )sou->base.is_implicit && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0)) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) && ((dev_priv->sou_priv)->num_implicit != 1U || ! sou->active_implicit)) && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )vfb) {
#line 397
    drm_err("vmw_sou_crtc_set_config", "Multiple framebuffers not supported\n");
#line 398
    return (-22);
  } else {

  }
#line 402
  connector = & sou->base.connector;
#line 403
  encoder = & sou->base.encoder;
#line 406
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 407
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 409
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 409
    if (tmp != 0L) {
#line 410
      return (ret);
    } else {

    }
#line 412
    connector->encoder = 0;
#line 413
    encoder->crtc = 0;
#line 414
    crtc->fb = 0;
#line 415
    crtc->x = 0;
#line 416
    crtc->y = 0;
#line 418
    vmw_sou_del_active(dev_priv, sou);
#line 420
    vmw_sou_backing_free(dev_priv, sou);
#line 422
    return (0);
  } else {

  }
#line 427
  mode = set->mode;
#line 428
  fb = set->fb;
#line 430
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 432
    drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
#line 433
    return (-22);
  } else {

  }
#line 436
  vmw_fb_off(dev_priv);
#line 438
  if (mode->hdisplay != crtc->mode.hdisplay || mode->vdisplay != crtc->mode.vdisplay) {
#line 444
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 446
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 446
    if (tmp___0 != 0L) {
#line 447
      return (ret);
    } else {

    }
#line 449
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 452
  if ((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 454
    size = (size_t )((mode->hdisplay * mode->vdisplay) * 4);
#line 455
    ret = vmw_sou_backing_alloc(dev_priv, sou, size);
#line 456
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 456
    if (tmp___1 != 0L) {
#line 457
      return (ret);
    } else {

    }
  } else {

  }
#line 460
  ret = vmw_sou_fifo_create(dev_priv, sou, set->x, set->y, mode);
#line 461
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 461
  if (tmp___2 != 0L) {
#line 469
    if ((int )sou->defined) {
#line 470
      return (ret);
    } else {

    }
#line 472
    connector->encoder = 0;
#line 473
    encoder->crtc = 0;
#line 474
    crtc->fb = 0;
#line 475
    crtc->x = 0;
#line 476
    crtc->y = 0;
#line 478
    return (ret);
  } else {

  }
#line 481
  vmw_sou_add_active(dev_priv, sou, vfb);
#line 483
  connector->encoder = encoder;
#line 484
  encoder->crtc = crtc;
#line 485
  crtc->mode = *mode;
#line 486
  crtc->fb = fb;
#line 487
  crtc->x = (int )set->x;
#line 488
  crtc->y = (int )set->y;
#line 490
  return (0);
}
}
#line 493 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_crtc_funcs vmw_screen_object_crtc_funcs  = 
#line 493
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_sou_crtc_destroy, & vmw_sou_crtc_set_config, & vmw_du_page_flip,
    0};
#line 508 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 510
  __mptr = (struct drm_encoder  const  *)encoder;
#line 510
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffca8UL);
#line 512
  return;
}
}
#line 513 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_encoder_funcs vmw_screen_object_encoder_funcs  =    {0, & vmw_sou_encoder_destroy};
#line 521 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_connector_destroy(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 523
  __mptr = (struct drm_connector  const  *)connector;
#line 523
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffc58UL);
#line 525
  return;
}
}
#line 526 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs___0  = 
#line 526
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_sou_connector_destroy, 0};
#line 536 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 539
  dev = dev_priv->dev;
#line 544
  tmp = kzalloc(2896UL, 208U);
#line 544
  sou = (struct vmw_screen_object_unit *)tmp;
#line 545
  if ((unsigned long )sou == (unsigned long )((struct vmw_screen_object_unit *)0)) {
#line 546
    return (-12);
  } else {

  }
#line 548
  sou->base.unit = unit;
#line 549
  crtc = & sou->base.crtc;
#line 550
  encoder = & sou->base.encoder;
#line 551
  connector = & sou->base.connector;
#line 553
  sou->active_implicit = 0;
#line 555
  sou->base.pref_active = unit == 0U;
#line 556
  sou->base.pref_width = dev_priv->initial_width;
#line 557
  sou->base.pref_height = dev_priv->initial_height;
#line 558
  sou->base.pref_mode = 0;
#line 559
  sou->base.is_implicit = 1;
#line 561
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs___0),
                     15);
#line 563
  connector->status = vmw_du_connector_detect(connector, 1);
#line 565
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_screen_object_encoder_funcs),
                   5);
#line 567
  drm_mode_connector_attach_encoder(connector, encoder);
#line 568
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 569
  encoder->possible_clones = 0U;
#line 571
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_screen_object_crtc_funcs));
#line 573
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 575
  drm_object_attach_property(& connector->base, dev->mode_config.dirty_info_property,
                             1ULL);
#line 579
  return (0);
}
}
#line 582 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 584
  dev = dev_priv->dev;
#line 587
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 588
    printk("\016[drm] sou system already on\n");
#line 589
    return (-22);
  } else {

  }
#line 592
  if ((dev_priv->capabilities & 8388608U) == 0U) {
#line 593
    printk("\016[drm] Not using screen objects, missing cap SCREEN_OBJECT_2\n");
#line 595
    return (-38);
  } else {

  }
#line 598
  ret = -12;
#line 599
  tmp = kmalloc(16UL, 208U);
#line 599
  dev_priv->sou_priv = (struct vmw_screen_object_display *)tmp;
#line 600
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 600
  if (tmp___0 != 0L) {
#line 601
    goto err_no_mem;
  } else {

  }
#line 603
  (dev_priv->sou_priv)->num_implicit = 0U;
#line 604
  (dev_priv->sou_priv)->implicit_fb = 0;
#line 606
  ret = drm_vblank_init(dev, 8);
#line 607
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 607
  if (tmp___1 != 0L) {
#line 608
    goto err_free;
  } else {

  }
#line 610
  ret = drm_mode_create_dirty_info_property(dev);
#line 611
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 611
  if (tmp___2 != 0L) {
#line 612
    goto err_vblank_cleanup;
  } else {

  }
#line 614
  i = 0;
#line 614
  goto ldv_40843;
  ldv_40842: 
#line 615
  vmw_sou_init(dev_priv, (unsigned int )i);
#line 614
  i = i + 1;
  ldv_40843: ;
#line 614
  if (i <= 7) {
#line 615
    goto ldv_40842;
  } else {

  }
#line 617
  printk("\016[drm] Screen objects system initialized\n");
#line 619
  return (0);
  err_vblank_cleanup: 
#line 622
  drm_vblank_cleanup(dev);
  err_free: 
#line 624
  kfree((void const   *)dev_priv->sou_priv);
#line 625
  dev_priv->sou_priv = 0;
  err_no_mem: ;
#line 627
  return (ret);
}
}
#line 630 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;

  {
#line 632
  dev = dev_priv->dev;
#line 634
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 635
    return (-38);
  } else {

  }
#line 637
  drm_vblank_cleanup(dev);
#line 639
  kfree((void const   *)dev_priv->sou_priv);
#line 641
  return (0);
}
}
#line 648 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;

  {
#line 651
  __mptr = (struct drm_crtc  const  *)crtc;
#line 651
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 653
  if (! sou->base.is_implicit) {
#line 654
    return (1);
  } else {

  }
#line 656
  if ((dev_priv->sou_priv)->num_implicit != 1U) {
#line 657
    return (0);
  } else {

  }
#line 659
  return (1);
}
}
#line 666 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;
  long tmp ;
  struct drm_framebuffer  const  *__mptr___0 ;

  {
#line 669
  __mptr = (struct drm_crtc  const  *)crtc;
#line 669
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 671
  tmp = ldv__builtin_expect((long )(! sou->base.is_implicit), 0L);
#line 671
  if (tmp != 0L) {
#line 671
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (671), "i" (12UL));
    ldv_40863: ;
#line 671
    goto ldv_40863;
  } else {

  }
#line 674
  __mptr___0 = (struct drm_framebuffer  const  *)sou->base.crtc.fb;
#line 674
  (dev_priv->sou_priv)->implicit_fb = (struct vmw_framebuffer *)__mptr___0;
#line 676
  return;
}
}
#line 714 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_main17_sequence_infinite_withcheck_stateful(void) 
{ 
  struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp ;
  int tmp___0 ;

  {
#line 776
  LDV_IN_INTERRUPT = 1;
#line 785
  ldv_initialize();
#line 793
  goto ldv_40893;
  ldv_40892: 
#line 796
  tmp = __VERIFIER_nondet_int();
#line 796
  switch (tmp) {
  case 0: 
#line 813
  ldv_handler_precall();
#line 814
  vmw_sou_crtc_destroy(var_group1);
#line 821
  goto ldv_40887;
  case 1: 
#line 837
  ldv_handler_precall();
#line 838
  vmw_sou_crtc_set_config(var_group2);
#line 845
  goto ldv_40887;
  case 2: 
#line 861
  ldv_handler_precall();
#line 862
  vmw_sou_encoder_destroy(var_group3);
#line 869
  goto ldv_40887;
  case 3: 
#line 885
  ldv_handler_precall();
#line 886
  vmw_sou_connector_destroy(var_group4);
#line 893
  goto ldv_40887;
  default: ;
#line 894
  goto ldv_40887;
  }
  ldv_40887: ;
  ldv_40893: 
#line 793
  tmp___0 = __VERIFIER_nondet_int();
#line 793
  if (tmp___0 != 0) {
#line 794
    goto ldv_40892;
  } else {

  }


#line 903
  ldv_check_final_state();
#line 906
  return;
}
}
#line 910 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 915
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 917
  mutex_lock(ldv_func_arg1);
#line 918
  return;
}
}
#line 920 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 925
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 927
  mutex_unlock(ldv_func_arg1);
#line 928
  return;
}
}
#line 930 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_661(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 935
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 937
  mutex_lock(ldv_func_arg1);
#line 938
  return;
}
}
#line 940 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldv_mutex_trylock_662(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 945
  tmp = mutex_trylock(ldv_func_arg1);
#line 945
  ldv_func_res = tmp;
#line 947
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 947
  return (tmp___0);
#line 949
  return (ldv_func_res);
}
}
#line 952 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_663(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 957
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 959
  mutex_unlock(ldv_func_arg1);
#line 960
  return;
}
}
#line 962 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 967
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 969
  mutex_lock(ldv_func_arg1);
#line 970
  return;
}
}
#line 972 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_665(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 977
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 979
  mutex_unlock(ldv_func_arg1);
#line 980
  return;
}
}
#line 982 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_666(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 987
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 989
  mutex_lock(ldv_func_arg1);
#line 990
  return;
}
}
#line 992 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_667(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 997
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 999
  mutex_unlock(ldv_func_arg1);
#line 1000
  return;
}
}
#line 1002 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1007
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1009
  mutex_unlock(ldv_func_arg1);
#line 1010
  return;
}
}
#line 1012 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1017
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1019
  mutex_lock(ldv_func_arg1);
#line 1020
  return;
}
}
#line 1022 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1027
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1029
  mutex_unlock(ldv_func_arg1);
#line 1030
  return;
}
}
#line 1032 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_671(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1037
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1039
  mutex_lock(ldv_func_arg1);
#line 1040
  return;
}
}
#line 1042 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_672(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1047
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1049
  mutex_unlock(ldv_func_arg1);
#line 1050
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_690(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_693(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_696(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_700(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_687(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_694(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) ;
#line 421 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) ;
#line 141 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_free(struct vmw_resource *res ) ;
#line 143
static struct vmw_resource *vmw_user_context_base_to_res(struct ttm_base_object *base ) ;
#line 145 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static uint64_t vmw_user_context_size  ;
#line 147 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_user_resource_conv  const  user_context_conv  =    {256, & vmw_user_context_base_to_res, & vmw_user_context_free};
#line 153 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct vmw_user_resource_conv  const  *user_context_converter  =    & user_context_conv;
#line 157 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_res_func  const  vmw_legacy_context_func  = 
#line 157
     {0, 0, "legacy contexts", 0, 0, 0, 0, 0, 0};
#line 173 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_hw_context_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct __anonstruct_cmd_291___2 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 176
  dev_priv = res->dev_priv;
#line 183
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 184
  tmp = vmw_fifo_reserve(dev_priv, 12U);
#line 184
  cmd = (struct __anonstruct_293___1 *)tmp;
#line 185
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___2 *)0),
                             0L);
#line 185
  if (tmp___0 != 0L) {
#line 186
    drm_err("vmw_hw_context_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 188
    return;
  } else {

  }
#line 191
  cmd->header.id = 1046U;
#line 192
  cmd->header.size = 4U;
#line 193
  cmd->body.cid = (unsigned int )res->id;
#line 195
  vmw_fifo_commit(dev_priv, 12U);
#line 196
  vmw_3d_resource_dec(dev_priv, 0);
#line 197
  return;
}
}
#line 199 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static int vmw_context_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                            void (*res_free)(struct vmw_resource * ) ) 
{ 
  int ret ;
  struct __anonstruct_cmd_295___0 *cmd ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 210
  ret = vmw_resource_init(dev_priv, res, 0, res_free, & vmw_legacy_context_func);
#line 213
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 213
  if (tmp != 0L) {
#line 214
    drm_err("vmw_context_init", "Failed to allocate a resource id.\n");
#line 215
    goto out_early;
  } else {

  }
#line 218
  tmp___0 = ldv__builtin_expect(res->id > 255, 0L);
#line 218
  if (tmp___0 != 0L) {
#line 219
    drm_err("vmw_context_init", "Out of hw context ids.\n");
#line 220
    vmw_resource_unreference(& res);
#line 221
    return (-12);
  } else {

  }
#line 224
  tmp___1 = vmw_fifo_reserve(dev_priv, 12U);
#line 224
  cmd = (struct __anonstruct_297___1 *)tmp___1;
#line 225
  tmp___2 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_295___0 *)0),
                             0L);
#line 225
  if (tmp___2 != 0L) {
#line 226
    drm_err("vmw_context_init", "Fifo reserve failed.\n");
#line 227
    vmw_resource_unreference(& res);
#line 228
    return (-12);
  } else {

  }
#line 231
  cmd->header.id = 1045U;
#line 232
  cmd->header.size = 4U;
#line 233
  cmd->body.cid = (unsigned int )res->id;
#line 235
  vmw_fifo_commit(dev_priv, 12U);
#line 236
  vmw_3d_resource_inc(dev_priv, 0);
#line 237
  vmw_resource_activate(res, & vmw_hw_context_destroy);
#line 238
  return (0);
  out_early: ;
#line 241
  if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 242
    kfree((void const   *)res);
  } else {
#line 244
    (*res_free)(res);
  }
#line 245
  return (ret);
}
}
#line 248 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) 
{ 
  struct vmw_resource *res ;
  void *tmp ;
  int ret ;
  long tmp___0 ;

  {
#line 250
  tmp = kmalloc(112UL, 208U);
#line 250
  res = (struct vmw_resource *)tmp;
#line 253
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 253
  if (tmp___0 != 0L) {
#line 254
    return (0);
  } else {

  }
#line 256
  ret = vmw_context_init(dev_priv, res, 0);
#line 258
  return (ret == 0 ? res : 0);
}
}
#line 266 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_resource *vmw_user_context_base_to_res(struct ttm_base_object *base ) 
{ 
  struct ttm_base_object  const  *__mptr ;

  {
#line 268
  __mptr = (struct ttm_base_object  const  *)base;
#line 268
  return (& ((struct vmw_user_context *)__mptr)->res);
}
}
#line 271 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_free(struct vmw_resource *res ) 
{ 
  struct vmw_user_context *ctx ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 274
  __mptr = (struct vmw_resource  const  *)res;
#line 274
  ctx = (struct vmw_user_context *)__mptr + 0xffffffffffffffb0UL;
#line 275
  dev_priv = res->dev_priv;
#line 277
  kfree_call_rcu(& ctx->base.rhead, 0);
#line 278
  tmp = vmw_mem_glob(dev_priv);
#line 278
  ttm_mem_global_free(tmp, vmw_user_context_size);
#line 279
  return;
}
}
#line 287 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_context *ctx ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 289
  base = *p_base;
#line 291
  __mptr = (struct ttm_base_object  const  *)base;
#line 291
  ctx = (struct vmw_user_context *)__mptr;
#line 292
  res = & ctx->res;
#line 294
  *p_base = 0;
#line 295
  vmw_resource_unreference(& res);
#line 296
  return;
}
}
#line 298 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 301
  arg = (struct drm_vmw_context_arg *)data;
#line 302
  tmp = vmw_fpriv(file_priv);
#line 302
  tfile = tmp->tfile;
#line 304
  tmp___0 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->cid, 0);
#line 304
  return (tmp___0);
}
}
#line 307 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 310
  tmp = vmw_priv(dev);
#line 310
  dev_priv = tmp;
#line 314
  arg = (struct drm_vmw_context_arg *)data;
#line 315
  tmp___1 = vmw_fpriv(file_priv);
#line 315
  tfile = tmp___1->tfile;
#line 316
  tmp___2 = vmw_master(file_priv->master);
#line 316
  vmaster = tmp___2;
#line 325
  tmp___4 = ldv__builtin_expect(vmw_user_context_size == 0ULL, 0L);
#line 325
  if (tmp___4 != 0L) {
#line 326
    tmp___3 = ttm_round_pot(192UL);
#line 326
    vmw_user_context_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 328
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 329
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 329
  if (tmp___5 != 0L) {
#line 330
    return (ret);
  } else {

  }
#line 332
  tmp___6 = vmw_mem_glob(dev_priv);
#line 332
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_context_size, 0, 1);
#line 335
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 335
  if (tmp___7 != 0L) {
#line 336
    if (ret != -512) {
#line 337
      drm_err("vmw_context_define_ioctl", "Out of graphics memory for context creation.\n");
    } else {

    }
#line 339
    goto out_unlock;
  } else {

  }
#line 342
  tmp___8 = kzalloc(192UL, 208U);
#line 342
  ctx = (struct vmw_user_context *)tmp___8;
#line 343
  tmp___10 = ldv__builtin_expect((unsigned long )ctx == (unsigned long )((struct vmw_user_context *)0),
                              0L);
#line 343
  if (tmp___10 != 0L) {
#line 344
    tmp___9 = vmw_mem_glob(dev_priv);
#line 344
    ttm_mem_global_free(tmp___9, vmw_user_context_size);
#line 346
    ret = -12;
#line 347
    goto out_unlock;
  } else {

  }
#line 350
  res = & ctx->res;
#line 351
  ctx->base.shareable = 0;
#line 352
  ctx->base.tfile = 0;
#line 358
  ret = vmw_context_init(dev_priv, res, & vmw_user_context_free);
#line 359
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 359
  if (tmp___11 != 0L) {
#line 360
    goto out_unlock;
  } else {

  }
#line 362
  tmp___0 = vmw_resource_reference(& ctx->res);
#line 363
  ret = ttm_base_object_init(tfile, & ctx->base, 0, 256, & vmw_user_context_base_release,
                             0);
#line 366
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 366
  if (tmp___12 != 0L) {
#line 367
    vmw_resource_unreference(& tmp___0);
#line 368
    goto out_err;
  } else {

  }
#line 371
  arg->cid = (int32_t )ctx->base.hash.key;
  out_err: 
#line 373
  vmw_resource_unreference(& res);
  out_unlock: 
#line 375
  ttm_read_unlock(& vmaster->lock);
#line 376
  return (ret);
}
}
#line 417 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_main18_sequence_infinite_withcheck_stateful(void) 
{ 
  struct ttm_base_object *var_group1 ;
  struct vmw_resource *var_group2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 439
  LDV_IN_INTERRUPT = 1;
#line 448
  ldv_initialize();
#line 452
  goto ldv_40633;
  ldv_40632: 
#line 455
  tmp = __VERIFIER_nondet_int();
#line 455
  switch (tmp) {
  case 0: 
#line 465
  ldv_handler_precall();
#line 466
  vmw_user_context_base_to_res(var_group1);
#line 473
  goto ldv_40629;
  case 1: 
#line 482
  ldv_handler_precall();
#line 483
  vmw_user_context_free(var_group2);
#line 490
  goto ldv_40629;
  default: ;
#line 491
  goto ldv_40629;
  }
  ldv_40629: ;
  ldv_40633: 
#line 452
  tmp___0 = __VERIFIER_nondet_int();
#line 452
  if (tmp___0 != 0) {
#line 453
    goto ldv_40632;
  } else {

  }


#line 500
  ldv_check_final_state();
#line 503
  return;
}
}
#line 507 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_687(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 522
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 524
  mutex_unlock(ldv_func_arg1);
#line 525
  return;
}
}
#line 527 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 532
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 534
  mutex_lock(ldv_func_arg1);
#line 535
  return;
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int ldv_mutex_trylock_690(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 542
  tmp = mutex_trylock(ldv_func_arg1);
#line 542
  ldv_func_res = tmp;
#line 544
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 544
  return (tmp___0);
#line 546
  return (ldv_func_res);
}
}
#line 549 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 554
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 556
  mutex_unlock(ldv_func_arg1);
#line 557
  return;
}
}
#line 559 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 564
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 566
  mutex_lock(ldv_func_arg1);
#line 567
  return;
}
}
#line 569 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_693(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 574
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 576
  mutex_unlock(ldv_func_arg1);
#line 577
  return;
}
}
#line 579 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_694(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 584
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 586
  mutex_lock(ldv_func_arg1);
#line 587
  return;
}
}
#line 589 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 594
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 596
  mutex_unlock(ldv_func_arg1);
#line 597
  return;
}
}
#line 599 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_696(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 604
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 606
  mutex_unlock(ldv_func_arg1);
#line 607
  return;
}
}
#line 609 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 614
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 616
  mutex_lock(ldv_func_arg1);
#line 617
  return;
}
}
#line 619 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 624
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 626
  mutex_unlock(ldv_func_arg1);
#line 627
  return;
}
}
#line 629 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 634
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 636
  mutex_lock(ldv_func_arg1);
#line 637
  return;
}
}
#line 639 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_700(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 646
  mutex_unlock(ldv_func_arg1);
#line 647
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_721(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_724(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_726(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_728(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_720(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_725(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_727(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_729(struct mutex *ldv_func_arg1 ) ;
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
static struct svga3d_surface_desc  const  svga3d_surface_descs[121U]  = 
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
  {      {0, {1U, 1U, 1U, 0U}, 0U, 0U, {0U, {{0U}, {0U}, {0U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {16U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {6U}, {5U}, {0U}}}, {{{0U}, {5U},
                                                                      {11U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 2U, 2U, {15U, {{5U}, {5U}, {5U}, {0U}}}, {{{0U}, {5U}, {10U},
                                                                   {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {5U}, {5U}, {1U}}}, {{{0U}, {5U},
                                                                       {10U}, {15U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{4U}, {4U}, {4U}, {4U}}}, {{{0U}, {4U}, {8U},
                                                                   {12U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {1U}, {15U}, {0U}}}, {{{0U}, {15U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {12, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {4U}, {4U}}}, {{{0U}, {0U},
                                                                      {0U}, {4U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {12, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {8U}, {8U}}}, {{{0U}, {0U},
                                                                       {0U}, {8U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U},
                                                                            {0U},
                                                                            {0U},
                                                                            {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {8U}, {8U}}}, {{{0U}, {0U}, {0U},
                                                                   {8U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {5U}, {6U}, {0U}}}, {{{11U}, {6U},
                                                                      {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 3U, 3U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {79,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {79,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {8U}, {0U}, {0U}}}, {{{8U}, {0U}, {0U},
                                                                   {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{24U}, {16U},
                                                                       {8U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {8U}, {0U}, {0U}}}, {{{8U}, {0U}, {0U},
                                                                   {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {8,
      {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {0U}, {8U}}}, {{{0U}, {0U}, {0U},
                                                                  {0U}}}}, 
        {68, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {68,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {70, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                         {0U}, {0U}}}}, 
        {70,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {16,
      {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                  {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{16U}, {16U}, {0U}, {0U}}}, {{{16U}, {0U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {0U}, {16U},
                                                                     {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U},
                                                                           {16U},
                                                                           {0U}, {48U}}}}, 
        {132,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {8U},
                                                                   {0U}}}}, 
        {132, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {0U}, {8U}, {0U}}}, {{{8U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {8448,
      {2U, 2U, 1U, 0U}, 6U, 2U, {48U, {{0U}, {0U}, {48U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {1548, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {71,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {32U}, {0U}}}, {{{0U}, {32U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                       {0U}, {0U}}}}, 
        {68,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {2, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {0U}, {0U}}}, {{{0U}, {32U},
                                                                      {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {71,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {11U}, {11U}, {0U}}}, {{{0U}, {10U},
                                                                      {21U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U},
                                                                       {0U}, {24U}}}}, 
        {4111,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U},
                                                                       {0U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                        {0U}, {0U}}}}, 
        {70,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                     {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                     {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {24U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {2, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {0U}, {0U}}}, {{{0U}, {24U},
                                                                      {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {3, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {1,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {8U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {2055, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{9U}, {9U}, {9U}, {5U}}}, {{{18U}, {9U},
                                                                         {0U}, {27U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4128, {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U},
                                                                          {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {4128,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {4128,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U},
                                                                            {0U},
                                                                            {0U},
                                                                            {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {4111, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {4103, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U}, {0U},
                                                                    {0U}}}}};
#line 705 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 clamped_umul32(u32 a , u32 b ) 
{ 
  uint64_t tmp ;

  {
#line 707
  tmp = (unsigned long long )a * (unsigned long long )b;
#line 708
  return ((u32 )(4294967295ULL < tmp ? 4294967295ULL : tmp));
}
}
#line 712 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static struct svga3d_surface_desc  const  *svga3dsurface_get_desc(SVGA3dSurfaceFormat format ) 
{ 


  {
#line 714
  if ((unsigned int )format <= 120U) {
#line 715
    return ((struct svga3d_surface_desc  const  *)(& svga3d_surface_descs) + (unsigned long )format);
  } else {

  }
#line 717
  return ((struct svga3d_surface_desc  const  *)(& svga3d_surface_descs));
}
}
#line 749 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static void svga3dsurface_get_size_in_blocks(struct svga3d_surface_desc  const  *desc ,
                                                      struct drm_vmw_size  const  *pixel_size ,
                                                      struct drm_vmw_size *block_size ) 
{ 


  {
#line 753
  block_size->width = (((unsigned int )pixel_size->width + (unsigned int )desc->block_size.width) - 1U) / (unsigned int )desc->block_size.width;
#line 755
  block_size->height = (((unsigned int )pixel_size->height + (unsigned int )desc->block_size.height) - 1U) / (unsigned int )desc->block_size.height;
#line 757
  block_size->depth = (((unsigned int )pixel_size->depth + (unsigned int )desc->block_size.depth) - 1U) / (unsigned int )desc->block_size.depth;
#line 758
  return;
}
}
#line 762 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static bool svga3dsurface_is_planar_surface(struct svga3d_surface_desc  const  *desc ) 
{ 


  {
#line 764
  return (((unsigned int )desc->block_desc & 256U) != 0U);
}
}
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 svga3dsurface_calculate_pitch(struct svga3d_surface_desc  const  *desc ,
                                                  struct drm_vmw_size  const  *size ) 
{ 
  u32 pitch ;
  struct drm_vmw_size blocks ;

  {
#line 774
  svga3dsurface_get_size_in_blocks(desc, size, & blocks);
#line 776
  pitch = blocks.width * (uint32_t )desc->pitch_bytes_per_block;
#line 778
  return (pitch);
}
}
#line 804 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 svga3dsurface_get_image_buffer_size(struct svga3d_surface_desc  const  *desc ,
                                                        struct drm_vmw_size  const  *size ,
                                                        u32 pitch ) 
{ 
  struct drm_vmw_size image_blocks ;
  u32 slice_size ;
  u32 total_size ;
  bool tmp ;

  {
#line 811
  svga3dsurface_get_size_in_blocks(desc, size, & image_blocks);
#line 813
  tmp = svga3dsurface_is_planar_surface(desc);
#line 813
  if ((int )tmp) {
#line 814
    total_size = clamped_umul32(image_blocks.width, image_blocks.height);
#line 816
    total_size = clamped_umul32(total_size, image_blocks.depth);
#line 817
    total_size = clamped_umul32(total_size, desc->bytes_per_block);
#line 818
    return (total_size);
  } else {

  }
#line 821
  if (pitch == 0U) {
#line 822
    pitch = svga3dsurface_calculate_pitch(desc, size);
  } else {

  }
#line 824
  slice_size = clamped_umul32(image_blocks.height, pitch);
#line 825
  total_size = clamped_umul32(slice_size, image_blocks.depth);
#line 827
  return (total_size);
}
}
#line 165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_free(struct vmw_resource *res ) ;
#line 167
static struct vmw_resource *vmw_user_surface_base_to_res(struct ttm_base_object *base ) ;
#line 168
static int vmw_legacy_srf_bind(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) ;
#line 170
static int vmw_legacy_srf_unbind(struct vmw_resource *res , bool readback , struct ttm_validate_buffer *val_buf ) ;
#line 173
static int vmw_legacy_srf_create(struct vmw_resource *res ) ;
#line 174
static int vmw_legacy_srf_destroy(struct vmw_resource *res ) ;
#line 176 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_user_resource_conv  const  user_surface_conv  =    {257, & vmw_user_surface_base_to_res, & vmw_user_surface_free};
#line 182 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_user_resource_conv  const  *user_surface_converter  =    & user_surface_conv;
#line 186 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static uint64_t vmw_user_surface_size  ;
#line 188 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_res_func  const  vmw_legacy_surface_func  = 
#line 188
     {1, 0, "legacy surfaces", & vmw_srf_placement, 1, & vmw_legacy_srf_create, & vmw_legacy_srf_destroy,
    & vmw_legacy_srf_bind, & vmw_legacy_srf_unbind};
#line 235 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_dma_size(struct vmw_surface  const  *srf ) 
{ 


  {
#line 237
  return ((uint32_t )srf->num_sizes * 84U);
}
}
#line 249 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_define_size(struct vmw_surface  const  *srf ) 
{ 


  {
#line 251
  return ((uint32_t )srf->num_sizes * 12U + 44U);
}
}
#line 262 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_destroy_size(void) 
{ 


  {
#line 264
  return (12U);
}
}
#line 273 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_destroy_encode(uint32_t id , void *cmd_space ) 
{ 
  struct vmw_surface_destroy *cmd ;

  {
#line 276
  cmd = (struct vmw_surface_destroy *)cmd_space;
#line 279
  cmd->header.id = 1041U;
#line 280
  cmd->header.size = 4U;
#line 281
  cmd->body.sid = id;
#line 282
  return;
}
}
#line 290 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_define_encode(struct vmw_surface  const  *srf , void *cmd_space ) 
{ 
  struct vmw_surface_define *cmd ;
  struct drm_vmw_size *src_size ;
  SVGA3dSize *cmd_size ;
  uint32_t cmd_len ;
  int i ;

  {
#line 293
  cmd = (struct vmw_surface_define *)cmd_space;
#line 300
  cmd_len = (uint32_t )srf->num_sizes * 12U + 36U;
#line 302
  cmd->header.id = 1040U;
#line 303
  cmd->header.size = cmd_len;
#line 304
  cmd->body.sid = (uint32 )srf->res.id;
#line 305
  cmd->body.surfaceFlags = (SVGA3dSurfaceFlags )srf->flags;
#line 306
  cmd->body.format = (SVGA3dSurfaceFormat )srf->format;
#line 307
  i = 0;
#line 307
  goto ldv_40801;
  ldv_40800: 
#line 308
  cmd->body.face[i].numMipLevels = srf->mip_levels[i];
#line 307
  i = i + 1;
  ldv_40801: ;
#line 307
  if (i <= 5) {
#line 308
    goto ldv_40800;
  } else {

  }
#line 310
  cmd = cmd + 1UL;
#line 311
  cmd_size = (SVGA3dSize *)cmd;
#line 312
  src_size = srf->sizes;
#line 314
  i = 0;
#line 314
  goto ldv_40804;
  ldv_40803: 
#line 315
  cmd_size->width = src_size->width;
#line 316
  cmd_size->height = src_size->height;
#line 317
  cmd_size->depth = src_size->depth;
#line 314
  i = i + 1;
#line 314
  cmd_size = cmd_size + 1;
#line 314
  src_size = src_size + 1;
  ldv_40804: ;
#line 314
  if ((unsigned int )i < (unsigned int )srf->num_sizes) {
#line 315
    goto ldv_40803;
  } else {

  }

#line 319
  return;
}
}
#line 330 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_dma_encode(struct vmw_surface *srf , void *cmd_space , SVGAGuestPtr const   *ptr ,
                                   bool to_surface ) 
{ 
  uint32_t i ;
  struct vmw_surface_dma *cmd ;
  struct svga3d_surface_desc  const  *desc ;
  struct svga3d_surface_desc  const  *tmp ;
  SVGA3dCmdHeader *header ;
  SVGA3dCmdSurfaceDMA *body ;
  SVGA3dCopyBox *cb ;
  SVGA3dCmdSurfaceDMASuffix *suffix ;
  struct vmw_surface_offset  const  *cur_offset ;
  struct drm_vmw_size  const  *cur_size ;

  {
#line 336
  cmd = (struct vmw_surface_dma *)cmd_space;
#line 337
  tmp = svga3dsurface_get_desc((SVGA3dSurfaceFormat )srf->format);
#line 337
  desc = tmp;
#line 340
  i = 0U;
#line 340
  goto ldv_40822;
  ldv_40821: 
#line 341
  header = & cmd->header;
#line 342
  body = & cmd->body;
#line 343
  cb = & cmd->cb;
#line 344
  suffix = & cmd->suffix;
#line 345
  cur_offset = (struct vmw_surface_offset  const  *)srf->offsets + (unsigned long )i;
#line 346
  cur_size = (struct drm_vmw_size  const  *)srf->sizes + (unsigned long )i;
#line 348
  header->id = 1044U;
#line 349
  header->size = 76U;
#line 351
  body->guest.ptr = *ptr;
#line 352
  body->guest.ptr.offset = body->guest.ptr.offset + (uint32 )cur_offset->bo_offset;
#line 353
  body->guest.pitch = svga3dsurface_calculate_pitch(desc, cur_size);
#line 355
  body->host.sid = (uint32 )srf->res.id;
#line 356
  body->host.face = cur_offset->face;
#line 357
  body->host.mipmap = cur_offset->mip;
#line 358
  body->transfer = (int )to_surface ? 1 : 2;
#line 360
  cb->x = 0U;
#line 361
  cb->y = 0U;
#line 362
  cb->z = 0U;
#line 363
  cb->srcx = 0U;
#line 364
  cb->srcy = 0U;
#line 365
  cb->srcz = 0U;
#line 366
  cb->w = cur_size->width;
#line 367
  cb->h = cur_size->height;
#line 368
  cb->d = cur_size->depth;
#line 370
  suffix->suffixSize = 12U;
#line 371
  suffix->maximumOffset = svga3dsurface_get_image_buffer_size(desc, cur_size, body->guest.pitch);
#line 374
  suffix->flags.discard = 0U;
#line 375
  suffix->flags.unsynchronized = 0U;
#line 376
  suffix->flags.reserved = 0U;
#line 377
  cmd = cmd + 1;
#line 340
  i = i + 1U;
  ldv_40822: ;
#line 340
  if (srf->num_sizes > i) {
#line 341
    goto ldv_40821;
  } else {

  }

#line 345
  return;
}
}
#line 391 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_hw_surface_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  void *cmd ;
  uint32_t tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 394
  dev_priv = res->dev_priv;
#line 398
  if (res->id != -1) {
#line 400
    tmp = vmw_surface_destroy_size();
#line 400
    cmd = vmw_fifo_reserve(dev_priv, tmp);
#line 401
    tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0),
                               0L);
#line 401
    if (tmp___0 != 0L) {
#line 402
      drm_err("vmw_hw_surface_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 404
      return;
    } else {

    }
#line 407
    vmw_surface_destroy_encode((uint32_t )res->id, cmd);
#line 408
    tmp___1 = vmw_surface_destroy_size();
#line 408
    vmw_fifo_commit(dev_priv, tmp___1);
#line 416
    ldv_mutex_lock_729(& dev_priv->cmdbuf_mutex);
#line 417
    srf = vmw_res_to_srf(res);
#line 418
    dev_priv->used_memory_size = dev_priv->used_memory_size - (uint32_t )res->backup_size;
#line 419
    ldv_mutex_unlock_730(& dev_priv->cmdbuf_mutex);
  } else {

  }
#line 421
  vmw_3d_resource_dec(dev_priv, 0);
#line 422
  return;
}
}
#line 437 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_create(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;

  {
#line 439
  dev_priv = res->dev_priv;
#line 445
  tmp = ldv__builtin_expect(res->id != -1, 1L);
#line 445
  if (tmp != 0L) {
#line 446
    return (0);
  } else {

  }
#line 448
  srf = vmw_res_to_srf(res);
#line 449
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->used_memory_size + res->backup_size >= (unsigned long )dev_priv->memory_size,
                             0L);
#line 449
  if (tmp___0 != 0L) {
#line 451
    return (-16);
  } else {

  }
#line 457
  ret = vmw_resource_alloc_id(res);
#line 458
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 458
  if (tmp___1 != 0L) {
#line 459
    drm_err("vmw_legacy_srf_create", "Failed to allocate a surface id.\n");
#line 460
    goto out_no_id;
  } else {

  }
#line 463
  tmp___2 = ldv__builtin_expect(res->id > 32767, 0L);
#line 463
  if (tmp___2 != 0L) {
#line 464
    ret = -16;
#line 465
    goto out_no_fifo;
  } else {

  }
#line 472
  submit_size = vmw_surface_define_size((struct vmw_surface  const  *)srf);
#line 473
  tmp___3 = vmw_fifo_reserve(dev_priv, submit_size);
#line 473
  cmd = (uint8_t *)tmp___3;
#line 474
  tmp___4 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 474
  if (tmp___4 != 0L) {
#line 475
    drm_err("vmw_legacy_srf_create", "Failed reserving FIFO space for surface creation.\n");
#line 477
    ret = -12;
#line 478
    goto out_no_fifo;
  } else {

  }
#line 481
  vmw_surface_define_encode((struct vmw_surface  const  *)srf, (void *)cmd);
#line 482
  vmw_fifo_commit(dev_priv, submit_size);
#line 487
  dev_priv->used_memory_size = dev_priv->used_memory_size + (uint32_t )res->backup_size;
#line 488
  return (0);
  out_no_fifo: 
#line 491
  vmw_resource_release_id(res);
  out_no_id: ;
#line 493
  return (ret);
}
}
#line 512 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_dma(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ,
                              bool bind ) 
{ 
  SVGAGuestPtr ptr ;
  struct vmw_fence_obj *fence ;
  uint32_t submit_size ;
  struct vmw_surface *srf ;
  struct vmw_surface *tmp ;
  uint8_t *cmd ;
  struct vmw_private *dev_priv ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 519
  tmp = vmw_res_to_srf(res);
#line 519
  srf = tmp;
#line 521
  dev_priv = res->dev_priv;
#line 523
  tmp___0 = ldv__builtin_expect((unsigned long )val_buf->bo == (unsigned long )((struct ttm_buffer_object *)0),
                             0L);
#line 523
  if (tmp___0 != 0L) {
#line 523
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (523), "i" (12UL));
    ldv_40853: ;
#line 523
    goto ldv_40853;
  } else {

  }
#line 525
  submit_size = vmw_surface_dma_size((struct vmw_surface  const  *)srf);
#line 526
  tmp___1 = vmw_fifo_reserve(dev_priv, submit_size);
#line 526
  cmd = (uint8_t *)tmp___1;
#line 527
  tmp___2 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 527
  if (tmp___2 != 0L) {
#line 528
    drm_err("vmw_legacy_srf_dma", "Failed reserving FIFO space for surface DMA.\n");
#line 530
    return (-12);
  } else {

  }
#line 532
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)val_buf->bo, & ptr);
#line 533
  vmw_surface_dma_encode(srf, (void *)cmd, (SVGAGuestPtr const   *)(& ptr), (int )bind);
#line 535
  vmw_fifo_commit(dev_priv, submit_size);
#line 541
  vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
#line 544
  vmw_fence_single_bo(val_buf->bo, fence);
#line 546
  tmp___3 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                             1L);
#line 546
  if (tmp___3 != 0L) {
#line 547
    vmw_fence_obj_unreference(& fence);
  } else {

  }
#line 549
  return (0);
}
}
#line 564 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_bind(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) 
{ 
  int tmp ;

  {
#line 567
  if (! res->backup_dirty) {
#line 568
    return (0);
  } else {

  }
#line 570
  tmp = vmw_legacy_srf_dma(res, val_buf, 1);
#line 570
  return (tmp);
}
}
#line 585 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_unbind(struct vmw_resource *res , bool readback , struct ttm_validate_buffer *val_buf ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 589
  tmp___0 = ldv__builtin_expect((long )readback, 0L);
#line 589
  if (tmp___0 != 0L) {
#line 590
    tmp = vmw_legacy_srf_dma(res, val_buf, 0);
#line 590
    return (tmp);
  } else {

  }
#line 591
  return (0);
}
}
#line 601 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 603
  dev_priv = res->dev_priv;
#line 607
  tmp = ldv__builtin_expect(res->id == -1, 0L);
#line 607
  if (tmp != 0L) {
#line 607
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (607), "i" (12UL));
    ldv_40870: ;
#line 607
    goto ldv_40870;
  } else {

  }
#line 613
  submit_size = vmw_surface_destroy_size();
#line 614
  tmp___0 = vmw_fifo_reserve(dev_priv, submit_size);
#line 614
  cmd = (uint8_t *)tmp___0;
#line 615
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 615
  if (tmp___1 != 0L) {
#line 616
    drm_err("vmw_legacy_srf_destroy", "Failed reserving FIFO space for surface eviction.\n");
#line 618
    return (-12);
  } else {

  }
#line 621
  vmw_surface_destroy_encode((uint32_t )res->id, (void *)cmd);
#line 622
  vmw_fifo_commit(dev_priv, submit_size);
#line 628
  dev_priv->used_memory_size = dev_priv->used_memory_size - (uint32_t )res->backup_size;
#line 634
  vmw_resource_release_id(res);
#line 636
  return (0);
}
}
#line 648 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf ,
                            void (*res_free)(struct vmw_resource * ) ) 
{ 
  int ret ;
  struct vmw_resource *res ;
  long tmp ;
  long tmp___0 ;

  {
#line 653
  res = & srf->res;
#line 655
  tmp = ldv__builtin_expect((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0),
                         0L);
#line 655
  if (tmp != 0L) {
#line 655
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (655), "i" (12UL));
    ldv_40880: ;
#line 655
    goto ldv_40880;
  } else {

  }
#line 656
  vmw_3d_resource_inc(dev_priv, 0);
#line 657
  ret = vmw_resource_init(dev_priv, res, 1, res_free, & vmw_legacy_surface_func);
#line 660
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 660
  if (tmp___0 != 0L) {
#line 661
    vmw_3d_resource_dec(dev_priv, 0);
#line 662
    (*res_free)(res);
#line 663
    return (ret);
  } else {

  }
#line 671
  vmw_resource_activate(res, & vmw_hw_surface_destroy);
#line 672
  return (ret);
}
}
#line 685 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_resource *vmw_user_surface_base_to_res(struct ttm_base_object *base ) 
{ 
  struct ttm_base_object  const  *__mptr ;

  {
#line 687
  __mptr = (struct ttm_base_object  const  *)base;
#line 687
  return (& ((struct vmw_user_surface *)__mptr)->srf.res);
}
}
#line 695 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_free(struct vmw_resource *res ) 
{ 
  struct vmw_surface *srf ;
  struct vmw_surface *tmp ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface  const  *__mptr ;
  struct vmw_private *dev_priv ;
  uint32_t size ;
  struct ttm_mem_global *tmp___0 ;

  {
#line 697
  tmp = vmw_res_to_srf(res);
#line 697
  srf = tmp;
#line 699
  __mptr = (struct vmw_surface  const  *)srf;
#line 699
  user_srf = (struct vmw_user_surface *)__mptr + 0xffffffffffffffb0UL;
#line 700
  dev_priv = srf->res.dev_priv;
#line 701
  size = user_srf->size;
#line 703
  kfree((void const   *)srf->offsets);
#line 704
  kfree((void const   *)srf->sizes);
#line 705
  kfree((void const   *)srf->snooper.image);
#line 706
  kfree_call_rcu(& user_srf->base.rhead, 0);
#line 707
  tmp___0 = vmw_mem_glob(dev_priv);
#line 707
  ttm_mem_global_free(tmp___0, (uint64_t )size);
#line 708
  return;
}
}
#line 719 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 721
  base = *p_base;
#line 723
  __mptr = (struct ttm_base_object  const  *)base;
#line 723
  user_srf = (struct vmw_user_surface *)__mptr;
#line 724
  res = & user_srf->srf.res;
#line 726
  *p_base = 0;
#line 727
  vmw_resource_unreference(& res);
#line 728
  return;
}
}
#line 738 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_surface_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 741
  arg = (struct drm_vmw_surface_arg *)data;
#line 742
  tmp = vmw_fpriv(file_priv);
#line 742
  tfile = tmp->tfile;
#line 744
  tmp___0 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->sid, 0);
#line 744
  return (tmp___0);
}
}
#line 755 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *srf ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  union drm_vmw_surface_create_arg *arg ;
  struct drm_vmw_surface_create_req *req ;
  struct drm_vmw_surface_arg *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct drm_vmw_size *user_sizes ;
  int ret ;
  int i ;
  int j ;
  uint32_t cur_bo_offset ;
  struct drm_vmw_size *cur_size ;
  struct vmw_surface_offset *cur_offset ;
  uint32_t num_sizes ;
  uint32_t size ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  struct svga3d_surface_desc  const  *desc ;
  size_t tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  size_t __len ;
  void *__ret ;
  void *tmp___13 ;
  long tmp___14 ;
  void *tmp___15 ;
  long tmp___16 ;
  unsigned long tmp___17 ;
  long tmp___18 ;
  uint32_t stride ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  void *tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  struct ttm_mem_global *tmp___24 ;

  {
#line 758
  tmp = vmw_priv(dev);
#line 758
  dev_priv = tmp;
#line 763
  arg = (union drm_vmw_surface_create_arg *)data;
#line 765
  req = & arg->req;
#line 766
  rep = & arg->rep;
#line 767
  tmp___1 = vmw_fpriv(file_priv);
#line 767
  tfile = tmp___1->tfile;
#line 776
  tmp___2 = vmw_master(file_priv->master);
#line 776
  vmaster = tmp___2;
#line 779
  tmp___4 = ldv__builtin_expect(vmw_user_surface_size == 0ULL, 0L);
#line 779
  if (tmp___4 != 0L) {
#line 780
    tmp___3 = ttm_round_pot(304UL);
#line 780
    vmw_user_surface_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 783
  num_sizes = 0U;
#line 784
  i = 0;
#line 784
  goto ldv_40937;
  ldv_40936: 
#line 785
  num_sizes = req->mip_levels[i] + num_sizes;
#line 784
  i = i + 1;
  ldv_40937: ;
#line 784
  if (i <= 5) {
#line 785
    goto ldv_40936;
  } else {

  }

#line 787
  if (num_sizes > 144U) {
#line 789
    return (-22);
  } else {

  }
#line 791
  tmp___5 = ttm_round_pot((unsigned long )num_sizes * 16UL);
#line 791
  tmp___6 = ttm_round_pot((unsigned long )num_sizes * 12UL);
#line 791
  size = (((uint32_t )tmp___5 + (uint32_t )vmw_user_surface_size) + (uint32_t )tmp___6) + 128U;
#line 796
  desc = svga3dsurface_get_desc((SVGA3dSurfaceFormat )req->format);
#line 797
  tmp___7 = ldv__builtin_expect((unsigned int )desc->block_desc == 0U, 0L);
#line 797
  if (tmp___7 != 0L) {
#line 798
    drm_err("vmw_surface_define_ioctl", "Invalid surface format for surface creation.\n");
#line 799
    return (-22);
  } else {

  }
#line 802
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 803
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 803
  if (tmp___8 != 0L) {
#line 804
    return (ret);
  } else {

  }
#line 806
  tmp___9 = vmw_mem_glob(dev_priv);
#line 806
  ret = ttm_mem_global_alloc(tmp___9, (uint64_t )size, 0, 1);
#line 808
  tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 808
  if (tmp___10 != 0L) {
#line 809
    if (ret != -512) {
#line 810
      drm_err("vmw_surface_define_ioctl", "Out of graphics memory for surface creation.\n");
    } else {

    }
#line 812
    goto out_unlock;
  } else {

  }
#line 815
  tmp___11 = kzalloc(304UL, 208U);
#line 815
  user_srf = (struct vmw_user_surface *)tmp___11;
#line 816
  tmp___12 = ldv__builtin_expect((unsigned long )user_srf == (unsigned long )((struct vmw_user_surface *)0),
                              0L);
#line 816
  if (tmp___12 != 0L) {
#line 817
    ret = -12;
#line 818
    goto out_no_user_srf;
  } else {

  }
#line 821
  srf = & user_srf->srf;
#line 822
  res = & srf->res;
#line 824
  srf->flags = req->flags;
#line 825
  srf->format = req->format;
#line 826
  srf->scanout = req->scanout != 0;
#line 828
  __len = 24UL;
#line 828
  if (__len > 63UL) {
#line 828
    __ret = __memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                     __len);
  } else {
#line 828
    __ret = __builtin_memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                             __len);
  }
#line 829
  srf->num_sizes = num_sizes;
#line 830
  user_srf->size = size;
#line 832
  tmp___13 = kmalloc((unsigned long )srf->num_sizes * 16UL, 208U);
#line 832
  srf->sizes = (struct drm_vmw_size *)tmp___13;
#line 833
  tmp___14 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 833
  if (tmp___14 != 0L) {
#line 834
    ret = -12;
#line 835
    goto out_no_sizes;
  } else {

  }
#line 837
  tmp___15 = kmalloc((unsigned long )srf->num_sizes * 12UL, 208U);
#line 837
  srf->offsets = (struct vmw_surface_offset *)tmp___15;
#line 839
  tmp___16 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 839
  if (tmp___16 != 0L) {
#line 840
    ret = -12;
#line 841
    goto out_no_offsets;
  } else {

  }
#line 844
  user_sizes = (struct drm_vmw_size *)req->size_addr;
#line 847
  tmp___17 = copy_from_user((void *)srf->sizes, (void const   *)user_sizes, (unsigned long )srf->num_sizes * 16UL);
#line 847
  ret = (int )tmp___17;
#line 849
  tmp___18 = ldv__builtin_expect(ret != 0, 0L);
#line 849
  if (tmp___18 != 0L) {
#line 850
    ret = -14;
#line 851
    goto out_no_copy;
  } else {

  }
#line 854
  srf->base_size = *(srf->sizes);
#line 855
  srf->autogen_filter = 0;
#line 856
  srf->multisample_count = 1U;
#line 858
  cur_bo_offset = 0U;
#line 859
  cur_offset = srf->offsets;
#line 860
  cur_size = srf->sizes;
#line 862
  i = 0;
#line 862
  goto ldv_40953;
  ldv_40952: 
#line 863
  j = 0;
#line 863
  goto ldv_40950;
  ldv_40949: 
#line 864
  tmp___19 = svga3dsurface_calculate_pitch(desc, (struct drm_vmw_size  const  *)cur_size);
#line 864
  stride = tmp___19;
#line 867
  cur_offset->face = (uint32_t )i;
#line 868
  cur_offset->mip = (uint32_t )j;
#line 869
  cur_offset->bo_offset = cur_bo_offset;
#line 870
  tmp___20 = svga3dsurface_get_image_buffer_size(desc, (struct drm_vmw_size  const  *)cur_size,
                                                 stride);
#line 870
  cur_bo_offset = tmp___20 + cur_bo_offset;
#line 872
  cur_offset = cur_offset + 1;
#line 873
  cur_size = cur_size + 1;
#line 863
  j = j + 1;
  ldv_40950: ;
#line 863
  if ((uint32_t )j < srf->mip_levels[i]) {
#line 864
    goto ldv_40949;
  } else {

  }
#line 862
  i = i + 1;
  ldv_40953: ;
#line 862
  if (i <= 5) {
#line 863
    goto ldv_40952;
  } else {

  }
#line 876
  res->backup_size = (unsigned long )cur_bo_offset;
#line 877
  if (((((int )srf->scanout && srf->num_sizes == 1U) && (srf->sizes)->width == 64U) && (srf->sizes)->height == 64U) && srf->format == 2U) {
#line 883
    tmp___21 = kmalloc(16384UL, 208U);
#line 883
    srf->snooper.image = (uint32_t *)tmp___21;
#line 885
    if ((unsigned long )srf->snooper.image != (unsigned long )((uint32_t *)0)) {
#line 886
      memset((void *)srf->snooper.image, 0, 16384UL);
    } else {
#line 888
      drm_err("vmw_surface_define_ioctl", "Failed to allocate cursor_image\n");
#line 889
      ret = -12;
#line 890
      goto out_no_copy;
    }
  } else {
#line 893
    srf->snooper.image = 0;
  }
#line 895
  srf->snooper.crtc = 0;
#line 897
  user_srf->base.shareable = 0;
#line 898
  user_srf->base.tfile = 0;
#line 905
  ret = vmw_surface_init(dev_priv, srf, & vmw_user_surface_free);
#line 906
  tmp___22 = ldv__builtin_expect(ret != 0, 0L);
#line 906
  if (tmp___22 != 0L) {
#line 907
    goto out_unlock;
  } else {

  }
#line 909
  tmp___0 = vmw_resource_reference(& srf->res);
#line 910
  ret = ttm_base_object_init(tfile, & user_srf->base, req->shareable != 0, 257, & vmw_user_surface_base_release,
                             0);
#line 914
  tmp___23 = ldv__builtin_expect(ret != 0, 0L);
#line 914
  if (tmp___23 != 0L) {
#line 915
    vmw_resource_unreference(& tmp___0);
#line 916
    vmw_resource_unreference(& res);
#line 917
    goto out_unlock;
  } else {

  }
#line 920
  rep->sid = (int32_t )user_srf->base.hash.key;
#line 921
  vmw_resource_unreference(& res);
#line 923
  ttm_read_unlock(& vmaster->lock);
#line 924
  return (0);
  out_no_copy: 
#line 926
  kfree((void const   *)srf->offsets);
  out_no_offsets: 
#line 928
  kfree((void const   *)srf->sizes);
  out_no_sizes: 
#line 930
  kfree_call_rcu(& user_srf->base.rhead, 0);
  out_no_user_srf: 
#line 932
  tmp___24 = vmw_mem_glob(dev_priv);
#line 932
  ttm_mem_global_free(tmp___24, (uint64_t )size);
  out_unlock: 
#line 934
  ttm_read_unlock(& vmaster->lock);
#line 935
  return (ret);
}
}
#line 946 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  union drm_vmw_surface_reference_arg *arg ;
  struct drm_vmw_surface_arg *req ;
  struct drm_vmw_surface_create_req *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct drm_vmw_size *user_sizes ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  long tmp___3 ;

  {
#line 949
  arg = (union drm_vmw_surface_reference_arg *)data;
#line 951
  req = & arg->req;
#line 952
  rep = & arg->rep;
#line 953
  tmp = vmw_fpriv(file_priv);
#line 953
  tfile = tmp->tfile;
#line 958
  ret = -22;
#line 960
  base = ttm_base_object_lookup(tfile, (uint32_t )req->sid);
#line 961
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 961
  if (tmp___0 != 0L) {
#line 962
    drm_err("vmw_surface_reference_ioctl", "Could not find surface to reference.\n");
#line 963
    return (-22);
  } else {

  }
#line 966
  tmp___1 = ldv__builtin_expect((unsigned int )base->object_type != 257U, 0L);
#line 966
  if (tmp___1 != 0L) {
#line 967
    goto out_bad_resource;
  } else {

  }
#line 969
  __mptr = (struct ttm_base_object  const  *)base;
#line 969
  user_srf = (struct vmw_user_surface *)__mptr;
#line 970
  srf = & user_srf->srf;
#line 972
  ret = ttm_ref_object_add(tfile, & user_srf->base, 0, 0);
#line 973
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 973
  if (tmp___2 != 0L) {
#line 974
    drm_err("vmw_surface_reference_ioctl", "Could not add a reference to a surface.\n");
#line 975
    goto out_no_reference;
  } else {

  }
#line 978
  rep->flags = srf->flags;
#line 979
  rep->format = srf->format;
#line 980
  __len = 24UL;
#line 980
  if (__len > 63UL) {
#line 980
    __ret = __memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                     __len);
  } else {
#line 980
    __ret = __builtin_memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                             __len);
  }
#line 981
  user_sizes = (struct drm_vmw_size *)rep->size_addr;
#line 984
  if ((unsigned long )user_sizes != (unsigned long )((struct drm_vmw_size *)0)) {
#line 985
    ret = copy_to_user((void *)user_sizes, (void const   *)srf->sizes, srf->num_sizes * 16U);
  } else {

  }
#line 987
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 987
  if (tmp___3 != 0L) {
#line 988
    drm_err("vmw_surface_reference_ioctl", "copy_to_user failed %p %u\n", user_sizes,
            srf->num_sizes);
#line 990
    ret = -14;
  } else {

  }
  out_bad_resource: ;
  out_no_reference: 
#line 994
  ttm_base_object_unref(& base);
#line 996
  return (ret);
}
}
#line 1036 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_main19_sequence_infinite_withcheck_stateful(void) 
{ 
  struct ttm_base_object *var_group1 ;
  struct vmw_resource *var_group2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1058
  LDV_IN_INTERRUPT = 1;
#line 1067
  ldv_initialize();
#line 1071
  goto ldv_41001;
  ldv_41000: 
#line 1074
  tmp = __VERIFIER_nondet_int();
#line 1074
  switch (tmp) {
  case 0: 
#line 1084
  ldv_handler_precall();
#line 1085
  vmw_user_surface_base_to_res(var_group1);
#line 1092
  goto ldv_40997;
  case 1: 
#line 1101
  ldv_handler_precall();
#line 1102
  vmw_user_surface_free(var_group2);
#line 1109
  goto ldv_40997;
  default: ;
#line 1110
  goto ldv_40997;
  }
  ldv_40997: ;
  ldv_41001: 
#line 1071
  tmp___0 = __VERIFIER_nondet_int();
#line 1071
  if (tmp___0 != 0) {
#line 1072
    goto ldv_41000;
  } else {

  }


#line 1119
  ldv_check_final_state();
#line 1122
  return;
}
}
#line 1126 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1131
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1133
  mutex_lock(ldv_func_arg1);
#line 1134
  return;
}
}
#line 1136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1141
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1143
  mutex_unlock(ldv_func_arg1);
#line 1144
  return;
}
}
#line 1146 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1151
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1153
  mutex_lock(ldv_func_arg1);
#line 1154
  return;
}
}
#line 1156 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1161
  tmp = mutex_trylock(ldv_func_arg1);
#line 1161
  ldv_func_res = tmp;
#line 1163
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1163
  return (tmp___0);
#line 1165
  return (ldv_func_res);
}
}
#line 1168 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1173
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1175
  mutex_unlock(ldv_func_arg1);
#line 1176
  return;
}
}
#line 1178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_720(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1183
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1185
  mutex_lock(ldv_func_arg1);
#line 1186
  return;
}
}
#line 1188 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_721(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1193
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1195
  mutex_unlock(ldv_func_arg1);
#line 1196
  return;
}
}
#line 1198 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1203
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1205
  mutex_lock(ldv_func_arg1);
#line 1206
  return;
}
}
#line 1208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1213
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1215
  mutex_unlock(ldv_func_arg1);
#line 1216
  return;
}
}
#line 1218 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_724(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1223
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1225
  mutex_unlock(ldv_func_arg1);
#line 1226
  return;
}
}
#line 1228 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_725(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1233
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1235
  mutex_lock(ldv_func_arg1);
#line 1236
  return;
}
}
#line 1238 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_726(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1243
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1245
  mutex_unlock(ldv_func_arg1);
#line 1246
  return;
}
}
#line 1248 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_727(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1253
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1255
  mutex_lock(ldv_func_arg1);
#line 1256
  return;
}
}
#line 1258 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_728(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1263
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1265
  mutex_unlock(ldv_func_arg1);
#line 1266
  return;
}
}
#line 1268 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_729(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1273
  ldv_mutex_lock_cmdbuf_mutex(ldv_func_arg1);
#line 1275
  mutex_lock(ldv_func_arg1);
#line 1276
  return;
}
}
#line 1278 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1283
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1285
  mutex_unlock(ldv_func_arg1);
#line 1286
  return;
}
}
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: __VERIFIER_error();
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cmdbuf_mutex  ;
#line 11 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_cmdbuf_mutex = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_cmdbuf_mutex = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cmdbuf_mutex(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_cmdbuf_mutex = 2;
#line 69
  return;
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_cmdbuf_mutex = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cmdbuf_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_cmdbuf_mutex = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_cmdbuf_mutex == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cmdbuf_mutex(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_cmdbuf_mutex == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_cmdbuf_mutex = 1;
#line 158
  return;
}
}
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex  ;
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cred_guard_mutex = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cred_guard_mutex = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cred_guard_mutex = 2;
#line 221
  return;
}
}
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cred_guard_mutex = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cred_guard_mutex = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_cred_guard_mutex == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_cred_guard_mutex == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cred_guard_mutex = 1;
#line 310
  return;
}
}
#line 312 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fb_surf_mutex  ;
#line 315 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 320
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_fb_surf_mutex = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 346
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_fb_surf_mutex = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fb_surf_mutex(struct mutex *lock ) 
{ 


  {
#line 370
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_fb_surf_mutex = 2;
#line 373
  return;
}
}
#line 376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fb_surf_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_fb_surf_mutex = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fb_surf_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_fb_surf_mutex = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 431
  if (ldv_mutex_fb_surf_mutex == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fb_surf_mutex(struct mutex *lock ) 
{ 


  {
#line 459
  if (ldv_mutex_fb_surf_mutex == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_fb_surf_mutex = 1;
#line 462
  return;
}
}
#line 464 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fifo_mutex  ;
#line 467 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 472
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_fifo_mutex = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 498
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_fifo_mutex = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fifo_mutex(struct mutex *lock ) 
{ 


  {
#line 522
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_fifo_mutex = 2;
#line 525
  return;
}
}
#line 528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fifo_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_fifo_mutex = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fifo_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_fifo_mutex = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 583
  if (ldv_mutex_fifo_mutex == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fifo_mutex(struct mutex *lock ) 
{ 


  {
#line 611
  if (ldv_mutex_fifo_mutex == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_fifo_mutex = 1;
#line 614
  return;
}
}
#line 616 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_goal_irq_mutex  ;
#line 619 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 624
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_goal_irq_mutex = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 650
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_goal_irq_mutex = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_goal_irq_mutex(struct mutex *lock ) 
{ 


  {
#line 674
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_goal_irq_mutex = 2;
#line 677
  return;
}
}
#line 680 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_goal_irq_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_goal_irq_mutex = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_goal_irq_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_goal_irq_mutex = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 735
  if (ldv_mutex_goal_irq_mutex == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_goal_irq_mutex(struct mutex *lock ) 
{ 


  {
#line 763
  if (ldv_mutex_goal_irq_mutex == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_goal_irq_mutex = 1;
#line 766
  return;
}
}
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_hw_mutex  ;
#line 771 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 776
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_hw_mutex = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 802
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_hw_mutex = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_hw_mutex(struct mutex *lock ) 
{ 


  {
#line 826
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_hw_mutex = 2;
#line 829
  return;
}
}
#line 832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_hw_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_hw_mutex = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_hw_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_hw_mutex = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 887
  if (ldv_mutex_hw_mutex == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_hw_mutex(struct mutex *lock ) 
{ 


  {
#line 915
  if (ldv_mutex_hw_mutex == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_hw_mutex = 1;
#line 918
  return;
}
}
#line 920 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 923 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 928
  if (ldv_mutex_lock == 1) {

  } else {
#line 928
    ldv_error();
  }
#line 931
  nondetermined = __VERIFIER_nondet_int();
#line 934
  if (nondetermined) {
#line 937
    ldv_mutex_lock = 2;
#line 939
    return (0);
  } else {
#line 944
    return (-4);
  }
}
}
#line 949 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 954
  if (ldv_mutex_lock == 1) {

  } else {
#line 954
    ldv_error();
  }
#line 957
  nondetermined = __VERIFIER_nondet_int();
#line 960
  if (nondetermined) {
#line 963
    ldv_mutex_lock = 2;
#line 965
    return (0);
  } else {
#line 970
    return (-4);
  }
}
}
#line 975 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 978
  if (ldv_mutex_lock == 1) {

  } else {
#line 978
    ldv_error();
  }
#line 980
  ldv_mutex_lock = 2;
#line 981
  return;
}
}
#line 984 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 989
  if (ldv_mutex_lock == 1) {

  } else {
#line 989
    ldv_error();
  }
#line 992
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 995
  if (is_mutex_held_by_another_thread) {
#line 998
    return (0);
  } else {
#line 1003
    ldv_mutex_lock = 2;
#line 1005
    return (1);
  }
}
}
#line 1010 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1015
  if (ldv_mutex_lock == 1) {

  } else {
#line 1015
    ldv_error();
  }
#line 1018
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1021
  if (atomic_value_after_dec == 0) {
#line 1024
    ldv_mutex_lock = 2;
#line 1026
    return (1);
  } else {

  }
#line 1030
  return (0);
}
}
#line 1035 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1039
  if (ldv_mutex_lock == 1) {
#line 1042
    nondetermined = __VERIFIER_nondet_int();
#line 1045
    if (nondetermined) {
#line 1048
      return (0);
    } else {
#line 1053
      return (1);
    }
  } else {
#line 1059
    return (1);
  }
}
}
#line 1064 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 1067
  if (ldv_mutex_lock == 2) {

  } else {
#line 1067
    ldv_error();
  }
#line 1069
  ldv_mutex_lock = 1;
#line 1070
  return;
}
}
#line 1072 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex  ;
#line 1075 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1080
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1080
    ldv_error();
  }
#line 1083
  nondetermined = __VERIFIER_nondet_int();
#line 1086
  if (nondetermined) {
#line 1089
    ldv_mutex_mutex = 2;
#line 1091
    return (0);
  } else {
#line 1096
    return (-4);
  }
}
}
#line 1101 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1106
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1106
    ldv_error();
  }
#line 1109
  nondetermined = __VERIFIER_nondet_int();
#line 1112
  if (nondetermined) {
#line 1115
    ldv_mutex_mutex = 2;
#line 1117
    return (0);
  } else {
#line 1122
    return (-4);
  }
}
}
#line 1127 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex(struct mutex *lock ) 
{ 


  {
#line 1130
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1130
    ldv_error();
  }
#line 1132
  ldv_mutex_mutex = 2;
#line 1133
  return;
}
}
#line 1136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1141
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1141
    ldv_error();
  }
#line 1144
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1147
  if (is_mutex_held_by_another_thread) {
#line 1150
    return (0);
  } else {
#line 1155
    ldv_mutex_mutex = 2;
#line 1157
    return (1);
  }
}
}
#line 1162 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1167
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1167
    ldv_error();
  }
#line 1170
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1173
  if (atomic_value_after_dec == 0) {
#line 1176
    ldv_mutex_mutex = 2;
#line 1178
    return (1);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1191
  if (ldv_mutex_mutex == 1) {
#line 1194
    nondetermined = __VERIFIER_nondet_int();
#line 1197
    if (nondetermined) {
#line 1200
      return (0);
    } else {
#line 1205
      return (1);
    }
  } else {
#line 1211
    return (1);
  }
}
}
#line 1216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex(struct mutex *lock ) 
{ 


  {
#line 1219
  if (ldv_mutex_mutex == 2) {

  } else {
#line 1219
    ldv_error();
  }
#line 1221
  ldv_mutex_mutex = 1;
#line 1222
  return;
}
}
#line 1224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_pm_mutex  ;
#line 1227 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1232
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1232
    ldv_error();
  }
#line 1235
  nondetermined = __VERIFIER_nondet_int();
#line 1238
  if (nondetermined) {
#line 1241
    ldv_mutex_pm_mutex = 2;
#line 1243
    return (0);
  } else {
#line 1248
    return (-4);
  }
}
}
#line 1253 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1258
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1258
    ldv_error();
  }
#line 1261
  nondetermined = __VERIFIER_nondet_int();
#line 1264
  if (nondetermined) {
#line 1267
    ldv_mutex_pm_mutex = 2;
#line 1269
    return (0);
  } else {
#line 1274
    return (-4);
  }
}
}
#line 1279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) 
{ 


  {
#line 1282
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1282
    ldv_error();
  }
#line 1284
  ldv_mutex_pm_mutex = 2;
#line 1285
  return;
}
}
#line 1288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_pm_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1293
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1293
    ldv_error();
  }
#line 1296
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1299
  if (is_mutex_held_by_another_thread) {
#line 1302
    return (0);
  } else {
#line 1307
    ldv_mutex_pm_mutex = 2;
#line 1309
    return (1);
  }
}
}
#line 1314 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_pm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1319
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1319
    ldv_error();
  }
#line 1322
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1325
  if (atomic_value_after_dec == 0) {
#line 1328
    ldv_mutex_pm_mutex = 2;
#line 1330
    return (1);
  } else {

  }
#line 1334
  return (0);
}
}
#line 1339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1343
  if (ldv_mutex_pm_mutex == 1) {
#line 1346
    nondetermined = __VERIFIER_nondet_int();
#line 1349
    if (nondetermined) {
#line 1352
      return (0);
    } else {
#line 1357
      return (1);
    }
  } else {
#line 1363
    return (1);
  }
}
}
#line 1368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) 
{ 


  {
#line 1371
  if (ldv_mutex_pm_mutex == 2) {

  } else {
#line 1371
    ldv_error();
  }
#line 1373
  ldv_mutex_pm_mutex = 1;
#line 1374
  return;
}
}
#line 1376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_release_mutex  ;
#line 1379 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1384
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1384
    ldv_error();
  }
#line 1387
  nondetermined = __VERIFIER_nondet_int();
#line 1390
  if (nondetermined) {
#line 1393
    ldv_mutex_release_mutex = 2;
#line 1395
    return (0);
  } else {
#line 1400
    return (-4);
  }
}
}
#line 1405 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1410
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1410
    ldv_error();
  }
#line 1413
  nondetermined = __VERIFIER_nondet_int();
#line 1416
  if (nondetermined) {
#line 1419
    ldv_mutex_release_mutex = 2;
#line 1421
    return (0);
  } else {
#line 1426
    return (-4);
  }
}
}
#line 1431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_release_mutex(struct mutex *lock ) 
{ 


  {
#line 1434
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1434
    ldv_error();
  }
#line 1436
  ldv_mutex_release_mutex = 2;
#line 1437
  return;
}
}
#line 1440 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_release_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1445
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1445
    ldv_error();
  }
#line 1448
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1451
  if (is_mutex_held_by_another_thread) {
#line 1454
    return (0);
  } else {
#line 1459
    ldv_mutex_release_mutex = 2;
#line 1461
    return (1);
  }
}
}
#line 1466 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_release_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1471
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1471
    ldv_error();
  }
#line 1474
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1477
  if (atomic_value_after_dec == 0) {
#line 1480
    ldv_mutex_release_mutex = 2;
#line 1482
    return (1);
  } else {

  }
#line 1486
  return (0);
}
}
#line 1491 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1495
  if (ldv_mutex_release_mutex == 1) {
#line 1498
    nondetermined = __VERIFIER_nondet_int();
#line 1501
    if (nondetermined) {
#line 1504
      return (0);
    } else {
#line 1509
      return (1);
    }
  } else {
#line 1515
    return (1);
  }
}
}
#line 1520 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_release_mutex(struct mutex *lock ) 
{ 


  {
#line 1523
  if (ldv_mutex_release_mutex == 2) {

  } else {
#line 1523
    ldv_error();
  }
#line 1525
  ldv_mutex_release_mutex = 1;
#line 1526
  return;
}
}
#line 1528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_struct_mutex  ;
#line 1531 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1536
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1536
    ldv_error();
  }
#line 1539
  nondetermined = __VERIFIER_nondet_int();
#line 1542
  if (nondetermined) {
#line 1545
    ldv_mutex_struct_mutex = 2;
#line 1547
    return (0);
  } else {
#line 1552
    return (-4);
  }
}
}
#line 1557 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1562
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1562
    ldv_error();
  }
#line 1565
  nondetermined = __VERIFIER_nondet_int();
#line 1568
  if (nondetermined) {
#line 1571
    ldv_mutex_struct_mutex = 2;
#line 1573
    return (0);
  } else {
#line 1578
    return (-4);
  }
}
}
#line 1583 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_struct_mutex(struct mutex *lock ) 
{ 


  {
#line 1586
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1586
    ldv_error();
  }
#line 1588
  ldv_mutex_struct_mutex = 2;
#line 1589
  return;
}
}
#line 1592 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_struct_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1597
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1597
    ldv_error();
  }
#line 1600
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1603
  if (is_mutex_held_by_another_thread) {
#line 1606
    return (0);
  } else {
#line 1611
    ldv_mutex_struct_mutex = 2;
#line 1613
    return (1);
  }
}
}
#line 1618 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_struct_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1623
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1623
    ldv_error();
  }
#line 1626
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1629
  if (atomic_value_after_dec == 0) {
#line 1632
    ldv_mutex_struct_mutex = 2;
#line 1634
    return (1);
  } else {

  }
#line 1638
  return (0);
}
}
#line 1643 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1647
  if (ldv_mutex_struct_mutex == 1) {
#line 1650
    nondetermined = __VERIFIER_nondet_int();
#line 1653
    if (nondetermined) {
#line 1656
      return (0);
    } else {
#line 1661
      return (1);
    }
  } else {
#line 1667
    return (1);
  }
}
}
#line 1672 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_struct_mutex(struct mutex *lock ) 
{ 


  {
#line 1675
  if (ldv_mutex_struct_mutex == 2) {

  } else {
#line 1675
    ldv_error();
  }
#line 1677
  ldv_mutex_struct_mutex = 1;
#line 1678
  return;
}
}
#line 1680 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_update_lock  ;
#line 1683 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1688
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1688
    ldv_error();
  }
#line 1691
  nondetermined = __VERIFIER_nondet_int();
#line 1694
  if (nondetermined) {
#line 1697
    ldv_mutex_update_lock = 2;
#line 1699
    return (0);
  } else {
#line 1704
    return (-4);
  }
}
}
#line 1709 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1714
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1714
    ldv_error();
  }
#line 1717
  nondetermined = __VERIFIER_nondet_int();
#line 1720
  if (nondetermined) {
#line 1723
    ldv_mutex_update_lock = 2;
#line 1725
    return (0);
  } else {
#line 1730
    return (-4);
  }
}
}
#line 1735 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_update_lock(struct mutex *lock ) 
{ 


  {
#line 1738
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1738
    ldv_error();
  }
#line 1740
  ldv_mutex_update_lock = 2;
#line 1741
  return;
}
}
#line 1744 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_update_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1749
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1749
    ldv_error();
  }
#line 1752
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1755
  if (is_mutex_held_by_another_thread) {
#line 1758
    return (0);
  } else {
#line 1763
    ldv_mutex_update_lock = 2;
#line 1765
    return (1);
  }
}
}
#line 1770 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_update_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1775
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1775
    ldv_error();
  }
#line 1778
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1781
  if (atomic_value_after_dec == 0) {
#line 1784
    ldv_mutex_update_lock = 2;
#line 1786
    return (1);
  } else {

  }
#line 1790
  return (0);
}
}
#line 1795 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1799
  if (ldv_mutex_update_lock == 1) {
#line 1802
    nondetermined = __VERIFIER_nondet_int();
#line 1805
    if (nondetermined) {
#line 1808
      return (0);
    } else {
#line 1813
      return (1);
    }
  } else {
#line 1819
    return (1);
  }
}
}
#line 1824 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_update_lock(struct mutex *lock ) 
{ 


  {
#line 1827
  if (ldv_mutex_update_lock == 2) {

  } else {
#line 1827
    ldv_error();
  }
#line 1829
  ldv_mutex_update_lock = 1;
#line 1830
  return;
}
}
#line 1834 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 1837
  ldv_mutex_cmdbuf_mutex = 1;
#line 1839
  ldv_mutex_cred_guard_mutex = 1;
#line 1841
  ldv_mutex_fb_surf_mutex = 1;
#line 1843
  ldv_mutex_fifo_mutex = 1;
#line 1845
  ldv_mutex_goal_irq_mutex = 1;
#line 1847
  ldv_mutex_hw_mutex = 1;
#line 1849
  ldv_mutex_lock = 1;
#line 1851
  ldv_mutex_mutex = 1;
#line 1853
  ldv_mutex_pm_mutex = 1;
#line 1855
  ldv_mutex_release_mutex = 1;
#line 1857
  ldv_mutex_struct_mutex = 1;
#line 1859
  ldv_mutex_update_lock = 1;
#line 1860
  return;
}
}
#line 1863 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 1866
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 1866
    ldv_error();
  }
#line 1868
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 1868
    ldv_error();
  }
#line 1870
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 1870
    ldv_error();
  }
#line 1872
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 1872
    ldv_error();
  }
#line 1874
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 1874
    ldv_error();
  }
#line 1876
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 1876
    ldv_error();
  }
#line 1878
  if (ldv_mutex_lock == 1) {

  } else {
#line 1878
    ldv_error();
  }
#line 1880
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1880
    ldv_error();
  }
#line 1882
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1882
    ldv_error();
  }
#line 1884
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1884
    ldv_error();
  }
#line 1886
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1886
    ldv_error();
  }
#line 1888
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1888
    ldv_error();
  }
#line 1889
  return;
}
}
