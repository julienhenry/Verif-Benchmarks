extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 75 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 76 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 91 "include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 27 "include/linux/types.h"
typedef unsigned short umode_t;
#line 38 "include/linux/types.h"
typedef _Bool bool;
#line 54 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 63 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 68 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 202 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 206 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 211 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 221 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 221 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 226 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 226 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 227 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 55 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/alternative.h"
struct module;
#line 55
struct module;
#line 146 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 46 "include/linux/dynamic_debug.h"
struct device;
#line 46
struct device;
#line 57
struct completion;
#line 57
struct completion;
#line 58 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/page_types.h"
struct page;
#line 58
struct page;
#line 26 "include/asm-generic/getorder.h"
struct task_struct;
#line 26
struct task_struct;
#line 290 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
struct file;
#line 290
struct file;
#line 327 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 327
struct arch_spinlock;
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 234 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 234
struct static_key;
#line 433 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct kmem_cache;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_5907_29 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_5907_29 ldv_5907 ;
};
#line 27 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
struct lockdep_map;
#line 34
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 556 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6122_33 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6123_32 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6122_33 ldv_6122 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6123_32 ldv_6123 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 48 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 53 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 670 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 128 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 139 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 312 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 341
struct tvec_base;
#line 341
struct tvec_base;
#line 342 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 302 "include/linux/timer.h"
struct work_struct;
#line 302
struct work_struct;
#line 45 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos_request;
#line 499
struct pm_qos_constraints;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   ktime_t suspend_time ;
   s64 max_time_suspended_ns ;
   struct dev_pm_qos_request *pq_req ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_constraints *constraints ;
};
#line 558 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 18
struct vm_area_struct;
#line 18 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 19 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 23 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 24 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 193 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 201 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 445
struct sock;
#line 445
struct sock;
#line 446
struct kobject;
#line 446
struct kobject;
#line 447
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 453 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 33 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 62 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 98 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 117
struct sysfs_dirent;
#line 117
struct sysfs_dirent;
#line 182 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 215
struct kernel_param;
#line 215
struct kernel_param;
#line 216 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 49 "include/linux/moduleparam.h"
struct kparam_string;
#line 49
struct kparam_array;
#line 49 "include/linux/moduleparam.h"
union __anonunion_ldv_13363_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 49 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_13363_134 ldv_13363 ;
};
#line 61 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 67 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 458 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 225 "include/linux/jump_label.h"
struct tracepoint;
#line 225
struct tracepoint;
#line 226 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 34 "include/linux/module.h"
struct module_param_attrs;
#line 34 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 43 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 69
struct exception_table_entry;
#line 69
struct exception_table_entry;
#line 198
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 204 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 219
struct module_sect_attrs;
#line 219
struct module_notes_attrs;
#line 219
struct ftrace_event_call;
#line 219 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[26U] ;
};
#line 55 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 66 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 76 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 15 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
struct klist_node;
#line 15
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct dma_map_ops;
#line 67 "include/linux/klist.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 17
struct device_private;
#line 17
struct device_private;
#line 18
struct device_driver;
#line 18
struct device_driver;
#line 19
struct driver_private;
#line 19
struct driver_private;
#line 20
struct class;
#line 20
struct class;
#line 21
struct subsys_private;
#line 21
struct subsys_private;
#line 22
struct bus_type;
#line 22
struct bus_type;
#line 23
struct device_node;
#line 23
struct device_node;
#line 24
struct iommu_ops;
#line 24
struct iommu_ops;
#line 25 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 51 "include/linux/device.h"
struct device_attribute;
#line 51
struct driver_attribute;
#line 51 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 125
struct device_type;
#line 182
struct of_device_id;
#line 182 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 245 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 299
struct class_attribute;
#line 299 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 394 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 447 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 474 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 557 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 567
struct dma_coherent_mem;
#line 567 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
};
#line 681 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned char active : 1 ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 215 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 492 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 584
struct mfd_cell;
#line 584
struct mfd_cell;
#line 585 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 272 "include/linux/platform_device.h"
struct watchdog_info {
   __u32 options ;
   __u32 firmware_version ;
   __u8 identity[32U] ;
};
#line 22 "include/linux/watchdog.h"
struct watchdog_ops;
#line 22
struct watchdog_ops;
#line 23
struct watchdog_device;
#line 23
struct watchdog_device;
#line 24 "include/linux/watchdog.h"
struct watchdog_ops {
   struct module *owner ;
   int (*start)(struct watchdog_device * ) ;
   int (*stop)(struct watchdog_device * ) ;
   int (*ping)(struct watchdog_device * ) ;
   unsigned int (*status)(struct watchdog_device * ) ;
   int (*set_timeout)(struct watchdog_device * , unsigned int  ) ;
   unsigned int (*get_timeleft)(struct watchdog_device * ) ;
   long (*ioctl)(struct watchdog_device * , unsigned int  , unsigned long  ) ;
};
#line 89 "include/linux/watchdog.h"
struct watchdog_device {
   struct watchdog_info  const  *info ;
   struct watchdog_ops  const  *ops ;
   unsigned int bootstatus ;
   unsigned int timeout ;
   unsigned int min_timeout ;
   unsigned int max_timeout ;
   void *driver_data ;
   unsigned long status ;
};
#line 152 "include/linux/watchdog.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 28 "include/linux/of.h"
typedef u32 phandle;
#line 30 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 39
struct proc_dir_entry;
#line 39 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 704 "include/linux/interrupt.h"
struct regmap;
#line 704
struct regmap;
#line 231 "include/linux/regmap.h"
struct wm831x;
#line 231
struct wm831x;
#line 232
enum wm831x_auxadc;
#line 232
enum wm831x_auxadc;
#line 359 "include/linux/mfd/wm831x/core.h"
struct wm831x {
   struct mutex io_lock ;
   struct device *dev ;
   struct regmap *regmap ;
   int irq ;
   struct mutex irq_lock ;
   int irq_base ;
   int irq_masks_cur[5U] ;
   int irq_masks_cache[5U] ;
   bool soft_shutdown ;
   unsigned char has_gpio_ena : 1 ;
   unsigned char has_cs_sts : 1 ;
   unsigned char charger_irq_wake : 1 ;
   int num_gpio ;
   int gpio_update[16U] ;
   bool gpio_level[16U] ;
   struct mutex auxadc_lock ;
   struct list_head auxadc_pending ;
   u16 auxadc_active ;
   int (*auxadc_read)(struct wm831x * , enum wm831x_auxadc  ) ;
   struct mutex key_lock ;
   unsigned char locked : 1 ;
};
#line 421
struct regulator_init_data;
#line 421
struct regulator_init_data;
#line 422 "include/linux/mfd/wm831x/core.h"
struct wm831x_backlight_pdata {
   int isink ;
   int max_uA ;
};
#line 25 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_backup_pdata {
   int charger_enable ;
   int no_constant_voltage ;
   int vlim ;
   int ilim ;
};
#line 32 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_battery_pdata {
   int enable ;
   int fast_enable ;
   int off_mask ;
   int trickle_ilim ;
   int vsel ;
   int eoc_iterm ;
   int fast_ilim ;
   int timeout ;
};
#line 60
enum wm831x_status_src {
    WM831X_STATUS_PRESERVE = 0,
    WM831X_STATUS_OTP = 1,
    WM831X_STATUS_POWER = 2,
    WM831X_STATUS_CHARGER = 3,
    WM831X_STATUS_MANUAL = 4
} ;
#line 68 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_status_pdata {
   enum wm831x_status_src default_src ;
   char const   *name ;
   char const   *default_trigger ;
};
#line 77 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_touch_pdata {
   int fivewire ;
   int isel ;
   int rpu ;
   int pressure ;
   unsigned int data_irq ;
   int data_irqf ;
   unsigned int pd_irq ;
   int pd_irqf ;
};
#line 88
enum wm831x_watchdog_action {
    WM831X_WDOG_NONE = 0,
    WM831X_WDOG_INTERRUPT = 1,
    WM831X_WDOG_RESET = 2,
    WM831X_WDOG_WAKE = 3
} ;
#line 95 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_watchdog_pdata {
   enum wm831x_watchdog_action primary ;
   enum wm831x_watchdog_action secondary ;
   int update_gpio ;
   unsigned char software : 1 ;
};
#line 101 "include/linux/mfd/wm831x/pdata.h"
struct wm831x_pdata {
   int wm831x_num ;
   int (*pre_init)(struct wm831x * ) ;
   int (*post_init)(struct wm831x * ) ;
   bool irq_cmos ;
   bool disable_touch ;
   bool soft_shutdown ;
   int irq_base ;
   int gpio_base ;
   int gpio_defaults[16U] ;
   struct wm831x_backlight_pdata *backlight ;
   struct wm831x_backup_pdata *backup ;
   struct wm831x_battery_pdata *battery ;
   struct wm831x_touch_pdata *touch ;
   struct wm831x_watchdog_pdata *watchdog ;
   struct wm831x_status_pdata *status[2U] ;
   struct regulator_init_data *dcdc[4U] ;
   struct regulator_init_data *epe[2U] ;
   struct regulator_init_data *ldo[11U] ;
   struct regulator_init_data *isink[2U] ;
};
#line 45 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
struct wm831x_wdt_drvdata {
   struct watchdog_device wdt ;
   struct wm831x *wm831x ;
   struct mutex lock ;
   int update_gpio ;
   int update_state ;
};
#line 59 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
struct __anonstruct_wm831x_wdt_cfgs_137 {
   unsigned int time ;
   u16 val ;
};
#line 2
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 4
int ldv_spin_trylock(void) ;
#line 60 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ long volatile   *__cil_tmp3 ;

  {
#line 68
  __cil_tmp3 = (long volatile   *)addr;
#line 68
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; bts %1,%0": "+m" (*__cil_tmp3): "Ir" (nr): "memory");
#line 70
  return;
}
}
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 134
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 169
extern void mutex_unlock(struct mutex * ) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 220 "include/linux/slub_def.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 223
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 11 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_check_alloc_nonatomic(void) ;
#line 14
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) ;
#line 553 "include/linux/device.h"
extern void *devm_kzalloc(struct device * , size_t  , gfp_t  ) ;
#line 792
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 793
extern int dev_set_drvdata(struct device * , void * ) ;
#line 892
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 894
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 132 "include/linux/watchdog.h"
__inline static void watchdog_set_nowayout(struct watchdog_device *wdd , bool nowayout ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long *__cil_tmp5 ;
  unsigned long volatile   *__cil_tmp6 ;

  {
#line 134
  if ((int )nowayout) {
    {
#line 135
    __cil_tmp3 = (unsigned long )wdd;
#line 135
    __cil_tmp4 = __cil_tmp3 + 40;
#line 135
    __cil_tmp5 = (unsigned long *)__cil_tmp4;
#line 135
    __cil_tmp6 = (unsigned long volatile   *)__cil_tmp5;
#line 135
    set_bit(3U, __cil_tmp6);
    }
  } else {

  }
#line 136
  return;
}
}
#line 139 "include/linux/watchdog.h"
__inline static void watchdog_set_drvdata(struct watchdog_device *wdd , void *data ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
#line 141
  __cil_tmp3 = (unsigned long )wdd;
#line 141
  __cil_tmp4 = __cil_tmp3 + 32;
#line 141
  *((void **)__cil_tmp4) = data;
#line 142
  return;
}
}
#line 144 "include/linux/watchdog.h"
__inline static void *watchdog_get_drvdata(struct watchdog_device *wdd ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 146
  __cil_tmp2 = (unsigned long )wdd;
#line 146
  __cil_tmp3 = __cil_tmp2 + 32;
#line 146
  return (*((void **)__cil_tmp3));
  }
}
}
#line 150
extern int watchdog_register_device(struct watchdog_device * ) ;
#line 153 "include/asm-generic/gpio.h"
extern int gpio_request(unsigned int  , char const   * ) ;
#line 154
extern void gpio_free(unsigned int  ) ;
#line 157
extern int gpio_direction_output(unsigned int  , int  ) ;
#line 162
extern void gpio_set_value_cansleep(unsigned int  , int  ) ;
#line 402 "include/linux/mfd/wm831x/core.h"
extern int wm831x_reg_read(struct wm831x * , unsigned short  ) ;
#line 403
extern int wm831x_reg_write(struct wm831x * , unsigned short  , unsigned short  ) ;
#line 405
extern void wm831x_reg_lock(struct wm831x * ) ;
#line 406
extern int wm831x_reg_unlock(struct wm831x * ) ;
#line 407
extern int wm831x_set_bits(struct wm831x * , unsigned short  , unsigned short  , unsigned short  ) ;
#line 40 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static bool nowayout  =    (bool )1;
#line 59 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static struct __anonstruct_wm831x_wdt_cfgs_137 wm831x_wdt_cfgs[7U]  = {      {1U, (u16 )2U}, 
        {2U, (u16 )3U}, 
        {4U, (u16 )4U}, 
        {8U, (u16 )5U}, 
        {16U, (u16 )6U}, 
        {32U, (u16 )7U}, 
        {33U, (u16 )7U}};
#line 69 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static int wm831x_wdt_start(struct watchdog_device *wdt_dev ) 
{ struct wm831x_wdt_drvdata *driver_data ;
  void *tmp ;
  struct wm831x *wm831x ;
  int ret ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct device *__cil_tmp13 ;
  struct device  const  *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct mutex *__cil_tmp17 ;

  {
  {
#line 71
  tmp = watchdog_get_drvdata(wdt_dev);
#line 71
  driver_data = (struct wm831x_wdt_drvdata *)tmp;
#line 72
  __cil_tmp6 = (unsigned long )driver_data;
#line 72
  __cil_tmp7 = __cil_tmp6 + 48;
#line 72
  wm831x = *((struct wm831x **)__cil_tmp7);
#line 75
  __cil_tmp8 = (unsigned long )driver_data;
#line 75
  __cil_tmp9 = __cil_tmp8 + 56;
#line 75
  __cil_tmp10 = (struct mutex *)__cil_tmp9;
#line 75
  mutex_lock_nested(__cil_tmp10, 0U);
#line 77
  ret = wm831x_reg_unlock(wm831x);
  }
#line 78
  if (ret == 0) {
    {
#line 79
    ret = wm831x_set_bits(wm831x, (unsigned short)16388, (unsigned short)32768, (unsigned short)32768);
#line 81
    wm831x_reg_lock(wm831x);
    }
  } else {
    {
#line 83
    __cil_tmp11 = (unsigned long )wm831x;
#line 83
    __cil_tmp12 = __cil_tmp11 + 168;
#line 83
    __cil_tmp13 = *((struct device **)__cil_tmp12);
#line 83
    __cil_tmp14 = (struct device  const  *)__cil_tmp13;
#line 83
    dev_err(__cil_tmp14, "Failed to unlock security key: %d\n", ret);
    }
  }
  {
#line 87
  __cil_tmp15 = (unsigned long )driver_data;
#line 87
  __cil_tmp16 = __cil_tmp15 + 56;
#line 87
  __cil_tmp17 = (struct mutex *)__cil_tmp16;
#line 87
  mutex_unlock(__cil_tmp17);
  }
#line 89
  return (ret);
}
}
#line 92 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static int wm831x_wdt_stop(struct watchdog_device *wdt_dev ) 
{ struct wm831x_wdt_drvdata *driver_data ;
  void *tmp ;
  struct wm831x *wm831x ;
  int ret ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct device *__cil_tmp13 ;
  struct device  const  *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct mutex *__cil_tmp17 ;

  {
  {
#line 94
  tmp = watchdog_get_drvdata(wdt_dev);
#line 94
  driver_data = (struct wm831x_wdt_drvdata *)tmp;
#line 95
  __cil_tmp6 = (unsigned long )driver_data;
#line 95
  __cil_tmp7 = __cil_tmp6 + 48;
#line 95
  wm831x = *((struct wm831x **)__cil_tmp7);
#line 98
  __cil_tmp8 = (unsigned long )driver_data;
#line 98
  __cil_tmp9 = __cil_tmp8 + 56;
#line 98
  __cil_tmp10 = (struct mutex *)__cil_tmp9;
#line 98
  mutex_lock_nested(__cil_tmp10, 0U);
#line 100
  ret = wm831x_reg_unlock(wm831x);
  }
#line 101
  if (ret == 0) {
    {
#line 102
    ret = wm831x_set_bits(wm831x, (unsigned short)16388, (unsigned short)32768, (unsigned short)0);
#line 104
    wm831x_reg_lock(wm831x);
    }
  } else {
    {
#line 106
    __cil_tmp11 = (unsigned long )wm831x;
#line 106
    __cil_tmp12 = __cil_tmp11 + 168;
#line 106
    __cil_tmp13 = *((struct device **)__cil_tmp12);
#line 106
    __cil_tmp14 = (struct device  const  *)__cil_tmp13;
#line 106
    dev_err(__cil_tmp14, "Failed to unlock security key: %d\n", ret);
    }
  }
  {
#line 110
  __cil_tmp15 = (unsigned long )driver_data;
#line 110
  __cil_tmp16 = __cil_tmp15 + 56;
#line 110
  __cil_tmp17 = (struct mutex *)__cil_tmp16;
#line 110
  mutex_unlock(__cil_tmp17);
  }
#line 112
  return (ret);
}
}
#line 115 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static int wm831x_wdt_ping(struct watchdog_device *wdt_dev ) 
{ struct wm831x_wdt_drvdata *driver_data ;
  void *tmp ;
  struct wm831x *wm831x ;
  int ret ;
  u16 reg ;
  int tmp___0 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct mutex *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct device *__cil_tmp32 ;
  struct device  const  *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned short __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct device *__cil_tmp40 ;
  struct device  const  *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct mutex *__cil_tmp44 ;

  {
  {
#line 117
  tmp = watchdog_get_drvdata(wdt_dev);
#line 117
  driver_data = (struct wm831x_wdt_drvdata *)tmp;
#line 118
  __cil_tmp8 = (unsigned long )driver_data;
#line 118
  __cil_tmp9 = __cil_tmp8 + 48;
#line 118
  wm831x = *((struct wm831x **)__cil_tmp9);
#line 122
  __cil_tmp10 = (unsigned long )driver_data;
#line 122
  __cil_tmp11 = __cil_tmp10 + 56;
#line 122
  __cil_tmp12 = (struct mutex *)__cil_tmp11;
#line 122
  mutex_lock_nested(__cil_tmp12, 0U);
  }
  {
#line 124
  __cil_tmp13 = (unsigned long )driver_data;
#line 124
  __cil_tmp14 = __cil_tmp13 + 224;
#line 124
  __cil_tmp15 = *((int *)__cil_tmp14);
#line 124
  if (__cil_tmp15 != 0) {
    {
#line 125
    __cil_tmp16 = (unsigned long )driver_data;
#line 125
    __cil_tmp17 = __cil_tmp16 + 224;
#line 125
    __cil_tmp18 = *((int *)__cil_tmp17);
#line 125
    __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 125
    __cil_tmp20 = (unsigned long )driver_data;
#line 125
    __cil_tmp21 = __cil_tmp20 + 228;
#line 125
    __cil_tmp22 = *((int *)__cil_tmp21);
#line 125
    gpio_set_value_cansleep(__cil_tmp19, __cil_tmp22);
#line 127
    __cil_tmp23 = (unsigned long )driver_data;
#line 127
    __cil_tmp24 = __cil_tmp23 + 228;
#line 127
    __cil_tmp25 = (unsigned long )driver_data;
#line 127
    __cil_tmp26 = __cil_tmp25 + 228;
#line 127
    __cil_tmp27 = *((int *)__cil_tmp26);
#line 127
    *((int *)__cil_tmp24) = __cil_tmp27 == 0;
#line 128
    ret = 0;
    }
#line 129
    goto out;
  } else {

  }
  }
  {
#line 132
  tmp___0 = wm831x_reg_read(wm831x, (unsigned short)16388);
#line 132
  reg = (u16 )tmp___0;
  }
  {
#line 134
  __cil_tmp28 = (int )reg;
#line 134
  __cil_tmp29 = __cil_tmp28 & 8192;
#line 134
  if (__cil_tmp29 == 0) {
    {
#line 135
    __cil_tmp30 = (unsigned long )wm831x;
#line 135
    __cil_tmp31 = __cil_tmp30 + 168;
#line 135
    __cil_tmp32 = *((struct device **)__cil_tmp31);
#line 135
    __cil_tmp33 = (struct device  const  *)__cil_tmp32;
#line 135
    dev_err(__cil_tmp33, "Hardware watchdog update unsupported\n");
#line 136
    ret = -22;
    }
#line 137
    goto out;
  } else {

  }
  }
  {
#line 140
  __cil_tmp34 = (unsigned int )reg;
#line 140
  __cil_tmp35 = __cil_tmp34 | 2048U;
#line 140
  reg = (u16 )__cil_tmp35;
#line 142
  ret = wm831x_reg_unlock(wm831x);
  }
#line 143
  if (ret == 0) {
    {
#line 144
    __cil_tmp36 = (int )reg;
#line 144
    __cil_tmp37 = (unsigned short )__cil_tmp36;
#line 144
    ret = wm831x_reg_write(wm831x, (unsigned short)16388, __cil_tmp37);
#line 145
    wm831x_reg_lock(wm831x);
    }
  } else {
    {
#line 147
    __cil_tmp38 = (unsigned long )wm831x;
#line 147
    __cil_tmp39 = __cil_tmp38 + 168;
#line 147
    __cil_tmp40 = *((struct device **)__cil_tmp39);
#line 147
    __cil_tmp41 = (struct device  const  *)__cil_tmp40;
#line 147
    dev_err(__cil_tmp41, "Failed to unlock security key: %d\n", ret);
    }
  }
  out: 
  {
#line 152
  __cil_tmp42 = (unsigned long )driver_data;
#line 152
  __cil_tmp43 = __cil_tmp42 + 56;
#line 152
  __cil_tmp44 = (struct mutex *)__cil_tmp43;
#line 152
  mutex_unlock(__cil_tmp44);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static int wm831x_wdt_set_timeout(struct watchdog_device *wdt_dev , unsigned int timeout ) 
{ struct wm831x_wdt_drvdata *driver_data ;
  void *tmp ;
  struct wm831x *wm831x ;
  int ret ;
  int i ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  u16 __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct device *__cil_tmp22 ;
  struct device  const  *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;

  {
  {
#line 160
  tmp = watchdog_get_drvdata(wdt_dev);
#line 160
  driver_data = (struct wm831x_wdt_drvdata *)tmp;
#line 161
  __cil_tmp8 = (unsigned long )driver_data;
#line 161
  __cil_tmp9 = __cil_tmp8 + 48;
#line 161
  wm831x = *((struct wm831x **)__cil_tmp9);
#line 164
  i = 0;
  }
#line 164
  goto ldv_17541;
  ldv_17540: ;
  {
#line 165
  __cil_tmp10 = i * 8UL;
#line 165
  __cil_tmp11 = (unsigned long )(wm831x_wdt_cfgs) + __cil_tmp10;
#line 165
  __cil_tmp12 = *((unsigned int *)__cil_tmp11);
#line 165
  if (__cil_tmp12 == timeout) {
#line 166
    goto ldv_17539;
  } else {

  }
  }
#line 164
  i = i + 1;
  ldv_17541: ;
  {
#line 164
  __cil_tmp13 = (unsigned int )i;
#line 164
  if (__cil_tmp13 <= 6U) {
#line 165
    goto ldv_17540;
  } else {
#line 167
    goto ldv_17539;
  }
  }
  ldv_17539: ;
#line 167
  if (i == 7) {
#line 168
    return (-22);
  } else {

  }
  {
#line 170
  ret = wm831x_reg_unlock(wm831x);
  }
#line 171
  if (ret == 0) {
    {
#line 172
    __cil_tmp14 = i * 8UL;
#line 172
    __cil_tmp15 = __cil_tmp14 + 4;
#line 172
    __cil_tmp16 = (unsigned long )(wm831x_wdt_cfgs) + __cil_tmp15;
#line 172
    __cil_tmp17 = *((u16 *)__cil_tmp16);
#line 172
    __cil_tmp18 = (int )__cil_tmp17;
#line 172
    __cil_tmp19 = (unsigned short )__cil_tmp18;
#line 172
    ret = wm831x_set_bits(wm831x, (unsigned short)16388, (unsigned short)7, __cil_tmp19);
#line 175
    wm831x_reg_lock(wm831x);
    }
  } else {
    {
#line 177
    __cil_tmp20 = (unsigned long )wm831x;
#line 177
    __cil_tmp21 = __cil_tmp20 + 168;
#line 177
    __cil_tmp22 = *((struct device **)__cil_tmp21);
#line 177
    __cil_tmp23 = (struct device  const  *)__cil_tmp22;
#line 177
    dev_err(__cil_tmp23, "Failed to unlock security key: %d\n", ret);
    }
  }
#line 181
  __cil_tmp24 = (unsigned long )wdt_dev;
#line 181
  __cil_tmp25 = __cil_tmp24 + 20;
#line 181
  *((unsigned int *)__cil_tmp25) = timeout;
#line 183
  return (ret);
}
}
#line 186 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static struct watchdog_info  const  wm831x_wdt_info  =    {33152U, 0U, {(__u8 )'W', (__u8 )'M', (__u8 )'8', (__u8 )'3', (__u8 )'1', (__u8 )'x',
                 (__u8 )' ', (__u8 )'W', (__u8 )'a', (__u8 )'t', (__u8 )'c', (__u8 )'h',
                 (__u8 )'d', (__u8 )'o', (__u8 )'g', (__u8 )'\000', (unsigned char)0,
                 (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                 (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                 (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                 (unsigned char)0, (unsigned char)0, (unsigned char)0}};
#line 191 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static struct watchdog_ops  const  wm831x_wdt_ops  = 
#line 191
     {& __this_module, & wm831x_wdt_start, & wm831x_wdt_stop, & wm831x_wdt_ping, (unsigned int (*)(struct watchdog_device * ))0,
    & wm831x_wdt_set_timeout, (unsigned int (*)(struct watchdog_device * ))0, (long (*)(struct watchdog_device * ,
                                                                                        unsigned int  ,
                                                                                        unsigned long  ))0};
#line 199 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
static int wm831x_wdt_probe(struct platform_device *pdev ) 
{ struct wm831x *wm831x ;
  void *tmp ;
  struct wm831x_pdata *chip_pdata ;
  struct wm831x_watchdog_pdata *pdata ;
  struct wm831x_wdt_drvdata *driver_data ;
  struct watchdog_device *wm831x_wdt ;
  int reg ;
  int ret ;
  int i ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct device *__cil_tmp15 ;
  struct device  const  *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct device *__cil_tmp19 ;
  struct device  const  *__cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct device *__cil_tmp24 ;
  struct device  const  *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct device *__cil_tmp28 ;
  struct wm831x_wdt_drvdata *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct device *__cil_tmp34 ;
  struct device  const  *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  bool *__cil_tmp43 ;
  bool __cil_tmp44 ;
  int __cil_tmp45 ;
  bool __cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  u16 __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct device *__cil_tmp56 ;
  struct device  const  *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct device *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  void *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct device *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  void *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct wm831x_watchdog_pdata *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned int __cil_tmp82 ;
  enum wm831x_watchdog_action __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  enum wm831x_watchdog_action __cil_tmp90 ;
  unsigned int __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned char __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  int __cil_tmp104 ;
  unsigned int __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  struct device *__cil_tmp108 ;
  struct device  const  *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  int __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  struct device *__cil_tmp116 ;
  struct device  const  *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned short __cil_tmp122 ;
  int __cil_tmp123 ;
  unsigned short __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  struct device *__cil_tmp127 ;
  struct device  const  *__cil_tmp128 ;
  struct watchdog_device *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  struct device *__cil_tmp132 ;
  struct device  const  *__cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  struct device *__cil_tmp136 ;
  void *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  int __cil_tmp143 ;
  unsigned int __cil_tmp144 ;

  {
  {
#line 201
  __cil_tmp13 = (unsigned long )pdev;
#line 201
  __cil_tmp14 = __cil_tmp13 + 16;
#line 201
  __cil_tmp15 = *((struct device **)__cil_tmp14);
#line 201
  __cil_tmp16 = (struct device  const  *)__cil_tmp15;
#line 201
  tmp = dev_get_drvdata(__cil_tmp16);
#line 201
  wm831x = (struct wm831x *)tmp;
#line 208
  ret = wm831x_reg_read(wm831x, (unsigned short)16388);
  }
#line 209
  if (ret < 0) {
    {
#line 210
    __cil_tmp17 = (unsigned long )wm831x;
#line 210
    __cil_tmp18 = __cil_tmp17 + 168;
#line 210
    __cil_tmp19 = *((struct device **)__cil_tmp18);
#line 210
    __cil_tmp20 = (struct device  const  *)__cil_tmp19;
#line 210
    dev_err(__cil_tmp20, "Failed to read watchdog status: %d\n", ret);
    }
#line 212
    goto err;
  } else {

  }
#line 214
  reg = ret;
  {
#line 216
  __cil_tmp21 = reg & 16384;
#line 216
  if (__cil_tmp21 != 0) {
    {
#line 217
    __cil_tmp22 = (unsigned long )wm831x;
#line 217
    __cil_tmp23 = __cil_tmp22 + 168;
#line 217
    __cil_tmp24 = *((struct device **)__cil_tmp23);
#line 217
    __cil_tmp25 = (struct device  const  *)__cil_tmp24;
#line 217
    dev_warn(__cil_tmp25, "Watchdog is paused\n");
    }
  } else {

  }
  }
  {
#line 219
  __cil_tmp26 = (unsigned long )pdev;
#line 219
  __cil_tmp27 = __cil_tmp26 + 16;
#line 219
  __cil_tmp28 = (struct device *)__cil_tmp27;
#line 219
  tmp___0 = devm_kzalloc(__cil_tmp28, 232UL, 208U);
#line 219
  driver_data = (struct wm831x_wdt_drvdata *)tmp___0;
  }
  {
#line 221
  __cil_tmp29 = (struct wm831x_wdt_drvdata *)0;
#line 221
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 221
  __cil_tmp31 = (unsigned long )driver_data;
#line 221
  if (__cil_tmp31 == __cil_tmp30) {
    {
#line 222
    __cil_tmp32 = (unsigned long )wm831x;
#line 222
    __cil_tmp33 = __cil_tmp32 + 168;
#line 222
    __cil_tmp34 = *((struct device **)__cil_tmp33);
#line 222
    __cil_tmp35 = (struct device  const  *)__cil_tmp34;
#line 222
    dev_err(__cil_tmp35, "Unable to alloacate watchdog device\n");
#line 223
    ret = -12;
    }
#line 224
    goto err;
  } else {

  }
  }
  {
#line 227
  __cil_tmp36 = (unsigned long )driver_data;
#line 227
  __cil_tmp37 = __cil_tmp36 + 56;
#line 227
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
#line 227
  __mutex_init(__cil_tmp38, "&driver_data->lock", & __key);
#line 228
  __cil_tmp39 = (unsigned long )driver_data;
#line 228
  __cil_tmp40 = __cil_tmp39 + 48;
#line 228
  *((struct wm831x **)__cil_tmp40) = wm831x;
#line 230
  wm831x_wdt = (struct watchdog_device *)driver_data;
#line 232
  *((struct watchdog_info  const  **)wm831x_wdt) = & wm831x_wdt_info;
#line 233
  __cil_tmp41 = (unsigned long )wm831x_wdt;
#line 233
  __cil_tmp42 = __cil_tmp41 + 8;
#line 233
  *((struct watchdog_ops  const  **)__cil_tmp42) = & wm831x_wdt_ops;
#line 234
  __cil_tmp43 = & nowayout;
#line 234
  __cil_tmp44 = *__cil_tmp43;
#line 234
  __cil_tmp45 = (int )__cil_tmp44;
#line 234
  __cil_tmp46 = (bool )__cil_tmp45;
#line 234
  watchdog_set_nowayout(wm831x_wdt, __cil_tmp46);
#line 235
  __cil_tmp47 = (void *)driver_data;
#line 235
  watchdog_set_drvdata(wm831x_wdt, __cil_tmp47);
#line 237
  reg = wm831x_reg_read(wm831x, (unsigned short)16388);
#line 238
  reg = reg & 7;
#line 239
  i = 0;
  }
#line 239
  goto ldv_17563;
  ldv_17562: ;
  {
#line 240
  __cil_tmp48 = i * 8UL;
#line 240
  __cil_tmp49 = __cil_tmp48 + 4;
#line 240
  __cil_tmp50 = (unsigned long )(wm831x_wdt_cfgs) + __cil_tmp49;
#line 240
  __cil_tmp51 = *((u16 *)__cil_tmp50);
#line 240
  __cil_tmp52 = (int )__cil_tmp51;
#line 240
  if (__cil_tmp52 == reg) {
#line 241
    goto ldv_17561;
  } else {

  }
  }
#line 239
  i = i + 1;
  ldv_17563: ;
  {
#line 239
  __cil_tmp53 = (unsigned int )i;
#line 239
  if (__cil_tmp53 <= 6U) {
#line 240
    goto ldv_17562;
  } else {
#line 242
    goto ldv_17561;
  }
  }
  ldv_17561: ;
#line 242
  if (i == 7) {
    {
#line 243
    __cil_tmp54 = (unsigned long )wm831x;
#line 243
    __cil_tmp55 = __cil_tmp54 + 168;
#line 243
    __cil_tmp56 = *((struct device **)__cil_tmp55);
#line 243
    __cil_tmp57 = (struct device  const  *)__cil_tmp56;
#line 243
    dev_warn(__cil_tmp57, "Unknown watchdog timeout: %x\n", reg);
    }
  } else {
#line 246
    __cil_tmp58 = (unsigned long )wm831x_wdt;
#line 246
    __cil_tmp59 = __cil_tmp58 + 20;
#line 246
    __cil_tmp60 = i * 8UL;
#line 246
    __cil_tmp61 = (unsigned long )(wm831x_wdt_cfgs) + __cil_tmp60;
#line 246
    *((unsigned int *)__cil_tmp59) = *((unsigned int *)__cil_tmp61);
  }
  {
#line 249
  __cil_tmp62 = (void *)0;
#line 249
  __cil_tmp63 = (unsigned long )__cil_tmp62;
#line 249
  __cil_tmp64 = (unsigned long )pdev;
#line 249
  __cil_tmp65 = __cil_tmp64 + 16;
#line 249
  __cil_tmp66 = *((struct device **)__cil_tmp65);
#line 249
  __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 249
  __cil_tmp68 = __cil_tmp67 + 280;
#line 249
  __cil_tmp69 = *((void **)__cil_tmp68);
#line 249
  __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 249
  if (__cil_tmp70 != __cil_tmp63) {
#line 250
    __cil_tmp71 = (unsigned long )pdev;
#line 250
    __cil_tmp72 = __cil_tmp71 + 16;
#line 250
    __cil_tmp73 = *((struct device **)__cil_tmp72);
#line 250
    __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 250
    __cil_tmp75 = __cil_tmp74 + 280;
#line 250
    __cil_tmp76 = *((void **)__cil_tmp75);
#line 250
    chip_pdata = (struct wm831x_pdata *)__cil_tmp76;
#line 251
    __cil_tmp77 = (unsigned long )chip_pdata;
#line 251
    __cil_tmp78 = __cil_tmp77 + 136;
#line 251
    pdata = *((struct wm831x_watchdog_pdata **)__cil_tmp78);
  } else {
#line 253
    pdata = (struct wm831x_watchdog_pdata *)0;
  }
  }
  {
#line 256
  __cil_tmp79 = (struct wm831x_watchdog_pdata *)0;
#line 256
  __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 256
  __cil_tmp81 = (unsigned long )pdata;
#line 256
  if (__cil_tmp81 != __cil_tmp80) {
#line 257
    reg = reg & -9009;
#line 260
    __cil_tmp82 = (unsigned int )reg;
#line 260
    __cil_tmp83 = *((enum wm831x_watchdog_action *)pdata);
#line 260
    __cil_tmp84 = (unsigned int )__cil_tmp83;
#line 260
    __cil_tmp85 = __cil_tmp84 << 4;
#line 260
    __cil_tmp86 = __cil_tmp85 | __cil_tmp82;
#line 260
    reg = (int )__cil_tmp86;
#line 261
    __cil_tmp87 = (unsigned int )reg;
#line 261
    __cil_tmp88 = (unsigned long )pdata;
#line 261
    __cil_tmp89 = __cil_tmp88 + 4;
#line 261
    __cil_tmp90 = *((enum wm831x_watchdog_action *)__cil_tmp89);
#line 261
    __cil_tmp91 = (unsigned int )__cil_tmp90;
#line 261
    __cil_tmp92 = __cil_tmp91 << 8;
#line 261
    __cil_tmp93 = __cil_tmp92 | __cil_tmp87;
#line 261
    reg = (int )__cil_tmp93;
#line 262
    __cil_tmp94 = (unsigned long )pdata;
#line 262
    __cil_tmp95 = __cil_tmp94 + 12;
#line 262
    __cil_tmp96 = *((unsigned char *)__cil_tmp95);
#line 262
    __cil_tmp97 = (int )__cil_tmp96;
#line 262
    __cil_tmp98 = __cil_tmp97 << 13;
#line 262
    reg = __cil_tmp98 | reg;
    {
#line 264
    __cil_tmp99 = (unsigned long )pdata;
#line 264
    __cil_tmp100 = __cil_tmp99 + 8;
#line 264
    __cil_tmp101 = *((int *)__cil_tmp100);
#line 264
    if (__cil_tmp101 != 0) {
      {
#line 265
      __cil_tmp102 = (unsigned long )pdata;
#line 265
      __cil_tmp103 = __cil_tmp102 + 8;
#line 265
      __cil_tmp104 = *((int *)__cil_tmp103);
#line 265
      __cil_tmp105 = (unsigned int )__cil_tmp104;
#line 265
      ret = gpio_request(__cil_tmp105, "Watchdog update");
      }
#line 267
      if (ret < 0) {
        {
#line 268
        __cil_tmp106 = (unsigned long )wm831x;
#line 268
        __cil_tmp107 = __cil_tmp106 + 168;
#line 268
        __cil_tmp108 = *((struct device **)__cil_tmp107);
#line 268
        __cil_tmp109 = (struct device  const  *)__cil_tmp108;
#line 268
        dev_err(__cil_tmp109, "Failed to request update GPIO: %d\n", ret);
        }
#line 271
        goto err;
      } else {

      }
      {
#line 274
      __cil_tmp110 = (unsigned long )pdata;
#line 274
      __cil_tmp111 = __cil_tmp110 + 8;
#line 274
      __cil_tmp112 = *((int *)__cil_tmp111);
#line 274
      __cil_tmp113 = (unsigned int )__cil_tmp112;
#line 274
      ret = gpio_direction_output(__cil_tmp113, 0);
      }
#line 275
      if (ret != 0) {
        {
#line 276
        __cil_tmp114 = (unsigned long )wm831x;
#line 276
        __cil_tmp115 = __cil_tmp114 + 168;
#line 276
        __cil_tmp116 = *((struct device **)__cil_tmp115);
#line 276
        __cil_tmp117 = (struct device  const  *)__cil_tmp116;
#line 276
        dev_err(__cil_tmp117, "gpio_direction_output returned: %d\n", ret);
        }
#line 279
        goto err_gpio;
      } else {

      }
#line 282
      __cil_tmp118 = (unsigned long )driver_data;
#line 282
      __cil_tmp119 = __cil_tmp118 + 224;
#line 282
      __cil_tmp120 = (unsigned long )pdata;
#line 282
      __cil_tmp121 = __cil_tmp120 + 8;
#line 282
      *((int *)__cil_tmp119) = *((int *)__cil_tmp121);
#line 285
      reg = reg | 8192;
    } else {

    }
    }
    {
#line 288
    ret = wm831x_reg_unlock(wm831x);
    }
#line 289
    if (ret == 0) {
      {
#line 290
      __cil_tmp122 = (unsigned short )reg;
#line 290
      __cil_tmp123 = (int )__cil_tmp122;
#line 290
      __cil_tmp124 = (unsigned short )__cil_tmp123;
#line 290
      ret = wm831x_reg_write(wm831x, (unsigned short)16388, __cil_tmp124);
#line 291
      wm831x_reg_lock(wm831x);
      }
    } else {
      {
#line 293
      __cil_tmp125 = (unsigned long )wm831x;
#line 293
      __cil_tmp126 = __cil_tmp125 + 168;
#line 293
      __cil_tmp127 = *((struct device **)__cil_tmp126);
#line 293
      __cil_tmp128 = (struct device  const  *)__cil_tmp127;
#line 293
      dev_err(__cil_tmp128, "Failed to unlock security key: %d\n", ret);
      }
#line 295
      goto err_gpio;
    }
  } else {

  }
  }
  {
#line 299
  __cil_tmp129 = (struct watchdog_device *)driver_data;
#line 299
  ret = watchdog_register_device(__cil_tmp129);
  }
#line 300
  if (ret != 0) {
    {
#line 301
    __cil_tmp130 = (unsigned long )wm831x;
#line 301
    __cil_tmp131 = __cil_tmp130 + 168;
#line 301
    __cil_tmp132 = *((struct device **)__cil_tmp131);
#line 301
    __cil_tmp133 = (struct device  const  *)__cil_tmp132;
#line 301
    dev_err(__cil_tmp133, "watchdog_register_device() failed: %d\n", ret);
    }
#line 303
    goto err_gpio;
  } else {

  }
  {
#line 306
  __cil_tmp134 = (unsigned long )pdev;
#line 306
  __cil_tmp135 = __cil_tmp134 + 16;
#line 306
  __cil_tmp136 = (struct device *)__cil_tmp135;
#line 306
  __cil_tmp137 = (void *)driver_data;
#line 306
  dev_set_drvdata(__cil_tmp136, __cil_tmp137);
  }
#line 308
  return (0);
  err_gpio: ;
  {
#line 311
  __cil_tmp138 = (unsigned long )driver_data;
#line 311
  __cil_tmp139 = __cil_tmp138 + 224;
#line 311
  __cil_tmp140 = *((int *)__cil_tmp139);
#line 311
  if (__cil_tmp140 != 0) {
    {
#line 312
    __cil_tmp141 = (unsigned long )driver_data;
#line 312
    __cil_tmp142 = __cil_tmp141 + 224;
#line 312
    __cil_tmp143 = *((int *)__cil_tmp142);
#line 312
    __cil_tmp144 = (unsigned int )__cil_tmp143;
#line 312
    gpio_free(__cil_tmp144);
    }
  } else {

  }
  }
  err: ;
#line 314
  return (ret);
}
}
#line 360
extern void ldv_check_final_state(void) ;
#line 363
extern void ldv_check_return_value(int  ) ;
#line 366
extern void ldv_initialize(void) ;
#line 369
extern int __VERIFIER_nondet_int(void) ;
#line 372 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
int LDV_IN_INTERRUPT  ;
#line 375 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void main(void) 
{ struct watchdog_device *var_group1 ;
  unsigned int var_wm831x_wdt_set_timeout_3_p1 ;
  struct platform_device *var_group2 ;
  int res_wm831x_wdt_probe_4 ;
  int ldv_s_wm831x_wdt_driver_platform_driver ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 421
  ldv_s_wm831x_wdt_driver_platform_driver = 0;
#line 409
  LDV_IN_INTERRUPT = 1;
#line 418
  ldv_initialize();
  }
#line 424
  goto ldv_17618;
  ldv_17617: 
  {
#line 428
  tmp = __VERIFIER_nondet_int();
  }
#line 430
  if (tmp == 0) {
#line 430
    goto case_0;
  } else
#line 446
  if (tmp == 1) {
#line 446
    goto case_1;
  } else
#line 462
  if (tmp == 2) {
#line 462
    goto case_2;
  } else
#line 478
  if (tmp == 3) {
#line 478
    goto case_3;
  } else
#line 494
  if (tmp == 4) {
#line 494
    goto case_4;
  } else {
    {
#line 513
    goto switch_default;
#line 428
    if (0) {
      case_0: /* CIL Label */ 
      {
#line 438
      wm831x_wdt_start(var_group1);
      }
#line 445
      goto ldv_17610;
      case_1: /* CIL Label */ 
      {
#line 454
      wm831x_wdt_stop(var_group1);
      }
#line 461
      goto ldv_17610;
      case_2: /* CIL Label */ 
      {
#line 470
      wm831x_wdt_ping(var_group1);
      }
#line 477
      goto ldv_17610;
      case_3: /* CIL Label */ 
      {
#line 486
      wm831x_wdt_set_timeout(var_group1, var_wm831x_wdt_set_timeout_3_p1);
      }
#line 493
      goto ldv_17610;
      case_4: /* CIL Label */ ;
#line 497
      if (ldv_s_wm831x_wdt_driver_platform_driver == 0) {
        {
#line 502
        res_wm831x_wdt_probe_4 = wm831x_wdt_probe(var_group2);
#line 503
        ldv_check_return_value(res_wm831x_wdt_probe_4);
        }
#line 504
        if (res_wm831x_wdt_probe_4 != 0) {
#line 505
          goto ldv_module_exit;
        } else {

        }
#line 506
        ldv_s_wm831x_wdt_driver_platform_driver = 0;
      } else {

      }
#line 512
      goto ldv_17610;
      switch_default: /* CIL Label */ ;
#line 513
      goto ldv_17610;
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_17610: ;
  ldv_17618: 
  {
#line 424
  tmp___0 = __VERIFIER_nondet_int();
  }
#line 424
  if (tmp___0 != 0) {
#line 426
    goto ldv_17617;
  } else
#line 424
  if (ldv_s_wm831x_wdt_driver_platform_driver != 0) {
#line 426
    goto ldv_17617;
  } else {
#line 428
    goto ldv_17619;
  }
  ldv_17619: ;
  ldv_module_exit: ;
  {
#line 522
  ldv_check_final_state();
  }
#line 525
  return;
}
}
#line 5 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/kernel-rules/files/engine-blast-assert.h"
void ldv_blast_assert(void) 
{ 

  {
  ERROR: __VERIFIER_error();
}
}
#line 6 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/kernel-rules/files/engine-blast.h"
extern int __VERIFIER_nondet_int(void) ;
#line 546 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
int ldv_spin  =    0;
#line 550 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 

  {
#line 553
  if (ldv_spin != 0) {
#line 553
    if (flags != 32U) {
      {
#line 553
      ldv_blast_assert();
      }
    } else {

    }
  } else {

  }
#line 556
  return;
}
}
#line 556
extern struct page *ldv_some_page(void) ;
#line 559 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ struct page *tmp ;

  {
#line 562
  if (ldv_spin != 0) {
#line 562
    if (flags != 32U) {
      {
#line 562
      ldv_blast_assert();
      }
    } else {

    }
  } else {

  }
  {
#line 564
  tmp = ldv_some_page();
  }
#line 564
  return (tmp);
}
}
#line 568 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void ldv_check_alloc_nonatomic(void) 
{ 

  {
#line 571
  if (ldv_spin != 0) {
    {
#line 571
    ldv_blast_assert();
    }
  } else {

  }
#line 574
  return;
}
}
#line 575 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void ldv_spin_lock(void) 
{ 

  {
#line 578
  ldv_spin = 1;
#line 579
  return;
}
}
#line 582 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void ldv_spin_unlock(void) 
{ 

  {
#line 585
  ldv_spin = 0;
#line 586
  return;
}
}
#line 589 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
int ldv_spin_trylock(void) 
{ int is_lock ;

  {
  {
#line 594
  is_lock = __VERIFIER_nondet_int();
  }
#line 596
  if (is_lock != 0) {
#line 599
    return (0);
  } else {
#line 604
    ldv_spin = 1;
#line 606
    return (1);
  }
}
}
#line 773 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/17374/dscv_tempdir/dscv/ri/43_1a/drivers/watchdog/wm831x_wdt.c.p"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 

  {
  {
#line 779
  ldv_check_alloc_flags(ldv_func_arg2);
#line 781
  kmem_cache_alloc(ldv_func_arg1, ldv_func_arg2);
  }
#line 782
  return ((void *)0);
}
}
