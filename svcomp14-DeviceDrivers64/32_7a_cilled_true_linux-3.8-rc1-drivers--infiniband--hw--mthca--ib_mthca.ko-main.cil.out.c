/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 71 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 13 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 357
struct cpumask;
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 443 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct kmem_cache;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 752 "include/linux/mmzone.h"
struct rw_semaphore;
#line 753 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 128 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 267 "include/linux/timer.h"
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 135 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 398 "include/linux/gfp.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 44 "include/linux/elf.h"
struct sock;
#line 45
struct kobject;
#line 46
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 52 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14021_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14021_134 ldv_14021 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 191 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
#line 225 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 610
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 17 "include/linux/irqreturn.h"
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 95 "include/linux/pci.h"
typedef int pci_power_t;
#line 122 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 123
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 165 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 208
struct pcie_link_state;
#line 209
struct pci_vpd;
#line 210
struct pci_sriov;
#line 211
struct pci_ats;
#line 212
struct proc_dir_entry;
#line 212
struct pci_driver;
#line 212 "include/linux/pci.h"
union __anonunion_ldv_15732_136 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 212 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_15732_136 ldv_15732 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 401
struct pci_ops;
#line 401 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 492 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 513 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 526 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 536 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 566 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1070 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct dma_pool;
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 1223 "include/linux/pci.h"
struct inode;
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112
struct address_space;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_16763_138 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_16773_142 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_16775_141 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_16773_142 ldv_16773 ;
   int units ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_16777_140 {
   union __anonunion_ldv_16775_141 ldv_16775 ;
   atomic_t _count ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_16778_139 {
   unsigned long counters ;
   struct __anonstruct_ldv_16777_140 ldv_16777 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_16779_137 {
   union __anonunion_ldv_16763_138 ldv_16763 ;
   union __anonunion_ldv_16778_139 ldv_16778 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_16786_144 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 113
struct slab;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_16790_143 {
   struct list_head lru ;
   struct __anonstruct_ldv_16786_144 ldv_16786 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_16795_145 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 113 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_16779_137 ldv_16779 ;
   union __anonunion_ldv_16790_143 ldv_16790 ;
   union __anonunion_ldv_16795_145 ldv_16795 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_147 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_146 {
   struct __anonstruct_linear_147 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_146 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 1751
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_19554_149 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_19555_148 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_19554_149 ldv_19554 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_19555_148 ldv_19555 ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 273 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 698 "include/linux/interrupt.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 56 "include/rdma/ib_verbs.h"
struct __anonstruct_global_151 {
   __be64 subnet_prefix ;
   __be64 interface_id ;
};
#line 56 "include/rdma/ib_verbs.h"
union ib_gid {
   u8 raw[16U] ;
   struct __anonstruct_global_151 global ;
};
#line 80
enum rdma_link_layer {
    IB_LINK_LAYER_UNSPECIFIED = 0,
    IB_LINK_LAYER_INFINIBAND = 1,
    IB_LINK_LAYER_ETHERNET = 2
} ;
#line 112
enum ib_atomic_cap {
    IB_ATOMIC_NONE = 0,
    IB_ATOMIC_HCA = 1,
    IB_ATOMIC_GLOB = 2
} ;
#line 118 "include/rdma/ib_verbs.h"
struct ib_device_attr {
   u64 fw_ver ;
   __be64 sys_image_guid ;
   u64 max_mr_size ;
   u64 page_size_cap ;
   u32 vendor_id ;
   u32 vendor_part_id ;
   u32 hw_ver ;
   int max_qp ;
   int max_qp_wr ;
   int device_cap_flags ;
   int max_sge ;
   int max_sge_rd ;
   int max_cq ;
   int max_cqe ;
   int max_mr ;
   int max_pd ;
   int max_qp_rd_atom ;
   int max_ee_rd_atom ;
   int max_res_rd_atom ;
   int max_qp_init_rd_atom ;
   int max_ee_init_rd_atom ;
   enum ib_atomic_cap atomic_cap ;
   enum ib_atomic_cap masked_atomic_cap ;
   int max_ee ;
   int max_rdd ;
   int max_mw ;
   int max_raw_ipv6_qp ;
   int max_raw_ethy_qp ;
   int max_mcast_grp ;
   int max_mcast_qp_attach ;
   int max_total_mcast_qp_attach ;
   int max_ah ;
   int max_fmr ;
   int max_map_per_fmr ;
   int max_srq ;
   int max_srq_wr ;
   int max_srq_sge ;
   unsigned int max_fast_reg_page_list_len ;
   u16 max_pkeys ;
   u8 local_ca_ack_delay ;
};
#line 168
enum ib_mtu {
    IB_MTU_256 = 1,
    IB_MTU_512 = 2,
    IB_MTU_1024 = 3,
    IB_MTU_2048 = 4,
    IB_MTU_4096 = 5
} ;
#line 188
enum ib_port_state {
    IB_PORT_NOP = 0,
    IB_PORT_DOWN = 1,
    IB_PORT_INIT = 2,
    IB_PORT_ARMED = 3,
    IB_PORT_ACTIVE = 4,
    IB_PORT_ACTIVE_DEFER = 5
} ;
#line 250 "include/rdma/ib_verbs.h"
struct ib_protocol_stats {

};
#line 253 "include/rdma/ib_verbs.h"
struct iw_protocol_stats {
   u64 ipInReceives ;
   u64 ipInHdrErrors ;
   u64 ipInTooBigErrors ;
   u64 ipInNoRoutes ;
   u64 ipInAddrErrors ;
   u64 ipInUnknownProtos ;
   u64 ipInTruncatedPkts ;
   u64 ipInDiscards ;
   u64 ipInDelivers ;
   u64 ipOutForwDatagrams ;
   u64 ipOutRequests ;
   u64 ipOutDiscards ;
   u64 ipOutNoRoutes ;
   u64 ipReasmTimeout ;
   u64 ipReasmReqds ;
   u64 ipReasmOKs ;
   u64 ipReasmFails ;
   u64 ipFragOKs ;
   u64 ipFragFails ;
   u64 ipFragCreates ;
   u64 ipInMcastPkts ;
   u64 ipOutMcastPkts ;
   u64 ipInBcastPkts ;
   u64 ipOutBcastPkts ;
   u64 tcpRtoAlgorithm ;
   u64 tcpRtoMin ;
   u64 tcpRtoMax ;
   u64 tcpMaxConn ;
   u64 tcpActiveOpens ;
   u64 tcpPassiveOpens ;
   u64 tcpAttemptFails ;
   u64 tcpEstabResets ;
   u64 tcpCurrEstab ;
   u64 tcpInSegs ;
   u64 tcpOutSegs ;
   u64 tcpRetransSegs ;
   u64 tcpInErrs ;
   u64 tcpOutRsts ;
};
#line 296 "include/rdma/ib_verbs.h"
union rdma_protocol_stats {
   struct ib_protocol_stats ib ;
   struct iw_protocol_stats iw ;
};
#line 301 "include/rdma/ib_verbs.h"
struct ib_port_attr {
   enum ib_port_state state ;
   enum ib_mtu max_mtu ;
   enum ib_mtu active_mtu ;
   int gid_tbl_len ;
   u32 port_cap_flags ;
   u32 max_msg_sz ;
   u32 bad_pkey_cntr ;
   u32 qkey_viol_cntr ;
   u16 pkey_tbl_len ;
   u16 lid ;
   u16 sm_lid ;
   u8 lmc ;
   u8 max_vl_num ;
   u8 sm_sl ;
   u8 subnet_timeout ;
   u8 init_type_reply ;
   u8 active_width ;
   u8 active_speed ;
   u8 phys_state ;
};
#line 328 "include/rdma/ib_verbs.h"
struct ib_device_modify {
   u64 sys_image_guid ;
   char node_desc[64U] ;
};
#line 339 "include/rdma/ib_verbs.h"
struct ib_port_modify {
   u32 set_port_cap_mask ;
   u32 clr_port_cap_mask ;
   u8 init_type ;
};
#line 345
enum ib_event_type {
    IB_EVENT_CQ_ERR = 0,
    IB_EVENT_QP_FATAL = 1,
    IB_EVENT_QP_REQ_ERR = 2,
    IB_EVENT_QP_ACCESS_ERR = 3,
    IB_EVENT_COMM_EST = 4,
    IB_EVENT_SQ_DRAINED = 5,
    IB_EVENT_PATH_MIG = 6,
    IB_EVENT_PATH_MIG_ERR = 7,
    IB_EVENT_DEVICE_FATAL = 8,
    IB_EVENT_PORT_ACTIVE = 9,
    IB_EVENT_PORT_ERR = 10,
    IB_EVENT_LID_CHANGE = 11,
    IB_EVENT_PKEY_CHANGE = 12,
    IB_EVENT_SM_CHANGE = 13,
    IB_EVENT_SRQ_ERR = 14,
    IB_EVENT_SRQ_LIMIT_REACHED = 15,
    IB_EVENT_QP_LAST_WQE_REACHED = 16,
    IB_EVENT_CLIENT_REREGISTER = 17,
    IB_EVENT_GID_CHANGE = 18
} ;
#line 367
struct ib_device;
#line 367
struct ib_cq;
#line 367
struct ib_qp;
#line 367
struct ib_srq;
#line 367 "include/rdma/ib_verbs.h"
union __anonunion_element_152 {
   struct ib_cq *cq ;
   struct ib_qp *qp ;
   struct ib_srq *srq ;
   u8 port_num ;
};
#line 367 "include/rdma/ib_verbs.h"
struct ib_event {
   struct ib_device *device ;
   union __anonunion_element_152 element ;
   enum ib_event_type event ;
};
#line 378 "include/rdma/ib_verbs.h"
struct ib_event_handler {
   struct ib_device *device ;
   void (*handler)(struct ib_event_handler * , struct ib_event * ) ;
   struct list_head list ;
};
#line 384 "include/rdma/ib_verbs.h"
struct ib_global_route {
   union ib_gid dgid ;
   u32 flow_label ;
   u8 sgid_index ;
   u8 hop_limit ;
   u8 traffic_class ;
};
#line 399 "include/rdma/ib_verbs.h"
struct ib_grh {
   __be32 version_tclass_flow ;
   __be16 paylen ;
   u8 next_hdr ;
   u8 hop_limit ;
   union ib_gid sgid ;
   union ib_gid dgid ;
};
#line 461 "include/rdma/ib_verbs.h"
struct ib_ah_attr {
   struct ib_global_route grh ;
   u16 dlid ;
   u8 sl ;
   u8 src_path_bits ;
   u8 static_rate ;
   u8 ah_flags ;
   u8 port_num ;
};
#line 471
enum ib_wc_status {
    IB_WC_SUCCESS = 0,
    IB_WC_LOC_LEN_ERR = 1,
    IB_WC_LOC_QP_OP_ERR = 2,
    IB_WC_LOC_EEC_OP_ERR = 3,
    IB_WC_LOC_PROT_ERR = 4,
    IB_WC_WR_FLUSH_ERR = 5,
    IB_WC_MW_BIND_ERR = 6,
    IB_WC_BAD_RESP_ERR = 7,
    IB_WC_LOC_ACCESS_ERR = 8,
    IB_WC_REM_INV_REQ_ERR = 9,
    IB_WC_REM_ACCESS_ERR = 10,
    IB_WC_REM_OP_ERR = 11,
    IB_WC_RETRY_EXC_ERR = 12,
    IB_WC_RNR_RETRY_EXC_ERR = 13,
    IB_WC_LOC_RDD_VIOL_ERR = 14,
    IB_WC_REM_INV_RD_REQ_ERR = 15,
    IB_WC_REM_ABORT_ERR = 16,
    IB_WC_INV_EECN_ERR = 17,
    IB_WC_INV_EEC_STATE_ERR = 18,
    IB_WC_FATAL_ERR = 19,
    IB_WC_RESP_TIMEOUT_ERR = 20,
    IB_WC_GENERAL_ERR = 21
} ;
#line 496
enum ib_wc_opcode {
    IB_WC_SEND = 0,
    IB_WC_RDMA_WRITE = 1,
    IB_WC_RDMA_READ = 2,
    IB_WC_COMP_SWAP = 3,
    IB_WC_FETCH_ADD = 4,
    IB_WC_BIND_MW = 5,
    IB_WC_LSO = 6,
    IB_WC_LOCAL_INV = 7,
    IB_WC_FAST_REG_MR = 8,
    IB_WC_MASKED_COMP_SWAP = 9,
    IB_WC_MASKED_FETCH_ADD = 10,
    IB_WC_RECV = 128,
    IB_WC_RECV_RDMA_WITH_IMM = 129
} ;
#line 519 "include/rdma/ib_verbs.h"
union __anonunion_ex_153 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 519 "include/rdma/ib_verbs.h"
struct ib_wc {
   u64 wr_id ;
   enum ib_wc_status status ;
   enum ib_wc_opcode opcode ;
   u32 vendor_err ;
   u32 byte_len ;
   struct ib_qp *qp ;
   union __anonunion_ex_153 ex ;
   u32 src_qp ;
   int wc_flags ;
   u16 pkey_index ;
   u16 slid ;
   u8 sl ;
   u8 dlid_path_bits ;
   u8 port_num ;
};
#line 543
enum ib_cq_notify_flags {
    IB_CQ_SOLICITED = 1,
    IB_CQ_NEXT_COMP = 2,
    IB_CQ_SOLICITED_MASK = 3,
    IB_CQ_REPORT_MISSED_EVENTS = 4
} ;
#line 550
enum ib_srq_type {
    IB_SRQT_BASIC = 0,
    IB_SRQT_XRC = 1
} ;
#line 555
enum ib_srq_attr_mask {
    IB_SRQ_MAX_WR = 1,
    IB_SRQ_LIMIT = 2
} ;
#line 560 "include/rdma/ib_verbs.h"
struct ib_srq_attr {
   u32 max_wr ;
   u32 max_sge ;
   u32 srq_limit ;
};
#line 566
struct ib_xrcd;
#line 566 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_155 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
};
#line 566 "include/rdma/ib_verbs.h"
union __anonunion_ext_154 {
   struct __anonstruct_xrc_155 xrc ;
};
#line 566 "include/rdma/ib_verbs.h"
struct ib_srq_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   struct ib_srq_attr attr ;
   enum ib_srq_type srq_type ;
   union __anonunion_ext_154 ext ;
};
#line 580 "include/rdma/ib_verbs.h"
struct ib_qp_cap {
   u32 max_send_wr ;
   u32 max_recv_wr ;
   u32 max_send_sge ;
   u32 max_recv_sge ;
   u32 max_inline_data ;
};
#line 588
enum ib_sig_type {
    IB_SIGNAL_ALL_WR = 0,
    IB_SIGNAL_REQ_WR = 1
} ;
#line 593
enum ib_qp_type {
    IB_QPT_SMI = 0,
    IB_QPT_GSI = 1,
    IB_QPT_RC = 2,
    IB_QPT_UC = 3,
    IB_QPT_UD = 4,
    IB_QPT_RAW_IPV6 = 5,
    IB_QPT_RAW_ETHERTYPE = 6,
    IB_QPT_RAW_PACKET = 8,
    IB_QPT_XRC_INI = 9,
    IB_QPT_XRC_TGT = 10,
    IB_QPT_MAX = 11
} ;
#line 607
enum ib_qp_create_flags {
    IB_QP_CREATE_IPOIB_UD_LSO = 1,
    IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
    IB_QP_CREATE_RESERVED_START = 67108864,
    IB_QP_CREATE_RESERVED_END = (-0x7FFFFFFF-1)
} ;
#line 614 "include/rdma/ib_verbs.h"
struct ib_qp_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct ib_qp_cap cap ;
   enum ib_sig_type sq_sig_type ;
   enum ib_qp_type qp_type ;
   enum ib_qp_create_flags create_flags ;
   u8 port_num ;
};
#line 701
enum ib_qp_state {
    IB_QPS_RESET = 0,
    IB_QPS_INIT = 1,
    IB_QPS_RTR = 2,
    IB_QPS_RTS = 3,
    IB_QPS_SQD = 4,
    IB_QPS_SQE = 5,
    IB_QPS_ERR = 6
} ;
#line 711
enum ib_mig_state {
    IB_MIG_MIGRATED = 0,
    IB_MIG_REARM = 1,
    IB_MIG_ARMED = 2
} ;
#line 717 "include/rdma/ib_verbs.h"
struct ib_qp_attr {
   enum ib_qp_state qp_state ;
   enum ib_qp_state cur_qp_state ;
   enum ib_mtu path_mtu ;
   enum ib_mig_state path_mig_state ;
   u32 qkey ;
   u32 rq_psn ;
   u32 sq_psn ;
   u32 dest_qp_num ;
   int qp_access_flags ;
   struct ib_qp_cap cap ;
   struct ib_ah_attr ah_attr ;
   struct ib_ah_attr alt_ah_attr ;
   u16 pkey_index ;
   u16 alt_pkey_index ;
   u8 en_sqd_async_notify ;
   u8 sq_draining ;
   u8 max_rd_atomic ;
   u8 max_dest_rd_atomic ;
   u8 min_rnr_timer ;
   u8 port_num ;
   u8 timeout ;
   u8 retry_cnt ;
   u8 rnr_retry ;
   u8 alt_port_num ;
   u8 alt_timeout ;
};
#line 745
enum ib_wr_opcode {
    IB_WR_RDMA_WRITE = 0,
    IB_WR_RDMA_WRITE_WITH_IMM = 1,
    IB_WR_SEND = 2,
    IB_WR_SEND_WITH_IMM = 3,
    IB_WR_RDMA_READ = 4,
    IB_WR_ATOMIC_CMP_AND_SWP = 5,
    IB_WR_ATOMIC_FETCH_AND_ADD = 6,
    IB_WR_LSO = 7,
    IB_WR_SEND_WITH_INV = 8,
    IB_WR_RDMA_READ_WITH_INV = 9,
    IB_WR_LOCAL_INV = 10,
    IB_WR_FAST_REG_MR = 11,
    IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
    IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13
} ;
#line 770 "include/rdma/ib_verbs.h"
struct ib_sge {
   u64 addr ;
   u32 length ;
   u32 lkey ;
};
#line 776 "include/rdma/ib_verbs.h"
struct ib_fast_reg_page_list {
   struct ib_device *device ;
   u64 *page_list ;
   unsigned int max_page_list_len ;
};
#line 782 "include/rdma/ib_verbs.h"
union __anonunion_ex_156 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 782 "include/rdma/ib_verbs.h"
struct __anonstruct_rdma_158 {
   u64 remote_addr ;
   u32 rkey ;
};
#line 782 "include/rdma/ib_verbs.h"
struct __anonstruct_atomic_159 {
   u64 remote_addr ;
   u64 compare_add ;
   u64 swap ;
   u64 compare_add_mask ;
   u64 swap_mask ;
   u32 rkey ;
};
#line 782
struct ib_ah;
#line 782 "include/rdma/ib_verbs.h"
struct __anonstruct_ud_160 {
   struct ib_ah *ah ;
   void *header ;
   int hlen ;
   int mss ;
   u32 remote_qpn ;
   u32 remote_qkey ;
   u16 pkey_index ;
   u8 port_num ;
};
#line 782 "include/rdma/ib_verbs.h"
struct __anonstruct_fast_reg_161 {
   u64 iova_start ;
   struct ib_fast_reg_page_list *page_list ;
   unsigned int page_shift ;
   unsigned int page_list_len ;
   u32 length ;
   int access_flags ;
   u32 rkey ;
};
#line 782 "include/rdma/ib_verbs.h"
union __anonunion_wr_157 {
   struct __anonstruct_rdma_158 rdma ;
   struct __anonstruct_atomic_159 atomic ;
   struct __anonstruct_ud_160 ud ;
   struct __anonstruct_fast_reg_161 fast_reg ;
};
#line 782 "include/rdma/ib_verbs.h"
struct ib_send_wr {
   struct ib_send_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
   enum ib_wr_opcode opcode ;
   int send_flags ;
   union __anonunion_ex_156 ex ;
   union __anonunion_wr_157 wr ;
   u32 xrc_remote_srq_num ;
};
#line 829 "include/rdma/ib_verbs.h"
struct ib_recv_wr {
   struct ib_recv_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
};
#line 844 "include/rdma/ib_verbs.h"
struct ib_phys_buf {
   u64 addr ;
   u64 size ;
};
#line 849
struct ib_pd;
#line 849 "include/rdma/ib_verbs.h"
struct ib_mr_attr {
   struct ib_pd *pd ;
   u64 device_virt_addr ;
   u64 size ;
   int mr_access_flags ;
   u32 lkey ;
   u32 rkey ;
};
#line 864
struct ib_mr;
#line 864 "include/rdma/ib_verbs.h"
struct ib_mw_bind {
   struct ib_mr *mr ;
   u64 wr_id ;
   u64 addr ;
   u32 length ;
   int send_flags ;
   int mw_access_flags ;
};
#line 873 "include/rdma/ib_verbs.h"
struct ib_fmr_attr {
   int max_pages ;
   int max_maps ;
   u8 page_shift ;
};
#line 879 "include/rdma/ib_verbs.h"
struct ib_ucontext {
   struct ib_device *device ;
   struct list_head pd_list ;
   struct list_head mr_list ;
   struct list_head mw_list ;
   struct list_head cq_list ;
   struct list_head qp_list ;
   struct list_head srq_list ;
   struct list_head ah_list ;
   struct list_head xrcd_list ;
   int closing ;
};
#line 892 "include/rdma/ib_verbs.h"
struct ib_uobject {
   u64 user_handle ;
   struct ib_ucontext *context ;
   void *object ;
   struct list_head list ;
   int id ;
   struct kref ref ;
   struct rw_semaphore mutex ;
   int live ;
};
#line 903 "include/rdma/ib_verbs.h"
struct ib_udata {
   void *inbuf ;
   void *outbuf ;
   size_t inlen ;
   size_t outlen ;
};
#line 910 "include/rdma/ib_verbs.h"
struct ib_pd {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   atomic_t usecnt ;
};
#line 916 "include/rdma/ib_verbs.h"
struct ib_xrcd {
   struct ib_device *device ;
   atomic_t usecnt ;
   struct inode *inode ;
   struct mutex tgt_qp_mutex ;
   struct list_head tgt_qp_list ;
};
#line 925 "include/rdma/ib_verbs.h"
struct ib_ah {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
};
#line 933 "include/rdma/ib_verbs.h"
struct ib_cq {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   void (*comp_handler)(struct ib_cq * , void * ) ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *cq_context ;
   int cqe ;
   atomic_t usecnt ;
};
#line 943 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_163 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
   u32 srq_num ;
};
#line 943 "include/rdma/ib_verbs.h"
union __anonunion_ext_162 {
   struct __anonstruct_xrc_163 xrc ;
};
#line 943 "include/rdma/ib_verbs.h"
struct ib_srq {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   enum ib_srq_type srq_type ;
   atomic_t usecnt ;
   union __anonunion_ext_162 ext ;
};
#line 961 "include/rdma/ib_verbs.h"
struct ib_qp {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct list_head xrcd_list ;
   atomic_t usecnt ;
   struct list_head open_list ;
   struct ib_qp *real_qp ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   u32 qp_num ;
   enum ib_qp_type qp_type ;
};
#line 979 "include/rdma/ib_verbs.h"
struct ib_mr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 lkey ;
   u32 rkey ;
   atomic_t usecnt ;
};
#line 988 "include/rdma/ib_verbs.h"
struct ib_mw {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 rkey ;
};
#line 995 "include/rdma/ib_verbs.h"
struct ib_fmr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct list_head list ;
   u32 lkey ;
   u32 rkey ;
};
#line 1003
struct ib_mad;
#line 1017
struct ib_pkey_cache;
#line 1017
struct ib_gid_cache;
#line 1017 "include/rdma/ib_verbs.h"
struct ib_cache {
   rwlock_t lock ;
   struct ib_event_handler event_handler ;
   struct ib_pkey_cache **pkey_cache ;
   struct ib_gid_cache **gid_cache ;
   u8 *lmc_cache ;
};
#line 1029 "include/rdma/ib_verbs.h"
struct ib_dma_mapping_ops {
   int (*mapping_error)(struct ib_device * , u64  ) ;
   u64 (*map_single)(struct ib_device * , void * , size_t  , enum dma_data_direction  ) ;
   void (*unmap_single)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   u64 (*map_page)(struct ib_device * , struct page * , unsigned long  , size_t  ,
                   enum dma_data_direction  ) ;
   void (*unmap_page)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   int (*map_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*unmap_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   u64 (*dma_address)(struct ib_device * , struct scatterlist * ) ;
   unsigned int (*dma_len)(struct ib_device * , struct scatterlist * ) ;
   void (*sync_single_for_cpu)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void *(*alloc_coherent)(struct ib_device * , size_t  , u64 * , gfp_t  ) ;
   void (*free_coherent)(struct ib_device * , size_t  , void * , u64  ) ;
};
#line 1070
struct iw_cm_verbs;
#line 1071
enum ldv_20016 {
    IB_DEV_UNINITIALIZED = 0,
    IB_DEV_REGISTERED = 1,
    IB_DEV_UNREGISTERED = 2
} ;
#line 1077 "include/rdma/ib_verbs.h"
struct ib_device {
   struct device *dma_device ;
   char name[64U] ;
   struct list_head event_handler_list ;
   spinlock_t event_handler_lock ;
   spinlock_t client_data_lock ;
   struct list_head core_list ;
   struct list_head client_data_list ;
   struct ib_cache cache ;
   int *pkey_tbl_len ;
   int *gid_tbl_len ;
   int num_comp_vectors ;
   struct iw_cm_verbs *iwcm ;
   int (*get_protocol_stats)(struct ib_device * , union rdma_protocol_stats * ) ;
   int (*query_device)(struct ib_device * , struct ib_device_attr * ) ;
   int (*query_port)(struct ib_device * , u8  , struct ib_port_attr * ) ;
   enum rdma_link_layer (*get_link_layer)(struct ib_device * , u8  ) ;
   int (*query_gid)(struct ib_device * , u8  , int  , union ib_gid * ) ;
   int (*query_pkey)(struct ib_device * , u8  , u16  , u16 * ) ;
   int (*modify_device)(struct ib_device * , int  , struct ib_device_modify * ) ;
   int (*modify_port)(struct ib_device * , u8  , int  , struct ib_port_modify * ) ;
   struct ib_ucontext *(*alloc_ucontext)(struct ib_device * , struct ib_udata * ) ;
   int (*dealloc_ucontext)(struct ib_ucontext * ) ;
   int (*mmap)(struct ib_ucontext * , struct vm_area_struct * ) ;
   struct ib_pd *(*alloc_pd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_pd)(struct ib_pd * ) ;
   struct ib_ah *(*create_ah)(struct ib_pd * , struct ib_ah_attr * ) ;
   int (*modify_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*query_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*destroy_ah)(struct ib_ah * ) ;
   struct ib_srq *(*create_srq)(struct ib_pd * , struct ib_srq_init_attr * , struct ib_udata * ) ;
   int (*modify_srq)(struct ib_srq * , struct ib_srq_attr * , enum ib_srq_attr_mask  ,
                     struct ib_udata * ) ;
   int (*query_srq)(struct ib_srq * , struct ib_srq_attr * ) ;
   int (*destroy_srq)(struct ib_srq * ) ;
   int (*post_srq_recv)(struct ib_srq * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_qp *(*create_qp)(struct ib_pd * , struct ib_qp_init_attr * , struct ib_udata * ) ;
   int (*modify_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_udata * ) ;
   int (*query_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_qp_init_attr * ) ;
   int (*destroy_qp)(struct ib_qp * ) ;
   int (*post_send)(struct ib_qp * , struct ib_send_wr * , struct ib_send_wr ** ) ;
   int (*post_recv)(struct ib_qp * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_cq *(*create_cq)(struct ib_device * , int  , int  , struct ib_ucontext * ,
                              struct ib_udata * ) ;
   int (*modify_cq)(struct ib_cq * , u16  , u16  ) ;
   int (*destroy_cq)(struct ib_cq * ) ;
   int (*resize_cq)(struct ib_cq * , int  , struct ib_udata * ) ;
   int (*poll_cq)(struct ib_cq * , int  , struct ib_wc * ) ;
   int (*peek_cq)(struct ib_cq * , int  ) ;
   int (*req_notify_cq)(struct ib_cq * , enum ib_cq_notify_flags  ) ;
   int (*req_ncomp_notif)(struct ib_cq * , int  ) ;
   struct ib_mr *(*get_dma_mr)(struct ib_pd * , int  ) ;
   struct ib_mr *(*reg_phys_mr)(struct ib_pd * , struct ib_phys_buf * , int  , int  ,
                                u64 * ) ;
   struct ib_mr *(*reg_user_mr)(struct ib_pd * , u64  , u64  , u64  , int  , struct ib_udata * ) ;
   int (*query_mr)(struct ib_mr * , struct ib_mr_attr * ) ;
   int (*dereg_mr)(struct ib_mr * ) ;
   struct ib_mr *(*alloc_fast_reg_mr)(struct ib_pd * , int  ) ;
   struct ib_fast_reg_page_list *(*alloc_fast_reg_page_list)(struct ib_device * ,
                                                             int  ) ;
   void (*free_fast_reg_page_list)(struct ib_fast_reg_page_list * ) ;
   int (*rereg_phys_mr)(struct ib_mr * , int  , struct ib_pd * , struct ib_phys_buf * ,
                        int  , int  , u64 * ) ;
   struct ib_mw *(*alloc_mw)(struct ib_pd * ) ;
   int (*bind_mw)(struct ib_qp * , struct ib_mw * , struct ib_mw_bind * ) ;
   int (*dealloc_mw)(struct ib_mw * ) ;
   struct ib_fmr *(*alloc_fmr)(struct ib_pd * , int  , struct ib_fmr_attr * ) ;
   int (*map_phys_fmr)(struct ib_fmr * , u64 * , int  , u64  ) ;
   int (*unmap_fmr)(struct list_head * ) ;
   int (*dealloc_fmr)(struct ib_fmr * ) ;
   int (*attach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*detach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*process_mad)(struct ib_device * , int  , u8  , struct ib_wc * , struct ib_grh * ,
                      struct ib_mad * , struct ib_mad * ) ;
   struct ib_xrcd *(*alloc_xrcd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_xrcd)(struct ib_xrcd * ) ;
   struct ib_dma_mapping_ops *dma_ops ;
   struct module *owner ;
   struct device dev ;
   struct kobject *ports_parent ;
   struct list_head port_list ;
   enum ldv_20016 reg_state ;
   int uverbs_abi_ver ;
   u64 uverbs_cmd_mask ;
   char node_desc[64U] ;
   __be64 node_guid ;
   u32 local_dma_lkey ;
   u8 node_type ;
   u8 phys_port_cnt ;
};
#line 265 "include/rdma/ib_pack.h"
struct mthca_buf_list {
   void *buf ;
   dma_addr_t mapping ;
};
#line 56 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_uar {
   unsigned long pfn ;
   int index ;
};
#line 70
struct mthca_mtt;
#line 71
struct ib_umem;
#line 71 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_mr {
   struct ib_mr ibmr ;
   struct ib_umem *umem ;
   struct mthca_mtt *mtt ;
};
#line 96 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_pd {
   struct ib_pd ibpd ;
   u32 pd_num ;
   atomic_t sqp_count ;
   struct mthca_mr ntmr ;
   int privileged ;
};
#line 104
struct mthca_dev;
#line 104 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_eq {
   struct mthca_dev *dev ;
   int eqn ;
   u32 eqn_mask ;
   u32 cons_index ;
   u16 msi_x_vector ;
   u16 msi_x_entry ;
   int have_irq ;
   int nent ;
   struct mthca_buf_list *page_list ;
   struct mthca_mr mr ;
   char irq_name[64U] ;
};
#line 129 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
struct mthca_cmd_context;
#line 129 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
struct mthca_cmd {
   struct dma_pool *pool ;
   struct mutex hcr_mutex ;
   struct semaphore poll_sem ;
   struct semaphore event_sem ;
   int max_cmds ;
   spinlock_t context_lock ;
   int free_head ;
   struct mthca_cmd_context *context ;
   u16 token_mask ;
   u32 flags ;
   void *dbell_map ;
   u16 dbell_offsets[8U] ;
};
#line 134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_limits {
   int num_ports ;
   int vl_cap ;
   int mtu_cap ;
   int gid_table_len ;
   int pkey_table_len ;
   int local_ca_ack_delay ;
   int num_uars ;
   int max_sg ;
   int num_qps ;
   int max_wqes ;
   int max_desc_sz ;
   int max_qp_init_rdma ;
   int reserved_qps ;
   int num_srqs ;
   int max_srq_wqes ;
   int max_srq_sge ;
   int reserved_srqs ;
   int num_eecs ;
   int reserved_eecs ;
   int num_cqs ;
   int max_cqes ;
   int reserved_cqs ;
   int num_eqs ;
   int reserved_eqs ;
   int num_mpts ;
   int num_mtt_segs ;
   int mtt_seg_size ;
   int fmr_reserved_mtts ;
   int reserved_mtts ;
   int reserved_mrws ;
   int reserved_uars ;
   int num_mgms ;
   int num_amgms ;
   int reserved_mcgs ;
   int num_pds ;
   int reserved_pds ;
   u32 page_size_cap ;
   u32 flags ;
   u16 stat_rate_support ;
   u8 port_width_cap ;
};
#line 177 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_alloc {
   u32 last ;
   u32 top ;
   u32 max ;
   u32 mask ;
   spinlock_t lock ;
   unsigned long *table ;
};
#line 186 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_page_list_167 {
   void **page ;
   int used ;
};
#line 186 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_array {
   struct __anonstruct_page_list_167 *page_list ;
};
#line 193 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_uar_table {
   struct mthca_alloc alloc ;
   u64 uarc_base ;
   int uarc_size ;
};
#line 199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_pd_table {
   struct mthca_alloc alloc ;
};
#line 203 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_buddy {
   unsigned long **bits ;
   int *num_free ;
   int max_order ;
   spinlock_t lock ;
};
#line 210
struct mthca_icm_table;
#line 210 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_fmr_168 {
   void *mpt_base ;
   void *mtt_base ;
   struct mthca_buddy mtt_buddy ;
};
#line 210 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mr_table {
   struct mthca_alloc mpt_alloc ;
   struct mthca_buddy mtt_buddy ;
   struct mthca_buddy *fmr_mtt_buddy ;
   u64 mtt_base ;
   u64 mpt_base ;
   struct mthca_icm_table *mtt_table ;
   struct mthca_icm_table *mpt_table ;
   struct __anonstruct_tavor_fmr_168 tavor_fmr ;
};
#line 225 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_eq_table {
   struct mthca_alloc alloc ;
   void *clr_int ;
   u32 clr_mask ;
   u32 arm_mask ;
   struct mthca_eq eq[3U] ;
   u64 icm_virt ;
   struct page *icm_page ;
   dma_addr_t icm_dma ;
   int have_irq ;
   u8 inta_pin ;
};
#line 238 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_cq_table {
   struct mthca_alloc alloc ;
   spinlock_t lock ;
   struct mthca_array cq ;
   struct mthca_icm_table *table ;
};
#line 245 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_srq_table {
   struct mthca_alloc alloc ;
   spinlock_t lock ;
   struct mthca_array srq ;
   struct mthca_icm_table *table ;
};
#line 252 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_qp_table {
   struct mthca_alloc alloc ;
   u32 rdb_base ;
   int rdb_shift ;
   int sqp_start ;
   spinlock_t lock ;
   struct mthca_array qp ;
   struct mthca_icm_table *qp_table ;
   struct mthca_icm_table *eqp_table ;
   struct mthca_icm_table *rdb_table ;
};
#line 264 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_av_table {
   struct dma_pool *pool ;
   int num_ddr_avs ;
   u64 ddr_av_base ;
   void *av_map ;
   struct mthca_alloc alloc ;
};
#line 272 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mcg_table {
   struct mutex mutex ;
   struct mthca_alloc alloc ;
   struct mthca_icm_table *table ;
};
#line 278 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_catas_err {
   u64 addr ;
   u32 *map ;
   u32 size ;
   struct timer_list timer ;
   struct list_head list ;
};
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_170 {
   u64 fw_start ;
   u64 fw_end ;
};
#line 288
struct mthca_icm;
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_arbel_171 {
   u64 clr_int_base ;
   u64 eq_arm_base ;
   u64 eq_set_ci_base ;
   struct mthca_icm *fw_icm ;
   struct mthca_icm *aux_icm ;
   u16 fw_pages ;
};
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
union __anonunion_fw_169 {
   struct __anonstruct_tavor_170 tavor ;
   struct __anonstruct_arbel_171 arbel ;
};
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_tavor_173 {
   void *ecr_base ;
};
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct __anonstruct_arbel_174 {
   void *eq_arm ;
   void *eq_set_ci_base ;
};
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
union __anonunion_eq_regs_172 {
   struct __anonstruct_tavor_173 tavor ;
   struct __anonstruct_arbel_174 arbel ;
};
#line 288
struct mthca_db_table;
#line 288
struct ib_mad_agent;
#line 288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_dev {
   struct ib_device ib_dev ;
   struct pci_dev *pdev ;
   int hca_type ;
   unsigned long mthca_flags ;
   unsigned long device_cap_flags ;
   u32 rev_id ;
   char board_id[64U] ;
   u64 fw_ver ;
   union __anonunion_fw_169 fw ;
   u64 ddr_start ;
   u64 ddr_end ;
   struct mutex cap_mask_mutex ;
   void *hcr ;
   void *kar ;
   void *clr_base ;
   union __anonunion_eq_regs_172 eq_regs ;
   struct mthca_cmd cmd ;
   struct mthca_limits limits ;
   struct mthca_uar_table uar_table ;
   struct mthca_pd_table pd_table ;
   struct mthca_mr_table mr_table ;
   struct mthca_eq_table eq_table ;
   struct mthca_cq_table cq_table ;
   struct mthca_srq_table srq_table ;
   struct mthca_qp_table qp_table ;
   struct mthca_av_table av_table ;
   struct mthca_mcg_table mcg_table ;
   struct mthca_catas_err catas_err ;
   struct mthca_uar driver_uar ;
   struct mthca_db_table *db_tab ;
   struct mthca_pd driver_pd ;
   struct mthca_mr driver_mr ;
   struct ib_mad_agent *send_agent[2U][2U] ;
   struct ib_ah *sm_ah[2U] ;
   spinlock_t sm_lock ;
   u8 rate[2U] ;
   bool active ;
};
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_tavor_176 {
   int max_avs ;
};
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_arbel_177 {
   int resize_srq ;
   int max_pbl_sz ;
   u8 bmme_flags ;
   u32 reserved_lkey ;
   int lam_required ;
   u64 max_icm_sz ;
};
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
union __anonunion_hca_175 {
   struct __anonstruct_tavor_176 tavor ;
   struct __anonstruct_arbel_177 arbel ;
};
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_dev_lim {
   int max_srq_sz ;
   int max_qp_sz ;
   int reserved_qps ;
   int max_qps ;
   int reserved_srqs ;
   int max_srqs ;
   int reserved_eecs ;
   int max_eecs ;
   int max_cq_sz ;
   int reserved_cqs ;
   int max_cqs ;
   int max_mpts ;
   int reserved_eqs ;
   int max_eqs ;
   int reserved_mtts ;
   int max_mrw_sz ;
   int reserved_mrws ;
   int max_mtt_seg ;
   int max_requester_per_qp ;
   int max_responder_per_qp ;
   int max_rdma_global ;
   int local_ca_ack_delay ;
   int max_mtu ;
   int max_port_width ;
   int max_vl ;
   int num_ports ;
   int max_gids ;
   u16 stat_rate_support ;
   int max_pkeys ;
   u32 flags ;
   int reserved_uars ;
   int uar_size ;
   int min_page_sz ;
   int max_sg ;
   int max_desc_sz ;
   int max_qp_per_mcg ;
   int reserved_mgms ;
   int max_mcgs ;
   int reserved_pds ;
   int max_pds ;
   int reserved_rdds ;
   int max_rdds ;
   int eec_entry_sz ;
   int qpc_entry_sz ;
   int eeec_entry_sz ;
   int eqpc_entry_sz ;
   int eqc_entry_sz ;
   int cqc_entry_sz ;
   int srq_entry_sz ;
   int uar_scratch_entry_sz ;
   int mpt_entry_sz ;
   union __anonunion_hca_175 hca ;
};
#line 186 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_adapter {
   u32 vendor_id ;
   u32 device_id ;
   u32 revision_id ;
   char board_id[64U] ;
   u8 inta_pin ;
};
#line 194 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_init_hca_param {
   u64 qpc_base ;
   u64 eec_base ;
   u64 srqc_base ;
   u64 cqc_base ;
   u64 eqpc_base ;
   u64 eeec_base ;
   u64 eqc_base ;
   u64 rdb_base ;
   u64 mc_base ;
   u64 mpt_base ;
   u64 mtt_base ;
   u64 uar_scratch_base ;
   u64 uarc_base ;
   u16 log_mc_entry_sz ;
   u16 mc_hash_sz ;
   u8 log_num_qps ;
   u8 log_num_eecs ;
   u8 log_num_srqs ;
   u8 log_num_cqs ;
   u8 log_num_eqs ;
   u8 log_mc_table_sz ;
   u8 mtt_seg_sz ;
   u8 log_mpt_sz ;
   u8 log_uar_sz ;
   u8 log_uarc_sz ;
};
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_profile {
   int num_qp ;
   int rdb_per_qp ;
   int num_srq ;
   int num_cq ;
   int num_mcg ;
   int num_mpt ;
   int num_mtt ;
   int num_udav ;
   int num_uar ;
   int uarc_size ;
   int fmr_reserved_mtts ;
};
#line 57 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm {
   struct list_head chunk_list ;
   int refcount ;
};
#line 62 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm_table {
   u64 virt ;
   int num_icm ;
   int num_obj ;
   int obj_size ;
   int lowmem ;
   int coherent ;
   struct mutex mutex ;
   struct mthca_icm *icm[0U] ;
};
#line 137 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_db_page {
   unsigned long used[8U] ;
   __be64 *db_rec ;
   dma_addr_t mapping ;
};
#line 143 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_db_table {
   int npages ;
   int max_group1 ;
   int min_group2 ;
   struct mthca_db_page *page ;
   struct mutex mutex ;
};
#line 1011 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
struct __anonstruct_mthca_hca_table_179 {
   u64 latest_fw ;
   u32 flags ;
};
#line 1578 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
typedef int ldv_func_ret_type___2;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 88 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 24 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 58 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct thread_struct;
#line 127 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 298 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 444
struct perf_event;
#line 445 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 137 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
struct timespec;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 42 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 44 "include/linux/shrinker.h"
struct user_struct;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 34
struct user_namespace;
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_144 {
   unsigned long sig[1U] ;
};
#line 24 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_144 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_146 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_147 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_148 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_149 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_150 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_151 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_152 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_145 {
   int _pad[28U] ;
   struct __anonstruct__kill_146 _kill ;
   struct __anonstruct__timer_147 _timer ;
   struct __anonstruct__rt_148 _rt ;
   struct __anonstruct__sigchld_149 _sigchld ;
   struct __anonstruct__sigfault_150 _sigfault ;
   struct __anonstruct__sigpoll_151 _sigpoll ;
   struct __anonstruct__sigsys_152 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_145 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 397
struct pid_namespace;
#line 397 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 440 "include/linux/rculist.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 460 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct cred;
#line 37
struct key_type;
#line 39
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_21370_157 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_21379_158 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_159 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_160 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_21370_157 ldv_21370 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_21379_158 ldv_21379 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_159 type_data ;
   union __anonunion_payload_160 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct backing_dev_info;
#line 735
struct reclaim_state;
#line 736 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1022
struct io_context;
#line 1050
struct pipe_inode_info;
#line 1052
struct rq;
#line 1053 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct files_struct;
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 2189 "include/rdma/ib_verbs.h"
struct ib_mad_hdr {
   u8 base_version ;
   u8 mgmt_class ;
   u8 class_version ;
   u8 method ;
   __be16 status ;
   __be16 class_specific ;
   __be64 tid ;
   __be16 attr_id ;
   __be16 resv ;
   __be32 attr_mod ;
};
#line 177 "include/rdma/ib_mad.h"
struct ib_mad {
   struct ib_mad_hdr mad_hdr ;
   u8 data[232U] ;
};
#line 223 "include/rdma/ib_mad.h"
struct ib_mad_send_buf {
   struct ib_mad_send_buf *next ;
   void *mad ;
   struct ib_mad_agent *mad_agent ;
   struct ib_ah *ah ;
   void *context[2U] ;
   int hdr_len ;
   int data_len ;
   int seg_count ;
   int seg_size ;
   int timeout_ms ;
   int retries ;
};
#line 304
struct ib_mad_send_wc;
#line 305
struct ib_mad_recv_wc;
#line 344 "include/rdma/ib_mad.h"
struct ib_mad_agent {
   struct ib_device *device ;
   struct ib_qp *qp ;
   struct ib_mr *mr ;
   void (*recv_handler)(struct ib_mad_agent * , struct ib_mad_recv_wc * ) ;
   void (*send_handler)(struct ib_mad_agent * , struct ib_mad_send_wc * ) ;
   void (*snoop_handler)(struct ib_mad_agent * , struct ib_mad_send_buf * , struct ib_mad_send_wc * ) ;
   void *context ;
   u32 hi_tid ;
   u8 port_num ;
   u8 rmpp_version ;
};
#line 373 "include/rdma/ib_mad.h"
struct ib_mad_send_wc {
   struct ib_mad_send_buf *send_buf ;
   enum ib_wc_status status ;
   u32 vendor_err ;
};
#line 386 "include/rdma/ib_mad.h"
struct ib_mad_recv_buf {
   struct list_head list ;
   struct ib_grh *grh ;
   struct ib_mad *mad ;
};
#line 400 "include/rdma/ib_mad.h"
struct ib_mad_recv_wc {
   struct ib_wc *wc ;
   struct ib_mad_recv_buf recv_buf ;
   struct list_head rmpp_list ;
   int mad_len ;
};
#line 650 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_mailbox {
   dma_addr_t dma ;
   void *buf ;
};
#line 222 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_init_ib_param {
   int port_width ;
   int vl_cap ;
   int mtu_cap ;
   u16 gid_cap ;
   u16 pkey_cap ;
   int set_guid0 ;
   u64 guid0 ;
   int set_node_guid ;
   u64 node_guid ;
   int set_si_guid ;
   u64 si_guid ;
};
#line 236 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_set_ib_param {
   int set_si_guid ;
   int reset_qkey_viol ;
   u64 si_guid ;
   u32 cap_mask ;
};
#line 330 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_icm_chunk {
   struct list_head list ;
   int npages ;
   int nsg ;
   struct scatterlist mem[5U] ;
};
#line 73 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm_iter {
   struct mthca_icm *icm ;
   struct mthca_icm_chunk *chunk ;
   int page_idx ;
};
#line 268 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_cmd_context {
   struct completion done ;
   int result ;
   int next ;
   u64 out_param ;
   u16 token ;
   u8 status ;
};
#line 186 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
struct mthca_resource {
   u64 size ;
   u64 start ;
   int type ;
   int num ;
   int log_num ;
};
#line 325 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 358 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 195 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 51 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
union mthca_buf {
   struct mthca_buf_list direct ;
   struct mthca_buf_list *page_list ;
};
#line 285 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
struct __anonstruct_168 {
   void **page ;
   int used ;
};
#line 152 "include/linux/preempt.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 331 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_eq_context {
   __be32 flags ;
   __be64 start ;
   __be32 logsize_usrpage ;
   __be32 tavor_pd ;
   u8 reserved1[3U] ;
   u8 intr ;
   __be32 arbel_pd ;
   __be32 lkey ;
   u32 reserved2[2U] ;
   __be32 consumer_index ;
   __be32 producer_index ;
   u32 reserved3[4U] ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_comp_172 {
   __be32 cqn ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_cmd_173 {
   u16 reserved1 ;
   __be16 token ;
   u32 reserved2 ;
   u8 reserved3[3U] ;
   u8 status ;
   __be64 out_param ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_qp_174 {
   __be32 qpn ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_srq_175 {
   __be32 srqn ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_cq_err_176 {
   __be32 cqn ;
   u32 reserved1 ;
   u8 reserved2[3U] ;
   u8 syndrome ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct __anonstruct_port_change_177 {
   u32 reserved1[2U] ;
   __be32 port ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
union __anonunion_event_171 {
   u32 raw[6U] ;
   struct __anonstruct_comp_172 comp ;
   struct __anonstruct_cmd_173 cmd ;
   struct __anonstruct_qp_174 qp ;
   struct __anonstruct_srq_175 srq ;
   struct __anonstruct_cq_err_176 cq_err ;
   struct __anonstruct_port_change_177 port_change ;
};
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
struct mthca_eqe {
   u8 reserved1 ;
   u8 type ;
   u8 reserved2 ;
   u8 subtype ;
   union __anonunion_event_171 event ;
   u8 reserved3[3U] ;
   u8 owner ;
};
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 61 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_user_db_table;
#line 62 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_ucontext {
   struct ib_ucontext ibucontext ;
   struct mthca_uar uar ;
   struct mthca_user_db_table *db_tab ;
   int reg_mr_warned ;
};
#line 134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq_buf {
   union mthca_buf queue ;
   struct mthca_mr mr ;
   int is_direct ;
};
#line 190
enum ldv_20949 {
    CQ_RESIZE_ALLOC = 0,
    CQ_RESIZE_READY = 1,
    CQ_RESIZE_SWAPPED = 2
} ;
#line 196 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq_resize {
   struct mthca_cq_buf buf ;
   int cqe ;
   enum ldv_20949 state ;
};
#line 200 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_cq {
   struct ib_cq ibcq ;
   spinlock_t lock ;
   int refcount ;
   int cqn ;
   u32 cons_index ;
   struct mthca_cq_buf buf ;
   struct mthca_cq_resize *resize_buf ;
   int is_kernel ;
   int set_ci_db_index ;
   __be32 *set_ci_db ;
   int arm_db_index ;
   __be32 *arm_db ;
   int arm_sn ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 221 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_srq {
   struct ib_srq ibsrq ;
   spinlock_t lock ;
   int refcount ;
   int srqn ;
   int max ;
   int max_gs ;
   int wqe_shift ;
   int first_free ;
   int last_free ;
   u16 counter ;
   int db_index ;
   __be32 *db ;
   void *last ;
   int is_direct ;
   u64 *wrid ;
   union mthca_buf queue ;
   struct mthca_mr mr ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 245 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_wq {
   spinlock_t lock ;
   int max ;
   unsigned int next_ind ;
   unsigned int last_comp ;
   unsigned int head ;
   unsigned int tail ;
   void *last ;
   int max_gs ;
   int wqe_shift ;
   int db_index ;
   __be32 *db ;
};
#line 260 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_qp {
   struct ib_qp ibqp ;
   int refcount ;
   u32 qpn ;
   int is_direct ;
   u8 port ;
   u8 alt_port ;
   u8 transport ;
   u8 state ;
   u8 atomic_rd_en ;
   u8 resp_depth ;
   struct mthca_mr mr ;
   struct mthca_wq rq ;
   struct mthca_wq sq ;
   enum ib_sig_type sq_policy ;
   int send_wqe_offset ;
   int max_inline_data ;
   u64 *wrid ;
   union mthca_buf queue ;
   wait_queue_head_t wait ;
   struct mutex mutex ;
};
#line 151 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
enum mthca_db_type {
    MTHCA_DB_TYPE_INVALID = 0,
    MTHCA_DB_TYPE_CQ_SET_CI = 1,
    MTHCA_DB_TYPE_CQ_ARM = 2,
    MTHCA_DB_TYPE_SQ = 3,
    MTHCA_DB_TYPE_RQ = 4,
    MTHCA_DB_TYPE_SRQ = 5,
    MTHCA_DB_TYPE_GROUP_SEP = 7
} ;
#line 190 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_cq_context {
   __be32 flags ;
   __be64 start ;
   __be32 logsize_usrpage ;
   __be32 error_eqn ;
   __be32 comp_eqn ;
   __be32 pd ;
   __be32 lkey ;
   __be32 last_notified_index ;
   __be32 solicit_producer_index ;
   __be32 consumer_index ;
   __be32 producer_index ;
   __be32 cqn ;
   __be32 ci_db ;
   __be32 state_db ;
   u32 reserved ;
};
#line 226 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
struct mthca_cqe {
   __be32 my_qpn ;
   __be32 my_ee ;
   __be32 rqpn ;
   u8 sl_ipok ;
   u8 g_mlpath ;
   __be16 rlid ;
   __be32 imm_etype_pkey_eec ;
   __be32 byte_cnt ;
   __be32 wqe ;
   u8 opcode ;
   u8 is_send ;
   u8 reserved ;
   u8 owner ;
};
#line 252 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
struct mthca_err_cqe {
   __be32 my_qpn ;
   u32 reserved1[3U] ;
   u8 syndrome ;
   u8 vendor_err ;
   __be16 db_cnt ;
   u32 reserved2 ;
   __be32 wqe ;
   u8 opcode ;
   u8 reserved3[2U] ;
   u8 owner ;
};
#line 1158 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
typedef int ldv_func_ret_type___4;
#line 78 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_mpt_entry;
#line 78 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct __anonstruct_tavor_157 {
   struct mthca_mpt_entry *mpt ;
   u64 *mtts ;
};
#line 78 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct __anonstruct_arbel_158 {
   struct mthca_mpt_entry *mpt ;
   __be64 *mtts ;
   dma_addr_t dma_handle ;
};
#line 78 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
union __anonunion_mem_156 {
   struct __anonstruct_tavor_157 tavor ;
   struct __anonstruct_arbel_158 arbel ;
};
#line 78 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_fmr {
   struct ib_fmr ibmr ;
   struct ib_fmr_attr attr ;
   struct mthca_mtt *mtt ;
   int maps ;
   union __anonunion_mem_156 mem ;
};
#line 178 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_mtt {
   struct mthca_buddy *buddy ;
   int order ;
   u32 first_seg ;
};
#line 166 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
struct mthca_mpt_entry {
   __be32 flags ;
   __be32 page_size ;
   __be32 key ;
   __be32 pd ;
   __be64 start ;
   __be64 length ;
   __be32 lkey ;
   __be32 window_count ;
   __be32 window_count_limit ;
   __be64 mtt_seg ;
   __be32 mtt_sz ;
   u32 reserved[2U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 416 "include/rdma/ib_verbs.h"
enum ib_rate {
    IB_RATE_PORT_CURRENT = 0,
    IB_RATE_2_5_GBPS = 2,
    IB_RATE_5_GBPS = 5,
    IB_RATE_10_GBPS = 3,
    IB_RATE_20_GBPS = 6,
    IB_RATE_30_GBPS = 4,
    IB_RATE_40_GBPS = 7,
    IB_RATE_60_GBPS = 8,
    IB_RATE_80_GBPS = 9,
    IB_RATE_120_GBPS = 10,
    IB_RATE_14_GBPS = 11,
    IB_RATE_56_GBPS = 12,
    IB_RATE_112_GBPS = 13,
    IB_RATE_168_GBPS = 14,
    IB_RATE_25_GBPS = 15,
    IB_RATE_100_GBPS = 16,
    IB_RATE_200_GBPS = 17,
    IB_RATE_300_GBPS = 18
} ;
#line 677
enum ib_qp_attr_mask {
    IB_QP_STATE = 1,
    IB_QP_CUR_STATE = 2,
    IB_QP_EN_SQD_ASYNC_NOTIFY = 4,
    IB_QP_ACCESS_FLAGS = 8,
    IB_QP_PKEY_INDEX = 16,
    IB_QP_PORT = 32,
    IB_QP_QKEY = 64,
    IB_QP_AV = 128,
    IB_QP_PATH_MTU = 256,
    IB_QP_TIMEOUT = 512,
    IB_QP_RETRY_CNT = 1024,
    IB_QP_RNR_RETRY = 2048,
    IB_QP_RQ_PSN = 4096,
    IB_QP_MAX_QP_RD_ATOMIC = 8192,
    IB_QP_ALT_PATH = 16384,
    IB_QP_MIN_RNR_TIMER = 32768,
    IB_QP_SQ_PSN = 65536,
    IB_QP_MAX_DEST_RD_ATOMIC = 131072,
    IB_QP_PATH_MIG_STATE = 262144,
    IB_QP_CAP = 524288,
    IB_QP_DEST_QPN = 1048576
} ;
#line 146 "include/rdma/ib_pack.h"
struct ib_unpacked_lrh {
   u8 virtual_lane ;
   u8 link_version ;
   u8 service_level ;
   u8 link_next_header ;
   __be16 destination_lid ;
   __be16 packet_length ;
   __be16 source_lid ;
};
#line 186 "include/rdma/ib_pack.h"
struct ib_unpacked_grh {
   u8 ip_version ;
   u8 traffic_class ;
   __be32 flow_label ;
   __be16 payload_length ;
   u8 next_header ;
   u8 hop_limit ;
   union ib_gid source_gid ;
   union ib_gid destination_gid ;
};
#line 197 "include/rdma/ib_pack.h"
struct ib_unpacked_bth {
   u8 opcode ;
   u8 solicited_event ;
   u8 mig_req ;
   u8 pad_count ;
   u8 transport_header_version ;
   __be16 pkey ;
   __be32 destination_qpn ;
   u8 ack_req ;
   __be32 psn ;
};
#line 209 "include/rdma/ib_pack.h"
struct ib_unpacked_deth {
   __be32 qkey ;
   __be32 source_qpn ;
};
#line 214 "include/rdma/ib_pack.h"
struct ib_unpacked_eth {
   u8 dmac_h[4U] ;
   u8 dmac_l[2U] ;
   u8 smac_h[2U] ;
   u8 smac_l[4U] ;
   __be16 type ;
};
#line 222 "include/rdma/ib_pack.h"
struct ib_unpacked_vlan {
   __be16 tag ;
   __be16 type ;
};
#line 227 "include/rdma/ib_pack.h"
struct ib_ud_header {
   int lrh_present ;
   struct ib_unpacked_lrh lrh ;
   int eth_present ;
   struct ib_unpacked_eth eth ;
   int vlan_present ;
   struct ib_unpacked_vlan vlan ;
   int grh_present ;
   struct ib_unpacked_grh grh ;
   struct ib_unpacked_bth bth ;
   struct ib_unpacked_deth deth ;
   int immediate_present ;
   __be32 immediate_data ;
};
#line 118 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_av;
#line 119
enum mthca_ah_type {
    MTHCA_AH_ON_HCA = 0,
    MTHCA_AH_PCI_POOL = 1,
    MTHCA_AH_KMALLOC = 2
} ;
#line 125 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_ah {
   struct ib_ah ibah ;
   enum mthca_ah_type type ;
   u32 key ;
   struct mthca_av *av ;
   dma_addr_t avdma ;
};
#line 287 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
struct mthca_sqp {
   struct mthca_qp qp ;
   int pkey_index ;
   u32 qkey ;
   u32 send_psn ;
   struct ib_ud_header ud_header ;
   int header_buf_size ;
   void *header_buf ;
   dma_addr_t header_dma ;
};
#line 196 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_next_seg {
   __be32 nda_op ;
   __be32 ee_nds ;
   __be32 flags ;
   __be32 imm ;
};
#line 63 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_tavor_ud_seg {
   u32 reserved1 ;
   __be32 lkey ;
   __be64 av_addr ;
   u32 reserved2[4U] ;
   __be32 dqpn ;
   __be32 qkey ;
   u32 reserved3[2U] ;
};
#line 73 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_arbel_ud_seg {
   __be32 av[8U] ;
   __be32 dqpn ;
   __be32 qkey ;
   u32 reserved[2U] ;
};
#line 89 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_raddr_seg {
   __be64 raddr ;
   __be32 rkey ;
   u32 reserved ;
};
#line 95 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_atomic_seg {
   __be64 swap_add ;
   __be64 compare ;
};
#line 100 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_data_seg {
   __be32 byte_count ;
   __be32 lkey ;
   __be64 addr ;
};
#line 106 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_mlx_seg {
   __be32 nda_op ;
   __be32 nds ;
   __be32 flags ;
   __be16 rlid ;
   __be16 vcrc ;
};
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_qp_path {
   __be32 port_pkey ;
   u8 rnr_retry ;
   u8 g_mylmc ;
   __be16 rlid ;
   u8 ackto ;
   u8 mgid_index ;
   u8 static_rate ;
   u8 hop_limit ;
   __be32 sl_tclass_flowlabel ;
   u8 rgid[16U] ;
};
#line 238 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
struct mthca_qp_context {
   __be32 flags ;
   __be32 tavor_sched_queue ;
   u8 mtu_msgmax ;
   u8 rq_size_stride ;
   u8 sq_size_stride ;
   u8 rlkey_arbel_sched_queue ;
   __be32 usr_page ;
   __be32 local_qpn ;
   __be32 remote_qpn ;
   u32 reserved1[2U] ;
   struct mthca_qp_path pri_path ;
   struct mthca_qp_path alt_path ;
   __be32 rdd ;
   __be32 pd ;
   __be32 wqe_base ;
   __be32 wqe_lkey ;
   __be32 params1 ;
   __be32 reserved2 ;
   __be32 next_send_psn ;
   __be32 cqn_snd ;
   __be32 snd_wqe_base_l ;
   __be32 snd_db_index ;
   __be32 last_acked_psn ;
   __be32 ssn ;
   __be32 params2 ;
   __be32 rnr_nextrecvpsn ;
   __be32 ra_buff_indx ;
   __be32 cqn_rcv ;
   __be32 rcv_wqe_base_l ;
   __be32 rcv_db_index ;
   __be32 qkey ;
   __be32 srqn ;
   __be32 rmsn ;
   __be16 rq_wqe_counter ;
   __be16 sq_wqe_counter ;
   u32 reserved3[18U] ;
};
#line 277 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
struct mthca_qp_param {
   __be32 opt_param_mask ;
   u32 reserved1 ;
   struct mthca_qp_context context ;
   u32 reserved2[62U] ;
};
#line 609 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mthca_av {
   __be32 port_pd ;
   u8 reserved1 ;
   u8 g_slid ;
   __be16 dlid ;
   u8 reserved2 ;
   u8 gid_index ;
   u8 msg_sr ;
   u8 hop_limit ;
   __be32 sl_tclass_flowlabel ;
   __be32 dgid[4U] ;
};
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_mgm {
   __be32 next_gid_index ;
   u32 reserved[3U] ;
   u8 gid[16U] ;
   __be32 qp[56U] ;
};
#line 223 "include/rdma/ib_verbs.h"
enum ib_port_width {
    IB_WIDTH_1X = 1,
    IB_WIDTH_4X = 2,
    IB_WIDTH_8X = 4,
    IB_WIDTH_12X = 8
} ;
#line 417 "include/rdma/ib_mad.h"
struct ib_mad_reg_req {
   u8 mgmt_class ;
   u8 mgmt_class_version ;
   u8 oui[3U] ;
   unsigned long method_mask[2U] ;
};
#line 663 "include/rdma/ib_mad.h"
struct ib_smp {
   u8 base_version ;
   u8 mgmt_class ;
   u8 class_version ;
   u8 method ;
   __be16 status ;
   u8 hop_ptr ;
   u8 hop_cnt ;
   __be64 tid ;
   __be16 attr_id ;
   __be16 resv ;
   __be32 attr_mod ;
   __be64 mkey ;
   __be16 dr_slid ;
   __be16 dr_dlid ;
   u8 reserved[28U] ;
   u8 data[64U] ;
   u8 initial_path[64U] ;
   u8 return_path[64U] ;
};
#line 65 "include/rdma/ib_smi.h"
struct ib_port_info {
   __be64 mkey ;
   __be64 gid_prefix ;
   __be16 lid ;
   __be16 sm_lid ;
   __be32 cap_mask ;
   __be16 diag_code ;
   __be16 mkey_lease_period ;
   u8 local_port_num ;
   u8 link_width_enabled ;
   u8 link_width_supported ;
   u8 link_width_active ;
   u8 linkspeed_portstate ;
   u8 portphysstate_linkdown ;
   u8 mkeyprot_resv_lmc ;
   u8 linkspeedactive_enabled ;
   u8 neighbormtu_mastersmsl ;
   u8 vlcap_inittype ;
   u8 vl_high_limit ;
   u8 vl_arb_high_cap ;
   u8 vl_arb_low_cap ;
   u8 inittypereply_mtucap ;
   u8 vlstallcnt_hoqlife ;
   u8 operationalvl_pei_peo_fpi_fpo ;
   __be16 mkey_violations ;
   __be16 pkey_violations ;
   __be16 qkey_violations ;
   u8 guid_cap ;
   u8 clientrereg_resv_subnetto ;
   u8 resv_resptimevalue ;
   u8 localphyerrors_overrunerrors ;
   __be16 max_credit_hint ;
   u8 resv ;
   u8 link_roundtrip_latency[3U] ;
};
#line 699 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
struct cpuinfo_x86;
#line 76 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[10U] ;
   char x86_vendor_id[16U] ;
   char x86_model_id[64U] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 127 "include/rdma/ib_smi.h"
struct ib_umem {
   struct ib_ucontext *context ;
   size_t length ;
   int offset ;
   int page_size ;
   int writable ;
   int hugetlb ;
   struct list_head chunk_list ;
   struct work_struct work ;
   struct mm_struct *mm ;
   unsigned long diff ;
};
#line 54 "include/rdma/ib_umem.h"
struct ib_umem_chunk {
   struct list_head list ;
   int nents ;
   int nmap ;
   struct scatterlist page_list[0U] ;
};
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_alloc_ucontext_resp {
   __u32 qp_tab_size ;
   __u32 uarc_size ;
};
#line 62 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_reg_mr {
   __u32 mr_attrs ;
   __u32 reserved ;
};
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_cq {
   __u32 lkey ;
   __u32 pdn ;
   __u64 arm_db_page ;
   __u64 set_db_page ;
   __u32 arm_db_index ;
   __u32 set_db_index ;
};
#line 86 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_resize_cq {
   __u32 lkey ;
   __u32 reserved ;
};
#line 91 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_srq {
   __u32 lkey ;
   __u32 db_index ;
   __u64 db_page ;
};
#line 102 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_user.h"
struct mthca_create_qp {
   __u32 lkey ;
   __u32 reserved ;
   __u64 sq_db_page ;
   __u64 rq_db_page ;
   __u32 sq_db_index ;
   __u32 rq_db_index ;
};
#line 1662 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
typedef int ldv_func_ret_type___6;
#line 1684 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
typedef int ldv_func_ret_type___8;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 329 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct __anonstruct_page_190 {
   u64 uvirt ;
   struct scatterlist mem ;
   int refcount ;
};
#line 329 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
struct mthca_user_db_table {
   struct mutex mutex ;
   struct __anonstruct_page_190 page[0U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
struct mthca_tavor_srq_context {
   __be64 wqe_base_ds ;
   __be32 state_pd ;
   __be32 lkey ;
   __be32 uar ;
   __be16 limit_watermark ;
   __be16 wqe_cnt ;
   u32 reserved[2U] ;
};
#line 177 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
struct mthca_arbel_srq_context {
   __be32 state_logsize_srqn ;
   __be32 lkey ;
   __be32 db_index ;
   __be32 logstride_usrpage ;
   __be64 wqe_base ;
   __be32 eq_pd ;
   __be16 limit_watermark ;
   __be16 wqe_cnt ;
   u16 reserved1 ;
   __be16 wqe_counter ;
   u32 reserved2[3U] ;
};
#line 266 "include/linux/timer.h"
struct workqueue_struct;
#line 1 "<compiler builtins>"
#line 489 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ int bitpos ;

  {
#line 491
  bitpos = -1;
#line 497
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 500
  return (bitpos + 1);
}
}
#line 160 "include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ int tmp___0 ;

  {
#line 164
  tmp___0 = fls64((__u64 )l);
#line 164
  return ((unsigned int )tmp___0);
}
}
#line 61 "include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
#line 63
  tmp = fls_long(n - 1UL);
#line 63
  return (1UL << (int )tmp);
}
}
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 168 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 173
extern void mutex_unlock(struct mutex * ) ;
#line 176
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_8(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 7 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) ;
#line 51
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 55
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 59
void ldv_mutex_lock_mthca_device_mutex(struct mutex *lock ) ;
#line 63
void ldv_mutex_unlock_mthca_device_mutex(struct mutex *lock ) ;
#line 67
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 68
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 71
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 129 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_3  ;
#line 130 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_2  ;
#line 131 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ref_cnt  ;
#line 132
extern int __VERIFIER_nondet_int(void) ;
#line 133 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_1  ;
#line 134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_4  ;
#line 135 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_0  ;
#line 136 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_state_variable_5  ;
#line 174 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
#line 184
  tmp = ioremap_nocache(offset, size);
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 80 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
#line 82
  return ((char const   *)kobj->name);
}
}
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 731 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
#line 734
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 735
    return ((char const   *)dev->init_name);
  } else {

  }
#line 737
  tmp = kobject_name(& dev->kobj);
#line 737
  return (tmp);
}
}
#line 845
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 846
extern int dev_set_drvdata(struct device * , void * ) ;
#line 937
extern int dev_printk(char const   * , struct device  const  * , char const   *  , ...) ;
#line 946
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 948
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 952
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 752 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 858
extern int pci_enable_device(struct pci_dev * ) ;
#line 875
extern void pci_disable_device(struct pci_dev * ) ;
#line 878
extern void pci_set_master(struct pci_dev * ) ;
#line 894
extern int pcix_get_max_mmrbc(struct pci_dev * ) ;
#line 896
extern int pcix_set_mmrbc(struct pci_dev * , int  ) ;
#line 898
extern int pcie_set_readrq(struct pci_dev * , int  ) ;
#line 987
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 989
extern void pci_release_regions(struct pci_dev * ) ;
#line 1023
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1032
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1138
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1141
extern void pci_disable_msix(struct pci_dev * ) ;
#line 60 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 91 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ int tmp ;

  {
#line 93
  tmp = dma_supported(dev, mask);
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 107 "include/linux/dma-mapping.h"
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 

  {
#line 110
  if ((unsigned long )dev->dma_parms != (unsigned long )((struct device_dma_parameters *)0)) {
#line 111
    (dev->dma_parms)->max_segment_size = size;
#line 112
    return (0U);
  } else {
#line 114
    return (4294967291U);
  }
}
}
#line 142 "include/linux/dma-mapping.h"
__inline static int dma_get_cache_alignment(void) 
{ 

  {
#line 147
  return (1);
}
}
#line 105 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;

  {
#line 107
  tmp = dma_set_mask(& dev->dev, mask);
#line 107
  return (tmp);
}
}
#line 110 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;

  {
#line 112
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 112
  return (tmp);
}
}
#line 1445 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
#line 1447
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1447
  return (tmp);
}
}
#line 1450 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
#line 1452
  dev_set_drvdata(& pdev->dev, data);
#line 1453
  return;
}
}
#line 1458 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ char const   *tmp ;

  {
#line 1460
  tmp = dev_name(& pdev->dev);
#line 1460
  return (tmp);
}
}
#line 1679 "include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 

  {
#line 1681
  return ((int )dev->pcie_cap);
}
}
#line 1690 "include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ int tmp ;

  {
#line 1692
  tmp = pci_pcie_cap(dev);
#line 1692
  return (tmp != 0);
}
}
#line 1267 "include/rdma/ib_verbs.h"
extern struct ib_device *ib_alloc_device(size_t  ) ;
#line 1268
extern void ib_dealloc_device(struct ib_device * ) ;
#line 287 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
struct mutex mthca_device_mutex ;
#line 364
int mthca_debug_level ;
#line 412
int mthca_reset(struct mthca_dev *mdev ) ;
#line 430
int mthca_init_uar_table(struct mthca_dev *dev ) ;
#line 431
int mthca_init_pd_table(struct mthca_dev *dev ) ;
#line 432
int mthca_init_mr_table(struct mthca_dev *dev ) ;
#line 433
int mthca_init_eq_table(struct mthca_dev *dev ) ;
#line 434
int mthca_init_cq_table(struct mthca_dev *dev ) ;
#line 435
int mthca_init_srq_table(struct mthca_dev *dev ) ;
#line 436
int mthca_init_qp_table(struct mthca_dev *dev ) ;
#line 437
int mthca_init_av_table(struct mthca_dev *dev ) ;
#line 438
int mthca_init_mcg_table(struct mthca_dev *dev ) ;
#line 440
void mthca_cleanup_uar_table(struct mthca_dev *dev ) ;
#line 441
void mthca_cleanup_pd_table(struct mthca_dev *dev ) ;
#line 442
void mthca_cleanup_mr_table(struct mthca_dev *dev ) ;
#line 443
void mthca_cleanup_eq_table(struct mthca_dev *dev ) ;
#line 444
void mthca_cleanup_cq_table(struct mthca_dev *dev ) ;
#line 445
void mthca_cleanup_srq_table(struct mthca_dev *dev ) ;
#line 446
void mthca_cleanup_qp_table(struct mthca_dev *dev ) ;
#line 447
void mthca_cleanup_av_table(struct mthca_dev *dev ) ;
#line 448
void mthca_cleanup_mcg_table(struct mthca_dev *dev ) ;
#line 450
int mthca_register_device(struct mthca_dev *dev ) ;
#line 451
void mthca_unregister_device(struct mthca_dev *dev ) ;
#line 455
int __mthca_restart_one(struct pci_dev *pdev ) ;
#line 456
int mthca_catas_init(void) ;
#line 457
void mthca_catas_cleanup(void) ;
#line 459
int mthca_uar_alloc(struct mthca_dev *dev , struct mthca_uar *uar ) ;
#line 460
void mthca_uar_free(struct mthca_dev *dev , struct mthca_uar *uar ) ;
#line 462
int mthca_pd_alloc(struct mthca_dev *dev , int privileged , struct mthca_pd *pd ) ;
#line 463
void mthca_pd_free(struct mthca_dev *dev , struct mthca_pd *pd ) ;
#line 491
int mthca_map_eq_icm(struct mthca_dev *dev , u64 icm_virt ) ;
#line 492
void mthca_unmap_eq_icm(struct mthca_dev *dev ) ;
#line 518
int mthca_max_srq_sge(struct mthca_dev *dev ) ;
#line 583
int mthca_create_agents(struct mthca_dev *dev ) ;
#line 584
void mthca_free_agents(struct mthca_dev *dev ) ;
#line 591 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
__inline static int mthca_is_memfree(struct mthca_dev *dev ) 
{ 

  {
#line 593
  return ((int )dev->mthca_flags & 64);
}
}
#line 244 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
int mthca_cmd_init(struct mthca_dev *dev ) ;
#line 245
void mthca_cmd_cleanup(struct mthca_dev *dev ) ;
#line 246
int mthca_cmd_use_events(struct mthca_dev *dev ) ;
#line 247
void mthca_cmd_use_polling(struct mthca_dev *dev ) ;
#line 255
int mthca_SYS_EN(struct mthca_dev *dev ) ;
#line 256
int mthca_SYS_DIS(struct mthca_dev *dev ) ;
#line 257
int mthca_MAP_FA(struct mthca_dev *dev , struct mthca_icm *icm ) ;
#line 258
int mthca_UNMAP_FA(struct mthca_dev *dev ) ;
#line 259
int mthca_RUN_FW(struct mthca_dev *dev ) ;
#line 260
int mthca_QUERY_FW(struct mthca_dev *dev ) ;
#line 261
int mthca_ENABLE_LAM(struct mthca_dev *dev ) ;
#line 262
int mthca_DISABLE_LAM(struct mthca_dev *dev ) ;
#line 263
int mthca_QUERY_DDR(struct mthca_dev *dev ) ;
#line 264
int mthca_QUERY_DEV_LIM(struct mthca_dev *dev , struct mthca_dev_lim *dev_lim ) ;
#line 266
int mthca_QUERY_ADAPTER(struct mthca_dev *dev , struct mthca_adapter *adapter ) ;
#line 268
int mthca_INIT_HCA(struct mthca_dev *dev , struct mthca_init_hca_param *param ) ;
#line 273
int mthca_CLOSE_IB(struct mthca_dev *dev , int port ) ;
#line 274
int mthca_CLOSE_HCA(struct mthca_dev *dev , int panic___0 ) ;
#line 280
int mthca_MAP_ICM_AUX(struct mthca_dev *dev , struct mthca_icm *icm ) ;
#line 281
int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev ) ;
#line 282
int mthca_SET_ICM_SIZE(struct mthca_dev *dev , u64 icm_size , u64 *aux_pages ) ;
#line 323
int mthca_NOP(struct mthca_dev *dev ) ;
#line 54 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_profile.h"
s64 mthca_make_profile(struct mthca_dev *dev , struct mthca_profile *request , struct mthca_dev_lim *dev_lim ,
                       struct mthca_init_hca_param *init_hca ) ;
#line 82 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
struct mthca_icm *mthca_alloc_icm(struct mthca_dev *dev , int npages , gfp_t gfp_mask ,
                                  int coherent ) ;
#line 84
void mthca_free_icm(struct mthca_dev *dev , struct mthca_icm *icm , int coherent ) ;
#line 86
struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev , u64 virt , int obj_size ,
                                              int nobj , int reserved , int use_lowmem ,
                                              int use_coherent ) ;
#line 90
void mthca_free_icm_table(struct mthca_dev *dev , struct mthca_icm_table *table ) ;
#line 177 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int mthca_debug_level  =    0;
#line 185 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int msi_x  =    1;
#line 195 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int tune_pci  =    0;
#line 199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
struct mutex mthca_device_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "mthca_device_mutex.wait_lock",
                                                                     0, 0UL}}}}, {& mthca_device_mutex.wait_list,
                                                                                  & mthca_device_mutex.wait_list},
    0, 0, (void *)(& mthca_device_mutex), {0, {0, 0}, "mthca_device_mutex", 0, 0UL}};
#line 211 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static struct mthca_profile hca_profile  = 
#line 211
     {65536, 4, 0, 65536, 8192, 131072, 1048576, 32768, 0, 262144, 262144};
#line 250 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int log_mtts_per_seg  =    3;
#line 254 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static char mthca_version[63U]  = 
#line 254
  {      'i',      'b',      '_',      'm', 
        't',      'h',      'c',      'a', 
        ':',      ' ',      'M',      'e', 
        'l',      'l',      'a',      'n', 
        'o',      'x',      ' ',      'I', 
        'n',      'f',      'i',      'n', 
        'i',      'B',      'a',      'n', 
        'd',      ' ',      'H',      'C', 
        'A',      ' ',      'd',      'r', 
        'i',      'v',      'e',      'r', 
        ' ',      'v',      '1',      '.', 
        '0',      ' ',      '(',      'A', 
        'p',      'r',      'i',      'l', 
        ' ',      '4',      ',',      ' ', 
        '2',      '0',      '0',      '8', 
        ')',      '\n',      '\000'};
#line 258 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_tune_pci(struct mthca_dev *mdev ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 260
  if (tune_pci == 0) {
#line 261
    return (0);
  } else {

  }
#line 264
  tmp___1 = pci_find_capability(mdev->pdev, 7);
#line 264
  if (tmp___1 != 0) {
#line 265
    tmp = pcix_get_max_mmrbc(mdev->pdev);
#line 265
    tmp___0 = pcix_set_mmrbc(mdev->pdev, tmp);
#line 265
    if (tmp___0 != 0) {
#line 266
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t set PCI-X max read count, aborting.\n");
#line 268
      return (-19);
    } else
#line 270
    if ((mdev->mthca_flags & 128UL) == 0UL) {
#line 271
      _dev_info((struct device  const  *)(& (mdev->pdev)->dev), "No PCI-X capability, not setting RBC.\n");
    } else {

    }
  } else {

  }
#line 273
  tmp___3 = pci_is_pcie(mdev->pdev);
#line 273
  if ((int )tmp___3) {
#line 274
    tmp___2 = pcie_set_readrq(mdev->pdev, 4096);
#line 274
    if (tmp___2 != 0) {
#line 275
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t write PCI Express read request, aborting.\n");
#line 277
      return (-19);
    } else
#line 279
    if ((mdev->mthca_flags & 128UL) != 0UL) {
#line 280
      _dev_info((struct device  const  *)(& (mdev->pdev)->dev), "No PCI Express capability, not setting Max Read Request Size.\n");
    } else {

    }
  } else {

  }
#line 283
  return (0);
}
}
#line 286 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_dev_lim(struct mthca_dev *mdev , struct mthca_dev_lim *dev_lim ) 
{ int err ;
  resource_size_t tmp ;
  resource_size_t tmp___0 ;
  int __min1 ;
  int __min2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 290
  mdev->limits.mtt_seg_size = 8 << log_mtts_per_seg;
#line 291
  err = mthca_QUERY_DEV_LIM(mdev, dev_lim);
#line 292
  if (err != 0) {
#line 293
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM command returned %d, aborting.\n",
            err);
#line 295
    return (err);
  } else {

  }
#line 297
  if ((unsigned int )dev_lim->min_page_sz > 4096U) {
#line 298
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA minimum page size of %d bigger than kernel PAGE_SIZE of %ld, aborting.\n",
            dev_lim->min_page_sz, 4096UL);
#line 301
    return (-19);
  } else {

  }
#line 303
  if (dev_lim->num_ports > 2) {
#line 304
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA has %d ports, but we only support %d, aborting.\n",
            dev_lim->num_ports, 2);
#line 307
    return (-19);
  } else {

  }
#line 310
  if ((mdev->pdev)->resource[2].start != 0ULL || (mdev->pdev)->resource[2].end != (mdev->pdev)->resource[2].start) {
#line 310
    tmp___0 = ((mdev->pdev)->resource[2].end - (mdev->pdev)->resource[2].start) + 1ULL;
  } else {
#line 310
    tmp___0 = 0ULL;
  }
#line 310
  if ((resource_size_t )dev_lim->uar_size > tmp___0) {
#line 311
    if ((mdev->pdev)->resource[2].start != 0ULL || (mdev->pdev)->resource[2].end != (mdev->pdev)->resource[2].start) {
#line 311
      tmp = ((mdev->pdev)->resource[2].end - (mdev->pdev)->resource[2].start) + 1ULL;
    } else {
#line 311
      tmp = 0ULL;
    }
#line 311
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "HCA reported UAR size of 0x%x bigger than PCI resource 2 size of 0x%llx, aborting.\n",
            dev_lim->uar_size, tmp);
#line 315
    return (-19);
  } else {

  }
#line 318
  mdev->limits.num_ports = dev_lim->num_ports;
#line 319
  mdev->limits.vl_cap = dev_lim->max_vl;
#line 320
  mdev->limits.mtu_cap = dev_lim->max_mtu;
#line 321
  mdev->limits.gid_table_len = dev_lim->max_gids;
#line 322
  mdev->limits.pkey_table_len = dev_lim->max_pkeys;
#line 323
  mdev->limits.local_ca_ack_delay = dev_lim->local_ca_ack_delay;
#line 329
  __min1 = dev_lim->max_sg;
#line 329
  mthca_is_memfree(mdev);
#line 329
  __min2 = (int )(((unsigned long )dev_lim->max_desc_sz - 64UL) / 16UL);
#line 329
  if (__min1 < __min2) {
#line 329
    tmp___1 = __min1;
  } else {
#line 329
    tmp___1 = __min2;
  }
#line 329
  mdev->limits.max_sg = tmp___1;
#line 336
  mdev->limits.max_wqes = dev_lim->max_qp_sz;
#line 337
  mdev->limits.max_qp_init_rdma = dev_lim->max_requester_per_qp;
#line 338
  mdev->limits.reserved_qps = dev_lim->reserved_qps;
#line 339
  mdev->limits.max_srq_wqes = dev_lim->max_srq_sz;
#line 340
  mdev->limits.reserved_srqs = dev_lim->reserved_srqs;
#line 341
  mdev->limits.reserved_eecs = dev_lim->reserved_eecs;
#line 342
  mdev->limits.max_desc_sz = dev_lim->max_desc_sz;
#line 343
  mdev->limits.max_srq_sge = mthca_max_srq_sge(mdev);
#line 349
  mdev->limits.max_cqes = dev_lim->max_cq_sz + -1;
#line 350
  mdev->limits.reserved_cqs = dev_lim->reserved_cqs;
#line 351
  mdev->limits.reserved_eqs = dev_lim->reserved_eqs;
#line 352
  mdev->limits.reserved_mtts = dev_lim->reserved_mtts;
#line 353
  mdev->limits.reserved_mrws = dev_lim->reserved_mrws;
#line 354
  mdev->limits.reserved_uars = dev_lim->reserved_uars;
#line 355
  mdev->limits.reserved_pds = dev_lim->reserved_pds;
#line 356
  mdev->limits.port_width_cap = (u8 )dev_lim->max_port_width;
#line 357
  mdev->limits.page_size_cap = - ((unsigned int )dev_lim->min_page_sz);
#line 358
  mdev->limits.flags = dev_lim->flags;
#line 365
  if ((unsigned int )dev_lim->stat_rate_support != 0U) {
#line 366
    mdev->limits.stat_rate_support = dev_lim->stat_rate_support;
  } else
#line 367
  if ((mdev->mthca_flags & 256UL) != 0UL) {
#line 368
    mdev->limits.stat_rate_support = 15U;
  } else {
#line 370
    mdev->limits.stat_rate_support = 3U;
  }
#line 379
  mdev->device_cap_flags = 7200UL;
#line 384
  if ((dev_lim->flags & 256U) != 0U) {
#line 385
    mdev->device_cap_flags = mdev->device_cap_flags | 2UL;
  } else {

  }
#line 387
  if ((dev_lim->flags & 512U) != 0U) {
#line 388
    mdev->device_cap_flags = mdev->device_cap_flags | 4UL;
  } else {

  }
#line 390
  if ((dev_lim->flags & 524288U) != 0U) {
#line 391
    mdev->device_cap_flags = mdev->device_cap_flags | 8UL;
  } else {

  }
#line 393
  if ((dev_lim->flags & 131072U) != 0U) {
#line 394
    mdev->device_cap_flags = mdev->device_cap_flags | 16UL;
  } else {

  }
#line 396
  if ((dev_lim->flags & 1048576U) != 0U) {
#line 397
    mdev->device_cap_flags = mdev->device_cap_flags | 64UL;
  } else {

  }
#line 399
  if ((dev_lim->flags & 64U) != 0U) {
#line 400
    mdev->mthca_flags = mdev->mthca_flags | 4UL;
  } else {

  }
#line 402
  tmp___2 = mthca_is_memfree(mdev);
#line 402
  if (tmp___2 != 0) {
#line 403
    if ((dev_lim->flags & 128U) != 0U) {
#line 404
      mdev->device_cap_flags = mdev->device_cap_flags | 262144UL;
    } else {

    }
  } else {

  }
#line 406
  return (0);
}
}
#line 409 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init_tavor(struct mthca_dev *mdev ) 
{ s64 size ;
  int err ;
  struct mthca_dev_lim dev_lim ;
  struct mthca_profile profile ;
  struct mthca_init_hca_param init_hca ;

  {
#line 417
  err = mthca_SYS_EN(mdev);
#line 418
  if (err != 0) {
#line 419
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "SYS_EN command returned %d, aborting.\n",
            err);
#line 420
    return (err);
  } else {

  }
#line 423
  err = mthca_QUERY_FW(mdev);
#line 424
  if (err != 0) {
#line 425
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_FW command returned %d, aborting.\n",
            err);
#line 427
    goto err_disable;
  } else {

  }
#line 429
  err = mthca_QUERY_DDR(mdev);
#line 430
  if (err != 0) {
#line 431
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DDR command returned %d, aborting.\n",
            err);
#line 432
    goto err_disable;
  } else {

  }
#line 435
  err = mthca_dev_lim(mdev, & dev_lim);
#line 436
  if (err != 0) {
#line 437
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM command returned %d, aborting.\n",
            err);
#line 438
    goto err_disable;
  } else {

  }
#line 441
  profile = hca_profile;
#line 442
  profile.num_uar = (int )((unsigned long )dev_lim.uar_size / 4096UL);
#line 443
  profile.uarc_size = 0;
#line 444
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 445
    profile.num_srq = dev_lim.max_srqs;
  } else {

  }
#line 447
  size = mthca_make_profile(mdev, & profile, & dev_lim, & init_hca);
#line 448
  if (size < 0LL) {
#line 449
    err = (int )size;
#line 450
    goto err_disable;
  } else {

  }
#line 453
  err = mthca_INIT_HCA(mdev, & init_hca);
#line 454
  if (err != 0) {
#line 455
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "INIT_HCA command returned %d, aborting.\n",
            err);
#line 456
    goto err_disable;
  } else {

  }
#line 459
  return (0);
  err_disable: 
#line 462
  mthca_SYS_DIS(mdev);
#line 464
  return (err);
}
}
#line 467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_load_fw(struct mthca_dev *mdev ) 
{ int err ;

  {
#line 473
  mdev->fw.arbel.fw_icm = mthca_alloc_icm(mdev, (int )mdev->fw.arbel.fw_pages, 131794U,
                                          0);
#line 476
  if ((unsigned long )mdev->fw.arbel.fw_icm == (unsigned long )((struct mthca_icm *)0)) {
#line 477
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate FW area, aborting.\n");
#line 478
    return (-12);
  } else {

  }
#line 481
  err = mthca_MAP_FA(mdev, mdev->fw.arbel.fw_icm);
#line 482
  if (err != 0) {
#line 483
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "MAP_FA command returned %d, aborting.\n",
            err);
#line 484
    goto err_free;
  } else {

  }
#line 486
  err = mthca_RUN_FW(mdev);
#line 487
  if (err != 0) {
#line 488
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "RUN_FW command returned %d, aborting.\n",
            err);
#line 489
    goto err_unmap_fa;
  } else {

  }
#line 492
  return (0);
  err_unmap_fa: 
#line 495
  mthca_UNMAP_FA(mdev);
  err_free: 
#line 498
  mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
#line 499
  return (err);
}
}
#line 502 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init_icm(struct mthca_dev *mdev , struct mthca_dev_lim *dev_lim ,
                          struct mthca_init_hca_param *init_hca , u64 icm_size ) 
{ u64 aux_pages ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 510
  err = mthca_SET_ICM_SIZE(mdev, icm_size, & aux_pages);
#line 511
  if (err != 0) {
#line 512
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "SET_ICM_SIZE command returned %d, aborting.\n",
            err);
#line 513
    return (err);
  } else {

  }
#line 516
  if (mthca_debug_level != 0) {
#line 516
    dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "%lld KB of HCA context requires %lld KB aux memory.\n",
               icm_size >> 10, aux_pages << 2);
  } else {

  }
#line 520
  mdev->fw.arbel.aux_icm = mthca_alloc_icm(mdev, (int )aux_pages, 131794U, 0);
#line 522
  if ((unsigned long )mdev->fw.arbel.aux_icm == (unsigned long )((struct mthca_icm *)0)) {
#line 523
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate aux memory, aborting.\n");
#line 524
    return (-12);
  } else {

  }
#line 527
  err = mthca_MAP_ICM_AUX(mdev, mdev->fw.arbel.aux_icm);
#line 528
  if (err != 0) {
#line 529
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "MAP_ICM_AUX returned %d, aborting.\n",
            err);
#line 530
    goto err_free_aux;
  } else {

  }
#line 533
  err = mthca_map_eq_icm(mdev, init_hca->eqc_base);
#line 534
  if (err != 0) {
#line 535
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map EQ context memory, aborting.\n");
#line 536
    goto err_unmap_aux;
  } else {

  }
#line 540
  tmp = dma_get_cache_alignment();
#line 540
  tmp___0 = dma_get_cache_alignment();
#line 540
  mdev->limits.reserved_mtts = ((mdev->limits.reserved_mtts * mdev->limits.mtt_seg_size + (tmp + -1)) & - tmp___0) / mdev->limits.mtt_seg_size;
#line 543
  mdev->mr_table.mtt_table = mthca_alloc_icm_table(mdev, init_hca->mtt_base, mdev->limits.mtt_seg_size,
                                                   mdev->limits.num_mtt_segs, mdev->limits.reserved_mtts,
                                                   1, 0);
#line 548
  if ((unsigned long )mdev->mr_table.mtt_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 549
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MTT context memory, aborting.\n");
#line 550
    err = -12;
#line 551
    goto err_unmap_eq;
  } else {

  }
#line 554
  mdev->mr_table.mpt_table = mthca_alloc_icm_table(mdev, init_hca->mpt_base, dev_lim->mpt_entry_sz,
                                                   mdev->limits.num_mpts, mdev->limits.reserved_mrws,
                                                   1, 1);
#line 559
  if ((unsigned long )mdev->mr_table.mpt_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 560
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MPT context memory, aborting.\n");
#line 561
    err = -12;
#line 562
    goto err_unmap_mtt;
  } else {

  }
#line 565
  mdev->qp_table.qp_table = mthca_alloc_icm_table(mdev, init_hca->qpc_base, dev_lim->qpc_entry_sz,
                                                  mdev->limits.num_qps, mdev->limits.reserved_qps,
                                                  0, 0);
#line 570
  if ((unsigned long )mdev->qp_table.qp_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 571
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map QP context memory, aborting.\n");
#line 572
    err = -12;
#line 573
    goto err_unmap_mpt;
  } else {

  }
#line 576
  mdev->qp_table.eqp_table = mthca_alloc_icm_table(mdev, init_hca->eqpc_base, dev_lim->eqpc_entry_sz,
                                                   mdev->limits.num_qps, mdev->limits.reserved_qps,
                                                   0, 0);
#line 581
  if ((unsigned long )mdev->qp_table.eqp_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 582
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map EQP context memory, aborting.\n");
#line 583
    err = -12;
#line 584
    goto err_unmap_qp;
  } else {

  }
#line 587
  mdev->qp_table.rdb_table = mthca_alloc_icm_table(mdev, init_hca->rdb_base, 32, mdev->limits.num_qps << mdev->qp_table.rdb_shift,
                                                   0, 0, 0);
#line 592
  if ((unsigned long )mdev->qp_table.rdb_table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 593
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map RDB context memory, aborting\n");
#line 594
    err = -12;
#line 595
    goto err_unmap_eqp;
  } else {

  }
#line 598
  mdev->cq_table.table = mthca_alloc_icm_table(mdev, init_hca->cqc_base, dev_lim->cqc_entry_sz,
                                               mdev->limits.num_cqs, mdev->limits.reserved_cqs,
                                               0, 0);
#line 603
  if ((unsigned long )mdev->cq_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 604
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map CQ context memory, aborting.\n");
#line 605
    err = -12;
#line 606
    goto err_unmap_rdb;
  } else {

  }
#line 609
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 610
    mdev->srq_table.table = mthca_alloc_icm_table(mdev, init_hca->srqc_base, dev_lim->srq_entry_sz,
                                                  mdev->limits.num_srqs, mdev->limits.reserved_srqs,
                                                  0, 0);
#line 616
    if ((unsigned long )mdev->srq_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 617
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map SRQ context memory, aborting.\n");
#line 619
      err = -12;
#line 620
      goto err_unmap_cq;
    } else {

    }
  } else {

  }
#line 629
  mdev->mcg_table.table = mthca_alloc_icm_table(mdev, init_hca->mc_base, 256, mdev->limits.num_mgms + mdev->limits.num_amgms,
                                                mdev->limits.num_mgms + mdev->limits.num_amgms,
                                                0, 0);
#line 636
  if ((unsigned long )mdev->mcg_table.table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 637
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to map MCG context memory, aborting.\n");
#line 638
    err = -12;
#line 639
    goto err_unmap_srq;
  } else {

  }
#line 642
  return (0);
  err_unmap_srq: ;
#line 645
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 646
    mthca_free_icm_table(mdev, mdev->srq_table.table);
  } else {

  }
  err_unmap_cq: 
#line 649
  mthca_free_icm_table(mdev, mdev->cq_table.table);
  err_unmap_rdb: 
#line 652
  mthca_free_icm_table(mdev, mdev->qp_table.rdb_table);
  err_unmap_eqp: 
#line 655
  mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
  err_unmap_qp: 
#line 658
  mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
  err_unmap_mpt: 
#line 661
  mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
  err_unmap_mtt: 
#line 664
  mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
  err_unmap_eq: 
#line 667
  mthca_unmap_eq_icm(mdev);
  err_unmap_aux: 
#line 670
  mthca_UNMAP_ICM_AUX(mdev);
  err_free_aux: 
#line 673
  mthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);
#line 675
  return (err);
}
}
#line 678 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void mthca_free_icms(struct mthca_dev *mdev ) 
{ 

  {
#line 681
  mthca_free_icm_table(mdev, mdev->mcg_table.table);
#line 682
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 683
    mthca_free_icm_table(mdev, mdev->srq_table.table);
  } else {

  }
#line 684
  mthca_free_icm_table(mdev, mdev->cq_table.table);
#line 685
  mthca_free_icm_table(mdev, mdev->qp_table.rdb_table);
#line 686
  mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
#line 687
  mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
#line 688
  mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
#line 689
  mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
#line 690
  mthca_unmap_eq_icm(mdev);
#line 692
  mthca_UNMAP_ICM_AUX(mdev);
#line 693
  mthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);
#line 694
  return;
}
}
#line 696 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init_arbel(struct mthca_dev *mdev ) 
{ struct mthca_dev_lim dev_lim ;
  struct mthca_profile profile ;
  struct mthca_init_hca_param init_hca ;
  s64 icm_size ;
  int err ;

  {
#line 704
  err = mthca_QUERY_FW(mdev);
#line 705
  if (err != 0) {
#line 706
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_FW command failed %d, aborting.\n",
            err);
#line 707
    return (err);
  } else {

  }
#line 710
  err = mthca_ENABLE_LAM(mdev);
#line 711
  if (err == -11) {
#line 712
    if (mthca_debug_level != 0) {
#line 712
      dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "No HCA-attached memory (running in MemFree mode)\n");
    } else {

    }
#line 713
    mdev->mthca_flags = mdev->mthca_flags | 16UL;
  } else
#line 714
  if (err != 0) {
#line 715
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "ENABLE_LAM returned %d, aborting.\n",
            err);
#line 716
    return (err);
  } else {

  }
#line 719
  err = mthca_load_fw(mdev);
#line 720
  if (err != 0) {
#line 721
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Loading FW returned %d, aborting.\n",
            err);
#line 722
    goto err_disable;
  } else {

  }
#line 725
  err = mthca_dev_lim(mdev, & dev_lim);
#line 726
  if (err != 0) {
#line 727
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_DEV_LIM returned %d, aborting.\n",
            err);
#line 728
    goto err_stop_fw;
  } else {

  }
#line 731
  profile = hca_profile;
#line 732
  profile.num_uar = (int )((unsigned long )dev_lim.uar_size / 4096UL);
#line 733
  profile.num_udav = 0;
#line 734
  if ((mdev->mthca_flags & 4UL) != 0UL) {
#line 735
    profile.num_srq = dev_lim.max_srqs;
  } else {

  }
#line 737
  icm_size = mthca_make_profile(mdev, & profile, & dev_lim, & init_hca);
#line 738
  if (icm_size < 0LL) {
#line 739
    err = (int )icm_size;
#line 740
    goto err_stop_fw;
  } else {

  }
#line 743
  err = mthca_init_icm(mdev, & dev_lim, & init_hca, (u64 )icm_size);
#line 744
  if (err != 0) {
#line 745
    goto err_stop_fw;
  } else {

  }
#line 747
  err = mthca_INIT_HCA(mdev, & init_hca);
#line 748
  if (err != 0) {
#line 749
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "INIT_HCA command returned %d, aborting.\n",
            err);
#line 750
    goto err_free_icm;
  } else {

  }
#line 753
  return (0);
  err_free_icm: 
#line 756
  mthca_free_icms(mdev);
  err_stop_fw: 
#line 759
  mthca_UNMAP_FA(mdev);
#line 760
  mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
  err_disable: ;
#line 763
  if ((mdev->mthca_flags & 16UL) == 0UL) {
#line 764
    mthca_DISABLE_LAM(mdev);
  } else {

  }
#line 766
  return (err);
}
}
#line 769 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void mthca_close_hca(struct mthca_dev *mdev ) 
{ int tmp ;

  {
#line 771
  mthca_CLOSE_HCA(mdev, 0);
#line 773
  tmp = mthca_is_memfree(mdev);
#line 773
  if (tmp != 0) {
#line 774
    mthca_free_icms(mdev);
#line 776
    mthca_UNMAP_FA(mdev);
#line 777
    mthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);
#line 779
    if ((mdev->mthca_flags & 16UL) == 0UL) {
#line 780
      mthca_DISABLE_LAM(mdev);
    } else {

    }
  } else {
#line 782
    mthca_SYS_DIS(mdev);
  }
#line 783
  return;
}
}
#line 785 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init_hca(struct mthca_dev *mdev ) 
{ int err ;
  struct mthca_adapter adapter ;
  int tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 790
  tmp = mthca_is_memfree(mdev);
#line 790
  if (tmp != 0) {
#line 791
    err = mthca_init_arbel(mdev);
  } else {
#line 793
    err = mthca_init_tavor(mdev);
  }
#line 795
  if (err != 0) {
#line 796
    return (err);
  } else {

  }
#line 798
  err = mthca_QUERY_ADAPTER(mdev, & adapter);
#line 799
  if (err != 0) {
#line 800
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "QUERY_ADAPTER command returned %d, aborting.\n",
            err);
#line 801
    goto err_close;
  } else {

  }
#line 804
  mdev->eq_table.inta_pin = adapter.inta_pin;
#line 805
  tmp___0 = mthca_is_memfree(mdev);
#line 805
  if (tmp___0 == 0) {
#line 806
    mdev->rev_id = adapter.revision_id;
  } else {

  }
#line 807
  __len = 64UL;
#line 807
  if (__len > 63UL) {
#line 807
    __ret = __memcpy((void *)(& mdev->board_id), (void const   *)(& adapter.board_id),
                     __len);
  } else {
#line 807
    __ret = __builtin_memcpy((void *)(& mdev->board_id), (void const   *)(& adapter.board_id),
                             __len);
  }
#line 809
  return (0);
  err_close: 
#line 812
  mthca_close_hca(mdev);
#line 813
  return (err);
}
}
#line 816 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_setup_hca(struct mthca_dev *dev ) 
{ int err ;

  {
#line 822
  err = mthca_init_uar_table(dev);
#line 823
  if (err != 0) {
#line 824
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize user access region table, aborting.\n");
#line 826
    return (err);
  } else {

  }
#line 829
  err = mthca_uar_alloc(dev, & dev->driver_uar);
#line 830
  if (err != 0) {
#line 831
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to allocate driver access region, aborting.\n");
#line 833
    goto err_uar_table_free;
  } else {

  }
#line 836
  dev->kar = ioremap((unsigned long long )dev->driver_uar.pfn << 12, 4096UL);
#line 837
  if ((unsigned long )dev->kar == (unsigned long )((void *)0)) {
#line 838
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map kernel access region, aborting.\n");
#line 840
    err = -12;
#line 841
    goto err_uar_free;
  } else {

  }
#line 844
  err = mthca_init_pd_table(dev);
#line 845
  if (err != 0) {
#line 846
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize protection domain table, aborting.\n");
#line 848
    goto err_kar_unmap;
  } else {

  }
#line 851
  err = mthca_init_mr_table(dev);
#line 852
  if (err != 0) {
#line 853
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize memory region table, aborting.\n");
#line 855
    goto err_pd_table_free;
  } else {

  }
#line 858
  err = mthca_pd_alloc(dev, 1, & dev->driver_pd);
#line 859
  if (err != 0) {
#line 860
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to create driver PD, aborting.\n");
#line 862
    goto err_mr_table_free;
  } else {

  }
#line 865
  err = mthca_init_eq_table(dev);
#line 866
  if (err != 0) {
#line 867
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize event queue table, aborting.\n");
#line 869
    goto err_pd_free;
  } else {

  }
#line 872
  err = mthca_cmd_use_events(dev);
#line 873
  if (err != 0) {
#line 874
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to switch to event-driven firmware commands, aborting.\n");
#line 876
    goto err_eq_table_free;
  } else {

  }
#line 879
  err = mthca_NOP(dev);
#line 880
  if (err != 0) {
#line 881
    if ((dev->mthca_flags & 8UL) != 0UL) {
#line 882
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "NOP command failed to generate interrupt (IRQ %d).\n",
               (int )dev->eq_table.eq[0].msi_x_vector);
#line 885
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Trying again with MSI-X disabled.\n");
    } else {
#line 887
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "NOP command failed to generate interrupt (IRQ %d), aborting.\n",
              (dev->pdev)->irq);
#line 890
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "BIOS or ACPI interrupt routing problem?\n");
    }
#line 893
    goto err_cmd_poll;
  } else {

  }
#line 896
  if (mthca_debug_level != 0) {
#line 896
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "NOP command IRQ test passed\n");
  } else {

  }
#line 898
  err = mthca_init_cq_table(dev);
#line 899
  if (err != 0) {
#line 900
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize completion queue table, aborting.\n");
#line 902
    goto err_cmd_poll;
  } else {

  }
#line 905
  err = mthca_init_srq_table(dev);
#line 906
  if (err != 0) {
#line 907
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize shared receive queue table, aborting.\n");
#line 909
    goto err_cq_table_free;
  } else {

  }
#line 912
  err = mthca_init_qp_table(dev);
#line 913
  if (err != 0) {
#line 914
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize queue pair table, aborting.\n");
#line 916
    goto err_srq_table_free;
  } else {

  }
#line 919
  err = mthca_init_av_table(dev);
#line 920
  if (err != 0) {
#line 921
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize address vector table, aborting.\n");
#line 923
    goto err_qp_table_free;
  } else {

  }
#line 926
  err = mthca_init_mcg_table(dev);
#line 927
  if (err != 0) {
#line 928
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to initialize multicast group table, aborting.\n");
#line 930
    goto err_av_table_free;
  } else {

  }
#line 933
  return (0);
  err_av_table_free: 
#line 936
  mthca_cleanup_av_table(dev);
  err_qp_table_free: 
#line 939
  mthca_cleanup_qp_table(dev);
  err_srq_table_free: 
#line 942
  mthca_cleanup_srq_table(dev);
  err_cq_table_free: 
#line 945
  mthca_cleanup_cq_table(dev);
  err_cmd_poll: 
#line 948
  mthca_cmd_use_polling(dev);
  err_eq_table_free: 
#line 951
  mthca_cleanup_eq_table(dev);
  err_pd_free: 
#line 954
  mthca_pd_free(dev, & dev->driver_pd);
  err_mr_table_free: 
#line 957
  mthca_cleanup_mr_table(dev);
  err_pd_table_free: 
#line 960
  mthca_cleanup_pd_table(dev);
  err_kar_unmap: 
#line 963
  iounmap((void volatile   *)dev->kar);
  err_uar_free: 
#line 966
  mthca_uar_free(dev, & dev->driver_uar);
  err_uar_table_free: 
#line 969
  mthca_cleanup_uar_table(dev);
#line 970
  return (err);
}
}
#line 973 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_enable_msi_x(struct mthca_dev *mdev ) 
{ struct msix_entry entries[3U] ;
  int err ;

  {
#line 978
  entries[0].entry = 0U;
#line 979
  entries[1].entry = 1U;
#line 980
  entries[2].entry = 2U;
#line 982
  err = pci_enable_msix(mdev->pdev, (struct msix_entry *)(& entries), 3);
#line 983
  if (err != 0) {
#line 984
    if (err > 0) {
#line 985
      _dev_info((struct device  const  *)(& (mdev->pdev)->dev), "Only %d MSI-X vectors available, not using MSI-X\n",
                err);
    } else {

    }
#line 987
    return (err);
  } else {

  }
#line 990
  mdev->eq_table.eq[2].msi_x_vector = (u16 )entries[0].vector;
#line 991
  mdev->eq_table.eq[1].msi_x_vector = (u16 )entries[1].vector;
#line 992
  mdev->eq_table.eq[0].msi_x_vector = (u16 )entries[2].vector;
#line 994
  return (0);
}
}
#line 1011 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static struct __anonstruct_mthca_hca_table_179 mthca_hca_table[4U]  = {      {12885229568ULL, 0U}, 
        {17180393672ULL, 128U}, 
        {21475033088ULL, 192U}, 
        {4295098368ULL, 448U}};
#line 1025 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int __mthca_init_one(struct pci_dev *pdev , int hca_type ) 
{ int ddr_hidden ;
  int err ;
  struct mthca_dev *mdev ;
  char const   *tmp ;
  struct ib_device *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1027
  ddr_hidden = 0;
#line 1031
  tmp = pci_name((struct pci_dev  const  *)pdev);
#line 1031
  printk("\016ib_mthca: Initializing %s\n", tmp);
#line 1034
  err = pci_enable_device(pdev);
#line 1035
  if (err != 0) {
#line 1036
    dev_err((struct device  const  *)(& pdev->dev), "Cannot enable PCI device, aborting.\n");
#line 1038
    return (err);
  } else {

  }
#line 1045
  if ((pdev->resource[0].flags & 512UL) == 0UL || ((pdev->resource[0].start == 0ULL && pdev->resource[0].end == pdev->resource[0].start) || pdev->resource[0].end - pdev->resource[0].start != 1048575ULL)) {
#line 1047
    dev_err((struct device  const  *)(& pdev->dev), "Missing DCS, aborting.\n");
#line 1048
    err = -19;
#line 1049
    goto err_disable_pdev;
  } else {

  }
#line 1051
  if ((pdev->resource[2].flags & 512UL) == 0UL) {
#line 1052
    dev_err((struct device  const  *)(& pdev->dev), "Missing UAR, aborting.\n");
#line 1053
    err = -19;
#line 1054
    goto err_disable_pdev;
  } else {

  }
#line 1056
  if ((pdev->resource[4].flags & 512UL) == 0UL) {
#line 1057
    ddr_hidden = 1;
  } else {

  }
#line 1059
  err = pci_request_regions(pdev, "ib_mthca");
#line 1060
  if (err != 0) {
#line 1061
    dev_err((struct device  const  *)(& pdev->dev), "Cannot obtain PCI resources, aborting.\n");
#line 1063
    goto err_disable_pdev;
  } else {

  }
#line 1066
  pci_set_master(pdev);
#line 1068
  err = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
#line 1069
  if (err != 0) {
#line 1070
    dev_warn((struct device  const  *)(& pdev->dev), "Warning: couldn\'t set 64-bit PCI DMA mask.\n");
#line 1071
    err = pci_set_dma_mask(pdev, 4294967295ULL);
#line 1072
    if (err != 0) {
#line 1073
      dev_err((struct device  const  *)(& pdev->dev), "Can\'t set PCI DMA mask, aborting.\n");
#line 1074
      goto err_free_res;
    } else {

    }
  } else {

  }
#line 1077
  err = pci_set_consistent_dma_mask(pdev, 0xffffffffffffffffULL);
#line 1078
  if (err != 0) {
#line 1079
    dev_warn((struct device  const  *)(& pdev->dev), "Warning: couldn\'t set 64-bit consistent PCI DMA mask.\n");
#line 1081
    err = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
#line 1082
    if (err != 0) {
#line 1083
      dev_err((struct device  const  *)(& pdev->dev), "Can\'t set consistent PCI DMA mask, aborting.\n");
#line 1085
      goto err_free_res;
    } else {

    }
  } else {

  }
#line 1090
  dma_set_max_seg_size(& pdev->dev, 1073741824U);
#line 1092
  tmp___0 = ib_alloc_device(5824UL);
#line 1092
  mdev = (struct mthca_dev *)tmp___0;
#line 1093
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 1094
    dev_err((struct device  const  *)(& pdev->dev), "Device struct alloc failed, aborting.\n");
#line 1096
    err = -12;
#line 1097
    goto err_free_res;
  } else {

  }
#line 1100
  mdev->pdev = pdev;
#line 1102
  mdev->mthca_flags = (unsigned long )mthca_hca_table[hca_type].flags;
#line 1103
  if (ddr_hidden != 0) {
#line 1104
    mdev->mthca_flags = mdev->mthca_flags | 2UL;
  } else {

  }
#line 1111
  err = mthca_reset(mdev);
#line 1112
  if (err != 0) {
#line 1113
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to reset HCA, aborting.\n");
#line 1114
    goto err_free_dev;
  } else {

  }
#line 1117
  tmp___1 = mthca_cmd_init(mdev);
#line 1117
  if (tmp___1 != 0) {
#line 1118
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Failed to init command interface, aborting.\n");
#line 1119
    goto err_free_dev;
  } else {

  }
#line 1122
  err = mthca_tune_pci(mdev);
#line 1123
  if (err != 0) {
#line 1124
    goto err_cmd;
  } else {

  }
#line 1126
  err = mthca_init_hca(mdev);
#line 1127
  if (err != 0) {
#line 1128
    goto err_cmd;
  } else {

  }
#line 1130
  if (mdev->fw_ver < mthca_hca_table[hca_type].latest_fw) {
#line 1131
    dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "HCA FW version %d.%d.%03d is old (%d.%d.%03d is current).\n",
             (int )(mdev->fw_ver >> 32), (int )(mdev->fw_ver >> 16) & 65535, (int )mdev->fw_ver & 65535,
             (int )(mthca_hca_table[hca_type].latest_fw >> 32), (int )(mthca_hca_table[hca_type].latest_fw >> 16) & 65535,
             (int )mthca_hca_table[hca_type].latest_fw & 65535);
#line 1137
    dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "If you have problems, try updating your HCA FW.\n");
  } else {

  }
#line 1140
  if (msi_x != 0) {
#line 1140
    tmp___2 = mthca_enable_msi_x(mdev);
#line 1140
    if (tmp___2 == 0) {
#line 1141
      mdev->mthca_flags = mdev->mthca_flags | 8UL;
    } else {

    }
  } else {

  }
#line 1143
  err = mthca_setup_hca(mdev);
#line 1144
  if (err == -16 && (mdev->mthca_flags & 8UL) != 0UL) {
#line 1145
    if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1146
      pci_disable_msix(pdev);
    } else {

    }
#line 1147
    mdev->mthca_flags = mdev->mthca_flags & 0xfffffffffffffff7UL;
#line 1149
    err = mthca_setup_hca(mdev);
  } else {

  }
#line 1152
  if (err != 0) {
#line 1153
    goto err_close;
  } else {

  }
#line 1155
  err = mthca_register_device(mdev);
#line 1156
  if (err != 0) {
#line 1157
    goto err_cleanup;
  } else {

  }
#line 1159
  err = mthca_create_agents(mdev);
#line 1160
  if (err != 0) {
#line 1161
    goto err_unregister;
  } else {

  }
#line 1163
  pci_set_drvdata(pdev, (void *)mdev);
#line 1164
  mdev->hca_type = hca_type;
#line 1166
  mdev->active = 1;
#line 1168
  return (0);
  err_unregister: 
#line 1171
  mthca_unregister_device(mdev);
  err_cleanup: 
#line 1174
  mthca_cleanup_mcg_table(mdev);
#line 1175
  mthca_cleanup_av_table(mdev);
#line 1176
  mthca_cleanup_qp_table(mdev);
#line 1177
  mthca_cleanup_srq_table(mdev);
#line 1178
  mthca_cleanup_cq_table(mdev);
#line 1179
  mthca_cmd_use_polling(mdev);
#line 1180
  mthca_cleanup_eq_table(mdev);
#line 1182
  mthca_pd_free(mdev, & mdev->driver_pd);
#line 1184
  mthca_cleanup_mr_table(mdev);
#line 1185
  mthca_cleanup_pd_table(mdev);
#line 1186
  mthca_cleanup_uar_table(mdev);
  err_close: ;
#line 1189
  if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1190
    pci_disable_msix(pdev);
  } else {

  }
#line 1192
  mthca_close_hca(mdev);
  err_cmd: 
#line 1195
  mthca_cmd_cleanup(mdev);
  err_free_dev: 
#line 1198
  ib_dealloc_device(& mdev->ib_dev);
  err_free_res: 
#line 1201
  pci_release_regions(pdev);
  err_disable_pdev: 
#line 1204
  pci_disable_device(pdev);
#line 1205
  pci_set_drvdata(pdev, 0);
#line 1206
  return (err);
}
}
#line 1209 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void __mthca_remove_one(struct pci_dev *pdev ) 
{ struct mthca_dev *mdev ;
  void *tmp ;
  int p ;

  {
#line 1211
  tmp = pci_get_drvdata(pdev);
#line 1211
  mdev = (struct mthca_dev *)tmp;
#line 1214
  if ((unsigned long )mdev != (unsigned long )((struct mthca_dev *)0)) {
#line 1215
    mthca_free_agents(mdev);
#line 1216
    mthca_unregister_device(mdev);
#line 1218
    p = 1;
#line 1218
    goto ldv_25998;
    ldv_25997: 
#line 1219
    mthca_CLOSE_IB(mdev, p);
#line 1218
    p = p + 1;
    ldv_25998: ;
#line 1218
    if (mdev->limits.num_ports >= p) {
#line 1219
      goto ldv_25997;
    } else {
#line 1221
      goto ldv_25999;
    }
    ldv_25999: 
#line 1221
    mthca_cleanup_mcg_table(mdev);
#line 1222
    mthca_cleanup_av_table(mdev);
#line 1223
    mthca_cleanup_qp_table(mdev);
#line 1224
    mthca_cleanup_srq_table(mdev);
#line 1225
    mthca_cleanup_cq_table(mdev);
#line 1226
    mthca_cmd_use_polling(mdev);
#line 1227
    mthca_cleanup_eq_table(mdev);
#line 1229
    mthca_pd_free(mdev, & mdev->driver_pd);
#line 1231
    mthca_cleanup_mr_table(mdev);
#line 1232
    mthca_cleanup_pd_table(mdev);
#line 1234
    iounmap((void volatile   *)mdev->kar);
#line 1235
    mthca_uar_free(mdev, & mdev->driver_uar);
#line 1236
    mthca_cleanup_uar_table(mdev);
#line 1237
    mthca_close_hca(mdev);
#line 1238
    mthca_cmd_cleanup(mdev);
#line 1240
    if ((mdev->mthca_flags & 8UL) != 0UL) {
#line 1241
      pci_disable_msix(pdev);
    } else {

    }
#line 1243
    ib_dealloc_device(& mdev->ib_dev);
#line 1244
    pci_release_regions(pdev);
#line 1245
    pci_disable_device(pdev);
#line 1246
    pci_set_drvdata(pdev, 0);
  } else {

  }
#line 1248
  return;
}
}
#line 1250 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int __mthca_restart_one(struct pci_dev *pdev ) 
{ struct mthca_dev *mdev ;
  int hca_type ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1255
  tmp = pci_get_drvdata(pdev);
#line 1255
  mdev = (struct mthca_dev *)tmp;
#line 1256
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 1257
    return (-19);
  } else {

  }
#line 1258
  hca_type = mdev->hca_type;
#line 1259
  __mthca_remove_one(pdev);
#line 1260
  tmp___0 = __mthca_init_one(pdev, hca_type);
#line 1260
  return (tmp___0);
}
}
#line 1263 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init_one(struct pci_dev *pdev , struct pci_device_id  const  *id ) 
{ int ret ;
  bool __print_once ;
  char const   *tmp ;

  {
#line 1268
  ldv_mutex_lock_6(& mthca_device_mutex);
#line 1270
  if (! __print_once) {
#line 1270
    __print_once = 1;
#line 1270
    printk("\016%s", (char *)(& mthca_version));
  } else {

  }
#line 1272
  if ((unsigned long )id->driver_data > 3UL) {
#line 1273
    tmp = pci_name((struct pci_dev  const  *)pdev);
#line 1273
    printk("\vib_mthca: %s has invalid driver data %lx\n", tmp, id->driver_data);
#line 1275
    ldv_mutex_unlock_7(& mthca_device_mutex);
#line 1276
    return (-19);
  } else {

  }
#line 1279
  ret = __mthca_init_one(pdev, (int )id->driver_data);
#line 1281
  ldv_mutex_unlock_8(& mthca_device_mutex);
#line 1283
  return (ret);
}
}
#line 1286 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void mthca_remove_one(struct pci_dev *pdev ) 
{ 

  {
#line 1288
  ldv_mutex_lock_9(& mthca_device_mutex);
#line 1289
  __mthca_remove_one(pdev);
#line 1290
  ldv_mutex_unlock_10(& mthca_device_mutex);
#line 1291
  return;
}
}
#line 1293 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static struct pci_device_id mthca_pci_table[11U]  = 
#line 1293
  {      {5555U, 23108U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6247U, 23108U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {5555U, 25208U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {6247U, 25208U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {5555U, 25218U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {6247U, 25218U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {5555U, 25204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {6247U, 25204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {5555U, 24204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {6247U, 24204U, 4294967295U, 4294967295U, 0U, 0U, 3UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 1317 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 1319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static struct pci_driver mthca_driver  = 
#line 1319
     {{0, 0}, "ib_mthca", (struct pci_device_id  const  *)(& mthca_pci_table), & mthca_init_one,
    & mthca_remove_one, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0,
                                              0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U,
                                                                  0, {0, {0, 0}, 0,
                                                                      0, 0UL}}}},
                                                               {0, 0}}};
#line 1326 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void __mthca_check_profile_val(char const   *name , int *pval , int pval_default ) 
{ int old_pval ;
  unsigned long tmp ;

  {
#line 1330
  old_pval = *pval;
#line 1332
  if (old_pval <= 0) {
#line 1333
    *pval = pval_default;
  } else {
#line 1335
    tmp = __roundup_pow_of_two((unsigned long )old_pval);
#line 1335
    *pval = (int )tmp;
  }
#line 1337
  if (*pval != old_pval) {
#line 1338
    printk("\fib_mthca: Invalid value %d for %s in module parameter.\n", old_pval,
           name);
#line 1340
    printk("\fib_mthca: Corrected %s to %d.\n", name, *pval);
  } else {

  }
#line 1342
  return;
}
}
#line 1347 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void mthca_validate_profile(void) 
{ 

  {
#line 1349
  __mthca_check_profile_val("num_qp", & hca_profile.num_qp, 65536);
#line 1350
  __mthca_check_profile_val("rdb_per_qp", & hca_profile.rdb_per_qp, 4);
#line 1351
  __mthca_check_profile_val("num_cq", & hca_profile.num_cq, 65536);
#line 1352
  __mthca_check_profile_val("num_mcg", & hca_profile.num_mcg, 8192);
#line 1353
  __mthca_check_profile_val("num_mpt", & hca_profile.num_mpt, 131072);
#line 1354
  __mthca_check_profile_val("num_mtt", & hca_profile.num_mtt, 1048576);
#line 1355
  __mthca_check_profile_val("num_udav", & hca_profile.num_udav, 32768);
#line 1356
  __mthca_check_profile_val("fmr_reserved_mtts", & hca_profile.fmr_reserved_mtts,
                            262144);
#line 1358
  if (hca_profile.fmr_reserved_mtts >= hca_profile.num_mtt) {
#line 1359
    printk("\fib_mthca: Invalid fmr_reserved_mtts module parameter %d.\n", hca_profile.fmr_reserved_mtts);
#line 1361
    printk("\fib_mthca: (Must be smaller than num_mtt %d)\n", hca_profile.num_mtt);
#line 1363
    hca_profile.fmr_reserved_mtts = hca_profile.num_mtt / 2;
#line 1364
    printk("\fib_mthca: Corrected fmr_reserved_mtts to %d.\n", hca_profile.fmr_reserved_mtts);
  } else {

  }
#line 1368
  if (log_mtts_per_seg <= 0 || log_mtts_per_seg > 5) {
#line 1369
    printk("\fib_mthca: bad log_mtts_per_seg (%d). Using default - %d\n", log_mtts_per_seg,
           3);
#line 1371
    log_mtts_per_seg = 3;
  } else {

  }
#line 1373
  return;
}
}
#line 1375 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static int mthca_init(void) 
{ int ret ;

  {
#line 1379
  mthca_validate_profile();
#line 1381
  ret = mthca_catas_init();
#line 1382
  if (ret != 0) {
#line 1383
    return (ret);
  } else {

  }
#line 1385
  ret = __pci_register_driver(& mthca_driver, & __this_module, "ib_mthca");
#line 1386
  if (ret < 0) {
#line 1387
    mthca_catas_cleanup();
#line 1388
    return (ret);
  } else {

  }
#line 1391
  return (0);
}
}
#line 1394 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
static void mthca_cleanup(void) 
{ 

  {
#line 1396
  pci_unregister_driver(& mthca_driver);
#line 1397
  mthca_catas_cleanup();
#line 1398
  return;
}
}
#line 1402 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
struct pci_dev *mthca_driver_group0  ;
#line 1403 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_retval_0  ;
#line 1404 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_retval_1  ;
#line 1405
void ldv_initialize(void) ;
#line 1406
void ldv_check_final_state(void) ;
#line 1407 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
struct pci_device_id *ldvarg12  ;
#line 1412
void ldv_main_exported_4(void) ;
#line 1413
void ldv_main_exported_1(void) ;
#line 1414
void ldv_main_exported_3(void) ;
#line 1415
void ldv_main_exported_2(void) ;
#line 1419 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void main(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1420
  ldv_initialize();
#line 1422
  ldv_state_variable_4 = 0;
#line 1423
  ldv_state_variable_1 = 0;
#line 1424
  ref_cnt = 0;
#line 1425
  ldv_state_variable_0 = 1;
#line 1426
  ldv_state_variable_3 = 0;
#line 1427
  ldv_state_variable_2 = 0;
#line 1428
  ldv_state_variable_5 = 0;
  ldv_26085: 
#line 1430
  tmp = __VERIFIER_nondet_int();
#line 1430
  switch (tmp) {
  case 0: ;
#line 1434
  if (ldv_state_variable_4 != 0) {
#line 1435
    ldv_main_exported_4();
  } else {

  }
#line 1438
  goto ldv_26069;
  case 1: ;
#line 1442
  if (ldv_state_variable_1 != 0) {
#line 1443
    ldv_main_exported_1();
  } else {

  }
#line 1446
  goto ldv_26069;
  case 2: ;
#line 1450
  if (ldv_state_variable_0 != 0) {
#line 1451
    tmp___0 = __VERIFIER_nondet_int();
#line 1451
    switch (tmp___0) {
    case 0: ;
#line 1454
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1456
      mthca_cleanup();
#line 1457
      ldv_state_variable_0 = 2;
#line 1458
      goto ldv_final;
    } else {

    }
#line 1461
    goto ldv_26074;
    case 1: ;
#line 1464
    if (ldv_state_variable_0 == 1) {
#line 1466
      ldv_retval_0 = mthca_init();
#line 1468
      if (ldv_retval_0 == 0) {
#line 1469
        ldv_state_variable_0 = 3;
#line 1470
        ldv_state_variable_5 = 1;
#line 1471
        ldv_state_variable_2 = 1;
#line 1472
        ldv_state_variable_3 = 1;
#line 1473
        ldv_state_variable_1 = 1;
#line 1474
        ldv_state_variable_4 = 1;
      } else {

      }
#line 1476
      if (ldv_retval_0 != 0) {
#line 1477
        ldv_state_variable_0 = 2;
#line 1478
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1482
    goto ldv_26074;
    default: ;
#line 1483
    goto ldv_26074;
    }
    ldv_26074: ;
  } else {

  }
#line 1487
  goto ldv_26069;
  case 3: ;
#line 1491
  if (ldv_state_variable_3 != 0) {
#line 1492
    ldv_main_exported_3();
  } else {

  }
#line 1495
  goto ldv_26069;
  case 4: ;
#line 1499
  if (ldv_state_variable_2 != 0) {
#line 1500
    ldv_main_exported_2();
  } else {

  }
#line 1503
  goto ldv_26069;
  case 5: ;
#line 1507
  if (ldv_state_variable_5 != 0) {
#line 1508
    tmp___1 = __VERIFIER_nondet_int();
#line 1508
    switch (tmp___1) {
    case 0: ;
#line 1511
    if (ldv_state_variable_5 == 1) {
#line 1513
      ldv_retval_1 = mthca_init_one(mthca_driver_group0, (struct pci_device_id  const  *)ldvarg12);
#line 1515
      if (ldv_retval_1 == 0) {
#line 1516
        ldv_state_variable_5 = 2;
#line 1517
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1521
    goto ldv_26081;
    case 1: ;
#line 1524
    if (ldv_state_variable_5 == 2) {
#line 1526
      mthca_remove_one(mthca_driver_group0);
#line 1528
      ldv_state_variable_5 = 1;
#line 1529
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1532
    goto ldv_26081;
    default: ;
#line 1533
    goto ldv_26081;
    }
    ldv_26081: ;
  } else {

  }
#line 1537
  goto ldv_26069;
  default: ;
#line 1538
  goto ldv_26069;
  }
  ldv_26069: ;
#line 1540
  goto ldv_26085;
  ldv_final: 
#line 1542
  ldv_check_final_state();
#line 1543
  return;
}
}
#line 1546 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1551
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1553
  mutex_lock(ldv_func_arg1);
#line 1554
  return;
}
}
#line 1556 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1561
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1563
  mutex_unlock(ldv_func_arg1);
#line 1564
  return;
}
}
#line 1566 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1571
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1573
  mutex_lock(ldv_func_arg1);
#line 1574
  return;
}
}
#line 1576 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1581
  tmp = mutex_trylock(ldv_func_arg1);
#line 1581
  ldv_func_res = tmp;
#line 1583
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1583
  return (tmp___0);
#line 1585
  return (ldv_func_res);
}
}
#line 1588 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1593
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1595
  mutex_unlock(ldv_func_arg1);
#line 1596
  return;
}
}
#line 1598 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1603
  ldv_mutex_lock_mthca_device_mutex(ldv_func_arg1);
#line 1605
  mutex_lock(ldv_func_arg1);
#line 1606
  return;
}
}
#line 1608 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1613
  ldv_mutex_unlock_mthca_device_mutex(ldv_func_arg1);
#line 1615
  mutex_unlock(ldv_func_arg1);
#line 1616
  return;
}
}
#line 1618 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_unlock_8(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1623
  ldv_mutex_unlock_mthca_device_mutex(ldv_func_arg1);
#line 1625
  mutex_unlock(ldv_func_arg1);
#line 1626
  return;
}
}
#line 1628 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1633
  ldv_mutex_lock_mthca_device_mutex(ldv_func_arg1);
#line 1635
  mutex_lock(ldv_func_arg1);
#line 1636
  return;
}
}
#line 1638 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_main.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1643
  ldv_mutex_unlock_mthca_device_mutex(ldv_func_arg1);
#line 1645
  mutex_unlock(ldv_func_arg1);
#line 1646
  return;
}
}
#line 1 "<compiler builtins>"
long ldv__builtin_expect(long exp , long c ) ;
#line 406 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ int r ;

  {
#line 420
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 433
  return (r + 1);
}
}
#line 7 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 

  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 154 "include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
#line 159
  tmp = __fswab16((int )*p);
#line 159
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 180 "include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
#line 185
  tmp = __fswab64(*p);
#line 185
  return (tmp);
}
}
#line 71 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ __u64 tmp ;

  {
#line 73
  tmp = __swab64p(p);
#line 73
  return (tmp);
}
}
#line 79 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ __u32 tmp ;

  {
#line 81
  tmp = __swab32p(p);
#line 81
  return (tmp);
}
}
#line 87 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ __u16 tmp ;

  {
#line 89
  tmp = __swab16p(p);
#line 89
  return (tmp);
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 88 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
#line 34
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 11 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 171
int ldv_mutex_trylock_24(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_26(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) ;
#line 35
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 39
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 43
void ldv_mutex_lock_hcr_mutex_of_mthca_cmd(struct mutex *lock ) ;
#line 47
void ldv_mutex_unlock_hcr_mutex_of_mthca_cmd(struct mutex *lock ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return (& lock->ldv_5961.rlock);
}
}
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 

  {
#line 285
  _raw_spin_lock(& lock->ldv_5961.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 

  {
#line 325
  _raw_spin_unlock(& lock->ldv_5961.rlock);
#line 326
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 82
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 91
extern void complete(struct completion * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 294
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
#line 59
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
#line 59
  return (ret);
}
}
#line 67 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 

  {
#line 67
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
#line 68
  return;
}
}
#line 17 "include/asm-generic/scatterlist.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 20 "include/linux/dmapool.h"
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 22
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 25
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 334 "include/linux/sched.h"
extern void schedule(void) ;
#line 32 "include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;

  {
#line 35
  __constr_expr_0.lock.raw_lock.ldv_2024.head_tail = 0U;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = 0xffffffffffffffffUL;
#line 35
  __constr_expr_0.lock.dep_map.key = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
#line 35
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
#line 35
  __constr_expr_0.lock.dep_map.cpu = 0;
#line 35
  __constr_expr_0.lock.dep_map.ip = 0UL;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
#line 36
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
#line 37
  return;
}
}
#line 39
extern void down(struct semaphore * ) ;
#line 44
extern void up(struct semaphore * ) ;
#line 385 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
extern void __buggy_use_of_MTHCA_GET(void) ;
#line 386
extern void __buggy_use_of_MTHCA_PUT(void) ;
#line 248 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_cmd.h"
void mthca_cmd_event(struct mthca_dev *dev , u16 token , u8 status , u64 out_param ) ;
#line 251
struct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev , gfp_t gfp_mask ) ;
#line 253
void mthca_free_mailbox(struct mthca_dev *dev , struct mthca_mailbox *mailbox ) ;
#line 270
int mthca_INIT_IB(struct mthca_dev *dev , struct mthca_init_ib_param *param , int port ) ;
#line 275
int mthca_SET_IB(struct mthca_dev *dev , struct mthca_set_ib_param *param , int port ) ;
#line 277
int mthca_MAP_ICM(struct mthca_dev *dev , struct mthca_icm *icm , u64 virt ) ;
#line 278
int mthca_MAP_ICM_page(struct mthca_dev *dev , u64 dma_addr , u64 virt ) ;
#line 279
int mthca_UNMAP_ICM(struct mthca_dev *dev , u64 virt , u32 page_count___0 ) ;
#line 283
int mthca_SW2HW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) ;
#line 285
int mthca_HW2SW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) ;
#line 287
int mthca_WRITE_MTT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int num_mtt ) ;
#line 289
int mthca_SYNC_TPT(struct mthca_dev *dev ) ;
#line 290
int mthca_MAP_EQ(struct mthca_dev *dev , u64 event_mask , int unmap , int eq_num ) ;
#line 292
int mthca_SW2HW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) ;
#line 294
int mthca_HW2SW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) ;
#line 296
int mthca_SW2HW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) ;
#line 298
int mthca_HW2SW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) ;
#line 300
int mthca_RESIZE_CQ(struct mthca_dev *dev , int cq_num , u32 lkey , u8 log_size ) ;
#line 301
int mthca_SW2HW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) ;
#line 303
int mthca_HW2SW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) ;
#line 305
int mthca_QUERY_SRQ(struct mthca_dev *dev , u32 num , struct mthca_mailbox *mailbox ) ;
#line 307
int mthca_ARM_SRQ(struct mthca_dev *dev , int srq_num , int limit ) ;
#line 308
int mthca_MODIFY_QP(struct mthca_dev *dev , enum ib_qp_state cur , enum ib_qp_state next ,
                    u32 num , int is_ee , struct mthca_mailbox *mailbox , u32 optmask ) ;
#line 311
int mthca_QUERY_QP(struct mthca_dev *dev , u32 num , int is_ee , struct mthca_mailbox *mailbox ) ;
#line 313
int mthca_CONF_SPECIAL_QP(struct mthca_dev *dev , int type , u32 qpn ) ;
#line 314
int mthca_MAD_IFC(struct mthca_dev *dev , int ignore_mkey , int ignore_bkey , int port ,
                  struct ib_wc *in_wc , struct ib_grh *in_grh , void *in_mad , void *response_mad ) ;
#line 317
int mthca_READ_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) ;
#line 319
int mthca_WRITE_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) ;
#line 321
int mthca_MGID_HASH(struct mthca_dev *dev , struct mthca_mailbox *mailbox , u16 *hash ) ;
#line 99 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static void mthca_icm_first(struct mthca_icm *icm , struct mthca_icm_iter *iter ) 
{ struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 102
  iter->icm = icm;
#line 104
  tmp___0 = list_empty((struct list_head  const  *)(& icm->chunk_list));
#line 104
  if (tmp___0 == 0) {
#line 104
    __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 104
    iter->chunk = (struct mthca_icm_chunk *)__mptr;
  } else {
#line 104
    iter->chunk = 0;
  }
#line 106
  iter->page_idx = 0;
#line 107
  return;
}
}
#line 109 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static int mthca_icm_last(struct mthca_icm_iter *iter ) 
{ 

  {
#line 111
  return ((unsigned long )iter->chunk == (unsigned long )((struct mthca_icm_chunk *)0));
}
}
#line 114 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static void mthca_icm_next(struct mthca_icm_iter *iter ) 
{ struct list_head  const  *__mptr ;

  {
#line 116
  iter->page_idx = iter->page_idx + 1;
#line 116
  if (iter->page_idx >= (iter->chunk)->nsg) {
#line 117
    if ((unsigned long )(iter->chunk)->list.next == (unsigned long )(& (iter->icm)->chunk_list)) {
#line 118
      iter->chunk = 0;
#line 119
      return;
    } else {

    }
#line 122
    __mptr = (struct list_head  const  *)(iter->chunk)->list.next;
#line 122
    iter->chunk = (struct mthca_icm_chunk *)__mptr;
#line 124
    iter->page_idx = 0;
  } else {

  }
#line 126
  return;
}
}
#line 128 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static dma_addr_t mthca_icm_addr(struct mthca_icm_iter *iter ) 
{ 

  {
#line 130
  return (((struct scatterlist *)(& (iter->chunk)->mem) + (unsigned long )iter->page_idx)->dma_address);
}
}
#line 133 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
__inline static unsigned long mthca_icm_size(struct mthca_icm_iter *iter ) 
{ 

  {
#line 135
  return ((unsigned long )((struct scatterlist *)(& (iter->chunk)->mem) + (unsigned long )iter->page_idx)->dma_length);
}
}
#line 307 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int fw_cmd_doorbell  =    0;
#line 312 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
__inline static int go_bit(struct mthca_dev *dev ) 
{ unsigned int tmp ;

  {
#line 314
  tmp = readl((void const volatile   *)dev->hcr + 24U);
#line 314
  return ((int )tmp & 32768);
}
}
#line 318 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static void mthca_cmd_post_dbell(struct mthca_dev *dev , u64 in_param , u64 out_param ,
                                 u32 in_modifier , u8 op_modifier , u16 op , u16 token ) 
{ void *ptr ;
  u16 *offs ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
#line 326
  ptr = dev->cmd.dbell_map;
#line 327
  offs = (u16 *)(& dev->cmd.dbell_offsets);
#line 329
  tmp = __fswab32((__u32 )(in_param >> 32));
#line 329
  __writel(tmp, (void volatile   *)ptr + (unsigned long )*offs);
#line 330
  __asm__  volatile   ("sfence": : : "memory");
#line 331
  tmp___0 = __fswab32((__u32 )in_param);
#line 331
  __writel(tmp___0, (void volatile   *)ptr + (unsigned long )*(offs + 1UL));
#line 332
  __asm__  volatile   ("sfence": : : "memory");
#line 333
  tmp___1 = __fswab32(in_modifier);
#line 333
  __writel(tmp___1, (void volatile   *)ptr + (unsigned long )*(offs + 2UL));
#line 334
  __asm__  volatile   ("sfence": : : "memory");
#line 335
  tmp___2 = __fswab32((__u32 )(out_param >> 32));
#line 335
  __writel(tmp___2, (void volatile   *)ptr + (unsigned long )*(offs + 3UL));
#line 336
  __asm__  volatile   ("sfence": : : "memory");
#line 337
  tmp___3 = __fswab32((__u32 )out_param);
#line 337
  __writel(tmp___3, (void volatile   *)ptr + (unsigned long )*(offs + 4UL));
#line 338
  __asm__  volatile   ("sfence": : : "memory");
#line 339
  tmp___4 = __fswab32((__u32 )((int )token << 16));
#line 339
  __writel(tmp___4, (void volatile   *)ptr + (unsigned long )*(offs + 5UL));
#line 340
  __asm__  volatile   ("sfence": : : "memory");
#line 341
  tmp___5 = __fswab32((__u32 )((((int )op_modifier << 12) | 12582912) | (int )op));
#line 341
  __writel(tmp___5, (void volatile   *)ptr + (unsigned long )*(offs + 6UL));
#line 345
  __asm__  volatile   ("sfence": : : "memory");
#line 346
  __writel(0U, (void volatile   *)ptr + (unsigned long )*(offs + 7UL));
#line 347
  __asm__  volatile   ("sfence": : : "memory");
#line 348
  return;
}
}
#line 350 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_post_hcr(struct mthca_dev *dev , u64 in_param , u64 out_param ,
                              u32 in_modifier , u8 op_modifier , u16 op , u16 token ,
                              int event ) 
{ unsigned long end ;
  long volatile   __ret ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  int tmp___11 ;
  __u32 tmp___12 ;

  {
#line 359
  if (event != 0) {
#line 360
    end = (unsigned long )jiffies + 2500UL;
#line 362
    goto ldv_27611;
    ldv_27610: 
#line 363
    __ret = 0L;
#line 363
    switch (8UL) {
    case 1: 
#line 363
    tmp = get_current();
#line 363
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp->state): : "memory",
                         "cc");
#line 363
    goto ldv_27604;
    case 2: 
#line 363
    tmp___0 = get_current();
#line 363
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
#line 363
    goto ldv_27604;
    case 4: 
#line 363
    tmp___1 = get_current();
#line 363
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
#line 363
    goto ldv_27604;
    case 8: 
#line 363
    tmp___2 = get_current();
#line 363
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
#line 363
    goto ldv_27604;
    default: 
#line 363
    __xchg_wrong_size();
    }
    ldv_27604: 
#line 364
    schedule();
    ldv_27611: 
#line 362
    tmp___3 = go_bit(dev);
#line 362
    if (tmp___3 != 0 && (long )jiffies - (long )end < 0L) {
#line 363
      goto ldv_27610;
    } else {
#line 365
      goto ldv_27612;
    }
    ldv_27612: ;
  } else {

  }
#line 368
  tmp___4 = go_bit(dev);
#line 368
  if (tmp___4 != 0) {
#line 369
    return (-11);
  } else {

  }
#line 377
  tmp___5 = __fswab32((__u32 )(in_param >> 32));
#line 377
  __writel(tmp___5, (void volatile   *)dev->hcr);
#line 378
  tmp___6 = __fswab32((__u32 )in_param);
#line 378
  __writel(tmp___6, (void volatile   *)dev->hcr + 4U);
#line 379
  tmp___7 = __fswab32(in_modifier);
#line 379
  __writel(tmp___7, (void volatile   *)dev->hcr + 8U);
#line 380
  tmp___8 = __fswab32((__u32 )(out_param >> 32));
#line 380
  __writel(tmp___8, (void volatile   *)dev->hcr + 12U);
#line 381
  tmp___9 = __fswab32((__u32 )out_param);
#line 381
  __writel(tmp___9, (void volatile   *)dev->hcr + 16U);
#line 382
  tmp___10 = __fswab32((__u32 )((int )token << 16));
#line 382
  __writel(tmp___10, (void volatile   *)dev->hcr + 20U);
#line 385
  __asm__  volatile   ("sfence": : : "memory");
#line 387
  if (event != 0) {
#line 387
    tmp___11 = 12582912;
  } else {
#line 387
    tmp___11 = 8388608;
  }
#line 387
  tmp___12 = __fswab32((__u32 )((tmp___11 | ((int )op_modifier << 12)) | (int )op));
#line 387
  __writel(tmp___12, (void volatile   *)dev->hcr + 24U);
#line 392
  return (0);
}
}
#line 395 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_post(struct mthca_dev *dev , u64 in_param , u64 out_param , u32 in_modifier ,
                          u8 op_modifier , u16 op , u16 token , int event ) 
{ int err ;

  {
#line 404
  err = 0;
#line 406
  ldv_mutex_lock_28(& dev->cmd.hcr_mutex);
#line 408
  if ((event != 0 && (dev->cmd.flags & 2U) != 0U) && fw_cmd_doorbell != 0) {
#line 409
    mthca_cmd_post_dbell(dev, in_param, out_param, in_modifier, (int )op_modifier,
                         (int )op, (int )token);
  } else {
#line 412
    err = mthca_cmd_post_hcr(dev, in_param, out_param, in_modifier, (int )op_modifier,
                             (int )op, (int )token, event);
  }
#line 419
  __asm__  volatile   ("": : : "memory");
#line 421
  ldv_mutex_unlock_29(& dev->cmd.hcr_mutex);
#line 422
  return (err);
}
}
#line 426 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_status_to_errno(u8 status ) 
{ int trans_table[65U] ;

  {
#line 428
  trans_table[0] = 0;
#line 428
  trans_table[1] = -5;
#line 428
  trans_table[2] = -1;
#line 428
  trans_table[3] = -22;
#line 428
  trans_table[4] = -6;
#line 428
  trans_table[5] = -9;
#line 428
  trans_table[6] = -16;
#line 428
  trans_table[7] = -12;
#line 428
  trans_table[8] = -12;
#line 428
  trans_table[9] = -9;
#line 428
  trans_table[10] = -9;
#line 428
  trans_table[11] = -14;
#line 428
  trans_table[12] = 0;
#line 428
  trans_table[13] = 0;
#line 428
  trans_table[14] = 0;
#line 428
  trans_table[15] = 0;
#line 428
  trans_table[16] = -22;
#line 428
  trans_table[17] = 0;
#line 428
  trans_table[18] = 0;
#line 428
  trans_table[19] = 0;
#line 428
  trans_table[20] = 0;
#line 428
  trans_table[21] = 0;
#line 428
  trans_table[22] = 0;
#line 428
  trans_table[23] = 0;
#line 428
  trans_table[24] = 0;
#line 428
  trans_table[25] = 0;
#line 428
  trans_table[26] = 0;
#line 428
  trans_table[27] = 0;
#line 428
  trans_table[28] = 0;
#line 428
  trans_table[29] = 0;
#line 428
  trans_table[30] = 0;
#line 428
  trans_table[31] = 0;
#line 428
  trans_table[32] = -14;
#line 428
  trans_table[33] = -16;
#line 428
  trans_table[34] = -11;
#line 428
  trans_table[35] = 0;
#line 428
  trans_table[36] = 0;
#line 428
  trans_table[37] = 0;
#line 428
  trans_table[38] = 0;
#line 428
  trans_table[39] = 0;
#line 428
  trans_table[40] = 0;
#line 428
  trans_table[41] = 0;
#line 428
  trans_table[42] = 0;
#line 428
  trans_table[43] = 0;
#line 428
  trans_table[44] = 0;
#line 428
  trans_table[45] = 0;
#line 428
  trans_table[46] = 0;
#line 428
  trans_table[47] = 0;
#line 428
  trans_table[48] = -74;
#line 428
  trans_table[49] = 0;
#line 428
  trans_table[50] = 0;
#line 428
  trans_table[51] = 0;
#line 428
  trans_table[52] = 0;
#line 428
  trans_table[53] = 0;
#line 428
  trans_table[54] = 0;
#line 428
  trans_table[55] = 0;
#line 428
  trans_table[56] = 0;
#line 428
  trans_table[57] = 0;
#line 428
  trans_table[58] = 0;
#line 428
  trans_table[59] = 0;
#line 428
  trans_table[60] = 0;
#line 428
  trans_table[61] = 0;
#line 428
  trans_table[62] = 0;
#line 428
  trans_table[63] = 0;
#line 428
  trans_table[64] = -12;
#line 448
  if ((unsigned int )status > 64U || ((unsigned int )status != 0U && trans_table[(int )status] == 0)) {
#line 451
    return (-22);
  } else {

  }
#line 453
  return (trans_table[(int )status]);
}
}
#line 457 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_poll(struct mthca_dev *dev , u64 in_param , u64 *out_param ,
                          int out_is_imm , u32 in_modifier , u8 op_modifier , u16 op ,
                          unsigned long timeout ) 
{ int err ;
  unsigned long end ;
  u8 status ;
  u64 tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  __u32 tmp___7 ;
  unsigned int tmp___8 ;
  __u32 tmp___9 ;
  unsigned int tmp___10 ;
  __u32 tmp___11 ;

  {
#line 466
  err = 0;
#line 470
  down(& dev->cmd.poll_sem);
#line 472
  if ((unsigned long )out_param != (unsigned long )((u64 *)0)) {
#line 472
    tmp = *out_param;
  } else {
#line 472
    tmp = 0ULL;
  }
#line 472
  err = mthca_cmd_post(dev, in_param, tmp, in_modifier, (int )op_modifier, (int )op,
                       65535, 0);
#line 476
  if (err != 0) {
#line 477
    goto out;
  } else {

  }
#line 479
  end = timeout + (unsigned long )jiffies;
#line 480
  goto ldv_27659;
  ldv_27658: 
#line 481
  __ret = 0L;
#line 481
  switch (8UL) {
  case 1: 
#line 481
  tmp___0 = get_current();
#line 481
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 481
  goto ldv_27652;
  case 2: 
#line 481
  tmp___1 = get_current();
#line 481
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 481
  goto ldv_27652;
  case 4: 
#line 481
  tmp___2 = get_current();
#line 481
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 481
  goto ldv_27652;
  case 8: 
#line 481
  tmp___3 = get_current();
#line 481
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 481
  goto ldv_27652;
  default: 
#line 481
  __xchg_wrong_size();
  }
  ldv_27652: 
#line 482
  schedule();
  ldv_27659: 
#line 480
  tmp___4 = go_bit(dev);
#line 480
  if (tmp___4 != 0 && (long )jiffies - (long )end < 0L) {
#line 481
    goto ldv_27658;
  } else {
#line 483
    goto ldv_27660;
  }
  ldv_27660: 
#line 485
  tmp___5 = go_bit(dev);
#line 485
  if (tmp___5 != 0) {
#line 486
    err = -16;
#line 487
    goto out;
  } else {

  }
#line 490
  if (out_is_imm != 0) {
#line 491
    tmp___6 = __readl((void const volatile   *)dev->hcr + 12U);
#line 491
    tmp___7 = __fswab32(tmp___6);
#line 491
    tmp___8 = __readl((void const volatile   *)dev->hcr + 16U);
#line 491
    tmp___9 = __fswab32(tmp___8);
#line 491
    *out_param = ((unsigned long long )tmp___7 << 32) | (unsigned long long )tmp___9;
  } else {

  }
#line 497
  tmp___10 = __readl((void const volatile   *)dev->hcr + 24U);
#line 497
  tmp___11 = __fswab32(tmp___10);
#line 497
  status = (u8 )(tmp___11 >> 24);
#line 498
  if ((unsigned int )status != 0U) {
#line 499
    if (mthca_debug_level != 0) {
#line 499
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Command %02x completed with status %02x\n",
                 (int )op, (int )status);
    } else {

    }
#line 501
    err = mthca_status_to_errno((int )status);
  } else {

  }
  out: 
#line 505
  up(& dev->cmd.poll_sem);
#line 506
  return (err);
}
}
#line 509 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void mthca_cmd_event(struct mthca_dev *dev , u16 token , u8 status , u64 out_param ) 
{ struct mthca_cmd_context *context ;

  {
#line 514
  context = dev->cmd.context + (unsigned long )((int )dev->cmd.token_mask & (int )token);
#line 518
  if ((int )context->token != (int )token) {
#line 519
    return;
  } else {

  }
#line 521
  context->result = 0;
#line 522
  context->status = status;
#line 523
  context->out_param = out_param;
#line 525
  complete(& context->done);
#line 526
  return;
}
}
#line 528 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_wait(struct mthca_dev *dev , u64 in_param , u64 *out_param ,
                          int out_is_imm , u32 in_modifier , u8 op_modifier , u16 op ,
                          unsigned long timeout ) 
{ int err ;
  struct mthca_cmd_context *context ;
  long tmp ;
  u64 tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 537
  err = 0;
#line 540
  down(& dev->cmd.event_sem);
#line 542
  spin_lock(& dev->cmd.context_lock);
#line 543
  tmp = ldv__builtin_expect(dev->cmd.free_head < 0, 0L);
#line 543
  if (tmp != 0L) {
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"),
                         "i" (543), "i" (12UL));
    ldv_27680: ;
#line 543
    goto ldv_27680;
  } else {

  }
#line 544
  context = dev->cmd.context + (unsigned long )dev->cmd.free_head;
#line 545
  context->token = (unsigned int )((int )context->token + (int )dev->cmd.token_mask) + 1U;
#line 546
  dev->cmd.free_head = context->next;
#line 547
  spin_unlock(& dev->cmd.context_lock);
#line 549
  init_completion(& context->done);
#line 551
  if ((unsigned long )out_param != (unsigned long )((u64 *)0)) {
#line 551
    tmp___0 = *out_param;
  } else {
#line 551
    tmp___0 = 0ULL;
  }
#line 551
  err = mthca_cmd_post(dev, in_param, tmp___0, in_modifier, (int )op_modifier, (int )op,
                       (int )context->token, 1);
#line 555
  if (err != 0) {
#line 556
    goto out;
  } else {

  }
#line 558
  tmp___1 = wait_for_completion_timeout(& context->done, timeout);
#line 558
  if (tmp___1 == 0UL) {
#line 559
    err = -16;
#line 560
    goto out;
  } else {

  }
#line 563
  err = context->result;
#line 564
  if (err != 0) {
#line 565
    goto out;
  } else {

  }
#line 567
  if ((unsigned int )context->status != 0U) {
#line 568
    if (mthca_debug_level != 0) {
#line 568
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Command %02x completed with status %02x\n",
                 (int )op, (int )context->status);
    } else {

    }
#line 570
    err = mthca_status_to_errno((int )context->status);
  } else {

  }
#line 573
  if (out_is_imm != 0) {
#line 574
    *out_param = context->out_param;
  } else {

  }
  out: 
#line 577
  spin_lock(& dev->cmd.context_lock);
#line 578
  context->next = dev->cmd.free_head;
#line 579
  dev->cmd.free_head = (int )(((long )context - (long )dev->cmd.context) / 120L);
#line 580
  spin_unlock(& dev->cmd.context_lock);
#line 582
  up(& dev->cmd.event_sem);
#line 583
  return (err);
}
}
#line 587 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_box(struct mthca_dev *dev , u64 in_param , u64 out_param , u32 in_modifier ,
                         u8 op_modifier , u16 op , unsigned long timeout ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 595
  if ((int )dev->cmd.flags & 1) {
#line 596
    tmp = mthca_cmd_wait(dev, in_param, & out_param, 0, in_modifier, (int )op_modifier,
                         (int )op, timeout);
#line 596
    return (tmp);
  } else {
#line 600
    tmp___0 = mthca_cmd_poll(dev, in_param, & out_param, 0, in_modifier, (int )op_modifier,
                             (int )op, timeout);
#line 600
    return (tmp___0);
  }
}
}
#line 606 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd(struct mthca_dev *dev , u64 in_param , u32 in_modifier , u8 op_modifier ,
                     u16 op , unsigned long timeout ) 
{ int tmp ;

  {
#line 613
  tmp = mthca_cmd_box(dev, in_param, 0ULL, in_modifier, (int )op_modifier, (int )op,
                      timeout);
#line 613
  return (tmp);
}
}
#line 622 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_cmd_imm(struct mthca_dev *dev , u64 in_param , u64 *out_param , u32 in_modifier ,
                         u8 op_modifier , u16 op , unsigned long timeout ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 630
  if ((int )dev->cmd.flags & 1) {
#line 631
    tmp = mthca_cmd_wait(dev, in_param, out_param, 1, in_modifier, (int )op_modifier,
                         (int )op, timeout);
#line 631
    return (tmp);
  } else {
#line 635
    tmp___0 = mthca_cmd_poll(dev, in_param, out_param, 1, in_modifier, (int )op_modifier,
                             (int )op, timeout);
#line 635
    return (tmp___0);
  }
}
}
#line 640 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_cmd_init(struct mthca_dev *dev ) 
{ struct lock_class_key __key ;

  {
#line 642
  __mutex_init(& dev->cmd.hcr_mutex, "&dev->cmd.hcr_mutex", & __key);
#line 643
  sema_init(& dev->cmd.poll_sem, 1);
#line 644
  dev->cmd.flags = 0U;
#line 646
  dev->hcr = ioremap((dev->pdev)->resource[0].start + 525952ULL, 28UL);
#line 648
  if ((unsigned long )dev->hcr == (unsigned long )((void *)0)) {
#line 649
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map command register.");
#line 650
    return (-12);
  } else {

  }
#line 653
  dev->cmd.pool = dma_pool_create("mthca_cmd", & (dev->pdev)->dev, 4096UL, 4096UL,
                                  0UL);
#line 656
  if ((unsigned long )dev->cmd.pool == (unsigned long )((struct dma_pool *)0)) {
#line 657
    iounmap((void volatile   *)dev->hcr);
#line 658
    return (-12);
  } else {

  }
#line 661
  return (0);
}
}
#line 664 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void mthca_cmd_cleanup(struct mthca_dev *dev ) 
{ 

  {
#line 666
  dma_pool_destroy(dev->cmd.pool);
#line 667
  iounmap((void volatile   *)dev->hcr);
#line 668
  if ((dev->cmd.flags & 2U) != 0U) {
#line 669
    iounmap((void volatile   *)dev->cmd.dbell_map);
  } else {

  }
#line 670
  return;
}
}
#line 676 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_cmd_use_events(struct mthca_dev *dev ) 
{ int i ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 680
  tmp = kmalloc((unsigned long )dev->cmd.max_cmds * 120UL, 208U);
#line 680
  dev->cmd.context = (struct mthca_cmd_context *)tmp;
#line 683
  if ((unsigned long )dev->cmd.context == (unsigned long )((struct mthca_cmd_context *)0)) {
#line 684
    return (-12);
  } else {

  }
#line 686
  i = 0;
#line 686
  goto ldv_27720;
  ldv_27719: 
#line 687
  (dev->cmd.context + (unsigned long )i)->token = (u16 )i;
#line 688
  (dev->cmd.context + (unsigned long )i)->next = i + 1;
#line 686
  i = i + 1;
  ldv_27720: ;
#line 686
  if (dev->cmd.max_cmds > i) {
#line 687
    goto ldv_27719;
  } else {
#line 689
    goto ldv_27721;
  }
  ldv_27721: 
#line 691
  (dev->cmd.context + ((unsigned long )dev->cmd.max_cmds + 0xffffffffffffffffUL))->next = -1;
#line 692
  dev->cmd.free_head = 0;
#line 694
  sema_init(& dev->cmd.event_sem, dev->cmd.max_cmds);
#line 695
  spinlock_check(& dev->cmd.context_lock);
#line 695
  __raw_spin_lock_init(& dev->cmd.context_lock.ldv_5961.rlock, "&(&dev->cmd.context_lock)->rlock",
                       & __key);
#line 697
  dev->cmd.token_mask = 1U;
#line 697
  goto ldv_27724;
  ldv_27723: 
#line 699
  dev->cmd.token_mask = (int )dev->cmd.token_mask << 1U;
  ldv_27724: ;
#line 697
  if ((int )dev->cmd.token_mask < dev->cmd.max_cmds) {
#line 699
    goto ldv_27723;
  } else {
#line 701
    goto ldv_27725;
  }
  ldv_27725: 
#line 701
  dev->cmd.token_mask = (u16 )((int )dev->cmd.token_mask - 1);
#line 703
  dev->cmd.flags = dev->cmd.flags | 1U;
#line 705
  down(& dev->cmd.poll_sem);
#line 707
  return (0);
}
}
#line 713 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void mthca_cmd_use_polling(struct mthca_dev *dev ) 
{ int i ;

  {
#line 717
  dev->cmd.flags = dev->cmd.flags & 4294967294U;
#line 719
  i = 0;
#line 719
  goto ldv_27731;
  ldv_27730: 
#line 720
  down(& dev->cmd.event_sem);
#line 719
  i = i + 1;
  ldv_27731: ;
#line 719
  if (dev->cmd.max_cmds > i) {
#line 720
    goto ldv_27730;
  } else {
#line 722
    goto ldv_27732;
  }
  ldv_27732: 
#line 722
  kfree((void const   *)dev->cmd.context);
#line 724
  up(& dev->cmd.poll_sem);
#line 725
  return;
}
}
#line 727 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
struct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev , gfp_t gfp_mask ) 
{ struct mthca_mailbox *mailbox ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 732
  tmp = kmalloc(16UL, gfp_mask);
#line 732
  mailbox = (struct mthca_mailbox *)tmp;
#line 733
  if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 734
    tmp___0 = ERR_PTR(-12L);
#line 734
    return ((struct mthca_mailbox *)tmp___0);
  } else {

  }
#line 736
  mailbox->buf = dma_pool_alloc(dev->cmd.pool, gfp_mask, & mailbox->dma);
#line 737
  if ((unsigned long )mailbox->buf == (unsigned long )((void *)0)) {
#line 738
    kfree((void const   *)mailbox);
#line 739
    tmp___1 = ERR_PTR(-12L);
#line 739
    return ((struct mthca_mailbox *)tmp___1);
  } else {

  }
#line 742
  return (mailbox);
}
}
#line 745 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void mthca_free_mailbox(struct mthca_dev *dev , struct mthca_mailbox *mailbox ) 
{ 

  {
#line 747
  if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 748
    return;
  } else {

  }
#line 750
  dma_pool_free(dev->cmd.pool, mailbox->buf, mailbox->dma);
#line 751
  kfree((void const   *)mailbox);
#line 752
  return;
}
}
#line 754 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SYS_EN(struct mthca_dev *dev ) 
{ u64 out ;
  int ret ;
  char *tmp ;

  {
#line 759
  ret = mthca_cmd_imm(dev, 0ULL, & out, 0U, 0, 1, 15000UL);
#line 761
  if (ret == -12) {
#line 762
    if ((int )out & 1) {
#line 762
      tmp = (char *)"NVMEM";
    } else {
#line 762
      tmp = (char *)"DIMM";
    }
#line 762
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SYS_EN DDR error: syn=%x, sock=%d, sladdr=%d, SPD source=%s\n",
             (int )(out >> 6) & 15, (int )(out >> 4) & 3, (int )(out >> 1) & 7, tmp);
  } else {

  }
#line 767
  return (ret);
}
}
#line 770 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SYS_DIS(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 772
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 2, 15000UL);
#line 772
  return (tmp);
}
}
#line 775 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static int mthca_map_cmd(struct mthca_dev *dev , u16 op , struct mthca_icm *icm ,
                         u64 virt ) 
{ struct mthca_mailbox *mailbox ;
  struct mthca_icm_iter iter ;
  __be64 *pages ;
  int lg ;
  int nent ;
  int i ;
  int err ;
  int ts ;
  int tc ;
  long tmp ;
  long tmp___0 ;
  dma_addr_t tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  dma_addr_t tmp___5 ;
  __u64 tmp___6 ;
  dma_addr_t tmp___7 ;
  __u64 tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;

  {
#line 782
  nent = 0;
#line 784
  err = 0;
#line 785
  ts = 0;
#line 785
  tc = 0;
#line 787
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 788
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 788
  if (tmp___0 != 0L) {
#line 789
    tmp = PTR_ERR((void const   *)mailbox);
#line 789
    return ((int )tmp);
  } else {

  }
#line 790
  memset(mailbox->buf, 0, 4096UL);
#line 791
  pages = (__be64 *)mailbox->buf;
#line 793
  mthca_icm_first(icm, & iter);
#line 793
  goto ldv_27770;
  ldv_27769: 
#line 801
  tmp___1 = mthca_icm_addr(& iter);
#line 801
  tmp___2 = mthca_icm_size(& iter);
#line 801
  tmp___3 = ffs((int )((unsigned int )tmp___1 | (unsigned int )tmp___2));
#line 801
  lg = tmp___3 + -1;
#line 802
  if (lg <= 11) {
#line 803
    tmp___4 = mthca_icm_size(& iter);
#line 803
    tmp___5 = mthca_icm_addr(& iter);
#line 803
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Got FW area not aligned to %d (%llx/%lx).\n",
             4096, tmp___5, tmp___4);
#line 807
    err = -22;
#line 808
    goto out;
  } else {

  }
#line 810
  i = 0;
#line 810
  goto ldv_27767;
  ldv_27766: ;
#line 811
  if (virt != 0xffffffffffffffffULL) {
#line 812
    tmp___6 = __fswab64(virt);
#line 812
    *(pages + (unsigned long )(nent * 2)) = tmp___6;
#line 813
    virt = (u64 )(1 << lg) + virt;
  } else {

  }
#line 816
  tmp___7 = mthca_icm_addr(& iter);
#line 816
  tmp___8 = __fswab64((tmp___7 + (dma_addr_t )(i << lg)) | (dma_addr_t )(lg + -12));
#line 816
  *(pages + ((unsigned long )(nent * 2) + 1UL)) = tmp___8;
#line 819
  ts = (1 << (lg + -10)) + ts;
#line 820
  tc = tc + 1;
#line 822
  nent = nent + 1;
#line 822
  if (nent == 256) {
#line 823
    err = mthca_cmd(dev, mailbox->dma, (u32 )nent, 0, (int )op, 15000UL);
#line 825
    if (err != 0) {
#line 826
      goto out;
    } else {

    }
#line 827
    nent = 0;
  } else {

  }
#line 810
  i = i + 1;
  ldv_27767: 
#line 810
  tmp___9 = mthca_icm_size(& iter);
#line 810
  if ((unsigned long )i < tmp___9 >> lg) {
#line 811
    goto ldv_27766;
  } else {
#line 813
    goto ldv_27768;
  }
  ldv_27768: 
#line 795
  mthca_icm_next(& iter);
  ldv_27770: 
#line 793
  tmp___10 = mthca_icm_last(& iter);
#line 793
  if (tmp___10 == 0) {
#line 795
    goto ldv_27769;
  } else {
#line 797
    goto ldv_27771;
  }
  ldv_27771: ;
#line 832
  if (nent != 0) {
#line 833
    err = mthca_cmd(dev, mailbox->dma, (u32 )nent, 0, (int )op, 15000UL);
  } else {

  }
#line 836
  switch ((int )op) {
  case 4095: ;
#line 838
  if (mthca_debug_level != 0) {
#line 838
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB for FW.\n",
               tc, ts);
  } else {

  }
#line 839
  goto ldv_27773;
  case 4092: ;
#line 841
  if (mthca_debug_level != 0) {
#line 841
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB for ICM aux.\n",
               tc, ts);
  } else {

  }
#line 842
  goto ldv_27773;
  case 4090: ;
#line 844
  if (mthca_debug_level != 0) {
#line 844
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped %d chunks/%d KB at %llx for ICM.\n",
               tc, ts, virt - (u64 )(ts << 10));
  } else {

  }
#line 846
  goto ldv_27773;
  }
  ldv_27773: ;
  out: 
#line 850
  mthca_free_mailbox(dev, mailbox);
#line 851
  return (err);
}
}
#line 854 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAP_FA(struct mthca_dev *dev , struct mthca_icm *icm ) 
{ int tmp ;

  {
#line 856
  tmp = mthca_map_cmd(dev, 4095, icm, 0xffffffffffffffffULL);
#line 856
  return (tmp);
}
}
#line 859 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_UNMAP_FA(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 861
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4094, 15000UL);
#line 861
  return (tmp);
}
}
#line 864 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_RUN_FW(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 866
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4086, 15000UL);
#line 866
  return (tmp);
}
}
#line 869 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static void mthca_setup_cmd_doorbells(struct mthca_dev *dev , u64 base ) 
{ phys_addr_t addr ;
  u16 max_off ;
  int i ;
  u16 _max1 ;
  u16 _max2 ;
  int tmp ;
  unsigned long long tmp___0 ;

  {
#line 872
  max_off = 0U;
#line 875
  i = 0;
#line 875
  goto ldv_27797;
  ldv_27796: 
#line 876
  _max1 = max_off;
#line 876
  _max2 = dev->cmd.dbell_offsets[i];
#line 876
  if ((int )_max1 > (int )_max2) {
#line 876
    tmp = _max1;
  } else {
#line 876
    tmp = _max2;
  }
#line 876
  max_off = (u16 )tmp;
#line 875
  i = i + 1;
  ldv_27797: ;
#line 875
  if (i <= 7) {
#line 876
    goto ldv_27796;
  } else {
#line 878
    goto ldv_27798;
  }
  ldv_27798: ;
#line 878
  if (((((u64 )max_off + base) ^ base) & 0xfffffffffffff000ULL) != 0ULL) {
#line 879
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Firmware doorbell region at 0x%016llx, length 0x%x crosses a page boundary\n",
             base, (int )max_off);
#line 882
    return;
  } else {

  }
#line 885
  if ((dev->pdev)->resource[2].start != 0ULL || (dev->pdev)->resource[2].end != (dev->pdev)->resource[2].start) {
#line 885
    tmp___0 = (dev->pdev)->resource[2].end - (dev->pdev)->resource[2].start;
  } else {
#line 885
    tmp___0 = 0xffffffffffffffffULL;
  }
#line 885
  addr = (dev->pdev)->resource[2].start + (tmp___0 & base);
#line 887
  dev->cmd.dbell_map = ioremap(addr, (unsigned long )max_off + 4UL);
#line 888
  if ((unsigned long )dev->cmd.dbell_map == (unsigned long )((void *)0)) {
#line 889
    return;
  } else {

  }
#line 891
  dev->cmd.flags = dev->cmd.flags | 2U;
#line 892
  if (mthca_debug_level != 0) {
#line 892
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped doorbell page for posting FW commands\n");
  } else {

  }
#line 893
  return;
}
}
#line 895 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_FW(struct mthca_dev *dev ) 
{ struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  u64 base ;
  u32 tmp ;
  int err ;
  u8 lg ;
  int i ;
  long tmp___0 ;
  long tmp___1 ;
  void *__p ;
  __u16 tmp___2 ;
  __u32 tmp___3 ;
  void *__p___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__p___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  void *__p___2 ;
  __u16 tmp___9 ;
  __u64 tmp___10 ;
  void *__p___3 ;
  __u16 tmp___11 ;
  __u64 tmp___12 ;
  void *__p___4 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  void *__p___5 ;
  __u32 tmp___15 ;
  __u64 tmp___16 ;
  void *__p___6 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__p___7 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  void *__p___8 ;
  __u16 tmp___21 ;
  __u32 tmp___22 ;
  void *__p___9 ;
  __u16 tmp___23 ;
  __u32 tmp___24 ;
  void *__p___10 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  void *__p___11 ;
  __u16 tmp___27 ;
  __u32 tmp___28 ;
  int tmp___29 ;

  {
#line 901
  err = 0;
#line 923
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 924
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 924
  if (tmp___1 != 0L) {
#line 925
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 925
    return ((int )tmp___0);
  } else {

  }
#line 926
  outbox = (u32 *)mailbox->buf;
#line 928
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 4, 15000UL);
#line 931
  if (err != 0) {
#line 932
    goto out;
  } else {

  }
#line 934
  __p = (void *)outbox;
#line 934
  switch (8UL) {
  case 1: 
#line 934
  dev->fw_ver = (u64 )*((u8 *)__p);
#line 934
  goto ldv_27812;
  case 2: 
#line 934
  tmp___2 = __be16_to_cpup((__be16 const   *)__p);
#line 934
  dev->fw_ver = (u64 )tmp___2;
#line 934
  goto ldv_27812;
  case 4: 
#line 934
  tmp___3 = __be32_to_cpup((__be32 const   *)__p);
#line 934
  dev->fw_ver = (u64 )tmp___3;
#line 934
  goto ldv_27812;
  case 8: 
#line 934
  dev->fw_ver = __be64_to_cpup((__be64 const   *)__p);
#line 934
  goto ldv_27812;
  default: 
#line 934
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27812: 
#line 939
  dev->fw_ver = ((dev->fw_ver & 281470681743360ULL) | ((dev->fw_ver & 4294901760ULL) >> 16)) | ((dev->fw_ver << 16) & 4294967295ULL);
#line 943
  __p___0 = (void *)outbox + 15U;
#line 943
  switch (1UL) {
  case 1: 
#line 943
  lg = *((u8 *)__p___0);
#line 943
  goto ldv_27819;
  case 2: 
#line 943
  tmp___4 = __be16_to_cpup((__be16 const   *)__p___0);
#line 943
  lg = (u8 )tmp___4;
#line 943
  goto ldv_27819;
  case 4: 
#line 943
  tmp___5 = __be32_to_cpup((__be32 const   *)__p___0);
#line 943
  lg = (u8 )tmp___5;
#line 943
  goto ldv_27819;
  case 8: 
#line 943
  tmp___6 = __be64_to_cpup((__be64 const   *)__p___0);
#line 943
  lg = (u8 )tmp___6;
#line 943
  goto ldv_27819;
  default: 
#line 943
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27819: 
#line 944
  dev->cmd.max_cmds = 1 << (int )lg;
#line 946
  if (mthca_debug_level != 0) {
#line 946
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW version %012llx, max commands %d\n",
               dev->fw_ver, dev->cmd.max_cmds);
  } else {

  }
#line 949
  __p___1 = (void *)outbox + 48U;
#line 949
  switch (8UL) {
  case 1: 
#line 949
  dev->catas_err.addr = (u64 )*((u8 *)__p___1);
#line 949
  goto ldv_27826;
  case 2: 
#line 949
  tmp___7 = __be16_to_cpup((__be16 const   *)__p___1);
#line 949
  dev->catas_err.addr = (u64 )tmp___7;
#line 949
  goto ldv_27826;
  case 4: 
#line 949
  tmp___8 = __be32_to_cpup((__be32 const   *)__p___1);
#line 949
  dev->catas_err.addr = (u64 )tmp___8;
#line 949
  goto ldv_27826;
  case 8: 
#line 949
  dev->catas_err.addr = __be64_to_cpup((__be64 const   *)__p___1);
#line 949
  goto ldv_27826;
  default: 
#line 949
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27826: 
#line 950
  __p___2 = (void *)outbox + 56U;
#line 950
  switch (4UL) {
  case 1: 
#line 950
  dev->catas_err.size = (u32 )*((u8 *)__p___2);
#line 950
  goto ldv_27833;
  case 2: 
#line 950
  tmp___9 = __be16_to_cpup((__be16 const   *)__p___2);
#line 950
  dev->catas_err.size = (u32 )tmp___9;
#line 950
  goto ldv_27833;
  case 4: 
#line 950
  dev->catas_err.size = __be32_to_cpup((__be32 const   *)__p___2);
#line 950
  goto ldv_27833;
  case 8: 
#line 950
  tmp___10 = __be64_to_cpup((__be64 const   *)__p___2);
#line 950
  dev->catas_err.size = (u32 )tmp___10;
#line 950
  goto ldv_27833;
  default: 
#line 950
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27833: ;
#line 952
  if (mthca_debug_level != 0) {
#line 952
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Catastrophic error buffer at 0x%llx, size 0x%x\n",
               dev->catas_err.addr, dev->catas_err.size);
  } else {

  }
#line 955
  __p___3 = (void *)outbox + 16U;
#line 955
  switch (4UL) {
  case 1: 
#line 955
  tmp = (u32 )*((u8 *)__p___3);
#line 955
  goto ldv_27840;
  case 2: 
#line 955
  tmp___11 = __be16_to_cpup((__be16 const   *)__p___3);
#line 955
  tmp = (u32 )tmp___11;
#line 955
  goto ldv_27840;
  case 4: 
#line 955
  tmp = __be32_to_cpup((__be32 const   *)__p___3);
#line 955
  goto ldv_27840;
  case 8: 
#line 955
  tmp___12 = __be64_to_cpup((__be64 const   *)__p___3);
#line 955
  tmp = (u32 )tmp___12;
#line 955
  goto ldv_27840;
  default: 
#line 955
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27840: ;
#line 956
  if ((int )tmp & 1) {
#line 957
    if (mthca_debug_level != 0) {
#line 957
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW supports commands through doorbells\n");
    } else {

    }
#line 959
    __p___4 = (void *)outbox + 96U;
#line 959
    switch (8UL) {
    case 1: 
#line 959
    base = (u64 )*((u8 *)__p___4);
#line 959
    goto ldv_27847;
    case 2: 
#line 959
    tmp___13 = __be16_to_cpup((__be16 const   *)__p___4);
#line 959
    base = (u64 )tmp___13;
#line 959
    goto ldv_27847;
    case 4: 
#line 959
    tmp___14 = __be32_to_cpup((__be32 const   *)__p___4);
#line 959
    base = (u64 )tmp___14;
#line 959
    goto ldv_27847;
    case 8: 
#line 959
    base = __be64_to_cpup((__be64 const   *)__p___4);
#line 959
    goto ldv_27847;
    default: 
#line 959
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27847: 
#line 960
    i = 0;
#line 960
    goto ldv_27860;
    ldv_27859: 
#line 961
    __p___5 = (void *)outbox + (unsigned long )((i << 1) + 80);
#line 961
    switch (2UL) {
    case 1: 
#line 961
    dev->cmd.dbell_offsets[i] = (u16 )*((u8 *)__p___5);
#line 961
    goto ldv_27854;
    case 2: 
#line 961
    dev->cmd.dbell_offsets[i] = __be16_to_cpup((__be16 const   *)__p___5);
#line 961
    goto ldv_27854;
    case 4: 
#line 961
    tmp___15 = __be32_to_cpup((__be32 const   *)__p___5);
#line 961
    dev->cmd.dbell_offsets[i] = (u16 )tmp___15;
#line 961
    goto ldv_27854;
    case 8: 
#line 961
    tmp___16 = __be64_to_cpup((__be64 const   *)__p___5);
#line 961
    dev->cmd.dbell_offsets[i] = (u16 )tmp___16;
#line 961
    goto ldv_27854;
    default: 
#line 961
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27854: 
#line 960
    i = i + 1;
    ldv_27860: ;
#line 960
    if (i <= 7) {
#line 961
      goto ldv_27859;
    } else {
#line 963
      goto ldv_27861;
    }
    ldv_27861: 
#line 964
    mthca_setup_cmd_doorbells(dev, base);
  } else {

  }
#line 967
  tmp___29 = mthca_is_memfree(dev);
#line 967
  if (tmp___29 != 0) {
#line 968
    __p___6 = (void *)outbox;
#line 968
    switch (2UL) {
    case 1: 
#line 968
    dev->fw.arbel.fw_pages = (u16 )*((u8 *)__p___6);
#line 968
    goto ldv_27864;
    case 2: 
#line 968
    dev->fw.arbel.fw_pages = __be16_to_cpup((__be16 const   *)__p___6);
#line 968
    goto ldv_27864;
    case 4: 
#line 968
    tmp___17 = __be32_to_cpup((__be32 const   *)__p___6);
#line 968
    dev->fw.arbel.fw_pages = (u16 )tmp___17;
#line 968
    goto ldv_27864;
    case 8: 
#line 968
    tmp___18 = __be64_to_cpup((__be64 const   *)__p___6);
#line 968
    dev->fw.arbel.fw_pages = (u16 )tmp___18;
#line 968
    goto ldv_27864;
    default: 
#line 968
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27864: 
#line 969
    __p___7 = (void *)outbox + 32U;
#line 969
    switch (8UL) {
    case 1: 
#line 969
    dev->fw.arbel.clr_int_base = (u64 )*((u8 *)__p___7);
#line 969
    goto ldv_27871;
    case 2: 
#line 969
    tmp___19 = __be16_to_cpup((__be16 const   *)__p___7);
#line 969
    dev->fw.arbel.clr_int_base = (u64 )tmp___19;
#line 969
    goto ldv_27871;
    case 4: 
#line 969
    tmp___20 = __be32_to_cpup((__be32 const   *)__p___7);
#line 969
    dev->fw.arbel.clr_int_base = (u64 )tmp___20;
#line 969
    goto ldv_27871;
    case 8: 
#line 969
    dev->fw.arbel.clr_int_base = __be64_to_cpup((__be64 const   *)__p___7);
#line 969
    goto ldv_27871;
    default: 
#line 969
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27871: 
#line 970
    __p___8 = (void *)outbox + 64U;
#line 970
    switch (8UL) {
    case 1: 
#line 970
    dev->fw.arbel.eq_arm_base = (u64 )*((u8 *)__p___8);
#line 970
    goto ldv_27878;
    case 2: 
#line 970
    tmp___21 = __be16_to_cpup((__be16 const   *)__p___8);
#line 970
    dev->fw.arbel.eq_arm_base = (u64 )tmp___21;
#line 970
    goto ldv_27878;
    case 4: 
#line 970
    tmp___22 = __be32_to_cpup((__be32 const   *)__p___8);
#line 970
    dev->fw.arbel.eq_arm_base = (u64 )tmp___22;
#line 970
    goto ldv_27878;
    case 8: 
#line 970
    dev->fw.arbel.eq_arm_base = __be64_to_cpup((__be64 const   *)__p___8);
#line 970
    goto ldv_27878;
    default: 
#line 970
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27878: 
#line 971
    __p___9 = (void *)outbox + 72U;
#line 971
    switch (8UL) {
    case 1: 
#line 971
    dev->fw.arbel.eq_set_ci_base = (u64 )*((u8 *)__p___9);
#line 971
    goto ldv_27885;
    case 2: 
#line 971
    tmp___23 = __be16_to_cpup((__be16 const   *)__p___9);
#line 971
    dev->fw.arbel.eq_set_ci_base = (u64 )tmp___23;
#line 971
    goto ldv_27885;
    case 4: 
#line 971
    tmp___24 = __be32_to_cpup((__be32 const   *)__p___9);
#line 971
    dev->fw.arbel.eq_set_ci_base = (u64 )tmp___24;
#line 971
    goto ldv_27885;
    case 8: 
#line 971
    dev->fw.arbel.eq_set_ci_base = __be64_to_cpup((__be64 const   *)__p___9);
#line 971
    goto ldv_27885;
    default: 
#line 971
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27885: ;
#line 972
    if (mthca_debug_level != 0) {
#line 972
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW size %d KB\n",
                 (int )dev->fw.arbel.fw_pages << 2);
    } else {

    }
#line 978
    dev->fw.arbel.fw_pages = dev->fw.arbel.fw_pages;
#line 982
    if (mthca_debug_level != 0) {
#line 982
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Clear int @ %llx, EQ arm @ %llx, EQ set CI @ %llx\n",
                 dev->fw.arbel.clr_int_base, dev->fw.arbel.eq_arm_base, dev->fw.arbel.eq_set_ci_base);
    } else {

    }
  } else {
#line 987
    __p___10 = (void *)outbox + 32U;
#line 987
    switch (8UL) {
    case 1: 
#line 987
    dev->fw.tavor.fw_start = (u64 )*((u8 *)__p___10);
#line 987
    goto ldv_27892;
    case 2: 
#line 987
    tmp___25 = __be16_to_cpup((__be16 const   *)__p___10);
#line 987
    dev->fw.tavor.fw_start = (u64 )tmp___25;
#line 987
    goto ldv_27892;
    case 4: 
#line 987
    tmp___26 = __be32_to_cpup((__be32 const   *)__p___10);
#line 987
    dev->fw.tavor.fw_start = (u64 )tmp___26;
#line 987
    goto ldv_27892;
    case 8: 
#line 987
    dev->fw.tavor.fw_start = __be64_to_cpup((__be64 const   *)__p___10);
#line 987
    goto ldv_27892;
    default: 
#line 987
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27892: 
#line 988
    __p___11 = (void *)outbox + 40U;
#line 988
    switch (8UL) {
    case 1: 
#line 988
    dev->fw.tavor.fw_end = (u64 )*((u8 *)__p___11);
#line 988
    goto ldv_27899;
    case 2: 
#line 988
    tmp___27 = __be16_to_cpup((__be16 const   *)__p___11);
#line 988
    dev->fw.tavor.fw_end = (u64 )tmp___27;
#line 988
    goto ldv_27899;
    case 4: 
#line 988
    tmp___28 = __be32_to_cpup((__be32 const   *)__p___11);
#line 988
    dev->fw.tavor.fw_end = (u64 )tmp___28;
#line 988
    goto ldv_27899;
    case 8: 
#line 988
    dev->fw.tavor.fw_end = __be64_to_cpup((__be64 const   *)__p___11);
#line 988
    goto ldv_27899;
    default: 
#line 988
    __buggy_use_of_MTHCA_GET();
    }
    ldv_27899: ;
#line 990
    if (mthca_debug_level != 0) {
#line 990
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "FW size %d KB (start %llx, end %llx)\n",
                 (int )((dev->fw.tavor.fw_end - dev->fw.tavor.fw_start) >> 10), dev->fw.tavor.fw_start,
                 dev->fw.tavor.fw_end);
    } else {

    }
  }
  out: 
#line 997
  mthca_free_mailbox(dev, mailbox);
#line 998
  return (err);
}
}
#line 1001 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_ENABLE_LAM(struct mthca_dev *dev ) 
{ struct mthca_mailbox *mailbox ;
  u8 info ;
  u32 *outbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u32 tmp___6 ;
  __u64 tmp___7 ;
  char *tmp___8 ;

  {
#line 1006
  err = 0;
#line 1016
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1017
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1017
  if (tmp___0 != 0L) {
#line 1018
    tmp = PTR_ERR((void const   *)mailbox);
#line 1018
    return ((int )tmp);
  } else {

  }
#line 1019
  outbox = (u32 *)mailbox->buf;
#line 1021
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 4088, 15000UL);
#line 1024
  if (err != 0) {
#line 1025
    goto out;
  } else {

  }
#line 1027
  __p = (void *)outbox;
#line 1027
  switch (8UL) {
  case 1: 
#line 1027
  dev->ddr_start = (u64 )*((u8 *)__p);
#line 1027
  goto ldv_27914;
  case 2: 
#line 1027
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1027
  dev->ddr_start = (u64 )tmp___1;
#line 1027
  goto ldv_27914;
  case 4: 
#line 1027
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 1027
  dev->ddr_start = (u64 )tmp___2;
#line 1027
  goto ldv_27914;
  case 8: 
#line 1027
  dev->ddr_start = __be64_to_cpup((__be64 const   *)__p);
#line 1027
  goto ldv_27914;
  default: 
#line 1027
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27914: 
#line 1028
  __p___0 = (void *)outbox + 8U;
#line 1028
  switch (8UL) {
  case 1: 
#line 1028
  dev->ddr_end = (u64 )*((u8 *)__p___0);
#line 1028
  goto ldv_27921;
  case 2: 
#line 1028
  tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1028
  dev->ddr_end = (u64 )tmp___3;
#line 1028
  goto ldv_27921;
  case 4: 
#line 1028
  tmp___4 = __be32_to_cpup((__be32 const   *)__p___0);
#line 1028
  dev->ddr_end = (u64 )tmp___4;
#line 1028
  goto ldv_27921;
  case 8: 
#line 1028
  dev->ddr_end = __be64_to_cpup((__be64 const   *)__p___0);
#line 1028
  goto ldv_27921;
  default: 
#line 1028
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27921: 
#line 1029
  __p___1 = (void *)outbox + 19U;
#line 1029
  switch (1UL) {
  case 1: 
#line 1029
  info = *((u8 *)__p___1);
#line 1029
  goto ldv_27928;
  case 2: 
#line 1029
  tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1029
  info = (u8 )tmp___5;
#line 1029
  goto ldv_27928;
  case 4: 
#line 1029
  tmp___6 = __be32_to_cpup((__be32 const   *)__p___1);
#line 1029
  info = (u8 )tmp___6;
#line 1029
  goto ldv_27928;
  case 8: 
#line 1029
  tmp___7 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1029
  info = (u8 )tmp___7;
#line 1029
  goto ldv_27928;
  default: 
#line 1029
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27928: ;
#line 1031
  if ((((int )info & 16) != 0) ^ ((dev->mthca_flags & 2UL) != 0UL)) {
#line 1033
    if (((int )info & 16) != 0) {
#line 1033
      tmp___8 = (char *)"";
    } else {
#line 1033
      tmp___8 = (char *)"not";
    }
#line 1033
    _dev_info((struct device  const  *)(& (dev->pdev)->dev), "FW reports that HCA-attached memory is %s hidden; does not match PCI config\n",
              tmp___8);
  } else {

  }
#line 1038
  if (((int )info & 16) != 0) {
#line 1039
    if (mthca_debug_level != 0) {
#line 1039
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA-attached memory is hidden.\n");
    } else {

    }
  } else {

  }
#line 1041
  if (mthca_debug_level != 0) {
#line 1041
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory size %d KB (start %llx, end %llx)\n",
               (int )((dev->ddr_end - dev->ddr_start) >> 10), dev->ddr_start, dev->ddr_end);
  } else {

  }
  out: 
#line 1047
  mthca_free_mailbox(dev, mailbox);
#line 1048
  return (err);
}
}
#line 1051 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_DISABLE_LAM(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 1053
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 2, 15000UL);
#line 1053
  return (tmp);
}
}
#line 1056 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_DDR(struct mthca_dev *dev ) 
{ struct mthca_mailbox *mailbox ;
  u8 info ;
  u32 *outbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u32 tmp___6 ;
  __u64 tmp___7 ;
  char *tmp___8 ;

  {
#line 1061
  err = 0;
#line 1071
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1072
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1072
  if (tmp___0 != 0L) {
#line 1073
    tmp = PTR_ERR((void const   *)mailbox);
#line 1073
    return ((int )tmp);
  } else {

  }
#line 1074
  outbox = (u32 *)mailbox->buf;
#line 1076
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 5, 15000UL);
#line 1079
  if (err != 0) {
#line 1080
    goto out;
  } else {

  }
#line 1082
  __p = (void *)outbox;
#line 1082
  switch (8UL) {
  case 1: 
#line 1082
  dev->ddr_start = (u64 )*((u8 *)__p);
#line 1082
  goto ldv_27946;
  case 2: 
#line 1082
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1082
  dev->ddr_start = (u64 )tmp___1;
#line 1082
  goto ldv_27946;
  case 4: 
#line 1082
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 1082
  dev->ddr_start = (u64 )tmp___2;
#line 1082
  goto ldv_27946;
  case 8: 
#line 1082
  dev->ddr_start = __be64_to_cpup((__be64 const   *)__p);
#line 1082
  goto ldv_27946;
  default: 
#line 1082
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27946: 
#line 1083
  __p___0 = (void *)outbox + 8U;
#line 1083
  switch (8UL) {
  case 1: 
#line 1083
  dev->ddr_end = (u64 )*((u8 *)__p___0);
#line 1083
  goto ldv_27953;
  case 2: 
#line 1083
  tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1083
  dev->ddr_end = (u64 )tmp___3;
#line 1083
  goto ldv_27953;
  case 4: 
#line 1083
  tmp___4 = __be32_to_cpup((__be32 const   *)__p___0);
#line 1083
  dev->ddr_end = (u64 )tmp___4;
#line 1083
  goto ldv_27953;
  case 8: 
#line 1083
  dev->ddr_end = __be64_to_cpup((__be64 const   *)__p___0);
#line 1083
  goto ldv_27953;
  default: 
#line 1083
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27953: 
#line 1084
  __p___1 = (void *)outbox + 19U;
#line 1084
  switch (1UL) {
  case 1: 
#line 1084
  info = *((u8 *)__p___1);
#line 1084
  goto ldv_27960;
  case 2: 
#line 1084
  tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1084
  info = (u8 )tmp___5;
#line 1084
  goto ldv_27960;
  case 4: 
#line 1084
  tmp___6 = __be32_to_cpup((__be32 const   *)__p___1);
#line 1084
  info = (u8 )tmp___6;
#line 1084
  goto ldv_27960;
  case 8: 
#line 1084
  tmp___7 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1084
  info = (u8 )tmp___7;
#line 1084
  goto ldv_27960;
  default: 
#line 1084
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27960: ;
#line 1086
  if ((((int )info & 16) != 0) ^ ((dev->mthca_flags & 2UL) != 0UL)) {
#line 1088
    if (((int )info & 16) != 0) {
#line 1088
      tmp___8 = (char *)"";
    } else {
#line 1088
      tmp___8 = (char *)"not";
    }
#line 1088
    _dev_info((struct device  const  *)(& (dev->pdev)->dev), "FW reports that HCA-attached memory is %s hidden; does not match PCI config\n",
              tmp___8);
  } else {

  }
#line 1093
  if (((int )info & 16) != 0) {
#line 1094
    if (mthca_debug_level != 0) {
#line 1094
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA-attached memory is hidden.\n");
    } else {

    }
  } else {

  }
#line 1096
  if (mthca_debug_level != 0) {
#line 1096
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory size %d KB (start %llx, end %llx)\n",
               (int )((dev->ddr_end - dev->ddr_start) >> 10), dev->ddr_start, dev->ddr_end);
  } else {

  }
  out: 
#line 1102
  mthca_free_mailbox(dev, mailbox);
#line 1103
  return (err);
}
}
#line 1106 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_DEV_LIM(struct mthca_dev *dev , struct mthca_dev_lim *dev_lim ) 
{ struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  u8 field ;
  u16 size ;
  u16 stat_rate ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__p___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__p___1 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__p___2 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__p___3 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__p___4 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__p___5 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;
  void *__p___6 ;
  __u16 tmp___22 ;
  __u32 tmp___23 ;
  __u64 tmp___24 ;
  void *__p___7 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  __u64 tmp___27 ;
  void *__p___8 ;
  __u16 tmp___28 ;
  __u32 tmp___29 ;
  __u64 tmp___30 ;
  void *__p___9 ;
  __u16 tmp___31 ;
  __u32 tmp___32 ;
  __u64 tmp___33 ;
  void *__p___10 ;
  __u16 tmp___34 ;
  __u32 tmp___35 ;
  __u64 tmp___36 ;
  void *__p___11 ;
  __u16 tmp___37 ;
  __u32 tmp___38 ;
  __u64 tmp___39 ;
  int tmp___40 ;
  void *__p___12 ;
  __u16 tmp___41 ;
  __u32 tmp___42 ;
  __u64 tmp___43 ;
  void *__p___13 ;
  __u16 tmp___44 ;
  __u32 tmp___45 ;
  __u64 tmp___46 ;
  void *__p___14 ;
  __u16 tmp___47 ;
  __u32 tmp___48 ;
  __u64 tmp___49 ;
  void *__p___15 ;
  __u16 tmp___50 ;
  __u32 tmp___51 ;
  __u64 tmp___52 ;
  void *__p___16 ;
  __u16 tmp___53 ;
  __u32 tmp___54 ;
  __u64 tmp___55 ;
  void *__p___17 ;
  __u16 tmp___56 ;
  __u32 tmp___57 ;
  __u64 tmp___58 ;
  void *__p___18 ;
  __u16 tmp___59 ;
  __u32 tmp___60 ;
  __u64 tmp___61 ;
  void *__p___19 ;
  __u16 tmp___62 ;
  __u32 tmp___63 ;
  __u64 tmp___64 ;
  void *__p___20 ;
  __u16 tmp___65 ;
  __u32 tmp___66 ;
  __u64 tmp___67 ;
  void *__p___21 ;
  __u16 tmp___68 ;
  __u32 tmp___69 ;
  __u64 tmp___70 ;
  void *__p___22 ;
  __u32 tmp___71 ;
  __u64 tmp___72 ;
  void *__p___23 ;
  __u16 tmp___73 ;
  __u32 tmp___74 ;
  __u64 tmp___75 ;
  void *__p___24 ;
  __u16 tmp___76 ;
  __u64 tmp___77 ;
  void *__p___25 ;
  __u16 tmp___78 ;
  __u32 tmp___79 ;
  __u64 tmp___80 ;
  void *__p___26 ;
  __u16 tmp___81 ;
  __u32 tmp___82 ;
  __u64 tmp___83 ;
  void *__p___27 ;
  __u16 tmp___84 ;
  __u32 tmp___85 ;
  __u64 tmp___86 ;
  void *__p___28 ;
  __u16 tmp___87 ;
  __u32 tmp___88 ;
  __u64 tmp___89 ;
  void *__p___29 ;
  __u32 tmp___90 ;
  __u64 tmp___91 ;
  void *__p___30 ;
  __u16 tmp___92 ;
  __u32 tmp___93 ;
  __u64 tmp___94 ;
  void *__p___31 ;
  __u16 tmp___95 ;
  __u32 tmp___96 ;
  __u64 tmp___97 ;
  void *__p___32 ;
  __u16 tmp___98 ;
  __u32 tmp___99 ;
  __u64 tmp___100 ;
  void *__p___33 ;
  __u16 tmp___101 ;
  __u32 tmp___102 ;
  __u64 tmp___103 ;
  void *__p___34 ;
  __u16 tmp___104 ;
  __u32 tmp___105 ;
  __u64 tmp___106 ;
  void *__p___35 ;
  __u16 tmp___107 ;
  __u32 tmp___108 ;
  __u64 tmp___109 ;
  void *__p___36 ;
  __u16 tmp___110 ;
  __u32 tmp___111 ;
  __u64 tmp___112 ;
  void *__p___37 ;
  __u32 tmp___113 ;
  __u64 tmp___114 ;
  void *__p___38 ;
  __u32 tmp___115 ;
  __u64 tmp___116 ;
  void *__p___39 ;
  __u32 tmp___117 ;
  __u64 tmp___118 ;
  void *__p___40 ;
  __u32 tmp___119 ;
  __u64 tmp___120 ;
  void *__p___41 ;
  __u32 tmp___121 ;
  __u64 tmp___122 ;
  void *__p___42 ;
  __u32 tmp___123 ;
  __u64 tmp___124 ;
  void *__p___43 ;
  __u32 tmp___125 ;
  __u64 tmp___126 ;
  void *__p___44 ;
  __u32 tmp___127 ;
  __u64 tmp___128 ;
  void *__p___45 ;
  __u16 tmp___129 ;
  __u32 tmp___130 ;
  __u64 tmp___131 ;
  void *__p___46 ;
  __u16 tmp___132 ;
  __u32 tmp___133 ;
  __u64 tmp___134 ;
  void *__p___47 ;
  __u16 tmp___135 ;
  __u32 tmp___136 ;
  __u64 tmp___137 ;
  void *__p___48 ;
  __u16 tmp___138 ;
  __u32 tmp___139 ;
  __u64 tmp___140 ;
  int __min1 ;
  int __min2 ;
  int tmp___141 ;
  void *__p___49 ;
  __u32 tmp___142 ;
  __u64 tmp___143 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___144 ;
  void *__p___50 ;
  __u32 tmp___145 ;
  __u64 tmp___146 ;
  void *__p___51 ;
  __u16 tmp___147 ;
  __u32 tmp___148 ;
  __u64 tmp___149 ;
  void *__p___52 ;
  __u16 tmp___150 ;
  __u32 tmp___151 ;
  __u64 tmp___152 ;
  void *__p___53 ;
  __u16 tmp___153 ;
  __u64 tmp___154 ;
  void *__p___54 ;
  __u16 tmp___155 ;
  __u32 tmp___156 ;
  __u64 tmp___157 ;
  void *__p___55 ;
  __u16 tmp___158 ;
  __u32 tmp___159 ;
  void *__p___56 ;
  __u16 tmp___160 ;
  __u32 tmp___161 ;
  __u64 tmp___162 ;
  void *__p___57 ;
  __u16 tmp___163 ;
  __u32 tmp___164 ;
  __u64 tmp___165 ;
  void *__p___58 ;
  __u16 tmp___166 ;
  __u32 tmp___167 ;
  __u64 tmp___168 ;
  int tmp___169 ;

  {
#line 1177
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1178
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1178
  if (tmp___0 != 0L) {
#line 1179
    tmp = PTR_ERR((void const   *)mailbox);
#line 1179
    return ((int )tmp);
  } else {

  }
#line 1180
  outbox = (u32 *)mailbox->buf;
#line 1182
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 3, 15000UL);
#line 1185
  if (err != 0) {
#line 1186
    goto out;
  } else {

  }
#line 1188
  __p = (void *)outbox + 18U;
#line 1188
  switch (1UL) {
  case 1: 
#line 1188
  field = *((u8 *)__p);
#line 1188
  goto ldv_27978;
  case 2: 
#line 1188
  tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1188
  field = (u8 )tmp___1;
#line 1188
  goto ldv_27978;
  case 4: 
#line 1188
  tmp___2 = __be32_to_cpup((__be32 const   *)__p);
#line 1188
  field = (u8 )tmp___2;
#line 1188
  goto ldv_27978;
  case 8: 
#line 1188
  tmp___3 = __be64_to_cpup((__be64 const   *)__p);
#line 1188
  field = (u8 )tmp___3;
#line 1188
  goto ldv_27978;
  default: 
#line 1188
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27978: 
#line 1189
  dev_lim->reserved_qps = 1 << ((int )field & 15);
#line 1190
  __p___0 = (void *)outbox + 19U;
#line 1190
  switch (1UL) {
  case 1: 
#line 1190
  field = *((u8 *)__p___0);
#line 1190
  goto ldv_27985;
  case 2: 
#line 1190
  tmp___4 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1190
  field = (u8 )tmp___4;
#line 1190
  goto ldv_27985;
  case 4: 
#line 1190
  tmp___5 = __be32_to_cpup((__be32 const   *)__p___0);
#line 1190
  field = (u8 )tmp___5;
#line 1190
  goto ldv_27985;
  case 8: 
#line 1190
  tmp___6 = __be64_to_cpup((__be64 const   *)__p___0);
#line 1190
  field = (u8 )tmp___6;
#line 1190
  goto ldv_27985;
  default: 
#line 1190
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27985: 
#line 1191
  dev_lim->max_qps = 1 << ((int )field & 31);
#line 1192
  __p___1 = (void *)outbox + 20U;
#line 1192
  switch (1UL) {
  case 1: 
#line 1192
  field = *((u8 *)__p___1);
#line 1192
  goto ldv_27992;
  case 2: 
#line 1192
  tmp___7 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1192
  field = (u8 )tmp___7;
#line 1192
  goto ldv_27992;
  case 4: 
#line 1192
  tmp___8 = __be32_to_cpup((__be32 const   *)__p___1);
#line 1192
  field = (u8 )tmp___8;
#line 1192
  goto ldv_27992;
  case 8: 
#line 1192
  tmp___9 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1192
  field = (u8 )tmp___9;
#line 1192
  goto ldv_27992;
  default: 
#line 1192
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27992: 
#line 1193
  dev_lim->reserved_srqs = 1 << ((int )field >> 4);
#line 1194
  __p___2 = (void *)outbox + 21U;
#line 1194
  switch (1UL) {
  case 1: 
#line 1194
  field = *((u8 *)__p___2);
#line 1194
  goto ldv_27999;
  case 2: 
#line 1194
  tmp___10 = __be16_to_cpup((__be16 const   *)__p___2);
#line 1194
  field = (u8 )tmp___10;
#line 1194
  goto ldv_27999;
  case 4: 
#line 1194
  tmp___11 = __be32_to_cpup((__be32 const   *)__p___2);
#line 1194
  field = (u8 )tmp___11;
#line 1194
  goto ldv_27999;
  case 8: 
#line 1194
  tmp___12 = __be64_to_cpup((__be64 const   *)__p___2);
#line 1194
  field = (u8 )tmp___12;
#line 1194
  goto ldv_27999;
  default: 
#line 1194
  __buggy_use_of_MTHCA_GET();
  }
  ldv_27999: 
#line 1195
  dev_lim->max_srqs = 1 << ((int )field & 31);
#line 1196
  __p___3 = (void *)outbox + 22U;
#line 1196
  switch (1UL) {
  case 1: 
#line 1196
  field = *((u8 *)__p___3);
#line 1196
  goto ldv_28006;
  case 2: 
#line 1196
  tmp___13 = __be16_to_cpup((__be16 const   *)__p___3);
#line 1196
  field = (u8 )tmp___13;
#line 1196
  goto ldv_28006;
  case 4: 
#line 1196
  tmp___14 = __be32_to_cpup((__be32 const   *)__p___3);
#line 1196
  field = (u8 )tmp___14;
#line 1196
  goto ldv_28006;
  case 8: 
#line 1196
  tmp___15 = __be64_to_cpup((__be64 const   *)__p___3);
#line 1196
  field = (u8 )tmp___15;
#line 1196
  goto ldv_28006;
  default: 
#line 1196
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28006: 
#line 1197
  dev_lim->reserved_eecs = 1 << ((int )field & 15);
#line 1198
  __p___4 = (void *)outbox + 23U;
#line 1198
  switch (1UL) {
  case 1: 
#line 1198
  field = *((u8 *)__p___4);
#line 1198
  goto ldv_28013;
  case 2: 
#line 1198
  tmp___16 = __be16_to_cpup((__be16 const   *)__p___4);
#line 1198
  field = (u8 )tmp___16;
#line 1198
  goto ldv_28013;
  case 4: 
#line 1198
  tmp___17 = __be32_to_cpup((__be32 const   *)__p___4);
#line 1198
  field = (u8 )tmp___17;
#line 1198
  goto ldv_28013;
  case 8: 
#line 1198
  tmp___18 = __be64_to_cpup((__be64 const   *)__p___4);
#line 1198
  field = (u8 )tmp___18;
#line 1198
  goto ldv_28013;
  default: 
#line 1198
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28013: 
#line 1199
  dev_lim->max_eecs = 1 << ((int )field & 31);
#line 1200
  __p___5 = (void *)outbox + 25U;
#line 1200
  switch (1UL) {
  case 1: 
#line 1200
  field = *((u8 *)__p___5);
#line 1200
  goto ldv_28020;
  case 2: 
#line 1200
  tmp___19 = __be16_to_cpup((__be16 const   *)__p___5);
#line 1200
  field = (u8 )tmp___19;
#line 1200
  goto ldv_28020;
  case 4: 
#line 1200
  tmp___20 = __be32_to_cpup((__be32 const   *)__p___5);
#line 1200
  field = (u8 )tmp___20;
#line 1200
  goto ldv_28020;
  case 8: 
#line 1200
  tmp___21 = __be64_to_cpup((__be64 const   *)__p___5);
#line 1200
  field = (u8 )tmp___21;
#line 1200
  goto ldv_28020;
  default: 
#line 1200
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28020: 
#line 1201
  dev_lim->max_cq_sz = 1 << (int )field;
#line 1202
  __p___6 = (void *)outbox + 26U;
#line 1202
  switch (1UL) {
  case 1: 
#line 1202
  field = *((u8 *)__p___6);
#line 1202
  goto ldv_28027;
  case 2: 
#line 1202
  tmp___22 = __be16_to_cpup((__be16 const   *)__p___6);
#line 1202
  field = (u8 )tmp___22;
#line 1202
  goto ldv_28027;
  case 4: 
#line 1202
  tmp___23 = __be32_to_cpup((__be32 const   *)__p___6);
#line 1202
  field = (u8 )tmp___23;
#line 1202
  goto ldv_28027;
  case 8: 
#line 1202
  tmp___24 = __be64_to_cpup((__be64 const   *)__p___6);
#line 1202
  field = (u8 )tmp___24;
#line 1202
  goto ldv_28027;
  default: 
#line 1202
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28027: 
#line 1203
  dev_lim->reserved_cqs = 1 << ((int )field & 15);
#line 1204
  __p___7 = (void *)outbox + 27U;
#line 1204
  switch (1UL) {
  case 1: 
#line 1204
  field = *((u8 *)__p___7);
#line 1204
  goto ldv_28034;
  case 2: 
#line 1204
  tmp___25 = __be16_to_cpup((__be16 const   *)__p___7);
#line 1204
  field = (u8 )tmp___25;
#line 1204
  goto ldv_28034;
  case 4: 
#line 1204
  tmp___26 = __be32_to_cpup((__be32 const   *)__p___7);
#line 1204
  field = (u8 )tmp___26;
#line 1204
  goto ldv_28034;
  case 8: 
#line 1204
  tmp___27 = __be64_to_cpup((__be64 const   *)__p___7);
#line 1204
  field = (u8 )tmp___27;
#line 1204
  goto ldv_28034;
  default: 
#line 1204
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28034: 
#line 1205
  dev_lim->max_cqs = 1 << ((int )field & 31);
#line 1206
  __p___8 = (void *)outbox + 29U;
#line 1206
  switch (1UL) {
  case 1: 
#line 1206
  field = *((u8 *)__p___8);
#line 1206
  goto ldv_28041;
  case 2: 
#line 1206
  tmp___28 = __be16_to_cpup((__be16 const   *)__p___8);
#line 1206
  field = (u8 )tmp___28;
#line 1206
  goto ldv_28041;
  case 4: 
#line 1206
  tmp___29 = __be32_to_cpup((__be32 const   *)__p___8);
#line 1206
  field = (u8 )tmp___29;
#line 1206
  goto ldv_28041;
  case 8: 
#line 1206
  tmp___30 = __be64_to_cpup((__be64 const   *)__p___8);
#line 1206
  field = (u8 )tmp___30;
#line 1206
  goto ldv_28041;
  default: 
#line 1206
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28041: 
#line 1207
  dev_lim->max_mpts = 1 << ((int )field & 63);
#line 1208
  __p___9 = (void *)outbox + 30U;
#line 1208
  switch (1UL) {
  case 1: 
#line 1208
  field = *((u8 *)__p___9);
#line 1208
  goto ldv_28048;
  case 2: 
#line 1208
  tmp___31 = __be16_to_cpup((__be16 const   *)__p___9);
#line 1208
  field = (u8 )tmp___31;
#line 1208
  goto ldv_28048;
  case 4: 
#line 1208
  tmp___32 = __be32_to_cpup((__be32 const   *)__p___9);
#line 1208
  field = (u8 )tmp___32;
#line 1208
  goto ldv_28048;
  case 8: 
#line 1208
  tmp___33 = __be64_to_cpup((__be64 const   *)__p___9);
#line 1208
  field = (u8 )tmp___33;
#line 1208
  goto ldv_28048;
  default: 
#line 1208
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28048: 
#line 1209
  dev_lim->reserved_eqs = 1 << ((int )field & 15);
#line 1210
  __p___10 = (void *)outbox + 31U;
#line 1210
  switch (1UL) {
  case 1: 
#line 1210
  field = *((u8 *)__p___10);
#line 1210
  goto ldv_28055;
  case 2: 
#line 1210
  tmp___34 = __be16_to_cpup((__be16 const   *)__p___10);
#line 1210
  field = (u8 )tmp___34;
#line 1210
  goto ldv_28055;
  case 4: 
#line 1210
  tmp___35 = __be32_to_cpup((__be32 const   *)__p___10);
#line 1210
  field = (u8 )tmp___35;
#line 1210
  goto ldv_28055;
  case 8: 
#line 1210
  tmp___36 = __be64_to_cpup((__be64 const   *)__p___10);
#line 1210
  field = (u8 )tmp___36;
#line 1210
  goto ldv_28055;
  default: 
#line 1210
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28055: 
#line 1211
  dev_lim->max_eqs = 1 << ((int )field & 7);
#line 1212
  __p___11 = (void *)outbox + 32U;
#line 1212
  switch (1UL) {
  case 1: 
#line 1212
  field = *((u8 *)__p___11);
#line 1212
  goto ldv_28062;
  case 2: 
#line 1212
  tmp___37 = __be16_to_cpup((__be16 const   *)__p___11);
#line 1212
  field = (u8 )tmp___37;
#line 1212
  goto ldv_28062;
  case 4: 
#line 1212
  tmp___38 = __be32_to_cpup((__be32 const   *)__p___11);
#line 1212
  field = (u8 )tmp___38;
#line 1212
  goto ldv_28062;
  case 8: 
#line 1212
  tmp___39 = __be64_to_cpup((__be64 const   *)__p___11);
#line 1212
  field = (u8 )tmp___39;
#line 1212
  goto ldv_28062;
  default: 
#line 1212
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28062: 
#line 1213
  tmp___40 = mthca_is_memfree(dev);
#line 1213
  if (tmp___40 != 0) {
#line 1214
    dev_lim->reserved_mtts = (int )(((((unsigned long )(1 << ((int )field >> 4)) * 8UL + (unsigned long )dev->limits.mtt_seg_size) - 1UL) & - ((unsigned long )dev->limits.mtt_seg_size)) / (unsigned long )dev->limits.mtt_seg_size);
  } else {
#line 1217
    dev_lim->reserved_mtts = 1 << ((int )field >> 4);
  }
#line 1218
  __p___12 = (void *)outbox + 33U;
#line 1218
  switch (1UL) {
  case 1: 
#line 1218
  field = *((u8 *)__p___12);
#line 1218
  goto ldv_28069;
  case 2: 
#line 1218
  tmp___41 = __be16_to_cpup((__be16 const   *)__p___12);
#line 1218
  field = (u8 )tmp___41;
#line 1218
  goto ldv_28069;
  case 4: 
#line 1218
  tmp___42 = __be32_to_cpup((__be32 const   *)__p___12);
#line 1218
  field = (u8 )tmp___42;
#line 1218
  goto ldv_28069;
  case 8: 
#line 1218
  tmp___43 = __be64_to_cpup((__be64 const   *)__p___12);
#line 1218
  field = (u8 )tmp___43;
#line 1218
  goto ldv_28069;
  default: 
#line 1218
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28069: 
#line 1219
  dev_lim->max_mrw_sz = 1 << (int )field;
#line 1220
  __p___13 = (void *)outbox + 34U;
#line 1220
  switch (1UL) {
  case 1: 
#line 1220
  field = *((u8 *)__p___13);
#line 1220
  goto ldv_28076;
  case 2: 
#line 1220
  tmp___44 = __be16_to_cpup((__be16 const   *)__p___13);
#line 1220
  field = (u8 )tmp___44;
#line 1220
  goto ldv_28076;
  case 4: 
#line 1220
  tmp___45 = __be32_to_cpup((__be32 const   *)__p___13);
#line 1220
  field = (u8 )tmp___45;
#line 1220
  goto ldv_28076;
  case 8: 
#line 1220
  tmp___46 = __be64_to_cpup((__be64 const   *)__p___13);
#line 1220
  field = (u8 )tmp___46;
#line 1220
  goto ldv_28076;
  default: 
#line 1220
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28076: 
#line 1221
  dev_lim->reserved_mrws = 1 << ((int )field & 15);
#line 1222
  __p___14 = (void *)outbox + 35U;
#line 1222
  switch (1UL) {
  case 1: 
#line 1222
  field = *((u8 *)__p___14);
#line 1222
  goto ldv_28083;
  case 2: 
#line 1222
  tmp___47 = __be16_to_cpup((__be16 const   *)__p___14);
#line 1222
  field = (u8 )tmp___47;
#line 1222
  goto ldv_28083;
  case 4: 
#line 1222
  tmp___48 = __be32_to_cpup((__be32 const   *)__p___14);
#line 1222
  field = (u8 )tmp___48;
#line 1222
  goto ldv_28083;
  case 8: 
#line 1222
  tmp___49 = __be64_to_cpup((__be64 const   *)__p___14);
#line 1222
  field = (u8 )tmp___49;
#line 1222
  goto ldv_28083;
  default: 
#line 1222
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28083: 
#line 1223
  dev_lim->max_mtt_seg = 1 << ((int )field & 63);
#line 1224
  __p___15 = (void *)outbox + 41U;
#line 1224
  switch (1UL) {
  case 1: 
#line 1224
  field = *((u8 *)__p___15);
#line 1224
  goto ldv_28090;
  case 2: 
#line 1224
  tmp___50 = __be16_to_cpup((__be16 const   *)__p___15);
#line 1224
  field = (u8 )tmp___50;
#line 1224
  goto ldv_28090;
  case 4: 
#line 1224
  tmp___51 = __be32_to_cpup((__be32 const   *)__p___15);
#line 1224
  field = (u8 )tmp___51;
#line 1224
  goto ldv_28090;
  case 8: 
#line 1224
  tmp___52 = __be64_to_cpup((__be64 const   *)__p___15);
#line 1224
  field = (u8 )tmp___52;
#line 1224
  goto ldv_28090;
  default: 
#line 1224
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28090: 
#line 1225
  dev_lim->max_requester_per_qp = 1 << ((int )field & 63);
#line 1226
  __p___16 = (void *)outbox + 43U;
#line 1226
  switch (1UL) {
  case 1: 
#line 1226
  field = *((u8 *)__p___16);
#line 1226
  goto ldv_28097;
  case 2: 
#line 1226
  tmp___53 = __be16_to_cpup((__be16 const   *)__p___16);
#line 1226
  field = (u8 )tmp___53;
#line 1226
  goto ldv_28097;
  case 4: 
#line 1226
  tmp___54 = __be32_to_cpup((__be32 const   *)__p___16);
#line 1226
  field = (u8 )tmp___54;
#line 1226
  goto ldv_28097;
  case 8: 
#line 1226
  tmp___55 = __be64_to_cpup((__be64 const   *)__p___16);
#line 1226
  field = (u8 )tmp___55;
#line 1226
  goto ldv_28097;
  default: 
#line 1226
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28097: 
#line 1227
  dev_lim->max_responder_per_qp = 1 << ((int )field & 63);
#line 1228
  __p___17 = (void *)outbox + 47U;
#line 1228
  switch (1UL) {
  case 1: 
#line 1228
  field = *((u8 *)__p___17);
#line 1228
  goto ldv_28104;
  case 2: 
#line 1228
  tmp___56 = __be16_to_cpup((__be16 const   *)__p___17);
#line 1228
  field = (u8 )tmp___56;
#line 1228
  goto ldv_28104;
  case 4: 
#line 1228
  tmp___57 = __be32_to_cpup((__be32 const   *)__p___17);
#line 1228
  field = (u8 )tmp___57;
#line 1228
  goto ldv_28104;
  case 8: 
#line 1228
  tmp___58 = __be64_to_cpup((__be64 const   *)__p___17);
#line 1228
  field = (u8 )tmp___58;
#line 1228
  goto ldv_28104;
  default: 
#line 1228
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28104: 
#line 1229
  dev_lim->max_rdma_global = 1 << ((int )field & 63);
#line 1230
  __p___18 = (void *)outbox + 53U;
#line 1230
  switch (1UL) {
  case 1: 
#line 1230
  field = *((u8 *)__p___18);
#line 1230
  goto ldv_28111;
  case 2: 
#line 1230
  tmp___59 = __be16_to_cpup((__be16 const   *)__p___18);
#line 1230
  field = (u8 )tmp___59;
#line 1230
  goto ldv_28111;
  case 4: 
#line 1230
  tmp___60 = __be32_to_cpup((__be32 const   *)__p___18);
#line 1230
  field = (u8 )tmp___60;
#line 1230
  goto ldv_28111;
  case 8: 
#line 1230
  tmp___61 = __be64_to_cpup((__be64 const   *)__p___18);
#line 1230
  field = (u8 )tmp___61;
#line 1230
  goto ldv_28111;
  default: 
#line 1230
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28111: 
#line 1231
  dev_lim->local_ca_ack_delay = (int )field & 31;
#line 1232
  __p___19 = (void *)outbox + 54U;
#line 1232
  switch (1UL) {
  case 1: 
#line 1232
  field = *((u8 *)__p___19);
#line 1232
  goto ldv_28118;
  case 2: 
#line 1232
  tmp___62 = __be16_to_cpup((__be16 const   *)__p___19);
#line 1232
  field = (u8 )tmp___62;
#line 1232
  goto ldv_28118;
  case 4: 
#line 1232
  tmp___63 = __be32_to_cpup((__be32 const   *)__p___19);
#line 1232
  field = (u8 )tmp___63;
#line 1232
  goto ldv_28118;
  case 8: 
#line 1232
  tmp___64 = __be64_to_cpup((__be64 const   *)__p___19);
#line 1232
  field = (u8 )tmp___64;
#line 1232
  goto ldv_28118;
  default: 
#line 1232
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28118: 
#line 1233
  dev_lim->max_mtu = (int )field >> 4;
#line 1234
  dev_lim->max_port_width = (int )field & 15;
#line 1235
  __p___20 = (void *)outbox + 55U;
#line 1235
  switch (1UL) {
  case 1: 
#line 1235
  field = *((u8 *)__p___20);
#line 1235
  goto ldv_28125;
  case 2: 
#line 1235
  tmp___65 = __be16_to_cpup((__be16 const   *)__p___20);
#line 1235
  field = (u8 )tmp___65;
#line 1235
  goto ldv_28125;
  case 4: 
#line 1235
  tmp___66 = __be32_to_cpup((__be32 const   *)__p___20);
#line 1235
  field = (u8 )tmp___66;
#line 1235
  goto ldv_28125;
  case 8: 
#line 1235
  tmp___67 = __be64_to_cpup((__be64 const   *)__p___20);
#line 1235
  field = (u8 )tmp___67;
#line 1235
  goto ldv_28125;
  default: 
#line 1235
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28125: 
#line 1236
  dev_lim->max_vl = (int )field >> 4;
#line 1237
  dev_lim->num_ports = (int )field & 15;
#line 1238
  __p___21 = (void *)outbox + 59U;
#line 1238
  switch (1UL) {
  case 1: 
#line 1238
  field = *((u8 *)__p___21);
#line 1238
  goto ldv_28132;
  case 2: 
#line 1238
  tmp___68 = __be16_to_cpup((__be16 const   *)__p___21);
#line 1238
  field = (u8 )tmp___68;
#line 1238
  goto ldv_28132;
  case 4: 
#line 1238
  tmp___69 = __be32_to_cpup((__be32 const   *)__p___21);
#line 1238
  field = (u8 )tmp___69;
#line 1238
  goto ldv_28132;
  case 8: 
#line 1238
  tmp___70 = __be64_to_cpup((__be64 const   *)__p___21);
#line 1238
  field = (u8 )tmp___70;
#line 1238
  goto ldv_28132;
  default: 
#line 1238
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28132: 
#line 1239
  dev_lim->max_gids = 1 << ((int )field & 15);
#line 1240
  __p___22 = (void *)outbox + 60U;
#line 1240
  switch (2UL) {
  case 1: 
#line 1240
  stat_rate = (u16 )*((u8 *)__p___22);
#line 1240
  goto ldv_28139;
  case 2: 
#line 1240
  stat_rate = __be16_to_cpup((__be16 const   *)__p___22);
#line 1240
  goto ldv_28139;
  case 4: 
#line 1240
  tmp___71 = __be32_to_cpup((__be32 const   *)__p___22);
#line 1240
  stat_rate = (u16 )tmp___71;
#line 1240
  goto ldv_28139;
  case 8: 
#line 1240
  tmp___72 = __be64_to_cpup((__be64 const   *)__p___22);
#line 1240
  stat_rate = (u16 )tmp___72;
#line 1240
  goto ldv_28139;
  default: 
#line 1240
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28139: 
#line 1241
  dev_lim->stat_rate_support = stat_rate;
#line 1242
  __p___23 = (void *)outbox + 63U;
#line 1242
  switch (1UL) {
  case 1: 
#line 1242
  field = *((u8 *)__p___23);
#line 1242
  goto ldv_28146;
  case 2: 
#line 1242
  tmp___73 = __be16_to_cpup((__be16 const   *)__p___23);
#line 1242
  field = (u8 )tmp___73;
#line 1242
  goto ldv_28146;
  case 4: 
#line 1242
  tmp___74 = __be32_to_cpup((__be32 const   *)__p___23);
#line 1242
  field = (u8 )tmp___74;
#line 1242
  goto ldv_28146;
  case 8: 
#line 1242
  tmp___75 = __be64_to_cpup((__be64 const   *)__p___23);
#line 1242
  field = (u8 )tmp___75;
#line 1242
  goto ldv_28146;
  default: 
#line 1242
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28146: 
#line 1243
  dev_lim->max_pkeys = 1 << ((int )field & 15);
#line 1244
  __p___24 = (void *)outbox + 68U;
#line 1244
  switch (4UL) {
  case 1: 
#line 1244
  dev_lim->flags = (u32 )*((u8 *)__p___24);
#line 1244
  goto ldv_28153;
  case 2: 
#line 1244
  tmp___76 = __be16_to_cpup((__be16 const   *)__p___24);
#line 1244
  dev_lim->flags = (u32 )tmp___76;
#line 1244
  goto ldv_28153;
  case 4: 
#line 1244
  dev_lim->flags = __be32_to_cpup((__be32 const   *)__p___24);
#line 1244
  goto ldv_28153;
  case 8: 
#line 1244
  tmp___77 = __be64_to_cpup((__be64 const   *)__p___24);
#line 1244
  dev_lim->flags = (u32 )tmp___77;
#line 1244
  goto ldv_28153;
  default: 
#line 1244
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28153: 
#line 1245
  __p___25 = (void *)outbox + 72U;
#line 1245
  switch (1UL) {
  case 1: 
#line 1245
  field = *((u8 *)__p___25);
#line 1245
  goto ldv_28160;
  case 2: 
#line 1245
  tmp___78 = __be16_to_cpup((__be16 const   *)__p___25);
#line 1245
  field = (u8 )tmp___78;
#line 1245
  goto ldv_28160;
  case 4: 
#line 1245
  tmp___79 = __be32_to_cpup((__be32 const   *)__p___25);
#line 1245
  field = (u8 )tmp___79;
#line 1245
  goto ldv_28160;
  case 8: 
#line 1245
  tmp___80 = __be64_to_cpup((__be64 const   *)__p___25);
#line 1245
  field = (u8 )tmp___80;
#line 1245
  goto ldv_28160;
  default: 
#line 1245
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28160: 
#line 1246
  dev_lim->reserved_uars = (int )field >> 4;
#line 1247
  __p___26 = (void *)outbox + 73U;
#line 1247
  switch (1UL) {
  case 1: 
#line 1247
  field = *((u8 *)__p___26);
#line 1247
  goto ldv_28167;
  case 2: 
#line 1247
  tmp___81 = __be16_to_cpup((__be16 const   *)__p___26);
#line 1247
  field = (u8 )tmp___81;
#line 1247
  goto ldv_28167;
  case 4: 
#line 1247
  tmp___82 = __be32_to_cpup((__be32 const   *)__p___26);
#line 1247
  field = (u8 )tmp___82;
#line 1247
  goto ldv_28167;
  case 8: 
#line 1247
  tmp___83 = __be64_to_cpup((__be64 const   *)__p___26);
#line 1247
  field = (u8 )tmp___83;
#line 1247
  goto ldv_28167;
  default: 
#line 1247
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28167: 
#line 1248
  dev_lim->uar_size = 1 << (((int )field & 63) + 20);
#line 1249
  __p___27 = (void *)outbox + 75U;
#line 1249
  switch (1UL) {
  case 1: 
#line 1249
  field = *((u8 *)__p___27);
#line 1249
  goto ldv_28174;
  case 2: 
#line 1249
  tmp___84 = __be16_to_cpup((__be16 const   *)__p___27);
#line 1249
  field = (u8 )tmp___84;
#line 1249
  goto ldv_28174;
  case 4: 
#line 1249
  tmp___85 = __be32_to_cpup((__be32 const   *)__p___27);
#line 1249
  field = (u8 )tmp___85;
#line 1249
  goto ldv_28174;
  case 8: 
#line 1249
  tmp___86 = __be64_to_cpup((__be64 const   *)__p___27);
#line 1249
  field = (u8 )tmp___86;
#line 1249
  goto ldv_28174;
  default: 
#line 1249
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28174: 
#line 1250
  dev_lim->min_page_sz = 1 << (int )field;
#line 1251
  __p___28 = (void *)outbox + 81U;
#line 1251
  switch (1UL) {
  case 1: 
#line 1251
  field = *((u8 *)__p___28);
#line 1251
  goto ldv_28181;
  case 2: 
#line 1251
  tmp___87 = __be16_to_cpup((__be16 const   *)__p___28);
#line 1251
  field = (u8 )tmp___87;
#line 1251
  goto ldv_28181;
  case 4: 
#line 1251
  tmp___88 = __be32_to_cpup((__be32 const   *)__p___28);
#line 1251
  field = (u8 )tmp___88;
#line 1251
  goto ldv_28181;
  case 8: 
#line 1251
  tmp___89 = __be64_to_cpup((__be64 const   *)__p___28);
#line 1251
  field = (u8 )tmp___89;
#line 1251
  goto ldv_28181;
  default: 
#line 1251
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28181: 
#line 1252
  dev_lim->max_sg = (int )field;
#line 1254
  __p___29 = (void *)outbox + 82U;
#line 1254
  switch (2UL) {
  case 1: 
#line 1254
  size = (u16 )*((u8 *)__p___29);
#line 1254
  goto ldv_28188;
  case 2: 
#line 1254
  size = __be16_to_cpup((__be16 const   *)__p___29);
#line 1254
  goto ldv_28188;
  case 4: 
#line 1254
  tmp___90 = __be32_to_cpup((__be32 const   *)__p___29);
#line 1254
  size = (u16 )tmp___90;
#line 1254
  goto ldv_28188;
  case 8: 
#line 1254
  tmp___91 = __be64_to_cpup((__be64 const   *)__p___29);
#line 1254
  size = (u16 )tmp___91;
#line 1254
  goto ldv_28188;
  default: 
#line 1254
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28188: 
#line 1255
  dev_lim->max_desc_sz = (int )size;
#line 1257
  __p___30 = (void *)outbox + 97U;
#line 1257
  switch (1UL) {
  case 1: 
#line 1257
  field = *((u8 *)__p___30);
#line 1257
  goto ldv_28195;
  case 2: 
#line 1257
  tmp___92 = __be16_to_cpup((__be16 const   *)__p___30);
#line 1257
  field = (u8 )tmp___92;
#line 1257
  goto ldv_28195;
  case 4: 
#line 1257
  tmp___93 = __be32_to_cpup((__be32 const   *)__p___30);
#line 1257
  field = (u8 )tmp___93;
#line 1257
  goto ldv_28195;
  case 8: 
#line 1257
  tmp___94 = __be64_to_cpup((__be64 const   *)__p___30);
#line 1257
  field = (u8 )tmp___94;
#line 1257
  goto ldv_28195;
  default: 
#line 1257
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28195: 
#line 1258
  dev_lim->max_qp_per_mcg = 1 << (int )field;
#line 1259
  __p___31 = (void *)outbox + 98U;
#line 1259
  switch (1UL) {
  case 1: 
#line 1259
  field = *((u8 *)__p___31);
#line 1259
  goto ldv_28202;
  case 2: 
#line 1259
  tmp___95 = __be16_to_cpup((__be16 const   *)__p___31);
#line 1259
  field = (u8 )tmp___95;
#line 1259
  goto ldv_28202;
  case 4: 
#line 1259
  tmp___96 = __be32_to_cpup((__be32 const   *)__p___31);
#line 1259
  field = (u8 )tmp___96;
#line 1259
  goto ldv_28202;
  case 8: 
#line 1259
  tmp___97 = __be64_to_cpup((__be64 const   *)__p___31);
#line 1259
  field = (u8 )tmp___97;
#line 1259
  goto ldv_28202;
  default: 
#line 1259
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28202: 
#line 1260
  dev_lim->reserved_mgms = (int )field & 15;
#line 1261
  __p___32 = (void *)outbox + 99U;
#line 1261
  switch (1UL) {
  case 1: 
#line 1261
  field = *((u8 *)__p___32);
#line 1261
  goto ldv_28209;
  case 2: 
#line 1261
  tmp___98 = __be16_to_cpup((__be16 const   *)__p___32);
#line 1261
  field = (u8 )tmp___98;
#line 1261
  goto ldv_28209;
  case 4: 
#line 1261
  tmp___99 = __be32_to_cpup((__be32 const   *)__p___32);
#line 1261
  field = (u8 )tmp___99;
#line 1261
  goto ldv_28209;
  case 8: 
#line 1261
  tmp___100 = __be64_to_cpup((__be64 const   *)__p___32);
#line 1261
  field = (u8 )tmp___100;
#line 1261
  goto ldv_28209;
  default: 
#line 1261
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28209: 
#line 1262
  dev_lim->max_mcgs = 1 << (int )field;
#line 1263
  __p___33 = (void *)outbox + 100U;
#line 1263
  switch (1UL) {
  case 1: 
#line 1263
  field = *((u8 *)__p___33);
#line 1263
  goto ldv_28216;
  case 2: 
#line 1263
  tmp___101 = __be16_to_cpup((__be16 const   *)__p___33);
#line 1263
  field = (u8 )tmp___101;
#line 1263
  goto ldv_28216;
  case 4: 
#line 1263
  tmp___102 = __be32_to_cpup((__be32 const   *)__p___33);
#line 1263
  field = (u8 )tmp___102;
#line 1263
  goto ldv_28216;
  case 8: 
#line 1263
  tmp___103 = __be64_to_cpup((__be64 const   *)__p___33);
#line 1263
  field = (u8 )tmp___103;
#line 1263
  goto ldv_28216;
  default: 
#line 1263
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28216: 
#line 1264
  dev_lim->reserved_pds = (int )field >> 4;
#line 1265
  __p___34 = (void *)outbox + 101U;
#line 1265
  switch (1UL) {
  case 1: 
#line 1265
  field = *((u8 *)__p___34);
#line 1265
  goto ldv_28223;
  case 2: 
#line 1265
  tmp___104 = __be16_to_cpup((__be16 const   *)__p___34);
#line 1265
  field = (u8 )tmp___104;
#line 1265
  goto ldv_28223;
  case 4: 
#line 1265
  tmp___105 = __be32_to_cpup((__be32 const   *)__p___34);
#line 1265
  field = (u8 )tmp___105;
#line 1265
  goto ldv_28223;
  case 8: 
#line 1265
  tmp___106 = __be64_to_cpup((__be64 const   *)__p___34);
#line 1265
  field = (u8 )tmp___106;
#line 1265
  goto ldv_28223;
  default: 
#line 1265
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28223: 
#line 1266
  dev_lim->max_pds = 1 << ((int )field & 63);
#line 1267
  __p___35 = (void *)outbox + 102U;
#line 1267
  switch (1UL) {
  case 1: 
#line 1267
  field = *((u8 *)__p___35);
#line 1267
  goto ldv_28230;
  case 2: 
#line 1267
  tmp___107 = __be16_to_cpup((__be16 const   *)__p___35);
#line 1267
  field = (u8 )tmp___107;
#line 1267
  goto ldv_28230;
  case 4: 
#line 1267
  tmp___108 = __be32_to_cpup((__be32 const   *)__p___35);
#line 1267
  field = (u8 )tmp___108;
#line 1267
  goto ldv_28230;
  case 8: 
#line 1267
  tmp___109 = __be64_to_cpup((__be64 const   *)__p___35);
#line 1267
  field = (u8 )tmp___109;
#line 1267
  goto ldv_28230;
  default: 
#line 1267
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28230: 
#line 1268
  dev_lim->reserved_rdds = (int )field >> 4;
#line 1269
  __p___36 = (void *)outbox + 103U;
#line 1269
  switch (1UL) {
  case 1: 
#line 1269
  field = *((u8 *)__p___36);
#line 1269
  goto ldv_28237;
  case 2: 
#line 1269
  tmp___110 = __be16_to_cpup((__be16 const   *)__p___36);
#line 1269
  field = (u8 )tmp___110;
#line 1269
  goto ldv_28237;
  case 4: 
#line 1269
  tmp___111 = __be32_to_cpup((__be32 const   *)__p___36);
#line 1269
  field = (u8 )tmp___111;
#line 1269
  goto ldv_28237;
  case 8: 
#line 1269
  tmp___112 = __be64_to_cpup((__be64 const   *)__p___36);
#line 1269
  field = (u8 )tmp___112;
#line 1269
  goto ldv_28237;
  default: 
#line 1269
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28237: 
#line 1270
  dev_lim->max_rdds = 1 << ((int )field & 63);
#line 1272
  __p___37 = (void *)outbox + 128U;
#line 1272
  switch (2UL) {
  case 1: 
#line 1272
  size = (u16 )*((u8 *)__p___37);
#line 1272
  goto ldv_28244;
  case 2: 
#line 1272
  size = __be16_to_cpup((__be16 const   *)__p___37);
#line 1272
  goto ldv_28244;
  case 4: 
#line 1272
  tmp___113 = __be32_to_cpup((__be32 const   *)__p___37);
#line 1272
  size = (u16 )tmp___113;
#line 1272
  goto ldv_28244;
  case 8: 
#line 1272
  tmp___114 = __be64_to_cpup((__be64 const   *)__p___37);
#line 1272
  size = (u16 )tmp___114;
#line 1272
  goto ldv_28244;
  default: 
#line 1272
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28244: 
#line 1273
  dev_lim->eec_entry_sz = (int )size;
#line 1274
  __p___38 = (void *)outbox + 130U;
#line 1274
  switch (2UL) {
  case 1: 
#line 1274
  size = (u16 )*((u8 *)__p___38);
#line 1274
  goto ldv_28251;
  case 2: 
#line 1274
  size = __be16_to_cpup((__be16 const   *)__p___38);
#line 1274
  goto ldv_28251;
  case 4: 
#line 1274
  tmp___115 = __be32_to_cpup((__be32 const   *)__p___38);
#line 1274
  size = (u16 )tmp___115;
#line 1274
  goto ldv_28251;
  case 8: 
#line 1274
  tmp___116 = __be64_to_cpup((__be64 const   *)__p___38);
#line 1274
  size = (u16 )tmp___116;
#line 1274
  goto ldv_28251;
  default: 
#line 1274
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28251: 
#line 1275
  dev_lim->qpc_entry_sz = (int )size;
#line 1276
  __p___39 = (void *)outbox + 132U;
#line 1276
  switch (2UL) {
  case 1: 
#line 1276
  size = (u16 )*((u8 *)__p___39);
#line 1276
  goto ldv_28258;
  case 2: 
#line 1276
  size = __be16_to_cpup((__be16 const   *)__p___39);
#line 1276
  goto ldv_28258;
  case 4: 
#line 1276
  tmp___117 = __be32_to_cpup((__be32 const   *)__p___39);
#line 1276
  size = (u16 )tmp___117;
#line 1276
  goto ldv_28258;
  case 8: 
#line 1276
  tmp___118 = __be64_to_cpup((__be64 const   *)__p___39);
#line 1276
  size = (u16 )tmp___118;
#line 1276
  goto ldv_28258;
  default: 
#line 1276
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28258: 
#line 1277
  dev_lim->eeec_entry_sz = (int )size;
#line 1278
  __p___40 = (void *)outbox + 134U;
#line 1278
  switch (2UL) {
  case 1: 
#line 1278
  size = (u16 )*((u8 *)__p___40);
#line 1278
  goto ldv_28265;
  case 2: 
#line 1278
  size = __be16_to_cpup((__be16 const   *)__p___40);
#line 1278
  goto ldv_28265;
  case 4: 
#line 1278
  tmp___119 = __be32_to_cpup((__be32 const   *)__p___40);
#line 1278
  size = (u16 )tmp___119;
#line 1278
  goto ldv_28265;
  case 8: 
#line 1278
  tmp___120 = __be64_to_cpup((__be64 const   *)__p___40);
#line 1278
  size = (u16 )tmp___120;
#line 1278
  goto ldv_28265;
  default: 
#line 1278
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28265: 
#line 1279
  dev_lim->eqpc_entry_sz = (int )size;
#line 1280
  __p___41 = (void *)outbox + 136U;
#line 1280
  switch (2UL) {
  case 1: 
#line 1280
  size = (u16 )*((u8 *)__p___41);
#line 1280
  goto ldv_28272;
  case 2: 
#line 1280
  size = __be16_to_cpup((__be16 const   *)__p___41);
#line 1280
  goto ldv_28272;
  case 4: 
#line 1280
  tmp___121 = __be32_to_cpup((__be32 const   *)__p___41);
#line 1280
  size = (u16 )tmp___121;
#line 1280
  goto ldv_28272;
  case 8: 
#line 1280
  tmp___122 = __be64_to_cpup((__be64 const   *)__p___41);
#line 1280
  size = (u16 )tmp___122;
#line 1280
  goto ldv_28272;
  default: 
#line 1280
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28272: 
#line 1281
  dev_lim->eqc_entry_sz = (int )size;
#line 1282
  __p___42 = (void *)outbox + 138U;
#line 1282
  switch (2UL) {
  case 1: 
#line 1282
  size = (u16 )*((u8 *)__p___42);
#line 1282
  goto ldv_28279;
  case 2: 
#line 1282
  size = __be16_to_cpup((__be16 const   *)__p___42);
#line 1282
  goto ldv_28279;
  case 4: 
#line 1282
  tmp___123 = __be32_to_cpup((__be32 const   *)__p___42);
#line 1282
  size = (u16 )tmp___123;
#line 1282
  goto ldv_28279;
  case 8: 
#line 1282
  tmp___124 = __be64_to_cpup((__be64 const   *)__p___42);
#line 1282
  size = (u16 )tmp___124;
#line 1282
  goto ldv_28279;
  default: 
#line 1282
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28279: 
#line 1283
  dev_lim->cqc_entry_sz = (int )size;
#line 1284
  __p___43 = (void *)outbox + 140U;
#line 1284
  switch (2UL) {
  case 1: 
#line 1284
  size = (u16 )*((u8 *)__p___43);
#line 1284
  goto ldv_28286;
  case 2: 
#line 1284
  size = __be16_to_cpup((__be16 const   *)__p___43);
#line 1284
  goto ldv_28286;
  case 4: 
#line 1284
  tmp___125 = __be32_to_cpup((__be32 const   *)__p___43);
#line 1284
  size = (u16 )tmp___125;
#line 1284
  goto ldv_28286;
  case 8: 
#line 1284
  tmp___126 = __be64_to_cpup((__be64 const   *)__p___43);
#line 1284
  size = (u16 )tmp___126;
#line 1284
  goto ldv_28286;
  default: 
#line 1284
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28286: 
#line 1285
  dev_lim->srq_entry_sz = (int )size;
#line 1286
  __p___44 = (void *)outbox + 142U;
#line 1286
  switch (2UL) {
  case 1: 
#line 1286
  size = (u16 )*((u8 *)__p___44);
#line 1286
  goto ldv_28293;
  case 2: 
#line 1286
  size = __be16_to_cpup((__be16 const   *)__p___44);
#line 1286
  goto ldv_28293;
  case 4: 
#line 1286
  tmp___127 = __be32_to_cpup((__be32 const   *)__p___44);
#line 1286
  size = (u16 )tmp___127;
#line 1286
  goto ldv_28293;
  case 8: 
#line 1286
  tmp___128 = __be64_to_cpup((__be64 const   *)__p___44);
#line 1286
  size = (u16 )tmp___128;
#line 1286
  goto ldv_28293;
  default: 
#line 1286
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28293: 
#line 1287
  dev_lim->uar_scratch_entry_sz = (int )size;
#line 1289
  tmp___169 = mthca_is_memfree(dev);
#line 1289
  if (tmp___169 != 0) {
#line 1290
    __p___45 = (void *)outbox + 16U;
#line 1290
    switch (1UL) {
    case 1: 
#line 1290
    field = *((u8 *)__p___45);
#line 1290
    goto ldv_28300;
    case 2: 
#line 1290
    tmp___129 = __be16_to_cpup((__be16 const   *)__p___45);
#line 1290
    field = (u8 )tmp___129;
#line 1290
    goto ldv_28300;
    case 4: 
#line 1290
    tmp___130 = __be32_to_cpup((__be32 const   *)__p___45);
#line 1290
    field = (u8 )tmp___130;
#line 1290
    goto ldv_28300;
    case 8: 
#line 1290
    tmp___131 = __be64_to_cpup((__be64 const   *)__p___45);
#line 1290
    field = (u8 )tmp___131;
#line 1290
    goto ldv_28300;
    default: 
#line 1290
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28300: 
#line 1291
    dev_lim->max_srq_sz = 1 << (int )field;
#line 1292
    __p___46 = (void *)outbox + 17U;
#line 1292
    switch (1UL) {
    case 1: 
#line 1292
    field = *((u8 *)__p___46);
#line 1292
    goto ldv_28307;
    case 2: 
#line 1292
    tmp___132 = __be16_to_cpup((__be16 const   *)__p___46);
#line 1292
    field = (u8 )tmp___132;
#line 1292
    goto ldv_28307;
    case 4: 
#line 1292
    tmp___133 = __be32_to_cpup((__be32 const   *)__p___46);
#line 1292
    field = (u8 )tmp___133;
#line 1292
    goto ldv_28307;
    case 8: 
#line 1292
    tmp___134 = __be64_to_cpup((__be64 const   *)__p___46);
#line 1292
    field = (u8 )tmp___134;
#line 1292
    goto ldv_28307;
    default: 
#line 1292
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28307: 
#line 1293
    dev_lim->max_qp_sz = 1 << (int )field;
#line 1294
    __p___47 = (void *)outbox + 51U;
#line 1294
    switch (1UL) {
    case 1: 
#line 1294
    field = *((u8 *)__p___47);
#line 1294
    goto ldv_28314;
    case 2: 
#line 1294
    tmp___135 = __be16_to_cpup((__be16 const   *)__p___47);
#line 1294
    field = (u8 )tmp___135;
#line 1294
    goto ldv_28314;
    case 4: 
#line 1294
    tmp___136 = __be32_to_cpup((__be32 const   *)__p___47);
#line 1294
    field = (u8 )tmp___136;
#line 1294
    goto ldv_28314;
    case 8: 
#line 1294
    tmp___137 = __be64_to_cpup((__be64 const   *)__p___47);
#line 1294
    field = (u8 )tmp___137;
#line 1294
    goto ldv_28314;
    default: 
#line 1294
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28314: 
#line 1295
    dev_lim->hca.arbel.resize_srq = (int )field & 1;
#line 1296
    __p___48 = (void *)outbox + 85U;
#line 1296
    switch (1UL) {
    case 1: 
#line 1296
    field = *((u8 *)__p___48);
#line 1296
    goto ldv_28321;
    case 2: 
#line 1296
    tmp___138 = __be16_to_cpup((__be16 const   *)__p___48);
#line 1296
    field = (u8 )tmp___138;
#line 1296
    goto ldv_28321;
    case 4: 
#line 1296
    tmp___139 = __be32_to_cpup((__be32 const   *)__p___48);
#line 1296
    field = (u8 )tmp___139;
#line 1296
    goto ldv_28321;
    case 8: 
#line 1296
    tmp___140 = __be64_to_cpup((__be64 const   *)__p___48);
#line 1296
    field = (u8 )tmp___140;
#line 1296
    goto ldv_28321;
    default: 
#line 1296
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28321: 
#line 1297
    __min1 = (int )field;
#line 1297
    __min2 = dev_lim->max_sg;
#line 1297
    if (__min1 < __min2) {
#line 1297
      tmp___141 = __min1;
    } else {
#line 1297
      tmp___141 = __min2;
    }
#line 1297
    dev_lim->max_sg = tmp___141;
#line 1298
    __p___49 = (void *)outbox + 86U;
#line 1298
    switch (2UL) {
    case 1: 
#line 1298
    size = (u16 )*((u8 *)__p___49);
#line 1298
    goto ldv_28331;
    case 2: 
#line 1298
    size = __be16_to_cpup((__be16 const   *)__p___49);
#line 1298
    goto ldv_28331;
    case 4: 
#line 1298
    tmp___142 = __be32_to_cpup((__be32 const   *)__p___49);
#line 1298
    size = (u16 )tmp___142;
#line 1298
    goto ldv_28331;
    case 8: 
#line 1298
    tmp___143 = __be64_to_cpup((__be64 const   *)__p___49);
#line 1298
    size = (u16 )tmp___143;
#line 1298
    goto ldv_28331;
    default: 
#line 1298
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28331: 
#line 1299
    __min1___0 = (int )size;
#line 1299
    __min2___0 = dev_lim->max_desc_sz;
#line 1299
    if (__min1___0 < __min2___0) {
#line 1299
      tmp___144 = __min1___0;
    } else {
#line 1299
      tmp___144 = __min2___0;
    }
#line 1299
    dev_lim->max_desc_sz = tmp___144;
#line 1300
    __p___50 = (void *)outbox + 146U;
#line 1300
    switch (2UL) {
    case 1: 
#line 1300
    size = (u16 )*((u8 *)__p___50);
#line 1300
    goto ldv_28341;
    case 2: 
#line 1300
    size = __be16_to_cpup((__be16 const   *)__p___50);
#line 1300
    goto ldv_28341;
    case 4: 
#line 1300
    tmp___145 = __be32_to_cpup((__be32 const   *)__p___50);
#line 1300
    size = (u16 )tmp___145;
#line 1300
    goto ldv_28341;
    case 8: 
#line 1300
    tmp___146 = __be64_to_cpup((__be64 const   *)__p___50);
#line 1300
    size = (u16 )tmp___146;
#line 1300
    goto ldv_28341;
    default: 
#line 1300
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28341: 
#line 1301
    dev_lim->mpt_entry_sz = (int )size;
#line 1302
    __p___51 = (void *)outbox + 150U;
#line 1302
    switch (1UL) {
    case 1: 
#line 1302
    field = *((u8 *)__p___51);
#line 1302
    goto ldv_28348;
    case 2: 
#line 1302
    tmp___147 = __be16_to_cpup((__be16 const   *)__p___51);
#line 1302
    field = (u8 )tmp___147;
#line 1302
    goto ldv_28348;
    case 4: 
#line 1302
    tmp___148 = __be32_to_cpup((__be32 const   *)__p___51);
#line 1302
    field = (u8 )tmp___148;
#line 1302
    goto ldv_28348;
    case 8: 
#line 1302
    tmp___149 = __be64_to_cpup((__be64 const   *)__p___51);
#line 1302
    field = (u8 )tmp___149;
#line 1302
    goto ldv_28348;
    default: 
#line 1302
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28348: 
#line 1303
    dev_lim->hca.arbel.max_pbl_sz = 1 << ((int )field & 63);
#line 1304
    __p___52 = (void *)outbox + 151U;
#line 1304
    switch (1UL) {
    case 1: 
#line 1304
    dev_lim->hca.arbel.bmme_flags = *((u8 *)__p___52);
#line 1304
    goto ldv_28355;
    case 2: 
#line 1304
    tmp___150 = __be16_to_cpup((__be16 const   *)__p___52);
#line 1304
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___150;
#line 1304
    goto ldv_28355;
    case 4: 
#line 1304
    tmp___151 = __be32_to_cpup((__be32 const   *)__p___52);
#line 1304
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___151;
#line 1304
    goto ldv_28355;
    case 8: 
#line 1304
    tmp___152 = __be64_to_cpup((__be64 const   *)__p___52);
#line 1304
    dev_lim->hca.arbel.bmme_flags = (u8 )tmp___152;
#line 1304
    goto ldv_28355;
    default: 
#line 1304
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28355: 
#line 1306
    __p___53 = (void *)outbox + 152U;
#line 1306
    switch (4UL) {
    case 1: 
#line 1306
    dev_lim->hca.arbel.reserved_lkey = (u32 )*((u8 *)__p___53);
#line 1306
    goto ldv_28362;
    case 2: 
#line 1306
    tmp___153 = __be16_to_cpup((__be16 const   *)__p___53);
#line 1306
    dev_lim->hca.arbel.reserved_lkey = (u32 )tmp___153;
#line 1306
    goto ldv_28362;
    case 4: 
#line 1306
    dev_lim->hca.arbel.reserved_lkey = __be32_to_cpup((__be32 const   *)__p___53);
#line 1306
    goto ldv_28362;
    case 8: 
#line 1306
    tmp___154 = __be64_to_cpup((__be64 const   *)__p___53);
#line 1306
    dev_lim->hca.arbel.reserved_lkey = (u32 )tmp___154;
#line 1306
    goto ldv_28362;
    default: 
#line 1306
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28362: 
#line 1308
    __p___54 = (void *)outbox + 159U;
#line 1308
    switch (1UL) {
    case 1: 
#line 1308
    field = *((u8 *)__p___54);
#line 1308
    goto ldv_28369;
    case 2: 
#line 1308
    tmp___155 = __be16_to_cpup((__be16 const   *)__p___54);
#line 1308
    field = (u8 )tmp___155;
#line 1308
    goto ldv_28369;
    case 4: 
#line 1308
    tmp___156 = __be32_to_cpup((__be32 const   *)__p___54);
#line 1308
    field = (u8 )tmp___156;
#line 1308
    goto ldv_28369;
    case 8: 
#line 1308
    tmp___157 = __be64_to_cpup((__be64 const   *)__p___54);
#line 1308
    field = (u8 )tmp___157;
#line 1308
    goto ldv_28369;
    default: 
#line 1308
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28369: 
#line 1309
    dev_lim->hca.arbel.lam_required = (int )field & 1;
#line 1310
    __p___55 = (void *)outbox + 160U;
#line 1310
    switch (8UL) {
    case 1: 
#line 1310
    dev_lim->hca.arbel.max_icm_sz = (u64 )*((u8 *)__p___55);
#line 1310
    goto ldv_28376;
    case 2: 
#line 1310
    tmp___158 = __be16_to_cpup((__be16 const   *)__p___55);
#line 1310
    dev_lim->hca.arbel.max_icm_sz = (u64 )tmp___158;
#line 1310
    goto ldv_28376;
    case 4: 
#line 1310
    tmp___159 = __be32_to_cpup((__be32 const   *)__p___55);
#line 1310
    dev_lim->hca.arbel.max_icm_sz = (u64 )tmp___159;
#line 1310
    goto ldv_28376;
    case 8: 
#line 1310
    dev_lim->hca.arbel.max_icm_sz = __be64_to_cpup((__be64 const   *)__p___55);
#line 1310
    goto ldv_28376;
    default: 
#line 1310
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28376: ;
#line 1313
    if ((int )dev_lim->hca.arbel.bmme_flags & 1) {
#line 1314
      if (mthca_debug_level != 0) {
#line 1314
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Base MM extensions: yes (flags %d, max PBL %d, rsvd L_Key %08x)\n",
                   (int )dev_lim->hca.arbel.bmme_flags, dev_lim->hca.arbel.max_pbl_sz,
                   dev_lim->hca.arbel.reserved_lkey);
      } else
#line 1320
      if (mthca_debug_level != 0) {
#line 1320
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Base MM extensions: no\n");
      } else {

      }
    } else {

    }
#line 1322
    if (mthca_debug_level != 0) {
#line 1322
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max ICM size %lld MB\n",
                 dev_lim->hca.arbel.max_icm_sz >> 20);
    } else {

    }
  } else {
#line 1325
    __p___56 = (void *)outbox + 16U;
#line 1325
    switch (1UL) {
    case 1: 
#line 1325
    field = *((u8 *)__p___56);
#line 1325
    goto ldv_28383;
    case 2: 
#line 1325
    tmp___160 = __be16_to_cpup((__be16 const   *)__p___56);
#line 1325
    field = (u8 )tmp___160;
#line 1325
    goto ldv_28383;
    case 4: 
#line 1325
    tmp___161 = __be32_to_cpup((__be32 const   *)__p___56);
#line 1325
    field = (u8 )tmp___161;
#line 1325
    goto ldv_28383;
    case 8: 
#line 1325
    tmp___162 = __be64_to_cpup((__be64 const   *)__p___56);
#line 1325
    field = (u8 )tmp___162;
#line 1325
    goto ldv_28383;
    default: 
#line 1325
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28383: 
#line 1326
    dev_lim->max_srq_sz = (1 << (int )field) + -1;
#line 1327
    __p___57 = (void *)outbox + 17U;
#line 1327
    switch (1UL) {
    case 1: 
#line 1327
    field = *((u8 *)__p___57);
#line 1327
    goto ldv_28390;
    case 2: 
#line 1327
    tmp___163 = __be16_to_cpup((__be16 const   *)__p___57);
#line 1327
    field = (u8 )tmp___163;
#line 1327
    goto ldv_28390;
    case 4: 
#line 1327
    tmp___164 = __be32_to_cpup((__be32 const   *)__p___57);
#line 1327
    field = (u8 )tmp___164;
#line 1327
    goto ldv_28390;
    case 8: 
#line 1327
    tmp___165 = __be64_to_cpup((__be64 const   *)__p___57);
#line 1327
    field = (u8 )tmp___165;
#line 1327
    goto ldv_28390;
    default: 
#line 1327
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28390: 
#line 1328
    dev_lim->max_qp_sz = (1 << (int )field) + -1;
#line 1329
    __p___58 = (void *)outbox + 39U;
#line 1329
    switch (1UL) {
    case 1: 
#line 1329
    field = *((u8 *)__p___58);
#line 1329
    goto ldv_28397;
    case 2: 
#line 1329
    tmp___166 = __be16_to_cpup((__be16 const   *)__p___58);
#line 1329
    field = (u8 )tmp___166;
#line 1329
    goto ldv_28397;
    case 4: 
#line 1329
    tmp___167 = __be32_to_cpup((__be32 const   *)__p___58);
#line 1329
    field = (u8 )tmp___167;
#line 1329
    goto ldv_28397;
    case 8: 
#line 1329
    tmp___168 = __be64_to_cpup((__be64 const   *)__p___58);
#line 1329
    field = (u8 )tmp___168;
#line 1329
    goto ldv_28397;
    default: 
#line 1329
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28397: 
#line 1330
    dev_lim->hca.tavor.max_avs = 1 << ((int )field & 63);
#line 1331
    dev_lim->mpt_entry_sz = 64;
  }
#line 1334
  if (mthca_debug_level != 0) {
#line 1334
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max QPs: %d, reserved QPs: %d, entry size: %d\n",
               dev_lim->max_qps, dev_lim->reserved_qps, dev_lim->qpc_entry_sz);
  } else {

  }
#line 1336
  if (mthca_debug_level != 0) {
#line 1336
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max SRQs: %d, reserved SRQs: %d, entry size: %d\n",
               dev_lim->max_srqs, dev_lim->reserved_srqs, dev_lim->srq_entry_sz);
  } else {

  }
#line 1338
  if (mthca_debug_level != 0) {
#line 1338
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max CQs: %d, reserved CQs: %d, entry size: %d\n",
               dev_lim->max_cqs, dev_lim->reserved_cqs, dev_lim->cqc_entry_sz);
  } else {

  }
#line 1340
  if (mthca_debug_level != 0) {
#line 1340
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max EQs: %d, reserved EQs: %d, entry size: %d\n",
               dev_lim->max_eqs, dev_lim->reserved_eqs, dev_lim->eqc_entry_sz);
  } else {

  }
#line 1342
  if (mthca_debug_level != 0) {
#line 1342
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "reserved MPTs: %d, reserved MTTs: %d\n",
               dev_lim->reserved_mrws, dev_lim->reserved_mtts);
  } else {

  }
#line 1344
  if (mthca_debug_level != 0) {
#line 1344
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n",
               dev_lim->max_pds, dev_lim->reserved_pds, dev_lim->reserved_uars);
  } else {

  }
#line 1346
  if (mthca_debug_level != 0) {
#line 1346
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max QP/MCG: %d, reserved MGMs: %d\n",
               dev_lim->max_pds, dev_lim->reserved_mgms);
  } else {

  }
#line 1348
  if (mthca_debug_level != 0) {
#line 1348
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n",
               dev_lim->max_cq_sz, dev_lim->max_qp_sz, dev_lim->max_srq_sz);
  } else {

  }
#line 1351
  if (mthca_debug_level != 0) {
#line 1351
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Flags: %08x\n",
               dev_lim->flags);
  } else {

  }
  out: 
#line 1354
  mthca_free_mailbox(dev, mailbox);
#line 1355
  return (err);
}
}
#line 1358 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
static void get_board_id(void *vsd , char *board_id ) 
{ int i ;
  __u32 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 1369
  memset((void *)board_id, 0, 64UL);
#line 1371
  tmp___0 = __be16_to_cpup((__be16 const   *)vsd);
#line 1371
  if ((unsigned int )tmp___0 == 1453U) {
#line 1371
    tmp___1 = __be16_to_cpup((__be16 const   *)vsd + 222U);
#line 1371
    if ((unsigned int )tmp___1 == 1453U) {
#line 1373
      strlcpy(board_id, (char const   *)vsd + 32U, 64UL);
    } else {
#line 1371
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1380
    i = 0;
#line 1380
    goto ldv_28408;
    ldv_28407: 
#line 1381
    tmp = __fswab32(*((u32 *)(vsd + ((unsigned long )(i * 4) + 208UL))));
#line 1381
    *((u32 *)board_id + (unsigned long )i) = tmp;
#line 1380
    i = i + 1;
    ldv_28408: ;
#line 1380
    if (i <= 3) {
#line 1381
      goto ldv_28407;
    } else {
#line 1383
      goto ldv_28409;
    }
    ldv_28409: ;
  }
#line 1386
  return;
}
}
#line 1386 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_ADAPTER(struct mthca_dev *dev , struct mthca_adapter *adapter ) 
{ struct mthca_mailbox *mailbox ;
  u32 *outbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__p ;
  __u16 tmp___1 ;
  __u64 tmp___2 ;
  void *__p___0 ;
  __u16 tmp___3 ;
  __u64 tmp___4 ;
  void *__p___1 ;
  __u16 tmp___5 ;
  __u64 tmp___6 ;
  int tmp___7 ;
  void *__p___2 ;
  __u16 tmp___8 ;
  __u32 tmp___9 ;
  __u64 tmp___10 ;

  {
#line 1400
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1401
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1401
  if (tmp___0 != 0L) {
#line 1402
    tmp = PTR_ERR((void const   *)mailbox);
#line 1402
    return ((int )tmp);
  } else {

  }
#line 1403
  outbox = (u32 *)mailbox->buf;
#line 1405
  err = mthca_cmd_box(dev, 0ULL, mailbox->dma, 0U, 0, 6, 15000UL);
#line 1408
  if (err != 0) {
#line 1409
    goto out;
  } else {

  }
#line 1411
  tmp___7 = mthca_is_memfree(dev);
#line 1411
  if (tmp___7 == 0) {
#line 1412
    __p = (void *)outbox;
#line 1412
    switch (4UL) {
    case 1: 
#line 1412
    adapter->vendor_id = (u32 )*((u8 *)__p);
#line 1412
    goto ldv_28420;
    case 2: 
#line 1412
    tmp___1 = __be16_to_cpup((__be16 const   *)__p);
#line 1412
    adapter->vendor_id = (u32 )tmp___1;
#line 1412
    goto ldv_28420;
    case 4: 
#line 1412
    adapter->vendor_id = __be32_to_cpup((__be32 const   *)__p);
#line 1412
    goto ldv_28420;
    case 8: 
#line 1412
    tmp___2 = __be64_to_cpup((__be64 const   *)__p);
#line 1412
    adapter->vendor_id = (u32 )tmp___2;
#line 1412
    goto ldv_28420;
    default: 
#line 1412
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28420: 
#line 1414
    __p___0 = (void *)outbox + 4U;
#line 1414
    switch (4UL) {
    case 1: 
#line 1414
    adapter->device_id = (u32 )*((u8 *)__p___0);
#line 1414
    goto ldv_28427;
    case 2: 
#line 1414
    tmp___3 = __be16_to_cpup((__be16 const   *)__p___0);
#line 1414
    adapter->device_id = (u32 )tmp___3;
#line 1414
    goto ldv_28427;
    case 4: 
#line 1414
    adapter->device_id = __be32_to_cpup((__be32 const   *)__p___0);
#line 1414
    goto ldv_28427;
    case 8: 
#line 1414
    tmp___4 = __be64_to_cpup((__be64 const   *)__p___0);
#line 1414
    adapter->device_id = (u32 )tmp___4;
#line 1414
    goto ldv_28427;
    default: 
#line 1414
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28427: 
#line 1416
    __p___1 = (void *)outbox + 8U;
#line 1416
    switch (4UL) {
    case 1: 
#line 1416
    adapter->revision_id = (u32 )*((u8 *)__p___1);
#line 1416
    goto ldv_28434;
    case 2: 
#line 1416
    tmp___5 = __be16_to_cpup((__be16 const   *)__p___1);
#line 1416
    adapter->revision_id = (u32 )tmp___5;
#line 1416
    goto ldv_28434;
    case 4: 
#line 1416
    adapter->revision_id = __be32_to_cpup((__be32 const   *)__p___1);
#line 1416
    goto ldv_28434;
    case 8: 
#line 1416
    tmp___6 = __be64_to_cpup((__be64 const   *)__p___1);
#line 1416
    adapter->revision_id = (u32 )tmp___6;
#line 1416
    goto ldv_28434;
    default: 
#line 1416
    __buggy_use_of_MTHCA_GET();
    }
    ldv_28434: ;
  } else {

  }
#line 1419
  __p___2 = (void *)outbox + 16U;
#line 1419
  switch (1UL) {
  case 1: 
#line 1419
  adapter->inta_pin = *((u8 *)__p___2);
#line 1419
  goto ldv_28441;
  case 2: 
#line 1419
  tmp___8 = __be16_to_cpup((__be16 const   *)__p___2);
#line 1419
  adapter->inta_pin = (u8 )tmp___8;
#line 1419
  goto ldv_28441;
  case 4: 
#line 1419
  tmp___9 = __be32_to_cpup((__be32 const   *)__p___2);
#line 1419
  adapter->inta_pin = (u8 )tmp___9;
#line 1419
  goto ldv_28441;
  case 8: 
#line 1419
  tmp___10 = __be64_to_cpup((__be64 const   *)__p___2);
#line 1419
  adapter->inta_pin = (u8 )tmp___10;
#line 1419
  goto ldv_28441;
  default: 
#line 1419
  __buggy_use_of_MTHCA_GET();
  }
  ldv_28441: 
#line 1421
  get_board_id((void *)outbox + 8U, (char *)(& adapter->board_id));
  out: 
#line 1425
  mthca_free_mailbox(dev, mailbox);
#line 1426
  return (err);
}
}
#line 1429 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_INIT_HCA(struct mthca_dev *dev , struct mthca_init_hca_param *param ) 
{ struct mthca_mailbox *mailbox ;
  __be32 *inbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__d ;
  void *__d___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___1 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__d___2 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__d___3 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__d___4 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__d___5 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__d___6 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;
  void *__d___7 ;
  __u16 tmp___22 ;
  __u32 tmp___23 ;
  __u64 tmp___24 ;
  void *__d___8 ;
  __u16 tmp___25 ;
  __u32 tmp___26 ;
  __u64 tmp___27 ;
  void *__d___9 ;
  __u16 tmp___28 ;
  __u32 tmp___29 ;
  __u64 tmp___30 ;
  void *__d___10 ;
  __u16 tmp___31 ;
  __u32 tmp___32 ;
  __u64 tmp___33 ;
  void *__d___11 ;
  __u16 tmp___34 ;
  __u32 tmp___35 ;
  __u64 tmp___36 ;
  void *__d___12 ;
  __u16 tmp___37 ;
  __u32 tmp___38 ;
  __u64 tmp___39 ;
  void *__d___13 ;
  __u16 tmp___40 ;
  __u32 tmp___41 ;
  __u64 tmp___42 ;
  void *__d___14 ;
  __u16 tmp___43 ;
  __u32 tmp___44 ;
  __u64 tmp___45 ;
  void *__d___15 ;
  __u16 tmp___46 ;
  __u32 tmp___47 ;
  __u64 tmp___48 ;
  void *__d___16 ;
  __u16 tmp___49 ;
  __u32 tmp___50 ;
  __u64 tmp___51 ;
  void *__d___17 ;
  __u16 tmp___52 ;
  __u32 tmp___53 ;
  __u64 tmp___54 ;
  void *__d___18 ;
  __u16 tmp___55 ;
  __u32 tmp___56 ;
  __u64 tmp___57 ;
  int tmp___58 ;
  void *__d___19 ;
  __u16 tmp___59 ;
  __u32 tmp___60 ;
  __u64 tmp___61 ;
  void *__d___20 ;
  __u16 tmp___62 ;
  __u32 tmp___63 ;
  __u64 tmp___64 ;
  u8 uar_page_sz ;
  void *__d___21 ;
  __u16 tmp___65 ;
  __u32 tmp___66 ;
  __u64 tmp___67 ;
  void *__d___22 ;
  __u16 tmp___68 ;
  __u32 tmp___69 ;
  __u64 tmp___70 ;
  void *__d___23 ;
  __u16 tmp___71 ;
  __u32 tmp___72 ;
  __u64 tmp___73 ;
  void *__d___24 ;
  __u16 tmp___74 ;
  __u32 tmp___75 ;
  __u64 tmp___76 ;
  void *__d___25 ;
  __u16 tmp___77 ;
  __u32 tmp___78 ;
  __u64 tmp___79 ;
  int tmp___80 ;

  {
#line 1474
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1475
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1475
  if (tmp___0 != 0L) {
#line 1476
    tmp = PTR_ERR((void const   *)mailbox);
#line 1476
    return ((int )tmp);
  } else {

  }
#line 1477
  inbox = (__be32 *)mailbox->buf;
#line 1479
  memset((void *)inbox, 0, 512UL);
#line 1481
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 1482
    __d = (void *)inbox + 12U;
#line 1482
    switch (4UL) {
    case 1: 
#line 1482
    *((u8 *)__d) = 1U;
#line 1482
    goto ldv_28455;
    case 2: 
#line 1482
    *((__be16 *)__d) = 256U;
#line 1482
    goto ldv_28455;
    case 4: 
#line 1482
    *((__be32 *)__d) = 16777216U;
#line 1482
    goto ldv_28455;
    case 8: 
#line 1482
    *((__be64 *)__d) = 72057594037927936ULL;
#line 1482
    goto ldv_28455;
    default: 
#line 1482
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28455: ;
  } else {

  }
#line 1485
  *(inbox + 5UL) = *(inbox + 5UL) & 4261412863U;
#line 1492
  *(inbox + 5UL) = *(inbox + 5UL) | 16777216U;
#line 1495
  if ((dev->device_cap_flags & 262144UL) != 0UL) {
#line 1496
    *(inbox + 5UL) = *(inbox + 5UL) | 939524096U;
  } else {

  }
#line 1502
  __d___0 = (void *)inbox + 48U;
#line 1502
  switch (8UL) {
  case 1: 
#line 1502
  *((u8 *)__d___0) = (u8 )param->qpc_base;
#line 1502
  goto ldv_28462;
  case 2: 
#line 1502
  tmp___1 = __fswab16((int )((__u16 )param->qpc_base));
#line 1502
  *((__be16 *)__d___0) = tmp___1;
#line 1502
  goto ldv_28462;
  case 4: 
#line 1502
  tmp___2 = __fswab32((__u32 )param->qpc_base);
#line 1502
  *((__be32 *)__d___0) = tmp___2;
#line 1502
  goto ldv_28462;
  case 8: 
#line 1502
  tmp___3 = __fswab64(param->qpc_base);
#line 1502
  *((__be64 *)__d___0) = tmp___3;
#line 1502
  goto ldv_28462;
  default: 
#line 1502
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28462: 
#line 1503
  __d___1 = (void *)inbox + 55U;
#line 1503
  switch (1UL) {
  case 1: 
#line 1503
  *((u8 *)__d___1) = param->log_num_qps;
#line 1503
  goto ldv_28469;
  case 2: 
#line 1503
  tmp___4 = __fswab16((int )param->log_num_qps);
#line 1503
  *((__be16 *)__d___1) = tmp___4;
#line 1503
  goto ldv_28469;
  case 4: 
#line 1503
  tmp___5 = __fswab32((__u32 )param->log_num_qps);
#line 1503
  *((__be32 *)__d___1) = tmp___5;
#line 1503
  goto ldv_28469;
  case 8: 
#line 1503
  tmp___6 = __fswab64((__u64 )param->log_num_qps);
#line 1503
  *((__be64 *)__d___1) = tmp___6;
#line 1503
  goto ldv_28469;
  default: 
#line 1503
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28469: 
#line 1504
  __d___2 = (void *)inbox + 64U;
#line 1504
  switch (8UL) {
  case 1: 
#line 1504
  *((u8 *)__d___2) = (u8 )param->eec_base;
#line 1504
  goto ldv_28476;
  case 2: 
#line 1504
  tmp___7 = __fswab16((int )((__u16 )param->eec_base));
#line 1504
  *((__be16 *)__d___2) = tmp___7;
#line 1504
  goto ldv_28476;
  case 4: 
#line 1504
  tmp___8 = __fswab32((__u32 )param->eec_base);
#line 1504
  *((__be32 *)__d___2) = tmp___8;
#line 1504
  goto ldv_28476;
  case 8: 
#line 1504
  tmp___9 = __fswab64(param->eec_base);
#line 1504
  *((__be64 *)__d___2) = tmp___9;
#line 1504
  goto ldv_28476;
  default: 
#line 1504
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28476: 
#line 1505
  __d___3 = (void *)inbox + 71U;
#line 1505
  switch (1UL) {
  case 1: 
#line 1505
  *((u8 *)__d___3) = param->log_num_eecs;
#line 1505
  goto ldv_28483;
  case 2: 
#line 1505
  tmp___10 = __fswab16((int )param->log_num_eecs);
#line 1505
  *((__be16 *)__d___3) = tmp___10;
#line 1505
  goto ldv_28483;
  case 4: 
#line 1505
  tmp___11 = __fswab32((__u32 )param->log_num_eecs);
#line 1505
  *((__be32 *)__d___3) = tmp___11;
#line 1505
  goto ldv_28483;
  case 8: 
#line 1505
  tmp___12 = __fswab64((__u64 )param->log_num_eecs);
#line 1505
  *((__be64 *)__d___3) = tmp___12;
#line 1505
  goto ldv_28483;
  default: 
#line 1505
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28483: 
#line 1506
  __d___4 = (void *)inbox + 72U;
#line 1506
  switch (8UL) {
  case 1: 
#line 1506
  *((u8 *)__d___4) = (u8 )param->srqc_base;
#line 1506
  goto ldv_28490;
  case 2: 
#line 1506
  tmp___13 = __fswab16((int )((__u16 )param->srqc_base));
#line 1506
  *((__be16 *)__d___4) = tmp___13;
#line 1506
  goto ldv_28490;
  case 4: 
#line 1506
  tmp___14 = __fswab32((__u32 )param->srqc_base);
#line 1506
  *((__be32 *)__d___4) = tmp___14;
#line 1506
  goto ldv_28490;
  case 8: 
#line 1506
  tmp___15 = __fswab64(param->srqc_base);
#line 1506
  *((__be64 *)__d___4) = tmp___15;
#line 1506
  goto ldv_28490;
  default: 
#line 1506
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28490: 
#line 1507
  __d___5 = (void *)inbox + 79U;
#line 1507
  switch (1UL) {
  case 1: 
#line 1507
  *((u8 *)__d___5) = param->log_num_srqs;
#line 1507
  goto ldv_28497;
  case 2: 
#line 1507
  tmp___16 = __fswab16((int )param->log_num_srqs);
#line 1507
  *((__be16 *)__d___5) = tmp___16;
#line 1507
  goto ldv_28497;
  case 4: 
#line 1507
  tmp___17 = __fswab32((__u32 )param->log_num_srqs);
#line 1507
  *((__be32 *)__d___5) = tmp___17;
#line 1507
  goto ldv_28497;
  case 8: 
#line 1507
  tmp___18 = __fswab64((__u64 )param->log_num_srqs);
#line 1507
  *((__be64 *)__d___5) = tmp___18;
#line 1507
  goto ldv_28497;
  default: 
#line 1507
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28497: 
#line 1508
  __d___6 = (void *)inbox + 80U;
#line 1508
  switch (8UL) {
  case 1: 
#line 1508
  *((u8 *)__d___6) = (u8 )param->cqc_base;
#line 1508
  goto ldv_28504;
  case 2: 
#line 1508
  tmp___19 = __fswab16((int )((__u16 )param->cqc_base));
#line 1508
  *((__be16 *)__d___6) = tmp___19;
#line 1508
  goto ldv_28504;
  case 4: 
#line 1508
  tmp___20 = __fswab32((__u32 )param->cqc_base);
#line 1508
  *((__be32 *)__d___6) = tmp___20;
#line 1508
  goto ldv_28504;
  case 8: 
#line 1508
  tmp___21 = __fswab64(param->cqc_base);
#line 1508
  *((__be64 *)__d___6) = tmp___21;
#line 1508
  goto ldv_28504;
  default: 
#line 1508
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28504: 
#line 1509
  __d___7 = (void *)inbox + 87U;
#line 1509
  switch (1UL) {
  case 1: 
#line 1509
  *((u8 *)__d___7) = param->log_num_cqs;
#line 1509
  goto ldv_28511;
  case 2: 
#line 1509
  tmp___22 = __fswab16((int )param->log_num_cqs);
#line 1509
  *((__be16 *)__d___7) = tmp___22;
#line 1509
  goto ldv_28511;
  case 4: 
#line 1509
  tmp___23 = __fswab32((__u32 )param->log_num_cqs);
#line 1509
  *((__be32 *)__d___7) = tmp___23;
#line 1509
  goto ldv_28511;
  case 8: 
#line 1509
  tmp___24 = __fswab64((__u64 )param->log_num_cqs);
#line 1509
  *((__be64 *)__d___7) = tmp___24;
#line 1509
  goto ldv_28511;
  default: 
#line 1509
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28511: 
#line 1510
  __d___8 = (void *)inbox + 96U;
#line 1510
  switch (8UL) {
  case 1: 
#line 1510
  *((u8 *)__d___8) = (u8 )param->eqpc_base;
#line 1510
  goto ldv_28518;
  case 2: 
#line 1510
  tmp___25 = __fswab16((int )((__u16 )param->eqpc_base));
#line 1510
  *((__be16 *)__d___8) = tmp___25;
#line 1510
  goto ldv_28518;
  case 4: 
#line 1510
  tmp___26 = __fswab32((__u32 )param->eqpc_base);
#line 1510
  *((__be32 *)__d___8) = tmp___26;
#line 1510
  goto ldv_28518;
  case 8: 
#line 1510
  tmp___27 = __fswab64(param->eqpc_base);
#line 1510
  *((__be64 *)__d___8) = tmp___27;
#line 1510
  goto ldv_28518;
  default: 
#line 1510
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28518: 
#line 1511
  __d___9 = (void *)inbox + 112U;
#line 1511
  switch (8UL) {
  case 1: 
#line 1511
  *((u8 *)__d___9) = (u8 )param->eeec_base;
#line 1511
  goto ldv_28525;
  case 2: 
#line 1511
  tmp___28 = __fswab16((int )((__u16 )param->eeec_base));
#line 1511
  *((__be16 *)__d___9) = tmp___28;
#line 1511
  goto ldv_28525;
  case 4: 
#line 1511
  tmp___29 = __fswab32((__u32 )param->eeec_base);
#line 1511
  *((__be32 *)__d___9) = tmp___29;
#line 1511
  goto ldv_28525;
  case 8: 
#line 1511
  tmp___30 = __fswab64(param->eeec_base);
#line 1511
  *((__be64 *)__d___9) = tmp___30;
#line 1511
  goto ldv_28525;
  default: 
#line 1511
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28525: 
#line 1512
  __d___10 = (void *)inbox + 128U;
#line 1512
  switch (8UL) {
  case 1: 
#line 1512
  *((u8 *)__d___10) = (u8 )param->eqc_base;
#line 1512
  goto ldv_28532;
  case 2: 
#line 1512
  tmp___31 = __fswab16((int )((__u16 )param->eqc_base));
#line 1512
  *((__be16 *)__d___10) = tmp___31;
#line 1512
  goto ldv_28532;
  case 4: 
#line 1512
  tmp___32 = __fswab32((__u32 )param->eqc_base);
#line 1512
  *((__be32 *)__d___10) = tmp___32;
#line 1512
  goto ldv_28532;
  case 8: 
#line 1512
  tmp___33 = __fswab64(param->eqc_base);
#line 1512
  *((__be64 *)__d___10) = tmp___33;
#line 1512
  goto ldv_28532;
  default: 
#line 1512
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28532: 
#line 1513
  __d___11 = (void *)inbox + 135U;
#line 1513
  switch (1UL) {
  case 1: 
#line 1513
  *((u8 *)__d___11) = param->log_num_eqs;
#line 1513
  goto ldv_28539;
  case 2: 
#line 1513
  tmp___34 = __fswab16((int )param->log_num_eqs);
#line 1513
  *((__be16 *)__d___11) = tmp___34;
#line 1513
  goto ldv_28539;
  case 4: 
#line 1513
  tmp___35 = __fswab32((__u32 )param->log_num_eqs);
#line 1513
  *((__be32 *)__d___11) = tmp___35;
#line 1513
  goto ldv_28539;
  case 8: 
#line 1513
  tmp___36 = __fswab64((__u64 )param->log_num_eqs);
#line 1513
  *((__be64 *)__d___11) = tmp___36;
#line 1513
  goto ldv_28539;
  default: 
#line 1513
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28539: 
#line 1514
  __d___12 = (void *)inbox + 144U;
#line 1514
  switch (8UL) {
  case 1: 
#line 1514
  *((u8 *)__d___12) = (u8 )param->rdb_base;
#line 1514
  goto ldv_28546;
  case 2: 
#line 1514
  tmp___37 = __fswab16((int )((__u16 )param->rdb_base));
#line 1514
  *((__be16 *)__d___12) = tmp___37;
#line 1514
  goto ldv_28546;
  case 4: 
#line 1514
  tmp___38 = __fswab32((__u32 )param->rdb_base);
#line 1514
  *((__be32 *)__d___12) = tmp___38;
#line 1514
  goto ldv_28546;
  case 8: 
#line 1514
  tmp___39 = __fswab64(param->rdb_base);
#line 1514
  *((__be64 *)__d___12) = tmp___39;
#line 1514
  goto ldv_28546;
  default: 
#line 1514
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28546: 
#line 1520
  __d___13 = (void *)inbox + 192U;
#line 1520
  switch (8UL) {
  case 1: 
#line 1520
  *((u8 *)__d___13) = (u8 )param->mc_base;
#line 1520
  goto ldv_28553;
  case 2: 
#line 1520
  tmp___40 = __fswab16((int )((__u16 )param->mc_base));
#line 1520
  *((__be16 *)__d___13) = tmp___40;
#line 1520
  goto ldv_28553;
  case 4: 
#line 1520
  tmp___41 = __fswab32((__u32 )param->mc_base);
#line 1520
  *((__be32 *)__d___13) = tmp___41;
#line 1520
  goto ldv_28553;
  case 8: 
#line 1520
  tmp___42 = __fswab64(param->mc_base);
#line 1520
  *((__be64 *)__d___13) = tmp___42;
#line 1520
  goto ldv_28553;
  default: 
#line 1520
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28553: 
#line 1521
  __d___14 = (void *)inbox + 210U;
#line 1521
  switch (2UL) {
  case 1: 
#line 1521
  *((u8 *)__d___14) = (u8 )param->log_mc_entry_sz;
#line 1521
  goto ldv_28560;
  case 2: 
#line 1521
  tmp___43 = __fswab16((int )param->log_mc_entry_sz);
#line 1521
  *((__be16 *)__d___14) = tmp___43;
#line 1521
  goto ldv_28560;
  case 4: 
#line 1521
  tmp___44 = __fswab32((__u32 )param->log_mc_entry_sz);
#line 1521
  *((__be32 *)__d___14) = tmp___44;
#line 1521
  goto ldv_28560;
  case 8: 
#line 1521
  tmp___45 = __fswab64((__u64 )param->log_mc_entry_sz);
#line 1521
  *((__be64 *)__d___14) = tmp___45;
#line 1521
  goto ldv_28560;
  default: 
#line 1521
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28560: 
#line 1522
  __d___15 = (void *)inbox + 214U;
#line 1522
  switch (2UL) {
  case 1: 
#line 1522
  *((u8 *)__d___15) = (u8 )param->mc_hash_sz;
#line 1522
  goto ldv_28567;
  case 2: 
#line 1522
  tmp___46 = __fswab16((int )param->mc_hash_sz);
#line 1522
  *((__be16 *)__d___15) = tmp___46;
#line 1522
  goto ldv_28567;
  case 4: 
#line 1522
  tmp___47 = __fswab32((__u32 )param->mc_hash_sz);
#line 1522
  *((__be32 *)__d___15) = tmp___47;
#line 1522
  goto ldv_28567;
  case 8: 
#line 1522
  tmp___48 = __fswab64((__u64 )param->mc_hash_sz);
#line 1522
  *((__be64 *)__d___15) = tmp___48;
#line 1522
  goto ldv_28567;
  default: 
#line 1522
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28567: 
#line 1523
  __d___16 = (void *)inbox + 219U;
#line 1523
  switch (1UL) {
  case 1: 
#line 1523
  *((u8 *)__d___16) = param->log_mc_table_sz;
#line 1523
  goto ldv_28574;
  case 2: 
#line 1523
  tmp___49 = __fswab16((int )param->log_mc_table_sz);
#line 1523
  *((__be16 *)__d___16) = tmp___49;
#line 1523
  goto ldv_28574;
  case 4: 
#line 1523
  tmp___50 = __fswab32((__u32 )param->log_mc_table_sz);
#line 1523
  *((__be32 *)__d___16) = tmp___50;
#line 1523
  goto ldv_28574;
  case 8: 
#line 1523
  tmp___51 = __fswab64((__u64 )param->log_mc_table_sz);
#line 1523
  *((__be64 *)__d___16) = tmp___51;
#line 1523
  goto ldv_28574;
  default: 
#line 1523
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28574: 
#line 1527
  __d___17 = (void *)inbox + 240U;
#line 1527
  switch (8UL) {
  case 1: 
#line 1527
  *((u8 *)__d___17) = (u8 )param->mpt_base;
#line 1527
  goto ldv_28581;
  case 2: 
#line 1527
  tmp___52 = __fswab16((int )((__u16 )param->mpt_base));
#line 1527
  *((__be16 *)__d___17) = tmp___52;
#line 1527
  goto ldv_28581;
  case 4: 
#line 1527
  tmp___53 = __fswab32((__u32 )param->mpt_base);
#line 1527
  *((__be32 *)__d___17) = tmp___53;
#line 1527
  goto ldv_28581;
  case 8: 
#line 1527
  tmp___54 = __fswab64(param->mpt_base);
#line 1527
  *((__be64 *)__d___17) = tmp___54;
#line 1527
  goto ldv_28581;
  default: 
#line 1527
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28581: 
#line 1528
  tmp___58 = mthca_is_memfree(dev);
#line 1528
  if (tmp___58 == 0) {
#line 1529
    __d___18 = (void *)inbox + 249U;
#line 1529
    switch (1UL) {
    case 1: 
#line 1529
    *((u8 *)__d___18) = param->mtt_seg_sz;
#line 1529
    goto ldv_28588;
    case 2: 
#line 1529
    tmp___55 = __fswab16((int )param->mtt_seg_sz);
#line 1529
    *((__be16 *)__d___18) = tmp___55;
#line 1529
    goto ldv_28588;
    case 4: 
#line 1529
    tmp___56 = __fswab32((__u32 )param->mtt_seg_sz);
#line 1529
    *((__be32 *)__d___18) = tmp___56;
#line 1529
    goto ldv_28588;
    case 8: 
#line 1529
    tmp___57 = __fswab64((__u64 )param->mtt_seg_sz);
#line 1529
    *((__be64 *)__d___18) = tmp___57;
#line 1529
    goto ldv_28588;
    default: 
#line 1529
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28588: ;
  } else {

  }
#line 1530
  __d___19 = (void *)inbox + 251U;
#line 1530
  switch (1UL) {
  case 1: 
#line 1530
  *((u8 *)__d___19) = param->log_mpt_sz;
#line 1530
  goto ldv_28595;
  case 2: 
#line 1530
  tmp___59 = __fswab16((int )param->log_mpt_sz);
#line 1530
  *((__be16 *)__d___19) = tmp___59;
#line 1530
  goto ldv_28595;
  case 4: 
#line 1530
  tmp___60 = __fswab32((__u32 )param->log_mpt_sz);
#line 1530
  *((__be32 *)__d___19) = tmp___60;
#line 1530
  goto ldv_28595;
  case 8: 
#line 1530
  tmp___61 = __fswab64((__u64 )param->log_mpt_sz);
#line 1530
  *((__be64 *)__d___19) = tmp___61;
#line 1530
  goto ldv_28595;
  default: 
#line 1530
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28595: 
#line 1531
  __d___20 = (void *)inbox + 256U;
#line 1531
  switch (8UL) {
  case 1: 
#line 1531
  *((u8 *)__d___20) = (u8 )param->mtt_base;
#line 1531
  goto ldv_28602;
  case 2: 
#line 1531
  tmp___62 = __fswab16((int )((__u16 )param->mtt_base));
#line 1531
  *((__be16 *)__d___20) = tmp___62;
#line 1531
  goto ldv_28602;
  case 4: 
#line 1531
  tmp___63 = __fswab32((__u32 )param->mtt_base);
#line 1531
  *((__be32 *)__d___20) = tmp___63;
#line 1531
  goto ldv_28602;
  case 8: 
#line 1531
  tmp___64 = __fswab64(param->mtt_base);
#line 1531
  *((__be64 *)__d___20) = tmp___64;
#line 1531
  goto ldv_28602;
  default: 
#line 1531
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28602: 
#line 1535
  uar_page_sz = 0U;
#line 1536
  __d___21 = (void *)inbox + 299U;
#line 1536
  switch (1UL) {
  case 1: 
#line 1536
  *((u8 *)__d___21) = uar_page_sz;
#line 1536
  goto ldv_28610;
  case 2: 
#line 1536
  tmp___65 = __fswab16((int )uar_page_sz);
#line 1536
  *((__be16 *)__d___21) = tmp___65;
#line 1536
  goto ldv_28610;
  case 4: 
#line 1536
  tmp___66 = __fswab32((__u32 )uar_page_sz);
#line 1536
  *((__be32 *)__d___21) = tmp___66;
#line 1536
  goto ldv_28610;
  case 8: 
#line 1536
  tmp___67 = __fswab64((__u64 )uar_page_sz);
#line 1536
  *((__be64 *)__d___21) = tmp___67;
#line 1536
  goto ldv_28610;
  default: 
#line 1536
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28610: 
#line 1539
  __d___22 = (void *)inbox + 304U;
#line 1539
  switch (8UL) {
  case 1: 
#line 1539
  *((u8 *)__d___22) = (u8 )param->uar_scratch_base;
#line 1539
  goto ldv_28617;
  case 2: 
#line 1539
  tmp___68 = __fswab16((int )((__u16 )param->uar_scratch_base));
#line 1539
  *((__be16 *)__d___22) = tmp___68;
#line 1539
  goto ldv_28617;
  case 4: 
#line 1539
  tmp___69 = __fswab32((__u32 )param->uar_scratch_base);
#line 1539
  *((__be32 *)__d___22) = tmp___69;
#line 1539
  goto ldv_28617;
  case 8: 
#line 1539
  tmp___70 = __fswab64(param->uar_scratch_base);
#line 1539
  *((__be64 *)__d___22) = tmp___70;
#line 1539
  goto ldv_28617;
  default: 
#line 1539
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28617: 
#line 1541
  tmp___80 = mthca_is_memfree(dev);
#line 1541
  if (tmp___80 != 0) {
#line 1542
    __d___23 = (void *)inbox + 297U;
#line 1542
    switch (1UL) {
    case 1: 
#line 1542
    *((u8 *)__d___23) = param->log_uarc_sz;
#line 1542
    goto ldv_28624;
    case 2: 
#line 1542
    tmp___71 = __fswab16((int )param->log_uarc_sz);
#line 1542
    *((__be16 *)__d___23) = tmp___71;
#line 1542
    goto ldv_28624;
    case 4: 
#line 1542
    tmp___72 = __fswab32((__u32 )param->log_uarc_sz);
#line 1542
    *((__be32 *)__d___23) = tmp___72;
#line 1542
    goto ldv_28624;
    case 8: 
#line 1542
    tmp___73 = __fswab64((__u64 )param->log_uarc_sz);
#line 1542
    *((__be64 *)__d___23) = tmp___73;
#line 1542
    goto ldv_28624;
    default: 
#line 1542
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28624: 
#line 1543
    __d___24 = (void *)inbox + 298U;
#line 1543
    switch (1UL) {
    case 1: 
#line 1543
    *((u8 *)__d___24) = param->log_uar_sz;
#line 1543
    goto ldv_28631;
    case 2: 
#line 1543
    tmp___74 = __fswab16((int )param->log_uar_sz);
#line 1543
    *((__be16 *)__d___24) = tmp___74;
#line 1543
    goto ldv_28631;
    case 4: 
#line 1543
    tmp___75 = __fswab32((__u32 )param->log_uar_sz);
#line 1543
    *((__be32 *)__d___24) = tmp___75;
#line 1543
    goto ldv_28631;
    case 8: 
#line 1543
    tmp___76 = __fswab64((__u64 )param->log_uar_sz);
#line 1543
    *((__be64 *)__d___24) = tmp___76;
#line 1543
    goto ldv_28631;
    default: 
#line 1543
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28631: 
#line 1544
    __d___25 = (void *)inbox + 312U;
#line 1544
    switch (8UL) {
    case 1: 
#line 1544
    *((u8 *)__d___25) = (u8 )param->uarc_base;
#line 1544
    goto ldv_28638;
    case 2: 
#line 1544
    tmp___77 = __fswab16((int )((__u16 )param->uarc_base));
#line 1544
    *((__be16 *)__d___25) = tmp___77;
#line 1544
    goto ldv_28638;
    case 4: 
#line 1544
    tmp___78 = __fswab32((__u32 )param->uarc_base);
#line 1544
    *((__be32 *)__d___25) = tmp___78;
#line 1544
    goto ldv_28638;
    case 8: 
#line 1544
    tmp___79 = __fswab64(param->uarc_base);
#line 1544
    *((__be64 *)__d___25) = tmp___79;
#line 1544
    goto ldv_28638;
    default: 
#line 1544
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28638: ;
  } else {

  }
#line 1547
  err = mthca_cmd(dev, mailbox->dma, 0U, 0, 7, 15000UL);
#line 1550
  mthca_free_mailbox(dev, mailbox);
#line 1551
  return (err);
}
}
#line 1554 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_INIT_IB(struct mthca_dev *dev , struct mthca_init_ib_param *param , int port ) 
{ struct mthca_mailbox *mailbox ;
  u32 *inbox ;
  int err ;
  u32 flags ;
  long tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  void *__d ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;
  void *__d___0 ;
  __u16 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  void *__d___1 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u64 tmp___12 ;
  void *__d___2 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__d___3 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__d___4 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;

  {
#line 1577
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1578
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1578
  if (tmp___0 != 0L) {
#line 1579
    tmp = PTR_ERR((void const   *)mailbox);
#line 1579
    return ((int )tmp);
  } else {

  }
#line 1580
  inbox = (u32 *)mailbox->buf;
#line 1582
  memset((void *)inbox, 0, 56UL);
#line 1584
  flags = 0U;
#line 1585
  if (param->set_guid0 != 0) {
#line 1585
    tmp___1 = 65536U;
  } else {
#line 1585
    tmp___1 = 0U;
  }
#line 1585
  flags = tmp___1 | flags;
#line 1586
  if (param->set_node_guid != 0) {
#line 1586
    tmp___2 = 131072U;
  } else {
#line 1586
    tmp___2 = 0U;
  }
#line 1586
  flags = tmp___2 | flags;
#line 1587
  if (param->set_si_guid != 0) {
#line 1587
    tmp___3 = 262144U;
  } else {
#line 1587
    tmp___3 = 0U;
  }
#line 1587
  flags = tmp___3 | flags;
#line 1588
  flags = (u32 )(param->vl_cap << 4) | flags;
#line 1589
  flags = (u32 )(param->port_width << 8) | flags;
#line 1590
  flags = (u32 )(param->mtu_cap << 12) | flags;
#line 1591
  __d = (void *)inbox;
#line 1591
  switch (4UL) {
  case 1: 
#line 1591
  *((u8 *)__d) = (u8 )flags;
#line 1591
  goto ldv_28654;
  case 2: 
#line 1591
  tmp___4 = __fswab16((int )((__u16 )flags));
#line 1591
  *((__be16 *)__d) = tmp___4;
#line 1591
  goto ldv_28654;
  case 4: 
#line 1591
  tmp___5 = __fswab32(flags);
#line 1591
  *((__be32 *)__d) = tmp___5;
#line 1591
  goto ldv_28654;
  case 8: 
#line 1591
  tmp___6 = __fswab64((__u64 )flags);
#line 1591
  *((__be64 *)__d) = tmp___6;
#line 1591
  goto ldv_28654;
  default: 
#line 1591
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28654: 
#line 1593
  __d___0 = (void *)inbox + 6U;
#line 1593
  switch (2UL) {
  case 1: 
#line 1593
  *((u8 *)__d___0) = (u8 )param->gid_cap;
#line 1593
  goto ldv_28661;
  case 2: 
#line 1593
  tmp___7 = __fswab16((int )param->gid_cap);
#line 1593
  *((__be16 *)__d___0) = tmp___7;
#line 1593
  goto ldv_28661;
  case 4: 
#line 1593
  tmp___8 = __fswab32((__u32 )param->gid_cap);
#line 1593
  *((__be32 *)__d___0) = tmp___8;
#line 1593
  goto ldv_28661;
  case 8: 
#line 1593
  tmp___9 = __fswab64((__u64 )param->gid_cap);
#line 1593
  *((__be64 *)__d___0) = tmp___9;
#line 1593
  goto ldv_28661;
  default: 
#line 1593
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28661: 
#line 1594
  __d___1 = (void *)inbox + 10U;
#line 1594
  switch (2UL) {
  case 1: 
#line 1594
  *((u8 *)__d___1) = (u8 )param->pkey_cap;
#line 1594
  goto ldv_28668;
  case 2: 
#line 1594
  tmp___10 = __fswab16((int )param->pkey_cap);
#line 1594
  *((__be16 *)__d___1) = tmp___10;
#line 1594
  goto ldv_28668;
  case 4: 
#line 1594
  tmp___11 = __fswab32((__u32 )param->pkey_cap);
#line 1594
  *((__be32 *)__d___1) = tmp___11;
#line 1594
  goto ldv_28668;
  case 8: 
#line 1594
  tmp___12 = __fswab64((__u64 )param->pkey_cap);
#line 1594
  *((__be64 *)__d___1) = tmp___12;
#line 1594
  goto ldv_28668;
  default: 
#line 1594
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28668: 
#line 1595
  __d___2 = (void *)inbox + 16U;
#line 1595
  switch (8UL) {
  case 1: 
#line 1595
  *((u8 *)__d___2) = (u8 )param->guid0;
#line 1595
  goto ldv_28675;
  case 2: 
#line 1595
  tmp___13 = __fswab16((int )((__u16 )param->guid0));
#line 1595
  *((__be16 *)__d___2) = tmp___13;
#line 1595
  goto ldv_28675;
  case 4: 
#line 1595
  tmp___14 = __fswab32((__u32 )param->guid0);
#line 1595
  *((__be32 *)__d___2) = tmp___14;
#line 1595
  goto ldv_28675;
  case 8: 
#line 1595
  tmp___15 = __fswab64(param->guid0);
#line 1595
  *((__be64 *)__d___2) = tmp___15;
#line 1595
  goto ldv_28675;
  default: 
#line 1595
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28675: 
#line 1596
  __d___3 = (void *)inbox + 24U;
#line 1596
  switch (8UL) {
  case 1: 
#line 1596
  *((u8 *)__d___3) = (u8 )param->node_guid;
#line 1596
  goto ldv_28682;
  case 2: 
#line 1596
  tmp___16 = __fswab16((int )((__u16 )param->node_guid));
#line 1596
  *((__be16 *)__d___3) = tmp___16;
#line 1596
  goto ldv_28682;
  case 4: 
#line 1596
  tmp___17 = __fswab32((__u32 )param->node_guid);
#line 1596
  *((__be32 *)__d___3) = tmp___17;
#line 1596
  goto ldv_28682;
  case 8: 
#line 1596
  tmp___18 = __fswab64(param->node_guid);
#line 1596
  *((__be64 *)__d___3) = tmp___18;
#line 1596
  goto ldv_28682;
  default: 
#line 1596
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28682: 
#line 1597
  __d___4 = (void *)inbox + 32U;
#line 1597
  switch (8UL) {
  case 1: 
#line 1597
  *((u8 *)__d___4) = (u8 )param->si_guid;
#line 1597
  goto ldv_28689;
  case 2: 
#line 1597
  tmp___19 = __fswab16((int )((__u16 )param->si_guid));
#line 1597
  *((__be16 *)__d___4) = tmp___19;
#line 1597
  goto ldv_28689;
  case 4: 
#line 1597
  tmp___20 = __fswab32((__u32 )param->si_guid);
#line 1597
  *((__be32 *)__d___4) = tmp___20;
#line 1597
  goto ldv_28689;
  case 8: 
#line 1597
  tmp___21 = __fswab64(param->si_guid);
#line 1597
  *((__be64 *)__d___4) = tmp___21;
#line 1597
  goto ldv_28689;
  default: 
#line 1597
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28689: 
#line 1599
  err = mthca_cmd(dev, mailbox->dma, (u32 )port, 0, 9, 15000UL);
#line 1602
  mthca_free_mailbox(dev, mailbox);
#line 1603
  return (err);
}
}
#line 1606 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_CLOSE_IB(struct mthca_dev *dev , int port ) 
{ int tmp ;

  {
#line 1608
  tmp = mthca_cmd(dev, 0ULL, (u32 )port, 0, 10, 15000UL);
#line 1608
  return (tmp);
}
}
#line 1611 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_CLOSE_HCA(struct mthca_dev *dev , int panic___0 ) 
{ int tmp ;

  {
#line 1613
  tmp = mthca_cmd(dev, 0ULL, 0U, (int )((u8 )panic___0), 8, 15000UL);
#line 1613
  return (tmp);
}
}
#line 1616 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SET_IB(struct mthca_dev *dev , struct mthca_set_ib_param *param , int port ) 
{ struct mthca_mailbox *mailbox ;
  u32 *inbox ;
  int err ;
  u32 flags ;
  long tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  void *__d ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  __u64 tmp___5 ;
  void *__d___0 ;
  __u16 tmp___6 ;
  __u32 tmp___7 ;
  __u64 tmp___8 ;
  void *__d___1 ;
  __u16 tmp___9 ;
  __u32 tmp___10 ;
  __u64 tmp___11 ;

  {
#line 1622
  flags = 0U;
#line 1631
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1632
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1632
  if (tmp___0 != 0L) {
#line 1633
    tmp = PTR_ERR((void const   *)mailbox);
#line 1633
    return ((int )tmp);
  } else {

  }
#line 1634
  inbox = (u32 *)mailbox->buf;
#line 1636
  memset((void *)inbox, 0, 64UL);
#line 1638
  if (param->set_si_guid != 0) {
#line 1638
    tmp___1 = 262144U;
  } else {
#line 1638
    tmp___1 = 0U;
  }
#line 1638
  flags = tmp___1 | flags;
#line 1639
  if (param->reset_qkey_viol != 0) {
#line 1639
    tmp___2 = 1U;
  } else {
#line 1639
    tmp___2 = 0U;
  }
#line 1639
  flags = tmp___2 | flags;
#line 1640
  __d = (void *)inbox;
#line 1640
  switch (4UL) {
  case 1: 
#line 1640
  *((u8 *)__d) = (u8 )flags;
#line 1640
  goto ldv_28713;
  case 2: 
#line 1640
  tmp___3 = __fswab16((int )((__u16 )flags));
#line 1640
  *((__be16 *)__d) = tmp___3;
#line 1640
  goto ldv_28713;
  case 4: 
#line 1640
  tmp___4 = __fswab32(flags);
#line 1640
  *((__be32 *)__d) = tmp___4;
#line 1640
  goto ldv_28713;
  case 8: 
#line 1640
  tmp___5 = __fswab64((__u64 )flags);
#line 1640
  *((__be64 *)__d) = tmp___5;
#line 1640
  goto ldv_28713;
  default: 
#line 1640
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28713: 
#line 1642
  __d___0 = (void *)inbox + 4U;
#line 1642
  switch (4UL) {
  case 1: 
#line 1642
  *((u8 *)__d___0) = (u8 )param->cap_mask;
#line 1642
  goto ldv_28720;
  case 2: 
#line 1642
  tmp___6 = __fswab16((int )((__u16 )param->cap_mask));
#line 1642
  *((__be16 *)__d___0) = tmp___6;
#line 1642
  goto ldv_28720;
  case 4: 
#line 1642
  tmp___7 = __fswab32(param->cap_mask);
#line 1642
  *((__be32 *)__d___0) = tmp___7;
#line 1642
  goto ldv_28720;
  case 8: 
#line 1642
  tmp___8 = __fswab64((__u64 )param->cap_mask);
#line 1642
  *((__be64 *)__d___0) = tmp___8;
#line 1642
  goto ldv_28720;
  default: 
#line 1642
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28720: 
#line 1643
  __d___1 = (void *)inbox + 8U;
#line 1643
  switch (8UL) {
  case 1: 
#line 1643
  *((u8 *)__d___1) = (u8 )param->si_guid;
#line 1643
  goto ldv_28727;
  case 2: 
#line 1643
  tmp___9 = __fswab16((int )((__u16 )param->si_guid));
#line 1643
  *((__be16 *)__d___1) = tmp___9;
#line 1643
  goto ldv_28727;
  case 4: 
#line 1643
  tmp___10 = __fswab32((__u32 )param->si_guid);
#line 1643
  *((__be32 *)__d___1) = tmp___10;
#line 1643
  goto ldv_28727;
  case 8: 
#line 1643
  tmp___11 = __fswab64(param->si_guid);
#line 1643
  *((__be64 *)__d___1) = tmp___11;
#line 1643
  goto ldv_28727;
  default: 
#line 1643
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28727: 
#line 1645
  err = mthca_cmd(dev, mailbox->dma, (u32 )port, 0, 12, 15000UL);
#line 1648
  mthca_free_mailbox(dev, mailbox);
#line 1649
  return (err);
}
}
#line 1652 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAP_ICM(struct mthca_dev *dev , struct mthca_icm *icm , u64 virt ) 
{ int tmp ;

  {
#line 1654
  tmp = mthca_map_cmd(dev, 4090, icm, virt);
#line 1654
  return (tmp);
}
}
#line 1657 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAP_ICM_page(struct mthca_dev *dev , u64 dma_addr , u64 virt ) 
{ struct mthca_mailbox *mailbox ;
  __be64 *inbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;

  {
#line 1663
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1664
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1664
  if (tmp___0 != 0L) {
#line 1665
    tmp = PTR_ERR((void const   *)mailbox);
#line 1665
    return ((int )tmp);
  } else {

  }
#line 1666
  inbox = (__be64 *)mailbox->buf;
#line 1668
  tmp___1 = __fswab64(virt);
#line 1668
  *inbox = tmp___1;
#line 1669
  tmp___2 = __fswab64(dma_addr);
#line 1669
  *(inbox + 1UL) = tmp___2;
#line 1671
  err = mthca_cmd(dev, mailbox->dma, 1U, 0, 4090, 15000UL);
#line 1674
  mthca_free_mailbox(dev, mailbox);
#line 1676
  if (err == 0) {
#line 1677
    if (mthca_debug_level != 0) {
#line 1677
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Mapped page at %llx to %llx for ICM.\n",
                 dma_addr, virt);
    } else {

    }
  } else {

  }
#line 1680
  return (err);
}
}
#line 1683 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_UNMAP_ICM(struct mthca_dev *dev , u64 virt , u32 page_count___0 ) 
{ int tmp ;

  {
#line 1685
  if (mthca_debug_level != 0) {
#line 1685
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Unmapping %d pages at %llx from ICM.\n",
               page_count___0, virt);
  } else {

  }
#line 1688
  tmp = mthca_cmd(dev, virt, page_count___0, 0, 4089, 15000UL);
#line 1688
  return (tmp);
}
}
#line 1692 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAP_ICM_AUX(struct mthca_dev *dev , struct mthca_icm *icm ) 
{ int tmp ;

  {
#line 1694
  tmp = mthca_map_cmd(dev, 4092, icm, 0xffffffffffffffffULL);
#line 1694
  return (tmp);
}
}
#line 1697 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 1699
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 4091, 15000UL);
#line 1699
  return (tmp);
}
}
#line 1702 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SET_ICM_SIZE(struct mthca_dev *dev , u64 icm_size , u64 *aux_pages ) 
{ int ret ;
  int tmp ;

  {
#line 1704
  tmp = mthca_cmd_imm(dev, icm_size, aux_pages, 0U, 0, 4093, 15000UL);
#line 1704
  ret = tmp;
#line 1707
  if (ret != 0) {
#line 1708
    return (ret);
  } else {

  }
#line 1714
  *aux_pages = *aux_pages;
#line 1717
  return (0);
}
}
#line 1720 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SW2HW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) 
{ int tmp ;

  {
#line 1723
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )mpt_index, 0, 13, 15000UL);
#line 1723
  return (tmp);
}
}
#line 1727 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_HW2SW_MPT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int mpt_index ) 
{ dma_addr_t tmp ;
  int tmp___0 ;

  {
#line 1730
  if ((unsigned long )mailbox != (unsigned long )((struct mthca_mailbox *)0)) {
#line 1730
    tmp = mailbox->dma;
  } else {
#line 1730
    tmp = 0ULL;
  }
#line 1730
  tmp___0 = mthca_cmd_box(dev, 0ULL, tmp, (u32 )mpt_index, (unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0),
                          15, 15000UL);
#line 1730
  return (tmp___0);
}
}
#line 1735 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_WRITE_MTT(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int num_mtt ) 
{ int tmp ;

  {
#line 1738
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )num_mtt, 0, 17, 15000UL);
#line 1738
  return (tmp);
}
}
#line 1742 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SYNC_TPT(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 1744
  tmp = mthca_cmd(dev, 0ULL, 0U, 0, 47, 15000UL);
#line 1744
  return (tmp);
}
}
#line 1747 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAP_EQ(struct mthca_dev *dev , u64 event_mask , int unmap , int eq_num ) 
{ char *tmp ;
  int tmp___0 ;

  {
#line 1750
  if (mthca_debug_level != 0) {
#line 1750
    if (unmap != 0) {
#line 1750
      tmp = (char *)"Clearing";
    } else {
#line 1750
      tmp = (char *)"Setting";
    }
#line 1750
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "%s mask %016llx for eqn %d\n",
               tmp, event_mask, eq_num);
  } else {

  }
#line 1753
  tmp___0 = mthca_cmd(dev, event_mask, (u32 )((unmap << 31) | eq_num), 0, 18, 15000UL);
#line 1753
  return (tmp___0);
}
}
#line 1757 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SW2HW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) 
{ int tmp ;

  {
#line 1760
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )eq_num, 0, 19, 15000UL);
#line 1760
  return (tmp);
}
}
#line 1764 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_HW2SW_EQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int eq_num ) 
{ int tmp ;

  {
#line 1767
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )eq_num, 0, 20, 15000UL);
#line 1767
  return (tmp);
}
}
#line 1772 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SW2HW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) 
{ int tmp ;

  {
#line 1775
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )cq_num, 0, 22, 15000UL);
#line 1775
  return (tmp);
}
}
#line 1779 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_HW2SW_CQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int cq_num ) 
{ int tmp ;

  {
#line 1782
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )cq_num, 0, 23, 15000UL);
#line 1782
  return (tmp);
}
}
#line 1787 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_RESIZE_CQ(struct mthca_dev *dev , int cq_num , u32 lkey , u8 log_size ) 
{ struct mthca_mailbox *mailbox ;
  __be32 *inbox ;
  int err ;
  long tmp ;
  long tmp___0 ;
  void *__d ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u64 tmp___3 ;
  void *__d___0 ;
  __u16 tmp___4 ;
  __u32 tmp___5 ;
  __u64 tmp___6 ;

  {
#line 1797
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1798
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 1798
  if (tmp___0 != 0L) {
#line 1799
    tmp = PTR_ERR((void const   *)mailbox);
#line 1799
    return ((int )tmp);
  } else {

  }
#line 1800
  inbox = (__be32 *)mailbox->buf;
#line 1802
  memset((void *)inbox, 0, 64UL);
#line 1807
  __d = (void *)inbox + 12U;
#line 1807
  switch (1UL) {
  case 1: 
#line 1807
  *((u8 *)__d) = log_size;
#line 1807
  goto ldv_28818;
  case 2: 
#line 1807
  tmp___1 = __fswab16((int )log_size);
#line 1807
  *((__be16 *)__d) = tmp___1;
#line 1807
  goto ldv_28818;
  case 4: 
#line 1807
  tmp___2 = __fswab32((__u32 )log_size);
#line 1807
  *((__be32 *)__d) = tmp___2;
#line 1807
  goto ldv_28818;
  case 8: 
#line 1807
  tmp___3 = __fswab64((__u64 )log_size);
#line 1807
  *((__be64 *)__d) = tmp___3;
#line 1807
  goto ldv_28818;
  default: 
#line 1807
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28818: 
#line 1808
  __d___0 = (void *)inbox + 28U;
#line 1808
  switch (4UL) {
  case 1: 
#line 1808
  *((u8 *)__d___0) = (u8 )lkey;
#line 1808
  goto ldv_28825;
  case 2: 
#line 1808
  tmp___4 = __fswab16((int )((__u16 )lkey));
#line 1808
  *((__be16 *)__d___0) = tmp___4;
#line 1808
  goto ldv_28825;
  case 4: 
#line 1808
  tmp___5 = __fswab32(lkey);
#line 1808
  *((__be32 *)__d___0) = tmp___5;
#line 1808
  goto ldv_28825;
  case 8: 
#line 1808
  tmp___6 = __fswab64((__u64 )lkey);
#line 1808
  *((__be64 *)__d___0) = tmp___6;
#line 1808
  goto ldv_28825;
  default: 
#line 1808
  __buggy_use_of_MTHCA_PUT();
  }
  ldv_28825: 
#line 1810
  err = mthca_cmd(dev, mailbox->dma, (u32 )cq_num, 1, 44, 15000UL);
#line 1813
  mthca_free_mailbox(dev, mailbox);
#line 1814
  return (err);
}
}
#line 1817 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_SW2HW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) 
{ int tmp ;

  {
#line 1820
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )srq_num, 0, 53, 15000UL);
#line 1820
  return (tmp);
}
}
#line 1824 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_HW2SW_SRQ(struct mthca_dev *dev , struct mthca_mailbox *mailbox , int srq_num ) 
{ int tmp ;

  {
#line 1827
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )srq_num, 0, 54, 15000UL);
#line 1827
  return (tmp);
}
}
#line 1832 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_SRQ(struct mthca_dev *dev , u32 num , struct mthca_mailbox *mailbox ) 
{ int tmp ;

  {
#line 1835
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, num, 0, 55, 15000UL);
#line 1835
  return (tmp);
}
}
#line 1839 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_ARM_SRQ(struct mthca_dev *dev , int srq_num , int limit ) 
{ int tmp ;

  {
#line 1841
  tmp = mthca_cmd(dev, (u64 )limit, (u32 )srq_num, 0, 64, 15000UL);
#line 1841
  return (tmp);
}
}
#line 1845 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MODIFY_QP(struct mthca_dev *dev , enum ib_qp_state cur , enum ib_qp_state next ,
                    u32 num , int is_ee , struct mthca_mailbox *mailbox , u32 optmask ) 
{ u16 op[7U][7U] ;
  u8 op_mod ;
  int my_mailbox ;
  int err ;
  long tmp ;
  unsigned int tmp___0 ;
  dma_addr_t tmp___1 ;
  int i ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  int i___0 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 1849
  op[0][0] = 33U;
#line 1849
  op[0][1] = 25U;
#line 1849
  op[0][2] = (unsigned short)0;
#line 1849
  op[0][3] = (unsigned short)0;
#line 1849
  op[0][4] = (unsigned short)0;
#line 1849
  op[0][5] = (unsigned short)0;
#line 1849
  op[0][6] = 30U;
#line 1849
  op[1][0] = 33U;
#line 1849
  op[1][1] = 45U;
#line 1849
  op[1][2] = 26U;
#line 1849
  op[1][3] = (unsigned short)0;
#line 1849
  op[1][4] = (unsigned short)0;
#line 1849
  op[1][5] = (unsigned short)0;
#line 1849
  op[1][6] = 30U;
#line 1849
  op[2][0] = 33U;
#line 1849
  op[2][1] = (unsigned short)0;
#line 1849
  op[2][2] = (unsigned short)0;
#line 1849
  op[2][3] = 27U;
#line 1849
  op[2][4] = (unsigned short)0;
#line 1849
  op[2][5] = (unsigned short)0;
#line 1849
  op[2][6] = 30U;
#line 1849
  op[3][0] = 33U;
#line 1849
  op[3][1] = (unsigned short)0;
#line 1849
  op[3][2] = (unsigned short)0;
#line 1849
  op[3][3] = 28U;
#line 1849
  op[3][4] = 31U;
#line 1849
  op[3][5] = (unsigned short)0;
#line 1849
  op[3][6] = 30U;
#line 1849
  op[4][0] = 33U;
#line 1849
  op[4][1] = (unsigned short)0;
#line 1849
  op[4][2] = (unsigned short)0;
#line 1849
  op[4][3] = 32U;
#line 1849
  op[4][4] = 56U;
#line 1849
  op[4][5] = (unsigned short)0;
#line 1849
  op[4][6] = 30U;
#line 1849
  op[5][0] = 33U;
#line 1849
  op[5][1] = (unsigned short)0;
#line 1849
  op[5][2] = (unsigned short)0;
#line 1849
  op[5][3] = 29U;
#line 1849
  op[5][4] = (unsigned short)0;
#line 1849
  op[5][5] = (unsigned short)0;
#line 1849
  op[5][6] = 30U;
#line 1849
  op[6][0] = 33U;
#line 1849
  op[6][1] = (unsigned short)0;
#line 1849
  op[6][2] = (unsigned short)0;
#line 1849
  op[6][3] = (unsigned short)0;
#line 1849
  op[6][4] = (unsigned short)0;
#line 1849
  op[6][5] = (unsigned short)0;
#line 1849
  op[6][6] = 30U;
#line 1889
  op_mod = 0U;
#line 1890
  my_mailbox = 0;
#line 1893
  if ((unsigned int )op[(unsigned int )cur][(unsigned int )next] == 33U) {
#line 1894
    op_mod = 3U;
#line 1897
    if ((unsigned long )mailbox == (unsigned long )((struct mthca_mailbox *)0)) {
#line 1898
      mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1899
      tmp = IS_ERR((void const   *)mailbox);
#line 1899
      if (tmp == 0L) {
#line 1900
        my_mailbox = 1;
#line 1901
        op_mod = 2U;
      } else {
#line 1903
        mailbox = 0;
      }
    } else {

    }
#line 1906
    if (is_ee != 0) {
#line 1906
      tmp___0 = 16777216U;
    } else {
#line 1906
      tmp___0 = 0U;
    }
#line 1906
    if ((unsigned long )mailbox != (unsigned long )((struct mthca_mailbox *)0)) {
#line 1906
      tmp___1 = mailbox->dma;
    } else {
#line 1906
      tmp___1 = 0ULL;
    }
#line 1906
    err = mthca_cmd_box(dev, 0ULL, tmp___1, tmp___0 | num, (int )op_mod, (int )op[(unsigned int )cur][(unsigned int )next],
                        15000UL);
#line 1910
    if (0) {
#line 1912
      if (mthca_debug_level != 0) {
#line 1912
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping QP context:\n");
      } else {

      }
#line 1913
      tmp___2 = __be32_to_cpup((__be32 const   *)mailbox->buf);
#line 1913
      printk(" %08x\n", tmp___2);
#line 1914
      i = 0;
#line 1914
      goto ldv_28865;
      ldv_28864: ;
#line 1915
      if (((unsigned int )i & 7U) == 0U) {
#line 1916
        printk("[%02x] ", i * 4);
      } else {

      }
#line 1917
      tmp___3 = __fswab32(*((__be32 *)mailbox->buf + ((unsigned long )i + 2UL)));
#line 1917
      printk(" %08x", tmp___3);
#line 1919
      if (((unsigned int )(i + 1) & 7U) == 0U) {
#line 1920
        printk("\n");
      } else {

      }
#line 1914
      i = i + 1;
      ldv_28865: ;
#line 1914
      if (i <= 63) {
#line 1915
        goto ldv_28864;
      } else {
#line 1917
        goto ldv_28866;
      }
      ldv_28866: ;
    } else {

    }
#line 1924
    if (my_mailbox != 0) {
#line 1925
      mthca_free_mailbox(dev, mailbox);
    } else {

    }
  } else {
#line 1927
    if (0) {
#line 1929
      if (mthca_debug_level != 0) {
#line 1929
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping QP context:\n");
      } else {

      }
#line 1930
      tmp___4 = __be32_to_cpup((__be32 const   *)mailbox->buf);
#line 1930
      printk("  opt param mask: %08x\n", tmp___4);
#line 1931
      i___0 = 0;
#line 1931
      goto ldv_28869;
      ldv_28868: ;
#line 1932
      if (((unsigned int )i___0 & 7U) == 0U) {
#line 1933
        printk("  [%02x] ", i___0 * 4);
      } else {

      }
#line 1934
      tmp___5 = __fswab32(*((__be32 *)mailbox->buf + ((unsigned long )i___0 + 2UL)));
#line 1934
      printk(" %08x", tmp___5);
#line 1936
      if (((unsigned int )(i___0 + 1) & 7U) == 0U) {
#line 1937
        printk("\n");
      } else {

      }
#line 1931
      i___0 = i___0 + 1;
      ldv_28869: ;
#line 1931
      if (i___0 <= 63) {
#line 1932
        goto ldv_28868;
      } else {
#line 1934
        goto ldv_28870;
      }
      ldv_28870: ;
    } else {

    }
#line 1941
    if (is_ee != 0) {
#line 1941
      tmp___6 = 16777216U;
    } else {
#line 1941
      tmp___6 = 0U;
    }
#line 1941
    err = mthca_cmd(dev, mailbox->dma, (tmp___6 | optmask) | num, (int )op_mod, (int )op[(unsigned int )cur][(unsigned int )next],
                    15000UL);
  }
#line 1945
  return (err);
}
}
#line 1948 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_QUERY_QP(struct mthca_dev *dev , u32 num , int is_ee , struct mthca_mailbox *mailbox ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
#line 1951
  if (is_ee != 0) {
#line 1951
    tmp = 16777216U;
  } else {
#line 1951
    tmp = 0U;
  }
#line 1951
  tmp___0 = mthca_cmd_box(dev, 0ULL, mailbox->dma, tmp | num, 0, 34, 15000UL);
#line 1951
  return (tmp___0);
}
}
#line 1955 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_CONF_SPECIAL_QP(struct mthca_dev *dev , int type , u32 qpn ) 
{ u8 op_mod ;
  int tmp ;

  {
#line 1959
  switch (type) {
  case 0: 
#line 1961
  op_mod = 0U;
#line 1962
  goto ldv_28884;
  case 1: 
#line 1964
  op_mod = 1U;
#line 1965
  goto ldv_28884;
  case 5: 
#line 1967
  op_mod = 2U;
#line 1968
  goto ldv_28884;
  case 6: 
#line 1970
  op_mod = 3U;
#line 1971
  goto ldv_28884;
  default: ;
#line 1973
  return (-22);
  }
  ldv_28884: 
#line 1976
  tmp = mthca_cmd(dev, 0ULL, qpn, (int )op_mod, 35, 15000UL);
#line 1976
  return (tmp);
}
}
#line 1980 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MAD_IFC(struct mthca_dev *dev , int ignore_mkey , int ignore_bkey , int port ,
                  struct ib_wc *in_wc , struct ib_grh *in_grh , void *in_mad , void *response_mad ) 
{ struct mthca_mailbox *inmailbox ;
  struct mthca_mailbox *outmailbox ;
  void *inbox ;
  int err ;
  u32 in_modifier ;
  u8 op_modifier ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  u8 val ;
  void *__d ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  __u64 tmp___5 ;
  void *__d___0 ;
  __u16 tmp___6 ;
  __u32 tmp___7 ;
  __u64 tmp___8 ;
  void *__d___1 ;
  __u16 tmp___9 ;
  __u32 tmp___10 ;
  __u64 tmp___11 ;
  int tmp___12 ;
  void *__d___2 ;
  __u16 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  void *__d___3 ;
  __u16 tmp___16 ;
  __u32 tmp___17 ;
  __u64 tmp___18 ;
  void *__d___4 ;
  __u16 tmp___19 ;
  __u32 tmp___20 ;
  __u64 tmp___21 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1987
  in_modifier = (u32 )port;
#line 1988
  op_modifier = 0U;
#line 1999
  inmailbox = mthca_alloc_mailbox(dev, 208U);
#line 2000
  tmp___0 = IS_ERR((void const   *)inmailbox);
#line 2000
  if (tmp___0 != 0L) {
#line 2001
    tmp = PTR_ERR((void const   *)inmailbox);
#line 2001
    return ((int )tmp);
  } else {

  }
#line 2002
  inbox = inmailbox->buf;
#line 2004
  outmailbox = mthca_alloc_mailbox(dev, 208U);
#line 2005
  tmp___2 = IS_ERR((void const   *)outmailbox);
#line 2005
  if (tmp___2 != 0L) {
#line 2006
    mthca_free_mailbox(dev, inmailbox);
#line 2007
    tmp___1 = PTR_ERR((void const   *)outmailbox);
#line 2007
    return ((int )tmp___1);
  } else {

  }
#line 2010
  __len = 256UL;
#line 2010
  if (__len > 63UL) {
#line 2010
    __ret = __memcpy(inbox, (void const   *)in_mad, __len);
  } else {
#line 2010
    __ret = __builtin_memcpy(inbox, (void const   *)in_mad, __len);
  }
#line 2016
  if (ignore_mkey != 0 || (unsigned long )in_wc == (unsigned long )((struct ib_wc *)0)) {
#line 2017
    op_modifier = (u8 )((unsigned int )op_modifier | 1U);
  } else {

  }
#line 2018
  if (ignore_bkey != 0 || (unsigned long )in_wc == (unsigned long )((struct ib_wc *)0)) {
#line 2019
    op_modifier = (u8 )((unsigned int )op_modifier | 2U);
  } else {

  }
#line 2021
  if ((unsigned long )in_wc != (unsigned long )((struct ib_wc *)0)) {
#line 2024
    memset(inbox + 256UL, 0, 256UL);
#line 2026
    __d = inbox + 256U;
#line 2026
    switch (4UL) {
    case 1: 
#line 2026
    *((u8 *)__d) = (u8 )(in_wc->qp)->qp_num;
#line 2026
    goto ldv_28911;
    case 2: 
#line 2026
    tmp___3 = __fswab16((int )((__u16 )(in_wc->qp)->qp_num));
#line 2026
    *((__be16 *)__d) = tmp___3;
#line 2026
    goto ldv_28911;
    case 4: 
#line 2026
    tmp___4 = __fswab32((in_wc->qp)->qp_num);
#line 2026
    *((__be32 *)__d) = tmp___4;
#line 2026
    goto ldv_28911;
    case 8: 
#line 2026
    tmp___5 = __fswab64((__u64 )(in_wc->qp)->qp_num);
#line 2026
    *((__be64 *)__d) = tmp___5;
#line 2026
    goto ldv_28911;
    default: 
#line 2026
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28911: 
#line 2027
    __d___0 = inbox + 264U;
#line 2027
    switch (4UL) {
    case 1: 
#line 2027
    *((u8 *)__d___0) = (u8 )in_wc->src_qp;
#line 2027
    goto ldv_28918;
    case 2: 
#line 2027
    tmp___6 = __fswab16((int )((__u16 )in_wc->src_qp));
#line 2027
    *((__be16 *)__d___0) = tmp___6;
#line 2027
    goto ldv_28918;
    case 4: 
#line 2027
    tmp___7 = __fswab32(in_wc->src_qp);
#line 2027
    *((__be32 *)__d___0) = tmp___7;
#line 2027
    goto ldv_28918;
    case 8: 
#line 2027
    tmp___8 = __fswab64((__u64 )in_wc->src_qp);
#line 2027
    *((__be64 *)__d___0) = tmp___8;
#line 2027
    goto ldv_28918;
    default: 
#line 2027
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28918: 
#line 2029
    val = (int )in_wc->sl << 4U;
#line 2030
    __d___1 = inbox + 268U;
#line 2030
    switch (1UL) {
    case 1: 
#line 2030
    *((u8 *)__d___1) = val;
#line 2030
    goto ldv_28925;
    case 2: 
#line 2030
    tmp___9 = __fswab16((int )val);
#line 2030
    *((__be16 *)__d___1) = tmp___9;
#line 2030
    goto ldv_28925;
    case 4: 
#line 2030
    tmp___10 = __fswab32((__u32 )val);
#line 2030
    *((__be32 *)__d___1) = tmp___10;
#line 2030
    goto ldv_28925;
    case 8: 
#line 2030
    tmp___11 = __fswab64((__u64 )val);
#line 2030
    *((__be64 *)__d___1) = tmp___11;
#line 2030
    goto ldv_28925;
    default: 
#line 2030
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28925: ;
#line 2032
    if (in_wc->wc_flags & 1) {
#line 2032
      tmp___12 = -128;
    } else {
#line 2032
      tmp___12 = 0;
    }
#line 2032
    val = (u8 )((int )((signed char )in_wc->dlid_path_bits) | tmp___12);
#line 2034
    __d___2 = inbox + 269U;
#line 2034
    switch (1UL) {
    case 1: 
#line 2034
    *((u8 *)__d___2) = val;
#line 2034
    goto ldv_28932;
    case 2: 
#line 2034
    tmp___13 = __fswab16((int )val);
#line 2034
    *((__be16 *)__d___2) = tmp___13;
#line 2034
    goto ldv_28932;
    case 4: 
#line 2034
    tmp___14 = __fswab32((__u32 )val);
#line 2034
    *((__be32 *)__d___2) = tmp___14;
#line 2034
    goto ldv_28932;
    case 8: 
#line 2034
    tmp___15 = __fswab64((__u64 )val);
#line 2034
    *((__be64 *)__d___2) = tmp___15;
#line 2034
    goto ldv_28932;
    default: 
#line 2034
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28932: 
#line 2036
    __d___3 = inbox + 270U;
#line 2036
    switch (2UL) {
    case 1: 
#line 2036
    *((u8 *)__d___3) = (u8 )in_wc->slid;
#line 2036
    goto ldv_28939;
    case 2: 
#line 2036
    tmp___16 = __fswab16((int )in_wc->slid);
#line 2036
    *((__be16 *)__d___3) = tmp___16;
#line 2036
    goto ldv_28939;
    case 4: 
#line 2036
    tmp___17 = __fswab32((__u32 )in_wc->slid);
#line 2036
    *((__be32 *)__d___3) = tmp___17;
#line 2036
    goto ldv_28939;
    case 8: 
#line 2036
    tmp___18 = __fswab64((__u64 )in_wc->slid);
#line 2036
    *((__be64 *)__d___3) = tmp___18;
#line 2036
    goto ldv_28939;
    default: 
#line 2036
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28939: 
#line 2037
    __d___4 = inbox + 274U;
#line 2037
    switch (2UL) {
    case 1: 
#line 2037
    *((u8 *)__d___4) = (u8 )in_wc->pkey_index;
#line 2037
    goto ldv_28946;
    case 2: 
#line 2037
    tmp___19 = __fswab16((int )in_wc->pkey_index);
#line 2037
    *((__be16 *)__d___4) = tmp___19;
#line 2037
    goto ldv_28946;
    case 4: 
#line 2037
    tmp___20 = __fswab32((__u32 )in_wc->pkey_index);
#line 2037
    *((__be32 *)__d___4) = tmp___20;
#line 2037
    goto ldv_28946;
    case 8: 
#line 2037
    tmp___21 = __fswab64((__u64 )in_wc->pkey_index);
#line 2037
    *((__be64 *)__d___4) = tmp___21;
#line 2037
    goto ldv_28946;
    default: 
#line 2037
    __buggy_use_of_MTHCA_PUT();
    }
    ldv_28946: ;
#line 2039
    if ((unsigned long )in_grh != (unsigned long )((struct ib_grh *)0)) {
#line 2040
      __len___0 = 40UL;
#line 2040
      if (__len___0 > 63UL) {
#line 2040
        __ret___0 = __memcpy(inbox + 320UL, (void const   *)in_grh, __len___0);
      } else {
#line 2040
        __ret___0 = __builtin_memcpy(inbox + 320UL, (void const   *)in_grh, __len___0);
      }
    } else {

    }
#line 2042
    op_modifier = (u8 )((unsigned int )op_modifier | 4U);
#line 2044
    in_modifier = (u32 )((int )in_wc->slid << 16) | in_modifier;
  } else {

  }
#line 2047
  err = mthca_cmd_box(dev, inmailbox->dma, outmailbox->dma, in_modifier, (int )op_modifier,
                      36, 15000UL);
#line 2051
  if (err == 0) {
#line 2052
    __len___1 = 256UL;
#line 2052
    if (__len___1 > 63UL) {
#line 2052
      __ret___1 = __memcpy(response_mad, (void const   *)outmailbox->buf, __len___1);
    } else {
#line 2052
      __ret___1 = __builtin_memcpy(response_mad, (void const   *)outmailbox->buf,
                                   __len___1);
    }
  } else {

  }
#line 2054
  mthca_free_mailbox(dev, inmailbox);
#line 2055
  mthca_free_mailbox(dev, outmailbox);
#line 2056
  return (err);
}
}
#line 2059 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_READ_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) 
{ int tmp ;

  {
#line 2062
  tmp = mthca_cmd_box(dev, 0ULL, mailbox->dma, (u32 )index, 0, 37, 15000UL);
#line 2062
  return (tmp);
}
}
#line 2066 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_WRITE_MGM(struct mthca_dev *dev , int index , struct mthca_mailbox *mailbox ) 
{ int tmp ;

  {
#line 2069
  tmp = mthca_cmd(dev, mailbox->dma, (u32 )index, 0, 38, 15000UL);
#line 2069
  return (tmp);
}
}
#line 2073 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_MGID_HASH(struct mthca_dev *dev , struct mthca_mailbox *mailbox , u16 *hash ) 
{ u64 imm ;
  int err ;

  {
#line 2079
  err = mthca_cmd_imm(dev, mailbox->dma, & imm, 0U, 0, 39, 15000UL);
#line 2082
  *hash = (u16 )imm;
#line 2083
  return (err);
}
}
#line 2086 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int mthca_NOP(struct mthca_dev *dev ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
#line 2088
  tmp = msecs_to_jiffies(100U);
#line 2088
  tmp___0 = mthca_cmd(dev, 0ULL, 31U, 0, 49, tmp);
#line 2088
  return (tmp___0);
}
}
#line 2091 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2096
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2098
  mutex_lock(ldv_func_arg1);
#line 2099
  return;
}
}
#line 2101 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2106
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2108
  mutex_unlock(ldv_func_arg1);
#line 2109
  return;
}
}
#line 2111 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2116
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2118
  mutex_lock(ldv_func_arg1);
#line 2119
  return;
}
}
#line 2121 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
int ldv_mutex_trylock_24(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2126
  tmp = mutex_trylock(ldv_func_arg1);
#line 2126
  ldv_func_res = tmp;
#line 2128
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2128
  return (tmp___0);
#line 2130
  return (ldv_func_res);
}
}
#line 2133 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2138
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2140
  mutex_unlock(ldv_func_arg1);
#line 2141
  return;
}
}
#line 2143 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_lock_26(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2148
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2150
  mutex_lock(ldv_func_arg1);
#line 2151
  return;
}
}
#line 2153 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2158
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2160
  mutex_unlock(ldv_func_arg1);
#line 2161
  return;
}
}
#line 2163 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2168
  ldv_mutex_lock_hcr_mutex_of_mthca_cmd(ldv_func_arg1);
#line 2170
  mutex_lock(ldv_func_arg1);
#line 2171
  return;
}
}
#line 2173 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cmd.c.prepared"
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2178
  ldv_mutex_unlock_hcr_mutex_of_mthca_cmd(ldv_func_arg1);
#line 2180
  mutex_unlock(ldv_func_arg1);
#line 2181
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) ;
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 184 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
s64 mthca_make_profile(struct mthca_dev *dev , struct mthca_profile *request , struct mthca_dev_lim *dev_lim ,
                       struct mthca_init_hca_param *init_hca ) 
{ u64 mem_base ;
  u64 mem_avail ;
  s64 total_size ;
  struct mthca_resource *profile ;
  struct mthca_resource tmp ;
  int i ;
  int j ;
  void *tmp___0 ;
  int _max1 ;
  int tmp___1 ;
  int _max2 ;
  int tmp___2 ;
  u64 _max1___0 ;
  unsigned long long _max2___0 ;
  unsigned long long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 198
  total_size = 0LL;
#line 203
  tmp___0 = kzalloc(448UL, 208U);
#line 203
  profile = (struct mthca_resource *)tmp___0;
#line 204
  if ((unsigned long )profile == (unsigned long )((struct mthca_resource *)0)) {
#line 205
    return (-12LL);
  } else {

  }
#line 207
  profile->size = (u64 )dev_lim->qpc_entry_sz;
#line 208
  (profile + 1UL)->size = (u64 )dev_lim->eec_entry_sz;
#line 209
  (profile + 2UL)->size = (u64 )dev_lim->srq_entry_sz;
#line 210
  (profile + 3UL)->size = (u64 )dev_lim->cqc_entry_sz;
#line 211
  (profile + 4UL)->size = (u64 )dev_lim->eqpc_entry_sz;
#line 212
  (profile + 5UL)->size = (u64 )dev_lim->eeec_entry_sz;
#line 213
  (profile + 6UL)->size = (u64 )dev_lim->eqc_entry_sz;
#line 214
  (profile + 7UL)->size = 32ULL;
#line 215
  (profile + 8UL)->size = 256ULL;
#line 216
  (profile + 9UL)->size = (u64 )dev_lim->mpt_entry_sz;
#line 217
  (profile + 10UL)->size = (u64 )dev->limits.mtt_seg_size;
#line 218
  (profile + 11UL)->size = (u64 )dev_lim->uar_scratch_entry_sz;
#line 219
  (profile + 12UL)->size = 32ULL;
#line 220
  (profile + 13UL)->size = (u64 )request->uarc_size;
#line 222
  profile->num = request->num_qp;
#line 223
  (profile + 2UL)->num = request->num_srq;
#line 224
  (profile + 4UL)->num = request->num_qp;
#line 225
  (profile + 7UL)->num = request->num_qp * request->rdb_per_qp;
#line 226
  (profile + 3UL)->num = request->num_cq;
#line 227
  (profile + 6UL)->num = 32;
#line 228
  (profile + 8UL)->num = request->num_mcg;
#line 229
  (profile + 9UL)->num = request->num_mpt;
#line 230
  (profile + 10UL)->num = request->num_mtt;
#line 231
  (profile + 11UL)->num = request->num_uar;
#line 232
  (profile + 13UL)->num = request->num_uar;
#line 233
  (profile + 12UL)->num = request->num_udav;
#line 235
  i = 0;
#line 235
  goto ldv_24023;
  ldv_24022: 
#line 236
  (profile + (unsigned long )i)->type = i;
#line 237
  tmp___1 = ffs((profile + (unsigned long )i)->num);
#line 237
  _max1 = tmp___1 + -1;
#line 237
  _max2 = 0;
#line 237
  if (_max1 > _max2) {
#line 237
    tmp___2 = _max1;
  } else {
#line 237
    tmp___2 = _max2;
  }
#line 237
  (profile + (unsigned long )i)->log_num = tmp___2;
#line 238
  (profile + (unsigned long )i)->size = (profile + (unsigned long )i)->size * (u64 )(profile + (unsigned long )i)->num;
#line 239
  tmp___4 = mthca_is_memfree(dev);
#line 239
  if (tmp___4 != 0) {
#line 240
    _max1___0 = (profile + (unsigned long )i)->size;
#line 240
    _max2___0 = 4096ULL;
#line 240
    if (_max1___0 > _max2___0) {
#line 240
      tmp___3 = _max1___0;
    } else {
#line 240
      tmp___3 = _max2___0;
    }
#line 240
    (profile + (unsigned long )i)->size = tmp___3;
  } else {

  }
#line 235
  i = i + 1;
  ldv_24023: ;
#line 235
  if (i <= 13) {
#line 236
    goto ldv_24022;
  } else {
#line 238
    goto ldv_24024;
  }
  ldv_24024: 
#line 243
  tmp___5 = mthca_is_memfree(dev);
#line 243
  if (tmp___5 != 0) {
#line 244
    mem_base = 0ULL;
#line 245
    mem_avail = dev_lim->hca.arbel.max_icm_sz;
  } else {
#line 247
    mem_base = dev->ddr_start;
#line 248
    mem_avail = dev->fw.tavor.fw_start - dev->ddr_start;
  }
#line 257
  i = 14;
#line 257
  goto ldv_24029;
  ldv_24028: 
#line 258
  j = 1;
#line 258
  goto ldv_24026;
  ldv_24025: ;
#line 259
  if ((profile + (unsigned long )j)->size > (profile + ((unsigned long )j + 0xffffffffffffffffUL))->size) {
#line 260
    tmp = *(profile + (unsigned long )j);
#line 261
    *(profile + (unsigned long )j) = *(profile + ((unsigned long )j + 0xffffffffffffffffUL));
#line 262
    *(profile + ((unsigned long )j + 0xffffffffffffffffUL)) = tmp;
  } else {

  }
#line 258
  j = j + 1;
  ldv_24026: ;
#line 258
  if (j < i) {
#line 259
    goto ldv_24025;
  } else {
#line 261
    goto ldv_24027;
  }
  ldv_24027: 
#line 257
  i = i - 1;
  ldv_24029: ;
#line 257
  if (i > 0) {
#line 258
    goto ldv_24028;
  } else {
#line 260
    goto ldv_24030;
  }
  ldv_24030: 
#line 266
  i = 0;
#line 266
  goto ldv_24032;
  ldv_24031: ;
#line 267
  if ((profile + (unsigned long )i)->size != 0ULL) {
#line 268
    (profile + (unsigned long )i)->start = mem_base + (unsigned long long )total_size;
#line 269
    total_size = (s64 )((profile + (unsigned long )i)->size + (unsigned long long )total_size);
  } else {

  }
#line 271
  if ((unsigned long long )total_size > mem_avail) {
#line 272
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Profile requires 0x%llx bytes; won\'t fit in 0x%llx bytes of context memory.\n",
            (unsigned long long )total_size, mem_avail);
#line 276
    kfree((void const   *)profile);
#line 277
    return (-12LL);
  } else {

  }
#line 280
  if ((profile + (unsigned long )i)->size != 0ULL) {
#line 281
    if (mthca_debug_level != 0) {
#line 281
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "profile[%2d]--%2d/%2d @ 0x%16llx (size 0x%8llx)\n",
                 i, (profile + (unsigned long )i)->type, (profile + (unsigned long )i)->log_num,
                 (profile + (unsigned long )i)->start, (profile + (unsigned long )i)->size);
    } else {

    }
  } else {

  }
#line 266
  i = i + 1;
  ldv_24032: ;
#line 266
  if (i <= 13) {
#line 267
    goto ldv_24031;
  } else {
#line 269
    goto ldv_24033;
  }
  ldv_24033: 
#line 288
  tmp___6 = mthca_is_memfree(dev);
#line 288
  if (tmp___6 != 0) {
#line 289
    if (mthca_debug_level != 0) {
#line 289
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA context memory: reserving %d KB\n",
                 (int )(total_size >> 10));
    } else
#line 292
    if (mthca_debug_level != 0) {
#line 292
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "HCA memory: allocated %d KB/%d KB (%d KB free)\n",
                 (int )(total_size >> 10), (int )(mem_avail >> 10), (int )((mem_avail - (unsigned long long )total_size) >> 10));
    } else {

    }
  } else {

  }
#line 296
  i = 0;
#line 296
  goto ldv_24054;
  ldv_24053: ;
#line 297
  switch ((profile + (unsigned long )i)->type) {
  case 0: 
#line 299
  dev->limits.num_qps = (profile + (unsigned long )i)->num;
#line 300
  init_hca->qpc_base = (profile + (unsigned long )i)->start;
#line 301
  init_hca->log_num_qps = (u8 )(profile + (unsigned long )i)->log_num;
#line 302
  goto ldv_24035;
  case 1: 
#line 304
  dev->limits.num_eecs = (profile + (unsigned long )i)->num;
#line 305
  init_hca->eec_base = (profile + (unsigned long )i)->start;
#line 306
  init_hca->log_num_eecs = (u8 )(profile + (unsigned long )i)->log_num;
#line 307
  goto ldv_24035;
  case 2: 
#line 309
  dev->limits.num_srqs = (profile + (unsigned long )i)->num;
#line 310
  init_hca->srqc_base = (profile + (unsigned long )i)->start;
#line 311
  init_hca->log_num_srqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 312
  goto ldv_24035;
  case 3: 
#line 314
  dev->limits.num_cqs = (profile + (unsigned long )i)->num;
#line 315
  init_hca->cqc_base = (profile + (unsigned long )i)->start;
#line 316
  init_hca->log_num_cqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 317
  goto ldv_24035;
  case 4: 
#line 319
  init_hca->eqpc_base = (profile + (unsigned long )i)->start;
#line 320
  goto ldv_24035;
  case 5: 
#line 322
  init_hca->eeec_base = (profile + (unsigned long )i)->start;
#line 323
  goto ldv_24035;
  case 6: 
#line 325
  dev->limits.num_eqs = (profile + (unsigned long )i)->num;
#line 326
  init_hca->eqc_base = (profile + (unsigned long )i)->start;
#line 327
  init_hca->log_num_eqs = (u8 )(profile + (unsigned long )i)->log_num;
#line 328
  goto ldv_24035;
  case 7: 
#line 330
  dev->qp_table.rdb_shift = 0;
#line 330
  goto ldv_24044;
  ldv_24043: 
#line 332
  dev->qp_table.rdb_shift = dev->qp_table.rdb_shift + 1;
  ldv_24044: ;
#line 330
  if (request->num_qp << dev->qp_table.rdb_shift < (profile + (unsigned long )i)->num) {
#line 332
    goto ldv_24043;
  } else {
#line 334
    goto ldv_24045;
  }
  ldv_24045: 
#line 334
  dev->qp_table.rdb_base = (unsigned int )(profile + (unsigned long )i)->start;
#line 335
  init_hca->rdb_base = (profile + (unsigned long )i)->start;
#line 336
  goto ldv_24035;
  case 8: 
#line 338
  dev->limits.num_mgms = (profile + (unsigned long )i)->num >> 1;
#line 339
  dev->limits.num_amgms = (profile + (unsigned long )i)->num >> 1;
#line 340
  init_hca->mc_base = (profile + (unsigned long )i)->start;
#line 341
  tmp___7 = ffs(256);
#line 341
  init_hca->log_mc_entry_sz = (unsigned int )((u16 )tmp___7) + 65535U;
#line 342
  init_hca->log_mc_table_sz = (u8 )(profile + (unsigned long )i)->log_num;
#line 343
  init_hca->mc_hash_sz = (u16 )(1 << ((profile + (unsigned long )i)->log_num + -1));
#line 344
  goto ldv_24035;
  case 9: 
#line 346
  dev->limits.num_mpts = (profile + (unsigned long )i)->num;
#line 347
  dev->mr_table.mpt_base = (profile + (unsigned long )i)->start;
#line 348
  init_hca->mpt_base = (profile + (unsigned long )i)->start;
#line 349
  init_hca->log_mpt_sz = (u8 )(profile + (unsigned long )i)->log_num;
#line 350
  goto ldv_24035;
  case 10: 
#line 352
  dev->limits.num_mtt_segs = (profile + (unsigned long )i)->num;
#line 353
  dev->mr_table.mtt_base = (profile + (unsigned long )i)->start;
#line 354
  init_hca->mtt_base = (profile + (unsigned long )i)->start;
#line 355
  tmp___8 = ffs(dev->limits.mtt_seg_size);
#line 355
  init_hca->mtt_seg_sz = (unsigned int )((u8 )tmp___8) + 249U;
#line 356
  goto ldv_24035;
  case 11: 
#line 358
  dev->limits.num_uars = (profile + (unsigned long )i)->num;
#line 359
  init_hca->uar_scratch_base = (profile + (unsigned long )i)->start;
#line 360
  goto ldv_24035;
  case 12: 
#line 362
  dev->av_table.ddr_av_base = (profile + (unsigned long )i)->start;
#line 363
  dev->av_table.num_ddr_avs = (profile + (unsigned long )i)->num;
#line 364
  goto ldv_24035;
  case 13: 
#line 366
  dev->uar_table.uarc_size = request->uarc_size;
#line 367
  dev->uar_table.uarc_base = (profile + (unsigned long )i)->start;
#line 368
  init_hca->uarc_base = (profile + (unsigned long )i)->start;
#line 369
  tmp___9 = ffs(request->uarc_size);
#line 369
  init_hca->log_uarc_sz = (unsigned int )((u8 )tmp___9) + 243U;
#line 370
  tmp___10 = ffs(request->num_uar);
#line 370
  init_hca->log_uar_sz = (unsigned int )((u8 )tmp___10) + 255U;
#line 371
  goto ldv_24035;
  default: ;
#line 373
  goto ldv_24035;
  }
  ldv_24035: 
#line 296
  i = i + 1;
  ldv_24054: ;
#line 296
  if (i <= 13) {
#line 297
    goto ldv_24053;
  } else {
#line 299
    goto ldv_24055;
  }
  ldv_24055: 
#line 381
  dev->limits.num_pds = 32768;
#line 383
  if ((dev->mthca_flags & 256UL) != 0UL && (unsigned int )init_hca->log_mpt_sz > 23U) {
#line 385
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MPT table too large (requested size 2^%d >= 2^24)\n",
             (int )init_hca->log_mpt_sz);
#line 387
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Disabling memory key throughput optimization.\n");
#line 388
    dev->mthca_flags = dev->mthca_flags & 0xfffffffffffffeffUL;
  } else {

  }
#line 398
  mthca_is_memfree(dev);
#line 399
  dev->limits.fmr_reserved_mtts = 0;
#line 403
  kfree((void const   *)profile);
#line 404
  return (total_size);
}
}
#line 407 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 412
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 414
  mutex_lock(ldv_func_arg1);
#line 415
  return;
}
}
#line 417 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 422
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 424
  mutex_unlock(ldv_func_arg1);
#line 425
  return;
}
}
#line 427 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 432
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 434
  mutex_lock(ldv_func_arg1);
#line 435
  return;
}
}
#line 437 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 442
  tmp = mutex_trylock(ldv_func_arg1);
#line 442
  ldv_func_res = tmp;
#line 444
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 444
  return (tmp___0);
#line 446
  return (ldv_func_res);
}
}
#line 449 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_profile.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 454
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 456
  mutex_unlock(ldv_func_arg1);
#line 457
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_52(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_53(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
#line 63 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 732 "include/linux/pci.h"
extern void pci_dev_put(struct pci_dev * ) ;
#line 760
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 780
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 786
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 798 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ int tmp ;

  {
#line 801
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 801
  return (tmp);
}
}
#line 811 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ int tmp ;

  {
#line 814
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 814
  return (tmp);
}
}
#line 819
extern int pcie_capability_write_word(struct pci_dev * , int  , u16  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 161 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
int mthca_reset(struct mthca_dev *mdev ) 
{ int i ;
  int err ;
  u32 *hca_header ;
  u32 *bridge_header ;
  struct pci_dev *bridge ;
  int bridge_pcix_cap ;
  int hca_pcie_cap ;
  int hca_pcix_cap ;
  u16 devctl ;
  u16 linkctl ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *reset ;
  void *tmp___5 ;
  u32 v ;
  int c ;
  struct pci_dev *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 164
  err = 0;
#line 165
  hca_header = 0;
#line 166
  bridge_header = 0;
#line 167
  bridge = 0;
#line 168
  bridge_pcix_cap = 0;
#line 169
  hca_pcie_cap = 0;
#line 170
  hca_pcix_cap = 0;
#line 189
  if ((mdev->mthca_flags & 128UL) == 0UL) {
#line 192
    goto ldv_22190;
    ldv_22189: ;
#line 195
    if ((unsigned int )bridge->hdr_type == 1U && (unsigned long )bridge->subordinate == (unsigned long )(mdev->pdev)->bus) {
#line 197
      if (mthca_debug_level != 0) {
#line 197
        tmp = pci_name((struct pci_dev  const  *)bridge);
#line 197
        dev_printk("\017", (struct device  const  *)(& (mdev->pdev)->dev), "Found bridge: %s\n",
                   tmp);
      } else {

      }
#line 199
      goto ldv_22188;
    } else {

    }
    ldv_22190: 
#line 192
    bridge = pci_get_device((unsigned int )(mdev->pdev)->vendor, (unsigned int )((int )(mdev->pdev)->device + 2),
                            bridge);
#line 192
    if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 195
      goto ldv_22189;
    } else {
#line 197
      goto ldv_22188;
    }
    ldv_22188: ;
#line 203
    if ((unsigned long )bridge == (unsigned long )((struct pci_dev *)0)) {
#line 209
      tmp___0 = pci_name((struct pci_dev  const  *)mdev->pdev);
#line 209
      dev_warn((struct device  const  *)(& (mdev->pdev)->dev), "No bridge found for %s\n",
               tmp___0);
    } else {

    }
  } else {

  }
#line 216
  tmp___1 = kmalloc(256UL, 208U);
#line 216
  hca_header = (u32 *)tmp___1;
#line 217
  if ((unsigned long )hca_header == (unsigned long )((u32 *)0)) {
#line 218
    err = -12;
#line 219
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate memory to save HCA PCI header, aborting.\n");
#line 221
    goto out;
  } else {

  }
#line 224
  i = 0;
#line 224
  goto ldv_22194;
  ldv_22193: ;
#line 225
  if (i == 22 || i == 23) {
#line 226
    goto ldv_22192;
  } else {

  }
#line 227
  tmp___2 = pci_read_config_dword((struct pci_dev  const  *)mdev->pdev, i * 4, hca_header + (unsigned long )i);
#line 227
  if (tmp___2 != 0) {
#line 228
    err = -19;
#line 229
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t save HCA PCI header, aborting.\n");
#line 231
    goto out;
  } else {

  }
  ldv_22192: 
#line 224
  i = i + 1;
  ldv_22194: ;
#line 224
  if (i <= 63) {
#line 225
    goto ldv_22193;
  } else {
#line 227
    goto ldv_22195;
  }
  ldv_22195: 
#line 235
  hca_pcix_cap = pci_find_capability(mdev->pdev, 7);
#line 236
  hca_pcie_cap = pci_pcie_cap(mdev->pdev);
#line 238
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 239
    tmp___3 = kmalloc(256UL, 208U);
#line 239
    bridge_header = (u32 *)tmp___3;
#line 240
    if ((unsigned long )bridge_header == (unsigned long )((u32 *)0)) {
#line 241
      err = -12;
#line 242
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t allocate memory to save HCA bridge PCI header, aborting.\n");
#line 244
      goto out;
    } else {

    }
#line 247
    i = 0;
#line 247
    goto ldv_22198;
    ldv_22197: ;
#line 248
    if (i == 22 || i == 23) {
#line 249
      goto ldv_22196;
    } else {

    }
#line 250
    tmp___4 = pci_read_config_dword((struct pci_dev  const  *)bridge, i * 4, bridge_header + (unsigned long )i);
#line 250
    if (tmp___4 != 0) {
#line 251
      err = -19;
#line 252
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t save HCA bridge PCI header, aborting.\n");
#line 254
      goto out;
    } else {

    }
    ldv_22196: 
#line 247
    i = i + 1;
    ldv_22198: ;
#line 247
    if (i <= 63) {
#line 248
      goto ldv_22197;
    } else {
#line 250
      goto ldv_22199;
    }
    ldv_22199: 
#line 257
    bridge_pcix_cap = pci_find_capability(bridge, 7);
#line 258
    if (bridge_pcix_cap == 0) {
#line 259
      err = -19;
#line 260
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t locate HCA bridge PCI-X capability, aborting.\n");
#line 262
      goto out;
    } else {

    }
  } else {

  }
#line 268
  tmp___5 = ioremap((mdev->pdev)->resource[0].start + 983056ULL, 4UL);
#line 268
  reset = tmp___5;
#line 271
  if ((unsigned long )reset == (unsigned long )((void *)0)) {
#line 272
    err = -12;
#line 273
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t map HCA reset register, aborting.\n");
#line 275
    goto out;
  } else {

  }
#line 278
  writel(16777216U, (void volatile   *)reset);
#line 279
  iounmap((void volatile   *)reset);
#line 283
  msleep(1000U);
#line 288
  c = 0;
#line 290
  c = 0;
#line 290
  goto ldv_22205;
  ldv_22204: ;
#line 291
  if ((unsigned long )bridge == (unsigned long )((struct pci_dev *)0)) {
#line 291
    tmp___6 = mdev->pdev;
  } else {
#line 291
    tmp___6 = bridge;
  }
#line 291
  tmp___7 = pci_read_config_dword((struct pci_dev  const  *)tmp___6, 0, & v);
#line 291
  if (tmp___7 != 0) {
#line 292
    err = -19;
#line 293
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t access HCA after reset, aborting.\n");
#line 295
    goto out;
  } else {

  }
#line 298
  if (v != 4294967295U) {
#line 299
    goto good;
  } else {

  }
#line 301
  msleep(100U);
#line 290
  c = c + 1;
  ldv_22205: ;
#line 290
  if (c <= 99) {
#line 291
    goto ldv_22204;
  } else {
#line 293
    goto ldv_22206;
  }
  ldv_22206: 
#line 304
  err = -19;
#line 305
  dev_err((struct device  const  *)(& (mdev->pdev)->dev), "PCI device did not come back after reset, aborting.\n");
#line 307
  goto out;
  good: ;
#line 312
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 313
    tmp___8 = pci_write_config_dword((struct pci_dev  const  *)bridge, bridge_pcix_cap + 8,
                                     *(bridge_header + (unsigned long )((bridge_pcix_cap + 8) / 4)));
#line 313
    if (tmp___8 != 0) {
#line 315
      err = -19;
#line 316
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge Upstream split transaction control, aborting.\n");
#line 318
      goto out;
    } else {

    }
#line 320
    tmp___9 = pci_write_config_dword((struct pci_dev  const  *)bridge, bridge_pcix_cap + 12,
                                     *(bridge_header + (unsigned long )((bridge_pcix_cap + 12) / 4)));
#line 320
    if (tmp___9 != 0) {
#line 322
      err = -19;
#line 323
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge Downstream split transaction control, aborting.\n");
#line 325
      goto out;
    } else {

    }
#line 331
    i = 0;
#line 331
    goto ldv_22209;
    ldv_22208: ;
#line 332
    if (i * 4 == 4) {
#line 333
      goto ldv_22207;
    } else {

    }
#line 335
    tmp___10 = pci_write_config_dword((struct pci_dev  const  *)bridge, i * 4, *(bridge_header + (unsigned long )i));
#line 335
    if (tmp___10 != 0) {
#line 336
      err = -19;
#line 337
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge reg %x, aborting.\n",
              i);
#line 339
      goto out;
    } else {

    }
    ldv_22207: 
#line 331
    i = i + 1;
    ldv_22209: ;
#line 331
    if (i <= 15) {
#line 332
      goto ldv_22208;
    } else {
#line 334
      goto ldv_22210;
    }
    ldv_22210: 
#line 343
    tmp___11 = pci_write_config_dword((struct pci_dev  const  *)bridge, 4, *(bridge_header + 1UL));
#line 343
    if (tmp___11 != 0) {
#line 345
      err = -19;
#line 346
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA bridge COMMAND, aborting.\n");
#line 348
      goto out;
    } else {

    }
  } else {

  }
#line 352
  if (hca_pcix_cap != 0) {
#line 353
    tmp___12 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, hca_pcix_cap,
                                      *(hca_header + (unsigned long )(hca_pcix_cap / 4)));
#line 353
    if (tmp___12 != 0) {
#line 355
      err = -19;
#line 356
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI-X command register, aborting.\n");
#line 358
      goto out;
    } else {

    }
  } else {

  }
#line 362
  if (hca_pcie_cap != 0) {
#line 363
    devctl = (u16 )*(hca_header + (unsigned long )((hca_pcie_cap + 8) / 4));
#line 364
    tmp___13 = pcie_capability_write_word(mdev->pdev, 8, (int )devctl);
#line 364
    if (tmp___13 != 0) {
#line 366
      err = -19;
#line 367
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI Express Device Control register, aborting.\n");
#line 369
      goto out;
    } else {

    }
#line 371
    linkctl = (u16 )*(hca_header + (unsigned long )((hca_pcie_cap + 16) / 4));
#line 372
    tmp___14 = pcie_capability_write_word(mdev->pdev, 16, (int )linkctl);
#line 372
    if (tmp___14 != 0) {
#line 374
      err = -19;
#line 375
      dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA PCI Express Link control register, aborting.\n");
#line 377
      goto out;
    } else {

    }
  } else {

  }
#line 381
  i = 0;
#line 381
  goto ldv_22213;
  ldv_22212: ;
#line 382
  if (i * 4 == 4) {
#line 383
    goto ldv_22211;
  } else {

  }
#line 385
  tmp___15 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, i * 4, *(hca_header + (unsigned long )i));
#line 385
  if (tmp___15 != 0) {
#line 386
    err = -19;
#line 387
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA reg %x, aborting.\n",
            i);
#line 389
    goto out;
  } else {

  }
  ldv_22211: 
#line 381
  i = i + 1;
  ldv_22213: ;
#line 381
  if (i <= 15) {
#line 382
    goto ldv_22212;
  } else {
#line 384
    goto ldv_22214;
  }
  ldv_22214: 
#line 393
  tmp___16 = pci_write_config_dword((struct pci_dev  const  *)mdev->pdev, 4, *(hca_header + 1UL));
#line 393
  if (tmp___16 != 0) {
#line 395
    err = -19;
#line 396
    dev_err((struct device  const  *)(& (mdev->pdev)->dev), "Couldn\'t restore HCA COMMAND, aborting.\n");
#line 398
    goto out;
  } else {

  }
  out: ;
#line 402
  if ((unsigned long )bridge != (unsigned long )((struct pci_dev *)0)) {
#line 403
    pci_dev_put(bridge);
  } else {

  }
#line 404
  kfree((void const   *)bridge_header);
#line 405
  kfree((void const   *)hca_header);
#line 407
  return (err);
}
}
#line 410 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 415
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 417
  mutex_lock(ldv_func_arg1);
#line 418
  return;
}
}
#line 420 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 425
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 427
  mutex_unlock(ldv_func_arg1);
#line 428
  return;
}
}
#line 430 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 435
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 437
  mutex_lock(ldv_func_arg1);
#line 438
  return;
}
}
#line 440 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
int ldv_mutex_trylock_52(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 445
  tmp = mutex_trylock(ldv_func_arg1);
#line 445
  ldv_func_res = tmp;
#line 447
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 447
  return (tmp___0);
#line 449
  return (ldv_func_res);
}
}
#line 452 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_reset.c.prepared"
void ldv_mutex_unlock_53(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 457
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 459
  mutex_unlock(ldv_func_arg1);
#line 460
  return;
}
}
#line 62 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
#line 70
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 72
  return;
}
}
#line 100 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 109
  return;
}
}
#line 22 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_zero_bit(unsigned long const   * , unsigned long  ,
                                        unsigned long  ) ;
#line 45
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 45 "include/linux/dynamic_debug.h"
extern int __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
#line 54 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_64_types.h"
extern void clear_page(void * ) ;
#line 355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 159 "include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
#line 164
  len = (int )((unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U);
#line 165
  memset((void *)dst, 0, (size_t )len);
#line 167
  return;
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 823 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 825
  __edi = __edi;
#line 825
  __esi = __esi;
#line 825
  __edx = __edx;
#line 825
  __ecx = __ecx;
#line 825
  __eax = __eax;
#line 825
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 825
  if (tmp != 0L) {
#line 825
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (825), "i" (12UL));
    ldv_4725: ;
#line 825
    goto ldv_4725;
  } else {

  }
#line 825
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 825
  __ret = __eax;
#line 825
  return (__ret);
}
}
#line 155 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_62(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void ldv_mutex_lock_59(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
#line 341
  return;
}
}
#line 352 "include/linux/gfp.h"
extern unsigned long get_zeroed_page(gfp_t  ) ;
#line 366
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 70 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 

  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0) && *(dev->dma_mask) != 0ULL);
}
}
#line 53 "include/linux/dma-debug.h"
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 103 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    if ((int )gfp & 1) {
#line 110
      dma_mask = 16777215UL;
    } else {
#line 110
      dma_mask = 4294967295UL;
    }
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return (0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return (0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h",
                       166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 414 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
u32 mthca_alloc(struct mthca_alloc *alloc ) ;
#line 415
void mthca_free(struct mthca_alloc *alloc , u32 obj ) ;
#line 416
int mthca_alloc_init(struct mthca_alloc *alloc , u32 num , u32 mask , u32 reserved ) ;
#line 418
void mthca_alloc_cleanup(struct mthca_alloc *alloc ) ;
#line 419
void *mthca_array_get(struct mthca_array *array , int index ) ;
#line 420
int mthca_array_set(struct mthca_array *array , int index , void *value ) ;
#line 421
void mthca_array_clear(struct mthca_array *array , int index ) ;
#line 422
int mthca_array_init(struct mthca_array *array , int nent ) ;
#line 423
void mthca_array_cleanup(struct mthca_array *array , int nent ) ;
#line 424
int mthca_buf_alloc(struct mthca_dev *dev , int size , int max_direct , union mthca_buf *buf ,
                    int *is_direct , struct mthca_pd *pd , int hca_write , struct mthca_mr *mr ) ;
#line 427
void mthca_buf_free(struct mthca_dev *dev , int size , union mthca_buf *buf , int is_direct ,
                    struct mthca_mr *mr ) ;
#line 475
int mthca_mr_alloc_phys(struct mthca_dev *dev , u32 pd , u64 *buffer_list , int buffer_size_shift ,
                        int list_len , u64 iova , u64 total_size , u32 access , struct mthca_mr *mr ) ;
#line 479
void mthca_free_mr(struct mthca_dev *dev , struct mthca_mr *mr ) ;
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
u32 mthca_alloc(struct mthca_alloc *alloc ) 
{ unsigned long flags ;
  u32 obj ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 165
  tmp = spinlock_check(& alloc->lock);
#line 165
  flags = _raw_spin_lock_irqsave(tmp);
#line 167
  tmp___0 = find_next_zero_bit((unsigned long const   *)alloc->table, (unsigned long )alloc->max,
                               (unsigned long )alloc->last);
#line 167
  obj = (u32 )tmp___0;
#line 168
  if (alloc->max <= obj) {
#line 169
    alloc->top = (alloc->top + alloc->max) & alloc->mask;
#line 170
    tmp___1 = find_first_zero_bit((unsigned long const   *)alloc->table, (unsigned long )alloc->max);
#line 170
    obj = (u32 )tmp___1;
  } else {

  }
#line 173
  if (alloc->max > obj) {
#line 174
    set_bit(obj, (unsigned long volatile   *)alloc->table);
#line 175
    obj = alloc->top | obj;
  } else {
#line 177
    obj = 4294967295U;
  }
#line 179
  spin_unlock_irqrestore(& alloc->lock, flags);
#line 181
  return (obj);
}
}
#line 184 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void mthca_free(struct mthca_alloc *alloc , u32 obj ) 
{ unsigned long flags ;
  raw_spinlock_t *tmp ;
  u32 _min1 ;
  u32 _min2 ;
  u32 tmp___0 ;

  {
#line 188
  obj = (alloc->max - 1U) & obj;
#line 190
  tmp = spinlock_check(& alloc->lock);
#line 190
  flags = _raw_spin_lock_irqsave(tmp);
#line 192
  clear_bit((int )obj, (unsigned long volatile   *)alloc->table);
#line 193
  _min1 = alloc->last;
#line 193
  _min2 = obj;
#line 193
  if (_min1 < _min2) {
#line 193
    tmp___0 = _min1;
  } else {
#line 193
    tmp___0 = _min2;
  }
#line 193
  alloc->last = tmp___0;
#line 194
  alloc->top = (alloc->top + alloc->max) & alloc->mask;
#line 196
  spin_unlock_irqrestore(& alloc->lock, flags);
#line 197
  return;
}
}
#line 199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
int mthca_alloc_init(struct mthca_alloc *alloc , u32 num , u32 mask , u32 reserved ) 
{ int i ;
  int tmp ;
  struct lock_class_key __key ;
  void *tmp___0 ;

  {
#line 205
  tmp = ffs((int )num);
#line 205
  if ((u32 )(1 << (tmp + -1)) != num) {
#line 206
    return (-22);
  } else {

  }
#line 208
  alloc->last = 0U;
#line 209
  alloc->top = 0U;
#line 210
  alloc->max = num;
#line 211
  alloc->mask = mask;
#line 212
  spinlock_check(& alloc->lock);
#line 212
  __raw_spin_lock_init(& alloc->lock.ldv_5961.rlock, "&(&alloc->lock)->rlock", & __key);
#line 213
  tmp___0 = kmalloc((((unsigned long )num + 63UL) / 64UL) * 8UL, 208U);
#line 213
  alloc->table = (unsigned long *)tmp___0;
#line 215
  if ((unsigned long )alloc->table == (unsigned long )((unsigned long *)0)) {
#line 216
    return (-12);
  } else {

  }
#line 218
  bitmap_zero(alloc->table, (int )num);
#line 219
  i = 0;
#line 219
  goto ldv_21831;
  ldv_21830: 
#line 220
  set_bit((unsigned int )i, (unsigned long volatile   *)alloc->table);
#line 219
  i = i + 1;
  ldv_21831: ;
#line 219
  if ((u32 )i < reserved) {
#line 220
    goto ldv_21830;
  } else {
#line 222
    goto ldv_21832;
  }
  ldv_21832: ;
#line 222
  return (0);
}
}
#line 225 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void mthca_alloc_cleanup(struct mthca_alloc *alloc ) 
{ 

  {
#line 227
  kfree((void const   *)alloc->table);
#line 228
  return;
}
}
#line 238 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void *mthca_array_get(struct mthca_array *array , int index ) 
{ int p ;

  {
#line 240
  p = (int )((unsigned long )index * 8UL >> 12);
#line 242
  if ((unsigned long )(array->page_list + (unsigned long )p)->page != (unsigned long )((void **)0)) {
#line 243
    return (*((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)));
  } else {
#line 245
    return (0);
  }
}
}
#line 248 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
int mthca_array_set(struct mthca_array *array , int index , void *value ) 
{ int p ;
  unsigned long tmp ;

  {
#line 250
  p = (int )((unsigned long )index * 8UL >> 12);
#line 253
  if ((unsigned long )(array->page_list + (unsigned long )p)->page == (unsigned long )((void **)0)) {
#line 254
    tmp = get_zeroed_page(32U);
#line 254
    (array->page_list + (unsigned long )p)->page = (void **)tmp;
  } else {

  }
#line 256
  if ((unsigned long )(array->page_list + (unsigned long )p)->page == (unsigned long )((void **)0)) {
#line 257
    return (-12);
  } else {

  }
#line 259
  *((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)) = value;
#line 260
  (array->page_list + (unsigned long )p)->used = (array->page_list + (unsigned long )p)->used + 1;
#line 262
  return (0);
}
}
#line 265 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void mthca_array_clear(struct mthca_array *array , int index ) 
{ int p ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 267
  p = (int )((unsigned long )index * 8UL >> 12);
#line 269
  (array->page_list + (unsigned long )p)->used = (array->page_list + (unsigned long )p)->used - 1;
#line 269
  if ((array->page_list + (unsigned long )p)->used == 0) {
#line 270
    free_pages((unsigned long )(array->page_list + (unsigned long )p)->page, 0U);
#line 271
    (array->page_list + (unsigned long )p)->page = 0;
  } else {
#line 273
    *((array->page_list + (unsigned long )p)->page + ((unsigned long )index & 511UL)) = 0;
  }
#line 275
  if ((array->page_list + (unsigned long )p)->used < 0) {
#line 276
    descriptor.modname = "ib_mthca";
#line 276
    descriptor.function = "mthca_array_clear";
#line 276
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared";
#line 276
    descriptor.format = "Array %p index %d page %d with ref count %d < 0\n";
#line 276
    descriptor.lineno = 277U;
#line 276
    descriptor.flags = 0U;
#line 276
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 276
    if (tmp != 0L) {
#line 276
      __dynamic_pr_debug(& descriptor, "Array %p index %d page %d with ref count %d < 0\n",
                         array, index, p, (array->page_list + (unsigned long )p)->used);
    } else {

    }
  } else {

  }
#line 278
  return;
}
}
#line 280 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
int mthca_array_init(struct mthca_array *array , int nent ) 
{ int npage ;
  int i ;
  void *tmp ;

  {
#line 282
  npage = (int )((((unsigned long )nent + 512UL) * 8UL - 1UL) / 4096UL);
#line 285
  tmp = kmalloc((unsigned long )npage * 16UL, 208U);
#line 285
  array->page_list = (struct __anonstruct_168 *)tmp;
#line 286
  if ((unsigned long )array->page_list == (unsigned long )((struct __anonstruct_page_list_167 *)0)) {
#line 287
    return (-12);
  } else {

  }
#line 289
  i = 0;
#line 289
  goto ldv_21861;
  ldv_21860: 
#line 290
  (array->page_list + (unsigned long )i)->page = 0;
#line 291
  (array->page_list + (unsigned long )i)->used = 0;
#line 289
  i = i + 1;
  ldv_21861: ;
#line 289
  if (i < npage) {
#line 290
    goto ldv_21860;
  } else {
#line 292
    goto ldv_21862;
  }
  ldv_21862: ;
#line 294
  return (0);
}
}
#line 297 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void mthca_array_cleanup(struct mthca_array *array , int nent ) 
{ int i ;

  {
#line 301
  i = 0;
#line 301
  goto ldv_21869;
  ldv_21868: 
#line 302
  free_pages((unsigned long )(array->page_list + (unsigned long )i)->page, 0U);
#line 301
  i = i + 1;
  ldv_21869: ;
#line 301
  if ((unsigned long )i < (((unsigned long )nent + 512UL) * 8UL - 1UL) / 4096UL) {
#line 302
    goto ldv_21868;
  } else {
#line 304
    goto ldv_21870;
  }
  ldv_21870: 
#line 304
  kfree((void const   *)array->page_list);
#line 305
  return;
}
}
#line 314 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
int mthca_buf_alloc(struct mthca_dev *dev , int size , int max_direct , union mthca_buf *buf ,
                    int *is_direct , struct mthca_pd *pd , int hca_write , struct mthca_mr *mr ) 
{ int err ;
  int npages ;
  int shift ;
  u64 *dma_list ;
  dma_addr_t t ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 318
  err = -12;
#line 320
  dma_list = 0;
#line 324
  if (size <= max_direct) {
#line 325
    *is_direct = 1;
#line 326
    npages = 1;
#line 327
    tmp = __get_order((unsigned long )size);
#line 327
    shift = tmp + 12;
#line 329
    buf->direct.buf = dma_alloc_attrs(& (dev->pdev)->dev, (size_t )size, & t, 208U,
                                      0);
#line 331
    if ((unsigned long )buf->direct.buf == (unsigned long )((void *)0)) {
#line 332
      return (-12);
    } else {

    }
#line 334
    buf->direct.mapping = t;
#line 336
    memset(buf->direct.buf, 0, (size_t )size);
#line 338
    goto ldv_21888;
    ldv_21887: 
#line 339
    shift = shift - 1;
#line 340
    npages = npages * 2;
    ldv_21888: ;
#line 338
    if (((dma_addr_t )((1 << shift) + -1) & t) != 0ULL) {
#line 339
      goto ldv_21887;
    } else {
#line 341
      goto ldv_21889;
    }
    ldv_21889: 
#line 343
    tmp___0 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 343
    dma_list = (u64 *)tmp___0;
#line 344
    if ((unsigned long )dma_list == (unsigned long )((u64 *)0)) {
#line 345
      goto err_free;
    } else {

    }
#line 347
    i = 0;
#line 347
    goto ldv_21892;
    ldv_21891: 
#line 348
    *(dma_list + (unsigned long )i) = (dma_addr_t )(i << shift) + t;
#line 347
    i = i + 1;
    ldv_21892: ;
#line 347
    if (i < npages) {
#line 348
      goto ldv_21891;
    } else {
#line 350
      goto ldv_21893;
    }
    ldv_21893: ;
  } else {
#line 350
    *is_direct = 0;
#line 351
    npages = (int )(((unsigned long )size + 4095UL) / 4096UL);
#line 352
    shift = 12;
#line 354
    tmp___1 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 354
    dma_list = (u64 *)tmp___1;
#line 355
    if ((unsigned long )dma_list == (unsigned long )((u64 *)0)) {
#line 356
      return (-12);
    } else {

    }
#line 358
    tmp___2 = kmalloc((unsigned long )npages * 16UL, 208U);
#line 358
    buf->page_list = (struct mthca_buf_list *)tmp___2;
#line 360
    if ((unsigned long )buf->page_list == (unsigned long )((struct mthca_buf_list *)0)) {
#line 361
      goto err_out;
    } else {

    }
#line 363
    i = 0;
#line 363
    goto ldv_21896;
    ldv_21895: 
#line 364
    (buf->page_list + (unsigned long )i)->buf = 0;
#line 363
    i = i + 1;
    ldv_21896: ;
#line 363
    if (i < npages) {
#line 364
      goto ldv_21895;
    } else {
#line 366
      goto ldv_21897;
    }
    ldv_21897: 
#line 366
    i = 0;
#line 366
    goto ldv_21899;
    ldv_21898: 
#line 367
    (buf->page_list + (unsigned long )i)->buf = dma_alloc_attrs(& (dev->pdev)->dev,
                                                                4096UL, & t, 208U,
                                                                0);
#line 370
    if ((unsigned long )(buf->page_list + (unsigned long )i)->buf == (unsigned long )((void *)0)) {
#line 371
      goto err_free;
    } else {

    }
#line 373
    *(dma_list + (unsigned long )i) = t;
#line 374
    (buf->page_list + (unsigned long )i)->mapping = t;
#line 376
    clear_page((buf->page_list + (unsigned long )i)->buf);
#line 366
    i = i + 1;
    ldv_21899: ;
#line 366
    if (i < npages) {
#line 367
      goto ldv_21898;
    } else {
#line 369
      goto ldv_21900;
    }
    ldv_21900: ;
  }
#line 380
  if (hca_write != 0) {
#line 380
    tmp___3 = 3072U;
  } else {
#line 380
    tmp___3 = 1024U;
  }
#line 380
  err = mthca_mr_alloc_phys(dev, pd->pd_num, dma_list, shift, npages, 0ULL, (u64 )size,
                            tmp___3, mr);
#line 386
  if (err != 0) {
#line 387
    goto err_free;
  } else {

  }
#line 389
  kfree((void const   *)dma_list);
#line 391
  return (0);
  err_free: 
#line 394
  mthca_buf_free(dev, size, buf, *is_direct, 0);
  err_out: 
#line 397
  kfree((void const   *)dma_list);
#line 399
  return (err);
}
}
#line 402 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void mthca_buf_free(struct mthca_dev *dev , int size , union mthca_buf *buf , int is_direct ,
                    struct mthca_mr *mr ) 
{ int i ;

  {
#line 407
  if ((unsigned long )mr != (unsigned long )((struct mthca_mr *)0)) {
#line 408
    mthca_free_mr(dev, mr);
  } else {

  }
#line 410
  if (is_direct != 0) {
#line 411
    dma_free_attrs(& (dev->pdev)->dev, (size_t )size, buf->direct.buf, buf->direct.mapping,
                   0);
  } else {
#line 414
    i = 0;
#line 414
    goto ldv_21910;
    ldv_21909: 
#line 415
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (buf->page_list + (unsigned long )i)->buf,
                   (buf->page_list + (unsigned long )i)->mapping, 0);
#line 414
    i = i + 1;
    ldv_21910: ;
#line 414
    if ((unsigned long )i < ((unsigned long )size + 4095UL) / 4096UL) {
#line 415
      goto ldv_21909;
    } else {
#line 417
      goto ldv_21911;
    }
    ldv_21911: 
#line 419
    kfree((void const   *)buf->page_list);
  }
#line 421
  return;
}
}
#line 423 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void ldv_mutex_lock_59(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 428
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 430
  mutex_lock(ldv_func_arg1);
#line 431
  return;
}
}
#line 433 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 438
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 440
  mutex_unlock(ldv_func_arg1);
#line 441
  return;
}
}
#line 443 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 448
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 450
  mutex_lock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
int ldv_mutex_trylock_62(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 458
  tmp = mutex_trylock(ldv_func_arg1);
#line 458
  ldv_func_res = tmp;
#line 460
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 460
  return (tmp___0);
#line 462
  return (ldv_func_res);
}
}
#line 465 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_allocator.c.prepared"
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 470
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 472
  mutex_unlock(ldv_func_arg1);
#line 473
  return;
}
}
#line 361 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_72(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_71(struct mutex *ldv_func_arg1 ) ;
#line 85 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 

  {
#line 85
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 86
  return;
}
}
#line 329 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 332 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ struct page *tmp ;

  {
#line 334
  tmp = alloc_pages_current(gfp_mask, order);
#line 334
  return (tmp);
}
}
#line 365
extern void __free_pages(struct page * , unsigned int  ) ;
#line 125 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 130 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
#line 133
  tmp = request_threaded_irq(irq, handler, 0, flags, name, dev);
#line 133
  return (tmp);
}
}
#line 178
extern void free_irq(unsigned int  , void * ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 

  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 63 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 

  {
#line 65
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 

  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 71 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 79
  if (tmp___2 != 0L) {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_20324: ;
#line 79
    goto ldv_20324;
  } else {

  }
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, 0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 83
  return (addr);
}
}
#line 86 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 91
  if (tmp___1 != 0L) {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_20332: ;
#line 91
    goto ldv_20332;
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, 0);
  } else {

  }
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 95
  return;
}
}
#line 47 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
#line 26
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 26
    tmp = & hwdev->dev;
  } else {
#line 26
    tmp = 0;
  }
#line 26
  dma_free_attrs(tmp, size, vaddr, dma_handle, 0);
#line 27
  return;
}
}
#line 43 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 46
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 46
    tmp = & hwdev->dev;
  } else {
#line 46
    tmp = 0;
  }
#line 46
  tmp___0 = dma_map_page(tmp, page, offset, size, (enum dma_data_direction )direction);
#line 46
  return (tmp___0);
}
}
#line 50 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 53
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 53
    tmp = & hwdev->dev;
  } else {
#line 53
    tmp = 0;
  }
#line 53
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
#line 54
  return;
}
}
#line 99 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ int tmp ;

  {
#line 101
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
#line 101
  return (tmp);
}
}
#line 1312 "include/rdma/ib_verbs.h"
extern void ib_dispatch_event(struct ib_event * ) ;
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write64(u32 hi , u32 lo , void *dest , spinlock_t *doorbell_lock ) 
{ __u64 tmp ;

  {
#line 62
  tmp = __fswab64(((unsigned long long )hi << 32) | (unsigned long long )lo);
#line 62
  writeq((unsigned long )tmp, (void volatile   *)dest);
#line 63
  return;
}
}
#line 503 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
void mthca_cq_completion(struct mthca_dev *dev , u32 cqn ) ;
#line 504
void mthca_cq_event(struct mthca_dev *dev , u32 cqn , enum ib_event_type event_type ) ;
#line 519
void mthca_srq_event(struct mthca_dev *dev , u32 srqn , enum ib_event_type event_type ) ;
#line 527
void mthca_qp_event(struct mthca_dev *dev , u32 qpn , enum ib_event_type event_type ) ;
#line 286 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static u64 async_mask(struct mthca_dev *dev ) 
{ unsigned long long tmp ;

  {
#line 288
  if ((dev->mthca_flags & 4UL) != 0UL) {
#line 288
    tmp = 2049022ULL;
  } else {
#line 288
    tmp = 214014ULL;
  }
#line 288
  return (tmp);
}
}
#line 293 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void tavor_set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq ,
                                     u32 ci ) 
{ 

  {
#line 303
  __asm__  volatile   ("sfence": : : "memory");
#line 304
  mthca_write64((u32 )(eq->eqn | 67108864), (u32 )(eq->nent + -1) & ci, dev->kar + 40UL,
                0);
#line 306
  return;
}
}
#line 309 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void arbel_set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq ,
                                     u32 ci ) 
{ __u32 tmp ;

  {
#line 312
  __asm__  volatile   ("sfence": : : "memory");
#line 313
  tmp = __fswab32(ci);
#line 313
  __writel(tmp, (void volatile   *)dev->eq_regs.arbel.eq_set_ci_base + (unsigned long )(eq->eqn * 8));
#line 316
  __asm__  volatile   ("mfence": : : "memory");
#line 317
  return;
}
}
#line 319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void set_eq_ci(struct mthca_dev *dev , struct mthca_eq *eq , u32 ci ) 
{ int tmp ;

  {
#line 321
  tmp = mthca_is_memfree(dev);
#line 321
  if (tmp != 0) {
#line 322
    arbel_set_eq_ci(dev, eq, ci);
  } else {
#line 324
    tavor_set_eq_ci(dev, eq, ci);
  }
#line 325
  return;
}
}
#line 327 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void tavor_eq_req_not(struct mthca_dev *dev , int eqn ) 
{ 

  {
#line 329
  mthca_write64((u32 )(eqn | 33554432), 0U, dev->kar + 40UL, 0);
#line 331
  return;
}
}
#line 334 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void arbel_eq_req_not(struct mthca_dev *dev , u32 eqn_mask ) 
{ 

  {
#line 336
  writel(eqn_mask, (void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 337
  return;
}
}
#line 339 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void disarm_cq(struct mthca_dev *dev , int eqn , int cqn ) 
{ int tmp ;

  {
#line 341
  tmp = mthca_is_memfree(dev);
#line 341
  if (tmp == 0) {
#line 342
    mthca_write64((u32 )(eqn | 50331648), (u32 )cqn, dev->kar + 40UL, 0);
  } else {

  }
#line 344
  return;
}
}
#line 348 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static struct mthca_eqe *get_eqe(struct mthca_eq *eq , u32 entry ) 
{ unsigned long off ;

  {
#line 350
  off = (unsigned long )(((u32 )(eq->nent + -1) & entry) * 32U);
#line 351
  return ((struct mthca_eqe *)((eq->page_list + off / 4096UL)->buf + (off & 4095UL)));
}
}
#line 354 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static struct mthca_eqe *next_eqe_sw(struct mthca_eq *eq ) 
{ struct mthca_eqe *eqe ;
  struct mthca_eqe *tmp ;

  {
#line 357
  eqe = get_eqe(eq, eq->cons_index);
#line 358
  if ((int )((signed char )eqe->owner) >= 0) {
#line 358
    tmp = eqe;
  } else {
#line 358
    tmp = 0;
  }
#line 358
  return (tmp);
}
}
#line 361 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
__inline static void set_eqe_hw(struct mthca_eqe *eqe ) 
{ 

  {
#line 363
  eqe->owner = 128U;
#line 364
  return;
}
}
#line 366 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static void port_change(struct mthca_dev *dev , int port , int active ) 
{ struct ib_event record ;
  char *tmp ;

  {
#line 370
  if (mthca_debug_level != 0) {
#line 370
    if (active != 0) {
#line 370
      tmp = (char *)"active";
    } else {
#line 370
      tmp = (char *)"down";
    }
#line 370
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Port change to %s for port %d\n",
               tmp, port);
  } else {

  }
#line 373
  record.device = & dev->ib_dev;
#line 374
  if (active != 0) {
#line 374
    record.event = 9;
  } else {
#line 374
    record.event = 10;
  }
#line 375
  record.element.port_num = (u8 )port;
#line 377
  ib_dispatch_event(& record);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static int mthca_eq_int(struct mthca_dev *dev , struct mthca_eq *eq ) 
{ struct mthca_eqe *eqe ;
  int disarm_cqn ;
  int eqes_found ;
  int set_ci ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u64 tmp___9 ;
  __u16 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  char *tmp___13 ;
  __u32 tmp___14 ;
  long tmp___15 ;

  {
#line 384
  eqes_found = 0;
#line 385
  set_ci = 0;
#line 387
  goto ldv_23826;
  ldv_23825: 
#line 392
  __asm__  volatile   ("lfence": : : "memory");
#line 394
  switch ((int )eqe->type) {
  case 0: 
#line 396
  tmp = __fswab32(eqe->event.comp.cqn);
#line 396
  disarm_cqn = (int )tmp & 16777215;
#line 397
  disarm_cq(dev, eq->eqn, disarm_cqn);
#line 398
  mthca_cq_completion(dev, (u32 )disarm_cqn);
#line 399
  goto ldv_23806;
  case 1: 
#line 402
  tmp___0 = __fswab32(eqe->event.qp.qpn);
#line 402
  mthca_qp_event(dev, tmp___0 & 16777215U, 6);
#line 404
  goto ldv_23806;
  case 2: 
#line 407
  tmp___1 = __fswab32(eqe->event.qp.qpn);
#line 407
  mthca_qp_event(dev, tmp___1 & 16777215U, 4);
#line 409
  goto ldv_23806;
  case 3: 
#line 412
  tmp___2 = __fswab32(eqe->event.qp.qpn);
#line 412
  mthca_qp_event(dev, tmp___2 & 16777215U, 5);
#line 414
  goto ldv_23806;
  case 19: 
#line 417
  tmp___3 = __fswab32(eqe->event.qp.qpn);
#line 417
  mthca_qp_event(dev, tmp___3 & 16777215U, 16);
#line 419
  goto ldv_23806;
  case 20: 
#line 422
  tmp___4 = __fswab32(eqe->event.srq.srqn);
#line 422
  mthca_srq_event(dev, tmp___4 & 16777215U, 15);
#line 424
  goto ldv_23806;
  case 5: 
#line 427
  tmp___5 = __fswab32(eqe->event.qp.qpn);
#line 427
  mthca_qp_event(dev, tmp___5 & 16777215U, 1);
#line 429
  goto ldv_23806;
  case 7: 
#line 432
  tmp___6 = __fswab32(eqe->event.qp.qpn);
#line 432
  mthca_qp_event(dev, tmp___6 & 16777215U, 7);
#line 434
  goto ldv_23806;
  case 16: 
#line 437
  tmp___7 = __fswab32(eqe->event.qp.qpn);
#line 437
  mthca_qp_event(dev, tmp___7 & 16777215U, 2);
#line 439
  goto ldv_23806;
  case 17: 
#line 442
  tmp___8 = __fswab32(eqe->event.qp.qpn);
#line 442
  mthca_qp_event(dev, tmp___8 & 16777215U, 3);
#line 444
  goto ldv_23806;
  case 10: 
#line 447
  tmp___9 = __fswab64(eqe->event.cmd.out_param);
#line 447
  tmp___10 = __fswab16((int )eqe->event.cmd.token);
#line 447
  mthca_cmd_event(dev, (int )tmp___10, (int )eqe->event.cmd.status, tmp___9);
#line 451
  goto ldv_23806;
  case 9: 
#line 454
  tmp___11 = __fswab32(eqe->event.port_change.port);
#line 454
  port_change(dev, (int )(tmp___11 >> 28) & 3, (unsigned int )eqe->subtype == 4U);
#line 457
  goto ldv_23806;
  case 4: 
#line 460
  tmp___12 = __fswab32(eqe->event.cq_err.cqn);
#line 460
  if ((unsigned int )eqe->event.cq_err.syndrome == 1U) {
#line 460
    tmp___13 = (char *)"overrun";
  } else {
#line 460
    tmp___13 = (char *)"access violation";
  }
#line 460
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CQ %s on CQN %06x\n", tmp___13,
           tmp___12 & 16777215U);
#line 464
  tmp___14 = __fswab32(eqe->event.cq_err.cqn);
#line 464
  mthca_cq_event(dev, tmp___14, 0);
#line 466
  goto ldv_23806;
  case 15: 
#line 469
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "EQ overrun on EQN %d\n",
           eq->eqn);
#line 470
  goto ldv_23806;
  case 6: ;
  case 18: ;
  case 8: ;
  case 14: ;
  default: 
#line 477
  dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Unhandled event %02x(%02x) on EQ %d\n",
           (int )eqe->type, (int )eqe->subtype, eq->eqn);
#line 479
  goto ldv_23806;
  }
  ldv_23806: 
#line 482
  set_eqe_hw(eqe);
#line 483
  eq->cons_index = eq->cons_index + 1U;
#line 484
  eqes_found = 1;
#line 485
  set_ci = set_ci + 1;
#line 494
  tmp___15 = ldv__builtin_expect(set_ci > 127, 0L);
#line 494
  if (tmp___15 != 0L) {
#line 499
    set_eq_ci(dev, eq, eq->cons_index);
#line 500
    set_ci = 0;
  } else {

  }
  ldv_23826: 
#line 387
  eqe = next_eqe_sw(eq);
#line 387
  if ((unsigned long )eqe != (unsigned long )((struct mthca_eqe *)0)) {
#line 388
    goto ldv_23825;
  } else {
#line 390
    goto ldv_23827;
  }
  ldv_23827: ;
#line 508
  return (eqes_found);
}
}
#line 511 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static irqreturn_t mthca_tavor_interrupt(int irq , void *dev_ptr ) 
{ struct mthca_dev *dev ;
  u32 ecr ;
  int i ;
  int tmp ;

  {
#line 513
  dev = (struct mthca_dev *)dev_ptr;
#line 517
  if (dev->eq_table.clr_mask != 0U) {
#line 518
    writel(dev->eq_table.clr_mask, (void volatile   *)dev->eq_table.clr_int);
  } else {

  }
#line 520
  ecr = readl((void const volatile   *)dev->eq_regs.tavor.ecr_base + 4U);
#line 521
  if (ecr == 0U) {
#line 522
    return (0);
  } else {

  }
#line 524
  writel(ecr, (void volatile   *)dev->eq_regs.tavor.ecr_base + 12U);
#line 527
  i = 0;
#line 527
  goto ldv_23836;
  ldv_23835: ;
#line 528
  if ((dev->eq_table.eq[i].eqn_mask & ecr) != 0U) {
#line 529
    tmp = mthca_eq_int(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 529
    if (tmp != 0) {
#line 530
      tavor_set_eq_ci(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i,
                      dev->eq_table.eq[i].cons_index);
    } else {

    }
#line 532
    tavor_eq_req_not(dev, dev->eq_table.eq[i].eqn);
  } else {

  }
#line 527
  i = i + 1;
  ldv_23836: ;
#line 527
  if (i <= 2) {
#line 528
    goto ldv_23835;
  } else {
#line 530
    goto ldv_23837;
  }
  ldv_23837: ;
#line 535
  return (1);
}
}
#line 538 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static irqreturn_t mthca_tavor_msi_x_interrupt(int irq , void *eq_ptr ) 
{ struct mthca_eq *eq ;
  struct mthca_dev *dev ;

  {
#line 540
  eq = (struct mthca_eq *)eq_ptr;
#line 541
  dev = eq->dev;
#line 543
  mthca_eq_int(dev, eq);
#line 544
  tavor_set_eq_ci(dev, eq, eq->cons_index);
#line 545
  tavor_eq_req_not(dev, eq->eqn);
#line 548
  return (1);
}
}
#line 551 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static irqreturn_t mthca_arbel_interrupt(int irq , void *dev_ptr ) 
{ struct mthca_dev *dev ;
  int work ;
  int i ;
  int tmp ;

  {
#line 553
  dev = (struct mthca_dev *)dev_ptr;
#line 554
  work = 0;
#line 557
  if (dev->eq_table.clr_mask != 0U) {
#line 558
    writel(dev->eq_table.clr_mask, (void volatile   *)dev->eq_table.clr_int);
  } else {

  }
#line 560
  i = 0;
#line 560
  goto ldv_23852;
  ldv_23851: 
#line 561
  tmp = mthca_eq_int(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 561
  if (tmp != 0) {
#line 562
    work = 1;
#line 563
    arbel_set_eq_ci(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i,
                    dev->eq_table.eq[i].cons_index);
  } else {

  }
#line 560
  i = i + 1;
  ldv_23852: ;
#line 560
  if (i <= 2) {
#line 561
    goto ldv_23851;
  } else {
#line 563
    goto ldv_23853;
  }
  ldv_23853: 
#line 567
  arbel_eq_req_not(dev, dev->eq_table.arm_mask);
#line 569
  return (work != 0);
}
}
#line 572 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static irqreturn_t mthca_arbel_msi_x_interrupt(int irq , void *eq_ptr ) 
{ struct mthca_eq *eq ;
  struct mthca_dev *dev ;

  {
#line 574
  eq = (struct mthca_eq *)eq_ptr;
#line 575
  dev = eq->dev;
#line 577
  mthca_eq_int(dev, eq);
#line 578
  arbel_set_eq_ci(dev, eq, eq->cons_index);
#line 579
  arbel_eq_req_not(dev, eq->eqn_mask);
#line 582
  return (1);
}
}
#line 585 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static int mthca_create_eq(struct mthca_dev *dev , int nent , u8 intr , struct mthca_eq *eq ) 
{ int npages ;
  u64 *dma_list ;
  dma_addr_t t ;
  struct mthca_mailbox *mailbox ;
  struct mthca_eq_context *eq_context ;
  int err ;
  int i ;
  int _max1 ;
  int _max2 ;
  int tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  struct mthca_eqe *tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  int tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;

  {
#line 591
  dma_list = 0;
#line 595
  err = -12;
#line 598
  eq->dev = dev;
#line 599
  _max1 = nent;
#line 599
  _max2 = 2;
#line 599
  if (_max1 > _max2) {
#line 599
    tmp = _max1;
  } else {
#line 599
    tmp = _max2;
  }
#line 599
  tmp___0 = __roundup_pow_of_two((unsigned long )tmp);
#line 599
  eq->nent = (int )tmp___0;
#line 600
  npages = (int )((unsigned long )((eq->nent * 32 + 4095) & -4096) / 4096UL);
#line 602
  tmp___1 = kmalloc((unsigned long )npages * 16UL, 208U);
#line 602
  eq->page_list = (struct mthca_buf_list *)tmp___1;
#line 604
  if ((unsigned long )eq->page_list == (unsigned long )((struct mthca_buf_list *)0)) {
#line 605
    goto err_out;
  } else {

  }
#line 607
  i = 0;
#line 607
  goto ldv_24091;
  ldv_24090: 
#line 608
  (eq->page_list + (unsigned long )i)->buf = 0;
#line 607
  i = i + 1;
  ldv_24091: ;
#line 607
  if (i < npages) {
#line 608
    goto ldv_24090;
  } else {
#line 610
    goto ldv_24092;
  }
  ldv_24092: 
#line 610
  tmp___2 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 610
  dma_list = (u64 *)tmp___2;
#line 611
  if ((unsigned long )dma_list == (unsigned long )((u64 *)0)) {
#line 612
    goto err_out_free;
  } else {

  }
#line 614
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 615
  tmp___3 = IS_ERR((void const   *)mailbox);
#line 615
  if (tmp___3 != 0L) {
#line 616
    goto err_out_free;
  } else {

  }
#line 617
  eq_context = (struct mthca_eq_context *)mailbox->buf;
#line 619
  i = 0;
#line 619
  goto ldv_24096;
  ldv_24095: 
#line 620
  (eq->page_list + (unsigned long )i)->buf = dma_alloc_attrs(& (dev->pdev)->dev, 4096UL,
                                                             & t, 208U, 0);
#line 622
  if ((unsigned long )(eq->page_list + (unsigned long )i)->buf == (unsigned long )((void *)0)) {
#line 623
    goto err_out_free_pages;
  } else {

  }
#line 625
  *(dma_list + (unsigned long )i) = t;
#line 626
  (eq->page_list + (unsigned long )i)->mapping = t;
#line 628
  clear_page((eq->page_list + (unsigned long )i)->buf);
#line 619
  i = i + 1;
  ldv_24096: ;
#line 619
  if (i < npages) {
#line 620
    goto ldv_24095;
  } else {
#line 622
    goto ldv_24097;
  }
  ldv_24097: 
#line 631
  i = 0;
#line 631
  goto ldv_24099;
  ldv_24098: 
#line 632
  tmp___4 = get_eqe(eq, (u32 )i);
#line 632
  set_eqe_hw(tmp___4);
#line 631
  i = i + 1;
  ldv_24099: ;
#line 631
  if (eq->nent > i) {
#line 632
    goto ldv_24098;
  } else {
#line 634
    goto ldv_24100;
  }
  ldv_24100: 
#line 634
  tmp___5 = mthca_alloc(& dev->eq_table.alloc);
#line 634
  eq->eqn = (int )tmp___5;
#line 635
  if (eq->eqn == -1) {
#line 636
    goto err_out_free_pages;
  } else {

  }
#line 638
  err = mthca_mr_alloc_phys(dev, dev->driver_pd.pd_num, dma_list, 12, npages, 0ULL,
                            (u64 )((unsigned long )npages * 4096UL), 3072U, & eq->mr);
#line 644
  if (err != 0) {
#line 645
    goto err_out_free_eq;
  } else {

  }
#line 647
  memset((void *)eq_context, 0, 64UL);
#line 648
  eq_context->flags = 66561U;
#line 652
  tmp___6 = mthca_is_memfree(dev);
#line 652
  if (tmp___6 != 0) {
#line 653
    eq_context->flags = eq_context->flags | 524288U;
  } else {

  }
#line 655
  tmp___7 = ffs(eq->nent);
#line 655
  tmp___8 = __fswab32((__u32 )((tmp___7 + -1) << 24));
#line 655
  eq_context->logsize_usrpage = tmp___8;
#line 656
  tmp___12 = mthca_is_memfree(dev);
#line 656
  if (tmp___12 != 0) {
#line 657
    tmp___9 = __fswab32(dev->driver_pd.pd_num);
#line 657
    eq_context->arbel_pd = tmp___9;
  } else {
#line 659
    tmp___10 = __fswab32((__u32 )dev->driver_uar.index);
#line 659
    eq_context->logsize_usrpage = eq_context->logsize_usrpage | tmp___10;
#line 660
    tmp___11 = __fswab32(dev->driver_pd.pd_num);
#line 660
    eq_context->tavor_pd = tmp___11;
  }
#line 662
  eq_context->intr = intr;
#line 663
  tmp___13 = __fswab32(eq->mr.ibmr.lkey);
#line 663
  eq_context->lkey = tmp___13;
#line 665
  err = mthca_SW2HW_EQ(dev, mailbox, eq->eqn);
#line 666
  if (err != 0) {
#line 667
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_EQ returned %d\n",
             err);
#line 668
    goto err_out_free_mr;
  } else {

  }
#line 671
  kfree((void const   *)dma_list);
#line 672
  mthca_free_mailbox(dev, mailbox);
#line 674
  tmp___14 = __fswab32((__u32 )(1 << eq->eqn));
#line 674
  eq->eqn_mask = tmp___14;
#line 675
  eq->cons_index = 0U;
#line 677
  dev->eq_table.arm_mask = dev->eq_table.arm_mask | eq->eqn_mask;
#line 679
  if (mthca_debug_level != 0) {
#line 679
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Allocated EQ %d with %d entries\n",
               eq->eqn, eq->nent);
  } else {

  }
#line 682
  return (err);
  err_out_free_mr: 
#line 685
  mthca_free_mr(dev, & eq->mr);
  err_out_free_eq: 
#line 688
  mthca_free(& dev->eq_table.alloc, (u32 )eq->eqn);
  err_out_free_pages: 
#line 691
  i = 0;
#line 691
  goto ldv_24104;
  ldv_24103: ;
#line 692
  if ((unsigned long )(eq->page_list + (unsigned long )i)->buf != (unsigned long )((void *)0)) {
#line 693
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (eq->page_list + (unsigned long )i)->buf,
                   (eq->page_list + (unsigned long )i)->mapping, 0);
  } else {

  }
#line 691
  i = i + 1;
  ldv_24104: ;
#line 691
  if (i < npages) {
#line 692
    goto ldv_24103;
  } else {
#line 694
    goto ldv_24105;
  }
  ldv_24105: 
#line 698
  mthca_free_mailbox(dev, mailbox);
  err_out_free: 
#line 701
  kfree((void const   *)eq->page_list);
#line 702
  kfree((void const   *)dma_list);
  err_out: ;
#line 705
  return (err);
}
}
#line 708 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static void mthca_free_eq(struct mthca_dev *dev , struct mthca_eq *eq ) 
{ struct mthca_mailbox *mailbox ;
  int err ;
  int npages ;
  int i ;
  long tmp ;
  __u32 tmp___0 ;

  {
#line 713
  npages = (int )(((unsigned long )(eq->nent * 32) + 4095UL) / 4096UL);
#line 717
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 718
  tmp = IS_ERR((void const   *)mailbox);
#line 718
  if (tmp != 0L) {
#line 719
    return;
  } else {

  }
#line 721
  err = mthca_HW2SW_EQ(dev, mailbox, eq->eqn);
#line 722
  if (err != 0) {
#line 723
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_EQ returned %d\n",
             err);
  } else {

  }
#line 725
  dev->eq_table.arm_mask = dev->eq_table.arm_mask & ~ eq->eqn_mask;
#line 727
  if (0) {
#line 728
    if (mthca_debug_level != 0) {
#line 728
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping EQ context %02x:\n",
                 eq->eqn);
    } else {

    }
#line 729
    i = 0;
#line 729
    goto ldv_24115;
    ldv_24114: ;
#line 730
    if (((unsigned int )i & 3U) == 0U) {
#line 731
      printk("[%02x] ", i * 4);
    } else {

    }
#line 732
    tmp___0 = __be32_to_cpup((__be32 const   *)mailbox->buf + (unsigned long )(i * 4));
#line 732
    printk(" %08x", tmp___0);
#line 733
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 734
      printk("\n");
    } else {

    }
#line 729
    i = i + 1;
    ldv_24115: ;
#line 729
    if ((unsigned int )i <= 15U) {
#line 730
      goto ldv_24114;
    } else {
#line 732
      goto ldv_24116;
    }
    ldv_24116: ;
  } else {

  }
#line 738
  mthca_free_mr(dev, & eq->mr);
#line 739
  i = 0;
#line 739
  goto ldv_24118;
  ldv_24117: 
#line 740
  pci_free_consistent(dev->pdev, 4096UL, (eq->page_list + (unsigned long )i)->buf,
                      (eq->page_list + (unsigned long )i)->mapping);
#line 739
  i = i + 1;
  ldv_24118: ;
#line 739
  if (i < npages) {
#line 740
    goto ldv_24117;
  } else {
#line 742
    goto ldv_24119;
  }
  ldv_24119: 
#line 744
  kfree((void const   *)eq->page_list);
#line 745
  mthca_free_mailbox(dev, mailbox);
#line 746
  return;
}
}
#line 748 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static void mthca_free_irqs(struct mthca_dev *dev ) 
{ int i ;

  {
#line 752
  if (dev->eq_table.have_irq != 0) {
#line 753
    free_irq((dev->pdev)->irq, (void *)dev);
  } else {

  }
#line 754
  i = 0;
#line 754
  goto ldv_24125;
  ldv_24124: ;
#line 755
  if (dev->eq_table.eq[i].have_irq != 0) {
#line 756
    free_irq((unsigned int )dev->eq_table.eq[i].msi_x_vector, (void *)(& dev->eq_table.eq) + (unsigned long )i);
#line 758
    dev->eq_table.eq[i].have_irq = 0;
  } else {

  }
#line 754
  i = i + 1;
  ldv_24125: ;
#line 754
  if (i <= 2) {
#line 755
    goto ldv_24124;
  } else {
#line 757
    goto ldv_24126;
  }
  ldv_24126: ;
#line 759
  return;
}
}
#line 762 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static int mthca_map_reg(struct mthca_dev *dev , unsigned long offset , unsigned long size ,
                         void **map ) 
{ phys_addr_t base ;

  {
#line 766
  base = (dev->pdev)->resource[0].start;
#line 768
  *map = ioremap(base + (unsigned long long )offset, size);
#line 769
  if ((unsigned long )*map == (unsigned long )((void *)0)) {
#line 770
    return (-12);
  } else {

  }
#line 772
  return (0);
}
}
#line 775 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static int mthca_map_eq_regs(struct mthca_dev *dev ) 
{ unsigned long long tmp ;
  int tmp___0 ;
  unsigned long long tmp___1 ;
  int tmp___2 ;
  unsigned long long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 777
  tmp___7 = mthca_is_memfree(dev);
#line 777
  if (tmp___7 != 0) {
#line 785
    if ((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start) {
#line 785
      tmp = (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start;
    } else {
#line 785
      tmp = 0xffffffffffffffffULL;
    }
#line 785
    tmp___0 = mthca_map_reg(dev, (unsigned long )(tmp & dev->fw.arbel.clr_int_base),
                            8UL, & dev->clr_base);
#line 785
    if (tmp___0 != 0) {
#line 788
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map interrupt clear register, aborting.\n");
#line 790
      return (-12);
    } else {

    }
#line 797
    if ((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start) {
#line 797
      tmp___1 = (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start;
    } else {
#line 797
      tmp___1 = 0xffffffffffffffffULL;
    }
#line 797
    tmp___2 = mthca_map_reg(dev, (unsigned long )((tmp___1 & dev->fw.arbel.eq_arm_base) + 4ULL),
                            4UL, & dev->eq_regs.arbel.eq_arm);
#line 797
    if (tmp___2 != 0) {
#line 800
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map EQ arm register, aborting.\n");
#line 801
      iounmap((void volatile   *)dev->clr_base);
#line 802
      return (-12);
    } else {

    }
#line 805
    if ((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start) {
#line 805
      tmp___3 = (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start;
    } else {
#line 805
      tmp___3 = 0xffffffffffffffffULL;
    }
#line 805
    tmp___4 = mthca_map_reg(dev, (unsigned long )(tmp___3 & dev->fw.arbel.eq_set_ci_base),
                            256UL, & dev->eq_regs.arbel.eq_set_ci_base);
#line 805
    if (tmp___4 != 0) {
#line 809
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map EQ CI register, aborting.\n");
#line 810
      iounmap((void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 811
      iounmap((void volatile   *)dev->clr_base);
#line 812
      return (-12);
    } else {

    }
  } else {
#line 815
    tmp___5 = mthca_map_reg(dev, 983256UL, 8UL, & dev->clr_base);
#line 815
    if (tmp___5 != 0) {
#line 817
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map interrupt clear register, aborting.\n");
#line 819
      return (-12);
    } else {

    }
#line 822
    tmp___6 = mthca_map_reg(dev, 526080UL, 16UL, & dev->eq_regs.tavor.ecr_base);
#line 822
    if (tmp___6 != 0) {
#line 825
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Couldn\'t map ecr register, aborting.\n");
#line 827
      iounmap((void volatile   *)dev->clr_base);
#line 828
      return (-12);
    } else {

    }
  }
#line 832
  return (0);
}
}
#line 836 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
static void mthca_unmap_eq_regs(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 838
  tmp = mthca_is_memfree(dev);
#line 838
  if (tmp != 0) {
#line 839
    iounmap((void volatile   *)dev->eq_regs.arbel.eq_set_ci_base);
#line 840
    iounmap((void volatile   *)dev->eq_regs.arbel.eq_arm);
#line 841
    iounmap((void volatile   *)dev->clr_base);
  } else {
#line 843
    iounmap((void volatile   *)dev->eq_regs.tavor.ecr_base);
#line 844
    iounmap((void volatile   *)dev->clr_base);
  }
#line 846
  return;
}
}
#line 848 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
int mthca_map_eq_icm(struct mthca_dev *dev , u64 icm_virt ) 
{ int ret ;
  int tmp ;

  {
#line 858
  dev->eq_table.icm_virt = icm_virt;
#line 859
  dev->eq_table.icm_page = alloc_pages(131282U, 0U);
#line 860
  if ((unsigned long )dev->eq_table.icm_page == (unsigned long )((struct page *)0)) {
#line 861
    return (-12);
  } else {

  }
#line 862
  dev->eq_table.icm_dma = pci_map_page(dev->pdev, dev->eq_table.icm_page, 0UL, 4096UL,
                                       0);
#line 864
  tmp = pci_dma_mapping_error(dev->pdev, dev->eq_table.icm_dma);
#line 864
  if (tmp != 0) {
#line 865
    __free_pages(dev->eq_table.icm_page, 0U);
#line 866
    return (-12);
  } else {

  }
#line 869
  ret = mthca_MAP_ICM_page(dev, dev->eq_table.icm_dma, icm_virt);
#line 870
  if (ret != 0) {
#line 871
    pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, 4096UL, 0);
#line 873
    __free_pages(dev->eq_table.icm_page, 0U);
  } else {

  }
#line 876
  return (ret);
}
}
#line 879 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void mthca_unmap_eq_icm(struct mthca_dev *dev ) 
{ 

  {
#line 881
  mthca_UNMAP_ICM(dev, dev->eq_table.icm_virt, 1U);
#line 882
  pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, 4096UL, 0);
#line 884
  __free_pages(dev->eq_table.icm_page, 0U);
#line 885
  return;
}
}
#line 887 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
int mthca_init_eq_table(struct mthca_dev *dev ) 
{ int err ;
  u8 intr ;
  int i ;
  __u32 tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *eq_name[3U] ;
  char const   *tmp___4 ;
  irqreturn_t (*tmp___6)(int irq , void *eq_ptr ) ;
  int tmp___7 ;
  char const   *tmp___8 ;
  irqreturn_t (*tmp___10)(int irq , void *dev_ptr ) ;
  int tmp___11 ;
  u64 tmp___12 ;
  int tmp___13 ;

  {
#line 893
  err = mthca_alloc_init(& dev->eq_table.alloc, (u32 )dev->limits.num_eqs, (u32 )(dev->limits.num_eqs + -1),
                         (u32 )dev->limits.reserved_eqs);
#line 897
  if (err != 0) {
#line 898
    return (err);
  } else {

  }
#line 900
  err = mthca_map_eq_regs(dev);
#line 901
  if (err != 0) {
#line 902
    goto err_out_free;
  } else {

  }
#line 904
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 905
    dev->eq_table.clr_mask = 0U;
  } else {
#line 907
    tmp = __fswab32((__u32 )(1 << ((int )dev->eq_table.inta_pin & 31)));
#line 907
    dev->eq_table.clr_mask = tmp;
#line 909
    if ((unsigned int )dev->eq_table.inta_pin <= 31U) {
#line 909
      tmp___0 = 4UL;
    } else {
#line 909
      tmp___0 = 0UL;
    }
#line 909
    dev->eq_table.clr_int = dev->clr_base + tmp___0;
  }
#line 913
  dev->eq_table.arm_mask = 0U;
#line 915
  intr = dev->eq_table.inta_pin;
#line 917
  if ((dev->mthca_flags & 8UL) == 0UL) {
#line 917
    tmp___1 = (int )intr;
  } else {
#line 917
    tmp___1 = 128;
  }
#line 917
  err = mthca_create_eq(dev, dev->limits.num_cqs + 128, tmp___1, (struct mthca_eq *)(& dev->eq_table.eq) + 2UL);
#line 920
  if (err != 0) {
#line 921
    goto err_out_unmap;
  } else {

  }
#line 923
  if ((dev->mthca_flags & 8UL) == 0UL) {
#line 923
    tmp___2 = (int )intr;
  } else {
#line 923
    tmp___2 = 129;
  }
#line 923
  err = mthca_create_eq(dev, 256, tmp___2, (struct mthca_eq *)(& dev->eq_table.eq) + 1UL);
#line 926
  if (err != 0) {
#line 927
    goto err_out_comp;
  } else {

  }
#line 929
  if ((dev->mthca_flags & 8UL) == 0UL) {
#line 929
    tmp___3 = (int )intr;
  } else {
#line 929
    tmp___3 = 130;
  }
#line 929
  err = mthca_create_eq(dev, 256, tmp___3, (struct mthca_eq *)(& dev->eq_table.eq));
#line 932
  if (err != 0) {
#line 933
    goto err_out_async;
  } else {

  }
#line 935
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 936
    eq_name[0] = "ib_mthca-cmd";
#line 936
    eq_name[1] = "ib_mthca-async";
#line 936
    eq_name[2] = "ib_mthca-comp";
#line 942
    i = 0;
#line 942
    goto ldv_24161;
    ldv_24160: 
#line 943
    tmp___4 = pci_name((struct pci_dev  const  *)dev->pdev);
#line 943
    snprintf((char *)(& dev->eq_table.eq[i].irq_name), 64UL, "%s@pci:%s", eq_name[i],
             tmp___4);
#line 947
    tmp___7 = mthca_is_memfree(dev);
#line 947
    if (tmp___7 != 0) {
#line 947
      tmp___6 = & mthca_arbel_msi_x_interrupt;
    } else {
#line 947
      tmp___6 = & mthca_tavor_msi_x_interrupt;
    }
#line 947
    err = request_irq((unsigned int )dev->eq_table.eq[i].msi_x_vector, tmp___6, 0UL,
                      (char const   *)(& dev->eq_table.eq[i].irq_name), (void *)(& dev->eq_table.eq) + (unsigned long )i);
#line 953
    if (err != 0) {
#line 954
      goto err_out_cmd;
    } else {

    }
#line 955
    dev->eq_table.eq[i].have_irq = 1;
#line 942
    i = i + 1;
    ldv_24161: ;
#line 942
    if (i <= 2) {
#line 943
      goto ldv_24160;
    } else {
#line 945
      goto ldv_24162;
    }
    ldv_24162: ;
  } else {
#line 958
    tmp___8 = pci_name((struct pci_dev  const  *)dev->pdev);
#line 958
    snprintf((char *)(& dev->eq_table.eq[0].irq_name), 64UL, "ib_mthca@pci:%s", tmp___8);
#line 960
    tmp___11 = mthca_is_memfree(dev);
#line 960
    if (tmp___11 != 0) {
#line 960
      tmp___10 = & mthca_arbel_interrupt;
    } else {
#line 960
      tmp___10 = & mthca_tavor_interrupt;
    }
#line 960
    err = request_irq((dev->pdev)->irq, tmp___10, 128UL, (char const   *)(& dev->eq_table.eq[0].irq_name),
                      (void *)dev);
#line 965
    if (err != 0) {
#line 966
      goto err_out_cmd;
    } else {

    }
#line 967
    dev->eq_table.have_irq = 1;
  }
#line 970
  tmp___12 = async_mask(dev);
#line 970
  err = mthca_MAP_EQ(dev, tmp___12, 0, dev->eq_table.eq[1].eqn);
#line 972
  if (err != 0) {
#line 973
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MAP_EQ for async EQ %d failed (%d)\n",
             dev->eq_table.eq[1].eqn, err);
  } else {

  }
#line 976
  err = mthca_MAP_EQ(dev, 1024ULL, 0, dev->eq_table.eq[0].eqn);
#line 978
  if (err != 0) {
#line 979
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MAP_EQ for cmd EQ %d failed (%d)\n",
             dev->eq_table.eq[0].eqn, err);
  } else {

  }
#line 982
  i = 0;
#line 982
  goto ldv_24164;
  ldv_24163: 
#line 983
  tmp___13 = mthca_is_memfree(dev);
#line 983
  if (tmp___13 != 0) {
#line 984
    arbel_eq_req_not(dev, dev->eq_table.eq[i].eqn_mask);
  } else {
#line 986
    tavor_eq_req_not(dev, dev->eq_table.eq[i].eqn);
  }
#line 982
  i = i + 1;
  ldv_24164: ;
#line 982
  if (i <= 2) {
#line 983
    goto ldv_24163;
  } else {
#line 985
    goto ldv_24165;
  }
  ldv_24165: ;
#line 988
  return (0);
  err_out_cmd: 
#line 991
  mthca_free_irqs(dev);
#line 992
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq));
  err_out_async: 
#line 995
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + 1UL);
  err_out_comp: 
#line 998
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + 2UL);
  err_out_unmap: 
#line 1001
  mthca_unmap_eq_regs(dev);
  err_out_free: 
#line 1004
  mthca_alloc_cleanup(& dev->eq_table.alloc);
#line 1005
  return (err);
}
}
#line 1008 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void mthca_cleanup_eq_table(struct mthca_dev *dev ) 
{ int i ;
  u64 tmp ;

  {
#line 1012
  mthca_free_irqs(dev);
#line 1014
  tmp = async_mask(dev);
#line 1014
  mthca_MAP_EQ(dev, tmp, 1, dev->eq_table.eq[1].eqn);
#line 1016
  mthca_MAP_EQ(dev, 1024ULL, 1, dev->eq_table.eq[0].eqn);
#line 1019
  i = 0;
#line 1019
  goto ldv_24171;
  ldv_24170: 
#line 1020
  mthca_free_eq(dev, (struct mthca_eq *)(& dev->eq_table.eq) + (unsigned long )i);
#line 1019
  i = i + 1;
  ldv_24171: ;
#line 1019
  if (i <= 2) {
#line 1020
    goto ldv_24170;
  } else {
#line 1022
    goto ldv_24172;
  }
  ldv_24172: 
#line 1022
  mthca_unmap_eq_regs(dev);
#line 1024
  mthca_alloc_cleanup(& dev->eq_table.alloc);
#line 1025
  return;
}
}
#line 1027 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1032
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1034
  mutex_lock(ldv_func_arg1);
#line 1035
  return;
}
}
#line 1037 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void ldv_mutex_unlock_70(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1042
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1044
  mutex_unlock(ldv_func_arg1);
#line 1045
  return;
}
}
#line 1047 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void ldv_mutex_lock_71(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1052
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1054
  mutex_lock(ldv_func_arg1);
#line 1055
  return;
}
}
#line 1057 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
int ldv_mutex_trylock_72(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1062
  tmp = mutex_trylock(ldv_func_arg1);
#line 1062
  ldv_func_res = tmp;
#line 1064
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1064
  return (tmp___0);
#line 1066
  return (ldv_func_res);
}
}
#line 1069 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_eq.c.prepared"
void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1074
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1076
  mutex_unlock(ldv_func_arg1);
#line 1077
  return;
}
}
#line 35 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 

  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_82(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_81(struct mutex *ldv_func_arg1 ) ;
#line 473 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_mr_alloc_notrans(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_mr *mr ) ;
#line 159 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
int mthca_pd_alloc(struct mthca_dev *dev , int privileged , struct mthca_pd *pd ) 
{ int err ;

  {
#line 161
  err = 0;
#line 163
  pd->privileged = privileged;
#line 165
  atomic_set(& pd->sqp_count, 0);
#line 166
  pd->pd_num = mthca_alloc(& dev->pd_table.alloc);
#line 167
  if (pd->pd_num == 4294967295U) {
#line 168
    return (-12);
  } else {

  }
#line 170
  if (privileged != 0) {
#line 171
    err = mthca_mr_alloc_notrans(dev, pd->pd_num, 3072U, & pd->ntmr);
#line 175
    if (err != 0) {
#line 176
      mthca_free(& dev->pd_table.alloc, pd->pd_num);
    } else {

    }
  } else {

  }
#line 179
  return (err);
}
}
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void mthca_pd_free(struct mthca_dev *dev , struct mthca_pd *pd ) 
{ 

  {
#line 184
  if (pd->privileged != 0) {
#line 185
    mthca_free_mr(dev, & pd->ntmr);
  } else {

  }
#line 186
  mthca_free(& dev->pd_table.alloc, pd->pd_num);
#line 187
  return;
}
}
#line 189 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
int mthca_init_pd_table(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 191
  tmp = mthca_alloc_init(& dev->pd_table.alloc, (u32 )dev->limits.num_pds, 16777215U,
                         (u32 )dev->limits.reserved_pds);
#line 191
  return (tmp);
}
}
#line 197 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void mthca_cleanup_pd_table(struct mthca_dev *dev ) 
{ 

  {
#line 200
  mthca_alloc_cleanup(& dev->pd_table.alloc);
#line 201
  return;
}
}
#line 203 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 208
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 210
  mutex_lock(ldv_func_arg1);
#line 211
  return;
}
}
#line 213 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 218
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 220
  mutex_unlock(ldv_func_arg1);
#line 221
  return;
}
}
#line 223 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void ldv_mutex_lock_81(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 228
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 230
  mutex_lock(ldv_func_arg1);
#line 231
  return;
}
}
#line 233 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
int ldv_mutex_trylock_82(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 238
  tmp = mutex_trylock(ldv_func_arg1);
#line 238
  ldv_func_res = tmp;
#line 240
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 240
  return (tmp___0);
#line 242
  return (ldv_func_res);
}
}
#line 245 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_pd.c.prepared"
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 250
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 252
  mutex_unlock(ldv_func_arg1);
#line 253
  return;
}
}
#line 158 "include/linux/byteorder/generic.h"
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ __u16 tmp ;
  __u16 tmp___0 ;

  {
#line 160
  tmp = __fswab16((int )*var);
#line 160
  tmp___0 = __fswab16((int )tmp + (int )val);
#line 160
  *var = tmp___0;
#line 161
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_94(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5961.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5961.rlock);
#line 336
  return;
}
}
#line 139 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 732
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 734
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 737
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 128 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_cq *to_mcq(struct ib_cq *ibcq ) 
{ struct ib_cq  const  *__mptr ;

  {
#line 326
  __mptr = (struct ib_cq  const  *)ibcq;
#line 326
  return ((struct mthca_cq *)__mptr);
}
}
#line 329 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_srq *to_msrq(struct ib_srq *ibsrq ) 
{ struct ib_srq  const  *__mptr ;

  {
#line 331
  __mptr = (struct ib_srq  const  *)ibsrq;
#line 331
  return ((struct mthca_srq *)__mptr);
}
}
#line 65 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write_db_rec(__be32 *val , __be32 *db ) 
{ 

  {
#line 67
  *((u64 *)db) = *((u64 *)val);
#line 68
  return;
}
}
#line 494 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_poll_cq(struct ib_cq *ibcq , int num_entries , struct ib_wc *entry ) ;
#line 496
int mthca_tavor_arm_cq(struct ib_cq *cq , enum ib_cq_notify_flags flags ) ;
#line 497
int mthca_arbel_arm_cq(struct ib_cq *ibcq , enum ib_cq_notify_flags flags ) ;
#line 498
int mthca_init_cq(struct mthca_dev *dev , int nent , struct mthca_ucontext *ctx ,
                  u32 pdn , struct mthca_cq *cq ) ;
#line 501
void mthca_free_cq(struct mthca_dev *dev , struct mthca_cq *cq ) ;
#line 506
void mthca_cq_clean(struct mthca_dev *dev , struct mthca_cq *cq , u32 qpn , struct mthca_srq *srq ) ;
#line 508
void mthca_cq_resize_copy_cqes(struct mthca_cq *cq ) ;
#line 509
int mthca_alloc_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int nent ) ;
#line 510
void mthca_free_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int cqe ) ;
#line 521
void mthca_free_srq_wqe(struct mthca_srq *srq , u32 wqe_addr ) ;
#line 541
void mthca_free_err_wqe(struct mthca_dev *dev , struct mthca_qp *qp , int is_send ,
                        int index , int *dbd , __be32 *new_wqe ) ;
#line 586 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
__inline static struct mthca_dev *to_mdev(struct ib_device *ibdev ) 
{ struct ib_device  const  *__mptr ;

  {
#line 588
  __mptr = (struct ib_device  const  *)ibdev;
#line 588
  return ((struct mthca_dev *)__mptr);
}
}
#line 91 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_table_get(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) ;
#line 92
void mthca_table_put(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) ;
#line 175
int mthca_alloc_db(struct mthca_dev *dev , enum mthca_db_type type , u32 qn , __be32 **db ) ;
#line 177
void mthca_free_db(struct mthca_dev *dev , int type , int db_index ) ;
#line 279 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static struct mthca_cqe *get_cqe_from_buf(struct mthca_cq_buf *buf , int entry ) 
{ 

  {
#line 282
  if (buf->is_direct != 0) {
#line 283
    return ((struct mthca_cqe *)buf->queue.direct.buf + (unsigned long )(entry * 32));
  } else {
#line 285
    return ((struct mthca_cqe *)((buf->queue.page_list + (unsigned long )(entry * 32) / 4096UL)->buf + ((unsigned long )(entry * 32) & 4095UL)));
  }
}
}
#line 289 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static struct mthca_cqe *get_cqe(struct mthca_cq *cq , int entry ) 
{ struct mthca_cqe *tmp ;

  {
#line 291
  tmp = get_cqe_from_buf(& cq->buf, entry);
#line 291
  return (tmp);
}
}
#line 294 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static struct mthca_cqe *cqe_sw(struct mthca_cqe *cqe ) 
{ struct mthca_cqe *tmp ;

  {
#line 296
  if ((int )((signed char )cqe->owner) >= 0) {
#line 296
    tmp = cqe;
  } else {
#line 296
    tmp = 0;
  }
#line 296
  return (tmp);
}
}
#line 299 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static struct mthca_cqe *next_cqe_sw(struct mthca_cq *cq ) 
{ struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;

  {
#line 301
  tmp = get_cqe(cq, (int )(cq->cons_index & (u32 )cq->ibcq.cqe));
#line 301
  tmp___0 = cqe_sw(tmp);
#line 301
  return (tmp___0);
}
}
#line 304 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static void set_cqe_hw(struct mthca_cqe *cqe ) 
{ 

  {
#line 306
  cqe->owner = 128U;
#line 307
  return;
}
}
#line 309 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
static void dump_cqe(struct mthca_dev *dev , void *cqe_ptr ) 
{ __be32 *cqe ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 311
  cqe = (__be32 *)cqe_ptr;
#line 314
  if (mthca_debug_level != 0) {
#line 314
    tmp = __fswab32(*(cqe + 7UL));
#line 314
    tmp___0 = __fswab32(*(cqe + 6UL));
#line 314
    tmp___1 = __fswab32(*(cqe + 5UL));
#line 314
    tmp___2 = __fswab32(*(cqe + 4UL));
#line 314
    tmp___3 = __fswab32(*(cqe + 3UL));
#line 314
    tmp___4 = __fswab32(*(cqe + 2UL));
#line 314
    tmp___5 = __fswab32(*(cqe + 1UL));
#line 314
    tmp___6 = __fswab32(*cqe);
#line 314
    dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "CQE contents %08x %08x %08x %08x %08x %08x %08x %08x\n",
               tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  } else {

  }
#line 315
  return;
}
}
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static void update_cons_index(struct mthca_dev *dev , struct mthca_cq *cq ,
                                       int incr ) 
{ __u32 tmp ;
  int tmp___0 ;

  {
#line 327
  tmp___0 = mthca_is_memfree(dev);
#line 327
  if (tmp___0 != 0) {
#line 328
    tmp = __fswab32(cq->cons_index);
#line 328
    *(cq->set_ci_db) = tmp;
#line 329
    __asm__  volatile   ("sfence": : : "memory");
  } else {
#line 331
    mthca_write64((u32 )(cq->cqn | 16777216), (u32 )(incr + -1), dev->kar + 32UL,
                  0);
#line 338
    __asm__  volatile   ("": : : "memory");
  }
#line 340
  return;
}
}
#line 342 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_cq_completion(struct mthca_dev *dev , u32 cqn ) 
{ struct mthca_cq *cq ;
  void *tmp ;

  {
#line 346
  tmp = mthca_array_get(& dev->cq_table.cq, (int )((u32 )(dev->limits.num_cqs + -1) & cqn));
#line 346
  cq = (struct mthca_cq *)tmp;
#line 348
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 349
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Completion event for bogus CQ %08x\n",
             cqn);
#line 350
    return;
  } else {

  }
#line 353
  cq->arm_sn = cq->arm_sn + 1;
#line 355
  (*(cq->ibcq.comp_handler))(& cq->ibcq, cq->ibcq.cq_context);
#line 356
  return;
}
}
#line 358 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_cq_event(struct mthca_dev *dev , u32 cqn , enum ib_event_type event_type ) 
{ struct mthca_cq *cq ;
  struct ib_event event ;
  void *tmp ;

  {
#line 364
  spin_lock(& dev->cq_table.lock);
#line 366
  tmp = mthca_array_get(& dev->cq_table.cq, (int )((u32 )(dev->limits.num_cqs + -1) & cqn));
#line 366
  cq = (struct mthca_cq *)tmp;
#line 367
  if ((unsigned long )cq != (unsigned long )((struct mthca_cq *)0)) {
#line 368
    cq->refcount = cq->refcount + 1;
  } else {

  }
#line 370
  spin_unlock(& dev->cq_table.lock);
#line 372
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 373
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event for bogus CQ %08x\n",
             cqn);
#line 374
    return;
  } else {

  }
#line 377
  event.device = & dev->ib_dev;
#line 378
  event.event = event_type;
#line 379
  event.element.cq = & cq->ibcq;
#line 380
  if ((unsigned long )cq->ibcq.event_handler != (unsigned long )((void (*)(struct ib_event * ,
                                                                           void * ))0)) {
#line 381
    (*(cq->ibcq.event_handler))(& event, cq->ibcq.cq_context);
  } else {

  }
#line 383
  spin_lock(& dev->cq_table.lock);
#line 384
  cq->refcount = cq->refcount - 1;
#line 384
  if (cq->refcount == 0) {
#line 385
    __wake_up(& cq->wait, 3U, 1, 0);
  } else {

  }
#line 386
  spin_unlock(& dev->cq_table.lock);
#line 387
  return;
}
}
#line 389 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static int is_recv_cqe(struct mthca_cqe *cqe ) 
{ 

  {
#line 391
  if (((int )cqe->opcode & 254) == 254) {
#line 393
    return (((int )cqe->opcode & 1) == 0);
  } else {
#line 395
    return ((int )((signed char )cqe->is_send) >= 0);
  }
}
}
#line 398 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_cq_clean(struct mthca_dev *dev , struct mthca_cq *cq , u32 qpn , struct mthca_srq *srq ) 
{ struct mthca_cqe *cqe ;
  u32 prod_index ;
  int i ;
  int nfreed ;
  struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  struct mthca_cqe *tmp___3 ;
  struct mthca_cqe *tmp___4 ;
  __u32 tmp___5 ;
  struct mthca_cqe *tmp___6 ;

  {
#line 403
  nfreed = 0;
#line 405
  spin_lock_irq(& cq->lock);
#line 414
  prod_index = cq->cons_index;
#line 414
  goto ldv_27448;
  ldv_27447: ;
#line 417
  if (cq->cons_index + (u32 )cq->ibcq.cqe == prod_index) {
#line 418
    goto ldv_27446;
  } else {

  }
#line 416
  prod_index = prod_index + 1U;
  ldv_27448: 
#line 414
  tmp = get_cqe(cq, (int )((u32 )cq->ibcq.cqe & prod_index));
#line 414
  tmp___0 = cqe_sw(tmp);
#line 414
  if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 416
    goto ldv_27447;
  } else {
#line 418
    goto ldv_27446;
  }
  ldv_27446: ;
#line 428
  goto ldv_27453;
  ldv_27452: 
#line 429
  cqe = get_cqe(cq, (int )((u32 )cq->ibcq.cqe & prod_index));
#line 430
  tmp___5 = __fswab32(qpn);
#line 430
  if (cqe->my_qpn == tmp___5) {
#line 431
    if ((unsigned long )srq != (unsigned long )((struct mthca_srq *)0)) {
#line 431
      tmp___2 = is_recv_cqe(cqe);
#line 431
      if (tmp___2 != 0) {
#line 432
        tmp___1 = __fswab32(cqe->wqe);
#line 432
        mthca_free_srq_wqe(srq, tmp___1);
      } else {

      }
    } else {

    }
#line 433
    nfreed = nfreed + 1;
  } else
#line 434
  if (nfreed != 0) {
#line 435
    __len = 32UL;
#line 435
    if (__len > 63UL) {
#line 435
      tmp___3 = get_cqe(cq, (int )((prod_index + (u32 )nfreed) & (u32 )cq->ibcq.cqe));
#line 435
      __ret = __memcpy((void *)tmp___3, (void const   *)cqe, __len);
    } else {
#line 435
      tmp___4 = get_cqe(cq, (int )((prod_index + (u32 )nfreed) & (u32 )cq->ibcq.cqe));
#line 435
      __ret = __builtin_memcpy((void *)tmp___4, (void const   *)cqe, __len);
    }
  } else {

  }
  ldv_27453: 
#line 428
  prod_index = prod_index - 1U;
#line 428
  if ((int )prod_index - (int )cq->cons_index >= 0) {
#line 429
    goto ldv_27452;
  } else {
#line 431
    goto ldv_27454;
  }
  ldv_27454: ;
#line 439
  if (nfreed != 0) {
#line 440
    i = 0;
#line 440
    goto ldv_27456;
    ldv_27455: 
#line 441
    tmp___6 = get_cqe(cq, (int )((cq->cons_index + (u32 )i) & (u32 )cq->ibcq.cqe));
#line 441
    set_cqe_hw(tmp___6);
#line 440
    i = i + 1;
    ldv_27456: ;
#line 440
    if (i < nfreed) {
#line 441
      goto ldv_27455;
    } else {
#line 443
      goto ldv_27457;
    }
    ldv_27457: 
#line 442
    __asm__  volatile   ("sfence": : : "memory");
#line 443
    cq->cons_index = cq->cons_index + (u32 )nfreed;
#line 444
    update_cons_index(dev, cq, nfreed);
  } else {

  }
#line 447
  spin_unlock_irq(& cq->lock);
#line 448
  return;
}
}
#line 450 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_cq_resize_copy_cqes(struct mthca_cq *cq ) 
{ int i ;
  struct mthca_cqe *tmp ;
  struct mthca_cqe *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  struct mthca_cqe *tmp___3 ;
  struct mthca_cqe *tmp___4 ;
  struct mthca_cqe *tmp___5 ;
  struct mthca_cqe *tmp___6 ;
  struct mthca_cqe *tmp___7 ;
  struct mthca_cqe *tmp___8 ;

  {
#line 460
  tmp___1 = to_mdev(cq->ibcq.device);
#line 460
  tmp___2 = mthca_is_memfree(tmp___1);
#line 460
  if (tmp___2 == 0 && cq->ibcq.cqe < (cq->resize_buf)->cqe) {
#line 462
    cq->cons_index = cq->cons_index & (u32 )cq->ibcq.cqe;
#line 463
    tmp = get_cqe(cq, cq->ibcq.cqe);
#line 463
    tmp___0 = cqe_sw(tmp);
#line 463
    if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 464
      cq->cons_index = cq->cons_index + (u32 )(~ cq->ibcq.cqe);
    } else {

    }
  } else {

  }
#line 467
  i = (int )cq->cons_index;
#line 467
  goto ldv_27466;
  ldv_27465: 
#line 468
  __len = 32UL;
#line 468
  if (__len > 63UL) {
#line 468
    tmp___3 = get_cqe(cq, cq->ibcq.cqe & i);
#line 468
    tmp___4 = get_cqe_from_buf(& (cq->resize_buf)->buf, (cq->resize_buf)->cqe & i);
#line 468
    __ret = __memcpy((void *)tmp___4, (void const   *)tmp___3, __len);
  } else {
#line 468
    tmp___5 = get_cqe(cq, cq->ibcq.cqe & i);
#line 468
    tmp___6 = get_cqe_from_buf(& (cq->resize_buf)->buf, (cq->resize_buf)->cqe & i);
#line 468
    __ret = __builtin_memcpy((void *)tmp___6, (void const   *)tmp___5, __len);
  }
#line 467
  i = i + 1;
  ldv_27466: 
#line 467
  tmp___7 = get_cqe(cq, cq->ibcq.cqe & i);
#line 467
  tmp___8 = cqe_sw(tmp___7);
#line 467
  if ((unsigned long )tmp___8 != (unsigned long )((struct mthca_cqe *)0)) {
#line 468
    goto ldv_27465;
  } else {
#line 470
    goto ldv_27467;
  }
  ldv_27467: ;
#line 472
  return;
}
}
#line 473 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_alloc_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int nent ) 
{ int ret ;
  int i ;
  struct mthca_cqe *tmp ;

  {
#line 478
  ret = mthca_buf_alloc(dev, nent * 32, 16384, & buf->queue, & buf->is_direct, & dev->driver_pd,
                        1, & buf->mr);
#line 482
  if (ret != 0) {
#line 483
    return (ret);
  } else {

  }
#line 485
  i = 0;
#line 485
  goto ldv_27476;
  ldv_27475: 
#line 486
  tmp = get_cqe_from_buf(buf, i);
#line 486
  set_cqe_hw(tmp);
#line 485
  i = i + 1;
  ldv_27476: ;
#line 485
  if (i < nent) {
#line 486
    goto ldv_27475;
  } else {
#line 488
    goto ldv_27477;
  }
  ldv_27477: ;
#line 488
  return (0);
}
}
#line 491 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_free_cq_buf(struct mthca_dev *dev , struct mthca_cq_buf *buf , int cqe ) 
{ 

  {
#line 493
  mthca_buf_free(dev, (cqe + 1) * 32, & buf->queue, buf->is_direct, & buf->mr);
#line 495
  return;
}
}
#line 497 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
static void handle_error_cqe(struct mthca_dev *dev , struct mthca_cq *cq , struct mthca_qp *qp ,
                             int wqe_index , int is_send , struct mthca_err_cqe *cqe ,
                             struct ib_wc *entry , int *free_cqe ) 
{ int dbd ;
  __be32 new_wqe ;
  __u32 tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 505
  if ((unsigned int )cqe->syndrome == 2U) {
#line 506
    if (mthca_debug_level != 0) {
#line 506
      tmp = __fswab32(cqe->wqe);
#line 506
      tmp___0 = __fswab32(cqe->my_qpn);
#line 506
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "local QP operation err (QPN %06x, WQE @ %08x, CQN %06x, index %d)\n",
                 tmp___0, tmp, cq->cqn, cq->cons_index);
    } else {

    }
#line 510
    dump_cqe(dev, (void *)cqe);
  } else {

  }
#line 517
  switch ((int )cqe->syndrome) {
  case 1: 
#line 519
  entry->status = 1;
#line 520
  goto ldv_27496;
  case 2: 
#line 522
  entry->status = 2;
#line 523
  goto ldv_27496;
  case 3: 
#line 525
  entry->status = 3;
#line 526
  goto ldv_27496;
  case 4: 
#line 528
  entry->status = 4;
#line 529
  goto ldv_27496;
  case 5: 
#line 531
  entry->status = 5;
#line 532
  goto ldv_27496;
  case 6: 
#line 534
  entry->status = 6;
#line 535
  goto ldv_27496;
  case 16: 
#line 537
  entry->status = 7;
#line 538
  goto ldv_27496;
  case 17: 
#line 540
  entry->status = 8;
#line 541
  goto ldv_27496;
  case 18: 
#line 543
  entry->status = 9;
#line 544
  goto ldv_27496;
  case 19: 
#line 546
  entry->status = 10;
#line 547
  goto ldv_27496;
  case 20: 
#line 549
  entry->status = 11;
#line 550
  goto ldv_27496;
  case 21: 
#line 552
  entry->status = 12;
#line 553
  goto ldv_27496;
  case 22: 
#line 555
  entry->status = 13;
#line 556
  goto ldv_27496;
  case 32: 
#line 558
  entry->status = 14;
#line 559
  goto ldv_27496;
  case 33: 
#line 561
  entry->status = 15;
#line 562
  goto ldv_27496;
  case 34: 
#line 564
  entry->status = 16;
#line 565
  goto ldv_27496;
  case 35: 
#line 567
  entry->status = 17;
#line 568
  goto ldv_27496;
  case 36: 
#line 570
  entry->status = 18;
#line 571
  goto ldv_27496;
  default: 
#line 573
  entry->status = 21;
#line 574
  goto ldv_27496;
  }
  ldv_27496: 
#line 577
  entry->vendor_err = (u32 )cqe->vendor_err;
#line 583
  tmp___1 = mthca_is_memfree(dev);
#line 583
  if (tmp___1 != 0) {
#line 584
    return;
  } else {

  }
#line 586
  mthca_free_err_wqe(dev, qp, is_send, wqe_index, & dbd, & new_wqe);
#line 593
  if ((new_wqe & 1056964608U) == 0U || ((unsigned int )cqe->db_cnt == 0U && dbd != 0)) {
#line 594
    return;
  } else {

  }
#line 596
  be16_add_cpu(& cqe->db_cnt, - ((int )((u16 )dbd)));
#line 597
  cqe->wqe = new_wqe;
#line 598
  cqe->syndrome = 5U;
#line 600
  *free_cqe = 0;
#line 601
  return;
}
}
#line 603 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static int mthca_poll_one(struct mthca_dev *dev , struct mthca_cq *cq , struct mthca_qp **cur_qp ,
                                   int *freed , struct ib_wc *entry ) 
{ struct mthca_wq *wq ;
  struct mthca_cqe *cqe ;
  int wqe_index ;
  int is_error ;
  int is_send ;
  int free_cqe ;
  int err ;
  u16 checksum ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___6 ;
  u32 wqe ;
  __u32 tmp___7 ;
  s32 wqe___0 ;
  __u32 tmp___8 ;
  long tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u16 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;

  {
#line 614
  free_cqe = 1;
#line 615
  err = 0;
#line 618
  cqe = next_cqe_sw(cq);
#line 619
  if ((unsigned long )cqe == (unsigned long )((struct mthca_cqe *)0)) {
#line 620
    return (-11);
  } else {

  }
#line 626
  __asm__  volatile   ("lfence": : : "memory");
#line 635
  is_error = ((int )cqe->opcode & 254) == 254;
#line 637
  if (is_error != 0) {
#line 637
    is_send = (int )cqe->opcode & 1;
  } else {
#line 637
    is_send = (int )cqe->is_send & 128;
  }
#line 639
  if ((unsigned long )*cur_qp == (unsigned long )((struct mthca_qp *)0)) {
#line 639
    goto _L;
  } else {
#line 639
    tmp___4 = __fswab32(cqe->my_qpn);
#line 639
    if (tmp___4 != (*cur_qp)->qpn) {
      _L: /* CIL Label */ 
#line 645
      tmp___1 = __fswab32(cqe->my_qpn);
#line 645
      tmp___2 = mthca_array_get(& dev->qp_table.qp, (int )(tmp___1 & (unsigned int )(dev->limits.num_qps + -1)));
#line 645
      *cur_qp = (struct mthca_qp *)tmp___2;
#line 648
      if ((unsigned long )*cur_qp == (unsigned long )((struct mthca_qp *)0)) {
#line 649
        tmp___3 = __fswab32(cqe->my_qpn);
#line 649
        dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CQ entry for unknown QP %06x\n",
                 tmp___3 & 16777215U);
#line 651
        err = -22;
#line 652
        goto out;
      } else {

      }
    } else {

    }
  }
#line 656
  entry->qp = & (*cur_qp)->ibqp;
#line 658
  if (is_send != 0) {
#line 659
    wq = & (*cur_qp)->sq;
#line 660
    tmp___5 = __fswab32(cqe->wqe);
#line 660
    wqe_index = (int )((tmp___5 - (unsigned int )(*cur_qp)->send_wqe_offset) >> wq->wqe_shift);
#line 662
    entry->wr_id = *((*cur_qp)->wrid + (unsigned long )((*cur_qp)->rq.max + wqe_index));
  } else
#line 664
  if ((unsigned long )(*cur_qp)->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 665
    tmp___6 = to_msrq((*cur_qp)->ibqp.srq);
#line 665
    srq = tmp___6;
#line 666
    tmp___7 = __fswab32(cqe->wqe);
#line 666
    wqe = tmp___7;
#line 667
    wq = 0;
#line 668
    wqe_index = (int )(wqe >> srq->wqe_shift);
#line 669
    entry->wr_id = *(srq->wrid + (unsigned long )wqe_index);
#line 670
    mthca_free_srq_wqe(srq, wqe);
  } else {
#line 673
    wq = & (*cur_qp)->rq;
#line 674
    tmp___8 = __fswab32(cqe->wqe);
#line 674
    wqe___0 = (s32 )tmp___8;
#line 675
    wqe_index = wqe___0 >> wq->wqe_shift;
#line 681
    tmp___9 = ldv__builtin_expect(wqe_index < 0, 0L);
#line 681
    if (tmp___9 != 0L) {
#line 682
      wqe_index = wq->max + -1;
    } else {

    }
#line 683
    entry->wr_id = *((*cur_qp)->wrid + (unsigned long )wqe_index);
  }
#line 686
  if ((unsigned long )wq != (unsigned long )((struct mthca_wq *)0)) {
#line 687
    if (wq->last_comp < (unsigned int )wqe_index) {
#line 688
      wq->tail = wq->tail + ((unsigned int )wqe_index - wq->last_comp);
    } else {
#line 690
      wq->tail = wq->tail + ((unsigned int )(wq->max + wqe_index) - wq->last_comp);
    }
#line 692
    wq->last_comp = (unsigned int )wqe_index;
  } else {

  }
#line 695
  if (is_error != 0) {
#line 696
    handle_error_cqe(dev, cq, *cur_qp, wqe_index, is_send, (struct mthca_err_cqe *)cqe,
                     entry, & free_cqe);
#line 699
    goto out;
  } else {

  }
#line 702
  if (is_send != 0) {
#line 703
    entry->wc_flags = 0;
#line 704
    switch ((int )cqe->opcode) {
    case 8: 
#line 706
    entry->opcode = 1;
#line 707
    goto ldv_27535;
    case 9: 
#line 709
    entry->opcode = 1;
#line 710
    entry->wc_flags = entry->wc_flags | 2;
#line 711
    goto ldv_27535;
    case 10: 
#line 713
    entry->opcode = 0;
#line 714
    goto ldv_27535;
    case 11: 
#line 716
    entry->opcode = 0;
#line 717
    entry->wc_flags = entry->wc_flags | 2;
#line 718
    goto ldv_27535;
    case 16: 
#line 720
    entry->opcode = 2;
#line 721
    tmp___10 = __fswab32(cqe->byte_cnt);
#line 721
    entry->byte_len = tmp___10;
#line 722
    goto ldv_27535;
    case 17: 
#line 724
    entry->opcode = 3;
#line 725
    entry->byte_len = 8U;
#line 726
    goto ldv_27535;
    case 18: 
#line 728
    entry->opcode = 4;
#line 729
    entry->byte_len = 8U;
#line 730
    goto ldv_27535;
    case 24: 
#line 732
    entry->opcode = 5;
#line 733
    goto ldv_27535;
    default: 
#line 735
    entry->opcode = 255;
#line 736
    goto ldv_27535;
    }
    ldv_27535: ;
  } else {
#line 739
    tmp___11 = __fswab32(cqe->byte_cnt);
#line 739
    entry->byte_len = tmp___11;
#line 740
    switch ((int )cqe->opcode & 31) {
    case 3: ;
    case 5: 
#line 743
    entry->wc_flags = 2;
#line 744
    entry->ex.imm_data = cqe->imm_etype_pkey_eec;
#line 745
    entry->opcode = 128;
#line 746
    goto ldv_27546;
    case 9: ;
    case 11: 
#line 749
    entry->wc_flags = 2;
#line 750
    entry->ex.imm_data = cqe->imm_etype_pkey_eec;
#line 751
    entry->opcode = 129;
#line 752
    goto ldv_27546;
    default: 
#line 754
    entry->wc_flags = 0;
#line 755
    entry->opcode = 128;
#line 756
    goto ldv_27546;
    }
    ldv_27546: 
#line 758
    tmp___12 = __fswab16((int )cqe->rlid);
#line 758
    entry->slid = tmp___12;
#line 759
    entry->sl = (u8 )((int )cqe->sl_ipok >> 4);
#line 760
    tmp___13 = __fswab32(cqe->rqpn);
#line 760
    entry->src_qp = tmp___13 & 16777215U;
#line 761
    entry->dlid_path_bits = (unsigned int )cqe->g_mlpath & 127U;
#line 762
    tmp___14 = __fswab32(cqe->imm_etype_pkey_eec);
#line 762
    entry->pkey_index = (u16 )(tmp___14 >> 16);
#line 763
    entry->wc_flags = entry->wc_flags | ((int )((signed char )cqe->g_mlpath) < 0);
#line 764
    tmp___15 = __fswab32(cqe->rqpn);
#line 764
    tmp___16 = __fswab32(cqe->my_ee);
#line 764
    checksum = (unsigned int )((u16 )(tmp___15 >> 24)) | ((unsigned int )((u16 )(tmp___16 >> 16)) & 65280U);
#line 766
    if ((int )cqe->sl_ipok & 1 && (unsigned int )checksum == 65535U) {
#line 766
      tmp___17 = 8;
    } else {
#line 766
      tmp___17 = 0;
    }
#line 766
    entry->wc_flags = entry->wc_flags | tmp___17;
  }
#line 770
  entry->status = 0;
  out: 
#line 773
  tmp___18 = ldv__builtin_expect(free_cqe != 0, 1L);
#line 773
  if (tmp___18 != 0L) {
#line 774
    set_cqe_hw(cqe);
#line 775
    *freed = *freed + 1;
#line 776
    cq->cons_index = cq->cons_index + 1U;
  } else {

  }
#line 779
  return (err);
}
}
#line 782 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_poll_cq(struct ib_cq *ibcq , int num_entries , struct ib_wc *entry ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_cq *cq ;
  struct mthca_cq *tmp___0 ;
  struct mthca_qp *qp ;
  unsigned long flags ;
  int err ;
  int freed ;
  int npolled ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  struct mthca_cq_buf tbuf ;
  int tcqe ;
  struct mthca_cqe *tmp___3 ;
  struct mthca_cqe *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 785
  tmp = to_mdev(ibcq->device);
#line 785
  dev = tmp;
#line 786
  tmp___0 = to_mcq(ibcq);
#line 786
  cq = tmp___0;
#line 787
  qp = 0;
#line 789
  err = 0;
#line 790
  freed = 0;
#line 793
  tmp___1 = spinlock_check(& cq->lock);
#line 793
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 795
  npolled = 0;
  repoll: ;
#line 797
  goto ldv_27568;
  ldv_27567: 
#line 798
  err = mthca_poll_one(dev, cq, & qp, & freed, entry + (unsigned long )npolled);
#line 800
  if (err != 0) {
#line 801
    goto ldv_27566;
  } else {

  }
#line 802
  npolled = npolled + 1;
  ldv_27568: ;
#line 797
  if (npolled < num_entries) {
#line 798
    goto ldv_27567;
  } else {
#line 800
    goto ldv_27566;
  }
  ldv_27566: ;
#line 805
  if (freed != 0) {
#line 806
    __asm__  volatile   ("sfence": : : "memory");
#line 807
    update_cons_index(dev, cq, freed);
  } else {

  }
#line 816
  tmp___5 = ldv__builtin_expect(err == -11, 0L);
#line 816
  if (tmp___5 != 0L) {
#line 816
    tmp___6 = ldv__builtin_expect((unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0),
                               0L);
#line 816
    if (tmp___6 != 0L) {
#line 816
      tmp___7 = 1;
    } else {
#line 816
      tmp___7 = 0;
    }
  } else {
#line 816
    tmp___7 = 0;
  }
#line 816
  if (tmp___7 != 0) {
#line 816
    tmp___8 = ldv__builtin_expect((unsigned int )(cq->resize_buf)->state == 1U, 0L);
#line 816
    if (tmp___8 != 0L) {
#line 825
      tmp___2 = mthca_is_memfree(dev);
#line 825
      if (tmp___2 == 0) {
#line 826
        cq->cons_index = cq->cons_index & (u32 )cq->ibcq.cqe;
      } else {

      }
#line 828
      tmp___3 = get_cqe_from_buf(& (cq->resize_buf)->buf, (int )(cq->cons_index & (u32 )(cq->resize_buf)->cqe));
#line 828
      tmp___4 = cqe_sw(tmp___3);
#line 828
      if ((unsigned long )tmp___4 != (unsigned long )((struct mthca_cqe *)0)) {
#line 833
        tbuf = cq->buf;
#line 834
        tcqe = cq->ibcq.cqe;
#line 835
        cq->buf = (cq->resize_buf)->buf;
#line 836
        cq->ibcq.cqe = (cq->resize_buf)->cqe;
#line 838
        (cq->resize_buf)->buf = tbuf;
#line 839
        (cq->resize_buf)->cqe = tcqe;
#line 840
        (cq->resize_buf)->state = 2;
#line 842
        goto repoll;
      } else {

      }
    } else {

    }
  } else {

  }
#line 846
  spin_unlock_irqrestore(& cq->lock, flags);
#line 848
  if (err == 0 || err == -11) {
#line 848
    tmp___9 = npolled;
  } else {
#line 848
    tmp___9 = err;
  }
#line 848
  return (tmp___9);
}
}
#line 851 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_tavor_arm_cq(struct ib_cq *cq , enum ib_cq_notify_flags flags ) 
{ u32 dbhi ;
  int tmp ;
  struct mthca_cq *tmp___0 ;
  struct mthca_dev *tmp___1 ;

  {
#line 853
  if (((unsigned int )flags & 3U) == 1U) {
#line 853
    tmp = 50331648;
  } else {
#line 853
    tmp = 33554432;
  }
#line 853
  tmp___0 = to_mcq(cq);
#line 853
  dbhi = (u32 )(tmp | tmp___0->cqn);
#line 858
  tmp___1 = to_mdev(cq->device);
#line 858
  mthca_write64(dbhi, 4294967295U, tmp___1->kar + 32UL, 0);
#line 861
  return (0);
}
}
#line 864 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_arbel_arm_cq(struct ib_cq *ibcq , enum ib_cq_notify_flags flags ) 
{ struct mthca_cq *cq ;
  struct mthca_cq *tmp ;
  __be32 db_rec[2U] ;
  u32 dbhi ;
  u32 sn ;
  __u32 tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  unsigned int tmp___3 ;
  struct mthca_dev *tmp___4 ;

  {
#line 866
  tmp = to_mcq(ibcq);
#line 866
  cq = tmp;
#line 869
  sn = (u32 )cq->arm_sn & 3U;
#line 871
  tmp___0 = __fswab32(cq->cons_index);
#line 871
  db_rec[0] = tmp___0;
#line 872
  if (((unsigned int )flags & 3U) == 1U) {
#line 872
    tmp___1 = 1U;
  } else {
#line 872
    tmp___1 = 2U;
  }
#line 872
  tmp___2 = __fswab32((((u32 )(cq->cqn << 8) | (sn << 3)) | tmp___1) | 64U);
#line 872
  db_rec[1] = tmp___2;
#line 876
  mthca_write_db_rec((__be32 *)(& db_rec), cq->arm_db);
#line 882
  __asm__  volatile   ("sfence": : : "memory");
#line 884
  if (((unsigned int )flags & 3U) == 1U) {
#line 884
    tmp___3 = 16777216U;
  } else {
#line 884
    tmp___3 = 33554432U;
  }
#line 884
  dbhi = ((sn << 28) | tmp___3) | (u32 )cq->cqn;
#line 889
  tmp___4 = to_mdev(ibcq->device);
#line 889
  mthca_write64(dbhi, cq->cons_index, tmp___4->kar + 32UL, 0);
#line 893
  return (0);
}
}
#line 896 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_init_cq(struct mthca_dev *dev , int nent , struct mthca_ucontext *ctx ,
                  u32 pdn , struct mthca_cq *cq ) 
{ struct mthca_mailbox *mailbox ;
  struct mthca_cq_context *cq_context ;
  int err ;
  u32 tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 902
  err = -12;
#line 904
  cq->ibcq.cqe = nent + -1;
#line 905
  cq->is_kernel = (unsigned long )ctx == (unsigned long )((struct mthca_ucontext *)0);
#line 907
  tmp = mthca_alloc(& dev->cq_table.alloc);
#line 907
  cq->cqn = (int )tmp;
#line 908
  if (cq->cqn == -1) {
#line 909
    return (-12);
  } else {

  }
#line 911
  tmp___0 = mthca_is_memfree(dev);
#line 911
  if (tmp___0 != 0) {
#line 912
    err = mthca_table_get(dev, dev->cq_table.table, cq->cqn);
#line 913
    if (err != 0) {
#line 914
      goto err_out;
    } else {

    }
#line 916
    if (cq->is_kernel != 0) {
#line 917
      cq->arm_sn = 1;
#line 919
      err = -12;
#line 921
      cq->set_ci_db_index = mthca_alloc_db(dev, 1, (u32 )cq->cqn, & cq->set_ci_db);
#line 923
      if (cq->set_ci_db_index < 0) {
#line 924
        goto err_out_icm;
      } else {

      }
#line 926
      cq->arm_db_index = mthca_alloc_db(dev, 2, (u32 )cq->cqn, & cq->arm_db);
#line 928
      if (cq->arm_db_index < 0) {
#line 929
        goto err_out_ci;
      } else {

      }
    } else {

    }
  } else {

  }
#line 933
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 934
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 934
  if (tmp___1 != 0L) {
#line 935
    goto err_out_arm;
  } else {

  }
#line 937
  cq_context = (struct mthca_cq_context *)mailbox->buf;
#line 939
  if (cq->is_kernel != 0) {
#line 940
    err = mthca_alloc_cq_buf(dev, & cq->buf, nent);
#line 941
    if (err != 0) {
#line 942
      goto err_out_mailbox;
    } else {

    }
  } else {

  }
#line 945
  spinlock_check(& cq->lock);
#line 945
  __raw_spin_lock_init(& cq->lock.ldv_5961.rlock, "&(&cq->lock)->rlock", & __key);
#line 946
  cq->refcount = 1;
#line 947
  __init_waitqueue_head(& cq->wait, "&cq->wait", & __key___0);
#line 948
  __mutex_init(& cq->mutex, "&cq->mutex", & __key___1);
#line 950
  memset((void *)cq_context, 0, 64UL);
#line 951
  cq_context->flags = 1024U;
#line 954
  tmp___2 = ffs(nent);
#line 954
  tmp___3 = __fswab32((__u32 )((tmp___2 + -1) << 24));
#line 954
  cq_context->logsize_usrpage = tmp___3;
#line 955
  if ((unsigned long )ctx != (unsigned long )((struct mthca_ucontext *)0)) {
#line 956
    tmp___4 = __fswab32((__u32 )ctx->uar.index);
#line 956
    cq_context->logsize_usrpage = cq_context->logsize_usrpage | tmp___4;
  } else {
#line 958
    tmp___5 = __fswab32((__u32 )dev->driver_uar.index);
#line 958
    cq_context->logsize_usrpage = cq_context->logsize_usrpage | tmp___5;
  }
#line 959
  tmp___6 = __fswab32((__u32 )dev->eq_table.eq[1].eqn);
#line 959
  cq_context->error_eqn = tmp___6;
#line 960
  tmp___7 = __fswab32((__u32 )dev->eq_table.eq[2].eqn);
#line 960
  cq_context->comp_eqn = tmp___7;
#line 961
  tmp___8 = __fswab32(pdn);
#line 961
  cq_context->pd = tmp___8;
#line 962
  tmp___9 = __fswab32(cq->buf.mr.ibmr.lkey);
#line 962
  cq_context->lkey = tmp___9;
#line 963
  tmp___10 = __fswab32((__u32 )cq->cqn);
#line 963
  cq_context->cqn = tmp___10;
#line 965
  tmp___13 = mthca_is_memfree(dev);
#line 965
  if (tmp___13 != 0) {
#line 966
    tmp___11 = __fswab32((__u32 )cq->set_ci_db_index);
#line 966
    cq_context->ci_db = tmp___11;
#line 967
    tmp___12 = __fswab32((__u32 )cq->arm_db_index);
#line 967
    cq_context->state_db = tmp___12;
  } else {

  }
#line 970
  err = mthca_SW2HW_CQ(dev, mailbox, cq->cqn);
#line 971
  if (err != 0) {
#line 972
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_CQ failed (%d)\n",
             err);
#line 973
    goto err_out_free_mr;
  } else {

  }
#line 976
  spin_lock_irq(& dev->cq_table.lock);
#line 977
  tmp___14 = mthca_array_set(& dev->cq_table.cq, cq->cqn & (dev->limits.num_cqs + -1),
                             (void *)cq);
#line 977
  if (tmp___14 != 0) {
#line 980
    spin_unlock_irq(& dev->cq_table.lock);
#line 981
    goto err_out_free_mr;
  } else {

  }
#line 983
  spin_unlock_irq(& dev->cq_table.lock);
#line 985
  cq->cons_index = 0U;
#line 987
  mthca_free_mailbox(dev, mailbox);
#line 989
  return (0);
  err_out_free_mr: ;
#line 992
  if (cq->is_kernel != 0) {
#line 993
    mthca_free_cq_buf(dev, & cq->buf, cq->ibcq.cqe);
  } else {

  }
  err_out_mailbox: 
#line 996
  mthca_free_mailbox(dev, mailbox);
  err_out_arm: ;
#line 999
  if (cq->is_kernel != 0) {
#line 999
    tmp___15 = mthca_is_memfree(dev);
#line 999
    if (tmp___15 != 0) {
#line 1000
      mthca_free_db(dev, 2, cq->arm_db_index);
    } else {

    }
  } else {

  }
  err_out_ci: ;
#line 1003
  if (cq->is_kernel != 0) {
#line 1003
    tmp___16 = mthca_is_memfree(dev);
#line 1003
    if (tmp___16 != 0) {
#line 1004
      mthca_free_db(dev, 1, cq->set_ci_db_index);
    } else {

    }
  } else {

  }
  err_out_icm: 
#line 1007
  mthca_table_put(dev, dev->cq_table.table, cq->cqn);
  err_out: 
#line 1010
  mthca_free(& dev->cq_table.alloc, (u32 )cq->cqn);
#line 1012
  return (err);
}
}
#line 1015 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
__inline static int get_cq_refcount(struct mthca_dev *dev , struct mthca_cq *cq ) 
{ int c ;

  {
#line 1019
  spin_lock_irq(& dev->cq_table.lock);
#line 1020
  c = cq->refcount;
#line 1021
  spin_unlock_irq(& dev->cq_table.lock);
#line 1023
  return (c);
}
}
#line 1026 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_free_cq(struct mthca_dev *dev , struct mthca_cq *cq ) 
{ struct mthca_mailbox *mailbox ;
  int err ;
  long tmp ;
  __be32 *ctx ;
  int j ;
  struct mthca_cqe *tmp___0 ;
  int tmp___1 ;
  __u32 tmp___2 ;
  int tmp___3 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1032
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 1033
  tmp = IS_ERR((void const   *)mailbox);
#line 1033
  if (tmp != 0L) {
#line 1034
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "No memory for mailbox to free CQ.\n");
#line 1035
    return;
  } else {

  }
#line 1038
  err = mthca_HW2SW_CQ(dev, mailbox, cq->cqn);
#line 1039
  if (err != 0) {
#line 1040
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_CQ failed (%d)\n",
             err);
  } else {

  }
#line 1042
  if (0) {
#line 1043
    ctx = (__be32 *)mailbox->buf;
#line 1046
    if (cq->is_kernel != 0) {
#line 1046
      tmp___0 = next_cqe_sw(cq);
#line 1046
      if ((unsigned long )tmp___0 != (unsigned long )((struct mthca_cqe *)0)) {
#line 1046
        tmp___1 = 1;
      } else {
#line 1046
        tmp___1 = 0;
      }
    } else {
#line 1046
      tmp___1 = 0;
    }
#line 1046
    printk("\vcontext for CQN %x (cons index %x, next sw %d)\n", cq->cqn, cq->cons_index,
           tmp___1);
#line 1049
    j = 0;
#line 1049
    goto ldv_27617;
    ldv_27616: 
#line 1050
    tmp___2 = __fswab32(*(ctx + (unsigned long )j));
#line 1050
    printk("\v[%2x] %08x\n", j * 4, tmp___2);
#line 1049
    j = j + 1;
    ldv_27617: ;
#line 1049
    if (j <= 15) {
#line 1050
      goto ldv_27616;
    } else {
#line 1052
      goto ldv_27618;
    }
    ldv_27618: ;
  } else {

  }
#line 1053
  spin_lock_irq(& dev->cq_table.lock);
#line 1054
  mthca_array_clear(& dev->cq_table.cq, cq->cqn & (dev->limits.num_cqs + -1));
#line 1056
  cq->refcount = cq->refcount - 1;
#line 1057
  spin_unlock_irq(& dev->cq_table.lock);
#line 1059
  if ((dev->mthca_flags & 8UL) != 0UL) {
#line 1060
    synchronize_irq((unsigned int )dev->eq_table.eq[2].msi_x_vector);
  } else {
#line 1062
    synchronize_irq((dev->pdev)->irq);
  }
#line 1064
  tmp___3 = get_cq_refcount(dev, cq);
#line 1064
  if (tmp___3 == 0) {
#line 1064
    goto ldv_27619;
  } else {

  }
#line 1064
  tmp___4 = get_current();
#line 1064
  __wait.flags = 0U;
#line 1064
  __wait.private = (void *)tmp___4;
#line 1064
  __wait.func = & autoremove_wake_function;
#line 1064
  __wait.task_list.next = & __wait.task_list;
#line 1064
  __wait.task_list.prev = & __wait.task_list;
  ldv_27622: 
#line 1064
  prepare_to_wait(& cq->wait, & __wait, 2);
#line 1064
  tmp___5 = get_cq_refcount(dev, cq);
#line 1064
  if (tmp___5 == 0) {
#line 1064
    goto ldv_27621;
  } else {

  }
#line 1064
  schedule();
#line 1064
  goto ldv_27622;
  ldv_27621: 
#line 1064
  finish_wait(& cq->wait, & __wait);
  ldv_27619: ;
#line 1066
  if (cq->is_kernel != 0) {
#line 1067
    mthca_free_cq_buf(dev, & cq->buf, cq->ibcq.cqe);
#line 1068
    tmp___6 = mthca_is_memfree(dev);
#line 1068
    if (tmp___6 != 0) {
#line 1069
      mthca_free_db(dev, 2, cq->arm_db_index);
#line 1070
      mthca_free_db(dev, 1, cq->set_ci_db_index);
    } else {

    }
  } else {

  }
#line 1074
  mthca_table_put(dev, dev->cq_table.table, cq->cqn);
#line 1075
  mthca_free(& dev->cq_table.alloc, (u32 )cq->cqn);
#line 1076
  mthca_free_mailbox(dev, mailbox);
#line 1077
  return;
}
}
#line 1079 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int mthca_init_cq_table(struct mthca_dev *dev ) 
{ int err ;
  struct lock_class_key __key ;

  {
#line 1083
  spinlock_check(& dev->cq_table.lock);
#line 1083
  __raw_spin_lock_init(& dev->cq_table.lock.ldv_5961.rlock, "&(&dev->cq_table.lock)->rlock",
                       & __key);
#line 1085
  err = mthca_alloc_init(& dev->cq_table.alloc, (u32 )dev->limits.num_cqs, 16777215U,
                         (u32 )dev->limits.reserved_cqs);
#line 1089
  if (err != 0) {
#line 1090
    return (err);
  } else {

  }
#line 1092
  err = mthca_array_init(& dev->cq_table.cq, dev->limits.num_cqs);
#line 1094
  if (err != 0) {
#line 1095
    mthca_alloc_cleanup(& dev->cq_table.alloc);
  } else {

  }
#line 1097
  return (err);
}
}
#line 1100 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void mthca_cleanup_cq_table(struct mthca_dev *dev ) 
{ 

  {
#line 1102
  mthca_array_cleanup(& dev->cq_table.cq, dev->limits.num_cqs);
#line 1103
  mthca_alloc_cleanup(& dev->cq_table.alloc);
#line 1104
  return;
}
}
#line 1106 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1111
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1113
  mutex_lock(ldv_func_arg1);
#line 1114
  return;
}
}
#line 1116 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1121
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1123
  mutex_unlock(ldv_func_arg1);
#line 1124
  return;
}
}
#line 1126 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1131
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1133
  mutex_lock(ldv_func_arg1);
#line 1134
  return;
}
}
#line 1136 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1141
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1143
  mutex_unlock(ldv_func_arg1);
#line 1144
  return;
}
}
#line 1146 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1151
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1153
  mutex_lock(ldv_func_arg1);
#line 1154
  return;
}
}
#line 1156 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
int ldv_mutex_trylock_94(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1161
  tmp = mutex_trylock(ldv_func_arg1);
#line 1161
  ldv_func_res = tmp;
#line 1163
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1163
  return (tmp___0);
#line 1165
  return (ldv_func_res);
}
}
#line 1168 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_cq.c.prepared"
void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1173
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1175
  mutex_unlock(ldv_func_arg1);
#line 1176
  return;
}
}
#line 324 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
#line 328
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 333
  return (oldbit);
}
}
#line 447 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ int r ;

  {
#line 461
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 474
  return (r + 1);
}
}
#line 35 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_106(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) ;
#line 61 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
#line 61
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 62
  return;
}
}
#line 215 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;

  {
#line 217
  __len = count;
#line 217
  __ret = __builtin_memcpy((void *)dst, src, __len);
#line 219
  return;
}
}
#line 314 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 316
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 317
    return (0);
  } else {

  }
#line 318
  tmp = __kmalloc(n * size, flags);
#line 318
  return (tmp);
}
}
#line 327 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 329
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 329
  return (tmp);
}
}
#line 59 "include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 97 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 101
  tmp = get_dma_ops(dev);
#line 101
  ops = tmp;
#line 103
  tmp___0 = valid_dma_direction((int )dir);
#line 103
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 103
  if (tmp___1 != 0L) {
#line 103
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (103), "i" (12UL));
    ldv_18645: ;
#line 103
    goto ldv_18645;
  } else {

  }
#line 104
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 107
  return;
}
}
#line 109 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 113
  tmp = get_dma_ops(dev);
#line 113
  ops = tmp;
#line 115
  tmp___0 = valid_dma_direction((int )dir);
#line 115
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 115
  if (tmp___1 != 0L) {
#line 115
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (115), "i" (12UL));
    ldv_18653: ;
#line 115
    goto ldv_18653;
  } else {

  }
#line 116
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 117
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 118
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 119
  return;
}
}
#line 304 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_fmr *to_mfmr(struct ib_fmr *ibmr ) 
{ struct ib_fmr  const  *__mptr ;

  {
#line 306
  __mptr = (struct ib_fmr  const  *)ibmr;
#line 306
  return ((struct mthca_fmr *)__mptr);
}
}
#line 54 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_doorbell.h"
__inline static void mthca_write64_raw(__be64 val , void *dest ) 
{ 

  {
#line 56
  writeq((unsigned long )val, (void volatile   *)dest);
#line 57
  return;
}
}
#line 465 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_write_mtt_size(struct mthca_dev *dev ) ;
#line 467
struct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev , int size ) ;
#line 468
void mthca_free_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt ) ;
#line 469
int mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                    u64 *buffer_list , int list_len ) ;
#line 471
int mthca_mr_alloc(struct mthca_dev *dev , u32 pd , int buffer_size_shift , u64 iova ,
                   u64 total_size , u32 access , struct mthca_mr *mr ) ;
#line 481
int mthca_fmr_alloc(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_fmr *mr ) ;
#line 483
int mthca_tavor_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) ;
#line 485
void mthca_tavor_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 486
int mthca_arbel_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) ;
#line 488
void mthca_arbel_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 489
int mthca_free_fmr(struct mthca_dev *dev , struct mthca_fmr *fmr ) ;
#line 93 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
void *mthca_table_find(struct mthca_icm_table *table , int obj , dma_addr_t *dma_handle ) ;
#line 94
int mthca_table_get_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                          int start , int end ) ;
#line 96
void mthca_table_put_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                           int start , int end ) ;
#line 204 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static u32 mthca_buddy_alloc(struct mthca_buddy *buddy , int order ) 
{ int o ;
  int m ;
  u32 seg ;
  unsigned long tmp ;

  {
#line 210
  spin_lock(& buddy->lock);
#line 212
  o = order;
#line 212
  goto ldv_22303;
  ldv_22302: ;
#line 213
  if (*(buddy->num_free + (unsigned long )o) != 0) {
#line 214
    m = 1 << (buddy->max_order - o);
#line 215
    tmp = find_first_bit((unsigned long const   *)*(buddy->bits + (unsigned long )o),
                         (unsigned long )m);
#line 215
    seg = (u32 )tmp;
#line 216
    if ((u32 )m > seg) {
#line 217
      goto found;
    } else {

    }
  } else {

  }
#line 212
  o = o + 1;
  ldv_22303: ;
#line 212
  if (buddy->max_order >= o) {
#line 213
    goto ldv_22302;
  } else {
#line 215
    goto ldv_22304;
  }
  ldv_22304: 
#line 220
  spin_unlock(& buddy->lock);
#line 221
  return (4294967295U);
  found: 
#line 224
  clear_bit((int )seg, (unsigned long volatile   *)*(buddy->bits + (unsigned long )o));
#line 225
  *(buddy->num_free + (unsigned long )o) = *(buddy->num_free + (unsigned long )o) - 1;
#line 227
  goto ldv_22306;
  ldv_22305: 
#line 228
  o = o - 1;
#line 229
  seg = seg << 1;
#line 230
  set_bit(seg ^ 1U, (unsigned long volatile   *)*(buddy->bits + (unsigned long )o));
#line 231
  *(buddy->num_free + (unsigned long )o) = *(buddy->num_free + (unsigned long )o) + 1;
  ldv_22306: ;
#line 227
  if (o > order) {
#line 228
    goto ldv_22305;
  } else {
#line 230
    goto ldv_22307;
  }
  ldv_22307: 
#line 234
  spin_unlock(& buddy->lock);
#line 236
  seg = seg << order;
#line 238
  return (seg);
}
}
#line 241 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static void mthca_buddy_free(struct mthca_buddy *buddy , u32 seg , int order ) 
{ int tmp ;

  {
#line 243
  seg = seg >> order;
#line 245
  spin_lock(& buddy->lock);
#line 247
  goto ldv_22314;
  ldv_22313: 
#line 248
  clear_bit((int )(seg ^ 1U), (unsigned long volatile   *)*(buddy->bits + (unsigned long )order));
#line 249
  *(buddy->num_free + (unsigned long )order) = *(buddy->num_free + (unsigned long )order) - 1;
#line 250
  seg = seg >> 1;
#line 251
  order = order + 1;
  ldv_22314: 
#line 247
  tmp = variable_test_bit((int )(seg ^ 1U), (unsigned long const volatile   *)*(buddy->bits + (unsigned long )order));
#line 247
  if (tmp != 0) {
#line 248
    goto ldv_22313;
  } else {
#line 250
    goto ldv_22315;
  }
  ldv_22315: 
#line 254
  set_bit(seg, (unsigned long volatile   *)*(buddy->bits + (unsigned long )order));
#line 255
  *(buddy->num_free + (unsigned long )order) = *(buddy->num_free + (unsigned long )order) + 1;
#line 257
  spin_unlock(& buddy->lock);
#line 258
  return;
}
}
#line 260 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static int mthca_buddy_init(struct mthca_buddy *buddy , int max_order ) 
{ int i ;
  int s ;
  struct lock_class_key __key ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 264
  buddy->max_order = max_order;
#line 265
  spinlock_check(& buddy->lock);
#line 265
  __raw_spin_lock_init(& buddy->lock.ldv_5961.rlock, "&(&buddy->lock)->rlock", & __key);
#line 267
  tmp = kzalloc((unsigned long )(buddy->max_order + 1) * 8UL, 208U);
#line 267
  buddy->bits = (unsigned long **)tmp;
#line 269
  tmp___0 = kcalloc((size_t )(buddy->max_order + 1), 4UL, 208U);
#line 269
  buddy->num_free = (int *)tmp___0;
#line 271
  if ((unsigned long )buddy->bits == (unsigned long )((unsigned long **)0) || (unsigned long )buddy->num_free == (unsigned long )((int *)0)) {
#line 272
    goto err_out;
  } else {

  }
#line 274
  i = 0;
#line 274
  goto ldv_22326;
  ldv_22325: 
#line 275
  s = (int )(((unsigned long )(1 << (buddy->max_order - i)) + 63UL) / 64UL);
#line 276
  tmp___1 = kmalloc((unsigned long )s * 8UL, 208U);
#line 276
  *(buddy->bits + (unsigned long )i) = (unsigned long *)tmp___1;
#line 277
  if ((unsigned long )*(buddy->bits + (unsigned long )i) == (unsigned long )((unsigned long *)0)) {
#line 278
    goto err_out_free;
  } else {

  }
#line 279
  bitmap_zero(*(buddy->bits + (unsigned long )i), 1 << (buddy->max_order - i));
#line 274
  i = i + 1;
  ldv_22326: ;
#line 274
  if (buddy->max_order >= i) {
#line 275
    goto ldv_22325;
  } else {
#line 277
    goto ldv_22327;
  }
  ldv_22327: 
#line 283
  set_bit(0U, (unsigned long volatile   *)*(buddy->bits + (unsigned long )buddy->max_order));
#line 284
  *(buddy->num_free + (unsigned long )buddy->max_order) = 1;
#line 286
  return (0);
  err_out_free: 
#line 289
  i = 0;
#line 289
  goto ldv_22329;
  ldv_22328: 
#line 290
  kfree((void const   *)*(buddy->bits + (unsigned long )i));
#line 289
  i = i + 1;
  ldv_22329: ;
#line 289
  if (buddy->max_order >= i) {
#line 290
    goto ldv_22328;
  } else {
#line 292
    goto ldv_22330;
  }
  ldv_22330: ;
  err_out: 
#line 293
  kfree((void const   *)buddy->bits);
#line 294
  kfree((void const   *)buddy->num_free);
#line 296
  return (-12);
}
}
#line 299 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static void mthca_buddy_cleanup(struct mthca_buddy *buddy ) 
{ int i ;

  {
#line 303
  i = 0;
#line 303
  goto ldv_22336;
  ldv_22335: 
#line 304
  kfree((void const   *)*(buddy->bits + (unsigned long )i));
#line 303
  i = i + 1;
  ldv_22336: ;
#line 303
  if (buddy->max_order >= i) {
#line 304
    goto ldv_22335;
  } else {
#line 306
    goto ldv_22337;
  }
  ldv_22337: 
#line 306
  kfree((void const   *)buddy->bits);
#line 307
  kfree((void const   *)buddy->num_free);
#line 308
  return;
}
}
#line 310 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static u32 mthca_alloc_mtt_range(struct mthca_dev *dev , int order , struct mthca_buddy *buddy ) 
{ u32 seg ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 313
  tmp = mthca_buddy_alloc(buddy, order);
#line 313
  seg = tmp;
#line 315
  if (seg == 4294967295U) {
#line 316
    return (4294967295U);
  } else {

  }
#line 318
  tmp___1 = mthca_is_memfree(dev);
#line 318
  if (tmp___1 != 0) {
#line 319
    tmp___0 = mthca_table_get_range(dev, dev->mr_table.mtt_table, (int )seg, (int )(((u32 )(1 << order) + seg) - 1U));
#line 319
    if (tmp___0 != 0) {
#line 321
      mthca_buddy_free(buddy, seg, order);
#line 322
      seg = 4294967295U;
    } else {

    }
  } else {

  }
#line 325
  return (seg);
}
}
#line 328 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static struct mthca_mtt *__mthca_alloc_mtt(struct mthca_dev *dev , int size , struct mthca_buddy *buddy ) 
{ struct mthca_mtt *mtt ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 334
  if (size <= 0) {
#line 335
    tmp = ERR_PTR(-22L);
#line 335
    return ((struct mthca_mtt *)tmp);
  } else {

  }
#line 337
  tmp___0 = kmalloc(16UL, 208U);
#line 337
  mtt = (struct mthca_mtt *)tmp___0;
#line 338
  if ((unsigned long )mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 339
    tmp___1 = ERR_PTR(-12L);
#line 339
    return ((struct mthca_mtt *)tmp___1);
  } else {

  }
#line 341
  mtt->buddy = buddy;
#line 342
  mtt->order = 0;
#line 343
  i = dev->limits.mtt_seg_size / 8;
#line 343
  goto ldv_22352;
  ldv_22351: 
#line 344
  mtt->order = mtt->order + 1;
#line 343
  i = i << 1;
  ldv_22352: ;
#line 343
  if (i < size) {
#line 344
    goto ldv_22351;
  } else {
#line 346
    goto ldv_22353;
  }
  ldv_22353: 
#line 346
  mtt->first_seg = mthca_alloc_mtt_range(dev, mtt->order, buddy);
#line 347
  if (mtt->first_seg == 4294967295U) {
#line 348
    kfree((void const   *)mtt);
#line 349
    tmp___2 = ERR_PTR(-12L);
#line 349
    return ((struct mthca_mtt *)tmp___2);
  } else {

  }
#line 352
  return (mtt);
}
}
#line 355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
struct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev , int size ) 
{ struct mthca_mtt *tmp ;

  {
#line 357
  tmp = __mthca_alloc_mtt(dev, size, & dev->mr_table.mtt_buddy);
#line 357
  return (tmp);
}
}
#line 360 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void mthca_free_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt ) 
{ 

  {
#line 362
  if ((unsigned long )mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 363
    return;
  } else {

  }
#line 365
  mthca_buddy_free(mtt->buddy, mtt->first_seg, mtt->order);
#line 367
  mthca_table_put_range(dev, dev->mr_table.mtt_table, (int )mtt->first_seg, (int )((mtt->first_seg + (u32 )(1 << mtt->order)) - 1U));
#line 371
  kfree((void const   *)mtt);
#line 372
  return;
}
}
#line 374 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static int __mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                             u64 *buffer_list , int list_len ) 
{ struct mthca_mailbox *mailbox ;
  __be64 *mtt_entry ;
  int err ;
  int i ;
  long tmp ;
  long tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;

  {
#line 379
  err = 0;
#line 382
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 383
  tmp___0 = IS_ERR((void const   *)mailbox);
#line 383
  if (tmp___0 != 0L) {
#line 384
    tmp = PTR_ERR((void const   *)mailbox);
#line 384
    return ((int )tmp);
  } else {

  }
#line 385
  mtt_entry = (__be64 *)mailbox->buf;
#line 387
  goto ldv_22378;
  ldv_22377: 
#line 388
  tmp___1 = __fswab64((dev->mr_table.mtt_base + (u64 )(mtt->first_seg * (u32 )dev->limits.mtt_seg_size)) + (u64 )(start_index * 8));
#line 388
  *mtt_entry = tmp___1;
#line 391
  *(mtt_entry + 1UL) = 0ULL;
#line 392
  i = 0;
#line 392
  goto ldv_22374;
  ldv_22373: 
#line 393
  tmp___2 = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 393
  *(mtt_entry + ((unsigned long )i + 2UL)) = tmp___2;
#line 392
  i = i + 1;
  ldv_22374: ;
#line 392
  if (i < list_len && i <= 509) {
#line 393
    goto ldv_22373;
  } else {
#line 395
    goto ldv_22375;
  }
  ldv_22375: ;
#line 400
  if (i & 1) {
#line 401
    *(mtt_entry + ((unsigned long )i + 2UL)) = 0ULL;
  } else {

  }
#line 403
  err = mthca_WRITE_MTT(dev, mailbox, (i + 1) & -2);
#line 404
  if (err != 0) {
#line 405
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MTT failed (%d)\n",
             err);
#line 406
    goto out;
  } else {

  }
#line 409
  list_len = list_len - i;
#line 410
  start_index = start_index + i;
#line 411
  buffer_list = buffer_list + (unsigned long )i;
  ldv_22378: ;
#line 387
  if (list_len > 0) {
#line 388
    goto ldv_22377;
  } else {
#line 390
    goto ldv_22379;
  }
  ldv_22379: ;
  out: 
#line 415
  mthca_free_mailbox(dev, mailbox);
#line 416
  return (err);
}
}
#line 419 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_write_mtt_size(struct mthca_dev *dev ) 
{ int tmp___0 ;
  int tmp___1 ;

  {
#line 421
  if ((unsigned long )dev->mr_table.fmr_mtt_buddy != (unsigned long )(& dev->mr_table.mtt_buddy) || (dev->mthca_flags & 32UL) == 0UL) {
#line 429
    return (510);
  } else {

  }
#line 432
  tmp___1 = mthca_is_memfree(dev);
#line 432
  if (tmp___1 != 0) {
#line 432
    tmp___0 = 512;
  } else {
#line 432
    tmp___0 = 134217727;
  }
#line 432
  return (tmp___0);
}
}
#line 435 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static void mthca_tavor_write_mtt_seg(struct mthca_dev *dev , struct mthca_mtt *mtt ,
                                      int start_index , u64 *buffer_list , int list_len ) 
{ u64 *mtts ;
  int i ;
  __u64 tmp ;

  {
#line 442
  mtts = (u64 *)(dev->mr_table.tavor_fmr.mtt_base + ((unsigned long )(mtt->first_seg * (u32 )dev->limits.mtt_seg_size) + (unsigned long )start_index * 8UL));
#line 444
  i = 0;
#line 444
  goto ldv_22393;
  ldv_22392: 
#line 445
  tmp = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 445
  mthca_write64_raw(tmp, (void *)mtts + (unsigned long )i);
#line 444
  i = i + 1;
  ldv_22393: ;
#line 444
  if (i < list_len) {
#line 445
    goto ldv_22392;
  } else {
#line 447
    goto ldv_22394;
  }
  ldv_22394: ;
#line 449
  return;
}
}
#line 449 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static void mthca_arbel_write_mtt_seg(struct mthca_dev *dev , struct mthca_mtt *mtt ,
                                      int start_index , u64 *buffer_list , int list_len ) 
{ __be64 *mtts ;
  dma_addr_t dma_handle ;
  int i ;
  int s ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  __u64 tmp___3 ;

  {
#line 456
  s = (int )((unsigned int )start_index * 8U);
#line 459
  tmp = ldv__builtin_expect((unsigned long )s / 4096UL != (((unsigned long )s + (unsigned long )list_len * 8UL) - 1UL) / 4096UL,
                         0L);
#line 459
  if (tmp != 0L) {
#line 459
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"),
                         "i" (459), "i" (12UL));
    ldv_22406: ;
#line 459
    goto ldv_22406;
  } else {

  }
#line 461
  tmp___0 = ldv__builtin_expect(s % dev->limits.mtt_seg_size != 0, 0L);
#line 461
  if (tmp___0 != 0L) {
#line 461
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"),
                         "i" (461), "i" (12UL));
    ldv_22407: ;
#line 461
    goto ldv_22407;
  } else {

  }
#line 463
  tmp___1 = mthca_table_find(dev->mr_table.mtt_table, (int )(mtt->first_seg + (u32 )(s / dev->limits.mtt_seg_size)),
                             & dma_handle);
#line 463
  mtts = (__be64 *)tmp___1;
#line 466
  tmp___2 = ldv__builtin_expect((unsigned long )mtts == (unsigned long )((__be64 *)0),
                             0L);
#line 466
  if (tmp___2 != 0L) {
#line 466
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"),
                         "i" (466), "i" (12UL));
    ldv_22408: ;
#line 466
    goto ldv_22408;
  } else {

  }
#line 468
  dma_sync_single_for_cpu(& (dev->pdev)->dev, dma_handle, (unsigned long )list_len * 8UL,
                          1);
#line 471
  i = 0;
#line 471
  goto ldv_22410;
  ldv_22409: 
#line 472
  tmp___3 = __fswab64(*(buffer_list + (unsigned long )i) | 1ULL);
#line 472
  *(mtts + (unsigned long )i) = tmp___3;
#line 471
  i = i + 1;
  ldv_22410: ;
#line 471
  if (i < list_len) {
#line 472
    goto ldv_22409;
  } else {
#line 474
    goto ldv_22411;
  }
  ldv_22411: 
#line 474
  dma_sync_single_for_device(& (dev->pdev)->dev, dma_handle, (unsigned long )list_len * 8UL,
                             1);
#line 476
  return;
}
}
#line 478 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_write_mtt(struct mthca_dev *dev , struct mthca_mtt *mtt , int start_index ,
                    u64 *buffer_list , int list_len ) 
{ int size ;
  int tmp ;
  int chunk ;
  int tmp___0 ;
  int _min1 ;
  int _min2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 481
  tmp = mthca_write_mtt_size(dev);
#line 481
  size = tmp;
#line 484
  if ((unsigned long )dev->mr_table.fmr_mtt_buddy != (unsigned long )(& dev->mr_table.mtt_buddy) || (dev->mthca_flags & 32UL) == 0UL) {
#line 486
    tmp___0 = __mthca_write_mtt(dev, mtt, start_index, buffer_list, list_len);
#line 486
    return (tmp___0);
  } else {

  }
#line 488
  goto ldv_22425;
  ldv_22424: 
#line 489
  _min1 = size;
#line 489
  _min2 = list_len;
#line 489
  if (_min1 < _min2) {
#line 489
    tmp___1 = _min1;
  } else {
#line 489
    tmp___1 = _min2;
  }
#line 489
  chunk = tmp___1;
#line 490
  tmp___2 = mthca_is_memfree(dev);
#line 490
  if (tmp___2 != 0) {
#line 491
    mthca_arbel_write_mtt_seg(dev, mtt, start_index, buffer_list, chunk);
  } else {
#line 494
    mthca_tavor_write_mtt_seg(dev, mtt, start_index, buffer_list, chunk);
  }
#line 497
  list_len = list_len - chunk;
#line 498
  start_index = start_index + chunk;
#line 499
  buffer_list = buffer_list + (unsigned long )chunk;
  ldv_22425: ;
#line 488
  if (list_len > 0) {
#line 489
    goto ldv_22424;
  } else {
#line 491
    goto ldv_22426;
  }
  ldv_22426: ;
#line 502
  return (0);
}
}
#line 505 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 tavor_hw_index_to_key(u32 ind ) 
{ 

  {
#line 507
  return (ind);
}
}
#line 515 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 arbel_hw_index_to_key(u32 ind ) 
{ 

  {
#line 517
  return ((ind << 8) | (ind >> (8UL * sizeof(ind) - 8UL)));
}
}
#line 520 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 arbel_key_to_hw_index(u32 key ) 
{ 

  {
#line 522
  return ((key << 24) | (key >> (8UL * sizeof(key) - 24UL)));
}
}
#line 525 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 hw_index_to_key(struct mthca_dev *dev , u32 ind ) 
{ u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 527
  tmp___1 = mthca_is_memfree(dev);
#line 527
  if (tmp___1 != 0) {
#line 528
    tmp = arbel_hw_index_to_key(ind);
#line 528
    return (tmp);
  } else {
#line 530
    tmp___0 = tavor_hw_index_to_key(ind);
#line 530
    return (tmp___0);
  }
}
}
#line 533 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 key_to_hw_index(struct mthca_dev *dev , u32 key ) 
{ u32 tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 535
  tmp___1 = mthca_is_memfree(dev);
#line 535
  if (tmp___1 != 0) {
#line 536
    tmp = arbel_key_to_hw_index(key);
#line 536
    return (tmp);
  } else {
#line 538
    tmp___0 = tavor_hw_index_to_key(key);
#line 538
    return (tmp___0);
  }
}
}
#line 541 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static u32 adjust_key(struct mthca_dev *dev , u32 key ) 
{ 

  {
#line 543
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 544
    return (((key << 20) & 8388608U) | (key & 8388607U));
  } else {
#line 546
    return (key);
  }
}
}
#line 549 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_mr_alloc(struct mthca_dev *dev , u32 pd , int buffer_size_shift , u64 iova ,
                   u64 total_size , u32 access , struct mthca_mr *mr ) 
{ struct mthca_mailbox *mailbox ;
  struct mthca_mpt_entry *mpt_entry ;
  u32 key ;
  int i ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;
  __u64 tmp___10 ;
  __u32 tmp___11 ;

  {
#line 558
  __ret_warn_on = buffer_size_shift > 31;
#line 558
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 558
  if (tmp != 0L) {
#line 558
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared",
                       558);
  } else {

  }
#line 558
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 560
  key = mthca_alloc(& dev->mr_table.mpt_alloc);
#line 561
  if (key == 4294967295U) {
#line 562
    return (-12);
  } else {

  }
#line 563
  key = adjust_key(dev, key);
#line 564
  tmp___0 = hw_index_to_key(dev, key);
#line 564
  mr->ibmr.lkey = tmp___0;
#line 564
  mr->ibmr.rkey = tmp___0;
#line 566
  tmp___1 = mthca_is_memfree(dev);
#line 566
  if (tmp___1 != 0) {
#line 567
    err = mthca_table_get(dev, dev->mr_table.mpt_table, (int )key);
#line 568
    if (err != 0) {
#line 569
      goto err_out_mpt_free;
    } else {

    }
  } else {

  }
#line 572
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 573
  tmp___3 = IS_ERR((void const   *)mailbox);
#line 573
  if (tmp___3 != 0L) {
#line 574
    tmp___2 = PTR_ERR((void const   *)mailbox);
#line 574
    err = (int )tmp___2;
#line 575
    goto err_out_table;
  } else {

  }
#line 577
  mpt_entry = (struct mthca_mpt_entry *)mailbox->buf;
#line 579
  tmp___4 = __fswab32(access | 4026663168U);
#line 579
  mpt_entry->flags = tmp___4;
#line 583
  if ((unsigned long )mr->mtt == (unsigned long )((struct mthca_mtt *)0)) {
#line 584
    mpt_entry->flags = mpt_entry->flags | 131072U;
  } else {

  }
#line 586
  tmp___5 = __fswab32((__u32 )(buffer_size_shift + -12));
#line 586
  mpt_entry->page_size = tmp___5;
#line 587
  tmp___6 = __fswab32(key);
#line 587
  mpt_entry->key = tmp___6;
#line 588
  tmp___7 = __fswab32(pd);
#line 588
  mpt_entry->pd = tmp___7;
#line 589
  tmp___8 = __fswab64(iova);
#line 589
  mpt_entry->start = tmp___8;
#line 590
  tmp___9 = __fswab64(total_size);
#line 590
  mpt_entry->length = tmp___9;
#line 592
  memset((void *)(& mpt_entry->lkey), 0, 32UL);
#line 595
  if ((unsigned long )mr->mtt != (unsigned long )((struct mthca_mtt *)0)) {
#line 596
    tmp___10 = __fswab64(dev->mr_table.mtt_base + (u64 )((mr->mtt)->first_seg * (u32 )dev->limits.mtt_seg_size));
#line 596
    mpt_entry->mtt_seg = tmp___10;
  } else {

  }
#line 600
  if (0) {
#line 601
    if (mthca_debug_level != 0) {
#line 601
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping MPT entry %08x:\n",
                 mr->ibmr.lkey);
    } else {

    }
#line 602
    i = 0;
#line 602
    goto ldv_22470;
    ldv_22469: ;
#line 603
    if (((unsigned int )i & 3U) == 0U) {
#line 604
      printk("[%02x] ", i * 4);
    } else {

    }
#line 605
    tmp___11 = __fswab32(*((__be32 *)mpt_entry + (unsigned long )i));
#line 605
    printk(" %08x", tmp___11);
#line 606
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 607
      printk("\n");
    } else {

    }
#line 602
    i = i + 1;
    ldv_22470: ;
#line 602
    if ((unsigned int )i <= 15U) {
#line 603
      goto ldv_22469;
    } else {
#line 605
      goto ldv_22471;
    }
    ldv_22471: ;
  } else {

  }
#line 611
  err = mthca_SW2HW_MPT(dev, mailbox, (int )((u32 )(dev->limits.num_mpts + -1) & key));
#line 613
  if (err != 0) {
#line 614
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_MPT failed (%d)\n",
             err);
#line 615
    goto err_out_mailbox;
  } else {

  }
#line 618
  mthca_free_mailbox(dev, mailbox);
#line 619
  return (err);
  err_out_mailbox: 
#line 622
  mthca_free_mailbox(dev, mailbox);
  err_out_table: 
#line 625
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )key);
  err_out_mpt_free: 
#line 628
  mthca_free(& dev->mr_table.mpt_alloc, key);
#line 629
  return (err);
}
}
#line 632 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_mr_alloc_notrans(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_mr *mr ) 
{ int tmp ;

  {
#line 635
  mr->mtt = 0;
#line 636
  tmp = mthca_mr_alloc(dev, pd, 12, 0ULL, 0xffffffffffffffffULL, access, mr);
#line 636
  return (tmp);
}
}
#line 639 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_mr_alloc_phys(struct mthca_dev *dev , u32 pd , u64 *buffer_list , int buffer_size_shift ,
                        int list_len , u64 iova , u64 total_size , u32 access , struct mthca_mr *mr ) 
{ int err ;
  long tmp ;
  long tmp___0 ;

  {
#line 646
  mr->mtt = mthca_alloc_mtt(dev, list_len);
#line 647
  tmp___0 = IS_ERR((void const   *)mr->mtt);
#line 647
  if (tmp___0 != 0L) {
#line 648
    tmp = PTR_ERR((void const   *)mr->mtt);
#line 648
    return ((int )tmp);
  } else {

  }
#line 650
  err = mthca_write_mtt(dev, mr->mtt, 0, buffer_list, list_len);
#line 651
  if (err != 0) {
#line 652
    mthca_free_mtt(dev, mr->mtt);
#line 653
    return (err);
  } else {

  }
#line 656
  err = mthca_mr_alloc(dev, pd, buffer_size_shift, iova, total_size, access, mr);
#line 658
  if (err != 0) {
#line 659
    mthca_free_mtt(dev, mr->mtt);
  } else {

  }
#line 661
  return (err);
}
}
#line 665 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
static void mthca_free_region(struct mthca_dev *dev , u32 lkey ) 
{ u32 tmp ;
  u32 tmp___0 ;

  {
#line 667
  tmp = key_to_hw_index(dev, lkey);
#line 667
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )tmp);
#line 670
  tmp___0 = key_to_hw_index(dev, lkey);
#line 670
  mthca_free(& dev->mr_table.mpt_alloc, tmp___0);
#line 671
  return;
}
}
#line 673 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void mthca_free_mr(struct mthca_dev *dev , struct mthca_mr *mr ) 
{ int err ;
  u32 tmp ;

  {
#line 677
  tmp = key_to_hw_index(dev, mr->ibmr.lkey);
#line 677
  err = mthca_HW2SW_MPT(dev, 0, (int )(tmp & (u32 )(dev->limits.num_mpts + -1)));
#line 680
  if (err != 0) {
#line 681
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_MPT failed (%d)\n",
             err);
  } else {

  }
#line 683
  mthca_free_region(dev, mr->ibmr.lkey);
#line 684
  mthca_free_mtt(dev, mr->mtt);
#line 685
  return;
}
}
#line 687 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_fmr_alloc(struct mthca_dev *dev , u32 pd , u32 access , struct mthca_fmr *mr ) 
{ struct mthca_mpt_entry *mpt_entry ;
  struct mthca_mailbox *mailbox ;
  u64 mtt_seg ;
  u32 key ;
  u32 idx ;
  int list_len ;
  int err ;
  int i ;
  int tmp ;
  u32 tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;
  __u32 tmp___16 ;

  {
#line 694
  list_len = mr->attr.max_pages;
#line 695
  err = -12;
#line 698
  if ((unsigned int )mr->attr.page_shift <= 11U || (unsigned int )mr->attr.page_shift > 31U) {
#line 699
    return (-22);
  } else {

  }
#line 702
  tmp = mthca_is_memfree(dev);
#line 702
  if (tmp != 0 && (unsigned long )mr->attr.max_pages * 8UL > 4096UL) {
#line 704
    return (-22);
  } else {

  }
#line 706
  mr->maps = 0;
#line 708
  key = mthca_alloc(& dev->mr_table.mpt_alloc);
#line 709
  if (key == 4294967295U) {
#line 710
    return (-12);
  } else {

  }
#line 711
  key = adjust_key(dev, key);
#line 713
  idx = (u32 )(dev->limits.num_mpts + -1) & key;
#line 714
  tmp___0 = hw_index_to_key(dev, key);
#line 714
  mr->ibmr.lkey = tmp___0;
#line 714
  mr->ibmr.rkey = tmp___0;
#line 716
  tmp___3 = mthca_is_memfree(dev);
#line 716
  if (tmp___3 != 0) {
#line 717
    err = mthca_table_get(dev, dev->mr_table.mpt_table, (int )key);
#line 718
    if (err != 0) {
#line 719
      goto err_out_mpt_free;
    } else {

    }
#line 721
    tmp___1 = mthca_table_find(dev->mr_table.mpt_table, (int )key, 0);
#line 721
    mr->mem.arbel.mpt = (struct mthca_mpt_entry *)tmp___1;
#line 722
    tmp___2 = ldv__builtin_expect((unsigned long )mr->mem.arbel.mpt == (unsigned long )((struct mthca_mpt_entry *)0),
                               0L);
#line 722
    if (tmp___2 != 0L) {
#line 722
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"),
                           "i" (722), "i" (12UL));
      ldv_22515: ;
#line 722
      goto ldv_22515;
    } else {

    }
  } else {
#line 724
    mr->mem.tavor.mpt = (struct mthca_mpt_entry *)(dev->mr_table.tavor_fmr.mpt_base + (unsigned long )idx * 64UL);
  }
#line 727
  mr->mtt = __mthca_alloc_mtt(dev, list_len, dev->mr_table.fmr_mtt_buddy);
#line 728
  tmp___5 = IS_ERR((void const   *)mr->mtt);
#line 728
  if (tmp___5 != 0L) {
#line 729
    tmp___4 = PTR_ERR((void const   *)mr->mtt);
#line 729
    err = (int )tmp___4;
#line 730
    goto err_out_table;
  } else {

  }
#line 733
  mtt_seg = (u64 )((mr->mtt)->first_seg * (u32 )dev->limits.mtt_seg_size);
#line 735
  tmp___8 = mthca_is_memfree(dev);
#line 735
  if (tmp___8 != 0) {
#line 736
    tmp___6 = mthca_table_find(dev->mr_table.mtt_table, (int )(mr->mtt)->first_seg,
                               & mr->mem.arbel.dma_handle);
#line 736
    mr->mem.arbel.mtts = (__be64 *)tmp___6;
#line 739
    tmp___7 = ldv__builtin_expect((unsigned long )mr->mem.arbel.mtts == (unsigned long )((__be64 *)0),
                               0L);
#line 739
    if (tmp___7 != 0L) {
#line 739
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"),
                           "i" (739), "i" (12UL));
      ldv_22517: ;
#line 739
      goto ldv_22517;
    } else {

    }
  } else {
#line 741
    mr->mem.tavor.mtts = (u64 *)(dev->mr_table.tavor_fmr.mtt_base + mtt_seg);
  }
#line 743
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 744
  tmp___10 = IS_ERR((void const   *)mailbox);
#line 744
  if (tmp___10 != 0L) {
#line 745
    tmp___9 = PTR_ERR((void const   *)mailbox);
#line 745
    err = (int )tmp___9;
#line 746
    goto err_out_free_mtt;
  } else {

  }
#line 749
  mpt_entry = (struct mthca_mpt_entry *)mailbox->buf;
#line 751
  tmp___11 = __fswab32(access | 4026663168U);
#line 751
  mpt_entry->flags = tmp___11;
#line 756
  tmp___12 = __fswab32((__u32 )((int )mr->attr.page_shift + -12));
#line 756
  mpt_entry->page_size = tmp___12;
#line 757
  tmp___13 = __fswab32(key);
#line 757
  mpt_entry->key = tmp___13;
#line 758
  tmp___14 = __fswab32(pd);
#line 758
  mpt_entry->pd = tmp___14;
#line 759
  memset((void *)(& mpt_entry->start), 0, 48UL);
#line 761
  tmp___15 = __fswab64(dev->mr_table.mtt_base + mtt_seg);
#line 761
  mpt_entry->mtt_seg = tmp___15;
#line 763
  if (0) {
#line 764
    if (mthca_debug_level != 0) {
#line 764
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Dumping MPT entry %08x:\n",
                 mr->ibmr.lkey);
    } else {

    }
#line 765
    i = 0;
#line 765
    goto ldv_22520;
    ldv_22519: ;
#line 766
    if (((unsigned int )i & 3U) == 0U) {
#line 767
      printk("[%02x] ", i * 4);
    } else {

    }
#line 768
    tmp___16 = __fswab32(*((__be32 *)mpt_entry + (unsigned long )i));
#line 768
    printk(" %08x", tmp___16);
#line 769
    if (((unsigned int )(i + 1) & 3U) == 0U) {
#line 770
      printk("\n");
    } else {

    }
#line 765
    i = i + 1;
    ldv_22520: ;
#line 765
    if ((unsigned int )i <= 15U) {
#line 766
      goto ldv_22519;
    } else {
#line 768
      goto ldv_22521;
    }
    ldv_22521: ;
  } else {

  }
#line 774
  err = mthca_SW2HW_MPT(dev, mailbox, (int )((u32 )(dev->limits.num_mpts + -1) & key));
#line 776
  if (err != 0) {
#line 777
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_MPT failed (%d)\n",
             err);
#line 778
    goto err_out_mailbox_free;
  } else {

  }
#line 781
  mthca_free_mailbox(dev, mailbox);
#line 782
  return (0);
  err_out_mailbox_free: 
#line 785
  mthca_free_mailbox(dev, mailbox);
  err_out_free_mtt: 
#line 788
  mthca_free_mtt(dev, mr->mtt);
  err_out_table: 
#line 791
  mthca_table_put(dev, dev->mr_table.mpt_table, (int )key);
  err_out_mpt_free: 
#line 794
  mthca_free(& dev->mr_table.mpt_alloc, key);
#line 795
  return (err);
}
}
#line 798 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_free_fmr(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 

  {
#line 800
  if (fmr->maps != 0) {
#line 801
    return (-16);
  } else {

  }
#line 803
  mthca_free_region(dev, fmr->ibmr.lkey);
#line 804
  mthca_free_mtt(dev, fmr->mtt);
#line 806
  return (0);
}
}
#line 809 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
__inline static int mthca_check_fmr(struct mthca_fmr *fmr , u64 *page_list , int list_len ,
                                    u64 iova ) 
{ int i ;
  int page_mask ;

  {
#line 814
  if (fmr->attr.max_pages < list_len) {
#line 815
    return (-22);
  } else {

  }
#line 817
  page_mask = (1 << (int )fmr->attr.page_shift) + -1;
#line 820
  if (((u64 )page_mask & iova) != 0ULL) {
#line 821
    return (-22);
  } else {

  }
#line 824
  if (0) {
#line 825
    i = 0;
#line 825
    goto ldv_22536;
    ldv_22535: ;
#line 826
    if ((*(page_list + (unsigned long )i) & (u64 )(~ page_mask)) != 0ULL) {
#line 827
      return (-22);
    } else {

    }
#line 825
    i = i + 1;
    ldv_22536: ;
#line 825
    if (i < list_len) {
#line 826
      goto ldv_22535;
    } else {
#line 828
      goto ldv_22537;
    }
    ldv_22537: ;
  } else {

  }
#line 830
  if (fmr->maps >= fmr->attr.max_maps) {
#line 831
    return (-22);
  } else {

  }
#line 833
  return (0);
}
}
#line 837 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_tavor_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) 
{ struct mthca_fmr *fmr ;
  struct mthca_fmr *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  struct mthca_mpt_entry mpt_entry ;
  u32 key ;
  int i ;
  int err ;
  u32 tmp___1 ;
  __be64 mtt_entry ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;

  {
#line 840
  tmp = to_mfmr(ibfmr);
#line 840
  fmr = tmp;
#line 841
  tmp___0 = to_mdev(ibfmr->device);
#line 841
  dev = tmp___0;
#line 846
  err = mthca_check_fmr(fmr, page_list, list_len, iova);
#line 847
  if (err != 0) {
#line 848
    return (err);
  } else {

  }
#line 850
  fmr->maps = fmr->maps + 1;
#line 852
  key = tavor_hw_index_to_key(fmr->ibmr.lkey);
#line 853
  key = (u32 )dev->limits.num_mpts + key;
#line 854
  tmp___1 = tavor_hw_index_to_key(key);
#line 854
  fmr->ibmr.rkey = tmp___1;
#line 854
  fmr->ibmr.lkey = tmp___1;
#line 856
  writeb(240, (void volatile   *)fmr->mem.tavor.mpt);
#line 858
  i = 0;
#line 858
  goto ldv_22552;
  ldv_22551: 
#line 859
  tmp___2 = __fswab64(*(page_list + (unsigned long )i) | 1ULL);
#line 859
  mtt_entry = tmp___2;
#line 861
  mthca_write64_raw(mtt_entry, (void *)fmr->mem.tavor.mtts + (unsigned long )i);
#line 858
  i = i + 1;
  ldv_22552: ;
#line 858
  if (i < list_len) {
#line 859
    goto ldv_22551;
  } else {
#line 861
    goto ldv_22553;
  }
  ldv_22553: 
#line 864
  tmp___3 = __fswab32(key);
#line 864
  mpt_entry.lkey = tmp___3;
#line 865
  tmp___4 = __fswab64((unsigned long long )list_len << (int )fmr->attr.page_shift);
#line 865
  mpt_entry.length = tmp___4;
#line 866
  tmp___5 = __fswab64(iova);
#line 866
  mpt_entry.start = tmp___5;
#line 868
  __writel(mpt_entry.lkey, (void volatile   *)(& (fmr->mem.tavor.mpt)->key));
#line 869
  memcpy_toio((void volatile   *)(& (fmr->mem.tavor.mpt)->start), (void const   *)(& mpt_entry.start),
              20UL);
#line 873
  writeb(0, (void volatile   *)fmr->mem.tavor.mpt);
#line 875
  return (0);
}
}
#line 878 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_arbel_map_phys_fmr(struct ib_fmr *ibfmr , u64 *page_list , int list_len ,
                             u64 iova ) 
{ struct mthca_fmr *fmr ;
  struct mthca_fmr *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  u32 key ;
  int i ;
  int err ;
  u32 tmp___1 ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;

  {
#line 881
  tmp = to_mfmr(ibfmr);
#line 881
  fmr = tmp;
#line 882
  tmp___0 = to_mdev(ibfmr->device);
#line 882
  dev = tmp___0;
#line 886
  err = mthca_check_fmr(fmr, page_list, list_len, iova);
#line 887
  if (err != 0) {
#line 888
    return (err);
  } else {

  }
#line 890
  fmr->maps = fmr->maps + 1;
#line 892
  key = arbel_key_to_hw_index(fmr->ibmr.lkey);
#line 893
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 894
    key = key + 16777216U;
  } else {
#line 896
    key = (u32 )dev->limits.num_mpts + key;
  }
#line 897
  tmp___1 = arbel_hw_index_to_key(key);
#line 897
  fmr->ibmr.rkey = tmp___1;
#line 897
  fmr->ibmr.lkey = tmp___1;
#line 899
  *((u8 *)fmr->mem.arbel.mpt) = 240U;
#line 901
  __asm__  volatile   ("sfence": : : "memory");
#line 903
  dma_sync_single_for_cpu(& (dev->pdev)->dev, fmr->mem.arbel.dma_handle, (unsigned long )list_len * 8UL,
                          1);
#line 906
  i = 0;
#line 906
  goto ldv_22566;
  ldv_22565: 
#line 907
  tmp___2 = __fswab64(*(page_list + (unsigned long )i) | 1ULL);
#line 907
  *(fmr->mem.arbel.mtts + (unsigned long )i) = tmp___2;
#line 906
  i = i + 1;
  ldv_22566: ;
#line 906
  if (i < list_len) {
#line 907
    goto ldv_22565;
  } else {
#line 909
    goto ldv_22567;
  }
  ldv_22567: 
#line 910
  dma_sync_single_for_device(& (dev->pdev)->dev, fmr->mem.arbel.dma_handle, (unsigned long )list_len * 8UL,
                             1);
#line 913
  tmp___3 = __fswab32(key);
#line 913
  (fmr->mem.arbel.mpt)->key = tmp___3;
#line 914
  tmp___4 = __fswab32(key);
#line 914
  (fmr->mem.arbel.mpt)->lkey = tmp___4;
#line 915
  tmp___5 = __fswab64((unsigned long long )list_len << (int )fmr->attr.page_shift);
#line 915
  (fmr->mem.arbel.mpt)->length = tmp___5;
#line 916
  tmp___6 = __fswab64(iova);
#line 916
  (fmr->mem.arbel.mpt)->start = tmp___6;
#line 918
  __asm__  volatile   ("sfence": : : "memory");
#line 920
  *((u8 *)fmr->mem.arbel.mpt) = 0U;
#line 922
  __asm__  volatile   ("sfence": : : "memory");
#line 924
  return (0);
}
}
#line 927 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void mthca_tavor_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 

  {
#line 929
  if (fmr->maps == 0) {
#line 930
    return;
  } else {

  }
#line 932
  fmr->maps = 0;
#line 934
  writeb(240, (void volatile   *)fmr->mem.tavor.mpt);
#line 935
  return;
}
}
#line 937 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void mthca_arbel_fmr_unmap(struct mthca_dev *dev , struct mthca_fmr *fmr ) 
{ 

  {
#line 939
  if (fmr->maps == 0) {
#line 940
    return;
  } else {

  }
#line 942
  fmr->maps = 0;
#line 944
  *((u8 *)fmr->mem.arbel.mpt) = 240U;
#line 945
  return;
}
}
#line 947 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int mthca_init_mr_table(struct mthca_dev *dev ) 
{ phys_addr_t addr ;
  int mpts ;
  int mtts ;
  int err ;
  int i ;
  int tmp ;
  int tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;

  {
#line 952
  err = mthca_alloc_init(& dev->mr_table.mpt_alloc, (u32 )dev->limits.num_mpts, 4294967295U,
                         (u32 )dev->limits.reserved_mrws);
#line 955
  if (err != 0) {
#line 956
    return (err);
  } else {

  }
#line 958
  tmp = mthca_is_memfree(dev);
#line 958
  if (tmp == 0 && (dev->mthca_flags & 2UL) != 0UL) {
#line 960
    dev->limits.fmr_reserved_mtts = 0;
  } else {
#line 962
    dev->mthca_flags = dev->mthca_flags | 32UL;
  }
#line 964
  if ((dev->mthca_flags & 256UL) != 0UL) {
#line 965
    if (mthca_debug_level != 0) {
#line 965
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Memory key throughput optimization activated.\n");
    } else {

    }
  } else {

  }
#line 967
  tmp___0 = fls(dev->limits.num_mtt_segs + -1);
#line 967
  err = mthca_buddy_init(& dev->mr_table.mtt_buddy, tmp___0);
#line 970
  if (err != 0) {
#line 971
    goto err_mtt_buddy;
  } else {

  }
#line 973
  dev->mr_table.tavor_fmr.mpt_base = 0;
#line 974
  dev->mr_table.tavor_fmr.mtt_base = 0;
#line 976
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 977
    i = fls(dev->limits.fmr_reserved_mtts + -1);
#line 979
    if (i > 30) {
#line 980
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Unable to reserve 2^31 FMR MTTs.\n");
#line 981
      err = -22;
#line 982
      goto err_fmr_mpt;
    } else {

    }
#line 984
    mtts = 1 << i;
#line 984
    mpts = mtts;
  } else {
#line 986
    mtts = dev->limits.num_mtt_segs;
#line 987
    mpts = dev->limits.num_mpts;
  }
#line 990
  tmp___3 = mthca_is_memfree(dev);
#line 990
  if (tmp___3 == 0 && (dev->mthca_flags & 32UL) != 0UL) {
#line 993
    if ((dev->pdev)->resource[4].start != 0ULL || (dev->pdev)->resource[4].end != (dev->pdev)->resource[4].start) {
#line 993
      tmp___1 = (dev->pdev)->resource[4].end - (dev->pdev)->resource[4].start;
    } else {
#line 993
      tmp___1 = 0xffffffffffffffffULL;
    }
#line 993
    addr = (dev->pdev)->resource[4].start + (tmp___1 & dev->mr_table.mpt_base);
#line 997
    dev->mr_table.tavor_fmr.mpt_base = ioremap(addr, (unsigned long )mpts * 64UL);
#line 1000
    if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base == (unsigned long )((void *)0)) {
#line 1001
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MPT ioremap for FMR failed.\n");
#line 1002
      err = -12;
#line 1003
      goto err_fmr_mpt;
    } else {

    }
#line 1006
    if ((dev->pdev)->resource[4].start != 0ULL || (dev->pdev)->resource[4].end != (dev->pdev)->resource[4].start) {
#line 1006
      tmp___2 = (dev->pdev)->resource[4].end - (dev->pdev)->resource[4].start;
    } else {
#line 1006
      tmp___2 = 0xffffffffffffffffULL;
    }
#line 1006
    addr = (dev->pdev)->resource[4].start + (tmp___2 & dev->mr_table.mtt_base);
#line 1010
    dev->mr_table.tavor_fmr.mtt_base = ioremap(addr, (unsigned long )(dev->limits.mtt_seg_size * mtts));
#line 1012
    if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base == (unsigned long )((void *)0)) {
#line 1013
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MTT ioremap for FMR failed.\n");
#line 1014
      err = -12;
#line 1015
      goto err_fmr_mtt;
    } else {

    }
  } else {

  }
#line 1019
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 1020
    tmp___4 = fls(mtts + -1);
#line 1020
    err = mthca_buddy_init(& dev->mr_table.tavor_fmr.mtt_buddy, tmp___4);
#line 1021
    if (err != 0) {
#line 1022
      goto err_fmr_mtt_buddy;
    } else {

    }
#line 1025
    tmp___5 = fls(mtts + -1);
#line 1025
    tmp___6 = mthca_buddy_alloc(& dev->mr_table.mtt_buddy, tmp___5);
#line 1025
    err = (int )tmp___6;
#line 1026
    if (err != 0) {
#line 1027
      goto err_reserve_fmr;
    } else {

    }
#line 1029
    dev->mr_table.fmr_mtt_buddy = & dev->mr_table.tavor_fmr.mtt_buddy;
  } else {
#line 1032
    dev->mr_table.fmr_mtt_buddy = & dev->mr_table.mtt_buddy;
  }
#line 1035
  if (dev->limits.reserved_mtts != 0) {
#line 1036
    i = fls(dev->limits.reserved_mtts + -1);
#line 1038
    tmp___7 = mthca_alloc_mtt_range(dev, i, dev->mr_table.fmr_mtt_buddy);
#line 1038
    if (tmp___7 == 4294967295U) {
#line 1040
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "MTT table of order %d is too small.\n",
               (dev->mr_table.fmr_mtt_buddy)->max_order);
#line 1042
      err = -12;
#line 1043
      goto err_reserve_mtts;
    } else {

    }
  } else {

  }
#line 1047
  return (0);
  err_reserve_mtts: ;
  err_reserve_fmr: ;
#line 1051
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 1052
    mthca_buddy_cleanup(& dev->mr_table.tavor_fmr.mtt_buddy);
  } else {

  }
  err_fmr_mtt_buddy: ;
#line 1055
  if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base != (unsigned long )((void *)0)) {
#line 1056
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mtt_base);
  } else {

  }
  err_fmr_mtt: ;
#line 1059
  if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base != (unsigned long )((void *)0)) {
#line 1060
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mpt_base);
  } else {

  }
  err_fmr_mpt: 
#line 1063
  mthca_buddy_cleanup(& dev->mr_table.mtt_buddy);
  err_mtt_buddy: 
#line 1066
  mthca_alloc_cleanup(& dev->mr_table.mpt_alloc);
#line 1068
  return (err);
}
}
#line 1071 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void mthca_cleanup_mr_table(struct mthca_dev *dev ) 
{ 

  {
#line 1074
  if (dev->limits.fmr_reserved_mtts != 0) {
#line 1075
    mthca_buddy_cleanup(& dev->mr_table.tavor_fmr.mtt_buddy);
  } else {

  }
#line 1077
  mthca_buddy_cleanup(& dev->mr_table.mtt_buddy);
#line 1079
  if ((unsigned long )dev->mr_table.tavor_fmr.mtt_base != (unsigned long )((void *)0)) {
#line 1080
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mtt_base);
  } else {

  }
#line 1081
  if ((unsigned long )dev->mr_table.tavor_fmr.mpt_base != (unsigned long )((void *)0)) {
#line 1082
    iounmap((void volatile   *)dev->mr_table.tavor_fmr.mpt_base);
  } else {

  }
#line 1084
  mthca_alloc_cleanup(& dev->mr_table.mpt_alloc);
#line 1085
  return;
}
}
#line 1087 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1092
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1094
  mutex_lock(ldv_func_arg1);
#line 1095
  return;
}
}
#line 1097 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1102
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1104
  mutex_unlock(ldv_func_arg1);
#line 1105
  return;
}
}
#line 1107 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1112
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1114
  mutex_lock(ldv_func_arg1);
#line 1115
  return;
}
}
#line 1117 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
int ldv_mutex_trylock_106(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1122
  tmp = mutex_trylock(ldv_func_arg1);
#line 1122
  ldv_func_res = tmp;
#line 1124
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1124
  return (tmp___0);
#line 1126
  return (ldv_func_res);
}
}
#line 1129 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mr.c.prepared"
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1134
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1136
  mutex_unlock(ldv_func_arg1);
#line 1137
  return;
}
}
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 93 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 105 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 

  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 109
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_113(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) ;
#line 111
void ldv_mutex_lock_mutex_of_mthca_qp(struct mutex *lock ) ;
#line 115
void ldv_mutex_unlock_mutex_of_mthca_qp(struct mutex *lock ) ;
#line 23 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_nested(raw_spinlock_t * , int  ) ;
#line 1307 "include/rdma/ib_verbs.h"
extern int ib_modify_qp_is_ok(enum ib_qp_state  , enum ib_qp_state  , enum ib_qp_type  ,
                              enum ib_qp_attr_mask  ) ;
#line 82 "include/rdma/ib_cache.h"
extern int ib_get_cached_pkey(struct ib_device * , u8  , int  , u16 * ) ;
#line 253 "include/rdma/ib_pack.h"
extern void ib_ud_header_init(int  , int  , int  , int  , int  , int  , struct ib_ud_header * ) ;
#line 261
extern int ib_ud_header_pack(struct ib_ud_header * , void * ) ;
#line 299 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_ucontext *to_mucontext(struct ib_ucontext *ibucontext ) 
{ struct ib_ucontext  const  *__mptr ;

  {
#line 301
  __mptr = (struct ib_ucontext  const  *)ibucontext;
#line 301
  return ((struct mthca_ucontext *)__mptr);
}
}
#line 314 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_pd *to_mpd(struct ib_pd *ibpd ) 
{ struct ib_pd  const  *__mptr ;

  {
#line 316
  __mptr = (struct ib_pd  const  *)ibpd;
#line 316
  return ((struct mthca_pd *)__mptr);
}
}
#line 319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_ah *to_mah(struct ib_ah *ibah ) 
{ struct ib_ah  const  *__mptr ;

  {
#line 321
  __mptr = (struct ib_ah  const  *)ibah;
#line 321
  return ((struct mthca_ah *)__mptr);
}
}
#line 334 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_qp *to_mqp(struct ib_qp *ibqp ) 
{ struct ib_qp  const  *__mptr ;

  {
#line 336
  __mptr = (struct ib_qp  const  *)ibqp;
#line 336
  return ((struct mthca_qp *)__mptr);
}
}
#line 339 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_sqp *to_msqp(struct mthca_qp *qp ) 
{ struct mthca_qp  const  *__mptr ;

  {
#line 341
  __mptr = (struct mthca_qp  const  *)qp;
#line 341
  return ((struct mthca_sqp *)__mptr);
}
}
#line 529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_query_qp(struct ib_qp *ibqp , struct ib_qp_attr *qp_attr , int qp_attr_mask ,
                   struct ib_qp_init_attr *qp_init_attr ) ;
#line 531
int mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr *attr , int attr_mask ,
                    struct ib_udata *udata ) ;
#line 533
int mthca_tavor_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) ;
#line 535
int mthca_tavor_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 537
int mthca_arbel_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) ;
#line 539
int mthca_arbel_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 543
int mthca_alloc_qp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                   struct mthca_cq *recv_cq , enum ib_qp_type type , enum ib_sig_type send_policy ,
                   struct ib_qp_cap *cap , struct mthca_qp *qp ) ;
#line 551
int mthca_alloc_sqp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                    struct mthca_cq *recv_cq , enum ib_sig_type send_policy , struct ib_qp_cap *cap ,
                    int qpn , int port , struct mthca_sqp *sqp ) ;
#line 560
void mthca_free_qp(struct mthca_dev *dev , struct mthca_qp *qp ) ;
#line 566
int mthca_read_ah(struct mthca_dev *dev , struct mthca_ah *ah , struct ib_ud_header *header ) ;
#line 569
int mthca_ah_grh_present(struct mthca_ah *ah ) ;
#line 570
u8 mthca_get_rate(struct mthca_dev *dev , int static_rate , u8 port ) ;
#line 571
enum ib_rate mthca_rate_to_ib(struct mthca_dev *dev , u8 mthca_rate , u8 port ) ;
#line 116 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
__inline static void mthca_set_data_seg(struct mthca_data_seg *dseg , struct ib_sge *sg ) 
{ __u32 tmp ;
  __u32 tmp___0 ;
  __u64 tmp___1 ;

  {
#line 119
  tmp = __fswab32(sg->length);
#line 119
  dseg->byte_count = tmp;
#line 120
  tmp___0 = __fswab32(sg->lkey);
#line 120
  dseg->lkey = tmp___0;
#line 121
  tmp___1 = __fswab64(sg->addr);
#line 121
  dseg->addr = tmp___1;
#line 122
  return;
}
}
#line 124 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_wqe.h"
__inline static void mthca_set_data_seg_inval(struct mthca_data_seg *dseg ) 
{ 

  {
#line 126
  dseg->byte_count = 0U;
#line 127
  dseg->lkey = 65536U;
#line 128
  dseg->addr = 0ULL;
#line 129
  return;
}
}
#line 305 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static u8 const   mthca_opcode[7U]  = {      8U,      9U,      10U,      11U, 
        16U,      17U,      18U};
#line 315 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int is_sqp(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 

  {
#line 317
  return (qp->qpn >= (u32 )dev->qp_table.sqp_start && qp->qpn <= (u32 )(dev->qp_table.sqp_start + 3));
}
}
#line 321 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int is_qp0(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 

  {
#line 323
  return (qp->qpn >= (u32 )dev->qp_table.sqp_start && qp->qpn <= (u32 )(dev->qp_table.sqp_start + 1));
}
}
#line 327 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void *get_recv_wqe(struct mthca_qp *qp , int n ) 
{ 

  {
#line 329
  if (qp->is_direct != 0) {
#line 330
    return (qp->queue.direct.buf + (unsigned long )(n << qp->rq.wqe_shift));
  } else {
#line 332
    return ((qp->queue.page_list + (unsigned long )((n << qp->rq.wqe_shift) >> 12))->buf + ((unsigned long )(n << qp->rq.wqe_shift) & 4095UL));
  }
}
}
#line 336 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void *get_send_wqe(struct mthca_qp *qp , int n ) 
{ 

  {
#line 338
  if (qp->is_direct != 0) {
#line 339
    return (qp->queue.direct.buf + ((unsigned long )qp->send_wqe_offset + (unsigned long )(n << qp->sq.wqe_shift)));
  } else {
#line 342
    return ((qp->queue.page_list + (unsigned long )((qp->send_wqe_offset + (n << qp->sq.wqe_shift)) >> 12))->buf + ((unsigned long )(qp->send_wqe_offset + (n << qp->sq.wqe_shift)) & 4095UL));
  }
}
}
#line 349 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_wq_reset(struct mthca_wq *wq ) 
{ 

  {
#line 351
  wq->next_ind = 0U;
#line 352
  wq->last_comp = (unsigned int )(wq->max + -1);
#line 353
  wq->head = 0U;
#line 354
  wq->tail = 0U;
#line 355
  return;
}
}
#line 357 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void mthca_qp_event(struct mthca_dev *dev , u32 qpn , enum ib_event_type event_type ) 
{ struct mthca_qp *qp ;
  struct ib_event event ;
  void *tmp ;

  {
#line 363
  spin_lock(& dev->qp_table.lock);
#line 364
  tmp = mthca_array_get(& dev->qp_table.qp, (int )((u32 )(dev->limits.num_qps + -1) & qpn));
#line 364
  qp = (struct mthca_qp *)tmp;
#line 365
  if ((unsigned long )qp != (unsigned long )((struct mthca_qp *)0)) {
#line 366
    qp->refcount = qp->refcount + 1;
  } else {

  }
#line 367
  spin_unlock(& dev->qp_table.lock);
#line 369
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 370
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event %d for bogus QP %08x\n",
             (unsigned int )event_type, qpn);
#line 372
    return;
  } else {

  }
#line 375
  if ((unsigned int )event_type == 6U) {
#line 376
    qp->port = qp->alt_port;
  } else {

  }
#line 378
  event.device = & dev->ib_dev;
#line 379
  event.event = event_type;
#line 380
  event.element.qp = & qp->ibqp;
#line 381
  if ((unsigned long )qp->ibqp.event_handler != (unsigned long )((void (*)(struct ib_event * ,
                                                                           void * ))0)) {
#line 382
    (*(qp->ibqp.event_handler))(& event, qp->ibqp.qp_context);
  } else {

  }
#line 384
  spin_lock(& dev->qp_table.lock);
#line 385
  qp->refcount = qp->refcount - 1;
#line 385
  if (qp->refcount == 0) {
#line 386
    __wake_up(& qp->wait, 3U, 1, 0);
  } else {

  }
#line 387
  spin_unlock(& dev->qp_table.lock);
#line 388
  return;
}
}
#line 390 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int to_mthca_state(enum ib_qp_state ib_state ) 
{ 

  {
#line 392
  switch ((unsigned int )ib_state) {
  case 0: ;
#line 393
  return (0);
  case 1: ;
#line 394
  return (1);
  case 2: ;
#line 395
  return (2);
  case 3: ;
#line 396
  return (3);
  case 4: ;
#line 397
  return (5);
  case 5: ;
#line 398
  return (4);
  case 6: ;
#line 399
  return (6);
  default: ;
#line 400
  return (-1);
  }
}
}
#line 406 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int to_mthca_st(int transport ) 
{ 

  {
#line 408
  switch (transport) {
  case 0: ;
#line 409
  return (0);
  case 1: ;
#line 410
  return (1);
  case 2: ;
#line 411
  return (3);
  case 3: ;
#line 412
  return (2);
  case 5: ;
#line 413
  return (7);
  default: ;
#line 414
  return (-1);
  }
}
}
#line 418 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void store_attrs(struct mthca_sqp *sqp , struct ib_qp_attr  const  *attr ,
                        int attr_mask ) 
{ 

  {
#line 421
  if ((attr_mask & 16) != 0) {
#line 422
    sqp->pkey_index = (int )attr->pkey_index;
  } else {

  }
#line 423
  if ((attr_mask & 64) != 0) {
#line 424
    sqp->qkey = attr->qkey;
  } else {

  }
#line 425
  if ((attr_mask & 65536) != 0) {
#line 426
    sqp->send_psn = attr->sq_psn;
  } else {

  }
#line 427
  return;
}
}
#line 429 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void init_port(struct mthca_dev *dev , int port ) 
{ int err ;
  struct mthca_init_ib_param param ;

  {
#line 434
  memset((void *)(& param), 0, 64UL);
#line 436
  param.port_width = (int )dev->limits.port_width_cap;
#line 437
  param.vl_cap = dev->limits.vl_cap;
#line 438
  param.mtu_cap = dev->limits.mtu_cap;
#line 439
  param.gid_cap = (u16 )dev->limits.gid_table_len;
#line 440
  param.pkey_cap = (u16 )dev->limits.pkey_table_len;
#line 442
  err = mthca_INIT_IB(dev, & param, port);
#line 443
  if (err != 0) {
#line 444
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "INIT_IB failed, return code %d.\n",
             err);
  } else {

  }
#line 445
  return;
}
}
#line 447 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static __be32 get_hw_access_flags(struct mthca_qp *qp , struct ib_qp_attr  const  *attr ,
                                  int attr_mask ) 
{ u8 dest_rd_atomic ;
  u32 access_flags ;
  u32 hw_access_flags ;
  __u32 tmp ;

  {
#line 452
  hw_access_flags = 0U;
#line 454
  if ((attr_mask & 131072) != 0) {
#line 455
    dest_rd_atomic = attr->max_dest_rd_atomic;
  } else {
#line 457
    dest_rd_atomic = qp->resp_depth;
  }
#line 459
  if ((attr_mask & 8) != 0) {
#line 460
    access_flags = (u32 )attr->qp_access_flags;
  } else {
#line 462
    access_flags = (u32 )qp->atomic_rd_en;
  }
#line 464
  if ((unsigned int )dest_rd_atomic == 0U) {
#line 465
    access_flags = access_flags & 2U;
  } else {

  }
#line 467
  if ((access_flags & 4U) != 0U) {
#line 468
    hw_access_flags = hw_access_flags | 32768U;
  } else {

  }
#line 469
  if ((access_flags & 8U) != 0U) {
#line 470
    hw_access_flags = hw_access_flags | 8192U;
  } else {

  }
#line 471
  if ((access_flags & 2U) != 0U) {
#line 472
    hw_access_flags = hw_access_flags | 16384U;
  } else {

  }
#line 474
  tmp = __fswab32(hw_access_flags);
#line 474
  return (tmp);
}
}
#line 477 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static enum ib_qp_state to_ib_qp_state(int mthca_state ) 
{ 

  {
#line 479
  switch (mthca_state) {
  case 0: ;
#line 480
  return (0);
  case 1: ;
#line 481
  return (1);
  case 2: ;
#line 482
  return (2);
  case 3: ;
#line 483
  return (3);
  case 7: ;
  case 5: ;
#line 485
  return (4);
  case 4: ;
#line 486
  return (5);
  case 6: ;
#line 487
  return (6);
  default: ;
#line 488
  return (4294967295L);
  }
}
}
#line 492 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static enum ib_mig_state to_ib_mig_state(int mthca_mig_state ) 
{ 

  {
#line 494
  switch (mthca_mig_state) {
  case 0: ;
#line 495
  return (2);
  case 1: ;
#line 496
  return (1);
  case 3: ;
#line 497
  return (0);
  default: ;
#line 498
  return (4294967295L);
  }
}
}
#line 502 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int to_ib_qp_access_flags(int mthca_flags ) 
{ int ib_flags ;

  {
#line 504
  ib_flags = 0;
#line 506
  if ((mthca_flags & 32768) != 0) {
#line 507
    ib_flags = ib_flags | 4;
  } else {

  }
#line 508
  if ((mthca_flags & 16384) != 0) {
#line 509
    ib_flags = ib_flags | 2;
  } else {

  }
#line 510
  if ((mthca_flags & 8192) != 0) {
#line 511
    ib_flags = ib_flags | 8;
  } else {

  }
#line 513
  return (ib_flags);
}
}
#line 516 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void to_ib_ah_attr(struct mthca_dev *dev , struct ib_ah_attr *ib_ah_attr ,
                          struct mthca_qp_path *path ) 
{ __u32 tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  enum ib_rate tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 519
  memset((void *)ib_ah_attr, 0, 32UL);
#line 520
  tmp = __fswab32(path->port_pkey);
#line 520
  ib_ah_attr->port_num = (unsigned int )((u8 )(tmp >> 24)) & 3U;
#line 522
  if ((unsigned int )ib_ah_attr->port_num == 0U || (int )ib_ah_attr->port_num > dev->limits.num_ports) {
#line 523
    return;
  } else {

  }
#line 525
  tmp___0 = __fswab16((int )path->rlid);
#line 525
  ib_ah_attr->dlid = tmp___0;
#line 526
  tmp___1 = __fswab32(path->sl_tclass_flowlabel);
#line 526
  ib_ah_attr->sl = (u8 )(tmp___1 >> 28);
#line 527
  ib_ah_attr->src_path_bits = (unsigned int )path->g_mylmc & 127U;
#line 528
  tmp___2 = mthca_rate_to_ib(dev, (int )path->static_rate & 15, (int )ib_ah_attr->port_num);
#line 528
  ib_ah_attr->static_rate = (u8 )tmp___2;
#line 531
  ib_ah_attr->ah_flags = (int )((signed char )path->g_mylmc) < 0;
#line 532
  if ((unsigned int )ib_ah_attr->ah_flags != 0U) {
#line 533
    ib_ah_attr->grh.sgid_index = (u8 )((int )((signed char )path->mgid_index) & (int )((signed char )((unsigned int )((unsigned char )dev->limits.gid_table_len) + 255U)));
#line 534
    ib_ah_attr->grh.hop_limit = path->hop_limit;
#line 535
    tmp___3 = __fswab32(path->sl_tclass_flowlabel);
#line 535
    ib_ah_attr->grh.traffic_class = (u8 )(tmp___3 >> 20);
#line 537
    tmp___4 = __fswab32(path->sl_tclass_flowlabel);
#line 537
    ib_ah_attr->grh.flow_label = tmp___4 & 1048575U;
#line 539
    __len = 16UL;
#line 539
    if (__len > 63UL) {
#line 539
      __ret = __memcpy((void *)(& ib_ah_attr->grh.dgid.raw), (void const   *)(& path->rgid),
                       __len);
    } else {
#line 539
      __ret = __builtin_memcpy((void *)(& ib_ah_attr->grh.dgid.raw), (void const   *)(& path->rgid),
                               __len);
    }
  } else {

  }
#line 542
  return;
}
}
#line 544 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_query_qp(struct ib_qp *ibqp , struct ib_qp_attr *qp_attr , int qp_attr_mask ,
                   struct ib_qp_init_attr *qp_init_attr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  int err ;
  struct mthca_mailbox *mailbox ;
  struct mthca_qp_param *qp_param ;
  struct mthca_qp_context *context ;
  int mthca_state ;
  long tmp___1 ;
  long tmp___2 ;
  __u32 tmp___3 ;
  enum ib_qp_state tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  __u32 tmp___17 ;

  {
#line 547
  tmp = to_mdev(ibqp->device);
#line 547
  dev = tmp;
#line 548
  tmp___0 = to_mqp(ibqp);
#line 548
  qp = tmp___0;
#line 549
  err = 0;
#line 550
  mailbox = 0;
#line 555
  ldv_mutex_lock_120(& qp->mutex);
#line 557
  if ((unsigned int )qp->state == 0U) {
#line 558
    qp_attr->qp_state = 0;
#line 559
    goto done;
  } else {

  }
#line 562
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 563
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 563
  if (tmp___2 != 0L) {
#line 564
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 564
    err = (int )tmp___1;
#line 565
    goto out;
  } else {

  }
#line 568
  err = mthca_QUERY_QP(dev, qp->qpn, 0, mailbox);
#line 569
  if (err != 0) {
#line 570
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "QUERY_QP failed (%d)\n",
             err);
#line 571
    goto out_mailbox;
  } else {

  }
#line 574
  qp_param = (struct mthca_qp_param *)mailbox->buf;
#line 575
  context = & qp_param->context;
#line 576
  tmp___3 = __fswab32(context->flags);
#line 576
  mthca_state = (int )(tmp___3 >> 28);
#line 578
  tmp___4 = to_ib_qp_state(mthca_state);
#line 578
  qp->state = (u8 )tmp___4;
#line 579
  qp_attr->qp_state = (enum ib_qp_state )qp->state;
#line 580
  qp_attr->path_mtu = (enum ib_mtu )((int )context->mtu_msgmax >> 5);
#line 581
  tmp___5 = __fswab32(context->flags);
#line 581
  qp_attr->path_mig_state = to_ib_mig_state((int )(tmp___5 >> 11) & 3);
#line 583
  tmp___6 = __fswab32(context->qkey);
#line 583
  qp_attr->qkey = tmp___6;
#line 584
  tmp___7 = __fswab32(context->rnr_nextrecvpsn);
#line 584
  qp_attr->rq_psn = tmp___7 & 16777215U;
#line 585
  tmp___8 = __fswab32(context->next_send_psn);
#line 585
  qp_attr->sq_psn = tmp___8 & 16777215U;
#line 586
  tmp___9 = __fswab32(context->remote_qpn);
#line 586
  qp_attr->dest_qp_num = tmp___9 & 16777215U;
#line 587
  tmp___10 = __fswab32(context->params2);
#line 587
  qp_attr->qp_access_flags = to_ib_qp_access_flags((int )tmp___10);
#line 590
  if ((unsigned int )qp->transport == 0U || (unsigned int )qp->transport == 1U) {
#line 591
    to_ib_ah_attr(dev, & qp_attr->ah_attr, & context->pri_path);
#line 592
    to_ib_ah_attr(dev, & qp_attr->alt_ah_attr, & context->alt_path);
#line 593
    tmp___11 = __fswab32(context->alt_path.port_pkey);
#line 593
    qp_attr->alt_pkey_index = (unsigned int )((u16 )tmp___11) & 127U;
#line 595
    qp_attr->alt_port_num = qp_attr->alt_ah_attr.port_num;
  } else {

  }
#line 598
  tmp___12 = __fswab32(context->pri_path.port_pkey);
#line 598
  qp_attr->pkey_index = (unsigned int )((u16 )tmp___12) & 127U;
#line 599
  tmp___13 = __fswab32(context->pri_path.port_pkey);
#line 599
  qp_attr->port_num = (unsigned int )((u8 )(tmp___13 >> 24)) & 3U;
#line 603
  qp_attr->sq_draining = mthca_state == 7;
#line 605
  tmp___14 = __fswab32(context->params1);
#line 605
  qp_attr->max_rd_atomic = (u8 )(1 << ((int )(tmp___14 >> 21) & 7));
#line 607
  tmp___15 = __fswab32(context->params2);
#line 607
  qp_attr->max_dest_rd_atomic = (u8 )(1 << ((int )(tmp___15 >> 21) & 7));
#line 609
  tmp___16 = __fswab32(context->rnr_nextrecvpsn);
#line 609
  qp_attr->min_rnr_timer = (unsigned int )((u8 )(tmp___16 >> 24)) & 31U;
#line 611
  qp_attr->timeout = (u8 )((int )context->pri_path.ackto >> 3);
#line 612
  tmp___17 = __fswab32(context->params1);
#line 612
  qp_attr->retry_cnt = (unsigned int )((u8 )(tmp___17 >> 16)) & 7U;
#line 613
  qp_attr->rnr_retry = (u8 )((int )context->pri_path.rnr_retry >> 5);
#line 614
  qp_attr->alt_timeout = (u8 )((int )context->alt_path.ackto >> 3);
  done: 
#line 617
  qp_attr->cur_qp_state = qp_attr->qp_state;
#line 618
  qp_attr->cap.max_send_wr = (u32 )qp->sq.max;
#line 619
  qp_attr->cap.max_recv_wr = (u32 )qp->rq.max;
#line 620
  qp_attr->cap.max_send_sge = (u32 )qp->sq.max_gs;
#line 621
  qp_attr->cap.max_recv_sge = (u32 )qp->rq.max_gs;
#line 622
  qp_attr->cap.max_inline_data = (u32 )qp->max_inline_data;
#line 624
  qp_init_attr->cap = qp_attr->cap;
#line 625
  qp_init_attr->sq_sig_type = qp->sq_policy;
  out_mailbox: 
#line 628
  mthca_free_mailbox(dev, mailbox);
  out: 
#line 631
  ldv_mutex_unlock_121(& qp->mutex);
#line 632
  return (err);
}
}
#line 635 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_path_set(struct mthca_dev *dev , struct ib_ah_attr  const  *ah ,
                          struct mthca_qp_path *path , u8 port ) 
{ __u16 tmp ;
  __u32 tmp___0 ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___1 ;

  {
#line 638
  path->g_mylmc = (unsigned int )((u8 )ah->src_path_bits) & 127U;
#line 639
  tmp = __fswab16((int )ah->dlid);
#line 639
  path->rlid = tmp;
#line 640
  path->static_rate = mthca_get_rate(dev, (int )ah->static_rate, (int )port);
#line 642
  if ((int )ah->ah_flags & 1) {
#line 643
    if ((int )ah->grh.sgid_index >= dev->limits.gid_table_len) {
#line 644
      if (mthca_debug_level != 0) {
#line 644
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "sgid_index (%u) too large. max is %d\n",
                   (int )ah->grh.sgid_index, dev->limits.gid_table_len + -1);
      } else {

      }
#line 646
      return (-1);
    } else {

    }
#line 649
    path->g_mylmc = (u8 )((unsigned int )path->g_mylmc | 128U);
#line 650
    path->mgid_index = ah->grh.sgid_index;
#line 651
    path->hop_limit = ah->grh.hop_limit;
#line 652
    tmp___0 = __fswab32((unsigned int )(((int )ah->sl << 28) | ((int )ah->grh.traffic_class << 20)) | (unsigned int )ah->grh.flow_label);
#line 652
    path->sl_tclass_flowlabel = tmp___0;
#line 656
    __len = 16UL;
#line 656
    if (__len > 63UL) {
#line 656
      __ret = __memcpy((void *)(& path->rgid), (void const   *)(& ah->grh.dgid.raw),
                       __len);
    } else {
#line 656
      __ret = __builtin_memcpy((void *)(& path->rgid), (void const   *)(& ah->grh.dgid.raw),
                               __len);
    }
  } else {
#line 658
    tmp___1 = __fswab32((__u32 )((int )ah->sl << 28));
#line 658
    path->sl_tclass_flowlabel = tmp___1;
  }
#line 660
  return (0);
}
}
#line 663 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int __mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr  const  *attr ,
                             int attr_mask , enum ib_qp_state cur_state , enum ib_qp_state new_state ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  struct mthca_mailbox *mailbox ;
  struct mthca_qp_param *qp_param ;
  struct mthca_qp_context *qp_context ;
  u32 sqd_event ;
  int err ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __u32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct mthca_ucontext *tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  u8 tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u8 sched_queue ;
  unsigned int tmp___20 ;
  __u32 tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  __u32 tmp___24 ;
  struct mthca_pd *tmp___25 ;
  __u32 tmp___26 ;
  __u32 tmp___27 ;
  __u32 tmp___28 ;
  int tmp___29 ;
  __u32 tmp___30 ;
  __u32 tmp___31 ;
  struct mthca_cq *tmp___32 ;
  __u32 tmp___33 ;
  __u32 tmp___34 ;
  __u32 tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  __u32 tmp___38 ;
  __be32 tmp___39 ;
  __u32 tmp___40 ;
  __u32 tmp___41 ;
  __u32 tmp___42 ;
  struct mthca_cq *tmp___43 ;
  __u32 tmp___44 ;
  __u32 tmp___45 ;
  int tmp___46 ;
  __u32 tmp___47 ;
  struct mthca_srq *tmp___48 ;
  __u32 tmp___49 ;
  struct mthca_sqp *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  struct mthca_srq *tmp___53 ;
  struct mthca_srq *tmp___54 ;
  struct mthca_cq *tmp___55 ;
  struct mthca_cq *tmp___56 ;
  int tmp___57 ;

  {
#line 667
  tmp = to_mdev(ibqp->device);
#line 667
  dev = tmp;
#line 668
  tmp___0 = to_mqp(ibqp);
#line 668
  qp = tmp___0;
#line 672
  sqd_event = 0U;
#line 673
  err = -22;
#line 675
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 676
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 676
  if (tmp___2 != 0L) {
#line 677
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 677
    err = (int )tmp___1;
#line 678
    goto out;
  } else {

  }
#line 680
  qp_param = (struct mthca_qp_param *)mailbox->buf;
#line 681
  qp_context = & qp_param->context;
#line 682
  memset((void *)qp_param, 0, 512UL);
#line 684
  tmp___3 = to_mthca_state(new_state);
#line 684
  tmp___4 = to_mthca_st((int )qp->transport);
#line 684
  tmp___5 = __fswab32((__u32 )((tmp___3 << 28) | (tmp___4 << 16)));
#line 684
  qp_context->flags = tmp___5;
#line 686
  qp_context->flags = qp_context->flags | 65536U;
#line 687
  if ((attr_mask & 262144) == 0) {
#line 688
    qp_context->flags = qp_context->flags | 1572864U;
  } else {
#line 690
    qp_param->opt_param_mask = qp_param->opt_param_mask | 262144U;
#line 691
    switch ((unsigned int )attr->path_mig_state) {
    case 0: 
#line 693
    qp_context->flags = qp_context->flags | 1572864U;
#line 694
    goto ldv_26750;
    case 1: 
#line 696
    qp_context->flags = qp_context->flags | 524288U;
#line 697
    goto ldv_26750;
    case 2: 
#line 699
    qp_context->flags = qp_context->flags;
#line 700
    goto ldv_26750;
    }
    ldv_26750: ;
  }
#line 706
  if ((unsigned int )qp->transport == 5U || (unsigned int )qp->transport == 2U) {
#line 707
    qp_context->mtu_msgmax = 139U;
  } else
#line 708
  if ((attr_mask & 256) != 0) {
#line 709
    if ((unsigned int )attr->path_mtu == 0U || (unsigned int )attr->path_mtu > 4U) {
#line 710
      if (mthca_debug_level != 0) {
#line 710
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "path MTU (%u) is invalid\n",
                   (unsigned int )attr->path_mtu);
      } else {

      }
#line 712
      goto out_mailbox;
    } else {

    }
#line 714
    qp_context->mtu_msgmax = (unsigned int )((int )((u8 )attr->path_mtu) << 5U) | 31U;
  } else {

  }
#line 717
  tmp___8 = mthca_is_memfree(dev);
#line 717
  if (tmp___8 != 0) {
#line 718
    if (qp->rq.max != 0) {
#line 719
      tmp___6 = __ilog2_u32((u32 )qp->rq.max);
#line 719
      qp_context->rq_size_stride = (int )((u8 )tmp___6) << 3U;
    } else {

    }
#line 720
    qp_context->rq_size_stride = (u8 )((int )((signed char )qp_context->rq_size_stride) | (int )((signed char )((unsigned int )((unsigned char )qp->rq.wqe_shift) + 252U)));
#line 722
    if (qp->sq.max != 0) {
#line 723
      tmp___7 = __ilog2_u32((u32 )qp->sq.max);
#line 723
      qp_context->sq_size_stride = (int )((u8 )tmp___7) << 3U;
    } else {

    }
#line 724
    qp_context->sq_size_stride = (u8 )((int )((signed char )qp_context->sq_size_stride) | (int )((signed char )((unsigned int )((unsigned char )qp->sq.wqe_shift) + 252U)));
  } else {

  }
#line 729
  if ((unsigned long )qp->ibqp.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 730
    tmp___9 = to_mucontext((qp->ibqp.uobject)->context);
#line 730
    tmp___10 = __fswab32((__u32 )tmp___9->uar.index);
#line 730
    qp_context->usr_page = tmp___10;
  } else {
#line 733
    tmp___11 = __fswab32((__u32 )dev->driver_uar.index);
#line 733
    qp_context->usr_page = tmp___11;
  }
#line 734
  tmp___12 = __fswab32(qp->qpn);
#line 734
  qp_context->local_qpn = tmp___12;
#line 735
  if ((attr_mask & 1048576) != 0) {
#line 736
    tmp___13 = __fswab32(attr->dest_qp_num);
#line 736
    qp_context->remote_qpn = tmp___13;
  } else {

  }
#line 739
  if ((unsigned int )qp->transport == 5U) {
#line 740
    tmp___14 = __fswab32((__u32 )((int )qp->port << 24));
#line 740
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___14;
  } else
#line 743
  if ((attr_mask & 32) != 0) {
#line 744
    tmp___15 = __fswab32((__u32 )((int )attr->port_num << 24));
#line 744
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___15;
#line 746
    qp_param->opt_param_mask = qp_param->opt_param_mask | 524288U;
  } else {

  }
#line 750
  if ((attr_mask & 16) != 0) {
#line 751
    tmp___16 = __fswab32((__u32 )attr->pkey_index);
#line 751
    qp_context->pri_path.port_pkey = qp_context->pri_path.port_pkey | tmp___16;
#line 753
    qp_param->opt_param_mask = qp_param->opt_param_mask | 268435456U;
  } else {

  }
#line 756
  if ((attr_mask & 2048) != 0) {
#line 757
    tmp___17 = (int )((u8 )attr->rnr_retry) << 5U;
#line 757
    qp_context->pri_path.rnr_retry = tmp___17;
#line 757
    qp_context->alt_path.rnr_retry = tmp___17;
#line 759
    qp_param->opt_param_mask = qp_param->opt_param_mask | 10485760U;
  } else {

  }
#line 763
  if ((attr_mask & 128) != 0) {
#line 764
    if ((attr_mask & 32) != 0) {
#line 764
      tmp___18 = (int )attr->port_num;
    } else {
#line 764
      tmp___18 = (int )qp->port;
    }
#line 764
    tmp___19 = mthca_path_set(dev, & attr->ah_attr, & qp_context->pri_path, tmp___18);
#line 764
    if (tmp___19 != 0) {
#line 766
      goto out_mailbox;
    } else {

    }
#line 768
    qp_param->opt_param_mask = qp_param->opt_param_mask | 2147483648U;
  } else {

  }
#line 771
  if (((unsigned int )ibqp->qp_type == 2U && (unsigned int )cur_state == 1U) && (unsigned int )new_state == 2U) {
#line 773
    if ((unsigned long )ibqp->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 773
      tmp___20 = 2U;
    } else {
#line 773
      tmp___20 = 1U;
    }
#line 773
    sched_queue = tmp___20;
#line 775
    tmp___22 = mthca_is_memfree(dev);
#line 775
    if (tmp___22 != 0) {
#line 776
      qp_context->rlkey_arbel_sched_queue = (u8 )((int )qp_context->rlkey_arbel_sched_queue | (int )sched_queue);
    } else {
#line 778
      tmp___21 = __fswab32((__u32 )sched_queue);
#line 778
      qp_context->tavor_sched_queue = qp_context->tavor_sched_queue | tmp___21;
    }
#line 780
    qp_param->opt_param_mask = qp_param->opt_param_mask | 256U;
  } else {

  }
#line 784
  if ((attr_mask & 512) != 0) {
#line 785
    qp_context->pri_path.ackto = (int )((u8 )attr->timeout) << 3U;
#line 786
    qp_param->opt_param_mask = qp_param->opt_param_mask | 4194304U;
  } else {

  }
#line 789
  if ((attr_mask & 16384) != 0) {
#line 790
    if ((int )attr->alt_pkey_index >= dev->limits.pkey_table_len) {
#line 791
      if (mthca_debug_level != 0) {
#line 791
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Alternate P_Key index (%u) too large. max is %d\n",
                   (int )attr->alt_pkey_index, dev->limits.pkey_table_len + -1);
      } else {

      }
#line 793
      goto out_mailbox;
    } else {

    }
#line 796
    if ((unsigned int )((unsigned char )attr->alt_port_num) == 0U || (int )attr->alt_port_num > dev->limits.num_ports) {
#line 797
      if (mthca_debug_level != 0) {
#line 797
        dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Alternate port number (%u) is invalid\n",
                   (int )attr->alt_port_num);
      } else {

      }
#line 799
      goto out_mailbox;
    } else {

    }
#line 802
    tmp___23 = mthca_path_set(dev, & attr->alt_ah_attr, & qp_context->alt_path, (int )attr->alt_ah_attr.port_num);
#line 802
    if (tmp___23 != 0) {
#line 804
      goto out_mailbox;
    } else {

    }
#line 806
    tmp___24 = __fswab32((__u32 )((int )attr->alt_pkey_index | ((int )attr->alt_port_num << 24)));
#line 806
    qp_context->alt_path.port_pkey = qp_context->alt_path.port_pkey | tmp___24;
#line 808
    qp_context->alt_path.ackto = (int )((u8 )attr->alt_timeout) << 3U;
#line 809
    qp_param->opt_param_mask = qp_param->opt_param_mask | 16777216U;
  } else {

  }
#line 813
  tmp___25 = to_mpd(ibqp->pd);
#line 813
  tmp___26 = __fswab32(tmp___25->pd_num);
#line 813
  qp_context->pd = tmp___26;
#line 815
  tmp___27 = __fswab32(qp->mr.ibmr.lkey);
#line 815
  qp_context->wqe_lkey = tmp___27;
#line 816
  qp_context->params1 = 4194473U;
#line 819
  if ((unsigned int )qp->sq_policy == 0U) {
#line 820
    qp_context->params1 = qp_context->params1 | 134217728U;
  } else {

  }
#line 821
  if ((attr_mask & 1024) != 0) {
#line 822
    tmp___28 = __fswab32((__u32 )((int )attr->retry_cnt << 16));
#line 822
    qp_context->params1 = qp_context->params1 | tmp___28;
#line 823
    qp_param->opt_param_mask = qp_param->opt_param_mask | 1048576U;
  } else {

  }
#line 826
  if ((attr_mask & 8192) != 0) {
#line 827
    if ((unsigned int )((unsigned char )attr->max_rd_atomic) != 0U) {
#line 828
      qp_context->params1 = qp_context->params1 | 10485760U;
#line 831
      tmp___29 = fls((int )attr->max_rd_atomic + -1);
#line 831
      tmp___30 = __fswab32((__u32 )(tmp___29 << 21));
#line 831
      qp_context->params1 = qp_context->params1 | tmp___30;
    } else {

    }
#line 834
    qp_param->opt_param_mask = qp_param->opt_param_mask | 65536U;
  } else {

  }
#line 837
  if ((attr_mask & 65536) != 0) {
#line 838
    tmp___31 = __fswab32(attr->sq_psn);
#line 838
    qp_context->next_send_psn = tmp___31;
  } else {

  }
#line 839
  tmp___32 = to_mcq(ibqp->send_cq);
#line 839
  tmp___33 = __fswab32((__u32 )tmp___32->cqn);
#line 839
  qp_context->cqn_snd = tmp___33;
#line 841
  tmp___36 = mthca_is_memfree(dev);
#line 841
  if (tmp___36 != 0) {
#line 842
    tmp___34 = __fswab32((__u32 )qp->send_wqe_offset);
#line 842
    qp_context->snd_wqe_base_l = tmp___34;
#line 843
    tmp___35 = __fswab32((__u32 )qp->sq.db_index);
#line 843
    qp_context->snd_db_index = tmp___35;
  } else {

  }
#line 846
  if ((attr_mask & 131072) != 0) {
#line 847
    if ((unsigned int )((unsigned char )attr->max_dest_rd_atomic) != 0U) {
#line 848
      tmp___37 = fls((int )attr->max_dest_rd_atomic + -1);
#line 848
      tmp___38 = __fswab32((__u32 )(tmp___37 << 21));
#line 848
      qp_context->params2 = qp_context->params2 | tmp___38;
    } else {

    }
#line 851
    qp_param->opt_param_mask = qp_param->opt_param_mask | 131072U;
  } else {

  }
#line 854
  if ((attr_mask & 131080) != 0) {
#line 855
    tmp___39 = get_hw_access_flags(qp, attr, attr_mask);
#line 855
    qp_context->params2 = qp_context->params2 | tmp___39;
#line 856
    qp_param->opt_param_mask = qp_param->opt_param_mask | 234881024U;
  } else {

  }
#line 861
  qp_context->params2 = qp_context->params2 | 134217728U;
#line 863
  if ((unsigned long )ibqp->srq != (unsigned long )((struct ib_srq *)0)) {
#line 864
    qp_context->params2 = qp_context->params2 | 268435456U;
  } else {

  }
#line 866
  if ((attr_mask & 32768) != 0) {
#line 867
    tmp___40 = __fswab32((__u32 )((int )attr->min_rnr_timer << 24));
#line 867
    qp_context->rnr_nextrecvpsn = qp_context->rnr_nextrecvpsn | tmp___40;
#line 868
    qp_param->opt_param_mask = qp_param->opt_param_mask | 1073741824U;
  } else {

  }
#line 870
  if ((attr_mask & 4096) != 0) {
#line 871
    tmp___41 = __fswab32(attr->rq_psn);
#line 871
    qp_context->rnr_nextrecvpsn = qp_context->rnr_nextrecvpsn | tmp___41;
  } else {

  }
#line 873
  tmp___42 = __fswab32(dev->qp_table.rdb_base + ((qp->qpn & (u32 )(dev->limits.num_qps + -1)) * 32U << dev->qp_table.rdb_shift));
#line 873
  qp_context->ra_buff_indx = tmp___42;
#line 878
  tmp___43 = to_mcq(ibqp->recv_cq);
#line 878
  tmp___44 = __fswab32((__u32 )tmp___43->cqn);
#line 878
  qp_context->cqn_rcv = tmp___44;
#line 880
  tmp___46 = mthca_is_memfree(dev);
#line 880
  if (tmp___46 != 0) {
#line 881
    tmp___45 = __fswab32((__u32 )qp->rq.db_index);
#line 881
    qp_context->rcv_db_index = tmp___45;
  } else {

  }
#line 883
  if ((attr_mask & 64) != 0) {
#line 884
    tmp___47 = __fswab32(attr->qkey);
#line 884
    qp_context->qkey = tmp___47;
#line 885
    qp_param->opt_param_mask = qp_param->opt_param_mask | 536870912U;
  } else {

  }
#line 888
  if ((unsigned long )ibqp->srq != (unsigned long )((struct ib_srq *)0)) {
#line 889
    tmp___48 = to_msrq(ibqp->srq);
#line 889
    tmp___49 = __fswab32((__u32 )(tmp___48->srqn | 16777216));
#line 889
    qp_context->srqn = tmp___49;
  } else {

  }
#line 892
  if ((((unsigned int )cur_state == 3U && (unsigned int )new_state == 4U) && (attr_mask & 4) != 0) && (unsigned int )((unsigned char )attr->en_sqd_async_notify) != 0U) {
#line 895
    sqd_event = 2147483648U;
  } else {

  }
#line 897
  err = mthca_MODIFY_QP(dev, cur_state, new_state, qp->qpn, 0, mailbox, sqd_event);
#line 899
  if (err != 0) {
#line 900
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "modify QP %d->%d returned %d.\n",
             (unsigned int )cur_state, (unsigned int )new_state, err);
#line 902
    goto out_mailbox;
  } else {

  }
#line 905
  qp->state = (u8 )new_state;
#line 906
  if ((attr_mask & 8) != 0) {
#line 907
    qp->atomic_rd_en = (u8 )attr->qp_access_flags;
  } else {

  }
#line 908
  if ((attr_mask & 131072) != 0) {
#line 909
    qp->resp_depth = attr->max_dest_rd_atomic;
  } else {

  }
#line 910
  if ((attr_mask & 32) != 0) {
#line 911
    qp->port = attr->port_num;
  } else {

  }
#line 912
  if ((attr_mask & 16384) != 0) {
#line 913
    qp->alt_port = attr->alt_port_num;
  } else {

  }
#line 915
  tmp___51 = is_sqp(dev, qp);
#line 915
  if (tmp___51 != 0) {
#line 916
    tmp___50 = to_msqp(qp);
#line 916
    store_attrs(tmp___50, attr, attr_mask);
  } else {

  }
#line 922
  tmp___52 = is_qp0(dev, qp);
#line 922
  if (tmp___52 != 0) {
#line 923
    if ((unsigned int )cur_state != 2U && (unsigned int )new_state == 2U) {
#line 925
      init_port(dev, (int )qp->port);
    } else {

    }
#line 927
    if (((unsigned int )cur_state != 0U && (unsigned int )cur_state != 6U) && ((unsigned int )new_state == 0U || (unsigned int )new_state == 6U)) {
#line 931
      mthca_CLOSE_IB(dev, (int )qp->port);
    } else {

    }
  } else {

  }
#line 938
  if ((unsigned int )new_state == 0U && (unsigned long )qp->ibqp.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 939
    if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 939
      tmp___53 = to_msrq(qp->ibqp.srq);
#line 939
      tmp___54 = tmp___53;
    } else {
#line 939
      tmp___54 = 0;
    }
#line 939
    tmp___55 = to_mcq(qp->ibqp.recv_cq);
#line 939
    mthca_cq_clean(dev, tmp___55, qp->qpn, tmp___54);
#line 941
    if ((unsigned long )qp->ibqp.send_cq != (unsigned long )qp->ibqp.recv_cq) {
#line 942
      tmp___56 = to_mcq(qp->ibqp.send_cq);
#line 942
      mthca_cq_clean(dev, tmp___56, qp->qpn, 0);
    } else {

    }
#line 944
    mthca_wq_reset(& qp->sq);
#line 945
    qp->sq.last = get_send_wqe(qp, qp->sq.max + -1);
#line 947
    mthca_wq_reset(& qp->rq);
#line 948
    qp->rq.last = get_recv_wqe(qp, qp->rq.max + -1);
#line 950
    tmp___57 = mthca_is_memfree(dev);
#line 950
    if (tmp___57 != 0) {
#line 951
      *(qp->sq.db) = 0U;
#line 952
      *(qp->rq.db) = 0U;
    } else {

    }
  } else {

  }
  out_mailbox: 
#line 957
  mthca_free_mailbox(dev, mailbox);
  out: ;
#line 959
  return (err);
}
}
#line 962 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_modify_qp(struct ib_qp *ibqp , struct ib_qp_attr *attr , int attr_mask ,
                    struct ib_udata *udata ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  enum ib_qp_state cur_state ;
  enum ib_qp_state new_state ;
  int err ;
  int tmp___1 ;

  {
#line 965
  tmp = to_mdev(ibqp->device);
#line 965
  dev = tmp;
#line 966
  tmp___0 = to_mqp(ibqp);
#line 966
  qp = tmp___0;
#line 968
  err = -22;
#line 970
  ldv_mutex_lock_122(& qp->mutex);
#line 971
  if ((attr_mask & 2) != 0) {
#line 972
    cur_state = attr->cur_qp_state;
  } else {
#line 974
    spin_lock_irq(& qp->sq.lock);
#line 975
    spin_lock(& qp->rq.lock);
#line 976
    cur_state = (enum ib_qp_state )qp->state;
#line 977
    spin_unlock(& qp->rq.lock);
#line 978
    spin_unlock_irq(& qp->sq.lock);
  }
#line 981
  if (attr_mask & 1) {
#line 981
    new_state = attr->qp_state;
  } else {
#line 981
    new_state = cur_state;
  }
#line 983
  tmp___1 = ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, (enum ib_qp_attr_mask )attr_mask);
#line 983
  if (tmp___1 == 0) {
#line 984
    if (mthca_debug_level != 0) {
#line 984
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Bad QP transition (transport %d) %d->%d with attr 0x%08x\n",
                 (int )qp->transport, (unsigned int )cur_state, (unsigned int )new_state,
                 attr_mask);
    } else {

    }
#line 988
    goto out;
  } else {

  }
#line 991
  if ((attr_mask & 16) != 0 && (int )attr->pkey_index >= dev->limits.pkey_table_len) {
#line 993
    if (mthca_debug_level != 0) {
#line 993
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "P_Key index (%u) too large. max is %d\n",
                 (int )attr->pkey_index, dev->limits.pkey_table_len + -1);
    } else {

    }
#line 995
    goto out;
  } else {

  }
#line 998
  if ((attr_mask & 32) != 0 && ((unsigned int )attr->port_num == 0U || (int )attr->port_num > dev->limits.num_ports)) {
#line 1000
    if (mthca_debug_level != 0) {
#line 1000
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Port number (%u) is invalid\n",
                 (int )attr->port_num);
    } else {

    }
#line 1001
    goto out;
  } else {

  }
#line 1004
  if ((attr_mask & 8192) != 0 && (int )attr->max_rd_atomic > dev->limits.max_qp_init_rdma) {
#line 1006
    if (mthca_debug_level != 0) {
#line 1006
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max rdma_atomic as initiator %u too large (max is %d)\n",
                 (int )attr->max_rd_atomic, dev->limits.max_qp_init_rdma);
    } else {

    }
#line 1008
    goto out;
  } else {

  }
#line 1011
  if ((attr_mask & 131072) != 0 && (int )attr->max_dest_rd_atomic > 1 << dev->qp_table.rdb_shift) {
#line 1013
    if (mthca_debug_level != 0) {
#line 1013
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Max rdma_atomic as responder %u too large (max %d)\n",
                 (int )attr->max_dest_rd_atomic, 1 << dev->qp_table.rdb_shift);
    } else {

    }
#line 1015
    goto out;
  } else {

  }
#line 1018
  if ((unsigned int )cur_state == (unsigned int )new_state && (unsigned int )cur_state == 0U) {
#line 1019
    err = 0;
#line 1020
    goto out;
  } else {

  }
#line 1023
  err = __mthca_modify_qp(ibqp, (struct ib_qp_attr  const  *)attr, attr_mask, cur_state,
                          new_state);
  out: 
#line 1026
  ldv_mutex_unlock_123(& qp->mutex);
#line 1027
  return (err);
}
}
#line 1030 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_max_data_size(struct mthca_dev *dev , struct mthca_qp *qp , int desc_sz ) 
{ int max_data_size ;
  int tmp ;

  {
#line 1036
  max_data_size = (int )((unsigned int )desc_sz - 16U);
#line 1038
  switch ((int )qp->transport) {
  case 5: 
#line 1040
  max_data_size = (int )((unsigned int )max_data_size - 32U);
#line 1041
  goto ldv_26774;
  case 2: 
#line 1044
  tmp = mthca_is_memfree(dev);
#line 1044
  if (tmp != 0) {
#line 1045
    max_data_size = (int )((unsigned int )max_data_size - 48U);
  } else {
#line 1047
    max_data_size = (int )((unsigned int )max_data_size - 48U);
  }
#line 1048
  goto ldv_26774;
  default: 
#line 1051
  max_data_size = (int )((unsigned int )max_data_size - 16U);
#line 1052
  goto ldv_26774;
  }
  ldv_26774: ;
#line 1055
  return (max_data_size);
}
}
#line 1058 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static int mthca_max_inline_data(struct mthca_pd *pd , int max_data_size ) 
{ int tmp ;

  {
#line 1061
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 1061
    tmp = max_data_size + -4;
  } else {
#line 1061
    tmp = 0;
  }
#line 1061
  return (tmp);
}
}
#line 1064 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_adjust_qp_caps(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_qp *qp ) 
{ int max_data_size ;
  int _min1 ;
  int _min2 ;
  int tmp ;
  int tmp___0 ;
  int __min1 ;
  int __min2 ;
  int tmp___1 ;
  int __min1___0 ;
  int __min2___0 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1069
  _min1 = dev->limits.max_desc_sz;
#line 1069
  _min2 = 1 << qp->sq.wqe_shift;
#line 1069
  if (_min1 < _min2) {
#line 1069
    tmp = _min1;
  } else {
#line 1069
    tmp = _min2;
  }
#line 1069
  tmp___0 = mthca_max_data_size(dev, qp, tmp);
#line 1069
  max_data_size = tmp___0;
#line 1072
  qp->max_inline_data = mthca_max_inline_data(pd, max_data_size);
#line 1074
  __min1 = dev->limits.max_sg;
#line 1074
  __min2 = (int )((unsigned long )max_data_size / 16UL);
#line 1074
  if (__min1 < __min2) {
#line 1074
    tmp___1 = __min1;
  } else {
#line 1074
    tmp___1 = __min2;
  }
#line 1074
  qp->sq.max_gs = tmp___1;
#line 1076
  __min1___0 = dev->limits.max_sg;
#line 1076
  _min1___0 = dev->limits.max_desc_sz;
#line 1076
  _min2___0 = 1 << qp->rq.wqe_shift;
#line 1076
  if (_min1___0 < _min2___0) {
#line 1076
    tmp___2 = _min1___0;
  } else {
#line 1076
    tmp___2 = _min2___0;
  }
#line 1076
  __min2___0 = (int )(((unsigned long )tmp___2 - 16UL) / 16UL);
#line 1076
  if (__min1___0 < __min2___0) {
#line 1076
    tmp___3 = __min1___0;
  } else {
#line 1076
    tmp___3 = __min2___0;
  }
#line 1076
  qp->rq.max_gs = tmp___3;
#line 1078
  return;
}
}
#line 1089 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_alloc_wqe_buf(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_qp *qp ) 
{ int size ;
  int err ;
  int __max1 ;
  int __max2 ;
  int tmp ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1094
  err = -12;
#line 1096
  size = (int )((unsigned int )((unsigned long )qp->rq.max_gs + 1UL) * 16U);
#line 1099
  if (dev->limits.max_desc_sz < size) {
#line 1100
    return (-22);
  } else {

  }
#line 1102
  qp->rq.wqe_shift = 6;
#line 1102
  goto ldv_26807;
  ldv_26806: 
#line 1103
  qp->rq.wqe_shift = qp->rq.wqe_shift + 1;
  ldv_26807: ;
#line 1102
  if (1 << qp->rq.wqe_shift < size) {
#line 1103
    goto ldv_26806;
  } else {
#line 1105
    goto ldv_26808;
  }
  ldv_26808: 
#line 1106
  size = (int )((unsigned int )qp->sq.max_gs * 16U);
#line 1107
  switch ((int )qp->transport) {
  case 5: 
#line 1109
  size = (int )((unsigned int )size + 32U);
#line 1110
  goto ldv_26810;
  case 2: 
#line 1113
  mthca_is_memfree(dev);
#line 1113
  size = (int )((unsigned long )size + 48UL);
#line 1116
  goto ldv_26810;
  case 1: 
#line 1119
  size = (int )((unsigned int )size + 16U);
#line 1120
  goto ldv_26810;
  case 0: 
#line 1123
  size = (int )((unsigned int )size + 16U);
#line 1128
  __max1 = size;
#line 1128
  __max2 = 48;
#line 1128
  if (__max1 > __max2) {
#line 1128
    tmp = __max1;
  } else {
#line 1128
    tmp = __max2;
  }
#line 1128
  size = tmp;
#line 1132
  goto ldv_26810;
  default: ;
#line 1135
  goto ldv_26810;
  }
  ldv_26810: 
#line 1139
  __max1___0 = size;
#line 1139
  __max2___0 = 32;
#line 1139
  if (__max1___0 > __max2___0) {
#line 1139
    tmp___0 = __max1___0;
  } else {
#line 1139
    tmp___0 = __max2___0;
  }
#line 1139
  size = tmp___0;
#line 1141
  size = (int )((unsigned int )size + 16U);
#line 1143
  if (dev->limits.max_desc_sz < size) {
#line 1144
    return (-22);
  } else {

  }
#line 1146
  qp->sq.wqe_shift = 6;
#line 1146
  goto ldv_26822;
  ldv_26821: 
#line 1147
  qp->sq.wqe_shift = qp->sq.wqe_shift + 1;
  ldv_26822: ;
#line 1146
  if (1 << qp->sq.wqe_shift < size) {
#line 1147
    goto ldv_26821;
  } else {
#line 1149
    goto ldv_26823;
  }
  ldv_26823: 
#line 1150
  qp->send_wqe_offset = ((qp->rq.max << qp->rq.wqe_shift) + ((1 << qp->sq.wqe_shift) + -1)) & - (1 << qp->sq.wqe_shift);
#line 1158
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 1159
    return (0);
  } else {

  }
#line 1161
  size = ((qp->send_wqe_offset + (qp->sq.max << qp->sq.wqe_shift)) + 4095) & -4096;
#line 1164
  tmp___1 = kmalloc((unsigned long )(qp->rq.max + qp->sq.max) * 8UL, 208U);
#line 1164
  qp->wrid = (u64 *)tmp___1;
#line 1166
  if ((unsigned long )qp->wrid == (unsigned long )((u64 *)0)) {
#line 1167
    goto err_out;
  } else {

  }
#line 1169
  err = mthca_buf_alloc(dev, size, 16384, & qp->queue, & qp->is_direct, pd, 0, & qp->mr);
#line 1171
  if (err != 0) {
#line 1172
    goto err_out;
  } else {

  }
#line 1174
  return (0);
  err_out: 
#line 1177
  kfree((void const   *)qp->wrid);
#line 1178
  return (err);
}
}
#line 1181 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_free_wqe_buf(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 

  {
#line 1184
  mthca_buf_free(dev, ((qp->send_wqe_offset + (qp->sq.max << qp->sq.wqe_shift)) + 4095) & -4096,
                 & qp->queue, qp->is_direct, & qp->mr);
#line 1187
  kfree((void const   *)qp->wrid);
#line 1188
  return;
}
}
#line 1190 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_map_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ int ret ;
  int tmp ;

  {
#line 1195
  tmp = mthca_is_memfree(dev);
#line 1195
  if (tmp != 0) {
#line 1196
    ret = mthca_table_get(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1197
    if (ret != 0) {
#line 1198
      return (ret);
    } else {

    }
#line 1200
    ret = mthca_table_get(dev, dev->qp_table.eqp_table, (int )qp->qpn);
#line 1201
    if (ret != 0) {
#line 1202
      goto err_qpc;
    } else {

    }
#line 1204
    ret = mthca_table_get(dev, dev->qp_table.rdb_table, (int )(qp->qpn << dev->qp_table.rdb_shift));
#line 1206
    if (ret != 0) {
#line 1207
      goto err_eqpc;
    } else {

    }
  } else {

  }
#line 1211
  return (0);
  err_eqpc: 
#line 1214
  mthca_table_put(dev, dev->qp_table.eqp_table, (int )qp->qpn);
  err_qpc: 
#line 1217
  mthca_table_put(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1219
  return (ret);
}
}
#line 1222 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_unmap_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ 

  {
#line 1225
  mthca_table_put(dev, dev->qp_table.rdb_table, (int )(qp->qpn << dev->qp_table.rdb_shift));
#line 1227
  mthca_table_put(dev, dev->qp_table.eqp_table, (int )qp->qpn);
#line 1228
  mthca_table_put(dev, dev->qp_table.qp_table, (int )qp->qpn);
#line 1229
  return;
}
}
#line 1231 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_alloc_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ int tmp ;

  {
#line 1234
  tmp = mthca_is_memfree(dev);
#line 1234
  if (tmp != 0) {
#line 1235
    qp->rq.db_index = mthca_alloc_db(dev, 4, qp->qpn, & qp->rq.db);
#line 1237
    if (qp->rq.db_index < 0) {
#line 1238
      return (-12);
    } else {

    }
#line 1240
    qp->sq.db_index = mthca_alloc_db(dev, 3, qp->qpn, & qp->sq.db);
#line 1242
    if (qp->sq.db_index < 0) {
#line 1243
      mthca_free_db(dev, 4, qp->rq.db_index);
#line 1244
      return (-12);
    } else {

    }
  } else {

  }
#line 1248
  return (0);
}
}
#line 1251 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_free_memfree(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ int tmp ;

  {
#line 1254
  tmp = mthca_is_memfree(dev);
#line 1254
  if (tmp != 0) {
#line 1255
    mthca_free_db(dev, 3, qp->sq.db_index);
#line 1256
    mthca_free_db(dev, 4, qp->rq.db_index);
  } else {

  }
#line 1258
  return;
}
}
#line 1260 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_alloc_qp_common(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                                 struct mthca_cq *recv_cq , enum ib_sig_type send_policy ,
                                 struct mthca_qp *qp ) 
{ int ret ;
  int i ;
  struct mthca_next_seg *next ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct mthca_data_seg *scatter ;
  int size ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  void *tmp___4 ;
  __u32 tmp___5 ;
  int tmp___6 ;

  {
#line 1271
  qp->refcount = 1;
#line 1272
  __init_waitqueue_head(& qp->wait, "&qp->wait", & __key);
#line 1273
  __mutex_init(& qp->mutex, "&qp->mutex", & __key___0);
#line 1274
  qp->state = 0U;
#line 1275
  qp->atomic_rd_en = 0U;
#line 1276
  qp->resp_depth = 0U;
#line 1277
  qp->sq_policy = send_policy;
#line 1278
  mthca_wq_reset(& qp->sq);
#line 1279
  mthca_wq_reset(& qp->rq);
#line 1281
  spinlock_check(& qp->sq.lock);
#line 1281
  __raw_spin_lock_init(& qp->sq.lock.ldv_5961.rlock, "&(&qp->sq.lock)->rlock", & __key___1);
#line 1282
  spinlock_check(& qp->rq.lock);
#line 1282
  __raw_spin_lock_init(& qp->rq.lock.ldv_5961.rlock, "&(&qp->rq.lock)->rlock", & __key___2);
#line 1284
  ret = mthca_map_memfree(dev, qp);
#line 1285
  if (ret != 0) {
#line 1286
    return (ret);
  } else {

  }
#line 1288
  ret = mthca_alloc_wqe_buf(dev, pd, qp);
#line 1289
  if (ret != 0) {
#line 1290
    mthca_unmap_memfree(dev, qp);
#line 1291
    return (ret);
  } else {

  }
#line 1294
  mthca_adjust_qp_caps(dev, pd, qp);
#line 1301
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 1302
    return (0);
  } else {

  }
#line 1304
  ret = mthca_alloc_memfree(dev, qp);
#line 1305
  if (ret != 0) {
#line 1306
    mthca_free_wqe_buf(dev, qp);
#line 1307
    mthca_unmap_memfree(dev, qp);
#line 1308
    return (ret);
  } else {

  }
#line 1311
  tmp___6 = mthca_is_memfree(dev);
#line 1311
  if (tmp___6 != 0) {
#line 1313
    size = (int )((((unsigned long )qp->rq.max_gs + 1UL) * 16UL) / 16UL);
#line 1316
    i = 0;
#line 1316
    goto ldv_26869;
    ldv_26868: 
#line 1317
    tmp = get_recv_wqe(qp, i);
#line 1317
    next = (struct mthca_next_seg *)tmp;
#line 1318
    tmp___0 = __fswab32((__u32 )(((i + 1) & (qp->rq.max + -1)) << qp->rq.wqe_shift));
#line 1318
    next->nda_op = tmp___0;
#line 1320
    tmp___1 = __fswab32((__u32 )size);
#line 1320
    next->ee_nds = tmp___1;
#line 1322
    scatter = (struct mthca_data_seg *)next + 1U;
#line 1322
    goto ldv_26866;
    ldv_26865: 
#line 1325
    scatter->lkey = 65536U;
#line 1324
    scatter = scatter + 1;
    ldv_26866: ;
#line 1322
    if ((unsigned long )((void *)next + (unsigned long )(1 << qp->rq.wqe_shift)) > (unsigned long )((void *)scatter)) {
#line 1324
      goto ldv_26865;
    } else {
#line 1326
      goto ldv_26867;
    }
    ldv_26867: 
#line 1316
    i = i + 1;
    ldv_26869: ;
#line 1316
    if (qp->rq.max > i) {
#line 1317
      goto ldv_26868;
    } else {
#line 1319
      goto ldv_26870;
    }
    ldv_26870: 
#line 1328
    i = 0;
#line 1328
    goto ldv_26872;
    ldv_26871: 
#line 1329
    tmp___2 = get_send_wqe(qp, i);
#line 1329
    next = (struct mthca_next_seg *)tmp___2;
#line 1330
    tmp___3 = __fswab32((__u32 )((((i + 1) & (qp->sq.max + -1)) << qp->sq.wqe_shift) + qp->send_wqe_offset));
#line 1330
    next->nda_op = tmp___3;
#line 1328
    i = i + 1;
    ldv_26872: ;
#line 1328
    if (qp->sq.max > i) {
#line 1329
      goto ldv_26871;
    } else {
#line 1331
      goto ldv_26873;
    }
    ldv_26873: ;
  } else {
#line 1335
    i = 0;
#line 1335
    goto ldv_26875;
    ldv_26874: 
#line 1336
    tmp___4 = get_recv_wqe(qp, i);
#line 1336
    next = (struct mthca_next_seg *)tmp___4;
#line 1337
    tmp___5 = __fswab32((__u32 )(((i + 1) % qp->rq.max << qp->rq.wqe_shift) | 1));
#line 1337
    next->nda_op = tmp___5;
#line 1335
    i = i + 1;
    ldv_26875: ;
#line 1335
    if (qp->rq.max > i) {
#line 1336
      goto ldv_26874;
    } else {
#line 1338
      goto ldv_26876;
    }
    ldv_26876: ;
  }
#line 1343
  qp->sq.last = get_send_wqe(qp, qp->sq.max + -1);
#line 1344
  qp->rq.last = get_recv_wqe(qp, qp->rq.max + -1);
#line 1346
  return (0);
}
}
#line 1349 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int mthca_set_qp_size(struct mthca_dev *dev , struct ib_qp_cap *cap , struct mthca_pd *pd ,
                             struct mthca_qp *qp ) 
{ int max_data_size ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int __max1 ;
  int __max2 ;
  int tmp___4 ;

  {
#line 1352
  tmp = mthca_max_data_size(dev, qp, dev->limits.max_desc_sz);
#line 1352
  max_data_size = tmp;
#line 1355
  if (((cap->max_send_wr > (u32 )dev->limits.max_wqes || cap->max_recv_wr > (u32 )dev->limits.max_wqes) || cap->max_send_sge > (u32 )dev->limits.max_sg) || cap->max_recv_sge > (u32 )dev->limits.max_sg) {
#line 1360
    return (-22);
  } else {
#line 1355
    tmp___0 = mthca_max_inline_data(pd, max_data_size);
#line 1355
    if (cap->max_inline_data > (u32 )tmp___0) {
#line 1360
      return (-22);
    } else {

    }
  }
#line 1366
  if ((unsigned int )qp->transport == 5U && cap->max_send_sge + 2U > (u32 )dev->limits.max_sg) {
#line 1367
    return (-22);
  } else {

  }
#line 1369
  tmp___3 = mthca_is_memfree(dev);
#line 1369
  if (tmp___3 != 0) {
#line 1370
    if (cap->max_recv_wr != 0U) {
#line 1370
      tmp___1 = __roundup_pow_of_two((unsigned long )cap->max_recv_wr);
#line 1370
      qp->rq.max = (int )tmp___1;
    } else {
#line 1370
      qp->rq.max = 0;
    }
#line 1372
    if (cap->max_send_wr != 0U) {
#line 1372
      tmp___2 = __roundup_pow_of_two((unsigned long )cap->max_send_wr);
#line 1372
      qp->sq.max = (int )tmp___2;
    } else {
#line 1372
      qp->sq.max = 0;
    }
  } else {
#line 1375
    qp->rq.max = (int )cap->max_recv_wr;
#line 1376
    qp->sq.max = (int )cap->max_send_wr;
  }
#line 1379
  qp->rq.max_gs = (int )cap->max_recv_sge;
#line 1380
  __max1 = (int )cap->max_send_sge;
#line 1380
  __max2 = (int )(((unsigned long )(cap->max_inline_data + 19U) & 4294967280UL) / 16UL);
#line 1380
  if (__max1 > __max2) {
#line 1380
    tmp___4 = __max1;
  } else {
#line 1380
    tmp___4 = __max2;
  }
#line 1380
  qp->sq.max_gs = tmp___4;
#line 1385
  return (0);
}
}
#line 1388 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_alloc_qp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                   struct mthca_cq *recv_cq , enum ib_qp_type type , enum ib_sig_type send_policy ,
                   struct ib_qp_cap *cap , struct mthca_qp *qp ) 
{ int err ;

  {
#line 1399
  switch ((unsigned int )type) {
  case 2: 
#line 1400
  qp->transport = 0U;
#line 1400
  goto ldv_26899;
  case 3: 
#line 1401
  qp->transport = 1U;
#line 1401
  goto ldv_26899;
  case 4: 
#line 1402
  qp->transport = 2U;
#line 1402
  goto ldv_26899;
  default: ;
#line 1403
  return (-22);
  }
  ldv_26899: 
#line 1406
  err = mthca_set_qp_size(dev, cap, pd, qp);
#line 1407
  if (err != 0) {
#line 1408
    return (err);
  } else {

  }
#line 1410
  qp->qpn = mthca_alloc(& dev->qp_table.alloc);
#line 1411
  if (qp->qpn == 4294967295U) {
#line 1412
    return (-12);
  } else {

  }
#line 1415
  qp->port = 0U;
#line 1417
  err = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq, send_policy, qp);
#line 1419
  if (err != 0) {
#line 1420
    mthca_free(& dev->qp_table.alloc, qp->qpn);
#line 1421
    return (err);
  } else {

  }
#line 1424
  spin_lock_irq(& dev->qp_table.lock);
#line 1425
  mthca_array_set(& dev->qp_table.qp, (int )(qp->qpn & (u32 )(dev->limits.num_qps + -1)),
                  (void *)qp);
#line 1427
  spin_unlock_irq(& dev->qp_table.lock);
#line 1429
  return (0);
}
}
#line 1432 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_lock_cqs(struct mthca_cq *send_cq , struct mthca_cq *recv_cq ) 
{ raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1435
  if ((unsigned long )send_cq == (unsigned long )recv_cq) {
#line 1436
    spin_lock_irq(& send_cq->lock);
  } else
#line 1438
  if (send_cq->cqn < recv_cq->cqn) {
#line 1439
    spin_lock_irq(& send_cq->lock);
#line 1440
    tmp = spinlock_check(& recv_cq->lock);
#line 1440
    _raw_spin_lock_nested(tmp, 1);
  } else {
#line 1442
    spin_lock_irq(& recv_cq->lock);
#line 1443
    tmp___0 = spinlock_check(& send_cq->lock);
#line 1443
    _raw_spin_lock_nested(tmp___0, 1);
  }
#line 1445
  return;
}
}
#line 1447 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void mthca_unlock_cqs(struct mthca_cq *send_cq , struct mthca_cq *recv_cq ) 
{ 

  {
#line 1450
  if ((unsigned long )send_cq == (unsigned long )recv_cq) {
#line 1452
    spin_unlock_irq(& send_cq->lock);
  } else
#line 1453
  if (send_cq->cqn < recv_cq->cqn) {
#line 1454
    spin_unlock(& recv_cq->lock);
#line 1455
    spin_unlock_irq(& send_cq->lock);
  } else {
#line 1457
    spin_unlock(& send_cq->lock);
#line 1458
    spin_unlock_irq(& recv_cq->lock);
  }
#line 1460
  return;
}
}
#line 1462 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_alloc_sqp(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_cq *send_cq ,
                    struct mthca_cq *recv_cq , enum ib_sig_type send_policy , struct ib_qp_cap *cap ,
                    int qpn , int port , struct mthca_sqp *sqp ) 
{ u32 mqpn ;
  int err ;
  void *tmp ;

  {
#line 1472
  mqpn = (u32 )(((qpn * 2 + dev->qp_table.sqp_start) + port) + -1);
#line 1475
  sqp->qp.transport = 5U;
#line 1476
  err = mthca_set_qp_size(dev, cap, pd, & sqp->qp);
#line 1477
  if (err != 0) {
#line 1478
    return (err);
  } else {

  }
#line 1480
  sqp->header_buf_size = sqp->qp.sq.max * 72;
#line 1481
  sqp->header_buf = dma_alloc_attrs(& (dev->pdev)->dev, (size_t )sqp->header_buf_size,
                                    & sqp->header_dma, 208U, 0);
#line 1483
  if ((unsigned long )sqp->header_buf == (unsigned long )((void *)0)) {
#line 1484
    return (-12);
  } else {

  }
#line 1486
  spin_lock_irq(& dev->qp_table.lock);
#line 1487
  tmp = mthca_array_get(& dev->qp_table.qp, (int )mqpn);
#line 1487
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1488
    err = -16;
  } else {
#line 1490
    mthca_array_set(& dev->qp_table.qp, (int )mqpn, (void *)sqp);
  }
#line 1491
  spin_unlock_irq(& dev->qp_table.lock);
#line 1493
  if (err != 0) {
#line 1494
    goto err_out;
  } else {

  }
#line 1496
  sqp->qp.port = (u8 )port;
#line 1497
  sqp->qp.qpn = mqpn;
#line 1498
  sqp->qp.transport = 5U;
#line 1500
  err = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq, send_policy, & sqp->qp);
#line 1502
  if (err != 0) {
#line 1503
    goto err_out_free;
  } else {

  }
#line 1505
  atomic_inc(& pd->sqp_count);
#line 1507
  return (0);
  err_out_free: 
#line 1514
  mthca_lock_cqs(send_cq, recv_cq);
#line 1516
  spin_lock(& dev->qp_table.lock);
#line 1517
  mthca_array_clear(& dev->qp_table.qp, (int )mqpn);
#line 1518
  spin_unlock(& dev->qp_table.lock);
#line 1520
  mthca_unlock_cqs(send_cq, recv_cq);
  err_out: 
#line 1523
  dma_free_attrs(& (dev->pdev)->dev, (size_t )sqp->header_buf_size, sqp->header_buf,
                 sqp->header_dma, 0);
#line 1526
  return (err);
}
}
#line 1529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static int get_qp_refcount(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ int c ;

  {
#line 1533
  spin_lock_irq(& dev->qp_table.lock);
#line 1534
  c = qp->refcount;
#line 1535
  spin_unlock_irq(& dev->qp_table.lock);
#line 1537
  return (c);
}
}
#line 1540 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void mthca_free_qp(struct mthca_dev *dev , struct mthca_qp *qp ) 
{ struct mthca_cq *send_cq ;
  struct mthca_cq *recv_cq ;
  int tmp ;
  wait_queue_t __wait ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  struct mthca_srq *tmp___2 ;
  struct mthca_srq *tmp___3 ;
  struct mthca_pd *tmp___4 ;
  struct mthca_sqp *tmp___5 ;
  struct mthca_sqp *tmp___6 ;
  struct mthca_sqp *tmp___7 ;
  int tmp___8 ;

  {
#line 1546
  send_cq = to_mcq(qp->ibqp.send_cq);
#line 1547
  recv_cq = to_mcq(qp->ibqp.recv_cq);
#line 1553
  mthca_lock_cqs(send_cq, recv_cq);
#line 1555
  spin_lock(& dev->qp_table.lock);
#line 1556
  mthca_array_clear(& dev->qp_table.qp, (int )(qp->qpn & (u32 )(dev->limits.num_qps + -1)));
#line 1558
  qp->refcount = qp->refcount - 1;
#line 1559
  spin_unlock(& dev->qp_table.lock);
#line 1561
  mthca_unlock_cqs(send_cq, recv_cq);
#line 1563
  tmp = get_qp_refcount(dev, qp);
#line 1563
  if (tmp == 0) {
#line 1563
    goto ldv_26937;
  } else {

  }
#line 1563
  tmp___0 = get_current();
#line 1563
  __wait.flags = 0U;
#line 1563
  __wait.private = (void *)tmp___0;
#line 1563
  __wait.func = & autoremove_wake_function;
#line 1563
  __wait.task_list.next = & __wait.task_list;
#line 1563
  __wait.task_list.prev = & __wait.task_list;
  ldv_26940: 
#line 1563
  prepare_to_wait(& qp->wait, & __wait, 2);
#line 1563
  tmp___1 = get_qp_refcount(dev, qp);
#line 1563
  if (tmp___1 == 0) {
#line 1563
    goto ldv_26939;
  } else {

  }
#line 1563
  schedule();
#line 1563
  goto ldv_26940;
  ldv_26939: 
#line 1563
  finish_wait(& qp->wait, & __wait);
  ldv_26937: ;
#line 1565
  if ((unsigned int )qp->state != 0U) {
#line 1566
    mthca_MODIFY_QP(dev, (enum ib_qp_state )qp->state, 0, qp->qpn, 0, 0, 0U);
  } else {

  }
#line 1574
  if ((unsigned long )qp->ibqp.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 1575
    if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0)) {
#line 1575
      tmp___2 = to_msrq(qp->ibqp.srq);
#line 1575
      tmp___3 = tmp___2;
    } else {
#line 1575
      tmp___3 = 0;
    }
#line 1575
    mthca_cq_clean(dev, recv_cq, qp->qpn, tmp___3);
#line 1577
    if ((unsigned long )send_cq != (unsigned long )recv_cq) {
#line 1578
      mthca_cq_clean(dev, send_cq, qp->qpn, 0);
    } else {

    }
#line 1580
    mthca_free_memfree(dev, qp);
#line 1581
    mthca_free_wqe_buf(dev, qp);
  } else {

  }
#line 1584
  mthca_unmap_memfree(dev, qp);
#line 1586
  tmp___8 = is_sqp(dev, qp);
#line 1586
  if (tmp___8 != 0) {
#line 1587
    tmp___4 = to_mpd(qp->ibqp.pd);
#line 1587
    atomic_dec(& tmp___4->sqp_count);
#line 1588
    tmp___5 = to_msqp(qp);
#line 1588
    tmp___6 = to_msqp(qp);
#line 1588
    tmp___7 = to_msqp(qp);
#line 1588
    dma_free_attrs(& (dev->pdev)->dev, (size_t )tmp___7->header_buf_size, tmp___6->header_buf,
                   tmp___5->header_dma, 0);
  } else {
#line 1593
    mthca_free(& dev->qp_table.alloc, qp->qpn);
  }
#line 1594
  return;
}
}
#line 1597 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static int build_mlx_header(struct mthca_dev *dev , struct mthca_sqp *sqp , int ind ,
                            struct ib_send_wr *wr , struct mthca_mlx_seg *mlx , struct mthca_data_seg *data ) 
{ int header_size ;
  int err ;
  u16 pkey ;
  struct mthca_ah *tmp ;
  int tmp___0 ;
  struct mthca_ah *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __u32 tmp___4 ;
  __u16 tmp___5 ;
  __u32 tmp___6 ;
  u32 tmp___7 ;
  __u32 tmp___8 ;
  u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  struct mthca_pd *tmp___13 ;
  __u32 tmp___14 ;
  __u64 tmp___15 ;

  {
#line 1606
  tmp = to_mah(wr->wr.ud.ah);
#line 1606
  tmp___0 = mthca_ah_grh_present(tmp);
#line 1606
  ib_ud_header_init(256, 1, 0, 0, tmp___0, 0, & sqp->ud_header);
#line 1610
  tmp___1 = to_mah(wr->wr.ud.ah);
#line 1610
  err = mthca_read_ah(dev, tmp___1, & sqp->ud_header);
#line 1611
  if (err != 0) {
#line 1612
    return (err);
  } else {

  }
#line 1613
  mlx->flags = mlx->flags & 4244635647U;
#line 1614
  if (sqp->qp.ibqp.qp_num == 0U) {
#line 1614
    tmp___2 = 131072;
  } else {
#line 1614
    tmp___2 = 0;
  }
#line 1614
  if ((unsigned int )sqp->ud_header.lrh.destination_lid == 65535U) {
#line 1614
    tmp___3 = 65536;
  } else {
#line 1614
    tmp___3 = 0;
  }
#line 1614
  tmp___4 = __fswab32((__u32 )((tmp___2 | tmp___3) | ((int )sqp->ud_header.lrh.service_level << 8)));
#line 1614
  mlx->flags = mlx->flags | tmp___4;
#line 1618
  mlx->rlid = sqp->ud_header.lrh.destination_lid;
#line 1619
  mlx->vcrc = 0U;
#line 1621
  switch ((unsigned int )wr->opcode) {
  case 2: 
#line 1623
  sqp->ud_header.bth.opcode = 100U;
#line 1624
  sqp->ud_header.immediate_present = 0;
#line 1625
  goto ldv_26953;
  case 3: 
#line 1627
  sqp->ud_header.bth.opcode = 101U;
#line 1628
  sqp->ud_header.immediate_present = 1;
#line 1629
  sqp->ud_header.immediate_data = wr->ex.imm_data;
#line 1630
  goto ldv_26953;
  default: ;
#line 1632
  return (-22);
  }
  ldv_26953: ;
#line 1635
  if (sqp->qp.ibqp.qp_num == 0U) {
#line 1635
    sqp->ud_header.lrh.virtual_lane = 15U;
  } else {
#line 1635
    sqp->ud_header.lrh.virtual_lane = 0U;
  }
#line 1636
  if ((unsigned int )sqp->ud_header.lrh.destination_lid == 65535U) {
#line 1637
    sqp->ud_header.lrh.source_lid = 65535U;
  } else {

  }
#line 1638
  sqp->ud_header.bth.solicited_event = (wr->send_flags & 4) != 0;
#line 1639
  if (sqp->qp.ibqp.qp_num == 0U) {
#line 1640
    ib_get_cached_pkey(& dev->ib_dev, (int )sqp->qp.port, sqp->pkey_index, & pkey);
  } else {
#line 1643
    ib_get_cached_pkey(& dev->ib_dev, (int )sqp->qp.port, (int )wr->wr.ud.pkey_index,
                       & pkey);
  }
#line 1645
  tmp___5 = __fswab16((int )pkey);
#line 1645
  sqp->ud_header.bth.pkey = tmp___5;
#line 1646
  tmp___6 = __fswab32(wr->wr.ud.remote_qpn);
#line 1646
  sqp->ud_header.bth.destination_qpn = tmp___6;
#line 1647
  tmp___7 = sqp->send_psn;
#line 1647
  sqp->send_psn = sqp->send_psn + 1U;
#line 1647
  tmp___8 = __fswab32(tmp___7 & 16777215U);
#line 1647
  sqp->ud_header.bth.psn = tmp___8;
#line 1648
  if ((int )wr->wr.ud.remote_qkey < 0) {
#line 1648
    tmp___9 = sqp->qkey;
  } else {
#line 1648
    tmp___9 = wr->wr.ud.remote_qkey;
  }
#line 1648
  tmp___10 = __fswab32(tmp___9);
#line 1648
  sqp->ud_header.deth.qkey = tmp___10;
#line 1650
  tmp___11 = __fswab32(sqp->qp.ibqp.qp_num);
#line 1650
  sqp->ud_header.deth.source_qpn = tmp___11;
#line 1652
  header_size = ib_ud_header_pack(& sqp->ud_header, sqp->header_buf + (unsigned long )(ind * 72));
#line 1656
  tmp___12 = __fswab32((__u32 )header_size);
#line 1656
  data->byte_count = tmp___12;
#line 1657
  tmp___13 = to_mpd(sqp->qp.ibqp.pd);
#line 1657
  tmp___14 = __fswab32(tmp___13->ntmr.ibmr.lkey);
#line 1657
  data->lkey = tmp___14;
#line 1658
  tmp___15 = __fswab64(sqp->header_dma + (dma_addr_t )(ind * 72));
#line 1658
  data->addr = tmp___15;
#line 1661
  return (0);
}
}
#line 1664 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static int mthca_wq_overflow(struct mthca_wq *wq , int nreq , struct ib_cq *ib_cq ) 
{ unsigned int cur ;
  struct mthca_cq *cq ;
  long tmp ;

  {
#line 1670
  cur = wq->head - wq->tail;
#line 1671
  tmp = ldv__builtin_expect(cur + (unsigned int )nreq < (unsigned int )wq->max, 1L);
#line 1671
  if (tmp != 0L) {
#line 1672
    return (0);
  } else {

  }
#line 1674
  cq = to_mcq(ib_cq);
#line 1675
  spin_lock(& cq->lock);
#line 1676
  cur = wq->head - wq->tail;
#line 1677
  spin_unlock(& cq->lock);
#line 1679
  return (cur + (unsigned int )nreq >= (unsigned int )wq->max);
}
}
#line 1682 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static void set_raddr_seg(struct mthca_raddr_seg *rseg , u64 remote_addr ,
                                   u32 rkey ) 
{ __u64 tmp ;
  __u32 tmp___0 ;

  {
#line 1685
  tmp = __fswab64(remote_addr);
#line 1685
  rseg->raddr = tmp;
#line 1686
  tmp___0 = __fswab32(rkey);
#line 1686
  rseg->rkey = tmp___0;
#line 1687
  rseg->reserved = 0U;
#line 1688
  return;
}
}
#line 1690 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
__inline static void set_atomic_seg(struct mthca_atomic_seg *aseg , struct ib_send_wr *wr ) 
{ __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;

  {
#line 1693
  if ((unsigned int )wr->opcode == 5U) {
#line 1694
    tmp = __fswab64(wr->wr.atomic.swap);
#line 1694
    aseg->swap_add = tmp;
#line 1695
    tmp___0 = __fswab64(wr->wr.atomic.compare_add);
#line 1695
    aseg->compare = tmp___0;
  } else {
#line 1697
    tmp___1 = __fswab64(wr->wr.atomic.compare_add);
#line 1697
    aseg->swap_add = tmp___1;
#line 1698
    aseg->compare = 0ULL;
  }
#line 1700
  return;
}
}
#line 1703 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void set_tavor_ud_seg(struct mthca_tavor_ud_seg *useg , struct ib_send_wr *wr ) 
{ struct mthca_ah *tmp ;
  __u32 tmp___0 ;
  struct mthca_ah *tmp___1 ;
  __u64 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 1706
  tmp = to_mah(wr->wr.ud.ah);
#line 1706
  tmp___0 = __fswab32(tmp->key);
#line 1706
  useg->lkey = tmp___0;
#line 1707
  tmp___1 = to_mah(wr->wr.ud.ah);
#line 1707
  tmp___2 = __fswab64(tmp___1->avdma);
#line 1707
  useg->av_addr = tmp___2;
#line 1708
  tmp___3 = __fswab32(wr->wr.ud.remote_qpn);
#line 1708
  useg->dqpn = tmp___3;
#line 1709
  tmp___4 = __fswab32(wr->wr.ud.remote_qkey);
#line 1709
  useg->qkey = tmp___4;
#line 1710
  return;
}
}
#line 1713 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
static void set_arbel_ud_seg(struct mthca_arbel_ud_seg *useg , struct ib_send_wr *wr ) 
{ size_t __len ;
  void *__ret ;
  struct mthca_ah *tmp ;
  struct mthca_ah *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 1716
  __len = 32UL;
#line 1716
  if (__len > 63UL) {
#line 1716
    tmp = to_mah(wr->wr.ud.ah);
#line 1716
    __ret = __memcpy((void *)(& useg->av), (void const   *)tmp->av, __len);
  } else {
#line 1716
    tmp___0 = to_mah(wr->wr.ud.ah);
#line 1716
    __ret = __builtin_memcpy((void *)(& useg->av), (void const   *)tmp___0->av, __len);
  }
#line 1717
  tmp___1 = __fswab32(wr->wr.ud.remote_qpn);
#line 1717
  useg->dqpn = tmp___1;
#line 1718
  tmp___2 = __fswab32(wr->wr.ud.remote_qkey);
#line 1718
  useg->qkey = tmp___2;
#line 1719
  return;
}
}
#line 1721 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_tavor_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  void *wqe ;
  void *prev_wqe ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  u32 f0 ;
  int ind ;
  u8 op0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  struct mthca_sqp *tmp___5 ;
  __u32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __u32 tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 1724
  tmp = to_mdev(ibqp->device);
#line 1724
  dev = tmp;
#line 1725
  tmp___0 = to_mqp(ibqp);
#line 1725
  qp = tmp___0;
#line 1729
  err = 0;
#line 1740
  size0 = size0;
#line 1741
  f0 = f0;
#line 1743
  op0 = 0U;
#line 1745
  tmp___1 = spinlock_check(& qp->sq.lock);
#line 1745
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1749
  ind = (int )qp->sq.next_ind;
#line 1751
  nreq = 0;
#line 1751
  goto ldv_27027;
  ldv_27026: 
#line 1752
  tmp___2 = mthca_wq_overflow(& qp->sq, nreq, qp->ibqp.send_cq);
#line 1752
  if (tmp___2 != 0) {
#line 1753
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->sq.head, qp->sq.tail, qp->sq.max, nreq);
#line 1757
    err = -12;
#line 1758
    *bad_wr = wr;
#line 1759
    goto out;
  } else {

  }
#line 1762
  wqe = get_send_wqe(qp, ind);
#line 1763
  prev_wqe = qp->sq.last;
#line 1764
  qp->sq.last = wqe;
#line 1766
  ((struct mthca_next_seg *)wqe)->nda_op = 0U;
#line 1767
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 1768
  if ((wr->send_flags & 2) != 0) {
#line 1768
    tmp___3 = 134217728U;
  } else {
#line 1768
    tmp___3 = 0U;
  }
#line 1768
  if ((wr->send_flags & 4) != 0) {
#line 1768
    tmp___4 = 33554432U;
  } else {
#line 1768
    tmp___4 = 0U;
  }
#line 1768
  ((struct mthca_next_seg *)wqe)->flags = (tmp___3 | tmp___4) | 16777216U;
#line 1774
  if ((unsigned int )wr->opcode == 3U || (unsigned int )wr->opcode == 1U) {
#line 1776
    ((struct mthca_next_seg *)wqe)->imm = wr->ex.imm_data;
  } else {

  }
#line 1778
  wqe = wqe + 16UL;
#line 1779
  size = 1;
#line 1781
  switch ((int )qp->transport) {
  case 0: ;
#line 1783
  switch ((unsigned int )wr->opcode) {
  case 5: ;
  case 6: 
#line 1786
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.atomic.remote_addr, wr->wr.atomic.rkey);
#line 1788
  wqe = wqe + 16UL;
#line 1790
  set_atomic_seg((struct mthca_atomic_seg *)wqe, wr);
#line 1791
  wqe = wqe + 16UL;
#line 1792
  size = (int )((unsigned int )size + 2U);
#line 1794
  goto ldv_27008;
  case 0: ;
  case 1: ;
  case 4: 
#line 1799
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 1801
  wqe = wqe + 16UL;
#line 1802
  size = (int )((unsigned int )size + 1U);
#line 1803
  goto ldv_27008;
  default: ;
#line 1807
  goto ldv_27008;
  }
  ldv_27008: ;
#line 1810
  goto ldv_27013;
  case 1: ;
#line 1813
  switch ((unsigned int )wr->opcode) {
  case 0: ;
  case 1: 
#line 1816
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 1818
  wqe = wqe + 16UL;
#line 1819
  size = (int )((unsigned int )size + 1U);
#line 1820
  goto ldv_27017;
  default: ;
#line 1824
  goto ldv_27017;
  }
  ldv_27017: ;
#line 1827
  goto ldv_27013;
  case 2: 
#line 1830
  set_tavor_ud_seg((struct mthca_tavor_ud_seg *)wqe, wr);
#line 1831
  wqe = wqe + 48UL;
#line 1832
  size = (int )((unsigned int )size + 3U);
#line 1833
  goto ldv_27013;
  case 5: 
#line 1836
  tmp___5 = to_msqp(qp);
#line 1836
  err = build_mlx_header(dev, tmp___5, ind, wr, (struct mthca_mlx_seg *)wqe + 0xfffffffffffffff0UL,
                         (struct mthca_data_seg *)wqe);
#line 1839
  if (err != 0) {
#line 1840
    *bad_wr = wr;
#line 1841
    goto out;
  } else {

  }
#line 1843
  wqe = wqe + 16UL;
#line 1844
  size = (int )((unsigned int )size + 1U);
#line 1845
  goto ldv_27013;
  }
  ldv_27013: ;
#line 1848
  if (wr->num_sge > qp->sq.max_gs) {
#line 1849
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "too many gathers\n");
#line 1850
    err = -22;
#line 1851
    *bad_wr = wr;
#line 1852
    goto out;
  } else {

  }
#line 1855
  i = 0;
#line 1855
  goto ldv_27022;
  ldv_27021: 
#line 1856
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 1857
  wqe = wqe + 16UL;
#line 1858
  size = (int )((unsigned int )size + 1U);
#line 1855
  i = i + 1;
  ldv_27022: ;
#line 1855
  if (wr->num_sge > i) {
#line 1856
    goto ldv_27021;
  } else {
#line 1858
    goto ldv_27023;
  }
  ldv_27023: ;
#line 1862
  if ((unsigned int )qp->transport == 5U) {
#line 1863
    ((struct mthca_data_seg *)wqe)->byte_count = 67108992U;
#line 1865
    *((u32 *)wqe + 1UL) = 0U;
#line 1866
    wqe = wqe + 16UL;
#line 1867
    size = (int )((unsigned int )size + 1U);
  } else {

  }
#line 1870
  *(qp->wrid + (unsigned long )(qp->rq.max + ind)) = wr->wr_id;
#line 1872
  if ((unsigned int )wr->opcode > 6U) {
#line 1873
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "opcode invalid\n");
#line 1874
    err = -22;
#line 1875
    *bad_wr = wr;
#line 1876
    goto out;
  } else {

  }
#line 1879
  tmp___6 = __fswab32((__u32 )(((ind << qp->sq.wqe_shift) + qp->send_wqe_offset) | (int )mthca_opcode[(unsigned int )wr->opcode]));
#line 1879
  ((struct mthca_next_seg *)prev_wqe)->nda_op = tmp___6;
#line 1883
  __asm__  volatile   ("sfence": : : "memory");
#line 1884
  if (nreq != 0) {
#line 1884
    tmp___7 = 0;
  } else {
#line 1884
    tmp___7 = 128;
  }
#line 1884
  if (wr->send_flags & 1) {
#line 1884
    tmp___8 = 64;
  } else {
#line 1884
    tmp___8 = 0;
  }
#line 1884
  tmp___9 = __fswab32((__u32 )((tmp___7 | size) | tmp___8));
#line 1884
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___9;
#line 1889
  if (nreq == 0) {
#line 1890
    size0 = size;
#line 1891
    op0 = mthca_opcode[(unsigned int )wr->opcode];
#line 1892
    if (wr->send_flags & 1) {
#line 1892
      f0 = 32U;
    } else {
#line 1892
      f0 = 0U;
    }
  } else {

  }
#line 1896
  ind = ind + 1;
#line 1897
  tmp___10 = ldv__builtin_expect(qp->sq.max <= ind, 0L);
#line 1897
  if (tmp___10 != 0L) {
#line 1898
    ind = ind - qp->sq.max;
  } else {

  }
#line 1751
  nreq = nreq + 1;
#line 1751
  wr = wr->next;
  ldv_27027: ;
#line 1751
  if ((unsigned long )wr != (unsigned long )((struct ib_send_wr *)0)) {
#line 1752
    goto ldv_27026;
  } else {
#line 1754
    goto ldv_27028;
  }
  ldv_27028: ;
  out: 
#line 1902
  tmp___11 = ldv__builtin_expect(nreq != 0, 1L);
#line 1902
  if (tmp___11 != 0L) {
#line 1903
    __asm__  volatile   ("sfence": : : "memory");
#line 1905
    mthca_write64((((qp->sq.next_ind << qp->sq.wqe_shift) + (unsigned int )qp->send_wqe_offset) | f0) | (unsigned int )op0,
                  (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, 0);
#line 1914
    __asm__  volatile   ("": : : "memory");
  } else {

  }
#line 1917
  qp->sq.next_ind = (unsigned int )ind;
#line 1918
  qp->sq.head = qp->sq.head + (unsigned int )nreq;
#line 1920
  spin_unlock_irqrestore(& qp->sq.lock, flags);
#line 1921
  return (err);
}
}
#line 1924 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_tavor_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  int ind ;
  void *wqe ;
  void *prev_wqe ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  __u32 tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 1927
  tmp = to_mdev(ibqp->device);
#line 1927
  dev = tmp;
#line 1928
  tmp___0 = to_mqp(ibqp);
#line 1928
  qp = tmp___0;
#line 1930
  err = 0;
#line 1941
  size0 = size0;
#line 1946
  tmp___1 = spinlock_check(& qp->rq.lock);
#line 1946
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1950
  ind = (int )qp->rq.next_ind;
#line 1952
  nreq = 0;
#line 1952
  goto ldv_27053;
  ldv_27052: 
#line 1953
  tmp___2 = mthca_wq_overflow(& qp->rq, nreq, qp->ibqp.recv_cq);
#line 1953
  if (tmp___2 != 0) {
#line 1954
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "RQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->rq.head, qp->rq.tail, qp->rq.max, nreq);
#line 1958
    err = -12;
#line 1959
    *bad_wr = wr;
#line 1960
    goto out;
  } else {

  }
#line 1963
  wqe = get_recv_wqe(qp, ind);
#line 1964
  prev_wqe = qp->rq.last;
#line 1965
  qp->rq.last = wqe;
#line 1967
  ((struct mthca_next_seg *)wqe)->ee_nds = 2147483648U;
#line 1969
  ((struct mthca_next_seg *)wqe)->flags = 0U;
#line 1971
  wqe = wqe + 16UL;
#line 1972
  size = 1;
#line 1974
  tmp___3 = ldv__builtin_expect(wr->num_sge > qp->rq.max_gs, 0L);
#line 1974
  if (tmp___3 != 0L) {
#line 1975
    err = -22;
#line 1976
    *bad_wr = wr;
#line 1977
    goto out;
  } else {

  }
#line 1980
  i = 0;
#line 1980
  goto ldv_27050;
  ldv_27049: 
#line 1981
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 1982
  wqe = wqe + 16UL;
#line 1983
  size = (int )((unsigned int )size + 1U);
#line 1980
  i = i + 1;
  ldv_27050: ;
#line 1980
  if (wr->num_sge > i) {
#line 1981
    goto ldv_27049;
  } else {
#line 1983
    goto ldv_27051;
  }
  ldv_27051: 
#line 1986
  *(qp->wrid + (unsigned long )ind) = wr->wr_id;
#line 1988
  tmp___4 = __fswab32((__u32 )(size | 128));
#line 1988
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___4;
#line 1991
  if (nreq == 0) {
#line 1992
    size0 = size;
  } else {

  }
#line 1994
  ind = ind + 1;
#line 1995
  tmp___5 = ldv__builtin_expect(qp->rq.max <= ind, 0L);
#line 1995
  if (tmp___5 != 0L) {
#line 1996
    ind = ind - qp->rq.max;
  } else {

  }
#line 1998
  nreq = nreq + 1;
#line 1999
  tmp___6 = ldv__builtin_expect(nreq == 256, 0L);
#line 1999
  if (tmp___6 != 0L) {
#line 2000
    nreq = 0;
#line 2002
    __asm__  volatile   ("sfence": : : "memory");
#line 2004
    mthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | (unsigned int )size0, qp->qpn << 8,
                  dev->kar + 24UL, 0);
#line 2008
    qp->rq.next_ind = (unsigned int )ind;
#line 2009
    qp->rq.head = qp->rq.head + 256U;
  } else {

  }
#line 1952
  wr = wr->next;
  ldv_27053: ;
#line 1952
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 1953
    goto ldv_27052;
  } else {
#line 1955
    goto ldv_27054;
  }
  ldv_27054: ;
  out: 
#line 2014
  tmp___7 = ldv__builtin_expect(nreq != 0, 1L);
#line 2014
  if (tmp___7 != 0L) {
#line 2015
    __asm__  volatile   ("sfence": : : "memory");
#line 2017
    mthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | (unsigned int )size0, (qp->qpn << 8) | (u32 )nreq,
                  dev->kar + 24UL, 0);
  } else {

  }
#line 2022
  qp->rq.next_ind = (unsigned int )ind;
#line 2023
  qp->rq.head = qp->rq.head + (unsigned int )nreq;
#line 2029
  __asm__  volatile   ("": : : "memory");
#line 2031
  spin_unlock_irqrestore(& qp->rq.lock, flags);
#line 2032
  return (err);
}
}
#line 2035 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_arbel_post_send(struct ib_qp *ibqp , struct ib_send_wr *wr , struct ib_send_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  u32 dbhi ;
  void *wqe ;
  void *prev_wqe ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int i ;
  int size ;
  int size0 ;
  u32 f0 ;
  int ind ;
  u8 op0 ;
  raw_spinlock_t *tmp___1 ;
  __u32 tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  struct mthca_sqp *tmp___8 ;
  __u32 tmp___9 ;
  int tmp___10 ;
  __u32 tmp___11 ;
  long tmp___12 ;
  __u32 tmp___13 ;
  long tmp___14 ;

  {
#line 2038
  tmp = to_mdev(ibqp->device);
#line 2038
  dev = tmp;
#line 2039
  tmp___0 = to_mqp(ibqp);
#line 2039
  qp = tmp___0;
#line 2044
  err = 0;
#line 2055
  size0 = size0;
#line 2056
  f0 = f0;
#line 2058
  op0 = 0U;
#line 2060
  tmp___1 = spinlock_check(& qp->sq.lock);
#line 2060
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2064
  ind = (int )(qp->sq.head & (unsigned int )(qp->sq.max + -1));
#line 2066
  nreq = 0;
#line 2066
  goto ldv_27100;
  ldv_27099: 
#line 2067
  tmp___3 = ldv__builtin_expect(nreq == 255, 0L);
#line 2067
  if (tmp___3 != 0L) {
#line 2068
    nreq = 0;
#line 2070
    dbhi = ((((qp->sq.head & 65535U) << 8) | f0) | (unsigned int )op0) | 4278190080U;
#line 2073
    qp->sq.head = qp->sq.head + 255U;
#line 2079
    __asm__  volatile   ("sfence": : : "memory");
#line 2080
    tmp___2 = __fswab32(qp->sq.head & 65535U);
#line 2080
    *(qp->sq.db) = tmp___2;
#line 2086
    __asm__  volatile   ("sfence": : : "memory");
#line 2088
    mthca_write64(dbhi, (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, 0);
  } else {

  }
#line 2093
  tmp___4 = mthca_wq_overflow(& qp->sq, nreq, qp->ibqp.send_cq);
#line 2093
  if (tmp___4 != 0) {
#line 2094
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->sq.head, qp->sq.tail, qp->sq.max, nreq);
#line 2098
    err = -12;
#line 2099
    *bad_wr = wr;
#line 2100
    goto out;
  } else {

  }
#line 2103
  wqe = get_send_wqe(qp, ind);
#line 2104
  prev_wqe = qp->sq.last;
#line 2105
  qp->sq.last = wqe;
#line 2107
  if ((wr->send_flags & 2) != 0) {
#line 2107
    tmp___5 = 134217728U;
  } else {
#line 2107
    tmp___5 = 0U;
  }
#line 2107
  if ((wr->send_flags & 4) != 0) {
#line 2107
    tmp___6 = 33554432U;
  } else {
#line 2107
    tmp___6 = 0U;
  }
#line 2107
  if ((wr->send_flags & 16) != 0) {
#line 2107
    tmp___7 = 805306368U;
  } else {
#line 2107
    tmp___7 = 0U;
  }
#line 2107
  ((struct mthca_next_seg *)wqe)->flags = ((tmp___5 | tmp___6) | tmp___7) | 16777216U;
#line 2115
  if ((unsigned int )wr->opcode == 3U || (unsigned int )wr->opcode == 1U) {
#line 2117
    ((struct mthca_next_seg *)wqe)->imm = wr->ex.imm_data;
  } else {

  }
#line 2119
  wqe = wqe + 16UL;
#line 2120
  size = 1;
#line 2122
  switch ((int )qp->transport) {
  case 0: ;
#line 2124
  switch ((unsigned int )wr->opcode) {
  case 5: ;
  case 6: 
#line 2127
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.atomic.remote_addr, wr->wr.atomic.rkey);
#line 2129
  wqe = wqe + 16UL;
#line 2131
  set_atomic_seg((struct mthca_atomic_seg *)wqe, wr);
#line 2132
  wqe = wqe + 16UL;
#line 2133
  size = (int )((unsigned int )size + 2U);
#line 2135
  goto ldv_27081;
  case 4: ;
  case 0: ;
  case 1: 
#line 2140
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 2142
  wqe = wqe + 16UL;
#line 2143
  size = (int )((unsigned int )size + 1U);
#line 2144
  goto ldv_27081;
  default: ;
#line 2148
  goto ldv_27081;
  }
  ldv_27081: ;
#line 2151
  goto ldv_27086;
  case 1: ;
#line 2154
  switch ((unsigned int )wr->opcode) {
  case 0: ;
  case 1: 
#line 2157
  set_raddr_seg((struct mthca_raddr_seg *)wqe, wr->wr.rdma.remote_addr, wr->wr.rdma.rkey);
#line 2159
  wqe = wqe + 16UL;
#line 2160
  size = (int )((unsigned int )size + 1U);
#line 2161
  goto ldv_27090;
  default: ;
#line 2165
  goto ldv_27090;
  }
  ldv_27090: ;
#line 2168
  goto ldv_27086;
  case 2: 
#line 2171
  set_arbel_ud_seg((struct mthca_arbel_ud_seg *)wqe, wr);
#line 2172
  wqe = wqe + 48UL;
#line 2173
  size = (int )((unsigned int )size + 3U);
#line 2174
  goto ldv_27086;
  case 5: 
#line 2177
  tmp___8 = to_msqp(qp);
#line 2177
  err = build_mlx_header(dev, tmp___8, ind, wr, (struct mthca_mlx_seg *)wqe + 0xfffffffffffffff0UL,
                         (struct mthca_data_seg *)wqe);
#line 2180
  if (err != 0) {
#line 2181
    *bad_wr = wr;
#line 2182
    goto out;
  } else {

  }
#line 2184
  wqe = wqe + 16UL;
#line 2185
  size = (int )((unsigned int )size + 1U);
#line 2186
  goto ldv_27086;
  }
  ldv_27086: ;
#line 2189
  if (wr->num_sge > qp->sq.max_gs) {
#line 2190
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "too many gathers\n");
#line 2191
    err = -22;
#line 2192
    *bad_wr = wr;
#line 2193
    goto out;
  } else {

  }
#line 2196
  i = 0;
#line 2196
  goto ldv_27095;
  ldv_27094: 
#line 2197
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 2198
  wqe = wqe + 16UL;
#line 2199
  size = (int )((unsigned int )size + 1U);
#line 2196
  i = i + 1;
  ldv_27095: ;
#line 2196
  if (wr->num_sge > i) {
#line 2197
    goto ldv_27094;
  } else {
#line 2199
    goto ldv_27096;
  }
  ldv_27096: ;
#line 2203
  if ((unsigned int )qp->transport == 5U) {
#line 2204
    ((struct mthca_data_seg *)wqe)->byte_count = 67108992U;
#line 2206
    *((u32 *)wqe + 1UL) = 0U;
#line 2207
    wqe = wqe + 16UL;
#line 2208
    size = (int )((unsigned int )size + 1U);
  } else {

  }
#line 2211
  *(qp->wrid + (unsigned long )(qp->rq.max + ind)) = wr->wr_id;
#line 2213
  if ((unsigned int )wr->opcode > 6U) {
#line 2214
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "opcode invalid\n");
#line 2215
    err = -22;
#line 2216
    *bad_wr = wr;
#line 2217
    goto out;
  } else {

  }
#line 2220
  tmp___9 = __fswab32((__u32 )(((ind << qp->sq.wqe_shift) + qp->send_wqe_offset) | (int )mthca_opcode[(unsigned int )wr->opcode]));
#line 2220
  ((struct mthca_next_seg *)prev_wqe)->nda_op = tmp___9;
#line 2224
  __asm__  volatile   ("sfence": : : "memory");
#line 2225
  if (wr->send_flags & 1) {
#line 2225
    tmp___10 = 64;
  } else {
#line 2225
    tmp___10 = 0;
  }
#line 2225
  tmp___11 = __fswab32((__u32 )((size | 128) | tmp___10));
#line 2225
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = tmp___11;
#line 2230
  if (nreq == 0) {
#line 2231
    size0 = size;
#line 2232
    op0 = mthca_opcode[(unsigned int )wr->opcode];
#line 2233
    if (wr->send_flags & 1) {
#line 2233
      f0 = 32U;
    } else {
#line 2233
      f0 = 0U;
    }
  } else {

  }
#line 2237
  ind = ind + 1;
#line 2238
  tmp___12 = ldv__builtin_expect(qp->sq.max <= ind, 0L);
#line 2238
  if (tmp___12 != 0L) {
#line 2239
    ind = ind - qp->sq.max;
  } else {

  }
#line 2066
  nreq = nreq + 1;
#line 2066
  wr = wr->next;
  ldv_27100: ;
#line 2066
  if ((unsigned long )wr != (unsigned long )((struct ib_send_wr *)0)) {
#line 2067
    goto ldv_27099;
  } else {
#line 2069
    goto ldv_27101;
  }
  ldv_27101: ;
  out: 
#line 2243
  tmp___14 = ldv__builtin_expect(nreq != 0, 1L);
#line 2243
  if (tmp___14 != 0L) {
#line 2244
    dbhi = (((unsigned int )(nreq << 24) | ((qp->sq.head & 65535U) << 8)) | f0) | (unsigned int )op0;
#line 2246
    qp->sq.head = qp->sq.head + (unsigned int )nreq;
#line 2252
    __asm__  volatile   ("sfence": : : "memory");
#line 2253
    tmp___13 = __fswab32(qp->sq.head & 65535U);
#line 2253
    *(qp->sq.db) = tmp___13;
#line 2259
    __asm__  volatile   ("sfence": : : "memory");
#line 2261
    mthca_write64(dbhi, (qp->qpn << 8) | (u32 )size0, dev->kar + 16UL, 0);
  } else {

  }
#line 2269
  __asm__  volatile   ("": : : "memory");
#line 2271
  spin_unlock_irqrestore(& qp->sq.lock, flags);
#line 2272
  return (err);
}
}
#line 2275 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_arbel_post_receive(struct ib_qp *ibqp , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_qp *qp ;
  struct mthca_qp *tmp___0 ;
  unsigned long flags ;
  int err ;
  int nreq ;
  int ind ;
  int i ;
  void *wqe ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  __u32 tmp___5 ;
  long tmp___6 ;

  {
#line 2278
  tmp = to_mdev(ibqp->device);
#line 2278
  dev = tmp;
#line 2279
  tmp___0 = to_mqp(ibqp);
#line 2279
  qp = tmp___0;
#line 2281
  err = 0;
#line 2287
  tmp___1 = spinlock_check(& qp->rq.lock);
#line 2287
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2291
  ind = (int )(qp->rq.head & (unsigned int )(qp->rq.max + -1));
#line 2293
  nreq = 0;
#line 2293
  goto ldv_27123;
  ldv_27122: 
#line 2294
  tmp___2 = mthca_wq_overflow(& qp->rq, nreq, qp->ibqp.recv_cq);
#line 2294
  if (tmp___2 != 0) {
#line 2295
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "RQ %06x full (%u head, %u tail, %d max, %d nreq)\n",
            qp->qpn, qp->rq.head, qp->rq.tail, qp->rq.max, nreq);
#line 2299
    err = -12;
#line 2300
    *bad_wr = wr;
#line 2301
    goto out;
  } else {

  }
#line 2304
  wqe = get_recv_wqe(qp, ind);
#line 2306
  ((struct mthca_next_seg *)wqe)->flags = 0U;
#line 2308
  wqe = wqe + 16UL;
#line 2310
  tmp___3 = ldv__builtin_expect(wr->num_sge > qp->rq.max_gs, 0L);
#line 2310
  if (tmp___3 != 0L) {
#line 2311
    err = -22;
#line 2312
    *bad_wr = wr;
#line 2313
    goto out;
  } else {

  }
#line 2316
  i = 0;
#line 2316
  goto ldv_27120;
  ldv_27119: 
#line 2317
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 2318
  wqe = wqe + 16UL;
#line 2316
  i = i + 1;
  ldv_27120: ;
#line 2316
  if (wr->num_sge > i) {
#line 2317
    goto ldv_27119;
  } else {
#line 2319
    goto ldv_27121;
  }
  ldv_27121: ;
#line 2321
  if (qp->rq.max_gs > i) {
#line 2322
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 2324
  *(qp->wrid + (unsigned long )ind) = wr->wr_id;
#line 2326
  ind = ind + 1;
#line 2327
  tmp___4 = ldv__builtin_expect(qp->rq.max <= ind, 0L);
#line 2327
  if (tmp___4 != 0L) {
#line 2328
    ind = ind - qp->rq.max;
  } else {

  }
#line 2293
  nreq = nreq + 1;
#line 2293
  wr = wr->next;
  ldv_27123: ;
#line 2293
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 2294
    goto ldv_27122;
  } else {
#line 2296
    goto ldv_27124;
  }
  ldv_27124: ;
  out: 
#line 2331
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 2331
  if (tmp___6 != 0L) {
#line 2332
    qp->rq.head = qp->rq.head + (unsigned int )nreq;
#line 2338
    __asm__  volatile   ("sfence": : : "memory");
#line 2339
    tmp___5 = __fswab32(qp->rq.head & 65535U);
#line 2339
    *(qp->rq.db) = tmp___5;
  } else {

  }
#line 2342
  spin_unlock_irqrestore(& qp->rq.lock, flags);
#line 2343
  return (err);
}
}
#line 2346 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void mthca_free_err_wqe(struct mthca_dev *dev , struct mthca_qp *qp , int is_send ,
                        int index , int *dbd , __be32 *new_wqe ) 
{ struct mthca_next_seg *next ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2355
  if ((unsigned long )qp->ibqp.srq != (unsigned long )((struct ib_srq *)0) && is_send == 0) {
#line 2356
    *new_wqe = 0U;
#line 2357
    return;
  } else {

  }
#line 2360
  if (is_send != 0) {
#line 2361
    tmp = get_send_wqe(qp, index);
#line 2361
    next = (struct mthca_next_seg *)tmp;
  } else {
#line 2363
    tmp___0 = get_recv_wqe(qp, index);
#line 2363
    next = (struct mthca_next_seg *)tmp___0;
  }
#line 2365
  *dbd = (int )next->ee_nds < 0;
#line 2366
  if ((next->ee_nds & 1056964608U) != 0U) {
#line 2367
    *new_wqe = (next->nda_op & 3238002687U) | (next->ee_nds & 1056964608U);
  } else {
#line 2370
    *new_wqe = 0U;
  }
#line 2371
  return;
}
}
#line 2373 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int mthca_init_qp_table(struct mthca_dev *dev ) 
{ int err ;
  int i ;
  struct lock_class_key __key ;

  {
#line 2378
  spinlock_check(& dev->qp_table.lock);
#line 2378
  __raw_spin_lock_init(& dev->qp_table.lock.ldv_5961.rlock, "&(&dev->qp_table.lock)->rlock",
                       & __key);
#line 2384
  dev->qp_table.sqp_start = (dev->limits.reserved_qps + 1) & -2;
#line 2385
  err = mthca_alloc_init(& dev->qp_table.alloc, (u32 )dev->limits.num_qps, 16777215U,
                         (u32 )(dev->qp_table.sqp_start + 4));
#line 2390
  if (err != 0) {
#line 2391
    return (err);
  } else {

  }
#line 2393
  err = mthca_array_init(& dev->qp_table.qp, dev->limits.num_qps);
#line 2395
  if (err != 0) {
#line 2396
    mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2397
    return (err);
  } else {

  }
#line 2400
  i = 0;
#line 2400
  goto ldv_27142;
  ldv_27141: 
#line 2401
  err = mthca_CONF_SPECIAL_QP(dev, i != 0, (u32 )(dev->qp_table.sqp_start + i * 2));
#line 2403
  if (err != 0) {
#line 2404
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "CONF_SPECIAL_QP returned %d, aborting.\n",
             err);
#line 2406
    goto err_out;
  } else {

  }
#line 2400
  i = i + 1;
  ldv_27142: ;
#line 2400
  if (i <= 1) {
#line 2401
    goto ldv_27141;
  } else {
#line 2403
    goto ldv_27143;
  }
  ldv_27143: ;
#line 2409
  return (0);
  err_out: 
#line 2412
  i = 0;
#line 2412
  goto ldv_27145;
  ldv_27144: 
#line 2413
  mthca_CONF_SPECIAL_QP(dev, i, 0U);
#line 2412
  i = i + 1;
  ldv_27145: ;
#line 2412
  if (i <= 1) {
#line 2413
    goto ldv_27144;
  } else {
#line 2415
    goto ldv_27146;
  }
  ldv_27146: 
#line 2415
  mthca_array_cleanup(& dev->qp_table.qp, dev->limits.num_qps);
#line 2416
  mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2418
  return (err);
}
}
#line 2421 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void mthca_cleanup_qp_table(struct mthca_dev *dev ) 
{ int i ;

  {
#line 2425
  i = 0;
#line 2425
  goto ldv_27152;
  ldv_27151: 
#line 2426
  mthca_CONF_SPECIAL_QP(dev, i, 0U);
#line 2425
  i = i + 1;
  ldv_27152: ;
#line 2425
  if (i <= 1) {
#line 2426
    goto ldv_27151;
  } else {
#line 2428
    goto ldv_27153;
  }
  ldv_27153: 
#line 2428
  mthca_array_cleanup(& dev->qp_table.qp, dev->limits.num_qps);
#line 2429
  mthca_alloc_cleanup(& dev->qp_table.alloc);
#line 2430
  return;
}
}
#line 2432 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_113(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2437
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2439
  mutex_lock(ldv_func_arg1);
#line 2440
  return;
}
}
#line 2442 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2447
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2449
  mutex_unlock(ldv_func_arg1);
#line 2450
  return;
}
}
#line 2452 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2457
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2459
  mutex_lock(ldv_func_arg1);
#line 2460
  return;
}
}
#line 2462 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2467
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2469
  mutex_unlock(ldv_func_arg1);
#line 2470
  return;
}
}
#line 2472 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2477
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2479
  mutex_lock(ldv_func_arg1);
#line 2480
  return;
}
}
#line 2482 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2487
  tmp = mutex_trylock(ldv_func_arg1);
#line 2487
  ldv_func_res = tmp;
#line 2489
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2489
  return (tmp___0);
#line 2491
  return (ldv_func_res);
}
}
#line 2494 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2499
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2501
  mutex_unlock(ldv_func_arg1);
#line 2502
  return;
}
}
#line 2504 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2509
  ldv_mutex_lock_mutex_of_mthca_qp(ldv_func_arg1);
#line 2511
  mutex_lock(ldv_func_arg1);
#line 2512
  return;
}
}
#line 2514 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2519
  ldv_mutex_unlock_mutex_of_mthca_qp(ldv_func_arg1);
#line 2521
  mutex_unlock(ldv_func_arg1);
#line 2522
  return;
}
}
#line 2524 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2529
  ldv_mutex_lock_mutex_of_mthca_qp(ldv_func_arg1);
#line 2531
  mutex_lock(ldv_func_arg1);
#line 2532
  return;
}
}
#line 2534 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_qp.c.prepared"
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2539
  ldv_mutex_unlock_mutex_of_mthca_qp(ldv_func_arg1);
#line 2541
  mutex_unlock(ldv_func_arg1);
#line 2542
  return;
}
}
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 

  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_138(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) ;
#line 446 "include/rdma/ib_verbs.h"
extern int ib_rate_to_mult(enum ib_rate  ) ;
#line 460
extern enum ib_rate mult_to_ib_rate(int  ) ;
#line 50 "include/rdma/ib_cache.h"
extern int ib_get_cached_gid(struct ib_device * , u8  , int  , union ib_gid * ) ;
#line 561 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_create_ah(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_ah_attr *ah_attr ,
                    struct mthca_ah *ah ) ;
#line 565
int mthca_destroy_ah(struct mthca_dev *dev , struct mthca_ah *ah ) ;
#line 568
int mthca_ah_query(struct ib_ah *ibah , struct ib_ah_attr *attr ) ;
#line 189 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
static enum ib_rate memfree_rate_to_ib(u8 mthca_rate , u8 port_rate ) 
{ enum ib_rate tmp ;
  enum ib_rate tmp___0 ;
  enum ib_rate tmp___1 ;
  enum ib_rate tmp___2 ;

  {
#line 191
  switch ((int )mthca_rate) {
  case 2: 
#line 193
  tmp = mult_to_ib_rate((int )port_rate >> 3);
#line 193
  return (tmp);
  case 1: 
#line 195
  tmp___0 = mult_to_ib_rate((int )port_rate >> 2);
#line 195
  return (tmp___0);
  case 3: 
#line 197
  tmp___1 = mult_to_ib_rate((int )port_rate >> 1);
#line 197
  return (tmp___1);
  case 0: ;
  default: 
#line 200
  tmp___2 = mult_to_ib_rate((int )port_rate);
#line 200
  return (tmp___2);
  }
}
}
#line 204 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
static enum ib_rate tavor_rate_to_ib(u8 mthca_rate , u8 port_rate ) 
{ enum ib_rate tmp ;

  {
#line 206
  switch ((int )mthca_rate) {
  case 1: ;
#line 207
  return (2);
  case 3: ;
#line 208
  return (5);
  case 2: ;
#line 209
  return (3);
  default: 
#line 210
  tmp = mult_to_ib_rate((int )port_rate);
#line 210
  return (tmp);
  }
}
}
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
enum ib_rate mthca_rate_to_ib(struct mthca_dev *dev , u8 mthca_rate , u8 port ) 
{ enum ib_rate tmp ;
  enum ib_rate tmp___0 ;
  int tmp___1 ;

  {
#line 216
  tmp___1 = mthca_is_memfree(dev);
#line 216
  if (tmp___1 != 0) {
#line 218
    if ((unsigned int )dev->limits.stat_rate_support == 3U && (unsigned int )mthca_rate != 0U) {
#line 219
      return (2);
    } else {

    }
#line 221
    tmp = memfree_rate_to_ib((int )mthca_rate, (int )dev->rate[(int )port + -1]);
#line 221
    return (tmp);
  } else {
#line 223
    tmp___0 = tavor_rate_to_ib((int )mthca_rate, (int )dev->rate[(int )port + -1]);
#line 223
    return (tmp___0);
  }
}
}
#line 226 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
static u8 ib_rate_to_memfree(u8 req_rate , u8 cur_rate ) 
{ 

  {
#line 228
  if ((int )cur_rate <= (int )req_rate) {
#line 229
    return (0U);
  } else {

  }
#line 235
  switch (((int )cur_rate + -1) / (int )req_rate) {
  case 0: ;
#line 236
  return (0U);
  case 1: ;
#line 237
  return (3U);
  case 2: ;
  case 3: ;
#line 239
  return (1U);
  default: ;
#line 240
  return (2U);
  }
}
}
#line 244 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
static u8 ib_rate_to_tavor(u8 static_rate ) 
{ 

  {
#line 246
  switch ((int )static_rate) {
  case 2: ;
#line 247
  return (1U);
  case 5: ;
#line 248
  return (3U);
  case 3: ;
#line 249
  return (2U);
  default: ;
#line 250
  return (0U);
  }
}
}
#line 254 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
u8 mthca_get_rate(struct mthca_dev *dev , int static_rate , u8 port ) 
{ u8 rate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 258
  if (static_rate == 0) {
#line 259
    return (0U);
  } else {
#line 258
    tmp = ib_rate_to_mult((enum ib_rate )static_rate);
#line 258
    if (tmp >= (int )dev->rate[(int )port + -1]) {
#line 259
      return (0U);
    } else {

    }
  }
#line 261
  tmp___1 = mthca_is_memfree(dev);
#line 261
  if (tmp___1 != 0) {
#line 262
    tmp___0 = ib_rate_to_mult((enum ib_rate )static_rate);
#line 262
    rate = ib_rate_to_memfree((int )((u8 )tmp___0), (int )dev->rate[(int )port + -1]);
  } else {
#line 265
    rate = ib_rate_to_tavor((int )((u8 )static_rate));
  }
#line 267
  if ((((int )dev->limits.stat_rate_support >> (int )rate) & 1) == 0) {
#line 268
    rate = 1U;
  } else {

  }
#line 270
  return (rate);
}
}
#line 273 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_create_ah(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_ah_attr *ah_attr ,
                    struct mthca_ah *ah ) 
{ u32 index ;
  struct mthca_av *av ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  __u32 tmp___4 ;
  __u16 tmp___5 ;
  u8 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  size_t __len ;
  void *__ret ;
  int j ;
  __u32 tmp___9 ;

  {
#line 278
  index = 4294967295U;
#line 279
  av = 0;
#line 281
  ah->type = 1;
#line 283
  tmp___2 = mthca_is_memfree(dev);
#line 283
  if (tmp___2 != 0) {
#line 284
    tmp = kmalloc(32UL, 32U);
#line 284
    ah->av = (struct mthca_av *)tmp;
#line 285
    if ((unsigned long )ah->av == (unsigned long )((struct mthca_av *)0)) {
#line 286
      return (-12);
    } else {

    }
#line 288
    ah->type = 2;
#line 289
    av = ah->av;
  } else {
#line 290
    tmp___1 = atomic_read((atomic_t const   *)(& pd->sqp_count));
#line 290
    if (tmp___1 == 0 && (dev->mthca_flags & 2UL) == 0UL) {
#line 292
      index = mthca_alloc(& dev->av_table.alloc);
#line 295
      if (index == 4294967295U) {
#line 296
        goto on_hca_fail;
      } else {

      }
#line 298
      tmp___0 = kmalloc(32UL, 32U);
#line 298
      av = (struct mthca_av *)tmp___0;
#line 299
      if ((unsigned long )av == (unsigned long )((struct mthca_av *)0)) {
#line 300
        goto on_hca_fail;
      } else {

      }
#line 302
      ah->type = 0;
#line 303
      ah->avdma = dev->av_table.ddr_av_base + (u64 )(index * 32U);
    } else {

    }
  }
  on_hca_fail: ;
#line 308
  if ((unsigned int )ah->type == 1U) {
#line 309
    tmp___3 = dma_pool_alloc(dev->av_table.pool, 32U, & ah->avdma);
#line 309
    ah->av = (struct mthca_av *)tmp___3;
#line 311
    if ((unsigned long )ah->av == (unsigned long )((struct mthca_av *)0)) {
#line 312
      return (-12);
    } else {

    }
#line 314
    av = ah->av;
  } else {

  }
#line 317
  ah->key = pd->ntmr.ibmr.lkey;
#line 319
  memset((void *)av, 0, 32UL);
#line 321
  tmp___4 = __fswab32(pd->pd_num | (u32 )((int )ah_attr->port_num << 24));
#line 321
  av->port_pd = tmp___4;
#line 322
  av->g_slid = ah_attr->src_path_bits;
#line 323
  tmp___5 = __fswab16((int )ah_attr->dlid);
#line 323
  av->dlid = tmp___5;
#line 324
  tmp___6 = mthca_get_rate(dev, (int )ah_attr->static_rate, (int )ah_attr->port_num);
#line 324
  av->msg_sr = (u8 )((unsigned int )tmp___6 | 48U);
#line 326
  tmp___7 = __fswab32((__u32 )((int )ah_attr->sl << 28));
#line 326
  av->sl_tclass_flowlabel = tmp___7;
#line 327
  if ((int )ah_attr->ah_flags & 1) {
#line 328
    av->g_slid = (u8 )((unsigned int )av->g_slid | 128U);
#line 329
    av->gid_index = (int )((u8 )((int )ah_attr->port_num + -1)) * (int )((u8 )dev->limits.gid_table_len) + (int )ah_attr->grh.sgid_index;
#line 331
    av->hop_limit = ah_attr->grh.hop_limit;
#line 332
    tmp___8 = __fswab32((u32 )((int )ah_attr->grh.traffic_class << 20) | ah_attr->grh.flow_label);
#line 332
    av->sl_tclass_flowlabel = av->sl_tclass_flowlabel | tmp___8;
#line 335
    __len = 16UL;
#line 335
    if (__len > 63UL) {
#line 335
      __ret = __memcpy((void *)(& av->dgid), (void const   *)(& ah_attr->grh.dgid.raw),
                       __len);
    } else {
#line 335
      __ret = __builtin_memcpy((void *)(& av->dgid), (void const   *)(& ah_attr->grh.dgid.raw),
                               __len);
    }
  } else {
#line 338
    av->dgid[3] = 33554432U;
  }
#line 341
  if (0) {
#line 344
    if (mthca_debug_level != 0) {
#line 344
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "Created UDAV at %p/%08lx:\n",
                 av, (unsigned long )ah->avdma);
    } else {

    }
#line 346
    j = 0;
#line 346
    goto ldv_21910;
    ldv_21909: 
#line 347
    tmp___9 = __fswab32(*((__be32 *)av + (unsigned long )j));
#line 347
    printk("\017  [%2x] %08x\n", j * 4, tmp___9);
#line 346
    j = j + 1;
    ldv_21910: ;
#line 346
    if (j <= 7) {
#line 347
      goto ldv_21909;
    } else {
#line 349
      goto ldv_21911;
    }
    ldv_21911: ;
  } else {

  }
#line 351
  if ((unsigned int )ah->type == 0U) {
#line 352
    memcpy_toio((void volatile   *)dev->av_table.av_map + (unsigned long )(index * 32U),
                (void const   *)av, 32UL);
#line 354
    kfree((void const   *)av);
  } else {

  }
#line 357
  return (0);
}
}
#line 360 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_destroy_ah(struct mthca_dev *dev , struct mthca_ah *ah ) 
{ 

  {
#line 362
  switch ((unsigned int )ah->type) {
  case 0: 
#line 364
  mthca_free(& dev->av_table.alloc, (u32 )((ah->avdma - dev->av_table.ddr_av_base) / 32ULL));
#line 367
  goto ldv_21917;
  case 1: 
#line 370
  dma_pool_free(dev->av_table.pool, (void *)ah->av, ah->avdma);
#line 371
  goto ldv_21917;
  case 2: 
#line 374
  kfree((void const   *)ah->av);
#line 375
  goto ldv_21917;
  }
  ldv_21917: ;
#line 378
  return (0);
}
}
#line 381 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_ah_grh_present(struct mthca_ah *ah ) 
{ 

  {
#line 383
  return ((int )((signed char )(ah->av)->g_slid) < 0);
}
}
#line 386 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_read_ah(struct mthca_dev *dev , struct mthca_ah *ah , struct ib_ud_header *header ) 
{ __u32 tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  size_t __len ;
  void *__ret ;
  int tmp___3 ;

  {
#line 389
  if ((unsigned int )ah->type == 0U) {
#line 390
    return (-22);
  } else {

  }
#line 392
  tmp = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 392
  header->lrh.service_level = (u8 )(tmp >> 28);
#line 393
  header->lrh.destination_lid = (ah->av)->dlid;
#line 394
  tmp___0 = __fswab16((int )(ah->av)->g_slid & 127);
#line 394
  header->lrh.source_lid = tmp___0;
#line 395
  tmp___3 = mthca_ah_grh_present(ah);
#line 395
  if (tmp___3 != 0) {
#line 396
    tmp___1 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 396
    header->grh.traffic_class = (u8 )(tmp___1 >> 20);
#line 398
    header->grh.flow_label = (ah->av)->sl_tclass_flowlabel & 4294905600U;
#line 400
    header->grh.hop_limit = (ah->av)->hop_limit;
#line 401
    tmp___2 = __fswab32((ah->av)->port_pd);
#line 401
    ib_get_cached_gid(& dev->ib_dev, (int )((u8 )(tmp___2 >> 24)), (int )(ah->av)->gid_index % dev->limits.gid_table_len,
                      & header->grh.source_gid);
#line 405
    __len = 16UL;
#line 405
    if (__len > 63UL) {
#line 405
      __ret = __memcpy((void *)(& header->grh.destination_gid.raw), (void const   *)(& (ah->av)->dgid),
                       __len);
    } else {
#line 405
      __ret = __builtin_memcpy((void *)(& header->grh.destination_gid.raw), (void const   *)(& (ah->av)->dgid),
                               __len);
    }
  } else {

  }
#line 409
  return (0);
}
}
#line 412 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_ah_query(struct ib_ah *ibah , struct ib_ah_attr *attr ) 
{ struct mthca_ah *ah ;
  struct mthca_ah *tmp ;
  struct mthca_dev *dev ;
  struct mthca_dev *tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  enum ib_rate tmp___4 ;
  int tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  size_t __len ;
  void *__ret ;

  {
#line 414
  tmp = to_mah(ibah);
#line 414
  ah = tmp;
#line 415
  tmp___0 = to_mdev(ibah->device);
#line 415
  dev = tmp___0;
#line 418
  if ((unsigned int )ah->type == 0U) {
#line 419
    return (-38);
  } else {

  }
#line 421
  memset((void *)attr, 0, 32UL);
#line 422
  tmp___1 = __fswab16((int )(ah->av)->dlid);
#line 422
  attr->dlid = tmp___1;
#line 423
  tmp___2 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 423
  attr->sl = (u8 )(tmp___2 >> 28);
#line 424
  tmp___3 = __fswab32((ah->av)->port_pd);
#line 424
  attr->port_num = (u8 )(tmp___3 >> 24);
#line 425
  tmp___4 = mthca_rate_to_ib(dev, (int )(ah->av)->msg_sr & 7, (int )attr->port_num);
#line 425
  attr->static_rate = (u8 )tmp___4;
#line 427
  attr->src_path_bits = (unsigned int )(ah->av)->g_slid & 127U;
#line 428
  tmp___5 = mthca_ah_grh_present(ah);
#line 428
  attr->ah_flags = tmp___5 != 0;
#line 430
  if ((unsigned int )attr->ah_flags != 0U) {
#line 431
    tmp___6 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 431
    attr->grh.traffic_class = (u8 )(tmp___6 >> 20);
#line 433
    tmp___7 = __fswab32((ah->av)->sl_tclass_flowlabel);
#line 433
    attr->grh.flow_label = tmp___7 & 1048575U;
#line 435
    attr->grh.hop_limit = (ah->av)->hop_limit;
#line 436
    attr->grh.sgid_index = (u8 )((int )((signed char )(ah->av)->gid_index) & (int )((signed char )((unsigned int )((unsigned char )dev->limits.gid_table_len) + 255U)));
#line 438
    __len = 16UL;
#line 438
    if (__len > 63UL) {
#line 438
      __ret = __memcpy((void *)(& attr->grh.dgid.raw), (void const   *)(& (ah->av)->dgid),
                       __len);
    } else {
#line 438
      __ret = __builtin_memcpy((void *)(& attr->grh.dgid.raw), (void const   *)(& (ah->av)->dgid),
                               __len);
    }
  } else {

  }
#line 441
  return (0);
}
}
#line 444 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int mthca_init_av_table(struct mthca_dev *dev ) 
{ int err ;
  int tmp ;

  {
#line 448
  tmp = mthca_is_memfree(dev);
#line 448
  if (tmp != 0) {
#line 449
    return (0);
  } else {

  }
#line 451
  err = mthca_alloc_init(& dev->av_table.alloc, (u32 )dev->av_table.num_ddr_avs, (u32 )(dev->av_table.num_ddr_avs + -1),
                         0U);
#line 455
  if (err != 0) {
#line 456
    return (err);
  } else {

  }
#line 458
  dev->av_table.pool = dma_pool_create("mthca_av", & (dev->pdev)->dev, 32UL, 32UL,
                                       0UL);
#line 461
  if ((unsigned long )dev->av_table.pool == (unsigned long )((struct dma_pool *)0)) {
#line 462
    goto out_free_alloc;
  } else {

  }
#line 464
  if ((dev->mthca_flags & 2UL) == 0UL) {
#line 465
    dev->av_table.av_map = ioremap(((dev->pdev)->resource[4].start + dev->av_table.ddr_av_base) - dev->ddr_start,
                                   (unsigned long )(dev->av_table.num_ddr_avs * 32));
#line 470
    if ((unsigned long )dev->av_table.av_map == (unsigned long )((void *)0)) {
#line 471
      goto out_free_pool;
    } else {

    }
  } else {
#line 473
    dev->av_table.av_map = 0;
  }
#line 475
  return (0);
  out_free_pool: 
#line 478
  dma_pool_destroy(dev->av_table.pool);
  out_free_alloc: 
#line 481
  mthca_alloc_cleanup(& dev->av_table.alloc);
#line 482
  return (-12);
}
}
#line 485 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void mthca_cleanup_av_table(struct mthca_dev *dev ) 
{ int tmp ;

  {
#line 487
  tmp = mthca_is_memfree(dev);
#line 487
  if (tmp != 0) {
#line 488
    return;
  } else {

  }
#line 490
  if ((unsigned long )dev->av_table.av_map != (unsigned long )((void *)0)) {
#line 491
    iounmap((void volatile   *)dev->av_table.av_map);
  } else {

  }
#line 492
  dma_pool_destroy(dev->av_table.pool);
#line 493
  mthca_alloc_cleanup(& dev->av_table.alloc);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 501
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 503
  mutex_lock(ldv_func_arg1);
#line 504
  return;
}
}
#line 506 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 511
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 513
  mutex_unlock(ldv_func_arg1);
#line 514
  return;
}
}
#line 516 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 521
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 523
  mutex_lock(ldv_func_arg1);
#line 524
  return;
}
}
#line 526 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
int ldv_mutex_trylock_138(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 531
  tmp = mutex_trylock(ldv_func_arg1);
#line 531
  ldv_func_res = tmp;
#line 533
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 533
  return (tmp___0);
#line 535
  return (ldv_func_res);
}
}
#line 538 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_av.c.prepared"
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 543
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 545
  mutex_unlock(ldv_func_arg1);
#line 546
  return;
}
}
#line 60 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_148(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_150(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) ;
#line 99
void ldv_mutex_lock_mutex_of_mthca_mcg_table(struct mutex *lock ) ;
#line 103
void ldv_mutex_unlock_mutex_of_mthca_mcg_table(struct mutex *lock ) ;
#line 573 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_multicast_attach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) ;
#line 574
int mthca_multicast_detach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) ;
#line 166 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
static u8 const   zero_gid[16U]  ;
#line 183 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
static int find_mgm(struct mthca_dev *dev , u8 *gid , struct mthca_mailbox *mgm_mailbox ,
                    u16 *hash , int *prev , int *index ) 
{ struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u8 *mgid ;
  int err ;
  long tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  int tmp___1 ;
  __u32 tmp___2 ;

  {
#line 188
  mgm = (struct mthca_mgm *)mgm_mailbox->buf;
#line 192
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 193
  tmp = IS_ERR((void const   *)mailbox);
#line 193
  if (tmp != 0L) {
#line 194
    return (-12);
  } else {

  }
#line 195
  mgid = (u8 *)mailbox->buf;
#line 197
  __len = 16UL;
#line 197
  if (__len > 63UL) {
#line 197
    __ret = __memcpy((void *)mgid, (void const   *)gid, __len);
  } else {
#line 197
    __ret = __builtin_memcpy((void *)mgid, (void const   *)gid, __len);
  }
#line 199
  err = mthca_MGID_HASH(dev, mailbox, hash);
#line 200
  if (err != 0) {
#line 201
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGID_HASH failed (%d)\n",
            err);
#line 202
    goto out;
  } else {

  }
#line 208
  *index = (int )*hash;
#line 209
  *prev = -1;
  ldv_22185: 
#line 212
  err = mthca_READ_MGM(dev, *index, mgm_mailbox);
#line 213
  if (err != 0) {
#line 214
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed (%d)\n",
            err);
#line 215
    goto out;
  } else {

  }
#line 218
  tmp___0 = memcmp((void const   *)(& mgm->gid), (void const   *)(& zero_gid), 16UL);
#line 218
  if (tmp___0 == 0) {
#line 219
    if (*index != (int )*hash) {
#line 220
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "Found zero MGID in AMGM.\n");
#line 221
      err = -22;
    } else {

    }
#line 223
    goto out;
  } else {

  }
#line 226
  tmp___1 = memcmp((void const   *)(& mgm->gid), (void const   *)gid, 16UL);
#line 226
  if (tmp___1 == 0) {
#line 227
    goto out;
  } else {

  }
#line 229
  *prev = *index;
#line 230
  tmp___2 = __fswab32(mgm->next_gid_index);
#line 230
  *index = (int )(tmp___2 >> 6);
#line 231
  if (*index != 0) {
#line 232
    goto ldv_22185;
  } else {
#line 234
    goto ldv_22186;
  }
  ldv_22186: 
#line 233
  *index = -1;
  out: 
#line 236
  mthca_free_mailbox(dev, mailbox);
#line 237
  return (err);
}
}
#line 240 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
int mthca_multicast_attach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u16 hash ;
  int index ;
  int prev ;
  int link ;
  int i ;
  int err ;
  long tmp___0 ;
  long tmp___1 ;
  size_t __len ;
  void *__ret ;
  u32 tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  long tmp___7 ;

  {
#line 242
  tmp = to_mdev(ibqp->device);
#line 242
  dev = tmp;
#line 247
  link = 0;
#line 251
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 252
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 252
  if (tmp___1 != 0L) {
#line 253
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 253
    return ((int )tmp___0);
  } else {

  }
#line 254
  mgm = (struct mthca_mgm *)mailbox->buf;
#line 256
  ldv_mutex_lock_150(& dev->mcg_table.mutex);
#line 258
  err = find_mgm(dev, (u8 *)(& gid->raw), mailbox, & hash, & prev, & index);
#line 259
  if (err != 0) {
#line 260
    goto out;
  } else {

  }
#line 262
  if (index != -1) {
#line 263
    tmp___3 = memcmp((void const   *)(& mgm->gid), (void const   *)(& zero_gid), 16UL);
#line 263
    if (tmp___3 == 0) {
#line 264
      __len = 16UL;
#line 264
      if (__len > 63UL) {
#line 264
        __ret = __memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw), __len);
      } else {
#line 264
        __ret = __builtin_memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw),
                                 __len);
      }
    } else {
#line 266
      link = 1;
#line 268
      tmp___2 = mthca_alloc(& dev->mcg_table.alloc);
#line 268
      index = (int )tmp___2;
#line 269
      if (index == -1) {
#line 270
        dev_err((struct device  const  *)(& (dev->pdev)->dev), "No AMGM entries left\n");
#line 271
        err = -12;
#line 272
        goto out;
      } else {

      }
#line 275
      err = mthca_READ_MGM(dev, index, mailbox);
#line 276
      if (err != 0) {
#line 277
        dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed (%d)\n",
                err);
#line 278
        goto out;
      } else {

      }
#line 280
      memset((void *)mgm, 0, 256UL);
#line 281
      __len___0 = 16UL;
#line 281
      if (__len___0 > 63UL) {
#line 281
        __ret___0 = __memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw), __len___0);
      } else {
#line 281
        __ret___0 = __builtin_memcpy((void *)(& mgm->gid), (void const   *)(& gid->raw),
                                     __len___0);
      }
    }
  } else {

  }
#line 284
  i = 0;
#line 284
  goto ldv_22210;
  ldv_22209: 
#line 285
  tmp___5 = __fswab32(ibqp->qp_num | 2147483648U);
#line 285
  if (mgm->qp[i] == tmp___5) {
#line 286
    if (mthca_debug_level != 0) {
#line 286
      dev_printk("\017", (struct device  const  *)(& (dev->pdev)->dev), "QP %06x already a member of MGM\n",
                 ibqp->qp_num);
    } else {

    }
#line 288
    err = 0;
#line 289
    goto out;
  } else
#line 290
  if ((mgm->qp[i] & 128U) == 0U) {
#line 291
    tmp___4 = __fswab32(ibqp->qp_num | 2147483648U);
#line 291
    mgm->qp[i] = tmp___4;
#line 292
    goto ldv_22208;
  } else {

  }
#line 284
  i = i + 1;
  ldv_22210: ;
#line 284
  if (i <= 55) {
#line 285
    goto ldv_22209;
  } else {
#line 287
    goto ldv_22208;
  }
  ldv_22208: ;
#line 295
  if (i == 56) {
#line 296
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGM at index %x is full.\n",
            index);
#line 297
    err = -12;
#line 298
    goto out;
  } else {

  }
#line 301
  err = mthca_WRITE_MGM(dev, index, mailbox);
#line 302
  if (err != 0) {
#line 303
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM failed %d\n",
            err);
#line 304
    err = -22;
#line 305
    goto out;
  } else {

  }
#line 308
  if (link == 0) {
#line 309
    goto out;
  } else {

  }
#line 311
  err = mthca_READ_MGM(dev, prev, mailbox);
#line 312
  if (err != 0) {
#line 313
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM failed %d\n",
            err);
#line 314
    goto out;
  } else {

  }
#line 317
  tmp___6 = __fswab32((__u32 )(index << 6));
#line 317
  mgm->next_gid_index = tmp___6;
#line 319
  err = mthca_WRITE_MGM(dev, prev, mailbox);
#line 320
  if (err != 0) {
#line 321
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
            err);
  } else {

  }
  out: ;
#line 324
  if ((err != 0 && link != 0) && index != -1) {
#line 325
    tmp___7 = ldv__builtin_expect(dev->limits.num_mgms > index, 0L);
#line 325
    if (tmp___7 != 0L) {
#line 325
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"),
                           "i" (325), "i" (12UL));
      ldv_22211: ;
#line 325
      goto ldv_22211;
    } else {

    }
#line 326
    mthca_free(& dev->mcg_table.alloc, (u32 )index);
  } else {

  }
#line 328
  ldv_mutex_unlock_151(& dev->mcg_table.mutex);
#line 330
  mthca_free_mailbox(dev, mailbox);
#line 331
  return (err);
}
}
#line 334 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
int mthca_multicast_detach(struct ib_qp *ibqp , union ib_gid *gid , u16 lid ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_mailbox *mailbox ;
  struct mthca_mgm *mgm ;
  u16 hash ;
  int prev ;
  int index ;
  int i ;
  int loc ;
  int err ;
  long tmp___0 ;
  long tmp___1 ;
  __u32 tmp___2 ;
  int amgm_index_to_free ;
  __u32 tmp___3 ;
  long tmp___4 ;
  int curr_next_index ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  long tmp___7 ;

  {
#line 336
  tmp = to_mdev(ibqp->device);
#line 336
  dev = tmp;
#line 344
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 345
  tmp___1 = IS_ERR((void const   *)mailbox);
#line 345
  if (tmp___1 != 0L) {
#line 346
    tmp___0 = PTR_ERR((void const   *)mailbox);
#line 346
    return ((int )tmp___0);
  } else {

  }
#line 347
  mgm = (struct mthca_mgm *)mailbox->buf;
#line 349
  ldv_mutex_lock_152(& dev->mcg_table.mutex);
#line 351
  err = find_mgm(dev, (u8 *)(& gid->raw), mailbox, & hash, & prev, & index);
#line 352
  if (err != 0) {
#line 353
    goto out;
  } else {

  }
#line 355
  if (index == -1) {
#line 356
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "MGID %pI6 not found\n",
            (u8 *)(& gid->raw));
#line 357
    err = -22;
#line 358
    goto out;
  } else {

  }
#line 361
  loc = -1;
#line 361
  i = 0;
#line 361
  goto ldv_22229;
  ldv_22228: 
#line 362
  tmp___2 = __fswab32(ibqp->qp_num | 2147483648U);
#line 362
  if (mgm->qp[i] == tmp___2) {
#line 363
    loc = i;
  } else {

  }
#line 364
  if ((mgm->qp[i] & 128U) == 0U) {
#line 365
    goto ldv_22227;
  } else {

  }
#line 361
  i = i + 1;
  ldv_22229: ;
#line 361
  if (i <= 55) {
#line 362
    goto ldv_22228;
  } else {
#line 364
    goto ldv_22227;
  }
  ldv_22227: ;
#line 368
  if (loc == -1) {
#line 369
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "QP %06x not found in MGM\n",
            ibqp->qp_num);
#line 370
    err = -22;
#line 371
    goto out;
  } else {

  }
#line 374
  mgm->qp[loc] = mgm->qp[i + -1];
#line 375
  mgm->qp[i + -1] = 0U;
#line 377
  err = mthca_WRITE_MGM(dev, index, mailbox);
#line 378
  if (err != 0) {
#line 379
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
            err);
#line 380
    goto out;
  } else {

  }
#line 383
  if (i != 1) {
#line 384
    goto out;
  } else {

  }
#line 386
  if (prev == -1) {
#line 388
    tmp___3 = __fswab32(mgm->next_gid_index);
#line 388
    amgm_index_to_free = (int )(tmp___3 >> 6);
#line 389
    if (amgm_index_to_free != 0) {
#line 390
      err = mthca_READ_MGM(dev, amgm_index_to_free, mailbox);
#line 392
      if (err != 0) {
#line 393
        dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM returned %d\n",
                err);
#line 394
        goto out;
      } else {

      }
    } else {
#line 397
      memset((void *)(& mgm->gid), 0, 16UL);
    }
#line 399
    err = mthca_WRITE_MGM(dev, index, mailbox);
#line 400
    if (err != 0) {
#line 401
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
              err);
#line 402
      goto out;
    } else {

    }
#line 404
    if (amgm_index_to_free != 0) {
#line 405
      tmp___4 = ldv__builtin_expect(dev->limits.num_mgms > amgm_index_to_free, 0L);
#line 405
      if (tmp___4 != 0L) {
#line 405
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"),
                             "i" (405), "i" (12UL));
        ldv_22231: ;
#line 405
        goto ldv_22231;
      } else {

      }
#line 406
      mthca_free(& dev->mcg_table.alloc, (u32 )amgm_index_to_free);
    } else {

    }
  } else {
#line 410
    tmp___5 = __fswab32(mgm->next_gid_index);
#line 410
    curr_next_index = (int )(tmp___5 >> 6);
#line 411
    err = mthca_READ_MGM(dev, prev, mailbox);
#line 412
    if (err != 0) {
#line 413
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "READ_MGM returned %d\n",
              err);
#line 414
      goto out;
    } else {

    }
#line 417
    tmp___6 = __fswab32((__u32 )(curr_next_index << 6));
#line 417
    mgm->next_gid_index = tmp___6;
#line 419
    err = mthca_WRITE_MGM(dev, prev, mailbox);
#line 420
    if (err != 0) {
#line 421
      dev_err((struct device  const  *)(& (dev->pdev)->dev), "WRITE_MGM returned %d\n",
              err);
#line 422
      goto out;
    } else {

    }
#line 424
    tmp___7 = ldv__builtin_expect(dev->limits.num_mgms > index, 0L);
#line 424
    if (tmp___7 != 0L) {
#line 424
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"),
                           "i" (424), "i" (12UL));
      ldv_22233: ;
#line 424
      goto ldv_22233;
    } else {

    }
#line 425
    mthca_free(& dev->mcg_table.alloc, (u32 )index);
  }
  out: 
#line 429
  ldv_mutex_unlock_153(& dev->mcg_table.mutex);
#line 431
  mthca_free_mailbox(dev, mailbox);
#line 432
  return (err);
}
}
#line 435 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
int mthca_init_mcg_table(struct mthca_dev *dev ) 
{ int err ;
  int table_size ;
  struct lock_class_key __key ;

  {
#line 438
  table_size = dev->limits.num_mgms + dev->limits.num_amgms;
#line 440
  err = mthca_alloc_init(& dev->mcg_table.alloc, (u32 )table_size, (u32 )(table_size + -1),
                         (u32 )dev->limits.num_mgms);
#line 444
  if (err != 0) {
#line 445
    return (err);
  } else {

  }
#line 447
  __mutex_init(& dev->mcg_table.mutex, "&dev->mcg_table.mutex", & __key);
#line 449
  return (0);
}
}
#line 452 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void mthca_cleanup_mcg_table(struct mthca_dev *dev ) 
{ 

  {
#line 454
  mthca_alloc_cleanup(& dev->mcg_table.alloc);
#line 455
  return;
}
}
#line 457 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 462
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 464
  mutex_lock(ldv_func_arg1);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 472
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 482
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 484
  mutex_lock(ldv_func_arg1);
#line 485
  return;
}
}
#line 487 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
int ldv_mutex_trylock_148(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 492
  tmp = mutex_trylock(ldv_func_arg1);
#line 492
  ldv_func_res = tmp;
#line 494
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 494
  return (tmp___0);
#line 496
  return (ldv_func_res);
}
}
#line 499 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 504
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 506
  mutex_unlock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_lock_150(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 514
  ldv_mutex_lock_mutex_of_mthca_mcg_table(ldv_func_arg1);
#line 516
  mutex_lock(ldv_func_arg1);
#line 517
  return;
}
}
#line 519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 524
  ldv_mutex_unlock_mutex_of_mthca_mcg_table(ldv_func_arg1);
#line 526
  mutex_unlock(ldv_func_arg1);
#line 527
  return;
}
}
#line 529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 534
  ldv_mutex_lock_mutex_of_mthca_mcg_table(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mcg.c.prepared"
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 544
  ldv_mutex_unlock_mutex_of_mthca_mcg_table(ldv_func_arg1);
#line 546
  mutex_unlock(ldv_func_arg1);
#line 547
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_166(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_167(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_168(struct mutex *ldv_func_arg1 ) ;
#line 23
void ldv_mutex_lock_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) ;
#line 27
void ldv_mutex_unlock_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) ;
#line 231 "include/rdma/ib_verbs.h"
__inline static int ib_width_enum_to_int(enum ib_port_width width ) 
{ 

  {
#line 233
  switch ((unsigned int )width) {
  case 1: ;
#line 234
  return (1);
  case 2: ;
#line 235
  return (4);
  case 4: ;
#line 236
  return (8);
  case 8: ;
#line 237
  return (12);
  default: ;
#line 238
  return (-1);
  }
}
}
#line 1317
extern int ib_query_port(struct ib_device * , u8  , struct ib_port_attr * ) ;
#line 1366
extern struct ib_ah *ib_create_ah(struct ib_pd * , struct ib_ah_attr * ) ;
#line 1419
extern int ib_destroy_ah(struct ib_ah * ) ;
#line 455 "include/rdma/ib_mad.h"
extern struct ib_mad_agent *ib_register_mad_agent(struct ib_device * , u8  , enum ib_qp_type  ,
                                                  struct ib_mad_reg_req * , u8  ,
                                                  void (*)(struct ib_mad_agent * ,
                                                           struct ib_mad_send_wc * ) ,
                                                  void (*)(struct ib_mad_agent * ,
                                                           struct ib_mad_recv_wc * ) ,
                                                  void * ) ;
#line 500
extern int ib_unregister_mad_agent(struct ib_mad_agent * ) ;
#line 521
extern int ib_post_send_mad(struct ib_mad_send_buf * , struct ib_mad_send_buf ** ) ;
#line 623
extern struct ib_mad_send_buf *ib_create_send_mad(struct ib_mad_agent * , u32  , u16  ,
                                                  int  , int  , int  , gfp_t  ) ;
#line 662
extern void ib_free_send_mad(struct ib_mad_send_buf * ) ;
#line 576 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
int mthca_process_mad(struct ib_device *ibdev , int mad_flags , u8 port_num , struct ib_wc *in_wc ,
                      struct ib_grh *in_grh , struct ib_mad *in_mad , struct ib_mad *out_mad ) ;
#line 170 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static int mthca_update_rate(struct mthca_dev *dev , u8 port_num ) 
{ struct ib_port_attr *tprops ;
  int ret ;
  void *tmp ;
  int tmp___0 ;

  {
#line 172
  tprops = 0;
#line 175
  tmp = kmalloc(48UL, 208U);
#line 175
  tprops = (struct ib_port_attr *)tmp;
#line 176
  if ((unsigned long )tprops == (unsigned long )((struct ib_port_attr *)0)) {
#line 177
    return (-12);
  } else {

  }
#line 179
  ret = ib_query_port(& dev->ib_dev, (int )port_num, tprops);
#line 180
  if (ret != 0) {
#line 181
    printk("\fib_query_port failed (%d) for %s port %d\n", ret, (char *)(& dev->ib_dev.name),
           (int )port_num);
#line 183
    goto out;
  } else {

  }
#line 186
  tmp___0 = ib_width_enum_to_int((enum ib_port_width )tprops->active_width);
#line 186
  dev->rate[(int )port_num + -1] = (int )tprops->active_speed * (int )((u8 )tmp___0);
  out: 
#line 190
  kfree((void const   *)tprops);
#line 191
  return (ret);
}
}
#line 194 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static void update_sm_ah(struct mthca_dev *dev , u8 port_num , u16 lid , u8 sl ) 
{ struct ib_ah *new_ah ;
  struct ib_ah_attr ah_attr ;
  unsigned long flags ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 201
  if ((unsigned long )dev->send_agent[(int )port_num + -1][0] == (unsigned long )((struct ib_mad_agent *)0)) {
#line 202
    return;
  } else {

  }
#line 204
  memset((void *)(& ah_attr), 0, 32UL);
#line 205
  ah_attr.dlid = lid;
#line 206
  ah_attr.sl = sl;
#line 207
  ah_attr.port_num = port_num;
#line 209
  new_ah = ib_create_ah(((dev->send_agent[(int )port_num + -1][0])->qp)->pd, & ah_attr);
#line 211
  tmp = IS_ERR((void const   *)new_ah);
#line 211
  if (tmp != 0L) {
#line 212
    return;
  } else {

  }
#line 214
  tmp___0 = spinlock_check(& dev->sm_lock);
#line 214
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 215
  if ((unsigned long )dev->sm_ah[(int )port_num + -1] != (unsigned long )((struct ib_ah *)0)) {
#line 216
    ib_destroy_ah(dev->sm_ah[(int )port_num + -1]);
  } else {

  }
#line 217
  dev->sm_ah[(int )port_num + -1] = new_ah;
#line 218
  spin_unlock_irqrestore(& dev->sm_lock, flags);
#line 219
  return;
}
}
#line 225 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static void smp_snoop(struct ib_device *ibdev , u8 port_num , struct ib_mad *mad ,
                      u16 prev_lid ) 
{ struct ib_event event ;
  struct ib_port_info *pinfo ;
  u16 lid ;
  __u16 tmp ;
  struct mthca_dev *tmp___0 ;
  __u16 tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 232
  if (((unsigned int )mad->mad_hdr.mgmt_class == 1U || (unsigned int )mad->mad_hdr.mgmt_class == 129U) && (unsigned int )mad->mad_hdr.method == 2U) {
#line 235
    if ((unsigned int )mad->mad_hdr.attr_id == 5376U) {
#line 236
      pinfo = (struct ib_port_info *)(& ((struct ib_smp *)mad)->data);
#line 238
      tmp = __fswab16((int )pinfo->lid);
#line 238
      lid = tmp;
#line 240
      tmp___0 = to_mdev(ibdev);
#line 240
      mthca_update_rate(tmp___0, (int )port_num);
#line 241
      tmp___1 = __fswab16((int )pinfo->sm_lid);
#line 241
      tmp___2 = to_mdev(ibdev);
#line 241
      update_sm_ah(tmp___2, (int )port_num, (int )tmp___1, (int )pinfo->neighbormtu_mastersmsl & 15);
#line 245
      event.device = ibdev;
#line 246
      event.element.port_num = port_num;
#line 248
      if ((int )((signed char )pinfo->clientrereg_resv_subnetto) < 0) {
#line 249
        event.event = 17;
#line 250
        ib_dispatch_event(& event);
      } else {

      }
#line 253
      if ((int )prev_lid != (int )lid) {
#line 254
        event.event = 11;
#line 255
        ib_dispatch_event(& event);
      } else {

      }
    } else {

    }
#line 259
    if ((unsigned int )mad->mad_hdr.attr_id == 5632U) {
#line 260
      event.device = ibdev;
#line 261
      event.event = 12;
#line 262
      event.element.port_num = port_num;
#line 263
      ib_dispatch_event(& event);
    } else {

    }
  } else {

  }
#line 266
  return;
}
}
#line 268 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static void node_desc_override(struct ib_device *dev , struct ib_mad *mad ) 
{ struct mthca_dev *tmp ;
  size_t __len ;
  void *__ret ;
  struct mthca_dev *tmp___0 ;

  {
#line 271
  if ((((unsigned int )mad->mad_hdr.mgmt_class == 1U || (unsigned int )mad->mad_hdr.mgmt_class == 129U) && (unsigned int )mad->mad_hdr.method == 129U) && (unsigned int )mad->mad_hdr.attr_id == 4096U) {
#line 275
    tmp = to_mdev(dev);
#line 275
    ldv_mutex_lock_168(& tmp->cap_mask_mutex);
#line 276
    __len = 64UL;
#line 276
    if (__len > 63UL) {
#line 276
      __ret = __memcpy((void *)(& ((struct ib_smp *)mad)->data), (void const   *)(& dev->node_desc),
                       __len);
    } else {
#line 276
      __ret = __builtin_memcpy((void *)(& ((struct ib_smp *)mad)->data), (void const   *)(& dev->node_desc),
                               __len);
    }
#line 277
    tmp___0 = to_mdev(dev);
#line 277
    ldv_mutex_unlock_169(& tmp___0->cap_mask_mutex);
  } else {

  }
#line 279
  return;
}
}
#line 281 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static void forward_trap(struct mthca_dev *dev , u8 port_num , struct ib_mad *mad ) 
{ int qpn ;
  struct ib_mad_send_buf *send_buf ;
  struct ib_mad_agent *agent ;
  int ret ;
  unsigned long flags ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  size_t __len ;
  void *__ret ;
  struct ib_ah *tmp___1 ;

  {
#line 285
  qpn = (unsigned int )mad->mad_hdr.mgmt_class != 1U;
#line 287
  agent = dev->send_agent[(int )port_num + -1][qpn];
#line 291
  if ((unsigned long )agent != (unsigned long )((struct ib_mad_agent *)0)) {
#line 292
    send_buf = ib_create_send_mad(agent, (u32 )qpn, 0, 0, 24, 232, 32U);
#line 294
    tmp = IS_ERR((void const   *)send_buf);
#line 294
    if (tmp != 0L) {
#line 295
      return;
    } else {

    }
#line 302
    tmp___0 = spinlock_check(& dev->sm_lock);
#line 302
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 303
    __len = 256UL;
#line 303
    if (__len > 63UL) {
#line 303
      __ret = __memcpy(send_buf->mad, (void const   *)mad, __len);
    } else {
#line 303
      __ret = __builtin_memcpy(send_buf->mad, (void const   *)mad, __len);
    }
#line 304
    tmp___1 = dev->sm_ah[(int )port_num + -1];
#line 304
    send_buf->ah = tmp___1;
#line 304
    if ((unsigned long )tmp___1 != (unsigned long )((struct ib_ah *)0)) {
#line 305
      ret = ib_post_send_mad(send_buf, 0);
    } else {
#line 307
      ret = -22;
    }
#line 308
    spin_unlock_irqrestore(& dev->sm_lock, flags);
#line 310
    if (ret != 0) {
#line 311
      ib_free_send_mad(send_buf);
    } else {

    }
  } else {

  }
#line 313
  return;
}
}
#line 315 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
int mthca_process_mad(struct ib_device *ibdev , int mad_flags , u8 port_num , struct ib_wc *in_wc ,
                      struct ib_grh *in_grh , struct ib_mad *in_mad , struct ib_mad *out_mad ) 
{ int err ;
  u16 slid ;
  unsigned int tmp ;
  u16 prev_lid ;
  struct ib_port_attr pattr ;
  struct mthca_dev *tmp___0 ;
  int tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;

  {
#line 324
  if ((unsigned long )in_wc != (unsigned long )((struct ib_wc *)0)) {
#line 324
    tmp = in_wc->slid;
  } else {
#line 324
    tmp = 65535U;
  }
#line 324
  slid = tmp;
#line 325
  prev_lid = 0U;
#line 329
  if ((unsigned int )in_mad->mad_hdr.method == 5U && (unsigned int )slid == 0U) {
#line 331
    tmp___0 = to_mdev(ibdev);
#line 331
    forward_trap(tmp___0, (int )port_num, in_mad);
#line 332
    return (5);
  } else {

  }
#line 341
  if ((unsigned int )in_mad->mad_hdr.mgmt_class == 1U || (unsigned int )in_mad->mad_hdr.mgmt_class == 129U) {
#line 343
    if (((unsigned int )in_mad->mad_hdr.method != 1U && (unsigned int )in_mad->mad_hdr.method != 2U) && (unsigned int )in_mad->mad_hdr.method != 7U) {
#line 346
      return (1);
    } else {

    }
#line 352
    if ((unsigned int )in_mad->mad_hdr.attr_id == 8192U || ((int )in_mad->mad_hdr.attr_id & 255) == 255) {
#line 355
      return (1);
    } else {

    }
  } else
#line 356
  if (((unsigned int )in_mad->mad_hdr.mgmt_class == 4U || (unsigned int )in_mad->mad_hdr.mgmt_class == 9U) || (unsigned int )in_mad->mad_hdr.mgmt_class == 10U) {
#line 359
    if ((unsigned int )in_mad->mad_hdr.method != 1U && (unsigned int )in_mad->mad_hdr.method != 2U) {
#line 361
      return (1);
    } else {
#line 363
      return (1);
    }
  } else {

  }
#line 364
  if ((((unsigned int )in_mad->mad_hdr.mgmt_class == 1U || (unsigned int )in_mad->mad_hdr.mgmt_class == 129U) && (unsigned int )in_mad->mad_hdr.method == 2U) && (unsigned int )in_mad->mad_hdr.attr_id == 5376U) {
#line 364
    tmp___1 = ib_query_port(ibdev, (int )port_num, & pattr);
#line 364
    if (tmp___1 == 0) {
#line 369
      prev_lid = pattr.lid;
    } else {

    }
  } else {

  }
#line 371
  tmp___2 = to_mdev(ibdev);
#line 371
  err = mthca_MAD_IFC(tmp___2, mad_flags & 1, mad_flags & 2, (int )port_num, in_wc,
                      in_grh, (void *)in_mad, (void *)out_mad);
#line 375
  if (err == -74) {
#line 376
    return (1);
  } else
#line 377
  if (err != 0) {
#line 378
    tmp___3 = to_mdev(ibdev);
#line 378
    dev_err((struct device  const  *)(& (tmp___3->pdev)->dev), "MAD_IFC returned %d\n",
            err);
#line 379
    return (0);
  } else {

  }
#line 382
  if ((unsigned int )out_mad->mad_hdr.status == 0U) {
#line 383
    smp_snoop(ibdev, (int )port_num, in_mad, (int )prev_lid);
#line 384
    node_desc_override(ibdev, out_mad);
  } else {

  }
#line 388
  if ((unsigned int )in_mad->mad_hdr.mgmt_class == 129U) {
#line 389
    out_mad->mad_hdr.status = (__be16 )((unsigned int )out_mad->mad_hdr.status | 128U);
  } else {

  }
#line 391
  if ((unsigned int )in_mad->mad_hdr.method == 7U) {
#line 393
    return (5);
  } else {

  }
#line 395
  return (3);
}
}
#line 398 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
static void send_handler(struct ib_mad_agent *agent , struct ib_mad_send_wc *mad_send_wc ) 
{ 

  {
#line 401
  ib_free_send_mad(mad_send_wc->send_buf);
#line 402
  return;
}
}
#line 404 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
int mthca_create_agents(struct mthca_dev *dev ) 
{ struct ib_mad_agent *agent ;
  int p ;
  int q ;
  int ret ;
  struct lock_class_key __key ;
  long tmp ;
  long tmp___0 ;

  {
#line 410
  spinlock_check(& dev->sm_lock);
#line 410
  __raw_spin_lock_init(& dev->sm_lock.ldv_5961.rlock, "&(&dev->sm_lock)->rlock", & __key);
#line 412
  p = 0;
#line 412
  goto ldv_22491;
  ldv_22490: 
#line 413
  q = 0;
#line 413
  goto ldv_22488;
  ldv_22487: 
#line 414
  agent = ib_register_mad_agent(& dev->ib_dev, (int )((unsigned int )((u8 )p) + 1U),
                                q != 0, 0, 0, & send_handler, 0, 0);
#line 418
  tmp___0 = IS_ERR((void const   *)agent);
#line 418
  if (tmp___0 != 0L) {
#line 419
    tmp = PTR_ERR((void const   *)agent);
#line 419
    ret = (int )tmp;
#line 420
    goto err;
  } else {

  }
#line 422
  dev->send_agent[p][q] = agent;
#line 413
  q = q + 1;
  ldv_22488: ;
#line 413
  if (q <= 1) {
#line 414
    goto ldv_22487;
  } else {
#line 416
    goto ldv_22489;
  }
  ldv_22489: 
#line 412
  p = p + 1;
  ldv_22491: ;
#line 412
  if (dev->limits.num_ports > p) {
#line 413
    goto ldv_22490;
  } else {
#line 415
    goto ldv_22492;
  }
  ldv_22492: 
#line 426
  p = 1;
#line 426
  goto ldv_22494;
  ldv_22493: 
#line 427
  ret = mthca_update_rate(dev, (int )((u8 )p));
#line 428
  if (ret != 0) {
#line 429
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "Failed to obtain port %d rate. aborting.\n",
            p);
#line 431
    goto err;
  } else {

  }
#line 426
  p = p + 1;
  ldv_22494: ;
#line 426
  if (dev->limits.num_ports >= p) {
#line 427
    goto ldv_22493;
  } else {
#line 429
    goto ldv_22495;
  }
  ldv_22495: ;
#line 435
  return (0);
  err: 
#line 438
  p = 0;
#line 438
  goto ldv_22500;
  ldv_22499: 
#line 439
  q = 0;
#line 439
  goto ldv_22497;
  ldv_22496: ;
#line 440
  if ((unsigned long )dev->send_agent[p][q] != (unsigned long )((struct ib_mad_agent *)0)) {
#line 441
    ib_unregister_mad_agent(dev->send_agent[p][q]);
  } else {

  }
#line 439
  q = q + 1;
  ldv_22497: ;
#line 439
  if (q <= 1) {
#line 440
    goto ldv_22496;
  } else {
#line 442
    goto ldv_22498;
  }
  ldv_22498: 
#line 438
  p = p + 1;
  ldv_22500: ;
#line 438
  if (dev->limits.num_ports > p) {
#line 439
    goto ldv_22499;
  } else {
#line 441
    goto ldv_22501;
  }
  ldv_22501: ;
#line 443
  return (ret);
}
}
#line 446 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void mthca_free_agents(struct mthca_dev *dev ) 
{ struct ib_mad_agent *agent ;
  int p ;
  int q ;

  {
#line 451
  p = 0;
#line 451
  goto ldv_22512;
  ldv_22511: 
#line 452
  q = 0;
#line 452
  goto ldv_22509;
  ldv_22508: 
#line 453
  agent = dev->send_agent[p][q];
#line 454
  dev->send_agent[p][q] = 0;
#line 455
  ib_unregister_mad_agent(agent);
#line 452
  q = q + 1;
  ldv_22509: ;
#line 452
  if (q <= 1) {
#line 453
    goto ldv_22508;
  } else {
#line 455
    goto ldv_22510;
  }
  ldv_22510: ;
#line 458
  if ((unsigned long )dev->sm_ah[p] != (unsigned long )((struct ib_ah *)0)) {
#line 459
    ib_destroy_ah(dev->sm_ah[p]);
  } else {

  }
#line 451
  p = p + 1;
  ldv_22512: ;
#line 451
  if (dev->limits.num_ports > p) {
#line 452
    goto ldv_22511;
  } else {
#line 454
    goto ldv_22513;
  }
  ldv_22513: ;
#line 456
  return;
}
}
#line 463 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 468
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 470
  mutex_lock(ldv_func_arg1);
#line 471
  return;
}
}
#line 473 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 478
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 480
  mutex_unlock(ldv_func_arg1);
#line 481
  return;
}
}
#line 483 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_lock_165(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 488
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 490
  mutex_lock(ldv_func_arg1);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
int ldv_mutex_trylock_166(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 498
  tmp = mutex_trylock(ldv_func_arg1);
#line 498
  ldv_func_res = tmp;
#line 500
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 500
  return (tmp___0);
#line 502
  return (ldv_func_res);
}
}
#line 505 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_unlock_167(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 510
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 512
  mutex_unlock(ldv_func_arg1);
#line 513
  return;
}
}
#line 515 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_lock_168(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 520
  ldv_mutex_lock_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 522
  mutex_lock(ldv_func_arg1);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_mad.c.prepared"
void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 530
  ldv_mutex_unlock_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 532
  mutex_unlock(ldv_func_arg1);
#line 533
  return;
}
}
#line 1 "<compiler builtins>"
#line 356 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word ) 
{ 

  {
#line 358
  __asm__  ("rep; bsf %1,%0": "=r" (word): "rm" (word));
#line 361
  return (word);
}
}
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 358
extern int sprintf(char * , char const   *  , ...) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 151 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 boot_cpu_data ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_180(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_185(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_187(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) ;
#line 5 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 8
int ldv_mutex_lock_interruptible_184(struct mutex *ldv_func_arg1 ) ;
#line 12
int ldv_mutex_lock_interruptible_186(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_182(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_188(struct mutex *ldv_func_arg1 ) ;
#line 32
int ldv_mutex_lock_interruptible_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) ;
#line 83
void ldv_mutex_lock_mutex_of_mthca_cq(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_mutex_of_mthca_cq(struct mutex *lock ) ;
#line 521 "include/linux/device.h"
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 351 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
#line 1620 "include/linux/mm.h"
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
#line 49 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 1270 "include/rdma/ib_verbs.h"
extern int ib_register_device(struct ib_device * , int (*)(struct ib_device * , u8  ,
                                                           struct kobject * ) ) ;
#line 1273
extern void ib_unregister_device(struct ib_device * ) ;
#line 1282 "include/rdma/ib_verbs.h"
__inline static int ib_copy_from_udata(void *dest , struct ib_udata *udata , size_t len ) 
{ int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1284
  tmp___1 = copy_from_user(dest, (void const   *)udata->inbuf, len);
#line 1284
  if (tmp___1 != 0UL) {
#line 1284
    tmp___0 = -14;
  } else {
#line 1284
    tmp___0 = 0;
  }
#line 1284
  return (tmp___0);
}
}
#line 1287 "include/rdma/ib_verbs.h"
__inline static int ib_copy_to_udata(struct ib_udata *udata , void *src , size_t len ) 
{ int tmp___0 ;
  int tmp___1 ;

  {
#line 1289
  tmp___1 = copy_to_user(udata->outbuf, (void const   *)src, (unsigned int )len);
#line 1289
  if (tmp___1 != 0) {
#line 1289
    tmp___0 = -14;
  } else {
#line 1289
    tmp___0 = 0;
  }
#line 1289
  return (tmp___0);
}
}
#line 64 "include/rdma/ib_umem.h"
extern struct ib_umem *ib_umem_get(struct ib_ucontext * , unsigned long  , size_t  ,
                                   int  , int  ) ;
#line 66
extern void ib_umem_release(struct ib_umem * ) ;
#line 309 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_provider.h"
__inline static struct mthca_mr *to_mmr(struct ib_mr *ibmr ) 
{ struct ib_mr  const  *__mptr ;

  {
#line 311
  __mptr = (struct ib_mr  const  *)ibmr;
#line 311
  return ((struct mthca_mr *)__mptr);
}
}
#line 453 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_dev.h"
void mthca_start_catas_poll(struct mthca_dev *dev ) ;
#line 454
void mthca_stop_catas_poll(struct mthca_dev *dev ) ;
#line 512
int mthca_alloc_srq(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_srq_attr *attr ,
                    struct mthca_srq *srq ) ;
#line 514
void mthca_free_srq(struct mthca_dev *dev , struct mthca_srq *srq ) ;
#line 515
int mthca_modify_srq(struct ib_srq *ibsrq , struct ib_srq_attr *attr , enum ib_srq_attr_mask attr_mask ,
                     struct ib_udata *udata ) ;
#line 517
int mthca_query_srq(struct ib_srq *ibsrq , struct ib_srq_attr *srq_attr ) ;
#line 522
int mthca_tavor_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 524
int mthca_arbel_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) ;
#line 165 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_map_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                      int index , u64 uaddr ) ;
#line 167
void mthca_unmap_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                         int index ) ;
#line 169
struct mthca_user_db_table *mthca_init_user_db_tab(struct mthca_dev *dev ) ;
#line 170
void mthca_cleanup_user_db_tab(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ) ;
#line 172 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static void init_query_mad(struct ib_smp *mad ) 
{ 

  {
#line 174
  mad->base_version = 1U;
#line 175
  mad->mgmt_class = 1U;
#line 176
  mad->class_version = 1U;
#line 177
  mad->method = 1U;
#line 178
  return;
}
}
#line 180 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_query_device(struct ib_device *ibdev , struct ib_device_attr *props ) 
{ struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  struct mthca_dev *mdev ;
  struct mthca_dev *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  __u32 tmp___2 ;
  __u16 tmp___3 ;
  size_t __len ;
  void *__ret ;
  int tmp___4 ;

  {
#line 183
  in_mad = 0;
#line 184
  out_mad = 0;
#line 185
  err = -12;
#line 186
  tmp = to_mdev(ibdev);
#line 186
  mdev = tmp;
#line 188
  tmp___0 = kzalloc(256UL, 208U);
#line 188
  in_mad = (struct ib_smp *)tmp___0;
#line 189
  tmp___1 = kmalloc(256UL, 208U);
#line 189
  out_mad = (struct ib_smp *)tmp___1;
#line 190
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 191
    goto out;
  } else {

  }
#line 193
  memset((void *)props, 0, 176UL);
#line 195
  props->fw_ver = mdev->fw_ver;
#line 197
  init_query_mad(in_mad);
#line 198
  in_mad->attr_id = 4352U;
#line 200
  err = mthca_MAD_IFC(mdev, 1, 1, 1, 0, 0, (void *)in_mad, (void *)out_mad);
#line 202
  if (err != 0) {
#line 203
    goto out;
  } else {

  }
#line 205
  props->device_cap_flags = (int )mdev->device_cap_flags;
#line 206
  tmp___2 = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 36U);
#line 206
  props->vendor_id = tmp___2 & 16777215U;
#line 208
  tmp___3 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 30U);
#line 208
  props->vendor_part_id = (u32 )tmp___3;
#line 209
  props->hw_ver = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 32U);
#line 210
  __len = 8UL;
#line 210
  if (__len > 63UL) {
#line 210
    __ret = __memcpy((void *)(& props->sys_image_guid), (void const   *)(& out_mad->data) + 4U,
                     __len);
  } else {
#line 210
    __ret = __builtin_memcpy((void *)(& props->sys_image_guid), (void const   *)(& out_mad->data) + 4U,
                             __len);
  }
#line 212
  props->max_mr_size = 0xffffffffffffffffULL;
#line 213
  props->page_size_cap = (u64 )mdev->limits.page_size_cap;
#line 214
  props->max_qp = mdev->limits.num_qps - mdev->limits.reserved_qps;
#line 215
  props->max_qp_wr = mdev->limits.max_wqes;
#line 216
  props->max_sge = mdev->limits.max_sg;
#line 217
  props->max_cq = mdev->limits.num_cqs - mdev->limits.reserved_cqs;
#line 218
  props->max_cqe = mdev->limits.max_cqes;
#line 219
  props->max_mr = mdev->limits.num_mpts - mdev->limits.reserved_mrws;
#line 220
  props->max_pd = mdev->limits.num_pds - mdev->limits.reserved_pds;
#line 221
  props->max_qp_rd_atom = 1 << mdev->qp_table.rdb_shift;
#line 222
  props->max_qp_init_rd_atom = mdev->limits.max_qp_init_rdma;
#line 223
  props->max_res_rd_atom = props->max_qp_rd_atom * props->max_qp;
#line 224
  props->max_srq = mdev->limits.num_srqs - mdev->limits.reserved_srqs;
#line 225
  props->max_srq_wr = mdev->limits.max_srq_wqes;
#line 226
  props->max_srq_sge = mdev->limits.max_srq_sge;
#line 227
  props->local_ca_ack_delay = (u8 )mdev->limits.local_ca_ack_delay;
#line 228
  props->atomic_cap = (mdev->limits.flags & 262144U) != 0U;
#line 230
  props->max_pkeys = (u16 )mdev->limits.pkey_table_len;
#line 231
  props->max_mcast_grp = mdev->limits.num_mgms + mdev->limits.num_amgms;
#line 232
  props->max_mcast_qp_attach = 56;
#line 233
  props->max_total_mcast_qp_attach = props->max_mcast_qp_attach * props->max_mcast_grp;
#line 240
  if ((mdev->mthca_flags & 256UL) != 0UL) {
#line 241
    props->max_map_per_fmr = 255;
  } else {
#line 243
    tmp___4 = __ilog2_u32((u32 )mdev->limits.num_mpts);
#line 243
    props->max_map_per_fmr = (1 << (32 - tmp___4)) + -1;
  }
#line 246
  err = 0;
  out: 
#line 248
  kfree((void const   *)in_mad);
#line 249
  kfree((void const   *)out_mad);
#line 250
  return (err);
}
}
#line 253 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_query_port(struct ib_device *ibdev , u8 port , struct ib_port_attr *props ) 
{ struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_dev *tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;

  {
#line 256
  in_mad = 0;
#line 257
  out_mad = 0;
#line 258
  err = -12;
#line 260
  tmp = kzalloc(256UL, 208U);
#line 260
  in_mad = (struct ib_smp *)tmp;
#line 261
  tmp___0 = kmalloc(256UL, 208U);
#line 261
  out_mad = (struct ib_smp *)tmp___0;
#line 262
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 263
    goto out;
  } else {

  }
#line 265
  memset((void *)props, 0, 48UL);
#line 267
  init_query_mad(in_mad);
#line 268
  in_mad->attr_id = 5376U;
#line 269
  tmp___1 = __fswab32((__u32 )port);
#line 269
  in_mad->attr_mod = tmp___1;
#line 271
  tmp___2 = to_mdev(ibdev);
#line 271
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, 0, 0, (void *)in_mad, (void *)out_mad);
#line 273
  if (err != 0) {
#line 274
    goto out;
  } else {

  }
#line 276
  props->lid = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 16U);
#line 277
  props->lmc = (unsigned int )out_mad->data[34] & 7U;
#line 278
  props->sm_lid = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 18U);
#line 279
  props->sm_sl = (unsigned int )out_mad->data[36] & 15U;
#line 280
  props->state = (enum ib_port_state )((int )out_mad->data[32] & 15);
#line 281
  props->phys_state = (u8 )((int )out_mad->data[33] >> 4);
#line 282
  props->port_cap_flags = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 20U);
#line 283
  tmp___3 = to_mdev(ibdev);
#line 283
  props->gid_tbl_len = tmp___3->limits.gid_table_len;
#line 284
  props->max_msg_sz = 2147483648U;
#line 285
  tmp___4 = to_mdev(ibdev);
#line 285
  props->pkey_tbl_len = (u16 )tmp___4->limits.pkey_table_len;
#line 286
  tmp___5 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 46U);
#line 286
  props->bad_pkey_cntr = (u32 )tmp___5;
#line 287
  tmp___6 = __be16_to_cpup((__be16 const   *)(& out_mad->data) + 48U);
#line 287
  props->qkey_viol_cntr = (u32 )tmp___6;
#line 288
  props->active_width = (unsigned int )out_mad->data[31] & 15U;
#line 289
  props->active_speed = (u8 )((int )out_mad->data[35] >> 4);
#line 290
  props->max_mtu = (enum ib_mtu )((int )out_mad->data[41] & 15);
#line 291
  props->active_mtu = (enum ib_mtu )((int )out_mad->data[36] >> 4);
#line 292
  props->subnet_timeout = (unsigned int )out_mad->data[51] & 31U;
#line 293
  props->max_vl_num = (u8 )((int )out_mad->data[37] >> 4);
#line 294
  props->init_type_reply = (u8 )((int )out_mad->data[41] >> 4);
  out: 
#line 297
  kfree((void const   *)in_mad);
#line 298
  kfree((void const   *)out_mad);
#line 299
  return (err);
}
}
#line 302 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_modify_device(struct ib_device *ibdev , int mask , struct ib_device_modify *props ) 
{ struct mthca_dev *tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  struct mthca_dev *tmp___1 ;

  {
#line 306
  if ((mask & -3) != 0) {
#line 307
    return (-95);
  } else {

  }
#line 309
  if ((mask & 2) != 0) {
#line 310
    tmp = to_mdev(ibdev);
#line 310
    tmp___0 = ldv_mutex_lock_interruptible_184(& tmp->cap_mask_mutex);
#line 310
    if (tmp___0 != 0) {
#line 311
      return (-512);
    } else {

    }
#line 312
    __len = 64UL;
#line 312
    if (__len > 63UL) {
#line 312
      __ret = __memcpy((void *)(& ibdev->node_desc), (void const   *)(& props->node_desc),
                       __len);
    } else {
#line 312
      __ret = __builtin_memcpy((void *)(& ibdev->node_desc), (void const   *)(& props->node_desc),
                               __len);
    }
#line 313
    tmp___1 = to_mdev(ibdev);
#line 313
    ldv_mutex_unlock_185(& tmp___1->cap_mask_mutex);
  } else {

  }
#line 316
  return (0);
}
}
#line 319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_modify_port(struct ib_device *ibdev , u8 port , int port_modify_mask ,
                             struct ib_port_modify *props ) 
{ struct mthca_set_ib_param set_ib ;
  struct ib_port_attr attr ;
  int err ;
  struct mthca_dev *tmp ;
  int tmp___0 ;
  struct mthca_dev *tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 327
  tmp = to_mdev(ibdev);
#line 327
  tmp___0 = ldv_mutex_lock_interruptible_186(& tmp->cap_mask_mutex);
#line 327
  if (tmp___0 != 0) {
#line 328
    return (-512);
  } else {

  }
#line 330
  err = mthca_query_port(ibdev, (int )port, & attr);
#line 331
  if (err != 0) {
#line 332
    goto out;
  } else {

  }
#line 334
  set_ib.set_si_guid = 0;
#line 335
  set_ib.reset_qkey_viol = (port_modify_mask & 8) != 0;
#line 337
  set_ib.cap_mask = (attr.port_cap_flags | props->set_port_cap_mask) & ~ props->clr_port_cap_mask;
#line 340
  tmp___1 = to_mdev(ibdev);
#line 340
  err = mthca_SET_IB(tmp___1, & set_ib, (int )port);
#line 341
  if (err != 0) {
#line 342
    goto out;
  } else {

  }
  out: 
#line 344
  tmp___2 = to_mdev(ibdev);
#line 344
  ldv_mutex_unlock_187(& tmp___2->cap_mask_mutex);
#line 345
  return (err);
}
}
#line 348 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_query_pkey(struct ib_device *ibdev , u8 port , u16 index , u16 *pkey ) 
{ struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  __u16 tmp___3 ;

  {
#line 351
  in_mad = 0;
#line 352
  out_mad = 0;
#line 353
  err = -12;
#line 355
  tmp = kzalloc(256UL, 208U);
#line 355
  in_mad = (struct ib_smp *)tmp;
#line 356
  tmp___0 = kmalloc(256UL, 208U);
#line 356
  out_mad = (struct ib_smp *)tmp___0;
#line 357
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 358
    goto out;
  } else {

  }
#line 360
  init_query_mad(in_mad);
#line 361
  in_mad->attr_id = 5632U;
#line 362
  tmp___1 = __fswab32((unsigned int )index / 32U);
#line 362
  in_mad->attr_mod = tmp___1;
#line 364
  tmp___2 = to_mdev(ibdev);
#line 364
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, 0, 0, (void *)in_mad, (void *)out_mad);
#line 366
  if (err != 0) {
#line 367
    goto out;
  } else {

  }
#line 369
  tmp___3 = __fswab16((int )*((__be16 *)(& out_mad->data) + ((unsigned long )index & 31UL)));
#line 369
  *pkey = tmp___3;
  out: 
#line 372
  kfree((void const   *)in_mad);
#line 373
  kfree((void const   *)out_mad);
#line 374
  return (err);
}
}
#line 377 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_query_gid(struct ib_device *ibdev , u8 port , int index , union ib_gid *gid ) 
{ struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_dev *tmp___2 ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___3 ;
  struct mthca_dev *tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 380
  in_mad = 0;
#line 381
  out_mad = 0;
#line 382
  err = -12;
#line 384
  tmp = kzalloc(256UL, 208U);
#line 384
  in_mad = (struct ib_smp *)tmp;
#line 385
  tmp___0 = kmalloc(256UL, 208U);
#line 385
  out_mad = (struct ib_smp *)tmp___0;
#line 386
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 387
    goto out;
  } else {

  }
#line 389
  init_query_mad(in_mad);
#line 390
  in_mad->attr_id = 5376U;
#line 391
  tmp___1 = __fswab32((__u32 )port);
#line 391
  in_mad->attr_mod = tmp___1;
#line 393
  tmp___2 = to_mdev(ibdev);
#line 393
  err = mthca_MAD_IFC(tmp___2, 1, 1, (int )port, 0, 0, (void *)in_mad, (void *)out_mad);
#line 395
  if (err != 0) {
#line 396
    goto out;
  } else {

  }
#line 398
  __len = 8UL;
#line 398
  if (__len > 63UL) {
#line 398
    __ret = __memcpy((void *)(& gid->raw), (void const   *)(& out_mad->data) + 8U,
                     __len);
  } else {
#line 398
    __ret = __builtin_memcpy((void *)(& gid->raw), (void const   *)(& out_mad->data) + 8U,
                             __len);
  }
#line 400
  init_query_mad(in_mad);
#line 401
  in_mad->attr_id = 5120U;
#line 402
  tmp___3 = __fswab32((__u32 )(index / 8));
#line 402
  in_mad->attr_mod = tmp___3;
#line 404
  tmp___4 = to_mdev(ibdev);
#line 404
  err = mthca_MAD_IFC(tmp___4, 1, 1, (int )port, 0, 0, (void *)in_mad, (void *)out_mad);
#line 406
  if (err != 0) {
#line 407
    goto out;
  } else {

  }
#line 409
  __len___0 = 8UL;
#line 409
  if (__len___0 > 63UL) {
#line 409
    __ret___0 = __memcpy((void *)(& gid->raw) + 8U, (void const   *)(& out_mad->data) + (unsigned long )((index % 8) * 8),
                         __len___0);
  } else {
#line 409
    __ret___0 = __builtin_memcpy((void *)(& gid->raw) + 8U, (void const   *)(& out_mad->data) + (unsigned long )((index % 8) * 8),
                                 __len___0);
  }
  out: 
#line 412
  kfree((void const   *)in_mad);
#line 413
  kfree((void const   *)out_mad);
#line 414
  return (err);
}
}
#line 417 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_ucontext *mthca_alloc_ucontext(struct ib_device *ibdev , struct ib_udata *udata ) 
{ struct mthca_alloc_ucontext_resp uresp ;
  struct mthca_ucontext *context ;
  int err ;
  void *tmp ;
  struct mthca_dev *tmp___0 ;
  int tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_dev *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  struct mthca_dev *tmp___8 ;
  void *tmp___9 ;
  struct mthca_dev *tmp___10 ;
  long tmp___11 ;
  struct mthca_dev *tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  struct mthca_dev *tmp___15 ;
  struct mthca_dev *tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;

  {
#line 424
  tmp___0 = to_mdev(ibdev);
#line 424
  if (tmp___0->active) {
#line 424
    tmp___1 = 0;
  } else {
#line 424
    tmp___1 = 1;
  }
#line 424
  if (tmp___1) {
#line 425
    tmp = ERR_PTR(-11L);
#line 425
    return ((struct ib_ucontext *)tmp);
  } else {

  }
#line 427
  memset((void *)(& uresp), 0, 8UL);
#line 429
  tmp___2 = to_mdev(ibdev);
#line 429
  uresp.qp_tab_size = (__u32 )tmp___2->limits.num_qps;
#line 430
  tmp___4 = to_mdev(ibdev);
#line 430
  tmp___5 = mthca_is_memfree(tmp___4);
#line 430
  if (tmp___5 != 0) {
#line 431
    tmp___3 = to_mdev(ibdev);
#line 431
    uresp.uarc_size = (__u32 )tmp___3->uar_table.uarc_size;
  } else {
#line 433
    uresp.uarc_size = 0U;
  }
#line 435
  tmp___6 = kmalloc(176UL, 208U);
#line 435
  context = (struct mthca_ucontext *)tmp___6;
#line 436
  if ((unsigned long )context == (unsigned long )((struct mthca_ucontext *)0)) {
#line 437
    tmp___7 = ERR_PTR(-12L);
#line 437
    return ((struct ib_ucontext *)tmp___7);
  } else {

  }
#line 439
  tmp___8 = to_mdev(ibdev);
#line 439
  err = mthca_uar_alloc(tmp___8, & context->uar);
#line 440
  if (err != 0) {
#line 441
    kfree((void const   *)context);
#line 442
    tmp___9 = ERR_PTR((long )err);
#line 442
    return ((struct ib_ucontext *)tmp___9);
  } else {

  }
#line 445
  tmp___10 = to_mdev(ibdev);
#line 445
  context->db_tab = mthca_init_user_db_tab(tmp___10);
#line 446
  tmp___14 = IS_ERR((void const   *)context->db_tab);
#line 446
  if (tmp___14 != 0L) {
#line 447
    tmp___11 = PTR_ERR((void const   *)context->db_tab);
#line 447
    err = (int )tmp___11;
#line 448
    tmp___12 = to_mdev(ibdev);
#line 448
    mthca_uar_free(tmp___12, & context->uar);
#line 449
    kfree((void const   *)context);
#line 450
    tmp___13 = ERR_PTR((long )err);
#line 450
    return ((struct ib_ucontext *)tmp___13);
  } else {

  }
#line 453
  tmp___18 = ib_copy_to_udata(udata, (void *)(& uresp), 8UL);
#line 453
  if (tmp___18 != 0) {
#line 454
    tmp___15 = to_mdev(ibdev);
#line 454
    mthca_cleanup_user_db_tab(tmp___15, & context->uar, context->db_tab);
#line 455
    tmp___16 = to_mdev(ibdev);
#line 455
    mthca_uar_free(tmp___16, & context->uar);
#line 456
    kfree((void const   *)context);
#line 457
    tmp___17 = ERR_PTR(-14L);
#line 457
    return ((struct ib_ucontext *)tmp___17);
  } else {

  }
#line 460
  context->reg_mr_warned = 0;
#line 462
  return (& context->ibucontext);
}
}
#line 465 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_dealloc_ucontext(struct ib_ucontext *context ) 
{ struct mthca_ucontext *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;

  {
#line 467
  tmp = to_mucontext(context);
#line 467
  tmp___0 = to_mucontext(context);
#line 467
  tmp___1 = to_mdev(context->device);
#line 467
  mthca_cleanup_user_db_tab(tmp___1, & tmp___0->uar, tmp->db_tab);
#line 469
  tmp___2 = to_mucontext(context);
#line 469
  tmp___3 = to_mdev(context->device);
#line 469
  mthca_uar_free(tmp___3, & tmp___2->uar);
#line 470
  tmp___4 = to_mucontext(context);
#line 470
  kfree((void const   *)tmp___4);
#line 472
  return (0);
}
}
#line 475 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_mmap_uar(struct ib_ucontext *context , struct vm_area_struct *vma ) 
{ pgprot_t __constr_expr_0 ;
  struct mthca_ucontext *tmp ;
  int tmp___0 ;

  {
#line 478
  if (vma->vm_end - vma->vm_start != 4096UL) {
#line 479
    return (-22);
  } else {

  }
#line 481
  if ((unsigned int )boot_cpu_data.x86 > 3U) {
#line 481
    __constr_expr_0.pgprot = vma->vm_page_prot.pgprot | 16UL;
#line 481
    vma->vm_page_prot = __constr_expr_0;
  } else {
#line 481
    vma->vm_page_prot = vma->vm_page_prot;
  }
#line 483
  tmp = to_mucontext(context);
#line 483
  tmp___0 = remap_pfn_range(vma, vma->vm_start, tmp->uar.pfn, 4096UL, vma->vm_page_prot);
#line 483
  if (tmp___0 != 0) {
#line 486
    return (-11);
  } else {

  }
#line 488
  return (0);
}
}
#line 491 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_pd *mthca_alloc_pd(struct ib_device *ibdev , struct ib_ucontext *context ,
                                    struct ib_udata *udata ) 
{ struct mthca_pd *pd ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct mthca_dev *tmp___1 ;
  void *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 498
  tmp = kmalloc(96UL, 208U);
#line 498
  pd = (struct mthca_pd *)tmp;
#line 499
  if ((unsigned long )pd == (unsigned long )((struct mthca_pd *)0)) {
#line 500
    tmp___0 = ERR_PTR(-12L);
#line 500
    return ((struct ib_pd *)tmp___0);
  } else {

  }
#line 502
  tmp___1 = to_mdev(ibdev);
#line 502
  err = mthca_pd_alloc(tmp___1, (unsigned long )context == (unsigned long )((struct ib_ucontext *)0),
                       pd);
#line 503
  if (err != 0) {
#line 504
    kfree((void const   *)pd);
#line 505
    tmp___2 = ERR_PTR((long )err);
#line 505
    return ((struct ib_pd *)tmp___2);
  } else {

  }
#line 508
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 509
    tmp___5 = ib_copy_to_udata(udata, (void *)(& pd->pd_num), 4UL);
#line 509
    if (tmp___5 != 0) {
#line 510
      tmp___3 = to_mdev(ibdev);
#line 510
      mthca_pd_free(tmp___3, pd);
#line 511
      kfree((void const   *)pd);
#line 512
      tmp___4 = ERR_PTR(-14L);
#line 512
      return ((struct ib_pd *)tmp___4);
    } else {

    }
  } else {

  }
#line 516
  return (& pd->ibpd);
}
}
#line 519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_dealloc_pd(struct ib_pd *pd ) 
{ struct mthca_pd *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 521
  tmp = to_mpd(pd);
#line 521
  tmp___0 = to_mdev(pd->device);
#line 521
  mthca_pd_free(tmp___0, tmp);
#line 522
  kfree((void const   *)pd);
#line 524
  return (0);
}
}
#line 527 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_ah *mthca_ah_create(struct ib_pd *pd , struct ib_ah_attr *ah_attr ) 
{ int err ;
  struct mthca_ah *ah ;
  void *tmp ;
  void *tmp___0 ;
  struct mthca_pd *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  void *tmp___3 ;

  {
#line 533
  tmp = kmalloc(48UL, 32U);
#line 533
  ah = (struct mthca_ah *)tmp;
#line 534
  if ((unsigned long )ah == (unsigned long )((struct mthca_ah *)0)) {
#line 535
    tmp___0 = ERR_PTR(-12L);
#line 535
    return ((struct ib_ah *)tmp___0);
  } else {

  }
#line 537
  tmp___1 = to_mpd(pd);
#line 537
  tmp___2 = to_mdev(pd->device);
#line 537
  err = mthca_create_ah(tmp___2, tmp___1, ah_attr, ah);
#line 538
  if (err != 0) {
#line 539
    kfree((void const   *)ah);
#line 540
    tmp___3 = ERR_PTR((long )err);
#line 540
    return ((struct ib_ah *)tmp___3);
  } else {

  }
#line 543
  return (& ah->ibah);
}
}
#line 546 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_ah_destroy(struct ib_ah *ah ) 
{ struct mthca_ah *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 548
  tmp = to_mah(ah);
#line 548
  tmp___0 = to_mdev(ah->device);
#line 548
  mthca_destroy_ah(tmp___0, tmp);
#line 549
  kfree((void const   *)ah);
#line 551
  return (0);
}
}
#line 554 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_srq *mthca_create_srq(struct ib_pd *pd , struct ib_srq_init_attr *init_attr ,
                                       struct ib_udata *udata ) 
{ struct mthca_create_srq ucmd ;
  struct mthca_ucontext *context ;
  struct mthca_srq *srq ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct mthca_dev *tmp___3 ;
  struct mthca_pd *tmp___4 ;
  struct mthca_dev *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
#line 559
  context = 0;
#line 563
  if ((unsigned int )init_attr->srq_type != 0U) {
#line 564
    tmp = ERR_PTR(-38L);
#line 564
    return ((struct ib_srq *)tmp);
  } else {

  }
#line 566
  tmp___0 = kmalloc(544UL, 208U);
#line 566
  srq = (struct mthca_srq *)tmp___0;
#line 567
  if ((unsigned long )srq == (unsigned long )((struct mthca_srq *)0)) {
#line 568
    tmp___1 = ERR_PTR(-12L);
#line 568
    return ((struct ib_srq *)tmp___1);
  } else {

  }
#line 570
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 571
    context = to_mucontext((pd->uobject)->context);
#line 573
    tmp___2 = ib_copy_from_udata((void *)(& ucmd), udata, 16UL);
#line 573
    if (tmp___2 != 0) {
#line 574
      err = -14;
#line 575
      goto err_free;
    } else {

    }
#line 578
    tmp___3 = to_mdev(pd->device);
#line 578
    err = mthca_map_user_db(tmp___3, & context->uar, context->db_tab, (int )ucmd.db_index,
                            ucmd.db_page);
#line 582
    if (err != 0) {
#line 583
      goto err_free;
    } else {

    }
#line 585
    srq->mr.ibmr.lkey = ucmd.lkey;
#line 586
    srq->db_index = (int )ucmd.db_index;
  } else {

  }
#line 589
  tmp___4 = to_mpd(pd);
#line 589
  tmp___5 = to_mdev(pd->device);
#line 589
  err = mthca_alloc_srq(tmp___5, tmp___4, & init_attr->attr, srq);
#line 592
  if (err != 0 && (unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 593
    tmp___6 = to_mdev(pd->device);
#line 593
    mthca_unmap_user_db(tmp___6, & context->uar, context->db_tab, (int )ucmd.db_index);
  } else {

  }
#line 596
  if (err != 0) {
#line 597
    goto err_free;
  } else {

  }
#line 599
  if ((unsigned long )context != (unsigned long )((struct mthca_ucontext *)0)) {
#line 599
    tmp___8 = ib_copy_to_udata(udata, (void *)(& srq->srqn), 4UL);
#line 599
    if (tmp___8 != 0) {
#line 600
      tmp___7 = to_mdev(pd->device);
#line 600
      mthca_free_srq(tmp___7, srq);
#line 601
      err = -14;
#line 602
      goto err_free;
    } else {

    }
  } else {

  }
#line 605
  return (& srq->ibsrq);
  err_free: 
#line 608
  kfree((void const   *)srq);
#line 610
  tmp___9 = ERR_PTR((long )err);
#line 610
  return ((struct ib_srq *)tmp___9);
}
}
#line 613 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_destroy_srq(struct ib_srq *srq ) 
{ struct mthca_ucontext *context ;
  struct mthca_srq *tmp ;
  struct mthca_dev *tmp___0 ;
  struct mthca_srq *tmp___1 ;
  struct mthca_dev *tmp___2 ;

  {
#line 617
  if ((unsigned long )srq->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 618
    context = to_mucontext((srq->uobject)->context);
#line 620
    tmp = to_msrq(srq);
#line 620
    tmp___0 = to_mdev(srq->device);
#line 620
    mthca_unmap_user_db(tmp___0, & context->uar, context->db_tab, tmp->db_index);
  } else {

  }
#line 624
  tmp___1 = to_msrq(srq);
#line 624
  tmp___2 = to_mdev(srq->device);
#line 624
  mthca_free_srq(tmp___2, tmp___1);
#line 625
  kfree((void const   *)srq);
#line 627
  return (0);
}
}
#line 630 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_qp *mthca_create_qp(struct ib_pd *pd , struct ib_qp_init_attr *init_attr ,
                                     struct ib_udata *udata ) 
{ struct mthca_create_qp ucmd ;
  struct mthca_qp *qp ;
  int err ;
  void *tmp ;
  struct mthca_ucontext *context ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct mthca_dev *tmp___4 ;
  void *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  void *tmp___8 ;
  struct mthca_cq *tmp___9 ;
  struct mthca_cq *tmp___10 ;
  struct mthca_pd *tmp___11 ;
  struct mthca_dev *tmp___12 ;
  struct mthca_dev *tmp___13 ;
  struct mthca_dev *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  struct mthca_sqp *tmp___18 ;
  struct mthca_cq *tmp___19 ;
  struct mthca_cq *tmp___20 ;
  struct mthca_pd *tmp___21 ;
  struct mthca_dev *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;

  {
#line 638
  if ((int )init_attr->create_flags != 0) {
#line 639
    tmp = ERR_PTR(-22L);
#line 639
    return ((struct ib_qp *)tmp);
  } else {

  }
#line 641
  switch ((unsigned int )init_attr->qp_type) {
  case 2: ;
  case 3: ;
  case 4: 
#line 648
  tmp___0 = kmalloc(760UL, 208U);
#line 648
  qp = (struct mthca_qp *)tmp___0;
#line 649
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 650
    tmp___1 = ERR_PTR(-12L);
#line 650
    return ((struct ib_qp *)tmp___1);
  } else {

  }
#line 652
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 653
    context = to_mucontext((pd->uobject)->context);
#line 655
    tmp___3 = ib_copy_from_udata((void *)(& ucmd), udata, 32UL);
#line 655
    if (tmp___3 != 0) {
#line 656
      kfree((void const   *)qp);
#line 657
      tmp___2 = ERR_PTR(-14L);
#line 657
      return ((struct ib_qp *)tmp___2);
    } else {

    }
#line 660
    tmp___4 = to_mdev(pd->device);
#line 660
    err = mthca_map_user_db(tmp___4, & context->uar, context->db_tab, (int )ucmd.sq_db_index,
                            ucmd.sq_db_page);
#line 663
    if (err != 0) {
#line 664
      kfree((void const   *)qp);
#line 665
      tmp___5 = ERR_PTR((long )err);
#line 665
      return ((struct ib_qp *)tmp___5);
    } else {

    }
#line 668
    tmp___6 = to_mdev(pd->device);
#line 668
    err = mthca_map_user_db(tmp___6, & context->uar, context->db_tab, (int )ucmd.rq_db_index,
                            ucmd.rq_db_page);
#line 671
    if (err != 0) {
#line 672
      tmp___7 = to_mdev(pd->device);
#line 672
      mthca_unmap_user_db(tmp___7, & context->uar, context->db_tab, (int )ucmd.sq_db_index);
#line 676
      kfree((void const   *)qp);
#line 677
      tmp___8 = ERR_PTR((long )err);
#line 677
      return ((struct ib_qp *)tmp___8);
    } else {

    }
#line 680
    qp->mr.ibmr.lkey = ucmd.lkey;
#line 681
    qp->sq.db_index = (int )ucmd.sq_db_index;
#line 682
    qp->rq.db_index = (int )ucmd.rq_db_index;
  } else {

  }
#line 685
  tmp___9 = to_mcq(init_attr->recv_cq);
#line 685
  tmp___10 = to_mcq(init_attr->send_cq);
#line 685
  tmp___11 = to_mpd(pd);
#line 685
  tmp___12 = to_mdev(pd->device);
#line 685
  err = mthca_alloc_qp(tmp___12, tmp___11, tmp___10, tmp___9, init_attr->qp_type,
                       init_attr->sq_sig_type, & init_attr->cap, qp);
#line 691
  if (err != 0 && (unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 692
    context = to_mucontext((pd->uobject)->context);
#line 694
    tmp___13 = to_mdev(pd->device);
#line 694
    mthca_unmap_user_db(tmp___13, & context->uar, context->db_tab, (int )ucmd.sq_db_index);
#line 698
    tmp___14 = to_mdev(pd->device);
#line 698
    mthca_unmap_user_db(tmp___14, & context->uar, context->db_tab, (int )ucmd.rq_db_index);
  } else {

  }
#line 704
  qp->ibqp.qp_num = qp->qpn;
#line 705
  goto ldv_27420;
  case 0: ;
  case 1: ;
#line 711
  if ((unsigned long )pd->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 712
    tmp___15 = ERR_PTR(-22L);
#line 712
    return ((struct ib_qp *)tmp___15);
  } else {

  }
#line 714
  tmp___16 = kmalloc(936UL, 208U);
#line 714
  qp = (struct mthca_qp *)tmp___16;
#line 715
  if ((unsigned long )qp == (unsigned long )((struct mthca_qp *)0)) {
#line 716
    tmp___17 = ERR_PTR(-12L);
#line 716
    return ((struct ib_qp *)tmp___17);
  } else {

  }
#line 718
  qp->ibqp.qp_num = (unsigned int )init_attr->qp_type != 0U;
#line 720
  tmp___18 = to_msqp(qp);
#line 720
  tmp___19 = to_mcq(init_attr->recv_cq);
#line 720
  tmp___20 = to_mcq(init_attr->send_cq);
#line 720
  tmp___21 = to_mpd(pd);
#line 720
  tmp___22 = to_mdev(pd->device);
#line 720
  err = mthca_alloc_sqp(tmp___22, tmp___21, tmp___20, tmp___19, init_attr->sq_sig_type,
                        & init_attr->cap, (int )qp->ibqp.qp_num, (int )init_attr->port_num,
                        tmp___18);
#line 726
  goto ldv_27420;
  default: 
#line 730
  tmp___23 = ERR_PTR(-38L);
#line 730
  return ((struct ib_qp *)tmp___23);
  }
  ldv_27420: ;
#line 733
  if (err != 0) {
#line 734
    kfree((void const   *)qp);
#line 735
    tmp___24 = ERR_PTR((long )err);
#line 735
    return ((struct ib_qp *)tmp___24);
  } else {

  }
#line 738
  init_attr->cap.max_send_wr = (u32 )qp->sq.max;
#line 739
  init_attr->cap.max_recv_wr = (u32 )qp->rq.max;
#line 740
  init_attr->cap.max_send_sge = (u32 )qp->sq.max_gs;
#line 741
  init_attr->cap.max_recv_sge = (u32 )qp->rq.max_gs;
#line 742
  init_attr->cap.max_inline_data = (u32 )qp->max_inline_data;
#line 744
  return (& qp->ibqp);
}
}
#line 747 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_destroy_qp(struct ib_qp *qp ) 
{ struct mthca_qp *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_qp *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_ucontext *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_qp *tmp___7 ;
  struct mthca_dev *tmp___8 ;

  {
#line 749
  if ((unsigned long )qp->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 750
    tmp = to_mqp(qp);
#line 750
    tmp___0 = to_mucontext((qp->uobject)->context);
#line 750
    tmp___1 = to_mucontext((qp->uobject)->context);
#line 750
    tmp___2 = to_mdev(qp->device);
#line 750
    mthca_unmap_user_db(tmp___2, & tmp___1->uar, tmp___0->db_tab, tmp->sq.db_index);
#line 754
    tmp___3 = to_mqp(qp);
#line 754
    tmp___4 = to_mucontext((qp->uobject)->context);
#line 754
    tmp___5 = to_mucontext((qp->uobject)->context);
#line 754
    tmp___6 = to_mdev(qp->device);
#line 754
    mthca_unmap_user_db(tmp___6, & tmp___5->uar, tmp___4->db_tab, tmp___3->rq.db_index);
  } else {

  }
#line 759
  tmp___7 = to_mqp(qp);
#line 759
  tmp___8 = to_mdev(qp->device);
#line 759
  mthca_free_qp(tmp___8, tmp___7);
#line 760
  kfree((void const   *)qp);
#line 761
  return (0);
}
}
#line 764 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_cq *mthca_create_cq(struct ib_device *ibdev , int entries , int comp_vector ,
                                     struct ib_ucontext *context , struct ib_udata *udata ) 
{ struct mthca_create_cq ucmd ;
  struct mthca_cq *cq ;
  int nent ;
  int err ;
  void *tmp ;
  struct mthca_dev *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct mthca_ucontext *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_dev *tmp___5 ;
  void *tmp___6 ;
  struct mthca_ucontext *tmp___7 ;
  struct mthca_ucontext *tmp___8 ;
  struct mthca_dev *tmp___9 ;
  void *tmp___10 ;
  struct mthca_dev *tmp___11 ;
  unsigned int tmp___12 ;
  struct mthca_ucontext *tmp___13 ;
  struct mthca_ucontext *tmp___14 ;
  struct mthca_dev *tmp___15 ;
  struct mthca_dev *tmp___16 ;
  int tmp___17 ;
  struct mthca_ucontext *tmp___18 ;
  struct mthca_ucontext *tmp___19 ;
  struct mthca_dev *tmp___20 ;
  struct mthca_ucontext *tmp___21 ;
  struct mthca_ucontext *tmp___22 ;
  struct mthca_dev *tmp___23 ;
  void *tmp___24 ;

  {
#line 774
  if (entries <= 0) {
#line 775
    tmp = ERR_PTR(-22L);
#line 775
    return ((struct ib_cq *)tmp);
  } else {
#line 774
    tmp___0 = to_mdev(ibdev);
#line 774
    if (tmp___0->limits.max_cqes < entries) {
#line 775
      tmp = ERR_PTR(-22L);
#line 775
      return ((struct ib_cq *)tmp);
    } else {

    }
  }
#line 777
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 778
    tmp___2 = ib_copy_from_udata((void *)(& ucmd), udata, 32UL);
#line 778
    if (tmp___2 != 0) {
#line 779
      tmp___1 = ERR_PTR(-14L);
#line 779
      return ((struct ib_cq *)tmp___1);
    } else {

    }
#line 781
    tmp___3 = to_mucontext(context);
#line 781
    tmp___4 = to_mucontext(context);
#line 781
    tmp___5 = to_mdev(ibdev);
#line 781
    err = mthca_map_user_db(tmp___5, & tmp___4->uar, tmp___3->db_tab, (int )ucmd.set_db_index,
                            ucmd.set_db_page);
#line 784
    if (err != 0) {
#line 785
      tmp___6 = ERR_PTR((long )err);
#line 785
      return ((struct ib_cq *)tmp___6);
    } else {

    }
#line 787
    tmp___7 = to_mucontext(context);
#line 787
    tmp___8 = to_mucontext(context);
#line 787
    tmp___9 = to_mdev(ibdev);
#line 787
    err = mthca_map_user_db(tmp___9, & tmp___8->uar, tmp___7->db_tab, (int )ucmd.arm_db_index,
                            ucmd.arm_db_page);
#line 790
    if (err != 0) {
#line 791
      goto err_unmap_set;
    } else {

    }
  } else {

  }
#line 794
  tmp___10 = kmalloc(520UL, 208U);
#line 794
  cq = (struct mthca_cq *)tmp___10;
#line 795
  if ((unsigned long )cq == (unsigned long )((struct mthca_cq *)0)) {
#line 796
    err = -12;
#line 797
    goto err_unmap_arm;
  } else {

  }
#line 800
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 801
    cq->buf.mr.ibmr.lkey = ucmd.lkey;
#line 802
    cq->set_ci_db_index = (int )ucmd.set_db_index;
#line 803
    cq->arm_db_index = (int )ucmd.arm_db_index;
  } else {

  }
#line 806
  nent = 1;
#line 806
  goto ldv_27441;
  ldv_27440: 
#line 806
  nent = nent << 1;
  ldv_27441: ;
#line 806
  if (nent <= entries) {
#line 807
    goto ldv_27440;
  } else {
#line 809
    goto ldv_27442;
  }
  ldv_27442: ;
#line 809
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 809
    tmp___12 = ucmd.pdn;
  } else {
#line 809
    tmp___11 = to_mdev(ibdev);
#line 809
    tmp___12 = tmp___11->driver_pd.pd_num;
  }
#line 809
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 809
    tmp___13 = to_mucontext(context);
#line 809
    tmp___14 = tmp___13;
  } else {
#line 809
    tmp___14 = 0;
  }
#line 809
  tmp___15 = to_mdev(ibdev);
#line 809
  err = mthca_init_cq(tmp___15, nent, tmp___14, tmp___12, cq);
#line 813
  if (err != 0) {
#line 814
    goto err_free;
  } else {

  }
#line 816
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 816
    tmp___17 = ib_copy_to_udata(udata, (void *)(& cq->cqn), 4UL);
#line 816
    if (tmp___17 != 0) {
#line 817
      tmp___16 = to_mdev(ibdev);
#line 817
      mthca_free_cq(tmp___16, cq);
#line 818
      goto err_free;
    } else {

    }
  } else {

  }
#line 821
  cq->resize_buf = 0;
#line 823
  return (& cq->ibcq);
  err_free: 
#line 826
  kfree((void const   *)cq);
  err_unmap_arm: ;
#line 829
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 830
    tmp___18 = to_mucontext(context);
#line 830
    tmp___19 = to_mucontext(context);
#line 830
    tmp___20 = to_mdev(ibdev);
#line 830
    mthca_unmap_user_db(tmp___20, & tmp___19->uar, tmp___18->db_tab, (int )ucmd.arm_db_index);
  } else {

  }
  err_unmap_set: ;
#line 834
  if ((unsigned long )context != (unsigned long )((struct ib_ucontext *)0)) {
#line 835
    tmp___21 = to_mucontext(context);
#line 835
    tmp___22 = to_mucontext(context);
#line 835
    tmp___23 = to_mdev(ibdev);
#line 835
    mthca_unmap_user_db(tmp___23, & tmp___22->uar, tmp___21->db_tab, (int )ucmd.set_db_index);
  } else {

  }
#line 838
  tmp___24 = ERR_PTR((long )err);
#line 838
  return ((struct ib_cq *)tmp___24);
}
}
#line 841 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_alloc_resize_buf(struct mthca_dev *dev , struct mthca_cq *cq , int entries ) 
{ int ret ;
  void *tmp ;

  {
#line 846
  spin_lock_irq(& cq->lock);
#line 847
  if ((unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0)) {
#line 848
    ret = -16;
#line 849
    goto unlock;
  } else {

  }
#line 852
  tmp = kmalloc(88UL, 32U);
#line 852
  cq->resize_buf = (struct mthca_cq_resize *)tmp;
#line 853
  if ((unsigned long )cq->resize_buf == (unsigned long )((struct mthca_cq_resize *)0)) {
#line 854
    ret = -12;
#line 855
    goto unlock;
  } else {

  }
#line 858
  (cq->resize_buf)->state = 0;
#line 860
  ret = 0;
  unlock: 
#line 863
  spin_unlock_irq(& cq->lock);
#line 865
  if (ret != 0) {
#line 866
    return (ret);
  } else {

  }
#line 868
  ret = mthca_alloc_cq_buf(dev, & (cq->resize_buf)->buf, entries);
#line 869
  if (ret != 0) {
#line 870
    spin_lock_irq(& cq->lock);
#line 871
    kfree((void const   *)cq->resize_buf);
#line 872
    cq->resize_buf = 0;
#line 873
    spin_unlock_irq(& cq->lock);
#line 874
    return (ret);
  } else {

  }
#line 877
  (cq->resize_buf)->cqe = entries + -1;
#line 879
  spin_lock_irq(& cq->lock);
#line 880
  (cq->resize_buf)->state = 1;
#line 881
  spin_unlock_irq(& cq->lock);
#line 883
  return (0);
}
}
#line 886 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_resize_cq(struct ib_cq *ibcq , int entries , struct ib_udata *udata ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_cq *cq ;
  struct mthca_cq *tmp___0 ;
  struct mthca_resize_cq ucmd ;
  u32 lkey ;
  int ret ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct mthca_cq_buf tbuf ;
  int tcqe ;

  {
#line 888
  tmp = to_mdev(ibcq->device);
#line 888
  dev = tmp;
#line 889
  tmp___0 = to_mcq(ibcq);
#line 889
  cq = tmp___0;
#line 894
  if (entries <= 0 || dev->limits.max_cqes < entries) {
#line 895
    return (-22);
  } else {

  }
#line 897
  ldv_mutex_lock_188(& cq->mutex);
#line 899
  tmp___1 = __roundup_pow_of_two((unsigned long )(entries + 1));
#line 899
  entries = (int )tmp___1;
#line 900
  if (ibcq->cqe + 1 == entries) {
#line 901
    ret = 0;
#line 902
    goto out;
  } else {

  }
#line 905
  if (cq->is_kernel != 0) {
#line 906
    ret = mthca_alloc_resize_buf(dev, cq, entries);
#line 907
    if (ret != 0) {
#line 908
      goto out;
    } else {

    }
#line 909
    lkey = (cq->resize_buf)->buf.mr.ibmr.lkey;
  } else {
#line 911
    tmp___2 = ib_copy_from_udata((void *)(& ucmd), udata, 8UL);
#line 911
    if (tmp___2 != 0) {
#line 912
      ret = -14;
#line 913
      goto out;
    } else {

    }
#line 915
    lkey = ucmd.lkey;
  }
#line 918
  tmp___3 = __ilog2_u32((u32 )entries);
#line 918
  ret = mthca_RESIZE_CQ(dev, cq->cqn, lkey, (int )((u8 )tmp___3));
#line 920
  if (ret != 0) {
#line 921
    if ((unsigned long )cq->resize_buf != (unsigned long )((struct mthca_cq_resize *)0)) {
#line 922
      mthca_free_cq_buf(dev, & (cq->resize_buf)->buf, (cq->resize_buf)->cqe);
#line 924
      kfree((void const   *)cq->resize_buf);
#line 925
      spin_lock_irq(& cq->lock);
#line 926
      cq->resize_buf = 0;
#line 927
      spin_unlock_irq(& cq->lock);
    } else {

    }
#line 929
    goto out;
  } else {

  }
#line 932
  if (cq->is_kernel != 0) {
#line 936
    spin_lock_irq(& cq->lock);
#line 937
    if ((unsigned int )(cq->resize_buf)->state == 1U) {
#line 938
      mthca_cq_resize_copy_cqes(cq);
#line 939
      tbuf = cq->buf;
#line 940
      tcqe = cq->ibcq.cqe;
#line 941
      cq->buf = (cq->resize_buf)->buf;
#line 942
      cq->ibcq.cqe = (cq->resize_buf)->cqe;
    } else {
#line 944
      tbuf = (cq->resize_buf)->buf;
#line 945
      tcqe = (cq->resize_buf)->cqe;
    }
#line 948
    kfree((void const   *)cq->resize_buf);
#line 949
    cq->resize_buf = 0;
#line 950
    spin_unlock_irq(& cq->lock);
#line 952
    mthca_free_cq_buf(dev, & tbuf, tcqe);
  } else {
#line 954
    ibcq->cqe = entries + -1;
  }
  out: 
#line 957
  ldv_mutex_unlock_189(& cq->mutex);
#line 959
  return (ret);
}
}
#line 962 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_destroy_cq(struct ib_cq *cq ) 
{ struct mthca_cq *tmp ;
  struct mthca_ucontext *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_dev *tmp___2 ;
  struct mthca_cq *tmp___3 ;
  struct mthca_ucontext *tmp___4 ;
  struct mthca_ucontext *tmp___5 ;
  struct mthca_dev *tmp___6 ;
  struct mthca_cq *tmp___7 ;
  struct mthca_dev *tmp___8 ;

  {
#line 964
  if ((unsigned long )cq->uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 965
    tmp = to_mcq(cq);
#line 965
    tmp___0 = to_mucontext((cq->uobject)->context);
#line 965
    tmp___1 = to_mucontext((cq->uobject)->context);
#line 965
    tmp___2 = to_mdev(cq->device);
#line 965
    mthca_unmap_user_db(tmp___2, & tmp___1->uar, tmp___0->db_tab, tmp->arm_db_index);
#line 969
    tmp___3 = to_mcq(cq);
#line 969
    tmp___4 = to_mucontext((cq->uobject)->context);
#line 969
    tmp___5 = to_mucontext((cq->uobject)->context);
#line 969
    tmp___6 = to_mdev(cq->device);
#line 969
    mthca_unmap_user_db(tmp___6, & tmp___5->uar, tmp___4->db_tab, tmp___3->set_ci_db_index);
  } else {

  }
#line 974
  tmp___7 = to_mcq(cq);
#line 974
  tmp___8 = to_mdev(cq->device);
#line 974
  mthca_free_cq(tmp___8, tmp___7);
#line 975
  kfree((void const   *)cq);
#line 977
  return (0);
}
}
#line 980 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
__inline static u32 convert_access(int acc ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 982
  if ((acc & 8) != 0) {
#line 982
    tmp = 16384;
  } else {
#line 982
    tmp = 0;
  }
#line 982
  if ((acc & 2) != 0) {
#line 982
    tmp___0 = 8192;
  } else {
#line 982
    tmp___0 = 0;
  }
#line 982
  if ((acc & 4) != 0) {
#line 982
    tmp___1 = 4096;
  } else {
#line 982
    tmp___1 = 0;
  }
#line 982
  if (acc & 1) {
#line 982
    tmp___2 = 2048;
  } else {
#line 982
    tmp___2 = 0;
  }
#line 982
  return ((u32 )((((tmp | tmp___0) | tmp___1) | tmp___2) | 1024));
}
}
#line 989 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_mr *mthca_get_dma_mr(struct ib_pd *pd , int acc ) 
{ struct mthca_mr *mr ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  struct mthca_pd *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;

  {
#line 994
  tmp = kmalloc(56UL, 208U);
#line 994
  mr = (struct mthca_mr *)tmp;
#line 995
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 996
    tmp___0 = ERR_PTR(-12L);
#line 996
    return ((struct ib_mr *)tmp___0);
  } else {

  }
#line 998
  tmp___1 = convert_access(acc);
#line 998
  tmp___2 = to_mpd(pd);
#line 998
  tmp___3 = to_mdev(pd->device);
#line 998
  err = mthca_mr_alloc_notrans(tmp___3, tmp___2->pd_num, tmp___1, mr);
#line 1002
  if (err != 0) {
#line 1003
    kfree((void const   *)mr);
#line 1004
    tmp___4 = ERR_PTR((long )err);
#line 1004
    return ((struct ib_mr *)tmp___4);
  } else {

  }
#line 1007
  mr->umem = 0;
#line 1009
  return (& mr->ibmr);
}
}
#line 1012 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_mr *mthca_reg_phys_mr(struct ib_pd *pd , struct ib_phys_buf *buffer_list ,
                                       int num_phys_buf , int acc , u64 *iova_start ) 
{ struct mthca_mr *mr ;
  u64 *page_list ;
  u64 total_size ;
  unsigned long mask ;
  int shift ;
  int npages ;
  int err ;
  int i ;
  int j ;
  int n ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  struct mthca_pd *tmp___6 ;
  struct mthca_dev *tmp___7 ;
  u32 tmp___8 ;
  struct mthca_pd *tmp___9 ;
  struct mthca_dev *tmp___10 ;
  void *tmp___11 ;

  {
#line 1027
  mask = (unsigned long )(buffer_list->addr ^ *iova_start);
#line 1028
  total_size = 0ULL;
#line 1029
  i = 0;
#line 1029
  goto ldv_27494;
  ldv_27493: ;
#line 1030
  if (i != 0) {
#line 1031
    mask = (unsigned long )((buffer_list + (unsigned long )i)->addr | (unsigned long long )mask);
  } else {

  }
#line 1032
  if (num_phys_buf + -1 != i) {
#line 1033
    mask = (unsigned long )(((buffer_list + (unsigned long )i)->addr + (buffer_list + (unsigned long )i)->size) | (unsigned long long )mask);
  } else {

  }
#line 1035
  total_size = (buffer_list + (unsigned long )i)->size + total_size;
#line 1029
  i = i + 1;
  ldv_27494: ;
#line 1029
  if (i < num_phys_buf) {
#line 1030
    goto ldv_27493;
  } else {
#line 1032
    goto ldv_27495;
  }
  ldv_27495: ;
#line 1038
  if ((mask & 4095UL) != 0UL) {
#line 1039
    tmp = ERR_PTR(-22L);
#line 1039
    return ((struct ib_mr *)tmp);
  } else {

  }
#line 1041
  tmp___0 = __ffs(mask | 0xffffffff80000000UL);
#line 1041
  shift = (int )tmp___0;
#line 1043
  buffer_list->size = buffer_list->size + (buffer_list->addr & ((1ULL << shift) - 1ULL));
#line 1044
  buffer_list->addr = buffer_list->addr & (0xffffffffffffffffULL << shift);
#line 1046
  tmp___1 = kmalloc(56UL, 208U);
#line 1046
  mr = (struct mthca_mr *)tmp___1;
#line 1047
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 1048
    tmp___2 = ERR_PTR(-12L);
#line 1048
    return ((struct ib_mr *)tmp___2);
  } else {

  }
#line 1050
  npages = 0;
#line 1051
  i = 0;
#line 1051
  goto ldv_27497;
  ldv_27496: 
#line 1052
  npages = (int )((unsigned int )((((buffer_list + (unsigned long )i)->size + (1ULL << shift)) - 1ULL) >> shift) + (unsigned int )npages);
#line 1051
  i = i + 1;
  ldv_27497: ;
#line 1051
  if (i < num_phys_buf) {
#line 1052
    goto ldv_27496;
  } else {
#line 1054
    goto ldv_27498;
  }
  ldv_27498: ;
#line 1054
  if (npages == 0) {
#line 1055
    return (& mr->ibmr);
  } else {

  }
#line 1057
  tmp___3 = kmalloc((unsigned long )npages * 8UL, 208U);
#line 1057
  page_list = (u64 *)tmp___3;
#line 1058
  if ((unsigned long )page_list == (unsigned long )((u64 *)0)) {
#line 1059
    kfree((void const   *)mr);
#line 1060
    tmp___4 = ERR_PTR(-12L);
#line 1060
    return ((struct ib_mr *)tmp___4);
  } else {

  }
#line 1063
  n = 0;
#line 1064
  i = 0;
#line 1064
  goto ldv_27503;
  ldv_27502: 
#line 1065
  j = 0;
#line 1065
  goto ldv_27500;
  ldv_27499: 
#line 1068
  tmp___5 = n;
#line 1068
  n = n + 1;
#line 1068
  *(page_list + (unsigned long )tmp___5) = (buffer_list + (unsigned long )i)->addr + ((unsigned long long )j << shift);
#line 1067
  j = j + 1;
  ldv_27500: ;
#line 1065
  if ((unsigned long long )j < (((buffer_list + (unsigned long )i)->size + (1ULL << shift)) - 1ULL) >> shift) {
#line 1067
    goto ldv_27499;
  } else {
#line 1069
    goto ldv_27501;
  }
  ldv_27501: 
#line 1064
  i = i + 1;
  ldv_27503: ;
#line 1064
  if (i < num_phys_buf) {
#line 1065
    goto ldv_27502;
  } else {
#line 1067
    goto ldv_27504;
  }
  ldv_27504: ;
#line 1070
  if (mthca_debug_level != 0) {
#line 1070
    tmp___6 = to_mpd(pd);
#line 1070
    tmp___7 = to_mdev(pd->device);
#line 1070
    dev_printk("\017", (struct device  const  *)(& (tmp___7->pdev)->dev), "Registering memory at %llx (iova %llx) in PD %x; shift %d, npages %d.\n",
               buffer_list->addr, *iova_start, tmp___6->pd_num, shift, npages);
  } else {

  }
#line 1077
  tmp___8 = convert_access(acc);
#line 1077
  tmp___9 = to_mpd(pd);
#line 1077
  tmp___10 = to_mdev(pd->device);
#line 1077
  err = mthca_mr_alloc_phys(tmp___10, tmp___9->pd_num, page_list, shift, npages, *iova_start,
                            total_size, tmp___8, mr);
#line 1083
  if (err != 0) {
#line 1084
    kfree((void const   *)page_list);
#line 1085
    kfree((void const   *)mr);
#line 1086
    tmp___11 = ERR_PTR((long )err);
#line 1086
    return ((struct ib_mr *)tmp___11);
  } else {

  }
#line 1089
  kfree((void const   *)page_list);
#line 1090
  mr->umem = 0;
#line 1092
  return (& mr->ibmr);
}
}
#line 1095 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_mr *mthca_reg_user_mr(struct ib_pd *pd , u64 start , u64 length ,
                                       u64 virt , int acc , struct ib_udata *udata ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct ib_umem_chunk *chunk ;
  struct mthca_mr *mr ;
  struct mthca_reg_mr ucmd ;
  u64 *pages ;
  int shift ;
  int n ;
  int len ;
  int i ;
  int j ;
  int k ;
  int err ;
  int write_mtt_size ;
  struct task_struct *tmp___0 ;
  struct mthca_ucontext *tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long tmp___12 ;
  int _min1 ;
  int tmp___13 ;
  int _min2 ;
  int tmp___14 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___15 ;
  struct list_head  const  *__mptr___2 ;
  u32 tmp___16 ;
  struct mthca_pd *tmp___17 ;
  void *tmp___18 ;

  {
#line 1098
  tmp = to_mdev(pd->device);
#line 1098
  dev = tmp;
#line 1105
  err = 0;
#line 1108
  if (udata->inlen - 8UL <= 7UL) {
#line 1109
    tmp___1 = to_mucontext((pd->uobject)->context);
#line 1109
    if (tmp___1->reg_mr_warned == 0) {
#line 1110
      tmp___0 = get_current();
#line 1110
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Process \'%s\' did not pass in MR attrs.\n",
               (char *)(& tmp___0->comm));
#line 1112
      dev_warn((struct device  const  *)(& (dev->pdev)->dev), "  Update libmthca to fix this.\n");
    } else {

    }
#line 1114
    tmp___2 = to_mucontext((pd->uobject)->context);
#line 1114
    tmp___2->reg_mr_warned = tmp___2->reg_mr_warned + 1;
#line 1115
    ucmd.mr_attrs = 0U;
  } else {
#line 1116
    tmp___4 = ib_copy_from_udata((void *)(& ucmd), udata, 8UL);
#line 1116
    if (tmp___4 != 0) {
#line 1117
      tmp___3 = ERR_PTR(-14L);
#line 1117
      return ((struct ib_mr *)tmp___3);
    } else {

    }
  }
#line 1119
  tmp___5 = kmalloc(56UL, 208U);
#line 1119
  mr = (struct mthca_mr *)tmp___5;
#line 1120
  if ((unsigned long )mr == (unsigned long )((struct mthca_mr *)0)) {
#line 1121
    tmp___6 = ERR_PTR(-12L);
#line 1121
    return ((struct ib_mr *)tmp___6);
  } else {

  }
#line 1123
  mr->umem = ib_umem_get((pd->uobject)->context, (unsigned long )start, (size_t )length,
                         acc, (int )ucmd.mr_attrs & 1);
#line 1126
  tmp___8 = IS_ERR((void const   *)mr->umem);
#line 1126
  if (tmp___8 != 0L) {
#line 1127
    tmp___7 = PTR_ERR((void const   *)mr->umem);
#line 1127
    err = (int )tmp___7;
#line 1128
    goto err;
  } else {

  }
#line 1131
  tmp___9 = ffs((mr->umem)->page_size);
#line 1131
  shift = tmp___9 + -1;
#line 1133
  n = 0;
#line 1134
  __mptr = (struct list_head  const  *)(mr->umem)->chunk_list.next;
#line 1134
  chunk = (struct ib_umem_chunk *)__mptr;
#line 1134
  goto ldv_27532;
  ldv_27531: 
#line 1135
  n = chunk->nents + n;
#line 1134
  __mptr___0 = (struct list_head  const  *)chunk->list.next;
#line 1134
  chunk = (struct ib_umem_chunk *)__mptr___0;
  ldv_27532: ;
#line 1134
  if ((unsigned long )(& chunk->list) != (unsigned long )(& (mr->umem)->chunk_list)) {
#line 1135
    goto ldv_27531;
  } else {
#line 1137
    goto ldv_27533;
  }
  ldv_27533: 
#line 1137
  mr->mtt = mthca_alloc_mtt(dev, n);
#line 1138
  tmp___11 = IS_ERR((void const   *)mr->mtt);
#line 1138
  if (tmp___11 != 0L) {
#line 1139
    tmp___10 = PTR_ERR((void const   *)mr->mtt);
#line 1139
    err = (int )tmp___10;
#line 1140
    goto err_umem;
  } else {

  }
#line 1143
  tmp___12 = __get_free_pages(208U, 0U);
#line 1143
  pages = (u64 *)tmp___12;
#line 1144
  if ((unsigned long )pages == (unsigned long )((u64 *)0)) {
#line 1145
    err = -12;
#line 1146
    goto err_mtt;
  } else {

  }
#line 1149
  n = 0;
#line 1149
  i = n;
#line 1151
  tmp___13 = mthca_write_mtt_size(dev);
#line 1151
  _min1 = tmp___13;
#line 1151
  _min2 = 512;
#line 1151
  if (_min1 < _min2) {
#line 1151
    tmp___14 = _min1;
  } else {
#line 1151
    tmp___14 = _min2;
  }
#line 1151
  write_mtt_size = tmp___14;
#line 1153
  __mptr___1 = (struct list_head  const  *)(mr->umem)->chunk_list.next;
#line 1153
  chunk = (struct ib_umem_chunk *)__mptr___1;
#line 1153
  goto ldv_27551;
  ldv_27550: 
#line 1154
  j = 0;
#line 1154
  goto ldv_27548;
  ldv_27547: 
#line 1155
  len = (int )(((struct scatterlist *)(& chunk->page_list) + (unsigned long )j)->dma_length >> shift);
#line 1156
  k = 0;
#line 1156
  goto ldv_27545;
  ldv_27544: 
#line 1157
  tmp___15 = i;
#line 1157
  i = i + 1;
#line 1157
  *(pages + (unsigned long )tmp___15) = ((struct scatterlist *)(& chunk->page_list) + (unsigned long )j)->dma_address + (dma_addr_t )((mr->umem)->page_size * k);
#line 1163
  if (i == write_mtt_size) {
#line 1164
    err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
#line 1165
    if (err != 0) {
#line 1166
      goto mtt_done;
    } else {

    }
#line 1167
    n = n + i;
#line 1168
    i = 0;
  } else {

  }
#line 1156
  k = k + 1;
  ldv_27545: ;
#line 1156
  if (k < len) {
#line 1157
    goto ldv_27544;
  } else {
#line 1159
    goto ldv_27546;
  }
  ldv_27546: 
#line 1154
  j = j + 1;
  ldv_27548: ;
#line 1154
  if (chunk->nmap > j) {
#line 1155
    goto ldv_27547;
  } else {
#line 1157
    goto ldv_27549;
  }
  ldv_27549: 
#line 1153
  __mptr___2 = (struct list_head  const  *)chunk->list.next;
#line 1153
  chunk = (struct ib_umem_chunk *)__mptr___2;
  ldv_27551: ;
#line 1153
  if ((unsigned long )(& chunk->list) != (unsigned long )(& (mr->umem)->chunk_list)) {
#line 1154
    goto ldv_27550;
  } else {
#line 1156
    goto ldv_27552;
  }
  ldv_27552: ;
#line 1173
  if (i != 0) {
#line 1174
    err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
  } else {

  }
  mtt_done: 
#line 1176
  free_pages((unsigned long )pages, 0U);
#line 1177
  if (err != 0) {
#line 1178
    goto err_mtt;
  } else {

  }
#line 1180
  tmp___16 = convert_access(acc);
#line 1180
  tmp___17 = to_mpd(pd);
#line 1180
  err = mthca_mr_alloc(dev, tmp___17->pd_num, shift, virt, length, tmp___16, mr);
#line 1183
  if (err != 0) {
#line 1184
    goto err_mtt;
  } else {

  }
#line 1186
  return (& mr->ibmr);
  err_mtt: 
#line 1189
  mthca_free_mtt(dev, mr->mtt);
  err_umem: 
#line 1192
  ib_umem_release(mr->umem);
  err: 
#line 1195
  kfree((void const   *)mr);
#line 1196
  tmp___18 = ERR_PTR((long )err);
#line 1196
  return ((struct ib_mr *)tmp___18);
}
}
#line 1199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_dereg_mr(struct ib_mr *mr ) 
{ struct mthca_mr *mmr ;
  struct mthca_mr *tmp ;
  struct mthca_dev *tmp___0 ;

  {
#line 1201
  tmp = to_mmr(mr);
#line 1201
  mmr = tmp;
#line 1203
  tmp___0 = to_mdev(mr->device);
#line 1203
  mthca_free_mr(tmp___0, mmr);
#line 1204
  if ((unsigned long )mmr->umem != (unsigned long )((struct ib_umem *)0)) {
#line 1205
    ib_umem_release(mmr->umem);
  } else {

  }
#line 1206
  kfree((void const   *)mmr);
#line 1208
  return (0);
}
}
#line 1211 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct ib_fmr *mthca_alloc_fmr(struct ib_pd *pd , int mr_access_flags , struct ib_fmr_attr *fmr_attr ) 
{ struct mthca_fmr *fmr ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  u32 tmp___1 ;
  struct mthca_pd *tmp___2 ;
  struct mthca_dev *tmp___3 ;
  void *tmp___4 ;

  {
#line 1217
  tmp = kmalloc(96UL, 208U);
#line 1217
  fmr = (struct mthca_fmr *)tmp;
#line 1218
  if ((unsigned long )fmr == (unsigned long )((struct mthca_fmr *)0)) {
#line 1219
    tmp___0 = ERR_PTR(-12L);
#line 1219
    return ((struct ib_fmr *)tmp___0);
  } else {

  }
#line 1221
  __len = 12UL;
#line 1221
  if (__len > 63UL) {
#line 1221
    __ret = __memcpy((void *)(& fmr->attr), (void const   *)fmr_attr, __len);
  } else {
#line 1221
    __ret = __builtin_memcpy((void *)(& fmr->attr), (void const   *)fmr_attr, __len);
  }
#line 1222
  tmp___1 = convert_access(mr_access_flags);
#line 1222
  tmp___2 = to_mpd(pd);
#line 1222
  tmp___3 = to_mdev(pd->device);
#line 1222
  err = mthca_fmr_alloc(tmp___3, tmp___2->pd_num, tmp___1, fmr);
#line 1225
  if (err != 0) {
#line 1226
    kfree((void const   *)fmr);
#line 1227
    tmp___4 = ERR_PTR((long )err);
#line 1227
    return ((struct ib_fmr *)tmp___4);
  } else {

  }
#line 1230
  return (& fmr->ibmr);
}
}
#line 1233 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_dealloc_fmr(struct ib_fmr *fmr ) 
{ struct mthca_fmr *mfmr ;
  struct mthca_fmr *tmp ;
  int err ;
  struct mthca_dev *tmp___0 ;

  {
#line 1235
  tmp = to_mfmr(fmr);
#line 1235
  mfmr = tmp;
#line 1238
  tmp___0 = to_mdev(fmr->device);
#line 1238
  err = mthca_free_fmr(tmp___0, mfmr);
#line 1239
  if (err != 0) {
#line 1240
    return (err);
  } else {

  }
#line 1242
  kfree((void const   *)mfmr);
#line 1243
  return (0);
}
}
#line 1246 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_unmap_fmr(struct list_head *fmr_list ) 
{ struct ib_fmr *fmr ;
  int err ;
  struct mthca_dev *mdev ;
  struct list_head  const  *__mptr ;
  struct mthca_dev *tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct mthca_fmr *tmp___0 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct mthca_fmr *tmp___1 ;
  struct list_head  const  *__mptr___4 ;
  int tmp___2 ;

  {
#line 1250
  mdev = 0;
#line 1252
  __mptr = (struct list_head  const  *)fmr_list->next;
#line 1252
  fmr = (struct ib_fmr *)__mptr + 0xfffffffffffffff0UL;
#line 1252
  goto ldv_27583;
  ldv_27582: ;
#line 1253
  if ((unsigned long )mdev != (unsigned long )((struct mthca_dev *)0)) {
#line 1253
    tmp = to_mdev(fmr->device);
#line 1253
    if ((unsigned long )tmp != (unsigned long )mdev) {
#line 1254
      return (-22);
    } else {

    }
  } else {

  }
#line 1255
  mdev = to_mdev(fmr->device);
#line 1252
  __mptr___0 = (struct list_head  const  *)fmr->list.next;
#line 1252
  fmr = (struct ib_fmr *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_27583: ;
#line 1252
  if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1253
    goto ldv_27582;
  } else {
#line 1255
    goto ldv_27584;
  }
  ldv_27584: ;
#line 1258
  if ((unsigned long )mdev == (unsigned long )((struct mthca_dev *)0)) {
#line 1259
    return (0);
  } else {

  }
#line 1261
  tmp___2 = mthca_is_memfree(mdev);
#line 1261
  if (tmp___2 != 0) {
#line 1262
    __mptr___1 = (struct list_head  const  *)fmr_list->next;
#line 1262
    fmr = (struct ib_fmr *)__mptr___1 + 0xfffffffffffffff0UL;
#line 1262
    goto ldv_27590;
    ldv_27589: 
#line 1263
    tmp___0 = to_mfmr(fmr);
#line 1263
    mthca_arbel_fmr_unmap(mdev, tmp___0);
#line 1262
    __mptr___2 = (struct list_head  const  *)fmr->list.next;
#line 1262
    fmr = (struct ib_fmr *)__mptr___2 + 0xfffffffffffffff0UL;
    ldv_27590: ;
#line 1262
    if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1263
      goto ldv_27589;
    } else {
#line 1265
      goto ldv_27591;
    }
    ldv_27591: 
#line 1265
    __asm__  volatile   ("sfence": : : "memory");
  } else {
#line 1267
    __mptr___3 = (struct list_head  const  *)fmr_list->next;
#line 1267
    fmr = (struct ib_fmr *)__mptr___3 + 0xfffffffffffffff0UL;
#line 1267
    goto ldv_27597;
    ldv_27596: 
#line 1268
    tmp___1 = to_mfmr(fmr);
#line 1268
    mthca_tavor_fmr_unmap(mdev, tmp___1);
#line 1267
    __mptr___4 = (struct list_head  const  *)fmr->list.next;
#line 1267
    fmr = (struct ib_fmr *)__mptr___4 + 0xfffffffffffffff0UL;
    ldv_27597: ;
#line 1267
    if ((unsigned long )(& fmr->list) != (unsigned long )fmr_list) {
#line 1268
      goto ldv_27596;
    } else {
#line 1270
      goto ldv_27598;
    }
    ldv_27598: ;
  }
#line 1270
  err = mthca_SYNC_TPT(mdev);
#line 1271
  return (err);
}
}
#line 1274 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static ssize_t show_rev(struct device *device , struct device_attribute *attr , char *buf ) 
{ struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1278
  __mptr = (struct device  const  *)device;
#line 1278
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc80UL;
#line 1279
  tmp = sprintf(buf, "%x\n", dev->rev_id);
#line 1279
  return ((ssize_t )tmp);
}
}
#line 1282 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static ssize_t show_fw_ver(struct device *device , struct device_attribute *attr ,
                           char *buf ) 
{ struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1286
  __mptr = (struct device  const  *)device;
#line 1286
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc80UL;
#line 1287
  tmp = sprintf(buf, "%d.%d.%d\n", (int )(dev->fw_ver >> 32), (int )(dev->fw_ver >> 16) & 65535,
                (int )dev->fw_ver & 65535);
#line 1287
  return ((ssize_t )tmp);
}
}
#line 1292 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static ssize_t show_hca(struct device *device , struct device_attribute *attr , char *buf ) 
{ struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1296
  __mptr = (struct device  const  *)device;
#line 1296
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc80UL;
#line 1297
  switch ((int )(dev->pdev)->device) {
  case 23108: 
#line 1299
  tmp = sprintf(buf, "MT23108\n");
#line 1299
  return ((ssize_t )tmp);
  case 25208: 
#line 1301
  tmp___0 = sprintf(buf, "MT25208 (MT23108 compat mode)\n");
#line 1301
  return ((ssize_t )tmp___0);
  case 25218: 
#line 1303
  tmp___1 = sprintf(buf, "MT25208\n");
#line 1303
  return ((ssize_t )tmp___1);
  case 25204: ;
  case 24204: 
#line 1306
  tmp___2 = sprintf(buf, "MT25204\n");
#line 1306
  return ((ssize_t )tmp___2);
  default: 
#line 1308
  tmp___3 = sprintf(buf, "unknown\n");
#line 1308
  return ((ssize_t )tmp___3);
  }
}
}
#line 1312 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static ssize_t show_board(struct device *device , struct device_attribute *attr ,
                          char *buf ) 
{ struct mthca_dev *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1316
  __mptr = (struct device  const  *)device;
#line 1316
  dev = (struct mthca_dev *)__mptr + 0xfffffffffffffc80UL;
#line 1317
  tmp = sprintf(buf, "%.*s\n", 64, (char *)(& dev->board_id));
#line 1317
  return ((ssize_t )tmp);
}
}
#line 1320 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct device_attribute dev_attr_hw_rev  =    {{"hw_rev", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_rev,
    0};
#line 1321 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct device_attribute dev_attr_fw_ver  =    {{"fw_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_fw_ver,
    0};
#line 1322 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct device_attribute dev_attr_hca_type  =    {{"hca_type", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & show_hca, 0};
#line 1323 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct device_attribute dev_attr_board_id  =    {{"board_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & show_board, 0};
#line 1325 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static struct device_attribute *mthca_dev_attributes[4U]  = {      & dev_attr_hw_rev,      & dev_attr_fw_ver,      & dev_attr_hca_type,      & dev_attr_board_id};
#line 1332 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
static int mthca_init_node_data(struct mthca_dev *dev ) 
{ struct ib_smp *in_mad ;
  struct ib_smp *out_mad ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1334
  in_mad = 0;
#line 1335
  out_mad = 0;
#line 1336
  err = -12;
#line 1338
  tmp = kzalloc(256UL, 208U);
#line 1338
  in_mad = (struct ib_smp *)tmp;
#line 1339
  tmp___0 = kmalloc(256UL, 208U);
#line 1339
  out_mad = (struct ib_smp *)tmp___0;
#line 1340
  if ((unsigned long )in_mad == (unsigned long )((struct ib_smp *)0) || (unsigned long )out_mad == (unsigned long )((struct ib_smp *)0)) {
#line 1341
    goto out;
  } else {

  }
#line 1343
  init_query_mad(in_mad);
#line 1344
  in_mad->attr_id = 4096U;
#line 1346
  err = mthca_MAD_IFC(dev, 1, 1, 1, 0, 0, (void *)in_mad, (void *)out_mad);
#line 1348
  if (err != 0) {
#line 1349
    goto out;
  } else {

  }
#line 1351
  __len = 64UL;
#line 1351
  if (__len > 63UL) {
#line 1351
    __ret = __memcpy((void *)(& dev->ib_dev.node_desc), (void const   *)(& out_mad->data),
                     __len);
  } else {
#line 1351
    __ret = __builtin_memcpy((void *)(& dev->ib_dev.node_desc), (void const   *)(& out_mad->data),
                             __len);
  }
#line 1353
  in_mad->attr_id = 4352U;
#line 1355
  err = mthca_MAD_IFC(dev, 1, 1, 1, 0, 0, (void *)in_mad, (void *)out_mad);
#line 1357
  if (err != 0) {
#line 1358
    goto out;
  } else {

  }
#line 1360
  tmp___1 = mthca_is_memfree(dev);
#line 1360
  if (tmp___1 != 0) {
#line 1361
    dev->rev_id = __be32_to_cpup((__be32 const   *)(& out_mad->data) + 32U);
  } else {

  }
#line 1362
  __len___0 = 8UL;
#line 1362
  if (__len___0 > 63UL) {
#line 1362
    __ret___0 = __memcpy((void *)(& dev->ib_dev.node_guid), (void const   *)(& out_mad->data) + 12U,
                         __len___0);
  } else {
#line 1362
    __ret___0 = __builtin_memcpy((void *)(& dev->ib_dev.node_guid), (void const   *)(& out_mad->data) + 12U,
                                 __len___0);
  }
  out: 
#line 1365
  kfree((void const   *)in_mad);
#line 1366
  kfree((void const   *)out_mad);
#line 1367
  return (err);
}
}
#line 1370 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
int mthca_register_device(struct mthca_dev *dev ) 
{ int ret ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct lock_class_key __key ;

  {
#line 1375
  ret = mthca_init_node_data(dev);
#line 1376
  if (ret != 0) {
#line 1377
    return (ret);
  } else {

  }
#line 1379
  strlcpy((char *)(& dev->ib_dev.name), "mthca%d", 64UL);
#line 1380
  dev->ib_dev.owner = & __this_module;
#line 1382
  dev->ib_dev.uverbs_abi_ver = 1;
#line 1383
  dev->ib_dev.uverbs_cmd_mask = 3474858527ULL;
#line 1401
  dev->ib_dev.node_type = 1U;
#line 1402
  dev->ib_dev.phys_port_cnt = (u8 )dev->limits.num_ports;
#line 1403
  dev->ib_dev.num_comp_vectors = 1;
#line 1404
  dev->ib_dev.dma_device = & (dev->pdev)->dev;
#line 1405
  dev->ib_dev.query_device = & mthca_query_device;
#line 1406
  dev->ib_dev.query_port = & mthca_query_port;
#line 1407
  dev->ib_dev.modify_device = & mthca_modify_device;
#line 1408
  dev->ib_dev.modify_port = & mthca_modify_port;
#line 1409
  dev->ib_dev.query_pkey = & mthca_query_pkey;
#line 1410
  dev->ib_dev.query_gid = & mthca_query_gid;
#line 1411
  dev->ib_dev.alloc_ucontext = & mthca_alloc_ucontext;
#line 1412
  dev->ib_dev.dealloc_ucontext = & mthca_dealloc_ucontext;
#line 1413
  dev->ib_dev.mmap = & mthca_mmap_uar;
#line 1414
  dev->ib_dev.alloc_pd = & mthca_alloc_pd;
#line 1415
  dev->ib_dev.dealloc_pd = & mthca_dealloc_pd;
#line 1416
  dev->ib_dev.create_ah = & mthca_ah_create;
#line 1417
  dev->ib_dev.query_ah = & mthca_ah_query;
#line 1418
  dev->ib_dev.destroy_ah = & mthca_ah_destroy;
#line 1420
  if ((dev->mthca_flags & 4UL) != 0UL) {
#line 1421
    dev->ib_dev.create_srq = & mthca_create_srq;
#line 1422
    dev->ib_dev.modify_srq = & mthca_modify_srq;
#line 1423
    dev->ib_dev.query_srq = & mthca_query_srq;
#line 1424
    dev->ib_dev.destroy_srq = & mthca_destroy_srq;
#line 1425
    dev->ib_dev.uverbs_cmd_mask = dev->ib_dev.uverbs_cmd_mask | 64424509440ULL;
#line 1431
    tmp = mthca_is_memfree(dev);
#line 1431
    if (tmp != 0) {
#line 1432
      dev->ib_dev.post_srq_recv = & mthca_arbel_post_srq_recv;
    } else {
#line 1434
      dev->ib_dev.post_srq_recv = & mthca_tavor_post_srq_recv;
    }
  } else {

  }
#line 1437
  dev->ib_dev.create_qp = & mthca_create_qp;
#line 1438
  dev->ib_dev.modify_qp = & mthca_modify_qp;
#line 1439
  dev->ib_dev.query_qp = & mthca_query_qp;
#line 1440
  dev->ib_dev.destroy_qp = & mthca_destroy_qp;
#line 1441
  dev->ib_dev.create_cq = & mthca_create_cq;
#line 1442
  dev->ib_dev.resize_cq = & mthca_resize_cq;
#line 1443
  dev->ib_dev.destroy_cq = & mthca_destroy_cq;
#line 1444
  dev->ib_dev.poll_cq = & mthca_poll_cq;
#line 1445
  dev->ib_dev.get_dma_mr = & mthca_get_dma_mr;
#line 1446
  dev->ib_dev.reg_phys_mr = & mthca_reg_phys_mr;
#line 1447
  dev->ib_dev.reg_user_mr = & mthca_reg_user_mr;
#line 1448
  dev->ib_dev.dereg_mr = & mthca_dereg_mr;
#line 1450
  if ((dev->mthca_flags & 32UL) != 0UL) {
#line 1451
    dev->ib_dev.alloc_fmr = & mthca_alloc_fmr;
#line 1452
    dev->ib_dev.unmap_fmr = & mthca_unmap_fmr;
#line 1453
    dev->ib_dev.dealloc_fmr = & mthca_dealloc_fmr;
#line 1454
    tmp___0 = mthca_is_memfree(dev);
#line 1454
    if (tmp___0 != 0) {
#line 1455
      dev->ib_dev.map_phys_fmr = & mthca_arbel_map_phys_fmr;
    } else {
#line 1457
      dev->ib_dev.map_phys_fmr = & mthca_tavor_map_phys_fmr;
    }
  } else {

  }
#line 1460
  dev->ib_dev.attach_mcast = & mthca_multicast_attach;
#line 1461
  dev->ib_dev.detach_mcast = & mthca_multicast_detach;
#line 1462
  dev->ib_dev.process_mad = & mthca_process_mad;
#line 1464
  tmp___1 = mthca_is_memfree(dev);
#line 1464
  if (tmp___1 != 0) {
#line 1465
    dev->ib_dev.req_notify_cq = & mthca_arbel_arm_cq;
#line 1466
    dev->ib_dev.post_send = & mthca_arbel_post_send;
#line 1467
    dev->ib_dev.post_recv = & mthca_arbel_post_receive;
  } else {
#line 1469
    dev->ib_dev.req_notify_cq = & mthca_tavor_arm_cq;
#line 1470
    dev->ib_dev.post_send = & mthca_tavor_post_send;
#line 1471
    dev->ib_dev.post_recv = & mthca_tavor_post_receive;
  }
#line 1474
  __mutex_init(& dev->cap_mask_mutex, "&dev->cap_mask_mutex", & __key);
#line 1476
  ret = ib_register_device(& dev->ib_dev, 0);
#line 1477
  if (ret != 0) {
#line 1478
    return (ret);
  } else {

  }
#line 1480
  i = 0;
#line 1480
  goto ldv_27664;
  ldv_27663: 
#line 1481
  ret = device_create_file(& dev->ib_dev.dev, (struct device_attribute  const  *)mthca_dev_attributes[i]);
#line 1483
  if (ret != 0) {
#line 1484
    ib_unregister_device(& dev->ib_dev);
#line 1485
    return (ret);
  } else {

  }
#line 1480
  i = i + 1;
  ldv_27664: ;
#line 1480
  if ((unsigned int )i <= 3U) {
#line 1481
    goto ldv_27663;
  } else {
#line 1483
    goto ldv_27665;
  }
  ldv_27665: 
#line 1489
  mthca_start_catas_poll(dev);
#line 1491
  return (0);
}
}
#line 1494 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void mthca_unregister_device(struct mthca_dev *dev ) 
{ 

  {
#line 1496
  mthca_stop_catas_poll(dev);
#line 1497
  ib_unregister_device(& dev->ib_dev);
#line 1498
  return;
}
}
#line 1500 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device_attribute *ldvarg11  ;
#line 1501 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
char *ldvarg7  ;
#line 1502 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device *ldvarg3  ;
#line 1503 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device *ldvarg0  ;
#line 1504 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device_attribute *ldvarg5  ;
#line 1505 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device *ldvarg6  ;
#line 1506 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device_attribute *ldvarg8  ;
#line 1507 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
char *ldvarg1  ;
#line 1508 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
char *ldvarg4  ;
#line 1509 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
char *ldvarg10  ;
#line 1510 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device *ldvarg9  ;
#line 1511 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
struct device_attribute *ldvarg2  ;
#line 1513 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_main_exported_4(void) 
{ int tmp ;

  {
#line 1515
  tmp = __VERIFIER_nondet_int();
#line 1515
  switch (tmp) {
  case 0: ;
#line 1518
  if (ldv_state_variable_4 == 1) {
#line 1520
    show_rev(ldvarg0, ldvarg2, ldvarg1);
#line 1522
    ldv_state_variable_4 = 1;
  } else {

  }
#line 1525
  goto ldv_27685;
  default: ;
#line 1526
  goto ldv_27685;
  }
  ldv_27685: ;
#line 1530
  return;
}
}
#line 1532 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_main_exported_1(void) 
{ int tmp ;

  {
#line 1534
  tmp = __VERIFIER_nondet_int();
#line 1534
  switch (tmp) {
  case 0: ;
#line 1537
  if (ldv_state_variable_1 == 1) {
#line 1539
    show_board(ldvarg3, ldvarg5, ldvarg4);
#line 1541
    ldv_state_variable_1 = 1;
  } else {

  }
#line 1544
  goto ldv_27691;
  default: ;
#line 1545
  goto ldv_27691;
  }
  ldv_27691: ;
#line 1549
  return;
}
}
#line 1551 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_main_exported_3(void) 
{ int tmp ;

  {
#line 1553
  tmp = __VERIFIER_nondet_int();
#line 1553
  switch (tmp) {
  case 0: ;
#line 1556
  if (ldv_state_variable_3 == 1) {
#line 1558
    show_fw_ver(ldvarg6, ldvarg8, ldvarg7);
#line 1560
    ldv_state_variable_3 = 1;
  } else {

  }
#line 1563
  goto ldv_27697;
  default: ;
#line 1564
  goto ldv_27697;
  }
  ldv_27697: ;
#line 1568
  return;
}
}
#line 1570 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_main_exported_2(void) 
{ int tmp ;

  {
#line 1572
  tmp = __VERIFIER_nondet_int();
#line 1572
  switch (tmp) {
  case 0: ;
#line 1575
  if (ldv_state_variable_2 == 1) {
#line 1577
    show_hca(ldvarg9, ldvarg11, ldvarg10);
#line 1579
    ldv_state_variable_2 = 1;
  } else {

  }
#line 1582
  goto ldv_27703;
  default: ;
#line 1583
  goto ldv_27703;
  }
  ldv_27703: ;
#line 1587
  return;
}
}
#line 1588 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1593
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1595
  mutex_lock(ldv_func_arg1);
#line 1596
  return;
}
}
#line 1598 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1603
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1605
  mutex_unlock(ldv_func_arg1);
#line 1606
  return;
}
}
#line 1608 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1613
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1615
  mutex_lock(ldv_func_arg1);
#line 1616
  return;
}
}
#line 1618 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
int ldv_mutex_trylock_180(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1623
  tmp = mutex_trylock(ldv_func_arg1);
#line 1623
  ldv_func_res = tmp;
#line 1625
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1625
  return (tmp___0);
#line 1627
  return (ldv_func_res);
}
}
#line 1630 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1635
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1637
  mutex_unlock(ldv_func_arg1);
#line 1638
  return;
}
}
#line 1640 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_lock_182(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1645
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1647
  mutex_lock(ldv_func_arg1);
#line 1648
  return;
}
}
#line 1650 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1655
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1657
  mutex_unlock(ldv_func_arg1);
#line 1658
  return;
}
}
#line 1660 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
int ldv_mutex_lock_interruptible_184(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1665
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 1665
  ldv_func_res = tmp;
#line 1667
  tmp___0 = ldv_mutex_lock_interruptible_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 1667
  return (tmp___0);
#line 1669
  return (ldv_func_res);
}
}
#line 1672 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_185(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1677
  ldv_mutex_unlock_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 1679
  mutex_unlock(ldv_func_arg1);
#line 1680
  return;
}
}
#line 1682 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
int ldv_mutex_lock_interruptible_186(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1687
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 1687
  ldv_func_res = tmp;
#line 1689
  tmp___0 = ldv_mutex_lock_interruptible_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 1689
  return (tmp___0);
#line 1691
  return (ldv_func_res);
}
}
#line 1694 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_187(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1699
  ldv_mutex_unlock_cap_mask_mutex_of_mthca_dev(ldv_func_arg1);
#line 1701
  mutex_unlock(ldv_func_arg1);
#line 1702
  return;
}
}
#line 1704 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_lock_188(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1709
  ldv_mutex_lock_mutex_of_mthca_cq(ldv_func_arg1);
#line 1711
  mutex_lock(ldv_func_arg1);
#line 1712
  return;
}
}
#line 1714 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_provider.c.prepared"
void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1719
  ldv_mutex_unlock_mutex_of_mthca_cq(ldv_func_arg1);
#line 1721
  mutex_unlock(ldv_func_arg1);
#line 1722
  return;
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 61 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 91 "include/linux/bitmap.h"
extern int __bitmap_empty(unsigned long const   * , int  ) ;
#line 92
extern int __bitmap_full(unsigned long const   * , int  ) ;
#line 260 "include/linux/bitmap.h"
__inline static int bitmap_empty(unsigned long const   *src , int nbits ) 
{ int tmp___0 ;

  {
#line 265
  tmp___0 = __bitmap_empty(src, nbits);
#line 265
  return (tmp___0);
}
}
#line 268 "include/linux/bitmap.h"
__inline static int bitmap_full(unsigned long const   *src , int nbits ) 
{ int tmp___0 ;

  {
#line 273
  tmp___0 = __bitmap_full(src, nbits);
#line 273
  return (tmp___0);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_208(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_215(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_217(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_219(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_212(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_214(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_216(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_218(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_220(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_222(struct mutex *ldv_func_arg1 ) ;
#line 107
void ldv_mutex_lock_mutex_of_mthca_db_table(struct mutex *lock ) ;
#line 111
void ldv_mutex_unlock_mutex_of_mthca_db_table(struct mutex *lock ) ;
#line 115
void ldv_mutex_lock_mutex_of_mthca_icm_table(struct mutex *lock ) ;
#line 119
void ldv_mutex_unlock_mutex_of_mthca_icm_table(struct mutex *lock ) ;
#line 147
void ldv_mutex_lock_mutex_of_mthca_user_db_table(struct mutex *lock ) ;
#line 151
void ldv_mutex_unlock_mutex_of_mthca_user_db_table(struct mutex *lock ) ;
#line 453 "include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 1048
extern int get_user_pages(struct task_struct * , struct mm_struct * , unsigned long  ,
                          int  , int  , int  , struct page ** , struct vm_area_struct ** ) ;
#line 57 "include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ unsigned long page_link ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 59
  page_link = sg->page_link & 3UL;
#line 65
  tmp = ldv__builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
#line 65
  if (tmp != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (65), "i" (12UL));
    ldv_15249: ;
#line 65
    goto ldv_15249;
  } else {

  }
#line 67
  tmp___0 = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 67
  if (tmp___0 != 0L) {
#line 67
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (67), "i" (12UL));
    ldv_15250: ;
#line 67
    goto ldv_15250;
  } else {

  }
#line 68
  tmp___1 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 68
  if (tmp___1 != 0L) {
#line 68
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (68), "i" (12UL));
    ldv_15251: ;
#line 68
    goto ldv_15251;
  } else {

  }
#line 70
  sg->page_link = page_link | (unsigned long )page;
#line 71
  return;
}
}
#line 87 "include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 

  {
#line 90
  sg_assign_page(sg, page);
#line 91
  sg->offset = offset;
#line 92
  sg->length = len;
#line 93
  return;
}
}
#line 95 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ long tmp ;
  long tmp___0 ;

  {
#line 98
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 98
  if (tmp != 0L) {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
    ldv_15261: ;
#line 98
    goto ldv_15261;
  } else {

  }
#line 99
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 99
  if (tmp___0 != 0L) {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
    ldv_15262: ;
#line 99
    goto ldv_15262;
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 111 "include/linux/scatterlist.h"
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ unsigned long tmp ;

  {
#line 114
  tmp = __phys_addr((unsigned long )buf);
#line 114
  sg_set_page(sg, 0xffffea0000000000UL + (tmp >> 12), buflen, (unsigned int )((long )buf) & 4095U);
#line 115
  return;
}
}
#line 199 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ struct page *tmp ;
  void *tmp___0 ;

  {
#line 201
  tmp = sg_page(sg);
#line 201
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 201
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 205
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 207
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 173 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/infiniband/hw/mthca/mthca_memfree.h"
int mthca_init_db_tab(struct mthca_dev *dev ) ;
#line 174
void mthca_cleanup_db_tab(struct mthca_dev *dev ) ;
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 42 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 46
  tmp = get_dma_ops(dev);
#line 46
  ops = tmp;
#line 50
  i = 0;
#line 50
  s = sg;
#line 50
  goto ldv_22908;
  ldv_22907: 
#line 51
  tmp___0 = sg_virt(s);
#line 51
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 50
  i = i + 1;
#line 50
  s = sg_next(s);
  ldv_22908: ;
#line 50
  if (i < nents) {
#line 51
    goto ldv_22907;
  } else {
#line 53
    goto ldv_22909;
  }
  ldv_22909: 
#line 52
  tmp___1 = valid_dma_direction((int )dir);
#line 52
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 52
  if (tmp___2 != 0L) {
#line 52
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (52), "i" (12UL));
    ldv_22910: ;
#line 52
    goto ldv_22910;
  } else {

  }
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 56
  return (ents);
}
}
#line 59 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 65
  if (tmp___1 != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
    ldv_22919: ;
#line 65
    goto ldv_22919;
  } else {

  }
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 69
  return;
}
}
#line 57 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
#line 60
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 60
    tmp = & hwdev->dev;
  } else {
#line 60
    tmp = 0;
  }
#line 60
  tmp___0 = dma_map_sg_attrs(tmp, sg, nents, (enum dma_data_direction )direction,
                             0);
#line 60
  return (tmp___0);
}
}
#line 64 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ struct device *tmp ;

  {
#line 67
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 67
    tmp = & hwdev->dev;
  } else {
#line 67
    tmp = 0;
  }
#line 67
  dma_unmap_sg_attrs(tmp, sg, nents, (enum dma_data_direction )direction, 0);
#line 68
  return;
}
}
#line 184 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
static void mthca_free_icm_pages(struct mthca_dev *dev , struct mthca_icm_chunk *chunk ) 
{ int i ;
  int tmp ;
  struct page *tmp___0 ;

  {
#line 188
  if (chunk->nsg > 0) {
#line 189
    pci_unmap_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages, 0);
  } else {

  }
#line 192
  i = 0;
#line 192
  goto ldv_26456;
  ldv_26455: 
#line 193
  tmp = __get_order((unsigned long )chunk->mem[i].length);
#line 193
  tmp___0 = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 193
  __free_pages(tmp___0, (unsigned int )tmp);
#line 192
  i = i + 1;
  ldv_26456: ;
#line 192
  if (chunk->npages > i) {
#line 193
    goto ldv_26455;
  } else {
#line 195
    goto ldv_26457;
  }
  ldv_26457: ;
#line 197
  return;
}
}
#line 197 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
static void mthca_free_icm_coherent(struct mthca_dev *dev , struct mthca_icm_chunk *chunk ) 
{ int i ;
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 201
  i = 0;
#line 201
  goto ldv_26464;
  ldv_26463: 
#line 202
  tmp = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 202
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 202
  dma_free_attrs(& (dev->pdev)->dev, (size_t )chunk->mem[i].length, tmp___0, ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_address,
                 0);
#line 201
  i = i + 1;
  ldv_26464: ;
#line 201
  if (chunk->npages > i) {
#line 202
    goto ldv_26463;
  } else {
#line 204
    goto ldv_26465;
  }
  ldv_26465: ;
#line 206
  return;
}
}
#line 208 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_free_icm(struct mthca_dev *dev , struct mthca_icm *icm , int coherent ) 
{ struct mthca_icm_chunk *chunk ;
  struct mthca_icm_chunk *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 212
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 213
    return;
  } else {

  }
#line 215
  __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 215
  chunk = (struct mthca_icm_chunk *)__mptr;
#line 215
  __mptr___0 = (struct list_head  const  *)chunk->list.next;
#line 215
  tmp = (struct mthca_icm_chunk *)__mptr___0;
#line 215
  goto ldv_26480;
  ldv_26479: ;
#line 216
  if (coherent != 0) {
#line 217
    mthca_free_icm_coherent(dev, chunk);
  } else {
#line 219
    mthca_free_icm_pages(dev, chunk);
  }
#line 221
  kfree((void const   *)chunk);
#line 215
  chunk = tmp;
#line 215
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 215
  tmp = (struct mthca_icm_chunk *)__mptr___1;
  ldv_26480: ;
#line 215
  if ((unsigned long )chunk != (unsigned long )icm) {
#line 216
    goto ldv_26479;
  } else {
#line 218
    goto ldv_26481;
  }
  ldv_26481: 
#line 224
  kfree((void const   *)icm);
#line 225
  return;
}
}
#line 227 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
static int mthca_alloc_icm_pages(struct scatterlist *mem , int order , gfp_t gfp_mask ) 
{ struct page *page ;

  {
#line 235
  page = alloc_pages(gfp_mask | 32768U, (unsigned int )order);
#line 236
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 237
    return (-12);
  } else {

  }
#line 239
  sg_set_page(mem, page, (unsigned int )(4096UL << order), 0U);
#line 240
  return (0);
}
}
#line 243 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
static int mthca_alloc_icm_coherent(struct device *dev , struct scatterlist *mem ,
                                    int order , gfp_t gfp_mask ) 
{ void *buf ;
  void *tmp ;
  long tmp___0 ;

  {
#line 246
  tmp = dma_alloc_attrs(dev, 4096UL << order, & mem->dma_address, gfp_mask, 0);
#line 246
  buf = tmp;
#line 248
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 249
    return (-12);
  } else {

  }
#line 251
  sg_set_buf(mem, (void const   *)buf, (unsigned int )(4096UL << order));
#line 252
  tmp___0 = ldv__builtin_expect(mem->offset != 0U, 0L);
#line 252
  if (tmp___0 != 0L) {
#line 252
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"),
                         "i" (252), "i" (12UL));
    ldv_26495: ;
#line 252
    goto ldv_26495;
  } else {

  }
#line 253
  mem->dma_length = (unsigned int )(4096UL << order);
#line 254
  return (0);
}
}
#line 257 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
struct mthca_icm *mthca_alloc_icm(struct mthca_dev *dev , int npages , gfp_t gfp_mask ,
                                  int coherent ) 
{ struct mthca_icm *icm ;
  struct mthca_icm_chunk *chunk ;
  int cur_order ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 261
  chunk = 0;
#line 266
  tmp = ldv__builtin_expect(coherent != 0, 0L);
#line 266
  if (tmp != 0L) {
#line 266
    tmp___0 = ldv__builtin_expect((gfp_mask & 2U) != 0U, 0L);
#line 266
    if (tmp___0 != 0L) {
#line 266
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"),
                           "i" (266), "i" (12UL));
      ldv_26506: ;
#line 266
      goto ldv_26506;
    } else {

    }
  } else {

  }
#line 268
  tmp___1 = kmalloc(24UL, gfp_mask & 4294966781U);
#line 268
  icm = (struct mthca_icm *)tmp___1;
#line 269
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 270
    return (icm);
  } else {

  }
#line 272
  icm->refcount = 0;
#line 273
  INIT_LIST_HEAD(& icm->chunk_list);
#line 275
  cur_order = 6;
#line 277
  goto ldv_26512;
  ldv_26511: ;
#line 278
  if ((unsigned long )chunk == (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 279
    tmp___2 = kmalloc(224UL, gfp_mask & 4294966781U);
#line 279
    chunk = (struct mthca_icm_chunk *)tmp___2;
#line 281
    if ((unsigned long )chunk == (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 282
      goto fail;
    } else {

    }
#line 284
    sg_init_table((struct scatterlist *)(& chunk->mem), 5U);
#line 285
    chunk->npages = 0;
#line 286
    chunk->nsg = 0;
#line 287
    list_add_tail(& chunk->list, & icm->chunk_list);
  } else {

  }
#line 290
  goto ldv_26509;
  ldv_26508: 
#line 291
  cur_order = cur_order - 1;
  ldv_26509: ;
#line 290
  if (1 << cur_order > npages) {
#line 291
    goto ldv_26508;
  } else {
#line 293
    goto ldv_26510;
  }
  ldv_26510: ;
#line 293
  if (coherent != 0) {
#line 294
    ret = mthca_alloc_icm_coherent(& (dev->pdev)->dev, (struct scatterlist *)(& chunk->mem) + (unsigned long )chunk->npages,
                                   cur_order, gfp_mask);
  } else {
#line 298
    ret = mthca_alloc_icm_pages((struct scatterlist *)(& chunk->mem) + (unsigned long )chunk->npages,
                                cur_order, gfp_mask);
  }
#line 301
  if (ret == 0) {
#line 302
    chunk->npages = chunk->npages + 1;
#line 304
    if (coherent != 0) {
#line 305
      chunk->nsg = chunk->nsg + 1;
    } else
#line 306
    if (chunk->npages == 5) {
#line 307
      chunk->nsg = pci_map_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages,
                              0);
#line 311
      if (chunk->nsg <= 0) {
#line 312
        goto fail;
      } else {

      }
    } else {

    }
#line 315
    if (chunk->npages == 5) {
#line 316
      chunk = 0;
    } else {

    }
#line 318
    npages = npages - (1 << cur_order);
  } else {
#line 320
    cur_order = cur_order - 1;
#line 321
    if (cur_order < 0) {
#line 322
      goto fail;
    } else {

    }
  }
  ldv_26512: ;
#line 277
  if (npages > 0) {
#line 278
    goto ldv_26511;
  } else {
#line 280
    goto ldv_26513;
  }
  ldv_26513: ;
#line 326
  if (coherent == 0 && (unsigned long )chunk != (unsigned long )((struct mthca_icm_chunk *)0)) {
#line 327
    chunk->nsg = pci_map_sg(dev->pdev, (struct scatterlist *)(& chunk->mem), chunk->npages,
                            0);
#line 331
    if (chunk->nsg <= 0) {
#line 332
      goto fail;
    } else {

    }
  } else {

  }
#line 335
  return (icm);
  fail: 
#line 338
  mthca_free_icm(dev, icm, coherent);
#line 339
  return (0);
}
}
#line 342 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int mthca_table_get(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) 
{ int i ;
  int ret ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 344
  i = (((table->num_obj + -1) & obj) * table->obj_size) / 262144;
#line 345
  ret = 0;
#line 347
  ldv_mutex_lock_210(& table->mutex);
#line 349
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 350
    (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
#line 351
    goto out;
  } else {

  }
#line 354
  if (table->lowmem != 0) {
#line 354
    tmp = 720U;
  } else {
#line 354
    tmp = 131794U;
  }
#line 354
  table->icm[i] = mthca_alloc_icm(dev, 64, tmp, table->coherent);
#line 357
  if ((unsigned long )table->icm[i] == (unsigned long )((struct mthca_icm *)0)) {
#line 358
    ret = -12;
#line 359
    goto out;
  } else {

  }
#line 362
  tmp___0 = mthca_MAP_ICM(dev, table->icm[i], table->virt + (u64 )(i * 262144));
#line 362
  if (tmp___0 != 0) {
#line 364
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 365
    table->icm[i] = 0;
#line 366
    ret = -12;
#line 367
    goto out;
  } else {

  }
#line 370
  (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
  out: 
#line 373
  ldv_mutex_unlock_211(& table->mutex);
#line 374
  return (ret);
}
}
#line 377 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_table_put(struct mthca_dev *dev , struct mthca_icm_table *table , int obj ) 
{ int i ;
  int tmp ;

  {
#line 381
  tmp = mthca_is_memfree(dev);
#line 381
  if (tmp == 0) {
#line 382
    return;
  } else {

  }
#line 384
  i = (((table->num_obj + -1) & obj) * table->obj_size) / 262144;
#line 386
  ldv_mutex_lock_212(& table->mutex);
#line 388
  (table->icm[i])->refcount = (table->icm[i])->refcount - 1;
#line 388
  if ((table->icm[i])->refcount == 0) {
#line 389
    mthca_UNMAP_ICM(dev, table->virt + (u64 )(i * 262144), 64U);
#line 391
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 392
    table->icm[i] = 0;
  } else {

  }
#line 395
  ldv_mutex_unlock_213(& table->mutex);
#line 396
  return;
}
}
#line 398 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void *mthca_table_find(struct mthca_icm_table *table , int obj , dma_addr_t *dma_handle ) 
{ int idx ;
  int offset ;
  int dma_offset ;
  int i ;
  struct mthca_icm_chunk *chunk ;
  struct mthca_icm *icm ;
  struct page *page ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 403
  page = 0;
#line 405
  if (table->lowmem == 0) {
#line 406
    return (0);
  } else {

  }
#line 408
  ldv_mutex_lock_214(& table->mutex);
#line 410
  idx = ((table->num_obj + -1) & obj) * table->obj_size;
#line 411
  icm = table->icm[idx / 262144];
#line 412
  offset = idx % 262144;
#line 412
  dma_offset = offset;
#line 414
  if ((unsigned long )icm == (unsigned long )((struct mthca_icm *)0)) {
#line 415
    goto out;
  } else {

  }
#line 417
  __mptr = (struct list_head  const  *)icm->chunk_list.next;
#line 417
  chunk = (struct mthca_icm_chunk *)__mptr;
#line 417
  goto ldv_26549;
  ldv_26548: 
#line 418
  i = 0;
#line 418
  goto ldv_26546;
  ldv_26545: ;
#line 419
  if ((unsigned long )dma_handle != (unsigned long )((dma_addr_t *)0) && dma_offset >= 0) {
#line 420
    if (((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_length > (unsigned int )dma_offset) {
#line 421
      *dma_handle = ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_address + (dma_addr_t )dma_offset;
    } else {

    }
#line 423
    dma_offset = (int )((unsigned int )dma_offset - ((struct scatterlist *)(& chunk->mem) + (unsigned long )i)->dma_length);
  } else {

  }
#line 428
  if (chunk->mem[i].length > (unsigned int )offset) {
#line 429
    page = sg_page((struct scatterlist *)(& chunk->mem) + (unsigned long )i);
#line 430
    goto out;
  } else {

  }
#line 432
  offset = (int )((unsigned int )offset - chunk->mem[i].length);
#line 418
  i = i + 1;
  ldv_26546: ;
#line 418
  if (chunk->npages > i) {
#line 419
    goto ldv_26545;
  } else {
#line 421
    goto ldv_26547;
  }
  ldv_26547: 
#line 417
  __mptr___0 = (struct list_head  const  *)chunk->list.next;
#line 417
  chunk = (struct mthca_icm_chunk *)__mptr___0;
  ldv_26549: ;
#line 417
  if ((unsigned long )chunk != (unsigned long )icm) {
#line 418
    goto ldv_26548;
  } else {
#line 420
    goto ldv_26550;
  }
  ldv_26550: ;
  out: 
#line 437
  ldv_mutex_unlock_215(& table->mutex);
#line 438
  if ((unsigned long )page != (unsigned long )((struct page *)0)) {
#line 438
    tmp = lowmem_page_address((struct page  const  *)page);
#line 438
    tmp___0 = tmp + (unsigned long )offset;
  } else {
#line 438
    tmp___0 = 0;
  }
#line 438
  return (tmp___0);
}
}
#line 441 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int mthca_table_get_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                          int start , int end ) 
{ int inc ;
  int i ;
  int err ;

  {
#line 444
  inc = 262144 / table->obj_size;
#line 447
  i = start;
#line 447
  goto ldv_26562;
  ldv_26561: 
#line 448
  err = mthca_table_get(dev, table, i);
#line 449
  if (err != 0) {
#line 450
    goto fail;
  } else {

  }
#line 447
  i = i + inc;
  ldv_26562: ;
#line 447
  if (i <= end) {
#line 448
    goto ldv_26561;
  } else {
#line 450
    goto ldv_26563;
  }
  ldv_26563: ;
#line 453
  return (0);
  fail: ;
#line 456
  goto ldv_26565;
  ldv_26564: 
#line 457
  i = i - inc;
#line 458
  mthca_table_put(dev, table, i);
  ldv_26565: ;
#line 456
  if (i > start) {
#line 457
    goto ldv_26564;
  } else {
#line 459
    goto ldv_26566;
  }
  ldv_26566: ;
#line 461
  return (err);
}
}
#line 464 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_table_put_range(struct mthca_dev *dev , struct mthca_icm_table *table ,
                           int start , int end ) 
{ int i ;
  int tmp ;

  {
#line 469
  tmp = mthca_is_memfree(dev);
#line 469
  if (tmp == 0) {
#line 470
    return;
  } else {

  }
#line 472
  i = start;
#line 472
  goto ldv_26575;
  ldv_26574: 
#line 473
  mthca_table_put(dev, table, i);
#line 472
  i = 262144 / table->obj_size + i;
  ldv_26575: ;
#line 472
  if (i <= end) {
#line 473
    goto ldv_26574;
  } else {
#line 475
    goto ldv_26576;
  }
  ldv_26576: ;
#line 477
  return;
}
}
#line 476 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev , u64 virt , int obj_size ,
                                              int nobj , int reserved , int use_lowmem ,
                                              int use_coherent ) 
{ struct mthca_icm_table *table ;
  int obj_per_chunk ;
  int num_icm ;
  unsigned int chunk_size ;
  int i ;
  void *tmp ;
  struct lock_class_key __key ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 487
  obj_per_chunk = 262144 / obj_size;
#line 488
  num_icm = ((nobj + obj_per_chunk) + -1) / obj_per_chunk;
#line 490
  tmp = kmalloc(((unsigned long )num_icm + 25UL) * 8UL, 208U);
#line 490
  table = (struct mthca_icm_table *)tmp;
#line 491
  if ((unsigned long )table == (unsigned long )((struct mthca_icm_table *)0)) {
#line 492
    return (0);
  } else {

  }
#line 494
  table->virt = virt;
#line 495
  table->num_icm = num_icm;
#line 496
  table->num_obj = nobj;
#line 497
  table->obj_size = obj_size;
#line 498
  table->lowmem = use_lowmem;
#line 499
  table->coherent = use_coherent;
#line 500
  __mutex_init(& table->mutex, "&table->mutex", & __key);
#line 502
  i = 0;
#line 502
  goto ldv_26593;
  ldv_26592: 
#line 503
  table->icm[i] = 0;
#line 502
  i = i + 1;
  ldv_26593: ;
#line 502
  if (i < num_icm) {
#line 503
    goto ldv_26592;
  } else {
#line 505
    goto ldv_26594;
  }
  ldv_26594: 
#line 505
  i = 0;
#line 505
  goto ldv_26597;
  ldv_26596: 
#line 506
  chunk_size = 262144U;
#line 507
  if ((i + 1) * 262144 > nobj * obj_size) {
#line 508
    chunk_size = (unsigned int )(nobj * obj_size + i * -262144);
  } else {

  }
#line 510
  if (use_lowmem != 0) {
#line 510
    tmp___0 = 720U;
  } else {
#line 510
    tmp___0 = 131794U;
  }
#line 510
  table->icm[i] = mthca_alloc_icm(dev, (int )(chunk_size >> 12), tmp___0, use_coherent);
#line 513
  if ((unsigned long )table->icm[i] == (unsigned long )((struct mthca_icm *)0)) {
#line 514
    goto err;
  } else {

  }
#line 515
  tmp___1 = mthca_MAP_ICM(dev, table->icm[i], (u64 )(i * 262144) + virt);
#line 515
  if (tmp___1 != 0) {
#line 517
    mthca_free_icm(dev, table->icm[i], table->coherent);
#line 518
    table->icm[i] = 0;
#line 519
    goto err;
  } else {

  }
#line 526
  (table->icm[i])->refcount = (table->icm[i])->refcount + 1;
#line 505
  i = i + 1;
  ldv_26597: ;
#line 505
  if (i * 262144 < reserved * obj_size) {
#line 506
    goto ldv_26596;
  } else {
#line 508
    goto ldv_26598;
  }
  ldv_26598: ;
#line 529
  return (table);
  err: 
#line 532
  i = 0;
#line 532
  goto ldv_26600;
  ldv_26599: ;
#line 533
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 534
    mthca_UNMAP_ICM(dev, (u64 )(i * 262144) + virt, 64U);
#line 536
    mthca_free_icm(dev, table->icm[i], table->coherent);
  } else {

  }
#line 532
  i = i + 1;
  ldv_26600: ;
#line 532
  if (i < num_icm) {
#line 533
    goto ldv_26599;
  } else {
#line 535
    goto ldv_26601;
  }
  ldv_26601: 
#line 539
  kfree((void const   *)table);
#line 541
  return (0);
}
}
#line 544 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_free_icm_table(struct mthca_dev *dev , struct mthca_icm_table *table ) 
{ int i ;

  {
#line 548
  i = 0;
#line 548
  goto ldv_26608;
  ldv_26607: ;
#line 549
  if ((unsigned long )table->icm[i] != (unsigned long )((struct mthca_icm *)0)) {
#line 550
    mthca_UNMAP_ICM(dev, table->virt + (u64 )(i * 262144), 64U);
#line 553
    mthca_free_icm(dev, table->icm[i], table->coherent);
  } else {

  }
#line 548
  i = i + 1;
  ldv_26608: ;
#line 548
  if (table->num_icm > i) {
#line 549
    goto ldv_26607;
  } else {
#line 551
    goto ldv_26609;
  }
  ldv_26609: 
#line 556
  kfree((void const   *)table);
#line 557
  return;
}
}
#line 559 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
static u64 mthca_uarc_virt(struct mthca_dev *dev , struct mthca_uar *uar , int page ) 
{ 

  {
#line 561
  return ((dev->uar_table.uarc_base + (u64 )(uar->index * dev->uar_table.uarc_size)) + (u64 )(page * 4096));
}
}
#line 566 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int mthca_map_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                      int index , u64 uaddr ) 
{ struct page *pages[1U] ;
  int ret ;
  int i ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  u64 tmp___2 ;
  struct page *tmp___3 ;

  {
#line 570
  ret = 0;
#line 573
  tmp = mthca_is_memfree(dev);
#line 573
  if (tmp == 0) {
#line 574
    return (0);
  } else {

  }
#line 576
  if (index < 0 || dev->uar_table.uarc_size / 8 < index) {
#line 577
    return (-22);
  } else {

  }
#line 579
  ldv_mutex_lock_216(& db_tab->mutex);
#line 581
  i = index / 512;
#line 583
  if ((db_tab->page[i].refcount > 511 || (db_tab->page[i].uvirt != 0ULL && db_tab->page[i].uvirt != uaddr)) || (uaddr & 4095ULL) != 0ULL) {
#line 586
    ret = -22;
#line 587
    goto out;
  } else {

  }
#line 590
  if (db_tab->page[i].refcount != 0) {
#line 591
    db_tab->page[i].refcount = db_tab->page[i].refcount + 1;
#line 592
    goto out;
  } else {

  }
#line 595
  tmp___0 = get_current();
#line 595
  tmp___1 = get_current();
#line 595
  ret = get_user_pages(tmp___1, tmp___0->mm, (unsigned long )uaddr & 0xfffffffffffff000UL,
                       1, 1, 0, (struct page **)(& pages), 0);
#line 597
  if (ret < 0) {
#line 598
    goto out;
  } else {

  }
#line 600
  sg_set_page(& db_tab->page[i].mem, pages[0], 4096U, (unsigned int )uaddr & 4095U);
#line 603
  ret = pci_map_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 604
  if (ret < 0) {
#line 605
    put_page(pages[0]);
#line 606
    goto out;
  } else {

  }
#line 609
  tmp___2 = mthca_uarc_virt(dev, uar, i);
#line 609
  ret = mthca_MAP_ICM_page(dev, db_tab->page[i].mem.dma_address, tmp___2);
#line 611
  if (ret != 0) {
#line 612
    pci_unmap_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 613
    tmp___3 = sg_page(& db_tab->page[i].mem);
#line 613
    put_page(tmp___3);
#line 614
    goto out;
  } else {

  }
#line 617
  db_tab->page[i].uvirt = uaddr;
#line 618
  db_tab->page[i].refcount = 1;
  out: 
#line 621
  ldv_mutex_unlock_217(& db_tab->mutex);
#line 622
  return (ret);
}
}
#line 625 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_unmap_user_db(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ,
                         int index ) 
{ int tmp ;

  {
#line 628
  tmp = mthca_is_memfree(dev);
#line 628
  if (tmp == 0) {
#line 629
    return;
  } else {

  }
#line 636
  ldv_mutex_lock_218(& db_tab->mutex);
#line 638
  db_tab->page[index / 512].refcount = db_tab->page[index / 512].refcount - 1;
#line 640
  ldv_mutex_unlock_219(& db_tab->mutex);
#line 641
  return;
}
}
#line 643 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
struct mthca_user_db_table *mthca_init_user_db_tab(struct mthca_dev *dev ) 
{ struct mthca_user_db_table *db_tab ;
  int npages ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;

  {
#line 649
  tmp = mthca_is_memfree(dev);
#line 649
  if (tmp == 0) {
#line 650
    return (0);
  } else {

  }
#line 652
  npages = dev->uar_table.uarc_size / 4096;
#line 653
  tmp___0 = kmalloc((unsigned long )npages * 56UL + 168UL, 208U);
#line 653
  db_tab = (struct mthca_user_db_table *)tmp___0;
#line 654
  if ((unsigned long )db_tab == (unsigned long )((struct mthca_user_db_table *)0)) {
#line 655
    tmp___1 = ERR_PTR(-12L);
#line 655
    return ((struct mthca_user_db_table *)tmp___1);
  } else {

  }
#line 657
  __mutex_init(& db_tab->mutex, "&db_tab->mutex", & __key);
#line 658
  i = 0;
#line 658
  goto ldv_26640;
  ldv_26639: 
#line 659
  db_tab->page[i].refcount = 0;
#line 660
  db_tab->page[i].uvirt = 0ULL;
#line 661
  sg_init_table(& db_tab->page[i].mem, 1U);
#line 658
  i = i + 1;
  ldv_26640: ;
#line 658
  if (i < npages) {
#line 659
    goto ldv_26639;
  } else {
#line 661
    goto ldv_26641;
  }
  ldv_26641: ;
#line 664
  return (db_tab);
}
}
#line 667 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_cleanup_user_db_tab(struct mthca_dev *dev , struct mthca_uar *uar , struct mthca_user_db_table *db_tab ) 
{ int i ;
  int tmp ;
  u64 tmp___0 ;
  struct page *tmp___1 ;

  {
#line 672
  tmp = mthca_is_memfree(dev);
#line 672
  if (tmp == 0) {
#line 673
    return;
  } else {

  }
#line 675
  i = 0;
#line 675
  goto ldv_26649;
  ldv_26648: ;
#line 676
  if (db_tab->page[i].uvirt != 0ULL) {
#line 677
    tmp___0 = mthca_uarc_virt(dev, uar, i);
#line 677
    mthca_UNMAP_ICM(dev, tmp___0, 1U);
#line 678
    pci_unmap_sg(dev->pdev, & db_tab->page[i].mem, 1, 1);
#line 679
    tmp___1 = sg_page(& db_tab->page[i].mem);
#line 679
    put_page(tmp___1);
  } else {

  }
#line 675
  i = i + 1;
  ldv_26649: ;
#line 675
  if (dev->uar_table.uarc_size / 4096 > i) {
#line 676
    goto ldv_26648;
  } else {
#line 678
    goto ldv_26650;
  }
  ldv_26650: 
#line 683
  kfree((void const   *)db_tab);
#line 684
  return;
}
}
#line 686 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int mthca_alloc_db(struct mthca_dev *dev , enum mthca_db_type type , u32 qn , __be32 **db ) 
{ int group ;
  int start ;
  int end ;
  int dir ;
  int i ;
  int j ;
  struct mthca_db_page *page ;
  int ret ;
  int tmp ;
  void *tmp___0 ;
  u64 tmp___1 ;
  unsigned long tmp___2 ;
  __u64 tmp___3 ;

  {
#line 693
  ret = 0;
#line 695
  ldv_mutex_lock_220(& (dev->db_tab)->mutex);
#line 697
  switch ((unsigned int )type) {
  case 2: ;
  case 3: 
#line 700
  group = 0;
#line 701
  start = 0;
#line 702
  end = (dev->db_tab)->max_group1;
#line 703
  dir = 1;
#line 704
  goto ldv_26667;
  case 1: ;
  case 4: ;
  case 5: 
#line 709
  group = 1;
#line 710
  start = (dev->db_tab)->npages + -1;
#line 711
  end = (dev->db_tab)->min_group2;
#line 712
  dir = -1;
#line 713
  goto ldv_26667;
  default: 
#line 716
  ret = -22;
#line 717
  goto out;
  }
  ldv_26667: 
#line 720
  i = start;
#line 720
  goto ldv_26675;
  ldv_26674: ;
#line 721
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec != (unsigned long )((__be64 *)0)) {
#line 721
    tmp = bitmap_full((unsigned long const   *)(& ((dev->db_tab)->page + (unsigned long )i)->used),
                      512);
#line 721
    if (tmp == 0) {
#line 724
      page = (dev->db_tab)->page + (unsigned long )i;
#line 725
      goto found;
    } else {

    }
  } else {

  }
#line 720
  i = i + dir;
  ldv_26675: ;
#line 720
  if (i != end) {
#line 721
    goto ldv_26674;
  } else {
#line 723
    goto ldv_26676;
  }
  ldv_26676: 
#line 728
  i = start;
#line 728
  goto ldv_26679;
  ldv_26678: ;
#line 729
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec == (unsigned long )((__be64 *)0)) {
#line 730
    page = (dev->db_tab)->page + (unsigned long )i;
#line 731
    goto alloc;
  } else {

  }
#line 728
  i = i + dir;
  ldv_26679: ;
#line 728
  if (i != end) {
#line 729
    goto ldv_26678;
  } else {
#line 731
    goto ldv_26680;
  }
  ldv_26680: ;
#line 734
  if ((dev->db_tab)->max_group1 >= (dev->db_tab)->min_group2 + -1) {
#line 735
    ret = -12;
#line 736
    goto out;
  } else {

  }
#line 739
  if (group == 0) {
#line 740
    (dev->db_tab)->max_group1 = (dev->db_tab)->max_group1 + 1;
  } else {
#line 742
    (dev->db_tab)->min_group2 = (dev->db_tab)->min_group2 - 1;
  }
#line 744
  page = (dev->db_tab)->page + (unsigned long )end;
  alloc: 
#line 747
  tmp___0 = dma_alloc_attrs(& (dev->pdev)->dev, 4096UL, & page->mapping, 208U, 0);
#line 747
  page->db_rec = (__be64 *)tmp___0;
#line 749
  if ((unsigned long )page->db_rec == (unsigned long )((__be64 *)0)) {
#line 750
    ret = -12;
#line 751
    goto out;
  } else {

  }
#line 753
  memset((void *)page->db_rec, 0, 4096UL);
#line 755
  tmp___1 = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 755
  ret = mthca_MAP_ICM_page(dev, page->mapping, tmp___1);
#line 757
  if (ret != 0) {
#line 758
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)page->db_rec, page->mapping,
                   0);
#line 760
    goto out;
  } else {

  }
#line 763
  bitmap_zero((unsigned long *)(& page->used), 512);
  found: 
#line 766
  tmp___2 = find_first_zero_bit((unsigned long const   *)(& page->used), 512UL);
#line 766
  j = (int )tmp___2;
#line 767
  set_bit((unsigned int )j, (unsigned long volatile   *)(& page->used));
#line 769
  if (group == 1) {
#line 770
    j = 511 - j;
  } else {

  }
#line 772
  ret = i * 512 + j;
#line 774
  tmp___3 = __fswab64((__u64 )((qn << 8) | ((unsigned int )type << 5)));
#line 774
  *(page->db_rec + (unsigned long )j) = tmp___3;
#line 776
  *db = (__be32 *)page->db_rec + (unsigned long )j;
  out: 
#line 779
  ldv_mutex_unlock_221(& (dev->db_tab)->mutex);
#line 781
  return (ret);
}
}
#line 784 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_free_db(struct mthca_dev *dev , int type , int db_index ) 
{ int i ;
  int j ;
  struct mthca_db_page *page ;
  u64 tmp ;
  int tmp___0 ;

  {
#line 789
  i = db_index / 512;
#line 790
  j = db_index % 512;
#line 792
  page = (dev->db_tab)->page + (unsigned long )i;
#line 794
  ldv_mutex_lock_222(& (dev->db_tab)->mutex);
#line 796
  *(page->db_rec + (unsigned long )j) = 0ULL;
#line 797
  if ((dev->db_tab)->min_group2 <= i) {
#line 798
    j = 511 - j;
  } else {

  }
#line 799
  clear_bit(j, (unsigned long volatile   *)(& page->used));
#line 801
  tmp___0 = bitmap_empty((unsigned long const   *)(& page->used), 512);
#line 801
  if (tmp___0 != 0 && (dev->db_tab)->max_group1 + -1 <= i) {
#line 803
    tmp = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 803
    mthca_UNMAP_ICM(dev, tmp, 1U);
#line 805
    dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)page->db_rec, page->mapping,
                   0);
#line 807
    page->db_rec = 0;
#line 809
    if ((dev->db_tab)->max_group1 == i) {
#line 810
      (dev->db_tab)->max_group1 = (dev->db_tab)->max_group1 - 1;
    } else {

    }
#line 813
    if ((dev->db_tab)->min_group2 == i) {
#line 814
      (dev->db_tab)->min_group2 = (dev->db_tab)->min_group2 + 1;
    } else {

    }
  } else {

  }
#line 817
  ldv_mutex_unlock_223(& (dev->db_tab)->mutex);
#line 818
  return;
}
}
#line 820 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int mthca_init_db_tab(struct mthca_dev *dev ) 
{ int i ;
  int tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  void *tmp___1 ;

  {
#line 824
  tmp = mthca_is_memfree(dev);
#line 824
  if (tmp == 0) {
#line 825
    return (0);
  } else {

  }
#line 827
  tmp___0 = kmalloc(192UL, 208U);
#line 827
  dev->db_tab = (struct mthca_db_table *)tmp___0;
#line 828
  if ((unsigned long )dev->db_tab == (unsigned long )((struct mthca_db_table *)0)) {
#line 829
    return (-12);
  } else {

  }
#line 831
  __mutex_init(& (dev->db_tab)->mutex, "&dev->db_tab->mutex", & __key);
#line 833
  (dev->db_tab)->npages = dev->uar_table.uarc_size / 4096;
#line 834
  (dev->db_tab)->max_group1 = 0;
#line 835
  (dev->db_tab)->min_group2 = (dev->db_tab)->npages + -1;
#line 837
  tmp___1 = kmalloc((unsigned long )(dev->db_tab)->npages * 80UL, 208U);
#line 837
  (dev->db_tab)->page = (struct mthca_db_page *)tmp___1;
#line 840
  if ((unsigned long )(dev->db_tab)->page == (unsigned long )((struct mthca_db_page *)0)) {
#line 841
    kfree((void const   *)dev->db_tab);
#line 842
    return (-12);
  } else {

  }
#line 845
  i = 0;
#line 845
  goto ldv_26695;
  ldv_26694: 
#line 846
  ((dev->db_tab)->page + (unsigned long )i)->db_rec = 0;
#line 845
  i = i + 1;
  ldv_26695: ;
#line 845
  if ((dev->db_tab)->npages > i) {
#line 846
    goto ldv_26694;
  } else {
#line 848
    goto ldv_26696;
  }
  ldv_26696: ;
#line 848
  return (0);
}
}
#line 851 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void mthca_cleanup_db_tab(struct mthca_dev *dev ) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  u64 tmp___1 ;

  {
#line 855
  tmp = mthca_is_memfree(dev);
#line 855
  if (tmp == 0) {
#line 856
    return;
  } else {

  }
#line 864
  i = 0;
#line 864
  goto ldv_26703;
  ldv_26702: ;
#line 865
  if ((unsigned long )((dev->db_tab)->page + (unsigned long )i)->db_rec == (unsigned long )((__be64 *)0)) {
#line 866
    goto ldv_26701;
  } else {

  }
#line 868
  tmp___0 = bitmap_empty((unsigned long const   *)(& ((dev->db_tab)->page + (unsigned long )i)->used),
                         512);
#line 868
  if (tmp___0 == 0) {
#line 869
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Kernel UARC page %d not empty\n",
             i);
  } else {

  }
#line 871
  tmp___1 = mthca_uarc_virt(dev, & dev->driver_uar, i);
#line 871
  mthca_UNMAP_ICM(dev, tmp___1, 1U);
#line 873
  dma_free_attrs(& (dev->pdev)->dev, 4096UL, (void *)((dev->db_tab)->page + (unsigned long )i)->db_rec,
                 ((dev->db_tab)->page + (unsigned long )i)->mapping, 0);
  ldv_26701: 
#line 864
  i = i + 1;
  ldv_26703: ;
#line 864
  if ((dev->db_tab)->npages > i) {
#line 865
    goto ldv_26702;
  } else {
#line 867
    goto ldv_26704;
  }
  ldv_26704: 
#line 878
  kfree((void const   *)(dev->db_tab)->page);
#line 879
  kfree((void const   *)dev->db_tab);
#line 880
  return;
}
}
#line 882 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 887
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 889
  mutex_lock(ldv_func_arg1);
#line 890
  return;
}
}
#line 892 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 897
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 899
  mutex_unlock(ldv_func_arg1);
#line 900
  return;
}
}
#line 902 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 907
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 909
  mutex_lock(ldv_func_arg1);
#line 910
  return;
}
}
#line 912 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 917
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 919
  mutex_unlock(ldv_func_arg1);
#line 920
  return;
}
}
#line 922 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 927
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 929
  mutex_lock(ldv_func_arg1);
#line 930
  return;
}
}
#line 932 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
int ldv_mutex_trylock_208(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 937
  tmp = mutex_trylock(ldv_func_arg1);
#line 937
  ldv_func_res = tmp;
#line 939
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 939
  return (tmp___0);
#line 941
  return (ldv_func_res);
}
}
#line 944 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 949
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 951
  mutex_unlock(ldv_func_arg1);
#line 952
  return;
}
}
#line 954 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 959
  ldv_mutex_lock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 961
  mutex_lock(ldv_func_arg1);
#line 962
  return;
}
}
#line 964 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 969
  ldv_mutex_unlock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 971
  mutex_unlock(ldv_func_arg1);
#line 972
  return;
}
}
#line 974 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_212(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 979
  ldv_mutex_lock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 981
  mutex_lock(ldv_func_arg1);
#line 982
  return;
}
}
#line 984 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 989
  ldv_mutex_unlock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 991
  mutex_unlock(ldv_func_arg1);
#line 992
  return;
}
}
#line 994 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_214(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 999
  ldv_mutex_lock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 1001
  mutex_lock(ldv_func_arg1);
#line 1002
  return;
}
}
#line 1004 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_215(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1009
  ldv_mutex_unlock_mutex_of_mthca_icm_table(ldv_func_arg1);
#line 1011
  mutex_unlock(ldv_func_arg1);
#line 1012
  return;
}
}
#line 1014 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_216(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1019
  ldv_mutex_lock_mutex_of_mthca_user_db_table(ldv_func_arg1);
#line 1021
  mutex_lock(ldv_func_arg1);
#line 1022
  return;
}
}
#line 1024 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_217(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1029
  ldv_mutex_unlock_mutex_of_mthca_user_db_table(ldv_func_arg1);
#line 1031
  mutex_unlock(ldv_func_arg1);
#line 1032
  return;
}
}
#line 1034 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_218(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1039
  ldv_mutex_lock_mutex_of_mthca_user_db_table(ldv_func_arg1);
#line 1041
  mutex_lock(ldv_func_arg1);
#line 1042
  return;
}
}
#line 1044 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_219(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1049
  ldv_mutex_unlock_mutex_of_mthca_user_db_table(ldv_func_arg1);
#line 1051
  mutex_unlock(ldv_func_arg1);
#line 1052
  return;
}
}
#line 1054 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_220(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1059
  ldv_mutex_lock_mutex_of_mthca_db_table(ldv_func_arg1);
#line 1061
  mutex_lock(ldv_func_arg1);
#line 1062
  return;
}
}
#line 1064 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1069
  ldv_mutex_unlock_mutex_of_mthca_db_table(ldv_func_arg1);
#line 1071
  mutex_unlock(ldv_func_arg1);
#line 1072
  return;
}
}
#line 1074 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_lock_222(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1079
  ldv_mutex_lock_mutex_of_mthca_db_table(ldv_func_arg1);
#line 1081
  mutex_lock(ldv_func_arg1);
#line 1082
  return;
}
}
#line 1084 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_memfree.c.prepared"
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1089
  ldv_mutex_unlock_mutex_of_mthca_db_table(ldv_func_arg1);
#line 1091
  mutex_unlock(ldv_func_arg1);
#line 1092
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_248(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_247(struct mutex *ldv_func_arg1 ) ;
#line 158 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
int mthca_uar_alloc(struct mthca_dev *dev , struct mthca_uar *uar ) 
{ u32 tmp ;

  {
#line 160
  tmp = mthca_alloc(& dev->uar_table.alloc);
#line 160
  uar->index = (int )tmp;
#line 161
  if (uar->index == -1) {
#line 162
    return (-12);
  } else {

  }
#line 164
  uar->pfn = (unsigned long )(((dev->pdev)->resource[2].start >> 12) + (resource_size_t )uar->index);
#line 166
  return (0);
}
}
#line 169 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void mthca_uar_free(struct mthca_dev *dev , struct mthca_uar *uar ) 
{ 

  {
#line 171
  mthca_free(& dev->uar_table.alloc, (u32 )uar->index);
#line 172
  return;
}
}
#line 174 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
int mthca_init_uar_table(struct mthca_dev *dev ) 
{ int ret ;

  {
#line 178
  ret = mthca_alloc_init(& dev->uar_table.alloc, (u32 )dev->limits.num_uars, (u32 )(dev->limits.num_uars + -1),
                         (u32 )(dev->limits.reserved_uars + 1));
#line 182
  if (ret != 0) {
#line 183
    return (ret);
  } else {

  }
#line 185
  ret = mthca_init_db_tab(dev);
#line 186
  if (ret != 0) {
#line 187
    mthca_alloc_cleanup(& dev->uar_table.alloc);
  } else {

  }
#line 189
  return (ret);
}
}
#line 192 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void mthca_cleanup_uar_table(struct mthca_dev *dev ) 
{ 

  {
#line 194
  mthca_cleanup_db_tab(dev);
#line 197
  mthca_alloc_cleanup(& dev->uar_table.alloc);
#line 198
  return;
}
}
#line 200 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 205
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 207
  mutex_lock(ldv_func_arg1);
#line 208
  return;
}
}
#line 210 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 215
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 217
  mutex_unlock(ldv_func_arg1);
#line 218
  return;
}
}
#line 220 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void ldv_mutex_lock_247(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 225
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 227
  mutex_lock(ldv_func_arg1);
#line 228
  return;
}
}
#line 230 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
int ldv_mutex_trylock_248(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 235
  tmp = mutex_trylock(ldv_func_arg1);
#line 235
  ldv_func_res = tmp;
#line 237
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 237
  return (tmp___0);
#line 239
  return (ldv_func_res);
}
}
#line 242 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_uar.c.prepared"
void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 247
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 249
  mutex_unlock(ldv_func_arg1);
#line 250
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_260(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) ;
#line 115
void ldv_mutex_lock_mutex_of_mthca_srq(struct mutex *lock ) ;
#line 119
void ldv_mutex_unlock_mutex_of_mthca_srq(struct mutex *lock ) ;
#line 192 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
static void *get_wqe(struct mthca_srq *srq , int n ) 
{ 

  {
#line 194
  if (srq->is_direct != 0) {
#line 195
    return (srq->queue.direct.buf + (unsigned long )(n << srq->wqe_shift));
  } else {
#line 197
    return ((srq->queue.page_list + (unsigned long )((n << srq->wqe_shift) >> 12))->buf + ((unsigned long )(n << srq->wqe_shift) & 4095UL));
  }
}
}
#line 210 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
__inline static int *wqe_to_link(void *wqe ) 
{ 

  {
#line 212
  return ((int *)wqe + 12U);
}
}
#line 215 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
static void mthca_tavor_init_srq_context(struct mthca_dev *dev , struct mthca_pd *pd ,
                                         struct mthca_srq *srq , struct mthca_tavor_srq_context *context ) 
{ __u64 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  struct mthca_ucontext *tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
#line 220
  memset((void *)context, 0, 32UL);
#line 222
  tmp = __fswab64((__u64 )(1 << (srq->wqe_shift + -4)));
#line 222
  context->wqe_base_ds = tmp;
#line 223
  tmp___0 = __fswab32(pd->pd_num);
#line 223
  context->state_pd = tmp___0;
#line 224
  tmp___1 = __fswab32(srq->mr.ibmr.lkey);
#line 224
  context->lkey = tmp___1;
#line 226
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 227
    tmp___2 = to_mucontext((pd->ibpd.uobject)->context);
#line 227
    tmp___3 = __fswab32((__u32 )tmp___2->uar.index);
#line 227
    context->uar = tmp___3;
  } else {
#line 230
    tmp___4 = __fswab32((__u32 )dev->driver_uar.index);
#line 230
    context->uar = tmp___4;
  }
#line 231
  return;
}
}
#line 233 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
static void mthca_arbel_init_srq_context(struct mthca_dev *dev , struct mthca_pd *pd ,
                                         struct mthca_srq *srq , struct mthca_arbel_srq_context *context ) 
{ int logsize ;
  int max ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  struct mthca_ucontext *tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;

  {
#line 240
  memset((void *)context, 0, 48UL);
#line 246
  max = srq->max;
#line 247
  logsize = __ilog2_u32((u32 )max);
#line 248
  tmp = __fswab32((__u32 )((logsize << 24) | srq->srqn));
#line 248
  context->state_logsize_srqn = tmp;
#line 249
  tmp___0 = __fswab32(srq->mr.ibmr.lkey);
#line 249
  context->lkey = tmp___0;
#line 250
  tmp___1 = __fswab32((__u32 )srq->db_index);
#line 250
  context->db_index = tmp___1;
#line 251
  tmp___2 = __fswab32((__u32 )((srq->wqe_shift + -4) << 29));
#line 251
  context->logstride_usrpage = tmp___2;
#line 252
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 253
    tmp___3 = to_mucontext((pd->ibpd.uobject)->context);
#line 253
    tmp___4 = __fswab32((__u32 )tmp___3->uar.index);
#line 253
    context->logstride_usrpage = context->logstride_usrpage | tmp___4;
  } else {
#line 256
    tmp___5 = __fswab32((__u32 )dev->driver_uar.index);
#line 256
    context->logstride_usrpage = context->logstride_usrpage | tmp___5;
  }
#line 257
  tmp___6 = __fswab32(pd->pd_num | 16777216U);
#line 257
  context->eq_pd = tmp___6;
#line 258
  return;
}
}
#line 260 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
static void mthca_free_srq_buf(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ 

  {
#line 262
  mthca_buf_free(dev, srq->max << srq->wqe_shift, & srq->queue, srq->is_direct, & srq->mr);
#line 264
  kfree((void const   *)srq->wrid);
#line 265
  return;
}
}
#line 267 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
static int mthca_alloc_srq_buf(struct mthca_dev *dev , struct mthca_pd *pd , struct mthca_srq *srq ) 
{ struct mthca_data_seg *scatter ;
  void *wqe ;
  int err ;
  int i ;
  void *tmp ;
  struct mthca_next_seg *next ;
  int *tmp___0 ;
  __u32 tmp___1 ;
  int *tmp___2 ;

  {
#line 275
  if ((unsigned long )pd->ibpd.uobject != (unsigned long )((struct ib_uobject *)0)) {
#line 276
    return (0);
  } else {

  }
#line 278
  tmp = kmalloc((unsigned long )srq->max * 8UL, 208U);
#line 278
  srq->wrid = (u64 *)tmp;
#line 279
  if ((unsigned long )srq->wrid == (unsigned long )((u64 *)0)) {
#line 280
    return (-12);
  } else {

  }
#line 282
  err = mthca_buf_alloc(dev, srq->max << srq->wqe_shift, 16384, & srq->queue, & srq->is_direct,
                        pd, 1, & srq->mr);
#line 285
  if (err != 0) {
#line 286
    kfree((void const   *)srq->wrid);
#line 287
    return (err);
  } else {

  }
#line 295
  i = 0;
#line 295
  goto ldv_26517;
  ldv_26516: 
#line 298
  wqe = get_wqe(srq, i);
#line 298
  next = (struct mthca_next_seg *)wqe;
#line 300
  if (srq->max + -1 > i) {
#line 301
    tmp___0 = wqe_to_link(wqe);
#line 301
    *tmp___0 = i + 1;
#line 302
    tmp___1 = __fswab32((__u32 )(((i + 1) << srq->wqe_shift) | 1));
#line 302
    next->nda_op = tmp___1;
  } else {
#line 304
    tmp___2 = wqe_to_link(wqe);
#line 304
    *tmp___2 = -1;
#line 305
    next->nda_op = 0U;
  }
#line 308
  scatter = (struct mthca_data_seg *)wqe + 16U;
#line 308
  goto ldv_26514;
  ldv_26513: 
#line 311
  scatter->lkey = 65536U;
#line 310
  scatter = scatter + 1;
  ldv_26514: ;
#line 308
  if ((unsigned long )(wqe + (unsigned long )(1 << srq->wqe_shift)) > (unsigned long )((void *)scatter)) {
#line 310
    goto ldv_26513;
  } else {
#line 312
    goto ldv_26515;
  }
  ldv_26515: 
#line 295
  i = i + 1;
  ldv_26517: ;
#line 295
  if (srq->max > i) {
#line 296
    goto ldv_26516;
  } else {
#line 298
    goto ldv_26518;
  }
  ldv_26518: 
#line 314
  srq->last = get_wqe(srq, srq->max + -1);
#line 316
  return (0);
}
}
#line 319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_alloc_srq(struct mthca_dev *dev , struct mthca_pd *pd , struct ib_srq_attr *attr ,
                    struct mthca_srq *srq ) 
{ struct mthca_mailbox *mailbox ;
  int ds ;
  int err ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 327
  if (attr->max_wr > (u32 )dev->limits.max_srq_wqes || attr->max_sge > (u32 )dev->limits.max_srq_sge) {
#line 329
    return (-22);
  } else {

  }
#line 331
  srq->max = (int )attr->max_wr;
#line 332
  srq->max_gs = (int )attr->max_sge;
#line 333
  srq->counter = 0U;
#line 335
  tmp___0 = mthca_is_memfree(dev);
#line 335
  if (tmp___0 != 0) {
#line 336
    tmp = __roundup_pow_of_two((unsigned long )(srq->max + 1));
#line 336
    srq->max = (int )tmp;
  } else {
#line 338
    srq->max = srq->max + 1;
  }
#line 340
  _max1 = 64UL;
#line 340
  tmp___1 = __roundup_pow_of_two(((unsigned long )srq->max_gs + 1UL) * 16UL);
#line 340
  _max2 = tmp___1;
#line 340
  if (_max1 > _max2) {
#line 340
    tmp___2 = _max1;
  } else {
#line 340
    tmp___2 = _max2;
  }
#line 340
  ds = (int )tmp___2;
#line 344
  tmp___3 = mthca_is_memfree(dev);
#line 344
  if (tmp___3 == 0 && dev->limits.max_desc_sz < ds) {
#line 345
    return (-22);
  } else {

  }
#line 347
  srq->wqe_shift = __ilog2_u32((u32 )ds);
#line 349
  tmp___4 = mthca_alloc(& dev->srq_table.alloc);
#line 349
  srq->srqn = (int )tmp___4;
#line 350
  if (srq->srqn == -1) {
#line 351
    return (-12);
  } else {

  }
#line 353
  tmp___5 = mthca_is_memfree(dev);
#line 353
  if (tmp___5 != 0) {
#line 354
    err = mthca_table_get(dev, dev->srq_table.table, srq->srqn);
#line 355
    if (err != 0) {
#line 356
      goto err_out;
    } else {

    }
#line 358
    if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 359
      srq->db_index = mthca_alloc_db(dev, 5, (u32 )srq->srqn, & srq->db);
#line 361
      if (srq->db_index < 0) {
#line 362
        err = -12;
#line 363
        goto err_out_icm;
      } else {

      }
    } else {

    }
  } else {

  }
#line 368
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 369
  tmp___7 = IS_ERR((void const   *)mailbox);
#line 369
  if (tmp___7 != 0L) {
#line 370
    tmp___6 = PTR_ERR((void const   *)mailbox);
#line 370
    err = (int )tmp___6;
#line 371
    goto err_out_db;
  } else {

  }
#line 374
  err = mthca_alloc_srq_buf(dev, pd, srq);
#line 375
  if (err != 0) {
#line 376
    goto err_out_mailbox;
  } else {

  }
#line 378
  spinlock_check(& srq->lock);
#line 378
  __raw_spin_lock_init(& srq->lock.ldv_5961.rlock, "&(&srq->lock)->rlock", & __key);
#line 379
  srq->refcount = 1;
#line 380
  __init_waitqueue_head(& srq->wait, "&srq->wait", & __key___0);
#line 381
  __mutex_init(& srq->mutex, "&srq->mutex", & __key___1);
#line 383
  tmp___8 = mthca_is_memfree(dev);
#line 383
  if (tmp___8 != 0) {
#line 384
    mthca_arbel_init_srq_context(dev, pd, srq, (struct mthca_arbel_srq_context *)mailbox->buf);
  } else {
#line 386
    mthca_tavor_init_srq_context(dev, pd, srq, (struct mthca_tavor_srq_context *)mailbox->buf);
  }
#line 388
  err = mthca_SW2HW_SRQ(dev, mailbox, srq->srqn);
#line 390
  if (err != 0) {
#line 391
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "SW2HW_SRQ failed (%d)\n",
             err);
#line 392
    goto err_out_free_buf;
  } else {

  }
#line 395
  spin_lock_irq(& dev->srq_table.lock);
#line 396
  tmp___9 = mthca_array_set(& dev->srq_table.srq, srq->srqn & (dev->limits.num_srqs + -1),
                            (void *)srq);
#line 396
  if (tmp___9 != 0) {
#line 399
    spin_unlock_irq(& dev->srq_table.lock);
#line 400
    goto err_out_free_srq;
  } else {

  }
#line 402
  spin_unlock_irq(& dev->srq_table.lock);
#line 404
  mthca_free_mailbox(dev, mailbox);
#line 406
  srq->first_free = 0;
#line 407
  srq->last_free = srq->max + -1;
#line 409
  attr->max_wr = (u32 )(srq->max + -1);
#line 410
  attr->max_sge = (u32 )srq->max_gs;
#line 412
  return (0);
  err_out_free_srq: 
#line 415
  err = mthca_HW2SW_SRQ(dev, mailbox, srq->srqn);
#line 416
  if (err != 0) {
#line 417
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_SRQ failed (%d)\n",
             err);
  } else {

  }
  err_out_free_buf: ;
#line 420
  if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 421
    mthca_free_srq_buf(dev, srq);
  } else {

  }
  err_out_mailbox: 
#line 424
  mthca_free_mailbox(dev, mailbox);
  err_out_db: ;
#line 427
  if ((unsigned long )pd->ibpd.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 427
    tmp___10 = mthca_is_memfree(dev);
#line 427
    if (tmp___10 != 0) {
#line 428
      mthca_free_db(dev, 5, srq->db_index);
    } else {

    }
  } else {

  }
  err_out_icm: 
#line 431
  mthca_table_put(dev, dev->srq_table.table, srq->srqn);
  err_out: 
#line 434
  mthca_free(& dev->srq_table.alloc, (u32 )srq->srqn);
#line 436
  return (err);
}
}
#line 439 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
__inline static int get_srq_refcount(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ int c ;

  {
#line 443
  spin_lock_irq(& dev->srq_table.lock);
#line 444
  c = srq->refcount;
#line 445
  spin_unlock_irq(& dev->srq_table.lock);
#line 447
  return (c);
}
}
#line 450 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void mthca_free_srq(struct mthca_dev *dev , struct mthca_srq *srq ) 
{ struct mthca_mailbox *mailbox ;
  int err ;
  long tmp ;
  int tmp___0 ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 455
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 456
  tmp = IS_ERR((void const   *)mailbox);
#line 456
  if (tmp != 0L) {
#line 457
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "No memory for mailbox to free SRQ.\n");
#line 458
    return;
  } else {

  }
#line 461
  err = mthca_HW2SW_SRQ(dev, mailbox, srq->srqn);
#line 462
  if (err != 0) {
#line 463
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "HW2SW_SRQ failed (%d)\n",
             err);
  } else {

  }
#line 465
  spin_lock_irq(& dev->srq_table.lock);
#line 466
  mthca_array_clear(& dev->srq_table.srq, srq->srqn & (dev->limits.num_srqs + -1));
#line 468
  srq->refcount = srq->refcount - 1;
#line 469
  spin_unlock_irq(& dev->srq_table.lock);
#line 471
  tmp___0 = get_srq_refcount(dev, srq);
#line 471
  if (tmp___0 == 0) {
#line 471
    goto ldv_26551;
  } else {

  }
#line 471
  tmp___1 = get_current();
#line 471
  __wait.flags = 0U;
#line 471
  __wait.private = (void *)tmp___1;
#line 471
  __wait.func = & autoremove_wake_function;
#line 471
  __wait.task_list.next = & __wait.task_list;
#line 471
  __wait.task_list.prev = & __wait.task_list;
  ldv_26554: 
#line 471
  prepare_to_wait(& srq->wait, & __wait, 2);
#line 471
  tmp___2 = get_srq_refcount(dev, srq);
#line 471
  if (tmp___2 == 0) {
#line 471
    goto ldv_26553;
  } else {

  }
#line 471
  schedule();
#line 471
  goto ldv_26554;
  ldv_26553: 
#line 471
  finish_wait(& srq->wait, & __wait);
  ldv_26551: ;
#line 473
  if ((unsigned long )srq->ibsrq.uobject == (unsigned long )((struct ib_uobject *)0)) {
#line 474
    mthca_free_srq_buf(dev, srq);
#line 475
    tmp___3 = mthca_is_memfree(dev);
#line 475
    if (tmp___3 != 0) {
#line 476
      mthca_free_db(dev, 5, srq->db_index);
    } else {

    }
  } else {

  }
#line 479
  mthca_table_put(dev, dev->srq_table.table, srq->srqn);
#line 480
  mthca_free(& dev->srq_table.alloc, (u32 )srq->srqn);
#line 481
  mthca_free_mailbox(dev, mailbox);
#line 482
  return;
}
}
#line 484 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_modify_srq(struct ib_srq *ibsrq , struct ib_srq_attr *attr , enum ib_srq_attr_mask attr_mask ,
                     struct ib_udata *udata ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  int ret ;
  u32 max_wr ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 487
  tmp = to_mdev(ibsrq->device);
#line 487
  dev = tmp;
#line 488
  tmp___0 = to_msrq(ibsrq);
#line 488
  srq = tmp___0;
#line 489
  ret = 0;
#line 492
  if ((int )attr_mask & 1) {
#line 493
    return (-22);
  } else {

  }
#line 495
  if (((unsigned int )attr_mask & 2U) != 0U) {
#line 496
    tmp___3 = mthca_is_memfree(dev);
#line 496
    if (tmp___3 != 0) {
#line 496
      tmp___2 = srq->max + -1;
    } else {
#line 496
      tmp___2 = srq->max;
    }
#line 496
    max_wr = (u32 )tmp___2;
#line 497
    if (attr->srq_limit > max_wr) {
#line 498
      return (-22);
    } else {

    }
#line 500
    ldv_mutex_lock_262(& srq->mutex);
#line 501
    ret = mthca_ARM_SRQ(dev, srq->srqn, (int )attr->srq_limit);
#line 502
    ldv_mutex_unlock_263(& srq->mutex);
  } else {

  }
#line 505
  return (ret);
}
}
#line 508 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_query_srq(struct ib_srq *ibsrq , struct ib_srq_attr *srq_attr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  struct mthca_mailbox *mailbox ;
  struct mthca_arbel_srq_context *arbel_ctx ;
  struct mthca_tavor_srq_context *tavor_ctx ;
  int err ;
  long tmp___1 ;
  long tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  int tmp___5 ;

  {
#line 510
  tmp = to_mdev(ibsrq->device);
#line 510
  dev = tmp;
#line 511
  tmp___0 = to_msrq(ibsrq);
#line 511
  srq = tmp___0;
#line 517
  mailbox = mthca_alloc_mailbox(dev, 208U);
#line 518
  tmp___2 = IS_ERR((void const   *)mailbox);
#line 518
  if (tmp___2 != 0L) {
#line 519
    tmp___1 = PTR_ERR((void const   *)mailbox);
#line 519
    return ((int )tmp___1);
  } else {

  }
#line 521
  err = mthca_QUERY_SRQ(dev, (u32 )srq->srqn, mailbox);
#line 522
  if (err != 0) {
#line 523
    goto out;
  } else {

  }
#line 525
  tmp___5 = mthca_is_memfree(dev);
#line 525
  if (tmp___5 != 0) {
#line 526
    arbel_ctx = (struct mthca_arbel_srq_context *)mailbox->buf;
#line 527
    tmp___3 = __fswab16((int )arbel_ctx->limit_watermark);
#line 527
    srq_attr->srq_limit = (u32 )tmp___3;
  } else {
#line 529
    tavor_ctx = (struct mthca_tavor_srq_context *)mailbox->buf;
#line 530
    tmp___4 = __fswab16((int )tavor_ctx->limit_watermark);
#line 530
    srq_attr->srq_limit = (u32 )tmp___4;
  }
#line 533
  srq_attr->max_wr = (u32 )(srq->max + -1);
#line 534
  srq_attr->max_sge = (u32 )srq->max_gs;
  out: 
#line 537
  mthca_free_mailbox(dev, mailbox);
#line 539
  return (err);
}
}
#line 542 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void mthca_srq_event(struct mthca_dev *dev , u32 srqn , enum ib_event_type event_type ) 
{ struct mthca_srq *srq ;
  struct ib_event event ;
  void *tmp ;

  {
#line 548
  spin_lock(& dev->srq_table.lock);
#line 549
  tmp = mthca_array_get(& dev->srq_table.srq, (int )((u32 )(dev->limits.num_srqs + -1) & srqn));
#line 549
  srq = (struct mthca_srq *)tmp;
#line 550
  if ((unsigned long )srq != (unsigned long )((struct mthca_srq *)0)) {
#line 551
    srq->refcount = srq->refcount + 1;
  } else {

  }
#line 552
  spin_unlock(& dev->srq_table.lock);
#line 554
  if ((unsigned long )srq == (unsigned long )((struct mthca_srq *)0)) {
#line 555
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "Async event for bogus SRQ %08x\n",
             srqn);
#line 556
    return;
  } else {

  }
#line 559
  if ((unsigned long )srq->ibsrq.event_handler == (unsigned long )((void (*)(struct ib_event * ,
                                                                             void * ))0)) {
#line 560
    goto out;
  } else {

  }
#line 562
  event.device = & dev->ib_dev;
#line 563
  event.event = event_type;
#line 564
  event.element.srq = & srq->ibsrq;
#line 565
  (*(srq->ibsrq.event_handler))(& event, srq->ibsrq.srq_context);
  out: 
#line 568
  spin_lock(& dev->srq_table.lock);
#line 569
  srq->refcount = srq->refcount - 1;
#line 569
  if (srq->refcount == 0) {
#line 570
    __wake_up(& srq->wait, 3U, 1, 0);
  } else {

  }
#line 571
  spin_unlock(& dev->srq_table.lock);
#line 572
  return;
}
}
#line 577 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void mthca_free_srq_wqe(struct mthca_srq *srq , u32 wqe_addr ) 
{ int ind ;
  struct mthca_next_seg *last_free ;
  void *tmp ;
  int *tmp___0 ;
  __u32 tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 582
  ind = (int )(wqe_addr >> srq->wqe_shift);
#line 584
  spin_lock(& srq->lock);
#line 586
  tmp = get_wqe(srq, srq->last_free);
#line 586
  last_free = (struct mthca_next_seg *)tmp;
#line 587
  tmp___0 = wqe_to_link((void *)last_free);
#line 587
  *tmp___0 = ind;
#line 588
  tmp___1 = __fswab32((__u32 )((ind << srq->wqe_shift) | 1));
#line 588
  last_free->nda_op = tmp___1;
#line 589
  tmp___2 = get_wqe(srq, ind);
#line 589
  tmp___3 = wqe_to_link(tmp___2);
#line 589
  *tmp___3 = -1;
#line 590
  srq->last_free = ind;
#line 592
  spin_unlock(& srq->lock);
#line 593
  return;
}
}
#line 595 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_tavor_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  unsigned long flags ;
  int err ;
  int first_ind ;
  int ind ;
  int next_ind ;
  int nreq ;
  int i ;
  void *wqe ;
  void *prev_wqe ;
  raw_spinlock_t *tmp___1 ;
  int *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 598
  tmp = to_mdev(ibsrq->device);
#line 598
  dev = tmp;
#line 599
  tmp___0 = to_msrq(ibsrq);
#line 599
  srq = tmp___0;
#line 601
  err = 0;
#line 610
  tmp___1 = spinlock_check(& srq->lock);
#line 610
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 612
  first_ind = srq->first_free;
#line 614
  nreq = 0;
#line 614
  goto ldv_26614;
  ldv_26613: 
#line 615
  ind = srq->first_free;
#line 616
  wqe = get_wqe(srq, ind);
#line 617
  tmp___2 = wqe_to_link(wqe);
#line 617
  next_ind = *tmp___2;
#line 619
  tmp___3 = ldv__builtin_expect(next_ind < 0, 0L);
#line 619
  if (tmp___3 != 0L) {
#line 620
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SRQ %06x full\n", srq->srqn);
#line 621
    err = -12;
#line 622
    *bad_wr = wr;
#line 623
    goto ldv_26609;
  } else {

  }
#line 626
  prev_wqe = srq->last;
#line 627
  srq->last = wqe;
#line 629
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 632
  wqe = wqe + 16UL;
#line 634
  tmp___4 = ldv__builtin_expect(wr->num_sge > srq->max_gs, 0L);
#line 634
  if (tmp___4 != 0L) {
#line 635
    err = -22;
#line 636
    *bad_wr = wr;
#line 637
    srq->last = prev_wqe;
#line 638
    goto ldv_26609;
  } else {

  }
#line 641
  i = 0;
#line 641
  goto ldv_26611;
  ldv_26610: 
#line 642
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 643
  wqe = wqe + 16UL;
#line 641
  i = i + 1;
  ldv_26611: ;
#line 641
  if (wr->num_sge > i) {
#line 642
    goto ldv_26610;
  } else {
#line 644
    goto ldv_26612;
  }
  ldv_26612: ;
#line 646
  if (srq->max_gs > i) {
#line 647
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 649
  ((struct mthca_next_seg *)prev_wqe)->ee_nds = 2147483648U;
#line 652
  *(srq->wrid + (unsigned long )ind) = wr->wr_id;
#line 653
  srq->first_free = next_ind;
#line 655
  nreq = nreq + 1;
#line 656
  tmp___5 = ldv__builtin_expect(nreq == 256, 0L);
#line 656
  if (tmp___5 != 0L) {
#line 657
    nreq = 0;
#line 663
    __asm__  volatile   ("sfence": : : "memory");
#line 665
    mthca_write64((u32 )(first_ind << srq->wqe_shift), (u32 )(srq->srqn << 8), dev->kar + 24UL,
                  0);
#line 669
    first_ind = srq->first_free;
  } else {

  }
#line 614
  wr = wr->next;
  ldv_26614: ;
#line 614
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 615
    goto ldv_26613;
  } else {
#line 617
    goto ldv_26609;
  }
  ldv_26609: 
#line 673
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 673
  if (tmp___6 != 0L) {
#line 678
    __asm__  volatile   ("sfence": : : "memory");
#line 680
    mthca_write64((u32 )(first_ind << srq->wqe_shift), (u32 )((srq->srqn << 8) | nreq),
                  dev->kar + 24UL, 0);
  } else {

  }
#line 689
  __asm__  volatile   ("": : : "memory");
#line 691
  spin_unlock_irqrestore(& srq->lock, flags);
#line 692
  return (err);
}
}
#line 695 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_arbel_post_srq_recv(struct ib_srq *ibsrq , struct ib_recv_wr *wr , struct ib_recv_wr **bad_wr ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmp ;
  struct mthca_srq *srq ;
  struct mthca_srq *tmp___0 ;
  unsigned long flags ;
  int err ;
  int ind ;
  int next_ind ;
  int nreq ;
  int i ;
  void *wqe ;
  raw_spinlock_t *tmp___1 ;
  int *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  __u32 tmp___5 ;
  long tmp___6 ;

  {
#line 698
  tmp = to_mdev(ibsrq->device);
#line 698
  dev = tmp;
#line 699
  tmp___0 = to_msrq(ibsrq);
#line 699
  srq = tmp___0;
#line 701
  err = 0;
#line 708
  tmp___1 = spinlock_check(& srq->lock);
#line 708
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 710
  nreq = 0;
#line 710
  goto ldv_26637;
  ldv_26636: 
#line 711
  ind = srq->first_free;
#line 712
  wqe = get_wqe(srq, ind);
#line 713
  tmp___2 = wqe_to_link(wqe);
#line 713
  next_ind = *tmp___2;
#line 715
  tmp___3 = ldv__builtin_expect(next_ind < 0, 0L);
#line 715
  if (tmp___3 != 0L) {
#line 716
    dev_err((struct device  const  *)(& (dev->pdev)->dev), "SRQ %06x full\n", srq->srqn);
#line 717
    err = -12;
#line 718
    *bad_wr = wr;
#line 719
    goto ldv_26632;
  } else {

  }
#line 722
  ((struct mthca_next_seg *)wqe)->ee_nds = 0U;
#line 725
  wqe = wqe + 16UL;
#line 727
  tmp___4 = ldv__builtin_expect(wr->num_sge > srq->max_gs, 0L);
#line 727
  if (tmp___4 != 0L) {
#line 728
    err = -22;
#line 729
    *bad_wr = wr;
#line 730
    goto ldv_26632;
  } else {

  }
#line 733
  i = 0;
#line 733
  goto ldv_26634;
  ldv_26633: 
#line 734
  mthca_set_data_seg((struct mthca_data_seg *)wqe, wr->sg_list + (unsigned long )i);
#line 735
  wqe = wqe + 16UL;
#line 733
  i = i + 1;
  ldv_26634: ;
#line 733
  if (wr->num_sge > i) {
#line 734
    goto ldv_26633;
  } else {
#line 736
    goto ldv_26635;
  }
  ldv_26635: ;
#line 738
  if (srq->max_gs > i) {
#line 739
    mthca_set_data_seg_inval((struct mthca_data_seg *)wqe);
  } else {

  }
#line 741
  *(srq->wrid + (unsigned long )ind) = wr->wr_id;
#line 742
  srq->first_free = next_ind;
#line 710
  nreq = nreq + 1;
#line 710
  wr = wr->next;
  ldv_26637: ;
#line 710
  if ((unsigned long )wr != (unsigned long )((struct ib_recv_wr *)0)) {
#line 711
    goto ldv_26636;
  } else {
#line 713
    goto ldv_26632;
  }
  ldv_26632: 
#line 745
  tmp___6 = ldv__builtin_expect(nreq != 0, 1L);
#line 745
  if (tmp___6 != 0L) {
#line 746
    srq->counter = (int )srq->counter + (int )((u16 )nreq);
#line 752
    __asm__  volatile   ("sfence": : : "memory");
#line 753
    tmp___5 = __fswab32((__u32 )srq->counter);
#line 753
    *(srq->db) = tmp___5;
  } else {

  }
#line 756
  spin_unlock_irqrestore(& srq->lock, flags);
#line 757
  return (err);
}
}
#line 760 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_max_srq_sge(struct mthca_dev *dev ) 
{ int tmp ;
  int __min1 ;
  int __min2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 762
  tmp = mthca_is_memfree(dev);
#line 762
  if (tmp != 0) {
#line 763
    return (dev->limits.max_sg);
  } else {

  }
#line 779
  __min1 = dev->limits.max_sg;
#line 779
  tmp___0 = fls(dev->limits.max_desc_sz);
#line 779
  __min2 = (int )(((unsigned long )(1 << (tmp___0 + -1)) - 16UL) / 16UL);
#line 779
  if (__min1 < __min2) {
#line 779
    tmp___1 = __min1;
  } else {
#line 779
    tmp___1 = __min2;
  }
#line 779
  return (tmp___1);
}
}
#line 785 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int mthca_init_srq_table(struct mthca_dev *dev ) 
{ int err ;
  struct lock_class_key __key ;

  {
#line 789
  if ((dev->mthca_flags & 4UL) == 0UL) {
#line 790
    return (0);
  } else {

  }
#line 792
  spinlock_check(& dev->srq_table.lock);
#line 792
  __raw_spin_lock_init(& dev->srq_table.lock.ldv_5961.rlock, "&(&dev->srq_table.lock)->rlock",
                       & __key);
#line 794
  err = mthca_alloc_init(& dev->srq_table.alloc, (u32 )dev->limits.num_srqs, (u32 )(dev->limits.num_srqs + -1),
                         (u32 )dev->limits.reserved_srqs);
#line 798
  if (err != 0) {
#line 799
    return (err);
  } else {

  }
#line 801
  err = mthca_array_init(& dev->srq_table.srq, dev->limits.num_srqs);
#line 803
  if (err != 0) {
#line 804
    mthca_alloc_cleanup(& dev->srq_table.alloc);
  } else {

  }
#line 806
  return (err);
}
}
#line 809 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void mthca_cleanup_srq_table(struct mthca_dev *dev ) 
{ 

  {
#line 811
  if ((dev->mthca_flags & 4UL) == 0UL) {
#line 812
    return;
  } else {

  }
#line 814
  mthca_array_cleanup(& dev->srq_table.srq, dev->limits.num_srqs);
#line 815
  mthca_alloc_cleanup(& dev->srq_table.alloc);
#line 816
  return;
}
}
#line 818 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 823
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 833
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 835
  mutex_unlock(ldv_func_arg1);
#line 836
  return;
}
}
#line 838 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 843
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 845
  mutex_lock(ldv_func_arg1);
#line 846
  return;
}
}
#line 848 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 853
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 855
  mutex_unlock(ldv_func_arg1);
#line 856
  return;
}
}
#line 858 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 863
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 865
  mutex_lock(ldv_func_arg1);
#line 866
  return;
}
}
#line 868 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
int ldv_mutex_trylock_260(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 873
  tmp = mutex_trylock(ldv_func_arg1);
#line 873
  ldv_func_res = tmp;
#line 875
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 875
  return (tmp___0);
#line 877
  return (ldv_func_res);
}
}
#line 880 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 885
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 887
  mutex_unlock(ldv_func_arg1);
#line 888
  return;
}
}
#line 890 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 895
  ldv_mutex_lock_mutex_of_mthca_srq(ldv_func_arg1);
#line 897
  mutex_lock(ldv_func_arg1);
#line 898
  return;
}
}
#line 900 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_srq.c.prepared"
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 905
  ldv_mutex_unlock_mutex_of_mthca_srq(ldv_func_arg1);
#line 907
  mutex_unlock(ldv_func_arg1);
#line 908
  return;
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
#line 277
  first = list->next;
#line 278
  last = list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
#line 285
  return;
}
}
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
#line 321
  if (tmp == 0) {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
  } else {

  }
#line 325
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_276(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_279(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) ;
#line 94 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 176
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 240
extern void add_timer(struct timer_list * ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 259
extern unsigned long round_jiffies(unsigned long  ) ;
#line 164 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 328
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 390
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 394
extern bool queue_work(struct workqueue_struct * , struct work_struct * ) ;
#line 169 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static spinlock_t catas_lock  =    {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "catas_lock",
                                                               0, 0UL}}}};
#line 171 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static struct list_head catas_list  =    {& catas_list, & catas_list};
#line 172 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static struct workqueue_struct *catas_wq  ;
#line 173 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static struct work_struct catas_work  ;
#line 175 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static int catas_reset_disable  ;
#line 179 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static void catas_reset(struct work_struct *work ) 
{ struct mthca_dev *dev ;
  struct mthca_dev *tmpdev ;
  struct list_head tlist ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct pci_dev *pdev ;
  char const   *tmp ;
  struct mthca_dev *d ;
  void *tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 182
  tlist.next = & tlist;
#line 182
  tlist.prev = & tlist;
#line 185
  ldv_mutex_lock_278(& mthca_device_mutex);
#line 187
  spin_lock_irq(& catas_lock);
#line 188
  list_splice_init(& catas_list, & tlist);
#line 189
  spin_unlock_irq(& catas_lock);
#line 191
  __mptr = (struct list_head  const  *)tlist.next;
#line 191
  dev = (struct mthca_dev *)__mptr + 0xffffffffffffea80UL;
#line 191
  __mptr___0 = (struct list_head  const  *)dev->catas_err.list.next;
#line 191
  tmpdev = (struct mthca_dev *)__mptr___0 + 0xffffffffffffea80UL;
#line 191
  goto ldv_23665;
  ldv_23664: 
#line 192
  pdev = dev->pdev;
#line 193
  ret = __mthca_restart_one(dev->pdev);
#line 195
  if (ret != 0) {
#line 196
    tmp = pci_name((struct pci_dev  const  *)pdev);
#line 196
    printk("\vmthca %s: Reset failed (%d)\n", tmp, ret);
  } else {
#line 199
    tmp___0 = pci_get_drvdata(pdev);
#line 199
    d = (struct mthca_dev *)tmp___0;
#line 200
    if (mthca_debug_level != 0) {
#line 200
      dev_printk("\017", (struct device  const  *)(& (d->pdev)->dev), "Reset succeeded\n");
    } else {

    }
  }
#line 191
  dev = tmpdev;
#line 191
  __mptr___1 = (struct list_head  const  *)tmpdev->catas_err.list.next;
#line 191
  tmpdev = (struct mthca_dev *)__mptr___1 + 0xffffffffffffea80UL;
  ldv_23665: ;
#line 191
  if ((unsigned long )(& dev->catas_err.list) != (unsigned long )(& tlist)) {
#line 192
    goto ldv_23664;
  } else {
#line 194
    goto ldv_23666;
  }
  ldv_23666: 
#line 204
  ldv_mutex_unlock_279(& mthca_device_mutex);
#line 205
  return;
}
}
#line 207 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static void handle_catas(struct mthca_dev *dev ) 
{ struct ib_event event ;
  unsigned long flags ;
  char const   *type ;
  int i ;
  unsigned int tmp ;
  __u32 tmp___0 ;
  unsigned int tmp___1 ;
  __u32 tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
#line 214
  event.device = & dev->ib_dev;
#line 215
  event.event = 8;
#line 216
  event.element.port_num = 0U;
#line 217
  dev->active = 0;
#line 219
  ib_dispatch_event(& event);
#line 221
  tmp = readl((void const volatile   *)dev->catas_err.map);
#line 221
  tmp___0 = __fswab32(tmp);
#line 221
  switch (tmp___0 >> 24) {
  case 0: 
#line 223
  type = "internal error";
#line 224
  goto ldv_23675;
  case 3: 
#line 226
  type = "uplink bus error";
#line 227
  goto ldv_23675;
  case 4: 
#line 229
  type = "DDR data error";
#line 230
  goto ldv_23675;
  case 5: 
#line 232
  type = "internal parity error";
#line 233
  goto ldv_23675;
  default: 
#line 235
  type = "unknown error";
#line 236
  goto ldv_23675;
  }
  ldv_23675: 
#line 239
  dev_err((struct device  const  *)(& (dev->pdev)->dev), "Catastrophic error detected: %s\n",
          type);
#line 240
  i = 0;
#line 240
  goto ldv_23681;
  ldv_23680: 
#line 241
  tmp___1 = readl((void const volatile   *)dev->catas_err.map + (unsigned long )i);
#line 241
  tmp___2 = __fswab32(tmp___1);
#line 241
  dev_err((struct device  const  *)(& (dev->pdev)->dev), "  buf[%02x]: %08x\n", i,
          tmp___2);
#line 240
  i = i + 1;
  ldv_23681: ;
#line 240
  if ((u32 )i < dev->catas_err.size) {
#line 241
    goto ldv_23680;
  } else {
#line 243
    goto ldv_23682;
  }
  ldv_23682: ;
#line 244
  if (catas_reset_disable != 0) {
#line 245
    return;
  } else {

  }
#line 247
  tmp___3 = spinlock_check(& catas_lock);
#line 247
  flags = _raw_spin_lock_irqsave(tmp___3);
#line 248
  list_add(& dev->catas_err.list, & catas_list);
#line 249
  queue_work(catas_wq, & catas_work);
#line 250
  spin_unlock_irqrestore(& catas_lock, flags);
#line 251
  return;
}
}
#line 253 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
static void poll_catas(unsigned long dev_ptr ) 
{ struct mthca_dev *dev ;
  int i ;
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 255
  dev = (struct mthca_dev *)dev_ptr;
#line 258
  i = 0;
#line 258
  goto ldv_23692;
  ldv_23691: 
#line 259
  tmp = readl((void const volatile   *)dev->catas_err.map + (unsigned long )i);
#line 259
  if (tmp != 0U) {
#line 260
    handle_catas(dev);
#line 261
    return;
  } else {

  }
#line 258
  i = i + 1;
  ldv_23692: ;
#line 258
  if ((u32 )i < dev->catas_err.size) {
#line 259
    goto ldv_23691;
  } else {
#line 261
    goto ldv_23693;
  }
  ldv_23693: 
#line 264
  tmp___0 = round_jiffies((unsigned long )jiffies + 1250UL);
#line 264
  mod_timer(& dev->catas_err.timer, tmp___0);
#line 266
  return;
}
}
#line 268 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void mthca_start_catas_poll(struct mthca_dev *dev ) 
{ phys_addr_t addr ;
  struct lock_class_key __key ;
  unsigned long long tmp ;
  void *tmp___0 ;

  {
#line 272
  init_timer_key(& dev->catas_err.timer, 0U, "(&dev->catas_err.timer)", & __key);
#line 273
  dev->catas_err.map = 0;
#line 275
  if ((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start) {
#line 275
    tmp = (dev->pdev)->resource[0].end - (dev->pdev)->resource[0].start;
  } else {
#line 275
    tmp = 0xffffffffffffffffULL;
  }
#line 275
  addr = (dev->pdev)->resource[0].start + (tmp & dev->catas_err.addr);
#line 279
  tmp___0 = ioremap(addr, (unsigned long )(dev->catas_err.size * 4U));
#line 279
  dev->catas_err.map = (u32 *)tmp___0;
#line 280
  if ((unsigned long )dev->catas_err.map == (unsigned long )((u32 *)0)) {
#line 281
    dev_warn((struct device  const  *)(& (dev->pdev)->dev), "couldn\'t map catastrophic error region at 0x%llx/0x%x\n",
             addr, dev->catas_err.size * 4U);
#line 284
    return;
  } else {

  }
#line 287
  dev->catas_err.timer.data = (unsigned long )dev;
#line 288
  dev->catas_err.timer.function = & poll_catas;
#line 289
  dev->catas_err.timer.expires = (unsigned long )jiffies + 1250UL;
#line 290
  INIT_LIST_HEAD(& dev->catas_err.list);
#line 291
  add_timer(& dev->catas_err.timer);
#line 292
  return;
}
}
#line 294 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void mthca_stop_catas_poll(struct mthca_dev *dev ) 
{ 

  {
#line 296
  del_timer_sync(& dev->catas_err.timer);
#line 298
  if ((unsigned long )dev->catas_err.map != (unsigned long )((u32 *)0)) {
#line 299
    iounmap((void volatile   *)dev->catas_err.map);
  } else {

  }
#line 301
  spin_lock_irq(& catas_lock);
#line 302
  list_del(& dev->catas_err.list);
#line 303
  spin_unlock_irq(& catas_lock);
#line 304
  return;
}
}
#line 306 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
int mthca_catas_init(void) 
{ struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 308
  __init_work(& catas_work, 0);
#line 308
  __constr_expr_0.counter = 4195328L;
#line 308
  catas_work.data = __constr_expr_0;
#line 308
  lockdep_init_map(& catas_work.lockdep_map, "(&catas_work)", & __key, 0);
#line 308
  INIT_LIST_HEAD(& catas_work.entry);
#line 308
  catas_work.func = & catas_reset;
#line 310
  __lock_name = "mthca_catas";
#line 310
  tmp = __alloc_workqueue_key("mthca_catas", 10U, 1, & __key___0, __lock_name);
#line 310
  catas_wq = tmp;
#line 311
  if ((unsigned long )catas_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 312
    return (-12);
  } else {

  }
#line 314
  return (0);
}
}
#line 317 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void mthca_catas_cleanup(void) 
{ 

  {
#line 319
  destroy_workqueue(catas_wq);
#line 320
  return;
}
}
#line 322 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 327
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 329
  mutex_lock(ldv_func_arg1);
#line 330
  return;
}
}
#line 332 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 337
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 339
  mutex_unlock(ldv_func_arg1);
#line 340
  return;
}
}
#line 342 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 347
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 349
  mutex_lock(ldv_func_arg1);
#line 350
  return;
}
}
#line 352 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
int ldv_mutex_trylock_276(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 357
  tmp = mutex_trylock(ldv_func_arg1);
#line 357
  ldv_func_res = tmp;
#line 359
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 359
  return (tmp___0);
#line 361
  return (ldv_func_res);
}
}
#line 364 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 369
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 371
  mutex_unlock(ldv_func_arg1);
#line 372
  return;
}
}
#line 374 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 379
  ldv_mutex_lock_mthca_device_mutex(ldv_func_arg1);
#line 381
  mutex_lock(ldv_func_arg1);
#line 382
  return;
}
}
#line 384 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/infiniband/hw/mthca/mthca_catas.c.prepared"
void ldv_mutex_unlock_279(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 389
  ldv_mutex_unlock_mthca_device_mutex(ldv_func_arg1);
#line 391
  mutex_unlock(ldv_func_arg1);
#line 392
  return;
}
}
#line 10 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 

  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 

  {
#line 51
  return (exp);
}
}
#line 59 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 

  {
#line 61
  ldv_error();
#line 62
  return;
}
}
#line 8 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cap_mask_mutex_of_mthca_dev  ;
#line 11 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 16
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_cap_mask_mutex_of_mthca_dev = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 42
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_cap_mask_mutex_of_mthca_dev = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ 

  {
#line 66
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_cap_mask_mutex_of_mthca_dev = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_cap_mask_mutex_of_mthca_dev = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cap_mask_mutex_of_mthca_dev(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_cap_mask_mutex_of_mthca_dev = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 127
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cap_mask_mutex_of_mthca_dev(struct mutex *lock ) 
{ 

  {
#line 155
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_cap_mask_mutex_of_mthca_dev = 1;
#line 158
  return;
}
}
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex_of_signal_struct  ;
#line 163 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 168
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 194
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 218
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 221
  return;
}
}
#line 224 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex_of_signal_struct(atomic_t *cnt ,
                                                                    struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 279
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 307
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 310
  return;
}
}
#line 312 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_hcr_mutex_of_mthca_cmd  ;
#line 315 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 320
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_hcr_mutex_of_mthca_cmd = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 346
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_hcr_mutex_of_mthca_cmd = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ 

  {
#line 370
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_hcr_mutex_of_mthca_cmd = 2;
#line 373
  return;
}
}
#line 376 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_hcr_mutex_of_mthca_cmd = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_hcr_mutex_of_mthca_cmd(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_hcr_mutex_of_mthca_cmd = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 431
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_hcr_mutex_of_mthca_cmd(struct mutex *lock ) 
{ 

  {
#line 459
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_hcr_mutex_of_mthca_cmd = 1;
#line 462
  return;
}
}
#line 464 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 472
  if (ldv_mutex_lock == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_lock = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 498
  if (ldv_mutex_lock == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_lock = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 

  {
#line 522
  if (ldv_mutex_lock == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_lock = 2;
#line 525
  return;
}
}
#line 528 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_lock == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_lock = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_lock == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_lock = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 583
  if (ldv_mutex_lock == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 

  {
#line 611
  if (ldv_mutex_lock == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_lock = 1;
#line 614
  return;
}
}
#line 616 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mthca_device_mutex  ;
#line 619 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mthca_device_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 624
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_mthca_device_mutex = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mthca_device_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 650
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_mthca_device_mutex = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mthca_device_mutex(struct mutex *lock ) 
{ 

  {
#line 674
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_mthca_device_mutex = 2;
#line 677
  return;
}
}
#line 680 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mthca_device_mutex(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_mthca_device_mutex = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mthca_device_mutex(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_mthca_device_mutex = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mthca_device_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 735
  if (ldv_mutex_mthca_device_mutex == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mthca_device_mutex(struct mutex *lock ) 
{ 

  {
#line 763
  if (ldv_mutex_mthca_device_mutex == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_mthca_device_mutex = 1;
#line 766
  return;
}
}
#line 768 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  ;
#line 771 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 776
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_mutex_of_device = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 802
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_mutex_of_device = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 826
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_mutex_of_device = 2;
#line 829
  return;
}
}
#line 832 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_mutex_of_device = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_mutex_of_device = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 887
  if (ldv_mutex_mutex_of_device == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 915
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_mutex_of_device = 1;
#line 918
  return;
}
}
#line 920 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_cq  ;
#line 923 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_cq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 928
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 928
    ldv_error();
  }
#line 931
  nondetermined = __VERIFIER_nondet_int();
#line 934
  if (nondetermined) {
#line 937
    ldv_mutex_mutex_of_mthca_cq = 2;
#line 939
    return (0);
  } else {
#line 944
    return (-4);
  }
}
}
#line 949 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_cq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 954
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 954
    ldv_error();
  }
#line 957
  nondetermined = __VERIFIER_nondet_int();
#line 960
  if (nondetermined) {
#line 963
    ldv_mutex_mutex_of_mthca_cq = 2;
#line 965
    return (0);
  } else {
#line 970
    return (-4);
  }
}
}
#line 975 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_cq(struct mutex *lock ) 
{ 

  {
#line 978
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 978
    ldv_error();
  }
#line 980
  ldv_mutex_mutex_of_mthca_cq = 2;
#line 981
  return;
}
}
#line 984 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_cq(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 989
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 989
    ldv_error();
  }
#line 992
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 995
  if (is_mutex_held_by_another_thread) {
#line 998
    return (0);
  } else {
#line 1003
    ldv_mutex_mutex_of_mthca_cq = 2;
#line 1005
    return (1);
  }
}
}
#line 1010 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_cq(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1015
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 1015
    ldv_error();
  }
#line 1018
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1021
  if (atomic_value_after_dec == 0) {
#line 1024
    ldv_mutex_mutex_of_mthca_cq = 2;
#line 1026
    return (1);
  } else {

  }
#line 1030
  return (0);
}
}
#line 1035 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_cq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1039
  if (ldv_mutex_mutex_of_mthca_cq == 1) {
#line 1042
    nondetermined = __VERIFIER_nondet_int();
#line 1045
    if (nondetermined) {
#line 1048
      return (0);
    } else {
#line 1053
      return (1);
    }
  } else {
#line 1059
    return (1);
  }
}
}
#line 1064 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_cq(struct mutex *lock ) 
{ 

  {
#line 1067
  if (ldv_mutex_mutex_of_mthca_cq == 2) {

  } else {
#line 1067
    ldv_error();
  }
#line 1069
  ldv_mutex_mutex_of_mthca_cq = 1;
#line 1070
  return;
}
}
#line 1072 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_db_table  ;
#line 1075 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1080
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 1080
    ldv_error();
  }
#line 1083
  nondetermined = __VERIFIER_nondet_int();
#line 1086
  if (nondetermined) {
#line 1089
    ldv_mutex_mutex_of_mthca_db_table = 2;
#line 1091
    return (0);
  } else {
#line 1096
    return (-4);
  }
}
}
#line 1101 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1106
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 1106
    ldv_error();
  }
#line 1109
  nondetermined = __VERIFIER_nondet_int();
#line 1112
  if (nondetermined) {
#line 1115
    ldv_mutex_mutex_of_mthca_db_table = 2;
#line 1117
    return (0);
  } else {
#line 1122
    return (-4);
  }
}
}
#line 1127 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_db_table(struct mutex *lock ) 
{ 

  {
#line 1130
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 1130
    ldv_error();
  }
#line 1132
  ldv_mutex_mutex_of_mthca_db_table = 2;
#line 1133
  return;
}
}
#line 1136 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_db_table(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1141
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 1141
    ldv_error();
  }
#line 1144
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1147
  if (is_mutex_held_by_another_thread) {
#line 1150
    return (0);
  } else {
#line 1155
    ldv_mutex_mutex_of_mthca_db_table = 2;
#line 1157
    return (1);
  }
}
}
#line 1162 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_db_table(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1167
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 1167
    ldv_error();
  }
#line 1170
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1173
  if (atomic_value_after_dec == 0) {
#line 1176
    ldv_mutex_mutex_of_mthca_db_table = 2;
#line 1178
    return (1);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1187 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1191
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {
#line 1194
    nondetermined = __VERIFIER_nondet_int();
#line 1197
    if (nondetermined) {
#line 1200
      return (0);
    } else {
#line 1205
      return (1);
    }
  } else {
#line 1211
    return (1);
  }
}
}
#line 1216 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_db_table(struct mutex *lock ) 
{ 

  {
#line 1219
  if (ldv_mutex_mutex_of_mthca_db_table == 2) {

  } else {
#line 1219
    ldv_error();
  }
#line 1221
  ldv_mutex_mutex_of_mthca_db_table = 1;
#line 1222
  return;
}
}
#line 1224 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_icm_table  ;
#line 1227 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1232
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 1232
    ldv_error();
  }
#line 1235
  nondetermined = __VERIFIER_nondet_int();
#line 1238
  if (nondetermined) {
#line 1241
    ldv_mutex_mutex_of_mthca_icm_table = 2;
#line 1243
    return (0);
  } else {
#line 1248
    return (-4);
  }
}
}
#line 1253 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1258
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 1258
    ldv_error();
  }
#line 1261
  nondetermined = __VERIFIER_nondet_int();
#line 1264
  if (nondetermined) {
#line 1267
    ldv_mutex_mutex_of_mthca_icm_table = 2;
#line 1269
    return (0);
  } else {
#line 1274
    return (-4);
  }
}
}
#line 1279 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ 

  {
#line 1282
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 1282
    ldv_error();
  }
#line 1284
  ldv_mutex_mutex_of_mthca_icm_table = 2;
#line 1285
  return;
}
}
#line 1288 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1293
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 1293
    ldv_error();
  }
#line 1296
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1299
  if (is_mutex_held_by_another_thread) {
#line 1302
    return (0);
  } else {
#line 1307
    ldv_mutex_mutex_of_mthca_icm_table = 2;
#line 1309
    return (1);
  }
}
}
#line 1314 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_icm_table(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1319
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 1319
    ldv_error();
  }
#line 1322
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1325
  if (atomic_value_after_dec == 0) {
#line 1328
    ldv_mutex_mutex_of_mthca_icm_table = 2;
#line 1330
    return (1);
  } else {

  }
#line 1334
  return (0);
}
}
#line 1339 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1343
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {
#line 1346
    nondetermined = __VERIFIER_nondet_int();
#line 1349
    if (nondetermined) {
#line 1352
      return (0);
    } else {
#line 1357
      return (1);
    }
  } else {
#line 1363
    return (1);
  }
}
}
#line 1368 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_icm_table(struct mutex *lock ) 
{ 

  {
#line 1371
  if (ldv_mutex_mutex_of_mthca_icm_table == 2) {

  } else {
#line 1371
    ldv_error();
  }
#line 1373
  ldv_mutex_mutex_of_mthca_icm_table = 1;
#line 1374
  return;
}
}
#line 1376 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_mcg_table  ;
#line 1379 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1384
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 1384
    ldv_error();
  }
#line 1387
  nondetermined = __VERIFIER_nondet_int();
#line 1390
  if (nondetermined) {
#line 1393
    ldv_mutex_mutex_of_mthca_mcg_table = 2;
#line 1395
    return (0);
  } else {
#line 1400
    return (-4);
  }
}
}
#line 1405 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1410
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 1410
    ldv_error();
  }
#line 1413
  nondetermined = __VERIFIER_nondet_int();
#line 1416
  if (nondetermined) {
#line 1419
    ldv_mutex_mutex_of_mthca_mcg_table = 2;
#line 1421
    return (0);
  } else {
#line 1426
    return (-4);
  }
}
}
#line 1431 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ 

  {
#line 1434
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 1434
    ldv_error();
  }
#line 1436
  ldv_mutex_mutex_of_mthca_mcg_table = 2;
#line 1437
  return;
}
}
#line 1440 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1445
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 1445
    ldv_error();
  }
#line 1448
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1451
  if (is_mutex_held_by_another_thread) {
#line 1454
    return (0);
  } else {
#line 1459
    ldv_mutex_mutex_of_mthca_mcg_table = 2;
#line 1461
    return (1);
  }
}
}
#line 1466 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_mcg_table(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1471
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 1471
    ldv_error();
  }
#line 1474
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1477
  if (atomic_value_after_dec == 0) {
#line 1480
    ldv_mutex_mutex_of_mthca_mcg_table = 2;
#line 1482
    return (1);
  } else {

  }
#line 1486
  return (0);
}
}
#line 1491 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1495
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {
#line 1498
    nondetermined = __VERIFIER_nondet_int();
#line 1501
    if (nondetermined) {
#line 1504
      return (0);
    } else {
#line 1509
      return (1);
    }
  } else {
#line 1515
    return (1);
  }
}
}
#line 1520 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_mcg_table(struct mutex *lock ) 
{ 

  {
#line 1523
  if (ldv_mutex_mutex_of_mthca_mcg_table == 2) {

  } else {
#line 1523
    ldv_error();
  }
#line 1525
  ldv_mutex_mutex_of_mthca_mcg_table = 1;
#line 1526
  return;
}
}
#line 1528 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_qp  ;
#line 1531 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_qp(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1536
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 1536
    ldv_error();
  }
#line 1539
  nondetermined = __VERIFIER_nondet_int();
#line 1542
  if (nondetermined) {
#line 1545
    ldv_mutex_mutex_of_mthca_qp = 2;
#line 1547
    return (0);
  } else {
#line 1552
    return (-4);
  }
}
}
#line 1557 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_qp(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1562
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 1562
    ldv_error();
  }
#line 1565
  nondetermined = __VERIFIER_nondet_int();
#line 1568
  if (nondetermined) {
#line 1571
    ldv_mutex_mutex_of_mthca_qp = 2;
#line 1573
    return (0);
  } else {
#line 1578
    return (-4);
  }
}
}
#line 1583 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_qp(struct mutex *lock ) 
{ 

  {
#line 1586
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 1586
    ldv_error();
  }
#line 1588
  ldv_mutex_mutex_of_mthca_qp = 2;
#line 1589
  return;
}
}
#line 1592 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_qp(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1597
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 1597
    ldv_error();
  }
#line 1600
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1603
  if (is_mutex_held_by_another_thread) {
#line 1606
    return (0);
  } else {
#line 1611
    ldv_mutex_mutex_of_mthca_qp = 2;
#line 1613
    return (1);
  }
}
}
#line 1618 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_qp(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1623
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 1623
    ldv_error();
  }
#line 1626
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1629
  if (atomic_value_after_dec == 0) {
#line 1632
    ldv_mutex_mutex_of_mthca_qp = 2;
#line 1634
    return (1);
  } else {

  }
#line 1638
  return (0);
}
}
#line 1643 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_qp(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1647
  if (ldv_mutex_mutex_of_mthca_qp == 1) {
#line 1650
    nondetermined = __VERIFIER_nondet_int();
#line 1653
    if (nondetermined) {
#line 1656
      return (0);
    } else {
#line 1661
      return (1);
    }
  } else {
#line 1667
    return (1);
  }
}
}
#line 1672 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_qp(struct mutex *lock ) 
{ 

  {
#line 1675
  if (ldv_mutex_mutex_of_mthca_qp == 2) {

  } else {
#line 1675
    ldv_error();
  }
#line 1677
  ldv_mutex_mutex_of_mthca_qp = 1;
#line 1678
  return;
}
}
#line 1680 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_srq  ;
#line 1683 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_srq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1688
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 1688
    ldv_error();
  }
#line 1691
  nondetermined = __VERIFIER_nondet_int();
#line 1694
  if (nondetermined) {
#line 1697
    ldv_mutex_mutex_of_mthca_srq = 2;
#line 1699
    return (0);
  } else {
#line 1704
    return (-4);
  }
}
}
#line 1709 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_srq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1714
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 1714
    ldv_error();
  }
#line 1717
  nondetermined = __VERIFIER_nondet_int();
#line 1720
  if (nondetermined) {
#line 1723
    ldv_mutex_mutex_of_mthca_srq = 2;
#line 1725
    return (0);
  } else {
#line 1730
    return (-4);
  }
}
}
#line 1735 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_srq(struct mutex *lock ) 
{ 

  {
#line 1738
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 1738
    ldv_error();
  }
#line 1740
  ldv_mutex_mutex_of_mthca_srq = 2;
#line 1741
  return;
}
}
#line 1744 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_srq(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1749
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 1749
    ldv_error();
  }
#line 1752
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1755
  if (is_mutex_held_by_another_thread) {
#line 1758
    return (0);
  } else {
#line 1763
    ldv_mutex_mutex_of_mthca_srq = 2;
#line 1765
    return (1);
  }
}
}
#line 1770 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_srq(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1775
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 1775
    ldv_error();
  }
#line 1778
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1781
  if (atomic_value_after_dec == 0) {
#line 1784
    ldv_mutex_mutex_of_mthca_srq = 2;
#line 1786
    return (1);
  } else {

  }
#line 1790
  return (0);
}
}
#line 1795 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_srq(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1799
  if (ldv_mutex_mutex_of_mthca_srq == 1) {
#line 1802
    nondetermined = __VERIFIER_nondet_int();
#line 1805
    if (nondetermined) {
#line 1808
      return (0);
    } else {
#line 1813
      return (1);
    }
  } else {
#line 1819
    return (1);
  }
}
}
#line 1824 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_srq(struct mutex *lock ) 
{ 

  {
#line 1827
  if (ldv_mutex_mutex_of_mthca_srq == 2) {

  } else {
#line 1827
    ldv_error();
  }
#line 1829
  ldv_mutex_mutex_of_mthca_srq = 1;
#line 1830
  return;
}
}
#line 1832 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_mthca_user_db_table  ;
#line 1835 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1840
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 1840
    ldv_error();
  }
#line 1843
  nondetermined = __VERIFIER_nondet_int();
#line 1846
  if (nondetermined) {
#line 1849
    ldv_mutex_mutex_of_mthca_user_db_table = 2;
#line 1851
    return (0);
  } else {
#line 1856
    return (-4);
  }
}
}
#line 1861 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1866
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 1866
    ldv_error();
  }
#line 1869
  nondetermined = __VERIFIER_nondet_int();
#line 1872
  if (nondetermined) {
#line 1875
    ldv_mutex_mutex_of_mthca_user_db_table = 2;
#line 1877
    return (0);
  } else {
#line 1882
    return (-4);
  }
}
}
#line 1887 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ 

  {
#line 1890
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 1890
    ldv_error();
  }
#line 1892
  ldv_mutex_mutex_of_mthca_user_db_table = 2;
#line 1893
  return;
}
}
#line 1896 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1901
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 1901
    ldv_error();
  }
#line 1904
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1907
  if (is_mutex_held_by_another_thread) {
#line 1910
    return (0);
  } else {
#line 1915
    ldv_mutex_mutex_of_mthca_user_db_table = 2;
#line 1917
    return (1);
  }
}
}
#line 1922 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_mthca_user_db_table(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1927
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 1927
    ldv_error();
  }
#line 1930
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1933
  if (atomic_value_after_dec == 0) {
#line 1936
    ldv_mutex_mutex_of_mthca_user_db_table = 2;
#line 1938
    return (1);
  } else {

  }
#line 1942
  return (0);
}
}
#line 1947 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1951
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {
#line 1954
    nondetermined = __VERIFIER_nondet_int();
#line 1957
    if (nondetermined) {
#line 1960
      return (0);
    } else {
#line 1965
      return (1);
    }
  } else {
#line 1971
    return (1);
  }
}
}
#line 1976 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_mthca_user_db_table(struct mutex *lock ) 
{ 

  {
#line 1979
  if (ldv_mutex_mutex_of_mthca_user_db_table == 2) {

  } else {
#line 1979
    ldv_error();
  }
#line 1981
  ldv_mutex_mutex_of_mthca_user_db_table = 1;
#line 1982
  return;
}
}
#line 1986 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 

  {
#line 1989
  ldv_mutex_cap_mask_mutex_of_mthca_dev = 1;
#line 1991
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 1993
  ldv_mutex_hcr_mutex_of_mthca_cmd = 1;
#line 1995
  ldv_mutex_lock = 1;
#line 1997
  ldv_mutex_mthca_device_mutex = 1;
#line 1999
  ldv_mutex_mutex_of_device = 1;
#line 2001
  ldv_mutex_mutex_of_mthca_cq = 1;
#line 2003
  ldv_mutex_mutex_of_mthca_db_table = 1;
#line 2005
  ldv_mutex_mutex_of_mthca_icm_table = 1;
#line 2007
  ldv_mutex_mutex_of_mthca_mcg_table = 1;
#line 2009
  ldv_mutex_mutex_of_mthca_qp = 1;
#line 2011
  ldv_mutex_mutex_of_mthca_srq = 1;
#line 2013
  ldv_mutex_mutex_of_mthca_user_db_table = 1;
#line 2014
  return;
}
}
#line 2017 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/infiniband/hw/mthca/ib_mthca.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 

  {
#line 2020
  if (ldv_mutex_cap_mask_mutex_of_mthca_dev == 1) {

  } else {
#line 2020
    ldv_error();
  }
#line 2022
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 2022
    ldv_error();
  }
#line 2024
  if (ldv_mutex_hcr_mutex_of_mthca_cmd == 1) {

  } else {
#line 2024
    ldv_error();
  }
#line 2026
  if (ldv_mutex_lock == 1) {

  } else {
#line 2026
    ldv_error();
  }
#line 2028
  if (ldv_mutex_mthca_device_mutex == 1) {

  } else {
#line 2028
    ldv_error();
  }
#line 2030
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 2030
    ldv_error();
  }
#line 2032
  if (ldv_mutex_mutex_of_mthca_cq == 1) {

  } else {
#line 2032
    ldv_error();
  }
#line 2034
  if (ldv_mutex_mutex_of_mthca_db_table == 1) {

  } else {
#line 2034
    ldv_error();
  }
#line 2036
  if (ldv_mutex_mutex_of_mthca_icm_table == 1) {

  } else {
#line 2036
    ldv_error();
  }
#line 2038
  if (ldv_mutex_mutex_of_mthca_mcg_table == 1) {

  } else {
#line 2038
    ldv_error();
  }
#line 2040
  if (ldv_mutex_mutex_of_mthca_qp == 1) {

  } else {
#line 2040
    ldv_error();
  }
#line 2042
  if (ldv_mutex_mutex_of_mthca_srq == 1) {

  } else {
#line 2042
    ldv_error();
  }
#line 2044
  if (ldv_mutex_mutex_of_mthca_user_db_table == 1) {

  } else {
#line 2044
    ldv_error();
  }
#line 2045
  return;
}
}
