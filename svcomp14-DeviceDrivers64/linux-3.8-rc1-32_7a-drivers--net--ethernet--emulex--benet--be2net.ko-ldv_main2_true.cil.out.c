/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 88 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 90 "include/linux/types.h"
typedef unsigned short ushort;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 145 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 353 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 23 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2043_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2043_8 ldv_2043 ;
};
#line 27 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2050_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2050_10 ldv_2050 ;
};
#line 33 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 60 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2103_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2118_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2119_11 {
   struct __anonstruct_ldv_2103_12 ldv_2103 ;
   struct __anonstruct_ldv_2118_13 ldv_2118 ;
};
#line 59 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2119_11 ldv_2119 ;
};
#line 15 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 323
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 358 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 127 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2775_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2775_18 ldv_2775 ;
};
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 663 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 162 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5181_23 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5187_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5188_22 {
   struct __anonstruct_ldv_5181_23 ldv_5181 ;
   struct __anonstruct_ldv_5187_24 ldv_5187 ;
};
#line 311 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5197_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5188_22 ldv_5188 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5197_25 ldv_5197 ;
};
#line 345 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 377 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 383 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 391 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 438
struct kmem_cache;
#line 439
struct perf_event;
#line 440 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 579 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6013_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6014_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6013_29 ldv_6013 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6014_28 ldv_6014 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 66 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 133 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec;
#line 394 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 41 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 177 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_35 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 177 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_35 seqlock_t;
#line 270 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 770 "include/linux/mmzone.h"
struct rw_semaphore;
#line 771 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 144 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 222 "include/linux/rcupdate.h"
struct notifier_block;
#line 313 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 371
struct tvec_base;
#line 372 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 888 "include/linux/mmzone.h"
struct ctl_table;
#line 72 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 170 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 506 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 513
struct dev_pm_qos;
#line 513 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 570 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 135 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 83
struct vm_area_struct;
#line 335 "include/linux/clocksource.h"
struct device_node;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13290_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13292_128 {
   struct __anonstruct_ldv_13290_129 ldv_13290 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13292_128 ldv_13292 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
struct sock;
#line 49
struct kobject;
#line 50
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 56 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 198 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14084_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14084_134 ldv_14084 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 208 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 579
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 22 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 55 "include/linux/device.h"
struct device_attribute;
#line 55
struct driver_attribute;
#line 55 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 123
struct device_type;
#line 180 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 245 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 301
struct class_attribute;
#line 301 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 396 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 449 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 477 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 582 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 591 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 596
struct dma_coherent_mem;
#line 596 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 730 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 180 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 223
struct pcie_link_state;
#line 224
struct pci_vpd;
#line 225
struct pci_sriov;
#line 226
struct pci_ats;
#line 227
struct proc_dir_entry;
#line 227
struct pci_driver;
#line 227 "include/linux/pci.h"
union __anonunion_ldv_15834_138 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 227 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_15834_138 ldv_15834 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 420
struct pci_ops;
#line 420 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 511 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 532 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 545 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 555 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 585 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1093 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 1252 "include/linux/pci.h"
struct inode;
#line 42 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 60 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 67
struct return_instance;
#line 67
struct uprobe;
#line 67 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct return_instance *return_instances ;
   unsigned int depth ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 83 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 102 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 128
struct address_space;
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_16901_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_16911_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_16913_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_16911_144 ldv_16911 ;
   int units ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_16915_142 {
   union __anonunion_ldv_16913_143 ldv_16913 ;
   atomic_t _count ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_16916_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_16915_142 ldv_16915 ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_16917_139 {
   union __anonunion_ldv_16901_140 ldv_16901 ;
   union __anonunion_ldv_16916_141 ldv_16916 ;
};
#line 129 "include/linux/uprobes.h"
struct __anonstruct_ldv_16924_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 129
struct slab;
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_16928_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_16924_146 ldv_16924 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 129 "include/linux/uprobes.h"
union __anonunion_ldv_16933_147 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 129 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_16917_139 ldv_16917 ;
   union __anonunion_ldv_16928_145 ldv_16928 ;
   union __anonunion_ldv_16933_147 ldv_16933 ;
   unsigned long debug_flags ;
};
#line 168 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 220 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 220 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 220
struct anon_vma;
#line 220
struct vm_operations_struct;
#line 220
struct mempolicy;
#line 220 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 292 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 298 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 311 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 324
struct linux_binfmt;
#line 324
struct mmu_notifier_mm;
#line 324 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct file_ra_state;
#line 44
struct user_struct;
#line 45
struct writeback_control;
#line 162 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 186 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 1827
struct mem_cgroup;
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 64
struct memcg_cache_params;
#line 64
struct kmem_cache_node;
#line 64 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 305 "include/linux/slab.h"
struct __anonstruct_ldv_19908_151 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 305 "include/linux/slab.h"
union __anonunion_ldv_19909_150 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_19908_151 ldv_19908 ;
};
#line 305 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_19909_150 ldv_19909 ;
};
#line 34 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 342 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 178 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/fcntl.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 328
enum ldv_18407 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_18407 socket_state;
#line 54
struct poll_table_struct;
#line 55
struct pipe_inode_info;
#line 56
struct net;
#line 73
struct fasync_struct;
#line 73 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119
struct kiocb;
#line 120 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   void (*set_peek_off)(struct sock * , int  ) ;
};
#line 72 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 108 "include/net/checksum.h"
struct sk_buff;
#line 37 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1041 "include/linux/dmaengine.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 17 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 117 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 127 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 153
struct skb_frag_struct;
#line 153 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 154 "include/linux/skbuff.h"
struct __anonstruct_page_154 {
   struct page *p ;
};
#line 154 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_154 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 187 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
   ktime_t syststamp ;
};
#line 256 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 329 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 330
struct sec_path;
#line 330 "include/linux/skbuff.h"
struct __anonstruct_ldv_22908_156 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 330 "include/linux/skbuff.h"
union __anonunion_ldv_22909_155 {
   __wsum csum ;
   struct __anonstruct_ldv_22908_156 ldv_22908 ;
};
#line 330 "include/linux/skbuff.h"
union __anonunion_ldv_22949_157 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 330 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   ktime_t tstamp ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_22909_155 ldv_22909 ;
   __u32 priority ;
   unsigned char local_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct sk_buff *nfct_reasm ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 rxhash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_rxhash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   dma_cookie_t dma_cookie ;
   __u32 secmark ;
   union __anonunion_ldv_22949_157 ldv_22949 ;
   sk_buff_data_t inner_transport_header ;
   sk_buff_data_t inner_network_header ;
   sk_buff_data_t inner_mac_header ;
   sk_buff_data_t transport_header ;
   sk_buff_data_t network_header ;
   sk_buff_data_t mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 556
struct dst_entry;
#line 624
struct rtable;
#line 2920 "include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 35 "include/linux/if_ether.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 80 "include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 45 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 50
enum dev_pm_qos_req_type {
    DEV_PM_QOS_LATENCY = 1,
    DEV_PM_QOS_FLAGS = 2
} ;
#line 55 "include/linux/pm_qos.h"
union __anonunion_data_158 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 55 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_158 data ;
   struct device *dev ;
};
#line 64
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 70 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 83 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 88 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints latency ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *latency_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 440 "include/linux/rculist.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 43 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_159 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_159 sync_serial_settings;
#line 50 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_160 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_160 te1_settings;
#line 55 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_161 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_161 raw_hdlc_proto;
#line 65 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_162 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_162 fr_proto;
#line 69 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_163 {
   unsigned int dlci ;
};
#line 69 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_163 fr_proto_pvc;
#line 74 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_164 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_164 fr_proto_pvc_info;
#line 79 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_165 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_165 cisco_proto;
#line 95 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 150 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_166 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 150 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_166 ifs_ifsu ;
};
#line 168 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_167 {
   char ifrn_name[16U] ;
};
#line 168 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_168 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 168 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_167 ifr_ifrn ;
   union __anonunion_ifr_ifru_168 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_24608_171 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_24610_170 {
   struct __anonstruct_ldv_24608_171 ldv_24608 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_24610_170 ldv_24610 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_172 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_172 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 413 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 387
struct pid_namespace;
#line 387 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct kstatfs;
#line 59
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_25616_174 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_25616_174 ldv_25616 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 340 "include/linux/fs.h"
union __anonunion_arg_176 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_175 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_176 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_175 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_26050_177 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_26070_178 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_26086_179 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_26050_177 ldv_26050 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_26070_178 ldv_26070 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_26086_179 ldv_26086 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 728 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 736 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 759 "include/linux/fs.h"
union __anonunion_f_u_180 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 759 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_180 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 902
struct files_struct;
#line 902 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 903 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 908 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 925
struct nlm_lockowner;
#line 926 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_182 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_181 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_182 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_181 fl_u ;
};
#line 1012 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1218 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1234
struct file_system_type;
#line 1234
struct super_operations;
#line 1234
struct xattr_handler;
#line 1234
struct mtd_info;
#line 1234 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1471 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1510 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1547 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1590 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1803 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 44 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 24 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_183 {
   unsigned long sig[1U] ;
};
#line 24 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_183 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_186 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_187 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_188 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_189 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_190 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_191 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_184 {
   int _pad[28U] ;
   struct __anonstruct__kill_185 _kill ;
   struct __anonstruct__timer_186 _timer ;
   struct __anonstruct__rt_187 _rt ;
   struct __anonstruct__sigchld_188 _sigchld ;
   struct __anonstruct__sigfault_189 _sigfault ;
   struct __anonstruct__sigpoll_190 _sigpoll ;
   struct __anonstruct__sigsys_191 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_184 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 251 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 265 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_28661_194 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_28670_195 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_196 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_197 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_28661_194 ldv_28661 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_28670_195 ldv_28670 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_196 type_data ;
   union __anonunion_payload_197 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 344
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 334 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 381 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 389 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 396 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 408 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 428 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 464
struct autogroup;
#line 465
struct tty_struct;
#line 465
struct taskstats;
#line 465
struct tty_audit_buf;
#line 465 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 644 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 688
struct reclaim_state;
#line 689 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 704 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 915
struct uts_namespace;
#line 916 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 923 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 935 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 970 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1006
struct rt_rq;
#line 1006 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1030 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1407
struct sched_class;
#line 1407
struct css_set;
#line 1407
struct compat_robust_list_head;
#line 1407 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 39 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 272 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 677 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 65 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 105 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 120 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 128 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 137 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 166 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 183 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 281 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 303 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 331 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 382 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 425 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 458 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 474 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 494 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 505 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 524 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 550 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 684 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 692 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 768 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh_indir)(struct net_device * , u32 * ) ;
   int (*set_rxfh_indir)(struct net_device * , u32 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 249
struct prot_inuse;
#line 250 "include/linux/ethtool.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 138 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[32U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[95U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[28U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[1U] ;
   struct ipstats_mib *ip_statistics[1U] ;
   struct linux_mib *net_statistics[1U] ;
   struct udp_mib *udp_statistics[1U] ;
   struct udp_mib *udplite_statistics[1U] ;
   struct icmp_mib *icmp_statistics[1U] ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[1U] ;
   struct udp_mib *udplite_stats_in6[1U] ;
   struct ipstats_mib *ipv6_statistics[1U] ;
   struct icmpv6_mib *icmpv6_statistics[1U] ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics[1U] ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 176 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 177
struct ipv4_devconf;
#line 178
struct fib_rules_ops;
#line 179
struct fib_table;
#line 180
struct inet_peer_base;
#line 180
struct xt_table;
#line 180 "include/net/inet_frag.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   int sysctl_tcp_ecn ;
   kgid_t sysctl_ping_group_range[2U] ;
   long sysctl_tcp_mem[3U] ;
   atomic_t dev_addr_genid ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
};
#line 80 "include/net/netns/ipv4.h"
struct neighbour;
#line 80 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int icmpv6_time ;
};
#line 32 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 32
struct rt6_info;
#line 32
struct rt6_statistics;
#line 32
struct fib6_table;
#line 32 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
};
#line 76 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 82
struct sctp_mib;
#line 83 "include/net/netns/ipv6.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics[1U] ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 104 "include/linux/in.h"
union __anonunion_in6_u_215 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 104 "include/linux/in.h"
struct in6_addr {
   union __anonunion_in6_u_215 in6_u ;
};
#line 321 "include/linux/netfilter.h"
struct nlattr;
#line 336
struct nf_logger;
#line 337 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 18 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 18 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 23 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 28 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 42 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 47 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 52 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 63
struct ip_conntrack_stat;
#line 63
struct nf_ct_event_notifier;
#line 63
struct nf_exp_event_notifier;
#line 63 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   int sysctl_events ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_acct ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int sysctl_log_invalid ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
};
#line 489 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   wait_queue_head_t km_waitq ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
};
#line 62
struct net_generic;
#line 63
struct netns_ipvs;
#line 64 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t rt_genid ;
};
#line 122 "include/net/net_namespace.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 342 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 200 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 41 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 103 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "include/linux/prio_heap.h"
struct idr_layer {
   int prefix ;
   unsigned long bitmap[4U] ;
   struct idr_layer *ary[256U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 38 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   int cur ;
   spinlock_t lock ;
};
#line 197 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 213 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 245 "include/linux/idr.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct cgroupfs_root;
#line 99
struct cgroup_subsys;
#line 100
struct cgroup;
#line 101
struct css_id;
#line 102
struct eventfd_ctx;
#line 62 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
#line 150 "include/linux/cgroup.h"
struct cgroup_name {
   struct callback_head callback_head ;
   char name[] ;
};
#line 168 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   int id ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_name *name ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct callback_head callback_head ;
   struct work_struct free_work ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
#line 249 "include/linux/cgroup.h"
struct cgroupfs_root {
   struct super_block *sb ;
   unsigned long subsys_mask ;
   int hierarchy_id ;
   unsigned long actual_subsys_mask ;
   struct list_head subsys_list ;
   struct cgroup top_cgroup ;
   int number_of_cgroups ;
   struct list_head root_list ;
   struct list_head allcg_list ;
   unsigned long flags ;
   struct ida cgroup_ida ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 333 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 377 "include/linux/cgroup.h"
struct cgroup_map_cb {
   int (*fill)(struct cgroup_map_cb * , char const   * , u64  ) ;
   void *state ;
};
#line 387 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   int (*open)(struct inode * , struct file * ) ;
   ssize_t (*read)(struct cgroup * , struct cftype * , struct file * , char * , size_t  ,
                   loff_t * ) ;
   u64 (*read_u64)(struct cgroup * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup * , struct cftype * ) ;
   int (*read_map)(struct cgroup * , struct cftype * , struct cgroup_map_cb * ) ;
   int (*read_seq_string)(struct cgroup * , struct cftype * , struct seq_file * ) ;
   ssize_t (*write)(struct cgroup * , struct cftype * , struct file * , char const   * ,
                    size_t  , loff_t * ) ;
   int (*write_u64)(struct cgroup * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup * , struct cftype * , s64  ) ;
   int (*write_string)(struct cgroup * , struct cftype * , char const   * ) ;
   int (*trigger)(struct cgroup * , unsigned int  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*register_event)(struct cgroup * , struct cftype * , struct eventfd_ctx * ,
                         char const   * ) ;
   void (*unregister_event)(struct cgroup * , struct cftype * , struct eventfd_ctx * ) ;
};
#line 502 "include/linux/cgroup.h"
struct cftype_set {
   struct list_head node ;
   struct cftype *cfts ;
};
#line 547
struct cgroup_taskset;
#line 557 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup * ) ;
   int (*css_online)(struct cgroup * ) ;
   void (*css_offline)(struct cgroup * ) ;
   void (*css_free)(struct cgroup * ) ;
   int (*can_attach)(struct cgroup * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup * , struct cgroup * , struct task_struct * ) ;
   void (*bind)(struct cgroup * ) ;
   int subsys_id ;
   int disabled ;
   int early_init ;
   bool use_id ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   char const   *name ;
   struct cgroupfs_root *root ;
   struct list_head sibling ;
   struct idr idr ;
   spinlock_t id_lock ;
   struct list_head cftsets ;
   struct cftype *base_cftypes ;
   struct cftype_set base_cftset ;
   struct module *module ;
};
#line 178 "include/linux/hardirq.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 99 "include/linux/security.h"
struct xfrm_policy;
#line 100
struct xfrm_state;
#line 120
struct request_sock;
#line 3091
struct mnt_namespace;
#line 3092
struct ipc_namespace;
#line 3093 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 86 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 146 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 449 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 tx_rate ;
   __u32 spoofchk ;
};
#line 26 "include/linux/if_link.h"
struct netpoll_info;
#line 27
struct phy_device;
#line 28
struct wireless_dev;
#line 64 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 116 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 135 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 196
struct neigh_parms;
#line 197 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 217 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 222 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 251 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 302 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
};
#line 334
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 342 "include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 343
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 391 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 392 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 502
struct Qdisc;
#line 502 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 564 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 576 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 588 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 639 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 649 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 662 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 673 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 684 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 700 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * , gfp_t  ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
};
#line 1042
struct iw_handler_def;
#line 1042
struct iw_public_data;
#line 1042
struct vlan_info;
#line 1042
struct in_device;
#line 1042
struct dn_dev;
#line 1042
struct inet6_dev;
#line 1042
struct cpu_rmap;
#line 1042
struct pcpu_lstats;
#line 1042
struct pcpu_tstats;
#line 1042
struct pcpu_dstats;
#line 1042
struct pcpu_vstats;
#line 1042 "include/linux/netdevice.h"
union __anonunion_ldv_38702_226 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_tstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1042
struct garp_port;
#line 1042
struct mrp_port;
#line 1042
struct rtnl_link_ops;
#line 1042 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head upper_dev_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned char neigh_priv_len ;
   unsigned short dev_id ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_38702_226 ldv_38702 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 564 "include/linux/memcontrol.h"
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
#line 226 "include/linux/res_counter.h"
struct kioctx;
#line 30 "include/linux/aio.h"
typedef int kiocb_cancel_fn(struct kiocb * , struct io_event * );
#line 31 "include/linux/aio.h"
union __anonunion_ki_obj_227 {
   void *user ;
   struct task_struct *tsk ;
};
#line 31 "include/linux/aio.h"
struct kiocb {
   atomic_t ki_users ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_227 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 115 "include/linux/aio.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 19 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   unsigned int len ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct sock_filter  const  * ) ;
   struct callback_head rcu ;
   struct sock_filter insns[0U] ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 103 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 27 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
};
#line 133
struct neigh_table;
#line 133 "include/net/rtnetlink.h"
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int base_reachable_time ;
   int retrans_time ;
   int gc_staletime ;
   int reachable_time ;
   int delay_probe_time ;
   int queue_len_bytes ;
   int ucast_probes ;
   int app_probes ;
   int mcast_probes ;
   int anycast_delay ;
   int proxy_delay ;
   int proxy_qlen ;
   int locktime ;
};
#line 71 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 90
struct neigh_ops;
#line 90 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 119 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 127 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 137 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 150 "include/net/neighbour.h"
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 409
struct dn_route;
#line 409 "include/net/neighbour.h"
union __anonunion_ldv_41928_232 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 409 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_ldv_41928_232 ldv_41928 ;
};
#line 123 "include/net/sock.h"
struct __anonstruct_socket_lock_t_233 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 123 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_233 socket_lock_t;
#line 123
struct proto;
#line 129 "include/net/sock.h"
typedef __u32 __portpair;
#line 130 "include/net/sock.h"
typedef __u64 __addrpair;
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_42147_235 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_42148_234 {
   __addrpair skc_addrpair ;
   struct __anonstruct_ldv_42147_235 ldv_42147 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_42152_236 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 131 "include/net/sock.h"
struct __anonstruct_ldv_42158_238 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_42159_237 {
   __portpair skc_portpair ;
   struct __anonstruct_ldv_42158_238 ldv_42158 ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_42168_239 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 131 "include/net/sock.h"
union __anonunion_ldv_42175_240 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 131 "include/net/sock.h"
struct sock_common {
   union __anonunion_ldv_42148_234 ldv_42148 ;
   union __anonunion_ldv_42152_236 ldv_42152 ;
   union __anonunion_ldv_42159_237 ldv_42159 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion_ldv_42168_239 ldv_42168 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_ldv_42175_240 ldv_42175 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 210
struct cg_proto;
#line 211 "include/net/sock.h"
struct __anonstruct_sk_backlog_241 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 211 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_241 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct sk_buff_head sk_async_wait_queue ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check : 2 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * , int  ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 862
struct request_sock_ops;
#line 863
struct timewait_sock_ops;
#line 864
struct inet_hashinfo;
#line 865
struct raw_hashinfo;
#line 866
struct udp_table;
#line 866 "include/net/sock.h"
union __anonunion_h_242 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 866 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  , int  ,
                  int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_242 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 992 "include/net/sock.h"
struct cg_proto {
   void (*enter_memory_pressure)(struct sock * ) ;
   struct res_counter *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 8 "include/linux/unaligned/packed_struct.h"
struct __una_u32 {
   u32 x ;
};
#line 169 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
#line 47 "include/net/request_sock.h"
struct request_sock {
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
#line 375 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 693 "include/linux/interrupt.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 48 "include/uapi/linux/ipv6.h"
struct ipv6_opt_hdr {
   __u8 nexthdr ;
   __u8 hdrlen ;
};
#line 102 "include/uapi/linux/ipv6.h"
struct ipv6hdr {
   unsigned char priority : 4 ;
   unsigned char version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 163 "include/uapi/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   void *sysctl ;
};
#line 99 "include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 108 "include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 140 "include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 152 "include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6[1U] ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163 "include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct inet6_dev *next ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 863 "include/net/ipv6.h"
union __anonunion_ldv_46762_256 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
#line 863 "include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_ldv_46762_256 ldv_46762 ;
};
#line 24 "include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_46777_257 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 29 "include/net/inetpeer.h"
struct __anonstruct_ldv_46782_259 {
   atomic_t rid ;
   atomic_t ip_id_count ;
};
#line 29 "include/net/inetpeer.h"
union __anonunion_ldv_46785_258 {
   struct __anonstruct_ldv_46782_259 ldv_46782 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 29 "include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[14U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_ldv_46777_257 ldv_46777 ;
   union __anonunion_ldv_46785_258 ldv_46785 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
#line 50 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
#line 319 "include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
   struct hlist_nulls_head twchain ;
};
#line 96 "include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 104 "include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 116 "include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
   atomic_t bsockets ;
};
#line 42 "include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 381 "include/linux/if_vlan.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 52 "include/linux/firmware.h"
struct be_eq_entry {
   u32 evt ;
};
#line 268 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_wrb {
   u32 frag_pa_hi ;
   u32 frag_pa_lo ;
   u32 rsvd0 ;
   u32 frag_len ;
};
#line 301 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_hdr_wrb {
   u32 dw[4U] ;
};
#line 328 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_tx_compl {
   u32 dw[4U] ;
};
#line 332 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_d {
   u32 fragpa_hi ;
   u32 fragpa_lo ;
};
#line 409 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_compl {
   u32 dw[4U] ;
};
#line 467 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_comp {
   unsigned long offset ;
   int optype ;
   int size ;
   int img_type ;
};
#line 474 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct image_hdr {
   u32 imageid ;
   u32 imageoffset ;
   u32 imagelength ;
   u32 image_checksum ;
   u8 image_version[32U] ;
};
#line 493 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_file_hdr_g3 {
   u8 sign[52U] ;
   u8 ufi_version[4U] ;
   u32 file_len ;
   u32 cksum ;
   u32 antidote ;
   u32 num_imgs ;
   u8 build[24U] ;
   u8 asic_type_rev ;
   u8 rsvd[31U] ;
};
#line 505 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 num_images ;
   u8 id_string[128U] ;
   u32 rsvd[4U] ;
};
#line 514 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr_g2 {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 build_num ;
   u8 id_string[128U] ;
   u32 rsvd[8U] ;
};
#line 523 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_entry {
   u32 type ;
   u32 offset ;
   u32 pad_size ;
   u32 image_size ;
   u32 cksum ;
   u32 entry_point ;
   u32 rsvd0 ;
   u32 rsvd1 ;
   u8 ver_data[32U] ;
};
#line 535 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info {
   u8 cookie[32U] ;
   struct flash_section_hdr fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 541 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info_g2 {
   u8 cookie[32U] ;
   struct flash_section_hdr_g2 fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 547
struct ocrdma_dev;
#line 81 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 123 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 179
struct be_adapter;
#line 179 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_eq_obj {
   struct be_queue_info q ;
   char desc[32U] ;
   bool enable_aic ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 eqd ;
   u32 cur_eqd ;
   u8 idx ;
   u16 tx_budget ;
   u16 spurious_intr ;
   struct napi_struct napi ;
   struct be_adapter *adapter ;
};
#line 197 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
   bool rearm_cq ;
};
#line 203 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_stats {
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_reqs ;
   u64 tx_wrbs ;
   u64 tx_compl ;
   ulong tx_jiffies ;
   u32 tx_stops ;
   struct u64_stats_sync sync ;
   struct u64_stats_sync sync_compl ;
};
#line 215 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_obj {
   u32 db_offset ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct sk_buff *sent_skb_list[2048U] ;
   struct be_tx_stats stats ;
};
#line 224 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_page_info {
   struct page *page ;
   dma_addr_t bus ;
   u16 page_offset ;
   bool last_page_user ;
};
#line 232 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_stats {
   u64 rx_bytes ;
   u64 rx_pkts ;
   u64 rx_pkts_prev ;
   ulong rx_jiffies ;
   u32 rx_drops_no_skbs ;
   u32 rx_drops_no_frags ;
   u32 rx_post_fail ;
   u32 rx_compl ;
   u32 rx_mcast_pkts ;
   u32 rx_compl_err ;
   u32 rx_pps ;
   struct u64_stats_sync sync ;
};
#line 247 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_compl_info {
   u32 rss_hash ;
   u16 vlan_tag ;
   u16 pkt_size ;
   u16 rxq_idx ;
   u16 port ;
   u8 vlanf ;
   u8 num_rcvd ;
   u8 err ;
   u8 ipf ;
   u8 tcpf ;
   u8 udpf ;
   u8 ip_csum ;
   u8 l4_csum ;
   u8 ipv6 ;
   u8 vtm ;
   u8 pkt_type ;
};
#line 266 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_obj {
   struct be_adapter *adapter ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct be_rx_compl_info rxcp ;
   struct be_rx_page_info page_info_tbl[1024U] ;
   struct be_rx_stats stats ;
   u8 rss_id ;
   bool rx_post_starved ;
};
#line 277 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_drv_stats {
   u32 be_on_die_temperature ;
   u32 eth_red_drops ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rx_drops_too_many_frags ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
};
#line 313 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_vf_cfg {
   unsigned char mac_addr[6U] ;
   int if_handle ;
   int pmac_id ;
   u16 def_vid ;
   u16 vlan_tag ;
   u32 tx_rate ;
};
#line 327 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct phy_info {
   u8 transceiver ;
   u8 autoneg ;
   u8 fc_autoneg ;
   u8 port_type ;
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   int link_speed ;
   u32 dac_cable_len ;
   u32 advertising ;
   u32 supported ;
};
#line 350 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct __anonstruct_roce_db_264 {
   u32 size ;
   u32 total_size ;
   u64 io_addr ;
};
#line 350 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_adapter {
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 *csr ;
   u8 *db ;
   struct mutex mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   u32 num_msix_vec ;
   u32 num_evt_qs ;
   struct be_eq_obj eq_obj[13U] ;
   struct msix_entry msix_entries[13U] ;
   bool isr_registered ;
   u32 num_tx_qs ;
   struct be_tx_obj tx_obj[8U] ;
   u32 num_rx_qs ;
   struct be_rx_obj rx_obj[9U] ;
   u32 big_page_size ;
   struct be_drv_stats drv_stats ;
   u16 vlans_added ;
   u8 vlan_tag[4096U] ;
   u8 vlan_prio_bmap ;
   u16 recommended_prio ;
   struct be_dma_mem rx_filter ;
   struct be_dma_mem stats_cmd ;
   struct delayed_work work ;
   u16 work_counter ;
   struct delayed_work func_recovery_work ;
   u32 flags ;
   u32 cmd_privileges ;
   char fw_ver[32U] ;
   int if_handle ;
   u32 *pmac_id ;
   u32 beacon_state ;
   bool eeh_error ;
   bool fw_timeout ;
   bool hw_error ;
   u32 port_num ;
   bool promiscuous ;
   u32 function_mode ;
   u32 function_caps ;
   u32 rx_fc ;
   u32 tx_fc ;
   bool stats_cmd_sent ;
   u32 if_type ;
   struct __anonstruct_roce_db_264 roce_db ;
   u32 num_msix_roce_vec ;
   struct ocrdma_dev *ocrdma_dev ;
   struct list_head entry ;
   u32 flash_status ;
   struct completion flash_compl ;
   u32 num_vfs ;
   u32 dev_num_vfs ;
   u8 virtfn ;
   struct be_vf_cfg *vf_cfg ;
   bool be3_native ;
   u32 sli_family ;
   u8 hba_port_num ;
   u16 pvid ;
   struct phy_info phy ;
   u8 wol_cap ;
   bool wol ;
   u32 uc_macs ;
   u16 asic_rev ;
   u16 qnq_vid ;
   u32 msg_enable ;
   int be_get_temp_freq ;
   u16 max_mcast_mac ;
   u16 max_tx_queues ;
   u16 max_rss_queues ;
   u16 max_rx_queues ;
   u16 max_pmac_cnt ;
   u16 max_vlans ;
   u16 max_event_queues ;
   u32 if_cap_flags ;
   u8 pf_number ;
   u64 rss_flags ;
};
#line 164 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd[3U] ;
};
#line 248 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd[2U] ;
   u8 status ;
   u8 add_status ;
   u8 rsvd1[2U] ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 590 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v0 {
   u32 rx_bytes_lsd ;
   u32 rx_bytes_msd ;
   u32 rx_total_frames ;
   u32 rx_unicast_frames ;
   u32 rx_multicast_frames ;
   u32 rx_broadcast_frames ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_64_byte_packets ;
   u32 rx_65_127_byte_packets ;
   u32 rx_128_256_byte_packets ;
   u32 rx_256_511_byte_packets ;
   u32 rx_512_1023_byte_packets ;
   u32 rx_1024_1518_byte_packets ;
   u32 rx_1519_2047_byte_packets ;
   u32 rx_2048_4095_byte_packets ;
   u32 rx_4096_8191_byte_packets ;
   u32 rx_8192_9216_byte_packets ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rx_non_rss_packets ;
   u32 rx_ipv4_packets ;
   u32 rx_ipv6_packets ;
   u32 rx_ipv4_bytes_lsd ;
   u32 rx_ipv4_bytes_msd ;
   u32 rx_ipv6_bytes_lsd ;
   u32 rx_ipv6_bytes_msd ;
   u32 rx_chute1_packets ;
   u32 rx_chute2_packets ;
   u32 rx_chute3_packets ;
   u32 rx_management_packets ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 tx_bytes_lsd ;
   u32 tx_bytes_msd ;
   u32 tx_unicastframes ;
   u32 tx_multicastframes ;
   u32 tx_broadcastframes ;
   u32 tx_pauseframes ;
   u32 tx_controlframes ;
   u32 tx_64_byte_packets ;
   u32 tx_65_127_byte_packets ;
   u32 tx_128_256_byte_packets ;
   u32 tx_256_511_byte_packets ;
   u32 tx_512_1023_byte_packets ;
   u32 tx_1024_1518_byte_packets ;
   u32 tx_1519_2047_byte_packets ;
   u32 tx_2048_4095_byte_packets ;
   u32 tx_4096_8191_byte_packets ;
   u32 tx_8192_9216_byte_packets ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
};
#line 660 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v0 {
   struct be_port_rxf_stats_v0 port[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 management_rx_port_packets ;
   u32 management_rx_port_bytes ;
   u32 management_rx_port_pause_frames ;
   u32 management_rx_port_errors ;
   u32 management_tx_port_packets ;
   u32 management_tx_port_bytes ;
   u32 management_tx_port_pause ;
   u32 management_rx_port_rxfifo_overflow ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd0[7U] ;
   u32 port0_jabber_events ;
   u32 port1_jabber_events ;
   u32 rsvd1[6U] ;
};
#line 684 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v0 {
   u32 rx_drops_no_fragments[44U] ;
   u32 rsvd[4U] ;
};
#line 689 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pmem_stats {
   u32 eth_red_drops ;
   u32 rsvd[5U] ;
};
#line 694 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v0 {
   struct be_rxf_stats_v0 rxf ;
   u32 rsvd[48U] ;
   struct be_erx_stats_v0 erx ;
   struct be_pmem_stats pmem ;
};
#line 706 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v0 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v0 hw_stats ;
};
#line 711 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_pport_stats {
   u32 tx_packets_lo ;
   u32 tx_packets_hi ;
   u32 tx_unicast_packets_lo ;
   u32 tx_unicast_packets_hi ;
   u32 tx_multicast_packets_lo ;
   u32 tx_multicast_packets_hi ;
   u32 tx_broadcast_packets_lo ;
   u32 tx_broadcast_packets_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
   u32 tx_unicast_bytes_lo ;
   u32 tx_unicast_bytes_hi ;
   u32 tx_multicast_bytes_lo ;
   u32 tx_multicast_bytes_hi ;
   u32 tx_broadcast_bytes_lo ;
   u32 tx_broadcast_bytes_hi ;
   u32 tx_discards_lo ;
   u32 tx_discards_hi ;
   u32 tx_errors_lo ;
   u32 tx_errors_hi ;
   u32 tx_pause_frames_lo ;
   u32 tx_pause_frames_hi ;
   u32 tx_pause_on_frames_lo ;
   u32 tx_pause_on_frames_hi ;
   u32 tx_pause_off_frames_lo ;
   u32 tx_pause_off_frames_hi ;
   u32 tx_internal_mac_errors_lo ;
   u32 tx_internal_mac_errors_hi ;
   u32 tx_control_frames_lo ;
   u32 tx_control_frames_hi ;
   u32 tx_packets_64_bytes_lo ;
   u32 tx_packets_64_bytes_hi ;
   u32 tx_packets_65_to_127_bytes_lo ;
   u32 tx_packets_65_to_127_bytes_hi ;
   u32 tx_packets_128_to_255_bytes_lo ;
   u32 tx_packets_128_to_255_bytes_hi ;
   u32 tx_packets_256_to_511_bytes_lo ;
   u32 tx_packets_256_to_511_bytes_hi ;
   u32 tx_packets_512_to_1023_bytes_lo ;
   u32 tx_packets_512_to_1023_bytes_hi ;
   u32 tx_packets_1024_to_1518_bytes_lo ;
   u32 tx_packets_1024_to_1518_bytes_hi ;
   u32 tx_packets_1519_to_2047_bytes_lo ;
   u32 tx_packets_1519_to_2047_bytes_hi ;
   u32 tx_packets_2048_to_4095_bytes_lo ;
   u32 tx_packets_2048_to_4095_bytes_hi ;
   u32 tx_packets_4096_to_8191_bytes_lo ;
   u32 tx_packets_4096_to_8191_bytes_hi ;
   u32 tx_packets_8192_to_9216_bytes_lo ;
   u32 tx_packets_8192_to_9216_bytes_hi ;
   u32 tx_lso_packets_lo ;
   u32 tx_lso_packets_hi ;
   u32 rx_packets_lo ;
   u32 rx_packets_hi ;
   u32 rx_unicast_packets_lo ;
   u32 rx_unicast_packets_hi ;
   u32 rx_multicast_packets_lo ;
   u32 rx_multicast_packets_hi ;
   u32 rx_broadcast_packets_lo ;
   u32 rx_broadcast_packets_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 rx_unicast_bytes_lo ;
   u32 rx_unicast_bytes_hi ;
   u32 rx_multicast_bytes_lo ;
   u32 rx_multicast_bytes_hi ;
   u32 rx_broadcast_bytes_lo ;
   u32 rx_broadcast_bytes_hi ;
   u32 rx_unknown_protos ;
   u32 rsvd_69 ;
   u32 rx_discards_lo ;
   u32 rx_discards_hi ;
   u32 rx_errors_lo ;
   u32 rx_errors_hi ;
   u32 rx_crc_errors_lo ;
   u32 rx_crc_errors_hi ;
   u32 rx_alignment_errors_lo ;
   u32 rx_alignment_errors_hi ;
   u32 rx_symbol_errors_lo ;
   u32 rx_symbol_errors_hi ;
   u32 rx_pause_frames_lo ;
   u32 rx_pause_frames_hi ;
   u32 rx_pause_on_frames_lo ;
   u32 rx_pause_on_frames_hi ;
   u32 rx_pause_off_frames_lo ;
   u32 rx_pause_off_frames_hi ;
   u32 rx_frames_too_long_lo ;
   u32 rx_frames_too_long_hi ;
   u32 rx_internal_mac_errors_lo ;
   u32 rx_internal_mac_errors_hi ;
   u32 rx_undersize_packets ;
   u32 rx_oversize_packets ;
   u32 rx_fragment_packets ;
   u32 rx_jabbers ;
   u32 rx_control_frames_lo ;
   u32 rx_control_frames_hi ;
   u32 rx_control_frames_unknown_opcode_lo ;
   u32 rx_control_frames_unknown_opcode_hi ;
   u32 rx_in_range_errors ;
   u32 rx_out_of_range_errors ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_invalid_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errors ;
   u32 rx_tcp_checksum_errors ;
   u32 rx_udp_checksum_errors ;
   u32 rx_non_rss_packets ;
   u32 rsvd_111 ;
   u32 rx_ipv4_packets_lo ;
   u32 rx_ipv4_packets_hi ;
   u32 rx_ipv6_packets_lo ;
   u32 rx_ipv6_packets_hi ;
   u32 rx_ipv4_bytes_lo ;
   u32 rx_ipv4_bytes_hi ;
   u32 rx_ipv6_bytes_lo ;
   u32 rx_ipv6_bytes_hi ;
   u32 rx_nic_packets_lo ;
   u32 rx_nic_packets_hi ;
   u32 rx_tcp_packets_lo ;
   u32 rx_tcp_packets_hi ;
   u32 rx_iscsi_packets_lo ;
   u32 rx_iscsi_packets_hi ;
   u32 rx_management_packets_lo ;
   u32 rx_management_packets_hi ;
   u32 rx_switched_unicast_packets_lo ;
   u32 rx_switched_unicast_packets_hi ;
   u32 rx_switched_multicast_packets_lo ;
   u32 rx_switched_multicast_packets_hi ;
   u32 rx_switched_broadcast_packets_lo ;
   u32 rx_switched_broadcast_packets_hi ;
   u32 num_forwards_lo ;
   u32 num_forwards_hi ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
   u32 rx_drops_too_many_frags_lo ;
   u32 rx_drops_too_many_frags_hi ;
   u32 rx_drops_invalid_queue ;
   u32 rsvd_141 ;
   u32 rx_drops_mtu_lo ;
   u32 rx_drops_mtu_hi ;
   u32 rx_packets_64_bytes_lo ;
   u32 rx_packets_64_bytes_hi ;
   u32 rx_packets_65_to_127_bytes_lo ;
   u32 rx_packets_65_to_127_bytes_hi ;
   u32 rx_packets_128_to_255_bytes_lo ;
   u32 rx_packets_128_to_255_bytes_hi ;
   u32 rx_packets_256_to_511_bytes_lo ;
   u32 rx_packets_256_to_511_bytes_hi ;
   u32 rx_packets_512_to_1023_bytes_lo ;
   u32 rx_packets_512_to_1023_bytes_hi ;
   u32 rx_packets_1024_to_1518_bytes_lo ;
   u32 rx_packets_1024_to_1518_bytes_hi ;
   u32 rx_packets_1519_to_2047_bytes_lo ;
   u32 rx_packets_1519_to_2047_bytes_hi ;
   u32 rx_packets_2048_to_4095_bytes_lo ;
   u32 rx_packets_2048_to_4095_bytes_hi ;
   u32 rx_packets_4096_to_8191_bytes_lo ;
   u32 rx_packets_4096_to_8191_bytes_hi ;
   u32 rx_packets_8192_to_9216_bytes_lo ;
   u32 rx_packets_8192_to_9216_bytes_hi ;
};
#line 892 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_pport_stats {
   struct be_cmd_resp_hdr hdr ;
   struct lancer_pport_stats pport_stats ;
};
#line 1150 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flashrom_params {
   u32 op_code ;
   u32 op_type ;
   u32 data_buf_size ;
   u32 offset ;
};
#line 1158 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_write_flashrom {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 data_buf[32768U] ;
   u8 rsvd[4U] ;
};
#line 1579 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v1 {
   u32 rsvd0[12U] ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd1[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd2[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd3[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd4[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd5[3U] ;
};
#line 1617 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v1 {
   struct be_port_rxf_stats_v1 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[14U] ;
};
#line 1633 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v1 {
   u32 rx_drops_no_fragments[68U] ;
   u32 rsvd[4U] ;
};
#line 1638 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v1 {
   struct be_rxf_stats_v1 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v1 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1651 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v1 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v1 hw_stats ;
};
#line 1656 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_mode {
   u8 mode ;
   u8 rsvd0 ;
   u16 port_mask ;
   u32 dbg_lvl ;
   u64 fun_mask ;
};
#line 1671 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_modules {
   u8 modules_str[32U] ;
   u32 modules_id ;
   u32 num_modes ;
   struct ext_fat_mode trace_lvl[4U] ;
};
#line 1678 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_fat_conf_params {
   u32 max_log_entries ;
   u32 log_entry_size ;
   u8 log_type ;
   u8 max_log_funs ;
   u8 max_log_ports ;
   u8 rsvd0 ;
   u32 supp_modes ;
   u32 num_modules ;
   struct ext_fat_modules module[27U] ;
};
#line 6153 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
typedef int ldv_func_ret_type___2;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 413 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_hba_attribs {
   u8 flashrom_version_string[32U] ;
   u8 manufacturer_name[32U] ;
   u32 supported_modes ;
   u32 rsvd0[3U] ;
   u8 ncsi_ver_string[12U] ;
   u32 default_extended_timeout ;
   u8 controller_model_number[32U] ;
   u8 controller_description[64U] ;
   u8 controller_serial_number[32U] ;
   u8 ip_version_string[32U] ;
   u8 firmware_version_string[32U] ;
   u8 bios_version_string[32U] ;
   u8 redboot_version_string[32U] ;
   u8 driver_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
   u32 functionalities_supported ;
   u16 max_cdblength ;
   u8 asic_revision ;
   u8 generational_guid[16U] ;
   u8 hba_port_count ;
   u16 default_link_down_timeout ;
   u8 iscsi_ver_min_max ;
   u8 multifunction_device ;
   u8 cache_valid ;
   u8 hba_status ;
   u8 max_domains_supported ;
   u8 phy_port ;
   u32 firmware_post_status ;
   u32 hba_mtu[8U] ;
   u32 rsvd1[4U] ;
};
#line 446 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_controller_attrib {
   struct mgmt_hba_attribs hba_attribs ;
   u16 pci_vendor_id ;
   u16 pci_device_id ;
   u16 pci_sub_vendor_id ;
   u16 pci_sub_system_id ;
   u8 pci_bus_number ;
   u8 pci_device_number ;
   u8 pci_function_number ;
   u8 interface_type ;
   u64 unique_identifier ;
   u32 rsvd0[5U] ;
};
#line 682 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
struct be_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 len ;
};
#line 31 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_payload_265 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 31 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_265 payload ;
};
#line 56 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 74 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_trailer {
   u32 code ;
};
#line 98 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   struct be_async_event_trailer trailer ;
};
#line 113 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_qos_link_speed {
   u8 physical_port ;
   u8 rsvd[5U] ;
   u16 qos_link_speed ;
   u32 event_tag ;
   struct be_async_event_trailer trailer ;
};
#line 124 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_cos_priority {
   u8 physical_port ;
   u8 available_priority_bmap ;
   u8 reco_default_priority ;
   u8 valid ;
   u8 rsvd0 ;
   u8 event_tag ;
   struct be_async_event_trailer trailer ;
};
#line 137 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_pvid_state {
   u8 enabled ;
   u8 rsvd0 ;
   u16 tag ;
   u32 event_tag ;
   u32 rsvd1 ;
   struct be_async_event_trailer trailer ;
};
#line 149 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_qnq {
   u8 valid ;
   u8 rsvd0 ;
   u16 vlan_tag ;
   u32 event_tag ;
   u8 rsvd1[4U] ;
   struct be_async_event_trailer trailer ;
};
#line 159 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 261 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 297 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 305 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 rsvd0 ;
};
#line 318 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mac_addr {
   u16 size_of_struct ;
   u8 addr[6U] ;
};
#line 324 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mac_query {
   struct be_cmd_req_hdr hdr ;
   u8 type ;
   u8 permanent ;
   u16 if_id ;
   u32 pmac_id ;
};
#line 332 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mac_query {
   struct be_cmd_resp_hdr hdr ;
   struct mac_addr mac ;
};
#line 337 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_add {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u8 mac_address[6U] ;
   u8 rsvd0[2U] ;
};
#line 345 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_pmac_add {
   struct be_cmd_resp_hdr hdr ;
   u32 pmac_id ;
};
#line 350 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_del {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u32 pmac_id ;
};
#line 399 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 408 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 415 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fat {
   struct be_cmd_req_hdr hdr ;
   u32 fat_operation ;
   u32 read_log_offset ;
   u32 read_log_length ;
   u32 data_buffer_size ;
   u32 data_buffer[1U] ;
};
#line 424 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fat {
   struct be_cmd_resp_hdr hdr ;
   u32 log_size ;
   u32 read_log_length ;
   u32 rsvd[2U] ;
   u32 data_buffer[1U] ;
};
#line 462 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 470 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_ext_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u32 async_event_bitmap[1U] ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 479 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 485 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_tx_create {
   struct be_cmd_req_hdr hdr ;
   u8 num_pages ;
   u8 ulp_num ;
   u16 type ;
   u16 if_id ;
   u8 queue_size ;
   u8 rsvd0 ;
   u32 rsvd1 ;
   u16 cq_id ;
   u16 rsvd2 ;
   u32 rsvd3[13U] ;
   struct phys_addr pages[8U] ;
};
#line 504 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_tx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cid ;
   u16 rid ;
   u32 db_offset ;
   u32 rsvd0[4U] ;
};
#line 512 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_rx_create {
   struct be_cmd_req_hdr hdr ;
   u16 cq_id ;
   u8 frag_size ;
   u8 num_pages ;
   struct phys_addr pages[2U] ;
   u32 interface_id ;
   u16 max_frame_size ;
   u16 rsvd0 ;
   u32 rss_queue ;
};
#line 525 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_rx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u8 rss_id ;
   u8 rsvd0 ;
};
#line 540 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 562 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_create {
   struct be_cmd_req_hdr hdr ;
   u32 version ;
   u32 capability_flags ;
   u32 enable_flags ;
   u8 mac_addr[6U] ;
   u8 rsvd0 ;
   u8 pmac_invalid ;
   u32 vlan_tag ;
};
#line 578 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_if_create {
   struct be_cmd_resp_hdr hdr ;
   u32 interface_id ;
   u32 pmac_id ;
};
#line 584 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_destroy {
   struct be_cmd_req_hdr hdr ;
   u32 interface_id ;
};
#line 878 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct pport_stats_params {
   u16 pport_num ;
   u8 rsvd ;
   u8 reset_stats ;
};
#line 884 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_cmd_params_266 {
   struct pport_stats_params params ;
   u8 rsvd[656U] ;
};
#line 884 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_pport_stats {
   struct be_cmd_req_hdr hdr ;
   union __anonunion_cmd_params_266 cmd_params ;
};
#line 904 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_cntl_addnl_attribs {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd[8U] ;
};
#line 909 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_cntl_addnl_attribs {
   struct be_cmd_resp_hdr hdr ;
   u16 ipl_file_number ;
   u8 ipl_file_version ;
   u8 rsvd0 ;
   u8 on_die_temperature ;
   u8 rsvd1[3U] ;
};
#line 918 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_vlan_config {
   struct be_cmd_req_hdr hdr ;
   u8 interface_id ;
   u8 promiscuous ;
   u8 untagged ;
   u8 num_vlan ;
   u16 normal_vlan[64U] ;
};
#line 927 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct macaddr {
   u8 byte[6U] ;
};
#line 933 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rx_filter {
   struct be_cmd_req_hdr hdr ;
   u32 global_flags_mask ;
   u32 global_flags ;
   u32 if_flags_mask ;
   u32 if_flags ;
   u32 if_id ;
   u32 mcast_num ;
   struct macaddr mcast_mac[64U] ;
};
#line 944 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_link_status {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 964 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_link_status {
   struct be_cmd_resp_hdr hdr ;
   u8 physical_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 link_speed ;
   u8 logical_link_status ;
   u8 rsvd1[3U] ;
};
#line 1014 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fw_version {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[32U] ;
   u8 rsvd1[32U] ;
};
#line 1021 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fw_version {
   struct be_cmd_resp_hdr hdr ;
   u8 firmware_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
};
#line 1027 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_flow_control {
   struct be_cmd_req_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1034 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_flow_control {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1040 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_flow_control {
   struct be_cmd_resp_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1046 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct __anonstruct_delay_267 {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 1046 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   u32 num_eq ;
   struct __anonstruct_delay_267 delay[8U] ;
};
#line 1062 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_query_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd[31U] ;
};
#line 1075 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_query_fw_cfg {
   struct be_cmd_resp_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   u32 rsvd[26U] ;
   u32 function_caps ;
};
#line 1085 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rss_config {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u16 enable_rss ;
   u16 cpu_table_size_log2 ;
   u32 hash[10U] ;
   u8 cpu_table[128U] ;
   u8 flush ;
   u8 rsvd0[3U] ;
};
#line 1119 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_enable_disable_beacon {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 beacon_state ;
   u8 beacon_duration ;
   u8 status_duration ;
};
#line 1137 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_beacon_state {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 rsvd0 ;
   u16 rsvd1 ;
};
#line 1144 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_beacon_state {
   struct be_cmd_resp_hdr resp_hdr ;
   u8 beacon_state ;
   u8 rsvd0[3U] ;
};
#line 1165 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_read_flash_crc {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 crc[4U] ;
   u8 rsvd[4U] ;
};
#line 1179 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_write_object {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
   u32 write_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1190 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_write_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_write_len ;
   u8 change_status ;
   u8 rsvd3[3U] ;
};
#line 1206 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_read_object {
   struct be_cmd_req_hdr hdr ;
   u32 desired_read_len ;
   u32 read_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1225 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_read_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_read_len ;
   u32 eof ;
};
#line 1238 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0[145U] ;
   u8 magic_mac[6U] ;
   u8 rsvd2[2U] ;
};
#line 1246 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config_v1 {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 query_options ;
   u8 rsvd1[5U] ;
   u32 rsvd2[288U] ;
   u8 magic_mac[6U] ;
   u8 rsvd3[22U] ;
};
#line 1256 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_acpi_wol_magic_config_v1 {
   struct be_cmd_resp_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 wol_settings ;
   u8 rsvd1[5U] ;
   u32 rsvd2[295U] ;
};
#line 1264 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_loopback_test {
   struct be_cmd_req_hdr hdr ;
   u32 loopback_type ;
   u32 num_pkts ;
   u64 pattern ;
   u32 src_port ;
   u32 dest_port ;
   u32 pkt_size ;
};
#line 1284 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_loopback_test {
   struct be_cmd_resp_hdr resp_hdr ;
   u32 status ;
   u32 num_txfer ;
   u32 num_rx ;
   u32 miscomp_off ;
   u32 ticks_compl ;
};
#line 1293 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_lmode {
   struct be_cmd_req_hdr hdr ;
   u8 src_port ;
   u8 dest_port ;
   u8 loopback_type ;
   u8 loopback_state ;
};
#line 1306 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_ddrdma_test {
   struct be_cmd_req_hdr hdr ;
   u64 pattern ;
   u32 byte_count ;
   u32 rsvd0 ;
   u8 snd_buff[4096U] ;
   u8 rsvd1[4096U] ;
};
#line 1316 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_ddrdma_test {
   struct be_cmd_resp_hdr hdr ;
   u64 pattern ;
   u32 byte_cnt ;
   u32 snd_err ;
   u8 rsvd0[4096U] ;
   u8 rcv_buff[4096U] ;
};
#line 1325 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[1024U] ;
};
#line 1352 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_phy_info {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[24U] ;
};
#line 1382 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_phy_info {
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 ext_phy_details ;
   u16 rsvd ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   u32 future_use[2U] ;
};
#line 1398 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_qos {
   struct be_cmd_req_hdr hdr ;
   u32 valid_bits ;
   u32 max_bps_nic ;
   u32 rsvd[7U] ;
};
#line 1414 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cntl_attribs {
   struct be_cmd_req_hdr hdr ;
};
#line 1419 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cntl_attribs {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attrib attribs ;
};
#line 1424 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_func_cap {
   struct be_cmd_req_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1435 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_set_func_cap {
   struct be_cmd_resp_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1456 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_priv_map {
   u8 opcode ;
   u8 subsystem ;
   u32 priv_mask ;
};
#line 1466 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1471 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fn_privileges {
   struct be_cmd_resp_hdr hdr ;
   u32 privilege_mask ;
};
#line 1476 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_type ;
   u8 perm_override ;
   u16 iface_id ;
   u32 mac_id ;
   u32 rsvd[3U] ;
};
#line 1488 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct __anonstruct_s_mac_id_269 {
   u8 rsvd[2U] ;
   u32 mac_id ;
};
#line 1488 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_mac_addr_id_268 {
   u8 macaddr[6U] ;
   struct __anonstruct_s_mac_id_269 s_mac_id ;
};
#line 1488 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct get_list_macaddr {
   u16 mac_addr_size ;
   union __anonunion_mac_addr_id_268 mac_addr_id ;
};
#line 1499 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_mac_list {
   struct be_cmd_resp_hdr hdr ;
   struct get_list_macaddr fd_macaddr ;
   struct get_list_macaddr macid_macaddr ;
   u8 true_mac_count ;
   u8 pseudo_mac_count ;
   u8 mac_list_size ;
   u8 rsvd ;
   struct get_list_macaddr macaddr_list[64U] ;
};
#line 1511 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_count ;
   u8 rsvd1 ;
   u16 rsvd2 ;
   struct macaddr mac[64U] ;
};
#line 1532 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[20U] ;
};
#line 1557 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
};
#line 1562 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_hsw_config {
   struct be_cmd_resp_hdr hdr ;
   u8 context[16U] ;
   u32 rsvd ;
};
#line 1568 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 1574 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u8 port_name[4U] ;
};
#line 1690 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   u32 parameter_type ;
};
#line 1700 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   struct be_fat_conf_params set_params ;
};
#line 1705 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_nic_resource_desc {
   u8 desc_type ;
   u8 desc_len ;
   u8 rsvd1 ;
   u8 flags ;
   u8 vf_num ;
   u8 rsvd2 ;
   u8 pf_num ;
   u8 rsvd3 ;
   u16 unicast_mac_count ;
   u8 rsvd4[6U] ;
   u16 mcc_count ;
   u16 vlan_count ;
   u16 mcast_mac_count ;
   u16 txq_count ;
   u16 rq_count ;
   u16 rssq_count ;
   u16 lro_count ;
   u16 cq_count ;
   u16 toe_conn_count ;
   u16 eq_count ;
   u32 rsvd5 ;
   u32 cap_flags ;
   u8 link_param ;
   u8 rsvd6[3U] ;
   u32 bw_min ;
   u32 bw_max ;
   u8 acpi_params ;
   u8 wol_param ;
   u16 rsvd7 ;
   u32 rsvd8[3U] ;
};
#line 1751 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_func_config {
   struct be_cmd_req_hdr hdr ;
};
#line 1755 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_func_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[352U] ;
};
#line 1761 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_profile_config {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd ;
   u8 type ;
   u16 rsvd1 ;
};
#line 1769 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_profile_config {
   struct be_cmd_req_hdr hdr ;
   u32 desc_count ;
   u8 func_param[352U] ;
};
#line 1781 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_profile_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
   u32 desc_count ;
   struct be_nic_resource_desc nic_desc ;
};
#line 1792 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_enable_disable_vf {
   struct be_cmd_req_hdr hdr ;
   u8 enable ;
   u8 rsvd[3U] ;
};
#line 1798 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_intr_set {
   struct be_cmd_req_hdr hdr ;
   u8 intr_enabled ;
   u8 rsvd[3U] ;
};
#line 1809 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_if_desc {
   u32 if_id ;
   u32 cap_flags ;
   u32 en_flags ;
};
#line 1816 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_iface_list {
   struct be_cmd_req_hdr hdr ;
};
#line 1820 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_iface_list {
   struct be_cmd_req_hdr hdr ;
   u32 if_cnt ;
   struct be_if_desc if_desc ;
};
#line 3451 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___4;
#line 3473 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___6;
#line 3495 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___8;
#line 3517 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___10;
#line 3539 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___12;
#line 3561 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___14;
#line 3583 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___16;
#line 3605 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___18;
#line 3627 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___20;
#line 3649 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___22;
#line 3671 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___24;
#line 3693 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___26;
#line 3715 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___28;
#line 3737 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___30;
#line 3759 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___32;
#line 3781 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___34;
#line 3803 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
typedef int ldv_func_ret_type___36;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 1333 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 seeprom_data[1024U] ;
};
#line 1952 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_ethtool_stat {
   char desc[32U] ;
   int type ;
   int size ;
   int offset ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 548 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
enum be_interrupt_mode {
    BE_INTERRUPT_MODE_MSIX = 0,
    BE_INTERRUPT_MODE_INTX = 1,
    BE_INTERRUPT_MODE_MSI = 2
} ;
#line 554 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct __anonstruct_msix_263 {
   int num_vectors ;
   int start_vector ;
   u32 vector_list[16U] ;
};
#line 554 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_dev_info {
   u8 *db ;
   u64 unmapped_db ;
   u32 db_page_size ;
   u32 db_total_size ;
   u64 dpp_unmapped_addr ;
   u32 dpp_unmapped_len ;
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 mac_addr[6U] ;
   u32 dev_family ;
   enum be_interrupt_mode intr_mode ;
   struct __anonstruct_msix_263 msix ;
};
#line 51 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
struct ocrdma_driver {
   unsigned char name[32U] ;
   struct ocrdma_dev *(*add)(struct be_dev_info * ) ;
   void (*remove)(struct ocrdma_dev * ) ;
   void (*state_change_handler)(struct ocrdma_dev * , u32  ) ;
};
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 62 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 70
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 72
  return;
}
}
#line 100 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 109
  return;
}
}
#line 197 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 201
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 204
  return (oldbit);
}
}
#line 248 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 256
  return (oldbit);
}
}
#line 318 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 320
  return ((int )((unsigned long )*(addr + (unsigned long )(nr / 64U)) >> ((int )nr & 63)) & 1);
}
}
#line 489 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 491
  bitpos = -1;
#line 497
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 500
  return (bitpos + 1);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 94 "include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 96
  return ((word << shift) | (word >> (8UL * sizeof(word) - (unsigned long )shift)));
}
}
#line 123 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 152 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 358
extern int sprintf(char * , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 356 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 88 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 23 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 34 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 58
extern void *memmove(void * , void const   * , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 113 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , int  ) ;
#line 276 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ 
  int tmp___0 ;

  {
#line 280
  tmp___0 = __bitmap_weight(src, nbits);
#line 280
  return (tmp___0);
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 28 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 459 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 461
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nr_cpu_ids);
#line 461
  return ((unsigned int )tmp);
}
}
#line 822 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 824
  __edi = __edi;
#line 824
  __esi = __esi;
#line 824
  __edx = __edx;
#line 824
  __ecx = __ecx;
#line 824
  __eax = __eax;
#line 824
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 824
  if (tmp != 0L) {
#line 824
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (824), "i" (12UL));
    ldv_4781: ;
#line 824
    goto ldv_4781;
  } else {

  }
#line 824
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 824
  __ret = __eax;
#line 824
  return (__ret);
}
}
#line 155 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 23 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 47 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 49
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1,%0": "+m" (v->counter): "ir" (i));
#line 51
  return;
}
}
#line 61 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 63
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %1,%0": "+m" (v->counter): "ir" (i));
#line 65
  return;
}
}
#line 93 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 105 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 109
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 118 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 171
extern int mutex_trylock(struct mutex * ) ;
#line 174
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 176
extern void mutex_unlock(struct mutex * ) ;
#line 179
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 183
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 7 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 27
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 31
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 43
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 44
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 47
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 4 "include/linux/bottom_half.h"
extern void local_bh_disable(void) ;
#line 6
extern void local_bh_enable(void) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->ldv_6014.rlock);
}
}
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 285
  _raw_spin_lock(& lock->ldv_6014.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 325
  _raw_spin_unlock(& lock->ldv_6014.rlock);
#line 326
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 293
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 94 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 192
extern void __init_work(struct work_struct * , int  ) ;
#line 337
extern struct workqueue_struct *system_wq ;
#line 428
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 446
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 480 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 484
  tmp = queue_delayed_work_on(4096, wq, dwork, delay);
#line 484
  return (tmp);
}
}
#line 553 "include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 556
  tmp = queue_delayed_work(system_wq, dwork, delay);
#line 556
  return (tmp);
}
}
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 72
extern void pci_iounmap(struct pci_dev * , void * ) ;
#line 17 "include/asm-generic/pci_iomap.h"
extern void *pci_iomap(struct pci_dev * , int  , unsigned long  ) ;
#line 39 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 173 "include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 329 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 332 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 334
  tmp = alloc_pages_current(gfp_mask, order);
#line 334
  return (tmp);
}
}
#line 856 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 857
extern int dev_set_drvdata(struct device * , void * ) ;
#line 957
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 959
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 963
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 357 "include/linux/pci.h"
__inline static struct pci_dev *pci_physfn(struct pci_dev *dev ) 
{ 


  {
#line 360
  if ((unsigned int )*((unsigned char *)dev + 2251UL) != 0U) {
#line 361
    dev = dev->ldv_15834.physfn;
  } else {

  }
#line 364
  return (dev);
}
}
#line 776
extern int pci_find_ext_capability(struct pci_dev * , int  ) ;
#line 782
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 800
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 802
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 808
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 816 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 818
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 818
  return (tmp);
}
}
#line 820 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 823
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 823
  return (tmp);
}
}
#line 833 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 836
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 836
  return (tmp);
}
}
#line 880
extern int pci_enable_device(struct pci_dev * ) ;
#line 897
extern void pci_disable_device(struct pci_dev * ) ;
#line 900
extern void pci_set_master(struct pci_dev * ) ;
#line 940
extern int pci_save_state(struct pci_dev * ) ;
#line 941
extern void pci_restore_state(struct pci_dev * ) ;
#line 947
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 948
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 951
extern int __pci_enable_wake(struct pci_dev * , pci_power_t  , bool  , bool  ) ;
#line 961 "include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp ;

  {
#line 964
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
#line 964
  return (tmp);
}
}
#line 1010
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1012
extern void pci_release_regions(struct pci_dev * ) ;
#line 1046
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1055
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1168
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1170
extern void pci_disable_msix(struct pci_dev * ) ;
#line 335 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 335
  tmp = constant_test_bit(15U, (unsigned long const volatile   *)(& page->flags));
#line 335
  return (tmp);
}
}
#line 400 "include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 402 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 404
  tmp___1 = PageTail((struct page  const  *)page);
#line 404
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 404
  if (tmp___2 != 0L) {
#line 405
    tmp = __get_page_tail(page);
#line 405
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 405
    if (tmp___0 != 0L) {
#line 406
      return;
    } else {

    }
  } else {

  }
#line 411
  tmp___3 = atomic_read((atomic_t const   *)(& page->ldv_16917.ldv_16916.ldv_16915._count));
#line 411
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 411
  if (tmp___4 != 0L) {
#line 411
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (411), "i" (12UL));
    ldv_18344: ;
#line 411
    goto ldv_18344;
  } else {

  }
#line 412
  atomic_inc(& page->ldv_16917.ldv_16916.ldv_16915._count);
#line 413
  return;
}
}
#line 458
extern void put_page(struct page * ) ;
#line 759 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 761
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 132 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 108 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 409 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 411
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 412
    return (0);
  } else {

  }
#line 413
  tmp = __kmalloc(n * size, flags);
#line 413
  return (tmp);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 63 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 65
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 70 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0) && *(dev->dma_mask) != 0ULL);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_20620: ;
#line 19
    goto ldv_20620;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, 0xffffea0000000000UL + (tmp___2 >> 12), (unsigned long )ptr & 4095UL,
                            size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, 0xffffea0000000000UL + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_20629: ;
#line 36
    goto ldv_20629;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 71 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 79
  if (tmp___2 != 0L) {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_20663: ;
#line 79
    goto ldv_20663;
  } else {

  }
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, 0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 83
  return (addr);
}
}
#line 86 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 91
  if (tmp___1 != 0L) {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_20671: ;
#line 91
    goto ldv_20671;
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, 0);
  } else {

  }
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 95
  return;
}
}
#line 47 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return (0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return (0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/dma-mapping.h",
                       166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 91 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 93
  tmp = dma_supported(dev, mask);
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                        size, dma_handle, 32U, 0);
#line 19
  return (tmp);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 26
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                 size, vaddr, dma_handle, 0);
#line 27
  return;
}
}
#line 1474 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1476
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1476
  return (tmp);
}
}
#line 1479 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1481
  dev_set_drvdata(& pdev->dev, data);
#line 1482
  return;
}
}
#line 1660
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1661
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 168 "include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 170
  return ((unsigned int )frag->size);
}
}
#line 173 "include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 175
  frag->size = size;
#line 176
  return;
}
}
#line 178 "include/linux/skbuff.h"
__inline static void skb_frag_size_add(skb_frag_t *frag , int delta ) 
{ 


  {
#line 180
  frag->size = frag->size + (__u32 )delta;
#line 181
  return;
}
}
#line 629
extern void kfree_skb(struct sk_buff * ) ;
#line 631
extern void consume_skb(struct sk_buff * ) ;
#line 662
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 669
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 721 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 723
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 872 "include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 876
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 0U) {
#line 877
    return (0);
  } else {

  }
#line 879
  tmp = skb_end_pointer(skb);
#line 879
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 880
  dataref = (dataref & 65535) - (dataref >> 16);
#line 881
  return (dataref != 1);
}
}
#line 906 "include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff  const  *skb ) 
{ 
  int tmp ;

  {
#line 908
  tmp = atomic_read(& skb->users);
#line 908
  return (tmp != 1);
}
}
#line 924 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t pri ) 
{ 
  struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 926
  if ((pri & 16U) != 0U) {
#line 926
    __might_sleep("include/linux/skbuff.h", 926, 0);
  } else {

  }
#line 927
  tmp___1 = skb_shared((struct sk_buff  const  *)skb);
#line 927
  if (tmp___1 != 0) {
#line 928
    tmp = skb_clone(skb, pri);
#line 928
    nskb = tmp;
#line 930
    tmp___0 = ldv__builtin_expect((unsigned long )nskb != (unsigned long )((struct sk_buff *)0),
                               1L);
#line 930
    if (tmp___0 != 0L) {
#line 931
      consume_skb(skb);
    } else {
#line 933
      kfree_skb(skb);
    }
#line 934
    skb = nskb;
  } else {

  }
#line 936
  return (skb);
}
}
#line 1291 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1293
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1296 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1298
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1380 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1382
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1383
  return;
}
}
#line 1385 "include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1387
  skb_reset_tail_pointer(skb);
#line 1388
  skb->tail = skb->tail + (sk_buff_data_t )offset;
#line 1389
  return;
}
}
#line 1421
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1473 "include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff  const  *skb ) 
{ 


  {
#line 1475
  return ((unsigned int )((long )skb->data) - (unsigned int )((long )skb->head));
}
}
#line 1604 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1606
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1853
extern int ___pskb_trim(struct sk_buff * , unsigned int  ) ;
#line 1855 "include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
#line 1857
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1857
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1857
  if (tmp___1 != 0L) {
#line 1858
    __ret_warn_on = 1;
#line 1858
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1858
    if (tmp != 0L) {
#line 1858
      warn_slowpath_null("include/linux/skbuff.h", 1858);
    } else {

    }
#line 1858
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1859
    return;
  } else {

  }
#line 1861
  skb->len = len;
#line 1862
  skb_set_tail_pointer(skb, (int const   )len);
#line 1863
  return;
}
}
#line 1867 "include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;

  {
#line 1869
  if (skb->data_len != 0U) {
#line 1870
    tmp = ___pskb_trim(skb, len);
#line 1870
    return (tmp);
  } else {

  }
#line 1871
  __skb_trim(skb, len);
#line 1872
  return (0);
}
}
#line 1875 "include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1877
  if (skb->len > len) {
#line 1877
    tmp = __pskb_trim(skb, len);
#line 1877
    tmp___0 = tmp;
  } else {
#line 1877
    tmp___0 = 0;
  }
#line 1877
  return (tmp___0);
}
}
#line 1949
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 1986 "include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                            unsigned int length ,
                                                            gfp_t gfp ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1989
  tmp = __netdev_alloc_skb(dev, length, gfp);
#line 1989
  skb = tmp;
#line 1993
  return (skb);
}
}
#line 1996 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                          unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1999
  tmp = __netdev_alloc_skb_ip_align(dev, length, 32U);
#line 1999
  return (tmp);
}
}
#line 2063 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2065
  return ((struct page *)frag->page.p);
}
}
#line 2149 "include/linux/skbuff.h"
__inline static void __skb_frag_set_page(skb_frag_t *frag , struct page *page ) 
{ 


  {
#line 2151
  frag->page.p = page;
#line 2152
  return;
}
}
#line 2162 "include/linux/skbuff.h"
__inline static void skb_frag_set_page(struct sk_buff *skb , int f , struct page *page ) 
{ 
  unsigned char *tmp ;

  {
#line 2165
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2165
  __skb_frag_set_page((skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )f,
                      page);
#line 2166
  return;
}
}
#line 2179 "include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2184
  tmp = skb_frag_page(frag);
#line 2184
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
#line 2184
  return (tmp___0);
}
}
#line 2208 "include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb , unsigned int headroom , int cloned ) 
{ 
  int delta ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___1 ;

  {
#line 2211
  delta = 0;
#line 2213
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
#line 2213
  if (tmp___0 < headroom) {
#line 2214
    tmp = skb_headroom((struct sk_buff  const  *)skb);
#line 2214
    delta = (int )(headroom - tmp);
  } else {

  }
#line 2216
  if (delta != 0 || cloned != 0) {
#line 2217
    _max1 = 32;
#line 2217
    _max2 = 64;
#line 2217
    _max1___0 = 32;
#line 2217
    _max2___0 = 64;
#line 2217
    tmp___1 = pskb_expand_head(skb, (((_max1 > _max2 ? _max1 : _max2) + -1) + delta) & - (_max1___0 > _max2___0 ? _max1___0 : _max2___0),
                               0, 32U);
#line 2217
    return (tmp___1);
  } else {

  }
#line 2219
  return (0);
}
}
#line 2249 "include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb , unsigned int headroom ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2251
  tmp = skb_header_cloned((struct sk_buff  const  *)skb);
#line 2251
  tmp___0 = __skb_cow(skb, headroom, tmp);
#line 2251
  return (tmp___0);
}
}
#line 2799 "include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 2801
  return ((u16 )skb->queue_mapping);
}
}
#line 2809 "include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 2811
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 2812
  return;
}
}
#line 2855 "include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 2857
  tmp = skb_end_pointer(skb);
#line 2857
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 2860 "include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 2862
  tmp = skb_end_pointer(skb);
#line 2862
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 2896 "include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 2898
  return;
}
}
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 50 "include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
#line 52
  msleep(seconds * 1000U);
#line 53
  return;
}
}
#line 70 "include/linux/u64_stats_sync.h"
__inline static void u64_stats_update_begin(struct u64_stats_sync *syncp ) 
{ 


  {
#line 72
  return;
}
}
#line 115 "include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_bh(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 123
  return (0U);
}
}
#line 127 "include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_bh(struct u64_stats_sync  const  *syncp ,
                                              unsigned int start ) 
{ 


  {
#line 136
  return (0);
}
}
#line 126 "include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 394 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 396 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 398
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& n->state));
#line 398
  return (tmp != 0);
}
}
#line 410 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 412
  tmp = napi_disable_pending(n);
#line 412
  if (tmp) {
#line 412
    tmp___0 = 0;
  } else {
#line 412
    tmp___0 = 1;
  }
#line 412
  if (tmp___0) {
#line 412
    tmp___1 = test_and_set_bit(0, (unsigned long volatile   *)(& n->state));
#line 412
    if (tmp___1 == 0) {
#line 412
      tmp___2 = 1;
    } else {
#line 412
      tmp___2 = 0;
    }
  } else {
#line 412
    tmp___2 = 0;
  }
#line 412
  return ((bool )tmp___2);
}
}
#line 423 "include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
#line 425
  tmp = napi_schedule_prep(n);
#line 425
  if ((int )tmp) {
#line 426
    __napi_schedule(n);
  } else {

  }
#line 427
  return;
}
}
#line 446
extern void napi_complete(struct napi_struct * ) ;
#line 455 "include/linux/netdevice.h"
__inline static void napi_disable(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 457
  set_bit(1U, (unsigned long volatile   *)(& n->state));
#line 458
  goto ldv_38282;
  ldv_38281: 
#line 459
  msleep(1U);
  ldv_38282: 
#line 458
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& n->state));
#line 458
  if (tmp != 0) {
#line 460
    goto ldv_38281;
  } else {

  }
#line 460
  clear_bit(1, (unsigned long volatile   *)(& n->state));
#line 461
  return;
}
}
#line 470 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 472
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& n->state));
#line 472
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 472
  if (tmp___0 != 0L) {
#line 472
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (472), "i" (12UL));
    ldv_38287: ;
#line 472
    goto ldv_38287;
  } else {

  }
#line 473
  __asm__  volatile   ("": : : "memory");
#line 474
  clear_bit(0, (unsigned long volatile   *)(& n->state));
#line 475
  return;
}
}
#line 1395 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1398
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1461 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1463
  return ((void *)dev + 2816U);
}
}
#line 1492
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1691
extern void free_netdev(struct net_device * ) ;
#line 1700
extern int netpoll_trap(void) ;
#line 1829
extern void __netif_schedule(struct Qdisc * ) ;
#line 1845 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 1847
  clear_bit(0, (unsigned long volatile   *)(& dev_queue->state));
#line 1848
  return;
}
}
#line 1861 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 1865
  i = 0U;
#line 1865
  goto ldv_39065;
  ldv_39064: 
#line 1866
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 1866
  txq = tmp;
#line 1867
  netif_tx_start_queue(txq);
#line 1865
  i = i + 1U;
  ldv_39065: ;
#line 1865
  if (dev->num_tx_queues > i) {
#line 1867
    goto ldv_39064;
  } else {

  }

#line 1872
  return;
}
}
#line 1905 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 1907
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 1907
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1907
  if (tmp != 0L) {
#line 1907
    warn_slowpath_null("include/linux/netdevice.h", 1907);
  } else {

  }
#line 1907
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1907
  if (tmp___0 != 0L) {
#line 1908
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
#line 1909
    return;
  } else {

  }
#line 1911
  set_bit(0U, (unsigned long volatile   *)(& dev_queue->state));
#line 1912
  return;
}
}
#line 1936 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 1938
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& dev_queue->state));
#line 1938
  return (tmp != 0);
}
}
#line 2040 "include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2042
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& dev->state));
#line 2042
  return (tmp != 0);
}
}
#line 2073 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;

  {
#line 2075
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2075
  txq = tmp;
#line 2077
  tmp___0 = netpoll_trap();
#line 2077
  if (tmp___0 != 0) {
#line 2078
    return;
  } else {

  }
#line 2080
  netif_tx_stop_queue(txq);
#line 2081
  return;
}
}
#line 2090 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2093
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2093
  txq = tmp;
#line 2095
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2095
  return (tmp___0);
}
}
#line 2111 "include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2113
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2113
  txq = tmp;
#line 2115
  tmp___0 = netpoll_trap();
#line 2115
  if (tmp___0 != 0) {
#line 2116
    return;
  } else {

  }
#line 2118
  tmp___1 = test_and_clear_bit(0, (unsigned long volatile   *)(& txq->state));
#line 2118
  if (tmp___1 != 0) {
#line 2119
    __netif_schedule(txq->qdisc);
  } else {

  }
#line 2120
  return;
}
}
#line 2155
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2159
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2187
extern int netif_get_num_default_rss_queues(void) ;
#line 2199
extern void dev_kfree_skb_any(struct sk_buff * ) ;
#line 2203
extern int netif_receive_skb(struct sk_buff * ) ;
#line 2207
extern struct sk_buff *napi_get_frags(struct napi_struct * ) ;
#line 2208
extern gro_result_t napi_gro_frags(struct napi_struct * ) ;
#line 2299
extern void netif_carrier_on(struct net_device * ) ;
#line 2301
extern void netif_carrier_off(struct net_device * ) ;
#line 2369
extern void netif_device_detach(struct net_device * ) ;
#line 2371
extern void netif_device_attach(struct net_device * ) ;
#line 2422 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 2424
  spin_lock(& txq->_xmit_lock);
#line 2425
  txq->xmit_lock_owner = cpu;
#line 2426
  return;
}
}
#line 2442 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 2444
  txq->xmit_lock_owner = -1;
#line 2445
  spin_unlock(& txq->_xmit_lock);
#line 2446
  return;
}
}
#line 2529 "include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2534
  local_bh_disable();
#line 2535
  __vpp_verify = 0;
#line 2535
  switch (4UL) {
  case 1UL: ;
#line 2535
  switch (4UL) {
  case 1UL: 
#line 2535
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2535
  goto ldv_39590;
  case 2UL: 
#line 2535
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2535
  goto ldv_39590;
  case 4UL: 
#line 2535
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2535
  goto ldv_39590;
  case 8UL: 
#line 2535
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2535
  goto ldv_39590;
  default: 
#line 2535
  __bad_percpu_size();
  }
  ldv_39590: 
#line 2535
  pscr_ret__ = pfo_ret__;
#line 2535
  goto ldv_39596;
  case 2UL: ;
#line 2535
  switch (4UL) {
  case 1UL: 
#line 2535
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2535
  goto ldv_39600;
  case 2UL: 
#line 2535
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2535
  goto ldv_39600;
  case 4UL: 
#line 2535
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2535
  goto ldv_39600;
  case 8UL: 
#line 2535
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2535
  goto ldv_39600;
  default: 
#line 2535
  __bad_percpu_size();
  }
  ldv_39600: 
#line 2535
  pscr_ret__ = pfo_ret_____0;
#line 2535
  goto ldv_39596;
  case 4UL: ;
#line 2535
  switch (4UL) {
  case 1UL: 
#line 2535
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2535
  goto ldv_39609;
  case 2UL: 
#line 2535
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2535
  goto ldv_39609;
  case 4UL: 
#line 2535
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2535
  goto ldv_39609;
  case 8UL: 
#line 2535
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2535
  goto ldv_39609;
  default: 
#line 2535
  __bad_percpu_size();
  }
  ldv_39609: 
#line 2535
  pscr_ret__ = pfo_ret_____1;
#line 2535
  goto ldv_39596;
  case 8UL: ;
#line 2535
  switch (4UL) {
  case 1UL: 
#line 2535
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2535
  goto ldv_39618;
  case 2UL: 
#line 2535
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2535
  goto ldv_39618;
  case 4UL: 
#line 2535
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2535
  goto ldv_39618;
  case 8UL: 
#line 2535
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2535
  goto ldv_39618;
  default: 
#line 2535
  __bad_percpu_size();
  }
  ldv_39618: 
#line 2535
  pscr_ret__ = pfo_ret_____2;
#line 2535
  goto ldv_39596;
  default: 
#line 2535
  __bad_size_call_parameter();
#line 2535
  goto ldv_39596;
  }
  ldv_39596: 
#line 2535
  cpu = pscr_ret__;
#line 2536
  i = 0U;
#line 2536
  goto ldv_39628;
  ldv_39627: 
#line 2537
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2537
  txq = tmp;
#line 2539
  __netif_tx_lock(txq, cpu);
#line 2540
  netif_tx_stop_queue(txq);
#line 2541
  __netif_tx_unlock(txq);
#line 2536
  i = i + 1U;
  ldv_39628: ;
#line 2536
  if (dev->num_tx_queues > i) {
#line 2538
    goto ldv_39627;
  } else {

  }
#line 2543
  local_bh_enable();
#line 2544
  return;
}
}
#line 2592
extern int register_netdev(struct net_device * ) ;
#line 2593
extern void unregister_netdev(struct net_device * ) ;
#line 2774 "include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 2777
  dev->gso_max_size = size;
#line 2778
  return;
}
}
#line 31 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 51
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 82 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 84
  return ((unsigned int )((((((int )((unsigned char )*addr) | (int )((unsigned char )*(addr + 1UL))) | (int )((unsigned char )*(addr + 2UL))) | (int )((unsigned char )*(addr + 3UL))) | (int )((unsigned char )*(addr + 4UL))) | (int )((unsigned char )*(addr + 5UL))) == 0U);
}
}
#line 94 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 96
  return (((int )*addr & 1) != 0);
}
}
#line 141 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 145
  tmp = is_multicast_ether_addr(addr);
#line 145
  if (tmp) {
#line 145
    tmp___0 = 0;
  } else {
#line 145
    tmp___0 = 1;
  }
#line 145
  if (tmp___0) {
#line 145
    tmp___1 = is_zero_ether_addr(addr);
#line 145
    if (tmp___1) {
#line 145
      tmp___2 = 0;
    } else {
#line 145
      tmp___2 = 1;
    }
#line 145
    if (tmp___2) {
#line 145
      tmp___3 = 1;
    } else {
#line 145
      tmp___3 = 0;
    }
  } else {
#line 145
    tmp___3 = 0;
  }
#line 145
  return ((bool )tmp___3);
}
}
#line 21 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 22
extern void rtnl_unlock(void) ;
#line 16 "include/linux/unaligned/packed_struct.h"
__inline static u32 __get_unaligned_cpu32(void const   *p ) 
{ 
  struct __una_u32  const  *ptr ;

  {
#line 18
  ptr = (struct __una_u32  const  *)p;
#line 19
  return ((u32 )ptr->x);
}
}
#line 70 "include/linux/jhash.h"
__inline static u32 jhash(void const   *key , u32 length , u32 initval ) 
{ 
  u32 a ;
  u32 b ;
  u32 c ;
  u8 const   *k ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;

  {
#line 73
  k = (u8 const   *)key;
#line 76
  c = (length + initval) + 3735928559U;
#line 76
  b = c;
#line 76
  a = b;
#line 79
  goto ldv_43370;
  ldv_43369: 
#line 80
  tmp = __get_unaligned_cpu32((void const   *)k);
#line 80
  a = tmp + a;
#line 81
  tmp___0 = __get_unaligned_cpu32((void const   *)k + 4U);
#line 81
  b = tmp___0 + b;
#line 82
  tmp___1 = __get_unaligned_cpu32((void const   *)k + 8U);
#line 82
  c = tmp___1 + c;
#line 83
  a = a - c;
#line 83
  tmp___2 = rol32(c, 4U);
#line 83
  a = tmp___2 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___3 = rol32(a, 6U);
#line 83
  b = tmp___3 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___4 = rol32(b, 8U);
#line 83
  c = tmp___4 ^ c;
#line 83
  b = b + a;
#line 83
  a = a - c;
#line 83
  tmp___5 = rol32(c, 16U);
#line 83
  a = tmp___5 ^ a;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___6 = rol32(a, 19U);
#line 83
  b = tmp___6 ^ b;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___7 = rol32(b, 4U);
#line 83
  c = tmp___7 ^ c;
#line 83
  b = b + a;
#line 84
  length = length - 12U;
#line 85
  k = k + 12UL;
  ldv_43370: ;
#line 79
  if (length > 12U) {
#line 81
    goto ldv_43369;
  } else {

  }

#line 89
  switch (length) {
  case 12U: 
#line 90
  c = ((unsigned int )*(k + 11UL) << 24) + c;
  case 11U: 
#line 91
  c = ((unsigned int )*(k + 10UL) << 16) + c;
  case 10U: 
#line 92
  c = ((unsigned int )*(k + 9UL) << 8) + c;
  case 9U: 
#line 93
  c = (u32 )*(k + 8UL) + c;
  case 8U: 
#line 94
  b = ((unsigned int )*(k + 7UL) << 24) + b;
  case 7U: 
#line 95
  b = ((unsigned int )*(k + 6UL) << 16) + b;
  case 6U: 
#line 96
  b = ((unsigned int )*(k + 5UL) << 8) + b;
  case 5U: 
#line 97
  b = (u32 )*(k + 4UL) + b;
  case 4U: 
#line 98
  a = ((unsigned int )*(k + 3UL) << 24) + a;
  case 3U: 
#line 99
  a = ((unsigned int )*(k + 2UL) << 16) + a;
  case 2U: 
#line 100
  a = ((unsigned int )*(k + 1UL) << 8) + a;
  case 1U: 
#line 101
  a = (u32 )*k + a;
#line 102
  c = c ^ b;
#line 102
  tmp___8 = rol32(b, 14U);
#line 102
  c = c - tmp___8;
#line 102
  a = a ^ c;
#line 102
  tmp___9 = rol32(c, 11U);
#line 102
  a = a - tmp___9;
#line 102
  b = b ^ a;
#line 102
  tmp___10 = rol32(a, 25U);
#line 102
  b = b - tmp___10;
#line 102
  c = c ^ b;
#line 102
  tmp___11 = rol32(b, 16U);
#line 102
  c = c - tmp___11;
#line 102
  a = a ^ c;
#line 102
  tmp___12 = rol32(c, 4U);
#line 102
  a = a - tmp___12;
#line 102
  b = b ^ a;
#line 102
  tmp___13 = rol32(a, 14U);
#line 102
  b = b - tmp___13;
#line 102
  c = c ^ b;
#line 102
  tmp___14 = rol32(b, 24U);
#line 102
  c = c - tmp___14;
  case 0U: ;
#line 104
  goto ldv_43385;
  }
  ldv_43385: ;
#line 107
  return (c);
}
}
#line 125 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 130 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 133
  tmp = request_threaded_irq(irq, handler, 0, flags, name, dev);
#line 133
  return (tmp);
}
}
#line 178
extern void free_irq(unsigned int  , void * ) ;
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 65 "include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 67
  tmp = skb_network_header(skb);
#line 67
  return ((struct ipv6hdr *)tmp);
}
}
#line 185 "include/linux/if_vlan.h"
__inline static struct sk_buff *vlan_insert_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                u16 vlan_tci ) 
{ 
  struct vlan_ethhdr *veth ;
  int tmp ;
  unsigned char *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 190
  tmp = skb_cow_head(skb, 4U);
#line 190
  if (tmp < 0) {
#line 191
    kfree_skb(skb);
#line 192
    return (0);
  } else {

  }
#line 194
  tmp___0 = skb_push(skb, 4U);
#line 194
  veth = (struct vlan_ethhdr *)tmp___0;
#line 197
  memmove((void *)skb->data, (void const   *)skb->data + 4U, 12UL);
#line 198
  skb->mac_header = skb->mac_header - 4U;
#line 201
  veth->h_vlan_proto = vlan_proto;
#line 204
  tmp___1 = __fswab16((int )vlan_tci);
#line 204
  veth->h_vlan_TCI = tmp___1;
#line 206
  return (skb);
}
}
#line 220 "include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                               u16 vlan_tci ) 
{ 


  {
#line 223
  skb = vlan_insert_tag(skb, (int )vlan_proto, (int )vlan_tci);
#line 224
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 225
    skb->protocol = vlan_proto;
  } else {

  }
#line 226
  return (skb);
}
}
#line 237 "include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                       u16 vlan_tci ) 
{ 


  {
#line 241
  skb->vlan_proto = vlan_proto;
#line 242
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 243
  return (skb);
}
}
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 62 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static char *nic_name(struct pci_dev *pdev ) 
{ 


  {
#line 64
  switch ((int )pdev->device) {
  case 1792: ;
#line 66
  return ((char *)"Emulex OneConnect");
  case 1808: ;
#line 68
  return ((char *)"Emulex OneConnect(be3)");
  case 57888: ;
  case 57896: ;
#line 71
  return ((char *)"Emulex OneConnect(Lancer)");
  case 545: ;
#line 73
  return ((char *)"Emulex BladeEngine3");
  case 1824: ;
  case 1832: ;
#line 76
  return ((char *)"Emulex OneConnect(Skyhawk)");
  default: ;
#line 78
  return ((char *)"Emulex BladeEngine2");
  }
}
}
#line 134 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 136
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 136
  if (tmp != 0L) {
#line 136
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (136), "i" (12UL));
    ldv_49361: ;
#line 136
    goto ldv_49361;
  } else {

  }
#line 137
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 140 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_adv(u16 *index , u16 val , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 142
  tmp = MODULO((int )*index + (int )val, (int )limit);
#line 142
  *index = (u16 )tmp;
#line 143
  return;
}
}
#line 145 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 147
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 147
  *index = (u16 )tmp;
#line 148
  return;
}
}
#line 150 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 152
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 155 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 157
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 165 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
#line 167
  index_inc(& q->head, (int )q->len);
#line 168
  return;
}
}
#line 175 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
#line 177
  index_inc(& q->tail, (int )q->len);
#line 178
  return;
}
}
#line 484
struct ethtool_ops  const  be_ethtool_ops ;
#line 528 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 530
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 534 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 536
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 537
  *dw = *dw & ~ (mask << (int )offset);
#line 538
  *dw = *dw | ((mask & value) << (int )offset);
#line 539
  return;
}
}
#line 548 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 550
  dw = (u32 *)ptr;
#line 551
  return ((*(dw + (unsigned long )dw_offset) >> (int )offset) & mask);
}
}
#line 562 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 564
  return;
}
}
#line 575 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 is_tcp_pkt(struct sk_buff *skb ) 
{ 
  u8 val ;
  struct iphdr *tmp ;
  struct ipv6hdr *tmp___0 ;
  struct iphdr *tmp___1 ;
  struct iphdr *tmp___2 ;

  {
#line 577
  val = 0U;
#line 579
  tmp___2 = ip_hdr((struct sk_buff  const  *)skb);
#line 579
  if ((unsigned int )*((unsigned char *)tmp___2 + 0UL) == 64U) {
#line 580
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 580
    val = (unsigned int )tmp->protocol == 6U;
  } else {
#line 581
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
#line 581
    if ((unsigned int )*((unsigned char *)tmp___1 + 0UL) == 96U) {
#line 582
      tmp___0 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 582
      val = (unsigned int )tmp___0->nexthdr == 6U;
    } else {

    }
  }
#line 584
  return (val);
}
}
#line 587 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 is_udp_pkt(struct sk_buff *skb ) 
{ 
  u8 val ;
  struct iphdr *tmp ;
  struct ipv6hdr *tmp___0 ;
  struct iphdr *tmp___1 ;
  struct iphdr *tmp___2 ;

  {
#line 589
  val = 0U;
#line 591
  tmp___2 = ip_hdr((struct sk_buff  const  *)skb);
#line 591
  if ((unsigned int )*((unsigned char *)tmp___2 + 0UL) == 64U) {
#line 592
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 592
    val = (unsigned int )tmp->protocol == 17U;
  } else {
#line 593
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
#line 593
    if ((unsigned int )*((unsigned char *)tmp___1 + 0UL) == 96U) {
#line 594
      tmp___0 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 594
      val = (unsigned int )tmp___0->nexthdr == 17U;
    } else {

    }
  }
#line 596
  return (val);
}
}
#line 599 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool is_ipv4_pkt(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp ;
  int tmp___0 ;

  {
#line 601
  if ((unsigned int )skb->protocol == 8U) {
#line 601
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 601
    if ((unsigned int )*((unsigned char *)tmp + 0UL) == 64U) {
#line 601
      tmp___0 = 1;
    } else {
#line 601
      tmp___0 = 0;
    }
  } else {
#line 601
    tmp___0 = 0;
  }
#line 601
  return ((bool )tmp___0);
}
}
#line 604 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_vf_eth_addr_generate(struct be_adapter *adapter , u8 *mac ) 
{ 
  u32 addr ;
  size_t __len ;
  void *__ret ;

  {
#line 608
  addr = jhash((void const   *)(adapter->netdev)->dev_addr, 6U, 0U);
#line 610
  *(mac + 5UL) = (unsigned char )addr;
#line 611
  *(mac + 4UL) = (unsigned char )(addr >> 8);
#line 612
  *(mac + 3UL) = (unsigned char )(addr >> 16);
#line 614
  __len = 3UL;
#line 614
  if (__len > 63UL) {
#line 614
    __ret = __memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr, __len);
  } else {
#line 614
    __ret = __builtin_memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr,
                             __len);
  }
#line 616
  return;
}
}
#line 617 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_multi_rxq(struct be_adapter  const  *adapter ) 
{ 


  {
#line 619
  return ((unsigned int )adapter->num_rx_qs > 1U);
}
}
#line 627 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_hw_error(struct be_adapter *adapter ) 
{ 


  {
#line 629
  return ((bool )((int )adapter->eeh_error || (int )adapter->hw_error));
}
}
#line 632 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_clear_all_error(struct be_adapter *adapter ) 
{ 


  {
#line 634
  adapter->eeh_error = 0;
#line 635
  adapter->hw_error = 0;
#line 636
  adapter->fw_timeout = 0;
#line 637
  return;
}
}
#line 639 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_is_wol_excluded(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;

  {
#line 641
  pdev = adapter->pdev;
#line 643
  if ((unsigned int )adapter->virtfn != 0U) {
#line 644
    return (1);
  } else {

  }
#line 646
  switch ((int )pdev->subsystem_device) {
  case 58882: ;
  case 58946: ;
  case 58898: ;
  case 58962: ;
#line 651
  return (1);
  default: ;
#line 653
  return (0);
  }
}
}
#line 657 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static int qnq_async_evt_rcvd(struct be_adapter *adapter ) 
{ 


  {
#line 659
  return ((int )adapter->flags & 2048);
}
}
#line 662
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) ;
#line 664
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) ;
#line 665
void be_parse_stats(struct be_adapter *adapter ) ;
#line 666
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) ;
#line 667
bool be_is_wol_supported(struct be_adapter *adapter ) ;
#line 668
bool be_pause_supported(struct be_adapter *adapter ) ;
#line 669
u32 be_get_fw_log_level(struct be_adapter *adapter ) ;
#line 674
void be_roce_dev_add(struct be_adapter *adapter ) ;
#line 675
void be_roce_dev_remove(struct be_adapter *adapter ) ;
#line 680
void be_roce_dev_open(struct be_adapter *adapter ) ;
#line 681
void be_roce_dev_close(struct be_adapter *adapter ) ;
#line 899 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static struct lancer_pport_stats *pport_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct lancer_cmd_resp_pport_stats *cmd ;

  {
#line 901
  cmd = (struct lancer_cmd_resp_pport_stats *)adapter->stats_cmd.va;
#line 902
  return (& cmd->pport_stats);
}
}
#line 1828
int be_fw_wait_ready(struct be_adapter *adapter ) ;
#line 1829
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) ;
#line 1831
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) ;
#line 1833
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) ;
#line 1835
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) ;
#line 1837
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) ;
#line 1839
int be_cmd_eq_create(struct be_adapter *adapter , struct be_queue_info *eq , int eq_delay ) ;
#line 1841
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) ;
#line 1844
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) ;
#line 1847
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) ;
#line 1849
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) ;
#line 1852
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) ;
#line 1854
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) ;
#line 1856
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) ;
#line 1859
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 1861
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 1863
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) ;
#line 1866
int be_cmd_modify_eqd(struct be_adapter *adapter , u32 eq_id , u32 eqd ) ;
#line 1867
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , bool untagged , bool promiscuous ) ;
#line 1870
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) ;
#line 1871
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) ;
#line 1873
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) ;
#line 1875
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) ;
#line 1877
int be_cmd_reset_function(struct be_adapter *adapter ) ;
#line 1878
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size ) ;
#line 1880
int be_process_mcc(struct be_adapter *adapter ) ;
#line 1885
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) ;
#line 1888
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) ;
#line 1897
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , int offset ) ;
#line 1899
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) ;
#line 1901
int be_cmd_fw_init(struct be_adapter *adapter ) ;
#line 1902
int be_cmd_fw_clean(struct be_adapter *adapter ) ;
#line 1903
void be_async_mcc_enable(struct be_adapter *adapter ) ;
#line 1904
void be_async_mcc_disable(struct be_adapter *adapter ) ;
#line 1914
int be_cmd_get_phy_info(struct be_adapter *adapter ) ;
#line 1915
int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) ;
#line 1916
void be_detect_error(struct be_adapter *adapter ) ;
#line 1917
int be_cmd_get_die_temperature(struct be_adapter *adapter ) ;
#line 1918
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) ;
#line 1919
int be_cmd_req_native_mode(struct be_adapter *adapter ) ;
#line 1922
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) ;
#line 1924
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_active ,
                             u32 *pmac_id , u8 domain ) ;
#line 1927
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) ;
#line 1929
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ) ;
#line 1931
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ) ;
#line 1933
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) ;
#line 1934
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) ;
#line 1940
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) ;
#line 1941
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) ;
#line 1942
int be_cmd_get_func_config(struct be_adapter *adapter ) ;
#line 1943
int be_cmd_get_profile_config(struct be_adapter *adapter , u32 *cap_flags , u16 *txq_count ,
                              u8 domain ) ;
#line 1946
int be_cmd_set_profile_config(struct be_adapter *adapter , u32 bps , u8 domain ) ;
#line 1948
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) ;
#line 1950
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) ;
#line 1951
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) ;
#line 34 "include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 35
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 36
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 66 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 71 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static unsigned int num_vfs  ;
#line 75 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static ushort rx_frag_size  =    2048U;
#line 79 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct pci_device_id  const  be_dev_ids[9U]  = 
#line 79
  {      {6562U, 529U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 545U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1792U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1808U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57888U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57896U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1824U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1832U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 92 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static char const   * const  ue_status_low_desc[32U]  = 
#line 92
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "AXGMAC0",      "AXGMAC1",      "JTAG",      "MPU_INTPEND"};
#line 127 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static char const   * const  ue_status_hi_desc[32U]  = 
#line 127
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "HOST8",      "HOST9",      "NETC", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 163 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static bool be_is_mc(struct be_adapter *adapter ) 
{ 


  {
#line 164
  return ((bool )(((adapter->function_mode & 1024U) != 0U || (adapter->function_mode & 131072U) != 0U) || (adapter->function_mode & 16777216U) != 0U));
}
}
#line 169 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_queue_free(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 171
  mem = & q->dma_mem;
#line 172
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 173
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   0);
#line 175
    mem->va = 0;
  } else {

  }
#line 177
  return;
}
}
#line 179 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_queue_alloc(struct be_adapter *adapter , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 182
  mem = & q->dma_mem;
#line 184
  memset((void *)q, 0, 40UL);
#line 185
  q->len = len;
#line 186
  q->entry_size = entry_size;
#line 187
  mem->size = (u32 )((int )len * (int )entry_size);
#line 188
  mem->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )mem->size, & mem->dma,
                            32976U, 0);
#line 190
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 191
    return (-12);
  } else {

  }
#line 192
  return (0);
}
}
#line 195 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_reg_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  u32 reg ;
  u32 enabled ;

  {
#line 199
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 252, & reg);
#line 201
  enabled = reg & 536870912U;
#line 203
  if (enabled == 0U && (int )enable) {
#line 204
    reg = reg | 536870912U;
  } else
#line 205
  if (enabled != 0U && ! enable) {
#line 206
    reg = reg & 3758096383U;
  } else {
#line 208
    return;
  }
#line 210
  pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 252, reg);
#line 211
  return;
}
}
#line 214 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  int status ;

  {
#line 216
  status = 0;
#line 219
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 220
    return;
  } else {

  }
#line 222
  if ((int )adapter->eeh_error) {
#line 223
    return;
  } else {

  }
#line 225
  status = be_cmd_intr_set(adapter, (int )enable);
#line 226
  if (status != 0) {
#line 227
    be_reg_intr_set(adapter, (int )enable);
  } else {

  }
#line 228
  return;
}
}
#line 230 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rxq_notify(struct be_adapter *adapter , u16 qid , u16 posted ) 
{ 
  u32 val ;

  {
#line 232
  val = 0U;
#line 233
  val = ((u32 )qid & 1023U) | val;
#line 234
  val = (u32 )((int )posted << 24) | val;
#line 236
  __asm__  volatile   ("sfence": : : "memory");
#line 237
  iowrite32(val, (void *)adapter->db + 256U);
#line 238
  return;
}
}
#line 240 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_txq_notify(struct be_adapter *adapter , struct be_tx_obj *txo , u16 posted ) 
{ 
  u32 val ;

  {
#line 243
  val = 0U;
#line 244
  val = ((u32 )txo->q.id & 2047U) | val;
#line 245
  val = (u32 )(((int )posted & 16383) << 16) | val;
#line 247
  __asm__  volatile   ("sfence": : : "memory");
#line 248
  iowrite32(val, (void *)adapter->db + (unsigned long )txo->db_offset);
#line 249
  return;
}
}
#line 251 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_eq_notify(struct be_adapter *adapter , u16 qid , bool arm , bool clear_int ,
                         u16 num_popped ) 
{ 
  u32 val ;

  {
#line 254
  val = 0U;
#line 255
  val = ((u32 )qid & 511U) | val;
#line 256
  val = (u32 )(((int )qid & 15872) << 2) | val;
#line 259
  if ((int )adapter->eeh_error) {
#line 260
    return;
  } else {

  }
#line 262
  if ((int )arm) {
#line 263
    val = val | 536870912U;
  } else {

  }
#line 264
  if ((int )clear_int) {
#line 265
    val = val | 512U;
  } else {

  }
#line 266
  val = val | 1024U;
#line 267
  val = (u32 )((int )num_popped << 16) | val;
#line 268
  iowrite32(val, (void *)adapter->db + 288U);
#line 269
  return;
}
}
#line 271 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) 
{ 
  u32 val ;

  {
#line 273
  val = 0U;
#line 274
  val = ((u32 )qid & 1023U) | val;
#line 275
  val = (u32 )(((int )qid & 31744) << 1) | val;
#line 278
  if ((int )adapter->eeh_error) {
#line 279
    return;
  } else {

  }
#line 281
  if ((int )arm) {
#line 282
    val = val | 536870912U;
  } else {

  }
#line 283
  val = (u32 )((int )num_popped << 16) | val;
#line 284
  iowrite32(val, (void *)adapter->db + 288U);
#line 285
  return;
}
}
#line 287 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_mac_addr_set(struct net_device *netdev , void *p ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct sockaddr *addr ;
  int status ;
  u8 current_mac[6U] ;
  u32 pmac_id ;
  bool active_mac ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;

  {
#line 289
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 289
  adapter = (struct be_adapter *)tmp;
#line 290
  addr = (struct sockaddr *)p;
#line 291
  status = 0;
#line 293
  pmac_id = *(adapter->pmac_id);
#line 294
  active_mac = 1;
#line 296
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
#line 296
  if (tmp___0) {
#line 296
    tmp___1 = 0;
  } else {
#line 296
    tmp___1 = 1;
  }
#line 296
  if (tmp___1) {
#line 297
    return (-99);
  } else {

  }
#line 304
  if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 305
    status = be_cmd_mac_addr_query(adapter, (u8 *)(& current_mac), 0, (u32 )adapter->if_handle,
                                   0U);
#line 307
    if (status == 0) {
#line 307
      tmp___2 = memcmp((void const   *)(& current_mac), (void const   *)(& addr->sa_data),
                       6UL);
#line 307
      if (tmp___2 == 0) {
#line 308
        goto done;
      } else {
#line 310
        goto err;
      }
    } else {
#line 310
      goto err;
    }
  } else {

  }
#line 313
  tmp___3 = memcmp((void const   *)(& addr->sa_data), (void const   *)netdev->dev_addr,
                   6UL);
#line 313
  if (tmp___3 == 0) {
#line 314
    goto done;
  } else {

  }
#line 319
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 320
    be_cmd_get_mac_from_list(adapter, (u8 *)(& current_mac), & active_mac, & pmac_id,
                             0);
  } else {

  }
#line 323
  status = be_cmd_pmac_add(adapter, (u8 *)(& addr->sa_data), (u32 )adapter->if_handle,
                           adapter->pmac_id, 0U);
#line 327
  if (status != 0) {
#line 328
    goto err;
  } else {

  }
#line 330
  if ((int )active_mac) {
#line 331
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )pmac_id, 0U);
  } else {

  }
  done: 
#line 334
  __len = (size_t )netdev->addr_len;
#line 334
  __ret = __builtin_memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data),
                           __len);
#line 335
  return (0);
  err: 
#line 337
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "MAC %pM set Failed\n",
          (char *)(& addr->sa_data));
#line 338
  return (status);
}
}
#line 342 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void *hw_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_cmd_resp_get_stats_v0 *cmd ;
  struct be_cmd_resp_get_stats_v1 *cmd___0 ;

  {
#line 344
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 345
    cmd = (struct be_cmd_resp_get_stats_v0 *)adapter->stats_cmd.va;
#line 347
    return ((void *)(& cmd->hw_stats));
  } else {
#line 349
    cmd___0 = (struct be_cmd_resp_get_stats_v1 *)adapter->stats_cmd.va;
#line 351
    return ((void *)(& cmd___0->hw_stats));
  }
}
}
#line 356 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void *be_erx_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_hw_stats_v1 *hw_stats___0 ;
  void *tmp___0 ;

  {
#line 358
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 359
    tmp = hw_stats_from_cmd(adapter);
#line 359
    hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 361
    return ((void *)(& hw_stats->erx));
  } else {
#line 363
    tmp___0 = hw_stats_from_cmd(adapter);
#line 363
    hw_stats___0 = (struct be_hw_stats_v1 *)tmp___0;
#line 365
    return ((void *)(& hw_stats___0->erx));
  }
}
}
#line 369 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void populate_be_v0_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v0 *rxf_stats ;
  struct be_port_rxf_stats_v0 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 371
  tmp = hw_stats_from_cmd(adapter);
#line 371
  hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 372
  pmem_sts = & hw_stats->pmem;
#line 373
  rxf_stats = & hw_stats->rxf;
#line 374
  port_stats = (struct be_port_rxf_stats_v0 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 376
  drvs = & adapter->drv_stats;
#line 378
  swap_dws((void *)hw_stats, 1060);
#line 379
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 380
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 381
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 382
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 383
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 384
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 385
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 386
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 387
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 388
  drvs->rxpp_fifo_overflow_drop = port_stats->rx_fifo_overflow;
#line 389
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 390
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 391
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 392
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 393
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow;
#line 394
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 396
  drvs->rx_address_filtered = port_stats->rx_address_filtered + port_stats->rx_vlan_filtered;
#line 399
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 402
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 403
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 405
  if (adapter->port_num != 0U) {
#line 406
    drvs->jabber_events = rxf_stats->port1_jabber_events;
  } else {
#line 408
    drvs->jabber_events = rxf_stats->port0_jabber_events;
  }
#line 409
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 410
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 411
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 412
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 413
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 414
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 415
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 416
  return;
}
}
#line 418 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void populate_be_v1_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v1 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v1 *rxf_stats ;
  struct be_port_rxf_stats_v1 *port_stats ;
  struct be_drv_stats *drvs ;

  {
#line 420
  tmp = hw_stats_from_cmd(adapter);
#line 420
  hw_stats = (struct be_hw_stats_v1 *)tmp;
#line 421
  pmem_sts = & hw_stats->pmem;
#line 422
  rxf_stats = & hw_stats->rxf;
#line 423
  port_stats = (struct be_port_rxf_stats_v1 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 425
  drvs = & adapter->drv_stats;
#line 427
  swap_dws((void *)hw_stats, 1848);
#line 428
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 429
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 430
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 431
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 432
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 433
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 434
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 435
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 436
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 437
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 438
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 439
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 440
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 441
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 442
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 443
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 445
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 447
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 448
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 450
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 451
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 452
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 453
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 454
  drvs->jabber_events = port_stats->jabber_events;
#line 455
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 456
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 457
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 458
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 459
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 460
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 461
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 462
  return;
}
}
#line 464 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void populate_lancer_stats(struct be_adapter *adapter ) 
{ 
  struct be_drv_stats *drvs ;
  struct lancer_pport_stats *pport_stats ;
  struct lancer_pport_stats *tmp ;

  {
#line 467
  drvs = & adapter->drv_stats;
#line 468
  tmp = pport_stats_from_cmd(adapter);
#line 468
  pport_stats = tmp;
#line 471
  swap_dws((void *)pport_stats, 656);
#line 472
  drvs->rx_pause_frames = pport_stats->rx_pause_frames_lo;
#line 473
  drvs->rx_crc_errors = pport_stats->rx_crc_errors_lo;
#line 474
  drvs->rx_control_frames = pport_stats->rx_control_frames_lo;
#line 475
  drvs->rx_in_range_errors = pport_stats->rx_in_range_errors;
#line 476
  drvs->rx_frame_too_long = pport_stats->rx_frames_too_long_lo;
#line 477
  drvs->rx_dropped_runt = pport_stats->rx_dropped_runt;
#line 478
  drvs->rx_ip_checksum_errs = pport_stats->rx_ip_checksum_errors;
#line 479
  drvs->rx_tcp_checksum_errs = pport_stats->rx_tcp_checksum_errors;
#line 480
  drvs->rx_udp_checksum_errs = pport_stats->rx_udp_checksum_errors;
#line 481
  drvs->rx_dropped_tcp_length = pport_stats->rx_dropped_invalid_tcp_length;
#line 483
  drvs->rx_dropped_too_small = pport_stats->rx_dropped_too_small;
#line 484
  drvs->rx_dropped_too_short = pport_stats->rx_dropped_too_short;
#line 485
  drvs->rx_out_range_errors = pport_stats->rx_out_of_range_errors;
#line 486
  drvs->rx_dropped_header_too_small = pport_stats->rx_dropped_header_too_small;
#line 488
  drvs->rx_input_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 489
  drvs->rx_address_filtered = pport_stats->rx_address_filtered + pport_stats->rx_vlan_filtered;
#line 492
  drvs->rx_alignment_symbol_errors = pport_stats->rx_symbol_errors_lo;
#line 493
  drvs->rxpp_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 494
  drvs->tx_pauseframes = pport_stats->tx_pause_frames_lo;
#line 495
  drvs->tx_controlframes = pport_stats->tx_control_frames_lo;
#line 496
  drvs->jabber_events = pport_stats->rx_jabbers;
#line 497
  drvs->forwarded_packets = pport_stats->num_forwards_lo;
#line 498
  drvs->rx_drops_mtu = pport_stats->rx_drops_mtu_lo;
#line 499
  drvs->rx_drops_too_many_frags = pport_stats->rx_drops_too_many_frags_lo;
#line 501
  return;
}
}
#line 503 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void accumulate_16bit_val(u32 *acc , u16 val ) 
{ 
  bool wrapped ;
  u32 newacc ;

  {
#line 507
  wrapped = (u32 )val < (*acc & 65535U);
#line 508
  newacc = (*acc & 4294901760U) + (u32 )val;
#line 510
  if ((int )wrapped) {
#line 511
    newacc = newacc + 65536U;
  } else {

  }
#line 512
  *((u32 volatile   *)acc) = newacc;
#line 513
  return;
}
}
#line 515 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void populate_erx_stats(struct be_adapter *adapter , struct be_rx_obj *rxo , u32 erx_stat ) 
{ 


  {
#line 519
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 520
    rxo->stats.rx_drops_no_frags = erx_stat;
  } else {
#line 525
    accumulate_16bit_val(& rxo->stats.rx_drops_no_frags, (int )((unsigned short )erx_stat));
  }
#line 527
  return;
}
}
#line 529 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void be_parse_stats(struct be_adapter *adapter ) 
{ 
  struct be_erx_stats_v1 *erx ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  int i ;
  u32 erx_stat ;

  {
#line 531
  tmp = be_erx_stats_from_cmd(adapter);
#line 531
  erx = (struct be_erx_stats_v1 *)tmp;
#line 536
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 537
    populate_lancer_stats(adapter);
  } else {
#line 539
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 540
      populate_be_v0_stats(adapter);
    } else {
#line 543
      populate_be_v1_stats(adapter);
    }
#line 546
    i = 0;
#line 546
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 546
    goto ldv_51361;
    ldv_51360: 
#line 547
    erx_stat = erx->rx_drops_no_fragments[(int )rxo->q.id];
#line 548
    populate_erx_stats(adapter, rxo, erx_stat);
#line 546
    i = i + 1;
#line 546
    rxo = rxo + 1;
    ldv_51361: ;
#line 546
    if ((u32 )i < adapter->num_rx_qs) {
#line 548
      goto ldv_51360;
    } else {

    }

  }
#line 554
  return;
}
}
#line 553 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct rtnl_link_stats64 *be_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_drv_stats *drvs ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 pkts ;
  u64 bytes ;
  unsigned int start ;
  int i ;
  struct be_rx_stats  const  *rx_stats ;
  bool tmp___0 ;
  struct be_tx_stats  const  *tx_stats ;
  bool tmp___1 ;

  {
#line 556
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 556
  adapter = (struct be_adapter *)tmp;
#line 557
  drvs = & adapter->drv_stats;
#line 564
  i = 0;
#line 564
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 564
  goto ldv_51379;
  ldv_51378: 
#line 565
  rx_stats = (struct be_rx_stats  const  *)(& rxo->stats);
  ldv_51376: 
#line 567
  start = u64_stats_fetch_begin_bh(& rx_stats->sync);
#line 568
  pkts = rxo->stats.rx_pkts;
#line 569
  bytes = rxo->stats.rx_bytes;
#line 570
  tmp___0 = u64_stats_fetch_retry_bh(& rx_stats->sync, start);
#line 570
  if ((int )tmp___0) {
#line 572
    goto ldv_51376;
  } else {

  }
#line 571
  stats->rx_packets = stats->rx_packets + pkts;
#line 572
  stats->rx_bytes = stats->rx_bytes + bytes;
#line 573
  stats->multicast = stats->multicast + (__u64 )rxo->stats.rx_mcast_pkts;
#line 574
  stats->rx_dropped = stats->rx_dropped + (__u64 )(rxo->stats.rx_drops_no_skbs + rxo->stats.rx_drops_no_frags);
#line 564
  i = i + 1;
#line 564
  rxo = rxo + 1;
  ldv_51379: ;
#line 564
  if ((u32 )i < adapter->num_rx_qs) {
#line 566
    goto ldv_51378;
  } else {

  }
#line 578
  i = 0;
#line 578
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 578
  goto ldv_51385;
  ldv_51384: 
#line 579
  tx_stats = (struct be_tx_stats  const  *)(& txo->stats);
  ldv_51382: 
#line 581
  start = u64_stats_fetch_begin_bh(& tx_stats->sync);
#line 582
  pkts = txo->stats.tx_pkts;
#line 583
  bytes = txo->stats.tx_bytes;
#line 584
  tmp___1 = u64_stats_fetch_retry_bh(& tx_stats->sync, start);
#line 584
  if ((int )tmp___1) {
#line 586
    goto ldv_51382;
  } else {

  }
#line 585
  stats->tx_packets = stats->tx_packets + pkts;
#line 586
  stats->tx_bytes = stats->tx_bytes + bytes;
#line 578
  i = i + 1;
#line 578
  txo = txo + 1;
  ldv_51385: ;
#line 578
  if ((u32 )i < adapter->num_tx_qs) {
#line 580
    goto ldv_51384;
  } else {

  }
#line 590
  stats->rx_errors = (__u64 )(((((((((drvs->rx_crc_errors + drvs->rx_alignment_symbol_errors) + drvs->rx_in_range_errors) + drvs->rx_out_range_errors) + drvs->rx_frame_too_long) + drvs->rx_dropped_too_small) + drvs->rx_dropped_too_short) + drvs->rx_dropped_header_too_small) + drvs->rx_dropped_tcp_length) + drvs->rx_dropped_runt);
#line 602
  stats->rx_length_errors = (__u64 )((drvs->rx_in_range_errors + drvs->rx_out_range_errors) + drvs->rx_frame_too_long);
#line 606
  stats->rx_crc_errors = (__u64 )drvs->rx_crc_errors;
#line 609
  stats->rx_frame_errors = (__u64 )drvs->rx_alignment_symbol_errors;
#line 613
  stats->rx_fifo_errors = (__u64 )((drvs->rxpp_fifo_overflow_drop + drvs->rx_input_fifo_overflow_drop) + drvs->rx_drops_no_pbuf);
#line 616
  return (stats);
}
}
#line 619 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) 
{ 
  struct net_device *netdev ;

  {
#line 621
  netdev = adapter->netdev;
#line 623
  if ((adapter->flags & 1U) == 0U) {
#line 624
    netif_carrier_off(netdev);
#line 625
    adapter->flags = adapter->flags | 1U;
  } else {

  }
#line 628
  if ((int )link_status & 1) {
#line 629
    netif_carrier_on(netdev);
  } else {
#line 631
    netif_carrier_off(netdev);
  }
#line 632
  return;
}
}
#line 634 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_tx_stats_update(struct be_tx_obj *txo , u32 wrb_cnt , u32 copied ,
                               u32 gso_segs , bool stopped ) 
{ 
  struct be_tx_stats *stats ;

  {
#line 637
  stats = & txo->stats;
#line 639
  u64_stats_update_begin(& stats->sync);
#line 640
  stats->tx_reqs = stats->tx_reqs + 1ULL;
#line 641
  stats->tx_wrbs = stats->tx_wrbs + (u64 )wrb_cnt;
#line 642
  stats->tx_bytes = stats->tx_bytes + (u64 )copied;
#line 643
  stats->tx_pkts = stats->tx_pkts + (gso_segs != 0U ? (u64 )gso_segs : 1ULL);
#line 644
  if ((int )stopped) {
#line 645
    stats->tx_stops = stats->tx_stops + 1U;
  } else {

  }
#line 646
  u64_stats_update_begin(& stats->sync);
#line 647
  return;
}
}
#line 650 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static u32 wrb_cnt_for_skb(struct be_adapter *adapter , struct sk_buff *skb , bool *dummy ) 
{ 
  int cnt ;
  unsigned char *tmp ;
  long tmp___0 ;

  {
#line 653
  cnt = skb->len > skb->data_len;
#line 655
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 655
  cnt = (int )((struct skb_shared_info *)tmp)->nr_frags + cnt;
#line 658
  cnt = cnt + 1;
#line 659
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (cnt & 1) == 0) {
#line 660
    *dummy = 0;
  } else {
#line 663
    cnt = cnt + 1;
#line 664
    *dummy = 1;
  }
#line 666
  tmp___0 = ldv__builtin_expect(cnt > 30, 0L);
#line 666
  if (tmp___0 != 0L) {
#line 666
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (666), "i" (12UL));
    ldv_51406: ;
#line 666
    goto ldv_51406;
  } else {

  }
#line 667
  return ((u32 )cnt);
}
}
#line 670 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static void wrb_fill(struct be_eth_wrb *wrb , u64 addr , int len ) 
{ 


  {
#line 672
  wrb->frag_pa_hi = (unsigned int )(addr >> 32ULL);
#line 673
  wrb->frag_pa_lo = (u32 )addr;
#line 674
  wrb->frag_len = (u32 )len & 65535U;
#line 675
  wrb->rsvd0 = 0U;
#line 676
  return;
}
}
#line 678 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static u16 be_get_tx_vlan_tag(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  u8 vlan_prio ;
  u16 vlan_tag ;

  {
#line 684
  vlan_tag = (unsigned int )skb->vlan_tci & 61439U;
#line 685
  vlan_prio = (u8 )((int )vlan_tag >> 13);
#line 687
  if ((((int )adapter->vlan_prio_bmap >> (int )vlan_prio) & 1) == 0) {
#line 688
    vlan_tag = (u16 )(((int )((short )vlan_tag) & 8191) | (int )((short )adapter->recommended_prio));
  } else {

  }
#line 691
  return (vlan_tag);
}
}
#line 694 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void wrb_fill_hdr(struct be_adapter *adapter , struct be_eth_hdr_wrb *hdr ,
                         struct sk_buff *skb , u32 wrb_cnt , u32 len , bool skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  u32 tmp ;
  u32 tmp___0 ;
  unsigned char *tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  bool tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  bool tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;

  {
#line 699
  memset((void *)hdr, 0, 16UL);
#line 701
  tmp = amap_mask(1U);
#line 701
  amap_set((void *)hdr, 2U, tmp, 2U, 1U);
#line 703
  tmp___9 = skb_is_gso((struct sk_buff  const  *)skb);
#line 703
  if ((int )tmp___9) {
#line 704
    tmp___0 = amap_mask(1U);
#line 704
    amap_set((void *)hdr, 2U, tmp___0, 9U, 1U);
#line 705
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 705
    tmp___2 = amap_mask(14U);
#line 705
    amap_set((void *)hdr, 2U, tmp___2, 18U, (u32 )((struct skb_shared_info *)tmp___1)->gso_size);
#line 707
    tmp___4 = skb_is_gso_v6((struct sk_buff  const  *)skb);
#line 707
    if ((int )tmp___4 && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 708
      tmp___3 = amap_mask(1U);
#line 708
      amap_set((void *)hdr, 2U, tmp___3, 4U, 1U);
    } else {

    }
  } else
#line 709
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 12U) {
#line 710
    tmp___8 = is_tcp_pkt(skb);
#line 710
    if ((unsigned int )tmp___8 != 0U) {
#line 711
      tmp___5 = amap_mask(1U);
#line 711
      amap_set((void *)hdr, 2U, tmp___5, 8U, 1U);
    } else {
#line 712
      tmp___7 = is_udp_pkt(skb);
#line 712
      if ((unsigned int )tmp___7 != 0U) {
#line 713
        tmp___6 = amap_mask(1U);
#line 713
        amap_set((void *)hdr, 2U, tmp___6, 7U, 1U);
      } else {

      }
    }
  } else {

  }
#line 716
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 717
    tmp___10 = amap_mask(1U);
#line 717
    amap_set((void *)hdr, 2U, tmp___10, 10U, 1U);
#line 718
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
#line 719
    tmp___11 = amap_mask(16U);
#line 719
    amap_set((void *)hdr, 3U, tmp___11, 16U, (u32 )vlan_tag);
  } else {

  }
#line 723
  tmp___12 = amap_mask(1U);
#line 723
  amap_set((void *)hdr, 2U, tmp___12, 0U, (u32 )(! skip_hw_vlan));
#line 724
  tmp___13 = amap_mask(1U);
#line 724
  amap_set((void *)hdr, 2U, tmp___13, 1U, 1U);
#line 725
  tmp___14 = amap_mask(5U);
#line 725
  amap_set((void *)hdr, 2U, tmp___14, 13U, wrb_cnt);
#line 726
  tmp___15 = amap_mask(16U);
#line 726
  amap_set((void *)hdr, 3U, tmp___15, 0U, len);
#line 727
  return;
}
}
#line 729 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void unmap_tx_frag(struct device *dev , struct be_eth_wrb *wrb , bool unmap_single ) 
{ 
  dma_addr_t dma ;

  {
#line 734
  swap_dws((void *)wrb, 16);
#line 736
  dma = ((unsigned long long )wrb->frag_pa_hi << 32) | (unsigned long long )wrb->frag_pa_lo;
#line 737
  if (wrb->frag_len != 0U) {
#line 738
    if ((int )unmap_single) {
#line 739
      dma_unmap_single_attrs(dev, dma, (size_t )wrb->frag_len, 1, 0);
    } else {
#line 742
      dma_unmap_page(dev, dma, (size_t )wrb->frag_len, 1);
    }
  } else {

  }
#line 743
  return;
}
}
#line 746 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int make_tx_wrbs(struct be_adapter *adapter , struct be_queue_info *txq , struct sk_buff *skb ,
                        u32 wrb_cnt , bool dummy_wrb , bool skip_hw_vlan ) 
{ 
  dma_addr_t busaddr ;
  int i ;
  int copied ;
  struct device *dev ;
  struct sk_buff *first_skb ;
  struct be_eth_wrb *wrb ;
  struct be_eth_hdr_wrb *hdr ;
  bool map_single ;
  u16 map_head ;
  void *tmp ;
  int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct skb_frag_struct  const  *frag ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 751
  copied = 0;
#line 752
  dev = & (adapter->pdev)->dev;
#line 753
  first_skb = skb;
#line 756
  map_single = 0;
#line 759
  tmp = queue_head_node(txq);
#line 759
  hdr = (struct be_eth_hdr_wrb *)tmp;
#line 760
  queue_head_inc(txq);
#line 761
  map_head = txq->head;
#line 763
  if (skb->len > skb->data_len) {
#line 764
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 764
    len = (int )tmp___0;
#line 765
    busaddr = dma_map_single_attrs(dev, (void *)skb->data, (size_t )len, 1, 0);
#line 766
    tmp___1 = dma_mapping_error(dev, busaddr);
#line 766
    if (tmp___1 != 0) {
#line 767
      goto dma_err;
    } else {

    }
#line 768
    map_single = 1;
#line 769
    tmp___2 = queue_head_node(txq);
#line 769
    wrb = (struct be_eth_wrb *)tmp___2;
#line 770
    wrb_fill(wrb, busaddr, len);
#line 771
    swap_dws((void *)wrb, 16);
#line 772
    queue_head_inc(txq);
#line 773
    copied = copied + len;
  } else {

  }
#line 776
  i = 0;
#line 776
  goto ldv_51454;
  ldv_51453: 
#line 777
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 777
  frag = (struct skb_frag_struct  const  *)(& ((struct skb_shared_info *)tmp___3)->frags) + (unsigned long )i;
#line 779
  tmp___4 = skb_frag_size(frag);
#line 779
  busaddr = skb_frag_dma_map(dev, frag, 0UL, (size_t )tmp___4, 1);
#line 781
  tmp___5 = dma_mapping_error(dev, busaddr);
#line 781
  if (tmp___5 != 0) {
#line 782
    goto dma_err;
  } else {

  }
#line 783
  tmp___6 = queue_head_node(txq);
#line 783
  wrb = (struct be_eth_wrb *)tmp___6;
#line 784
  tmp___7 = skb_frag_size(frag);
#line 784
  wrb_fill(wrb, busaddr, (int )tmp___7);
#line 785
  swap_dws((void *)wrb, 16);
#line 786
  queue_head_inc(txq);
#line 787
  tmp___8 = skb_frag_size(frag);
#line 787
  copied = (int )(tmp___8 + (unsigned int )copied);
#line 776
  i = i + 1;
  ldv_51454: 
#line 776
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 776
  if ((int )((struct skb_shared_info *)tmp___9)->nr_frags > i) {
#line 778
    goto ldv_51453;
  } else {

  }

#line 790
  if ((int )dummy_wrb) {
#line 791
    tmp___10 = queue_head_node(txq);
#line 791
    wrb = (struct be_eth_wrb *)tmp___10;
#line 792
    wrb_fill(wrb, 0ULL, 0);
#line 793
    swap_dws((void *)wrb, 16);
#line 794
    queue_head_inc(txq);
  } else {

  }
#line 797
  wrb_fill_hdr(adapter, hdr, first_skb, wrb_cnt, (u32 )copied, (int )skip_hw_vlan);
#line 798
  swap_dws((void *)hdr, 16);
#line 800
  return (copied);
  dma_err: 
#line 802
  txq->head = map_head;
#line 803
  goto ldv_51457;
  ldv_51456: 
#line 804
  tmp___11 = queue_head_node(txq);
#line 804
  wrb = (struct be_eth_wrb *)tmp___11;
#line 805
  unmap_tx_frag(dev, wrb, (int )map_single);
#line 806
  map_single = 0;
#line 807
  copied = (int )((u32 )copied - wrb->frag_len);
#line 808
  queue_head_inc(txq);
  ldv_51457: ;
#line 803
  if (copied != 0) {
#line 805
    goto ldv_51456;
  } else {

  }

#line 810
  return (0);
}
}
#line 813 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct sk_buff *be_insert_vlan_in_pkt(struct be_adapter *adapter , struct sk_buff *skb ,
                                             bool *skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 817
  vlan_tag = 0U;
#line 819
  skb = skb_share_check(skb, 32U);
#line 820
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 820
  if (tmp != 0L) {
#line 821
    return (skb);
  } else {

  }
#line 823
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 824
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
#line 825
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 826
    if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 827
      skb->vlan_tci = 0U;
    } else {

    }
  } else {

  }
#line 830
  tmp___0 = qnq_async_evt_rcvd(adapter);
#line 830
  if (tmp___0 != 0 && (unsigned int )adapter->pvid != 0U) {
#line 831
    if ((unsigned int )vlan_tag == 0U) {
#line 832
      vlan_tag = adapter->pvid;
    } else {

    }
#line 833
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 834
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 837
  if ((unsigned int )vlan_tag != 0U) {
#line 838
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 839
    tmp___1 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 839
    if (tmp___1 != 0L) {
#line 840
      return (skb);
    } else {

    }
#line 842
    skb->vlan_tci = 0U;
  } else {

  }
#line 846
  if ((unsigned int )adapter->qnq_vid != 0U) {
#line 847
    vlan_tag = adapter->qnq_vid;
#line 848
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 849
    tmp___2 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 849
    if (tmp___2 != 0L) {
#line 850
      return (skb);
    } else {

    }
#line 851
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 852
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 855
  return (skb);
}
}
#line 858 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool be_ipv6_exthdr_check(struct sk_buff *skb ) 
{ 
  struct ethhdr *eh ;
  u16 offset ;
  struct ipv6hdr *ip6h ;
  struct ipv6_opt_hdr *ehdr ;

  {
#line 860
  eh = (struct ethhdr *)skb->data;
#line 861
  offset = 14U;
#line 863
  if ((unsigned int )eh->h_proto == 56710U) {
#line 864
    ip6h = (struct ipv6hdr *)skb->data + (unsigned long )offset;
#line 866
    offset = (unsigned int )offset + 40U;
#line 867
    if ((unsigned int )ip6h->nexthdr != 6U && (unsigned int )ip6h->nexthdr != 17U) {
#line 869
      ehdr = (struct ipv6_opt_hdr *)skb->data + (unsigned long )offset;
#line 873
      if ((unsigned int )ehdr->hdrlen == 255U) {
#line 874
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 877
  return (0);
}
}
#line 880 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vlan_tag_tx_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 


  {
#line 882
  return ((((int )skb->vlan_tci & 4096) != 0 || (unsigned int )adapter->pvid != 0U) || (unsigned int )adapter->qnq_vid != 0U);
}
}
#line 885 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_ipv6_tx_stall_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 887
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 887
    tmp = be_ipv6_exthdr_check(skb);
#line 887
    if ((int )tmp) {
#line 887
      tmp___0 = 1;
    } else {
#line 887
      tmp___0 = 0;
    }
  } else {
#line 887
    tmp___0 = 0;
  }
#line 887
  return (tmp___0);
}
}
#line 891 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static netdev_tx_t be_xmit(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_tx_obj *txo ;
  u16 tmp___0 ;
  struct be_queue_info *txq ;
  struct iphdr *ip ;
  u32 wrb_cnt ;
  u32 copied ;
  u32 start ;
  u32 eth_hdr_len ;
  bool dummy_wrb ;
  bool stopped ;
  bool skip_hw_vlan ;
  struct vlan_ethhdr *veh ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  bool tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int gso_segs ;
  unsigned char *tmp___17 ;
  long tmp___18 ;
  u16 tmp___19 ;
  int tmp___20 ;

  {
#line 894
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 894
  adapter = (struct be_adapter *)tmp;
#line 895
  tmp___0 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 895
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )tmp___0;
#line 896
  txq = & txo->q;
#line 897
  ip = 0;
#line 898
  wrb_cnt = 0U;
#line 898
  copied = 0U;
#line 899
  start = (u32 )txq->head;
#line 900
  stopped = 0;
#line 901
  skip_hw_vlan = 0;
#line 902
  veh = (struct vlan_ethhdr *)skb->data;
#line 904
  tmp___1 = __fswab16((int )skb->protocol);
#line 904
  eth_hdr_len = (unsigned int )tmp___1 == 33024U ? 18U : 14U;
#line 910
  if (skb->len <= 60U && ((int )skb->vlan_tci & 4096) != 0) {
#line 910
    tmp___3 = is_ipv4_pkt(skb);
#line 910
    if ((int )tmp___3) {
#line 911
      ip = ip_hdr((struct sk_buff  const  *)skb);
#line 912
      tmp___2 = __fswab16((int )ip->tot_len);
#line 912
      pskb_trim(skb, (u32 )tmp___2 + eth_hdr_len);
    } else {

    }
  } else {

  }
#line 918
  if ((adapter->function_mode & 16777216U) != 0U && (unsigned int )veh->h_vlan_proto == 129U) {
#line 920
    skip_hw_vlan = 1;
  } else {

  }
#line 926
  if ((unsigned int )*((unsigned char *)skb + 124UL) != 12U && ((int )skb->vlan_tci & 4096) != 0) {
#line 928
    skb = be_insert_vlan_in_pkt(adapter, skb, & skip_hw_vlan);
#line 929
    tmp___4 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
#line 929
    if (tmp___4 != 0L) {
#line 930
      goto tx_drop;
    } else {

    }
  } else {

  }
#line 937
  tmp___5 = be_ipv6_tx_stall_chk(adapter, skb);
#line 937
  tmp___6 = ldv__builtin_expect(tmp___5 != 0, 0L);
#line 937
  if (tmp___6 != 0L) {
#line 937
    tmp___7 = ldv__builtin_expect((unsigned int )adapter->pvid != 0U, 0L);
#line 937
    if (tmp___7 != 0L) {
#line 937
      tmp___9 = 1;
    } else {
#line 937
      tmp___8 = ldv__builtin_expect((unsigned int )adapter->qnq_vid != 0U, 0L);
#line 937
      if (tmp___8 != 0L) {
#line 937
        tmp___9 = 1;
      } else {
#line 937
        tmp___9 = 0;
      }
    }
#line 937
    if (tmp___9 != 0) {
#line 937
      tmp___10 = 1;
    } else {
#line 937
      tmp___10 = 0;
    }
  } else {
#line 937
    tmp___10 = 0;
  }
#line 937
  if (tmp___10 != 0) {
#line 937
    tmp___11 = qnq_async_evt_rcvd(adapter);
#line 937
    tmp___12 = ldv__builtin_expect(tmp___11 == 0, 0L);
#line 937
    if (tmp___12 != 0L) {
#line 940
      goto tx_drop;
    } else {

    }
  } else {

  }
#line 948
  tmp___14 = be_ipv6_tx_stall_chk(adapter, skb);
#line 948
  if (tmp___14 != 0) {
#line 948
    tmp___15 = be_vlan_tag_tx_chk(adapter, skb);
#line 948
    if (tmp___15 != 0) {
#line 950
      skb = be_insert_vlan_in_pkt(adapter, skb, & skip_hw_vlan);
#line 951
      tmp___13 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                                  0L);
#line 951
      if (tmp___13 != 0L) {
#line 952
        goto tx_drop;
      } else {

      }
    } else {

    }
  } else {

  }
#line 955
  wrb_cnt = wrb_cnt_for_skb(adapter, skb, & dummy_wrb);
#line 957
  tmp___16 = make_tx_wrbs(adapter, txq, skb, wrb_cnt, (int )dummy_wrb, (int )skip_hw_vlan);
#line 957
  copied = (u32 )tmp___16;
#line 959
  if (copied != 0U) {
#line 960
    tmp___17 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 960
    gso_segs = (int )((struct skb_shared_info *)tmp___17)->gso_segs;
#line 963
    tmp___18 = ldv__builtin_expect((unsigned long )txo->sent_skb_list[start] != (unsigned long )((struct sk_buff *)0),
                                0L);
#line 963
    if (tmp___18 != 0L) {
#line 963
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                           "i" (963), "i" (12UL));
      ldv_51498: ;
#line 963
      goto ldv_51498;
    } else {

    }
#line 964
    txo->sent_skb_list[start] = skb;
#line 970
    atomic_add((int )wrb_cnt, & txq->used);
#line 971
    tmp___20 = atomic_read((atomic_t const   *)(& txq->used));
#line 971
    if (tmp___20 + 30 >= (int )txq->len) {
#line 973
      tmp___19 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 973
      netif_stop_subqueue(netdev, (int )tmp___19);
#line 974
      stopped = 1;
    } else {

    }
#line 977
    be_txq_notify(adapter, txo, (int )((u16 )wrb_cnt));
#line 979
    be_tx_stats_update(txo, wrb_cnt, copied, (u32 )gso_segs, (int )stopped);
  } else {
#line 981
    txq->head = (u16 )start;
#line 982
    dev_kfree_skb_any(skb);
  }
  tx_drop: ;
#line 985
  return (0);
}
}
#line 988 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 990
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 990
  adapter = (struct be_adapter *)tmp;
#line 991
  if (new_mtu <= 255 || new_mtu > 9000) {
#line 994
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU must be between %d and %d bytes\n",
              256, 9000);
#line 998
    return (-22);
  } else {

  }
#line 1000
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU changed from %d to %d bytes\n",
            netdev->mtu, new_mtu);
#line 1002
  netdev->mtu = (unsigned int )new_mtu;
#line 1003
  return (0);
}
}
#line 1010 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vid_config(struct be_adapter *adapter ) 
{ 
  u16 vids[64U] ;
  u16 num ;
  u16 i ;
  int status ;
  u16 tmp ;

  {
#line 1013
  num = 0U;
#line 1014
  status = 0;
#line 1017
  if ((int )adapter->promiscuous) {
#line 1018
    return (0);
  } else {

  }
#line 1020
  if ((int )adapter->vlans_added > (int )adapter->max_vlans) {
#line 1021
    goto set_vlan_promisc;
  } else {

  }
#line 1024
  i = 0U;
#line 1024
  goto ldv_51513;
  ldv_51512: ;
#line 1025
  if ((unsigned int )adapter->vlan_tag[(int )i] != 0U) {
#line 1026
    tmp = num;
#line 1026
    num = (u16 )((int )num + 1);
#line 1026
    vids[(int )tmp] = i;
  } else {

  }
#line 1024
  i = (u16 )((int )i + 1);
  ldv_51513: ;
#line 1024
  if ((unsigned int )i <= 4095U) {
#line 1026
    goto ldv_51512;
  } else {

  }
#line 1028
  status = be_cmd_vlan_config(adapter, (u32 )adapter->if_handle, (u16 *)(& vids),
                              (u32 )num, 1, 0);
#line 1032
  if (status != 0) {
#line 1033
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Exhausted VLAN HW filters.\n");
#line 1034
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabling HW VLAN filtering.\n");
#line 1035
    goto set_vlan_promisc;
  } else {

  }
#line 1038
  return (status);
  set_vlan_promisc: 
#line 1041
  status = be_cmd_vlan_config(adapter, (u32 )adapter->if_handle, 0, 0U, 1, 1);
#line 1043
  return (status);
}
}
#line 1046 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vlan_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1048
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1048
  adapter = (struct be_adapter *)tmp;
#line 1049
  status = 0;
#line 1051
  if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 1052
    status = -22;
#line 1053
    goto ret;
  } else {

  }
#line 1057
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1058
    goto ret;
  } else {

  }
#line 1060
  adapter->vlan_tag[(int )vid] = 1U;
#line 1061
  if ((int )adapter->vlans_added <= (int )adapter->max_vlans + 1) {
#line 1062
    status = be_vid_config(adapter);
  } else {

  }
#line 1064
  if (status == 0) {
#line 1065
    adapter->vlans_added = (u16 )((int )adapter->vlans_added + 1);
  } else {
#line 1067
    adapter->vlan_tag[(int )vid] = 0U;
  }
  ret: ;
#line 1069
  return (status);
}
}
#line 1072 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vlan_rem_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1074
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1074
  adapter = (struct be_adapter *)tmp;
#line 1075
  status = 0;
#line 1077
  if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 1078
    status = -22;
#line 1079
    goto ret;
  } else {

  }
#line 1083
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1084
    goto ret;
  } else {

  }
#line 1086
  adapter->vlan_tag[(int )vid] = 0U;
#line 1087
  if ((int )adapter->vlans_added <= (int )adapter->max_vlans) {
#line 1088
    status = be_vid_config(adapter);
  } else {

  }
#line 1090
  if (status == 0) {
#line 1091
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
  } else {
#line 1093
    adapter->vlan_tag[(int )vid] = 1U;
  }
  ret: ;
#line 1095
  return (status);
}
}
#line 1098 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_set_rx_mode(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  struct netdev_hw_addr *ha ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1100
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1100
  adapter = (struct be_adapter *)tmp;
#line 1103
  if ((netdev->flags & 256U) != 0U) {
#line 1104
    be_cmd_rx_filter(adapter, 256U, 1U);
#line 1105
    adapter->promiscuous = 1;
#line 1106
    goto done;
  } else {

  }
#line 1110
  if ((int )adapter->promiscuous) {
#line 1111
    adapter->promiscuous = 0;
#line 1112
    be_cmd_rx_filter(adapter, 256U, 0U);
#line 1114
    if ((unsigned int )adapter->vlans_added != 0U) {
#line 1115
      be_vid_config(adapter);
    } else {

    }
  } else {

  }
#line 1119
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )adapter->max_mcast_mac) {
#line 1121
    be_cmd_rx_filter(adapter, 512U, 1U);
#line 1122
    goto done;
  } else {

  }
#line 1125
  if ((u32 )netdev->uc.count != adapter->uc_macs) {
#line 1127
    i = 1;
#line 1129
    goto ldv_51540;
    ldv_51539: 
#line 1130
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                    0U);
#line 1129
    adapter->uc_macs = adapter->uc_macs - 1U;
#line 1129
    i = i + 1;
    ldv_51540: ;
#line 1129
    if (adapter->uc_macs != 0U) {
#line 1131
      goto ldv_51539;
    } else {

    }

#line 1134
    if (netdev->uc.count > (int )adapter->max_pmac_cnt) {
#line 1135
      be_cmd_rx_filter(adapter, 256U, 1U);
#line 1136
      adapter->promiscuous = 1;
#line 1137
      goto done;
    } else {

    }
#line 1140
    __mptr = (struct list_head  const  *)(adapter->netdev)->uc.list.next;
#line 1140
    ha = (struct netdev_hw_addr *)__mptr;
#line 1140
    goto ldv_51547;
    ldv_51546: 
#line 1141
    adapter->uc_macs = adapter->uc_macs + 1U;
#line 1142
    be_cmd_pmac_add(adapter, (u8 *)(& ha->addr), (u32 )adapter->if_handle, adapter->pmac_id + (unsigned long )adapter->uc_macs,
                    0U);
#line 1140
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1140
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_51547: ;
#line 1140
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->uc.list)) {
#line 1142
      goto ldv_51546;
    } else {

    }

  } else {

  }
#line 1148
  status = be_cmd_rx_filter(adapter, 4096U, 1U);
#line 1151
  if (status != 0) {
#line 1152
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Exhausted multicast HW filters.\n");
#line 1153
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabling HW multicast filtering.\n");
#line 1154
    be_cmd_rx_filter(adapter, 512U, 1U);
  } else {

  }
  done: ;
#line 1157
  return;
}
}
#line 1160 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  bool active_mac ;
  u32 pmac_id ;
  u8 old_mac[6U] ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 1162
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1162
  adapter = (struct be_adapter *)tmp;
#line 1163
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1165
  active_mac = 0;
#line 1169
  if (adapter->num_vfs == 0U) {
#line 1170
    return (-1);
  } else {

  }
#line 1172
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
#line 1172
  if (tmp___0) {
#line 1172
    tmp___1 = 0;
  } else {
#line 1172
    tmp___1 = 1;
  }
#line 1172
  if (tmp___1 || (u32 )vf >= adapter->num_vfs) {
#line 1173
    return (-22);
  } else {

  }
#line 1175
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1176
    status = be_cmd_get_mac_from_list(adapter, (u8 *)(& old_mac), & active_mac, & pmac_id,
                                      (int )((unsigned int )((u8 )vf) + 1U));
#line 1178
    if (status == 0 && (int )active_mac) {
#line 1179
      be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, (int )pmac_id, (u32 )(vf + 1));
    } else {

    }
#line 1182
    status = be_cmd_set_mac_list(adapter, mac, 1, (u32 )(vf + 1));
  } else {
#line 1184
    status = be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, (u32 )(vf + 1));
#line 1187
    status = be_cmd_pmac_add(adapter, mac, (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             (u32 )(vf + 1));
  }
#line 1191
  if (status != 0) {
#line 1192
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "MAC %pM set on VF %d Failed\n",
            mac, vf);
  } else {
#line 1195
    __len = 6UL;
#line 1195
    if (__len > 63UL) {
#line 1195
      __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)mac, __len);
    } else {
#line 1195
      __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)mac,
                               __len);
    }
  }
#line 1197
  return (status);
}
}
#line 1200 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *vi ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  size_t __len ;
  void *__ret ;

  {
#line 1203
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1203
  adapter = (struct be_adapter *)tmp;
#line 1204
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1206
  if (adapter->num_vfs == 0U) {
#line 1207
    return (-1);
  } else {

  }
#line 1209
  if ((u32 )vf >= adapter->num_vfs) {
#line 1210
    return (-22);
  } else {

  }
#line 1212
  vi->vf = (__u32 )vf;
#line 1213
  vi->tx_rate = vf_cfg->tx_rate;
#line 1214
  vi->vlan = (__u32 )vf_cfg->vlan_tag;
#line 1215
  vi->qos = 0U;
#line 1216
  __len = 6UL;
#line 1216
  if (__len > 63UL) {
#line 1216
    __ret = __memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr), __len);
  } else {
#line 1216
    __ret = __builtin_memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr),
                             __len);
  }
#line 1218
  return (0);
}
}
#line 1221 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1224
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1224
  adapter = (struct be_adapter *)tmp;
#line 1225
  status = 0;
#line 1227
  if (adapter->num_vfs == 0U) {
#line 1228
    return (-1);
  } else {

  }
#line 1230
  if ((u32 )vf >= adapter->num_vfs || (unsigned int )vlan > 4095U) {
#line 1231
    return (-22);
  } else {

  }
#line 1233
  if ((unsigned int )vlan != 0U) {
#line 1234
    if ((int )(adapter->vf_cfg + (unsigned long )vf)->vlan_tag != (int )vlan) {
#line 1236
      (adapter->vf_cfg + (unsigned long )vf)->vlan_tag = vlan;
#line 1238
      status = be_cmd_set_hsw_config(adapter, (int )vlan, (u32 )(vf + 1), (int )((u16 )(adapter->vf_cfg + (unsigned long )vf)->if_handle));
    } else {

    }
  } else {
#line 1243
    (adapter->vf_cfg + (unsigned long )vf)->vlan_tag = 0U;
#line 1244
    vlan = (adapter->vf_cfg + (unsigned long )vf)->def_vid;
#line 1245
    status = be_cmd_set_hsw_config(adapter, (int )vlan, (u32 )(vf + 1), (int )((u16 )(adapter->vf_cfg + (unsigned long )vf)->if_handle));
  }
#line 1250
  if (status != 0) {
#line 1251
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "VLAN %d config on VF %d failed\n",
              (int )vlan, vf);
  } else {

  }
#line 1253
  return (status);
}
}
#line 1256 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_set_vf_tx_rate(struct net_device *netdev , int vf , int rate ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 1259
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1259
  adapter = (struct be_adapter *)tmp;
#line 1260
  status = 0;
#line 1262
  if (adapter->num_vfs == 0U) {
#line 1263
    return (-1);
  } else {

  }
#line 1265
  if ((u32 )vf >= adapter->num_vfs) {
#line 1266
    return (-22);
  } else {

  }
#line 1268
  if (rate <= 99 || rate > 10000) {
#line 1269
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "tx rate must be between 100 and 10000 Mbps\n");
#line 1271
    return (-22);
  } else {

  }
#line 1274
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1275
    status = be_cmd_set_profile_config(adapter, (u32 )(rate / 10), (int )((unsigned int )((u8 )vf) + 1U));
  } else {
#line 1277
    status = be_cmd_set_qos(adapter, (u32 )(rate / 10), (u32 )(vf + 1));
  }
#line 1279
  if (status != 0) {
#line 1280
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "tx rate %d on VF %d failed\n",
            rate, vf);
  } else {
#line 1283
    (adapter->vf_cfg + (unsigned long )vf)->tx_rate = (u32 )rate;
  }
#line 1284
  return (status);
}
}
#line 1287 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_find_vfs(struct be_adapter *adapter , int vf_state ) 
{ 
  struct pci_dev *dev ;
  struct pci_dev *pdev ;
  int vfs ;
  int assigned_vfs ;
  int pos ;
  u16 offset ;
  u16 stride ;
  struct pci_dev *tmp ;

  {
#line 1289
  pdev = adapter->pdev;
#line 1290
  vfs = 0;
#line 1290
  assigned_vfs = 0;
#line 1293
  pos = pci_find_ext_capability(pdev, 16);
#line 1294
  if (pos == 0) {
#line 1295
    return (0);
  } else {

  }
#line 1296
  pci_read_config_word((struct pci_dev  const  *)pdev, pos + 20, & offset);
#line 1297
  pci_read_config_word((struct pci_dev  const  *)pdev, pos + 22, & stride);
#line 1299
  dev = pci_get_device((unsigned int )pdev->vendor, 4294967295U, 0);
#line 1300
  goto ldv_51600;
  ldv_51599: ;
#line 1301
  if ((unsigned int )*((unsigned char *)dev + 2251UL) != 0U) {
#line 1301
    tmp = pci_physfn(dev);
#line 1301
    if ((unsigned long )tmp == (unsigned long )pdev) {
#line 1302
      vfs = vfs + 1;
#line 1303
      if (((int )dev->dev_flags & 4) != 0) {
#line 1304
        assigned_vfs = assigned_vfs + 1;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1306
  dev = pci_get_device((unsigned int )pdev->vendor, 4294967295U, dev);
  ldv_51600: ;
#line 1300
  if ((unsigned long )dev != (unsigned long )((struct pci_dev *)0)) {
#line 1302
    goto ldv_51599;
  } else {

  }

#line 1308
  return (vf_state == 1 ? assigned_vfs : vfs);
}
}
#line 1311 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_eqd_update(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 
  struct be_rx_stats *stats ;
  ulong now ;
  ulong delta ;
  u64 pkts ;
  unsigned int start ;
  unsigned int eqd ;
  bool tmp ;
  unsigned int _min1 ;
  u32 _min2 ;
  unsigned int _max1 ;
  u32 _max2 ;

  {
#line 1313
  stats = & ((struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )eqo->idx)->stats;
#line 1314
  now = jiffies;
#line 1315
  delta = now - stats->rx_jiffies;
#line 1319
  if (! eqo->enable_aic) {
#line 1320
    eqd = eqo->eqd;
#line 1321
    goto modify_eqd;
  } else {

  }
#line 1324
  if ((u32 )eqo->idx >= adapter->num_rx_qs) {
#line 1325
    return;
  } else {

  }
#line 1327
  stats = & ((struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )eqo->idx)->stats;
#line 1330
  if ((long )now - (long )stats->rx_jiffies < 0L) {
#line 1331
    stats->rx_jiffies = now;
#line 1332
    return;
  } else {

  }
#line 1336
  if (delta <= 249UL) {
#line 1337
    return;
  } else {

  }
  ldv_51619: 
#line 1340
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats->sync));
#line 1341
  pkts = stats->rx_pkts;
#line 1342
  tmp = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats->sync),
                                 start);
#line 1342
  if ((int )tmp) {
#line 1344
    goto ldv_51619;
  } else {

  }
#line 1344
  stats->rx_pps = (u32 )((unsigned long )(pkts - stats->rx_pkts_prev) / (delta / 250UL));
#line 1345
  stats->rx_pkts_prev = pkts;
#line 1346
  stats->rx_jiffies = now;
#line 1347
  eqd = stats->rx_pps / 110000U << 3;
#line 1348
  _min1 = eqd;
#line 1348
  _min2 = eqo->max_eqd;
#line 1348
  eqd = _min1 < _min2 ? _min1 : _min2;
#line 1349
  _max1 = eqd;
#line 1349
  _max2 = eqo->min_eqd;
#line 1349
  eqd = _max1 > _max2 ? _max1 : _max2;
#line 1350
  if (eqd <= 9U) {
#line 1351
    eqd = 0U;
  } else {

  }
  modify_eqd: ;
#line 1354
  if (eqo->cur_eqd != eqd) {
#line 1355
    be_cmd_modify_eqd(adapter, (u32 )eqo->q.id, eqd);
#line 1356
    eqo->cur_eqd = eqd;
  } else {

  }
#line 1358
  return;
}
}
#line 1360 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_stats_update(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_stats *stats ;

  {
#line 1363
  stats = & rxo->stats;
#line 1365
  u64_stats_update_begin(& stats->sync);
#line 1366
  stats->rx_compl = stats->rx_compl + 1U;
#line 1367
  stats->rx_bytes = stats->rx_bytes + (u64 )rxcp->pkt_size;
#line 1368
  stats->rx_pkts = stats->rx_pkts + 1ULL;
#line 1369
  if ((unsigned int )rxcp->pkt_type == 1U) {
#line 1370
    stats->rx_mcast_pkts = stats->rx_mcast_pkts + 1U;
  } else {

  }
#line 1371
  if ((unsigned int )rxcp->err != 0U) {
#line 1372
    stats->rx_compl_err = stats->rx_compl_err + 1U;
  } else {

  }
#line 1373
  u64_stats_update_begin(& stats->sync);
#line 1374
  return;
}
}
#line 1376 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static bool csum_passed(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 1380
  return ((bool )((((unsigned int )rxcp->tcpf != 0U || (unsigned int )rxcp->udpf != 0U) && (unsigned int )rxcp->l4_csum != 0U) && ((unsigned int )rxcp->ip_csum != 0U || (unsigned int )rxcp->ipv6 != 0U)));
}
}
#line 1384 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct be_rx_page_info *get_rx_page_info(struct be_rx_obj *rxo , u16 frag_idx ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *rx_page_info ;
  struct be_queue_info *rxq ;
  long tmp ;

  {
#line 1387
  adapter = rxo->adapter;
#line 1389
  rxq = & rxo->q;
#line 1391
  rx_page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )frag_idx;
#line 1392
  tmp = ldv__builtin_expect((unsigned long )rx_page_info->page == (unsigned long )((struct page *)0),
                         0L);
#line 1392
  if (tmp != 0L) {
#line 1392
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (1392), "i" (12UL));
    ldv_51642: ;
#line 1392
    goto ldv_51642;
  } else {

  }
#line 1394
  if ((int )rx_page_info->last_page_user) {
#line 1395
    dma_unmap_page(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )adapter->big_page_size,
                   2);
#line 1398
    rx_page_info->last_page_user = 0;
  } else {

  }
#line 1401
  atomic_dec(& rxq->used);
#line 1402
  return (rx_page_info);
}
}
#line 1406 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_compl_discard(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_queue_info *rxq ;
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 num_rcvd ;

  {
#line 1409
  rxq = & rxo->q;
#line 1411
  num_rcvd = (u16 )rxcp->num_rcvd;
#line 1413
  i = 0U;
#line 1413
  goto ldv_51652;
  ldv_51651: 
#line 1414
  page_info = get_rx_page_info(rxo, (int )rxcp->rxq_idx);
#line 1415
  put_page(page_info->page);
#line 1416
  memset((void *)page_info, 0, 24UL);
#line 1417
  index_inc(& rxcp->rxq_idx, (int )rxq->len);
#line 1413
  i = (u16 )((int )i + 1);
  ldv_51652: ;
#line 1413
  if ((int )i < (int )num_rcvd) {
#line 1415
    goto ldv_51651;
  } else {

  }

#line 1420
  return;
}
}
#line 1425 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void skb_fill_rx_data(struct be_rx_obj *rxo , struct sk_buff *skb , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_queue_info *rxq ;
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 j ;
  u16 hdr_len ;
  u16 curr_frag_len ;
  u16 remaining ;
  u8 *start ;
  void *tmp ;
  u16 _min1 ;
  ushort _min2 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 _min1___0 ;
  ushort _min2___0 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;

  {
#line 1428
  rxq = & rxo->q;
#line 1434
  page_info = get_rx_page_info(rxo, (int )rxcp->rxq_idx);
#line 1435
  tmp = lowmem_page_address((struct page  const  *)page_info->page);
#line 1435
  start = (u8 *)tmp + (unsigned long )page_info->page_offset;
#line 1436
  __builtin_prefetch((void const   *)start);
#line 1439
  _min1 = rxcp->pkt_size;
#line 1439
  _min2 = rx_frag_size;
#line 1439
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 1441
  skb->len = (unsigned int )curr_frag_len;
#line 1442
  if ((unsigned int )curr_frag_len <= 64U) {
#line 1443
    __len = (size_t )curr_frag_len;
#line 1443
    __ret = __builtin_memcpy((void *)skb->data, (void const   *)start, __len);
#line 1445
    put_page(page_info->page);
#line 1446
    skb->data_len = 0U;
#line 1447
    skb->tail = skb->tail + (sk_buff_data_t )curr_frag_len;
  } else {
#line 1449
    hdr_len = 14U;
#line 1450
    __len___0 = (size_t )hdr_len;
#line 1450
    __ret___0 = __builtin_memcpy((void *)skb->data, (void const   *)start, __len___0);
#line 1451
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1451
    ((struct skb_shared_info *)tmp___0)->nr_frags = 1U;
#line 1452
    skb_frag_set_page(skb, 0, page_info->page);
#line 1453
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1453
    ((struct skb_shared_info *)tmp___1)->frags[0].page_offset = (__u32 )((int )page_info->page_offset + (int )hdr_len);
#line 1455
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1455
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___2)->frags),
                      (unsigned int )((int )curr_frag_len - (int )hdr_len));
#line 1456
    skb->data_len = (unsigned int )((int )curr_frag_len - (int )hdr_len);
#line 1457
    skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1458
    skb->tail = skb->tail + (sk_buff_data_t )hdr_len;
  }
#line 1460
  page_info->page = 0;
#line 1462
  if ((int )rxcp->pkt_size <= (int )rx_frag_size) {
#line 1463
    tmp___3 = ldv__builtin_expect((unsigned int )rxcp->num_rcvd != 1U, 0L);
#line 1463
    if (tmp___3 != 0L) {
#line 1463
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                           "i" (1463), "i" (12UL));
      ldv_51676: ;
#line 1463
      goto ldv_51676;
    } else {

    }
#line 1464
    return;
  } else {

  }
#line 1468
  index_inc(& rxcp->rxq_idx, (int )rxq->len);
#line 1469
  remaining = (int )rxcp->pkt_size - (int )curr_frag_len;
#line 1470
  i = 1U;
#line 1470
  j = 0U;
#line 1470
  goto ldv_51681;
  ldv_51680: 
#line 1471
  page_info = get_rx_page_info(rxo, (int )rxcp->rxq_idx);
#line 1472
  _min1___0 = remaining;
#line 1472
  _min2___0 = rx_frag_size;
#line 1472
  curr_frag_len = (u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0);
#line 1475
  if ((unsigned int )page_info->page_offset == 0U) {
#line 1477
    j = (u16 )((int )j + 1);
#line 1478
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1479
    tmp___4 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1479
    ((struct skb_shared_info *)tmp___4)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1481
    tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1481
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___5)->frags) + (unsigned long )j,
                      0U);
#line 1482
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1482
    ((struct skb_shared_info *)tmp___6)->nr_frags = (unsigned char )((int )((struct skb_shared_info *)tmp___6)->nr_frags + 1);
  } else {
#line 1484
    put_page(page_info->page);
  }
#line 1487
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1487
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___7)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1488
  skb->len = skb->len + (unsigned int )curr_frag_len;
#line 1489
  skb->data_len = skb->data_len + (unsigned int )curr_frag_len;
#line 1490
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1491
  remaining = (int )remaining - (int )curr_frag_len;
#line 1492
  index_inc(& rxcp->rxq_idx, (int )rxq->len);
#line 1493
  page_info->page = 0;
#line 1470
  i = (u16 )((int )i + 1);
  ldv_51681: ;
#line 1470
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 1472
    goto ldv_51680;
  } else {

  }
#line 1495
  tmp___8 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 1495
  if (tmp___8 != 0L) {
#line 1495
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (1495), "i" (12UL));
    ldv_51683: ;
#line 1495
    goto ldv_51683;
  } else {

  }
#line 1497
  return;
}
}
#line 1499 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_compl_process(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  struct sk_buff *skb ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
#line 1502
  adapter = rxo->adapter;
#line 1503
  netdev = adapter->netdev;
#line 1506
  skb = netdev_alloc_skb_ip_align(netdev, 128U);
#line 1507
  tmp = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 1507
  if (tmp != 0L) {
#line 1508
    rxo->stats.rx_drops_no_skbs = rxo->stats.rx_drops_no_skbs + 1U;
#line 1509
    be_rx_compl_discard(rxo, rxcp);
#line 1510
    return;
  } else {

  }
#line 1513
  skb_fill_rx_data(rxo, skb, rxcp);
#line 1515
  tmp___0 = ldv__builtin_expect((netdev->features & 536870912ULL) != 0ULL, 1L);
#line 1515
  if (tmp___0 != 0L) {
#line 1515
    tmp___1 = csum_passed(rxcp);
#line 1515
    tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 1515
    if (tmp___2 != 0L) {
#line 1516
      skb->ip_summed = 1U;
    } else {
#line 1518
      skb_checksum_none_assert((struct sk_buff  const  *)skb);
    }
  } else {
#line 1518
    skb_checksum_none_assert((struct sk_buff  const  *)skb);
  }
#line 1520
  skb->protocol = eth_type_trans(skb, netdev);
#line 1521
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 1522
  if ((netdev->features & 268435456ULL) != 0ULL) {
#line 1523
    skb->rxhash = rxcp->rss_hash;
  } else {

  }
#line 1526
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1527
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 1529
  netif_receive_skb(skb);
#line 1530
  return;
}
}
#line 1533 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void be_rx_compl_process_gro(struct be_rx_obj *rxo , struct napi_struct *napi , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct sk_buff *skb ;
  struct be_queue_info *rxq ;
  u16 remaining ;
  u16 curr_frag_len ;
  u16 i ;
  u16 j ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 1536
  adapter = rxo->adapter;
#line 1538
  skb = 0;
#line 1539
  rxq = & rxo->q;
#line 1543
  skb = napi_get_frags(napi);
#line 1544
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1545
    be_rx_compl_discard(rxo, rxcp);
#line 1546
    return;
  } else {

  }
#line 1549
  remaining = rxcp->pkt_size;
#line 1550
  i = 0U;
#line 1550
  j = 65535U;
#line 1550
  goto ldv_51708;
  ldv_51707: 
#line 1551
  page_info = get_rx_page_info(rxo, (int )rxcp->rxq_idx);
#line 1553
  _min1 = remaining;
#line 1553
  _min2 = rx_frag_size;
#line 1553
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 1556
  if ((unsigned int )i == 0U || (unsigned int )page_info->page_offset == 0U) {
#line 1558
    j = (u16 )((int )j + 1);
#line 1559
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1560
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1560
    ((struct skb_shared_info *)tmp)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1562
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1562
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___0)->frags) + (unsigned long )j,
                      0U);
  } else {
#line 1564
    put_page(page_info->page);
  }
#line 1566
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1566
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___1)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1567
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1568
  remaining = (int )remaining - (int )curr_frag_len;
#line 1569
  index_inc(& rxcp->rxq_idx, (int )rxq->len);
#line 1570
  memset((void *)page_info, 0, 24UL);
#line 1550
  i = (u16 )((int )i + 1);
  ldv_51708: ;
#line 1550
  if ((int )((unsigned short )rxcp->num_rcvd) > (int )i) {
#line 1552
    goto ldv_51707;
  } else {

  }
#line 1572
  tmp___2 = ldv__builtin_expect((unsigned int )j > 17U, 0L);
#line 1572
  if (tmp___2 != 0L) {
#line 1572
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (1572), "i" (12UL));
    ldv_51710: ;
#line 1572
    goto ldv_51710;
  } else {

  }
#line 1574
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1574
  ((struct skb_shared_info *)tmp___3)->nr_frags = (unsigned int )((unsigned char )j) + 1U;
#line 1575
  skb->len = (unsigned int )rxcp->pkt_size;
#line 1576
  skb->data_len = (unsigned int )rxcp->pkt_size;
#line 1577
  skb->ip_summed = 1U;
#line 1578
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
#line 1579
  if (((adapter->netdev)->features & 268435456ULL) != 0ULL) {
#line 1580
    skb->rxhash = rxcp->rss_hash;
  } else {

  }
#line 1582
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1583
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
  } else {

  }
#line 1585
  napi_gro_frags(napi);
#line 1586
  return;
}
}
#line 1588 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_parse_rx_compl_v1(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 1591
  tmp = amap_mask(14U);
#line 1591
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1591
  rxcp->pkt_size = (u16 )tmp___0;
#line 1593
  tmp___1 = amap_mask(1U);
#line 1593
  tmp___2 = amap_get((void *)compl, 0U, tmp___1, 30U);
#line 1593
  rxcp->vlanf = (u8 )tmp___2;
#line 1594
  tmp___3 = amap_mask(1U);
#line 1594
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1594
  rxcp->err = (u8 )tmp___4;
#line 1595
  tmp___5 = amap_mask(1U);
#line 1595
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1595
  rxcp->tcpf = (u8 )tmp___6;
#line 1596
  tmp___7 = amap_mask(1U);
#line 1596
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1596
  rxcp->udpf = (u8 )tmp___8;
#line 1597
  tmp___9 = amap_mask(1U);
#line 1597
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1597
  rxcp->ip_csum = (u8 )tmp___10;
#line 1599
  tmp___11 = amap_mask(1U);
#line 1599
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1599
  rxcp->l4_csum = (u8 )tmp___12;
#line 1601
  tmp___13 = amap_mask(1U);
#line 1601
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1601
  rxcp->ipv6 = (u8 )tmp___14;
#line 1603
  tmp___15 = amap_mask(10U);
#line 1603
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 16U);
#line 1603
  rxcp->rxq_idx = (u16 )tmp___16;
#line 1605
  tmp___17 = amap_mask(3U);
#line 1605
  tmp___18 = amap_get((void *)compl, 1U, tmp___17, 29U);
#line 1605
  rxcp->num_rcvd = (u8 )tmp___18;
#line 1607
  tmp___19 = amap_mask(2U);
#line 1607
  tmp___20 = amap_get((void *)compl, 2U, tmp___19, 1U);
#line 1607
  rxcp->pkt_type = (u8 )tmp___20;
#line 1609
  tmp___21 = amap_mask(32U);
#line 1609
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___21, 0U);
#line 1611
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1612
    tmp___22 = amap_mask(1U);
#line 1612
    tmp___23 = amap_get((void *)compl, 2U, tmp___22, 3U);
#line 1612
    rxcp->vtm = (u8 )tmp___23;
#line 1614
    tmp___24 = amap_mask(16U);
#line 1614
    tmp___25 = amap_get((void *)compl, 0U, tmp___24, 0U);
#line 1614
    rxcp->vlan_tag = (u16 )tmp___25;
  } else {

  }
#line 1617
  tmp___26 = amap_mask(2U);
#line 1617
  tmp___27 = amap_get((void *)compl, 2U, tmp___26, 5U);
#line 1617
  rxcp->port = (u16 )tmp___27;
#line 1618
  return;
}
}
#line 1620 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_parse_rx_compl_v0(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
#line 1623
  tmp = amap_mask(14U);
#line 1623
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1623
  rxcp->pkt_size = (u16 )tmp___0;
#line 1625
  tmp___1 = amap_mask(1U);
#line 1625
  tmp___2 = amap_get((void *)compl, 1U, tmp___1, 14U);
#line 1625
  rxcp->vlanf = (u8 )tmp___2;
#line 1626
  tmp___3 = amap_mask(1U);
#line 1626
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1626
  rxcp->err = (u8 )tmp___4;
#line 1627
  tmp___5 = amap_mask(1U);
#line 1627
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1627
  rxcp->tcpf = (u8 )tmp___6;
#line 1628
  tmp___7 = amap_mask(1U);
#line 1628
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1628
  rxcp->udpf = (u8 )tmp___8;
#line 1629
  tmp___9 = amap_mask(1U);
#line 1629
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1629
  rxcp->ip_csum = (u8 )tmp___10;
#line 1631
  tmp___11 = amap_mask(1U);
#line 1631
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1631
  rxcp->l4_csum = (u8 )tmp___12;
#line 1633
  tmp___13 = amap_mask(1U);
#line 1633
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1633
  rxcp->ipv6 = (u8 )tmp___14;
#line 1635
  tmp___15 = amap_mask(10U);
#line 1635
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 16U);
#line 1635
  rxcp->rxq_idx = (u16 )tmp___16;
#line 1637
  tmp___17 = amap_mask(3U);
#line 1637
  tmp___18 = amap_get((void *)compl, 1U, tmp___17, 29U);
#line 1637
  rxcp->num_rcvd = (u8 )tmp___18;
#line 1639
  tmp___19 = amap_mask(2U);
#line 1639
  tmp___20 = amap_get((void *)compl, 2U, tmp___19, 1U);
#line 1639
  rxcp->pkt_type = (u8 )tmp___20;
#line 1641
  tmp___21 = amap_mask(32U);
#line 1641
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___21, 0U);
#line 1643
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1644
    tmp___22 = amap_mask(1U);
#line 1644
    tmp___23 = amap_get((void *)compl, 2U, tmp___22, 3U);
#line 1644
    rxcp->vtm = (u8 )tmp___23;
#line 1646
    tmp___24 = amap_mask(16U);
#line 1646
    tmp___25 = amap_get((void *)compl, 0U, tmp___24, 0U);
#line 1646
    rxcp->vlan_tag = (u16 )tmp___25;
  } else {

  }
#line 1649
  tmp___26 = amap_mask(1U);
#line 1649
  tmp___27 = amap_get((void *)compl, 0U, tmp___26, 30U);
#line 1649
  rxcp->port = (u16 )tmp___27;
#line 1650
  return;
}
}
#line 1652 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct be_rx_compl_info *be_rx_compl_get(struct be_rx_obj *rxo ) 
{ 
  struct be_eth_rx_compl *compl ;
  void *tmp ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  __u16 tmp___0 ;

  {
#line 1654
  tmp = queue_tail_node(& rxo->cq);
#line 1654
  compl = (struct be_eth_rx_compl *)tmp;
#line 1655
  rxcp = & rxo->rxcp;
#line 1656
  adapter = rxo->adapter;
#line 1660
  if (compl->dw[2UL] == 0U) {
#line 1661
    return (0);
  } else {

  }
#line 1663
  __asm__  volatile   ("lfence": : : "memory");
#line 1664
  swap_dws((void *)compl, 16);
#line 1666
  if ((int )adapter->be3_native) {
#line 1667
    be_parse_rx_compl_v1(compl, rxcp);
  } else {
#line 1669
    be_parse_rx_compl_v0(compl, rxcp);
  }
#line 1671
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1674
    if ((adapter->function_mode & 1024U) != 0U && (unsigned int )rxcp->vtm == 0U) {
#line 1675
      rxcp->vlanf = 0U;
    } else {

    }
#line 1677
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 1678
      tmp___0 = __fswab16((int )rxcp->vlan_tag);
#line 1678
      rxcp->vlan_tag = tmp___0;
    } else {

    }
#line 1680
    if ((int )adapter->pvid == ((int )rxcp->vlan_tag & 4095) && (unsigned int )adapter->vlan_tag[(int )rxcp->vlan_tag] == 0U) {
#line 1682
      rxcp->vlanf = 0U;
    } else {

    }
  } else {

  }
#line 1686
  compl->dw[2UL] = 0U;
#line 1688
  queue_tail_inc(& rxo->cq);
#line 1689
  return (rxcp);
}
}
#line 1692 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static struct page *be_alloc_pages(u32 size , gfp_t gfp ) 
{ 
  u32 order ;
  int tmp ;
  struct page *tmp___0 ;

  {
#line 1694
  tmp = __get_order((unsigned long )size);
#line 1694
  order = (u32 )tmp;
#line 1696
  if (order != 0U) {
#line 1697
    gfp = gfp | 16384U;
  } else {

  }
#line 1698
  tmp___0 = alloc_pages(gfp, order);
#line 1698
  return (tmp___0);
}
}
#line 1705 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_post_rx_frags(struct be_rx_obj *rxo , gfp_t gfp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct be_rx_page_info *prev_page_info ;
  struct be_queue_info *rxq ;
  struct page *pagep ;
  struct be_eth_rx_d *rxd ;
  u64 page_dmaaddr ;
  u64 frag_dmaaddr ;
  u32 posted ;
  u32 page_offset ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1707
  adapter = rxo->adapter;
#line 1708
  page_info = 0;
#line 1708
  prev_page_info = 0;
#line 1709
  rxq = & rxo->q;
#line 1710
  pagep = 0;
#line 1712
  page_dmaaddr = 0ULL;
#line 1713
  page_offset = 0U;
#line 1715
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1716
  posted = 0U;
#line 1716
  goto ldv_51746;
  ldv_51745: ;
#line 1717
  if ((unsigned long )pagep == (unsigned long )((struct page *)0)) {
#line 1718
    pagep = be_alloc_pages(adapter->big_page_size, gfp);
#line 1719
    tmp = ldv__builtin_expect((unsigned long )pagep == (unsigned long )((struct page *)0),
                           0L);
#line 1719
    if (tmp != 0L) {
#line 1720
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
#line 1721
      goto ldv_51744;
    } else {

    }
#line 1723
    page_dmaaddr = dma_map_page(& (adapter->pdev)->dev, pagep, 0UL, (size_t )adapter->big_page_size,
                                2);
#line 1726
    page_info->page_offset = 0U;
  } else {
#line 1728
    get_page(pagep);
#line 1729
    page_info->page_offset = (int )((u16 )page_offset) + (int )rx_frag_size;
  }
#line 1731
  page_offset = (u32 )page_info->page_offset;
#line 1732
  page_info->page = pagep;
#line 1733
  page_info->bus = page_dmaaddr;
#line 1734
  frag_dmaaddr = (u64 )page_info->page_offset + page_dmaaddr;
#line 1736
  tmp___0 = queue_head_node(rxq);
#line 1736
  rxd = (struct be_eth_rx_d *)tmp___0;
#line 1737
  rxd->fragpa_lo = (unsigned int )frag_dmaaddr;
#line 1738
  rxd->fragpa_hi = (unsigned int )(frag_dmaaddr >> 32ULL);
#line 1741
  if (((u32 )rx_frag_size + page_offset) + (u32 )rx_frag_size > adapter->big_page_size) {
#line 1743
    pagep = 0;
#line 1744
    page_info->last_page_user = 1;
  } else {

  }
#line 1747
  prev_page_info = page_info;
#line 1748
  queue_head_inc(rxq);
#line 1749
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1716
  posted = posted + 1U;
  ldv_51746: ;
#line 1716
  if (posted <= 63U && (unsigned long )page_info->page == (unsigned long )((struct page *)0)) {
#line 1718
    goto ldv_51745;
  } else {

  }
  ldv_51744: ;
#line 1751
  if ((unsigned long )pagep != (unsigned long )((struct page *)0)) {
#line 1752
    prev_page_info->last_page_user = 1;
  } else {

  }
#line 1754
  if (posted != 0U) {
#line 1755
    atomic_add((int )posted, & rxq->used);
#line 1756
    be_rxq_notify(adapter, (int )rxq->id, (int )((u16 )posted));
  } else {
#line 1757
    tmp___1 = atomic_read((atomic_t const   *)(& rxq->used));
#line 1757
    if (tmp___1 == 0) {
#line 1759
      rxo->rx_post_starved = 1;
    } else {

    }
  }
#line 1760
  return;
}
}
#line 1763 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct be_eth_tx_compl *be_tx_compl_get(struct be_queue_info *tx_cq ) 
{ 
  struct be_eth_tx_compl *txcp ;
  void *tmp ;

  {
#line 1765
  tmp = queue_tail_node(tx_cq);
#line 1765
  txcp = (struct be_eth_tx_compl *)tmp;
#line 1767
  if (txcp->dw[3UL] == 0U) {
#line 1768
    return (0);
  } else {

  }
#line 1770
  __asm__  volatile   ("lfence": : : "memory");
#line 1771
  swap_dws((void *)txcp, 16);
#line 1773
  txcp->dw[3UL] = 0U;
#line 1775
  queue_tail_inc(tx_cq);
#line 1776
  return (txcp);
}
}
#line 1779 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static u16 be_tx_compl_process(struct be_adapter *adapter , struct be_tx_obj *txo ,
                               u16 last_index ) 
{ 
  struct be_queue_info *txq ;
  struct be_eth_wrb *wrb ;
  struct sk_buff **sent_skbs ;
  struct sk_buff *sent_skb ;
  u16 cur_index ;
  u16 num_wrbs ;
  bool unmap_skb_hdr ;
  long tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 1782
  txq = & txo->q;
#line 1784
  sent_skbs = (struct sk_buff **)(& txo->sent_skb_list);
#line 1786
  num_wrbs = 1U;
#line 1787
  unmap_skb_hdr = 1;
#line 1789
  sent_skb = *(sent_skbs + (unsigned long )txq->tail);
#line 1790
  tmp = ldv__builtin_expect((unsigned long )sent_skb == (unsigned long )((struct sk_buff *)0),
                         0L);
#line 1790
  if (tmp != 0L) {
#line 1790
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (1790), "i" (12UL));
    ldv_51763: ;
#line 1790
    goto ldv_51763;
  } else {

  }
#line 1791
  *(sent_skbs + (unsigned long )txq->tail) = 0;
#line 1794
  queue_tail_inc(txq);
  ldv_51764: 
#line 1797
  cur_index = txq->tail;
#line 1798
  tmp___0 = queue_tail_node(txq);
#line 1798
  wrb = (struct be_eth_wrb *)tmp___0;
#line 1799
  if ((int )unmap_skb_hdr) {
#line 1799
    tmp___1 = skb_headlen((struct sk_buff  const  *)sent_skb);
#line 1799
    if (tmp___1 != 0U) {
#line 1799
      tmp___2 = 1;
    } else {
#line 1799
      tmp___2 = 0;
    }
  } else {
#line 1799
    tmp___2 = 0;
  }
#line 1799
  unmap_tx_frag(& (adapter->pdev)->dev, wrb, (int )((bool )tmp___2));
#line 1801
  unmap_skb_hdr = 0;
#line 1803
  num_wrbs = (u16 )((int )num_wrbs + 1);
#line 1804
  queue_tail_inc(txq);
#line 1805
  if ((int )cur_index != (int )last_index) {
#line 1807
    goto ldv_51764;
  } else {

  }
#line 1807
  kfree_skb(sent_skb);
#line 1808
  return (num_wrbs);
}
}
#line 1812 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static int events_get(struct be_eq_obj *eqo ) 
{ 
  struct be_eq_entry *eqe ;
  int num ;
  void *tmp ;

  {
#line 1815
  num = 0;
  ldv_51772: 
#line 1818
  tmp = queue_tail_node(& eqo->q);
#line 1818
  eqe = (struct be_eq_entry *)tmp;
#line 1819
  if (eqe->evt == 0U) {
#line 1820
    goto ldv_51771;
  } else {

  }
#line 1822
  __asm__  volatile   ("lfence": : : "memory");
#line 1823
  eqe->evt = 0U;
#line 1824
  num = num + 1;
#line 1825
  queue_tail_inc(& eqo->q);
#line 1826
  goto ldv_51772;
  ldv_51771: ;
#line 1828
  return (num);
}
}
#line 1832 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_eq_clean(struct be_eq_obj *eqo ) 
{ 
  int num ;
  int tmp ;

  {
#line 1834
  tmp = events_get(eqo);
#line 1834
  num = tmp;
#line 1836
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num));
#line 1837
  return;
}
}
#line 1839 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_cq_clean(struct be_rx_obj *rxo ) 
{ 
  struct be_rx_page_info *page_info ;
  struct be_queue_info *rxq ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  int flush_wait ;
  u16 tail ;
  int tmp ;
  bool tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  u16 tmp___6 ;

  {
#line 1842
  rxq = & rxo->q;
#line 1843
  rx_cq = & rxo->cq;
#line 1845
  adapter = rxo->adapter;
#line 1846
  flush_wait = 0;
  ldv_51792: 
#line 1856
  rxcp = be_rx_compl_get(rxo);
#line 1857
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 1858
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1859
      goto ldv_51787;
    } else {

    }
#line 1861
    tmp = flush_wait;
#line 1861
    flush_wait = flush_wait + 1;
#line 1861
    if (tmp > 10) {
#line 1862
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 1864
      goto ldv_51787;
    } else {
#line 1861
      tmp___0 = be_hw_error(adapter);
#line 1861
      if ((int )tmp___0) {
#line 1862
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
#line 1864
        goto ldv_51787;
      } else {

      }
    }
#line 1866
    be_cq_notify(adapter, (int )rx_cq->id, 1, 0);
#line 1867
    if (1) {
#line 1867
      __const_udelay(4295000UL);
    } else {
#line 1867
      __ms = 1UL;
#line 1867
      goto ldv_51790;
      ldv_51789: 
#line 1867
      __const_udelay(4295000UL);
      ldv_51790: 
#line 1867
      tmp___1 = __ms;
#line 1867
      __ms = __ms - 1UL;
#line 1867
      if (tmp___1 != 0UL) {
#line 1869
        goto ldv_51789;
      } else {

      }

    }
  } else {
#line 1869
    be_rx_compl_discard(rxo, rxcp);
#line 1870
    be_cq_notify(adapter, (int )rx_cq->id, 0, 1);
#line 1871
    if ((unsigned int )rxcp->num_rcvd == 0U) {
#line 1872
      goto ldv_51787;
    } else {

    }
  }
#line 1874
  goto ldv_51792;
  ldv_51787: 
#line 1877
  be_cq_notify(adapter, (int )rx_cq->id, 0, 0);
#line 1880
  tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
#line 1880
  tail = (u16 )((((int )rxq->head + (int )rxq->len) - tmp___2) % (int )rxq->len);
#line 1881
  goto ldv_51794;
  ldv_51793: 
#line 1882
  page_info = get_rx_page_info(rxo, (int )tail);
#line 1883
  put_page(page_info->page);
#line 1884
  memset((void *)page_info, 0, 24UL);
#line 1881
  index_inc(& tail, (int )rxq->len);
  ldv_51794: 
#line 1881
  tmp___3 = atomic_read((atomic_t const   *)(& rxq->used));
#line 1881
  if (tmp___3 > 0) {
#line 1883
    goto ldv_51793;
  } else {

  }
#line 1886
  tmp___4 = atomic_read((atomic_t const   *)(& rxq->used));
#line 1886
  tmp___5 = ldv__builtin_expect(tmp___4 != 0, 0L);
#line 1886
  if (tmp___5 != 0L) {
#line 1886
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"),
                         "i" (1886), "i" (12UL));
    ldv_51796: ;
#line 1886
    goto ldv_51796;
  } else {

  }
#line 1887
  tmp___6 = 0U;
#line 1887
  rxq->head = tmp___6;
#line 1887
  rxq->tail = tmp___6;
#line 1888
  return;
}
}
#line 1890 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_tx_compl_clean(struct be_adapter *adapter ) 
{ 
  struct be_tx_obj *txo ;
  struct be_queue_info *txq ;
  struct be_eth_tx_compl *txcp ;
  u16 end_idx ;
  u16 cmpl ;
  u16 timeo ;
  u16 num_wrbs ;
  struct sk_buff *sent_skb ;
  bool dummy_wrb ;
  int i ;
  int pending_txqs ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  int tmp___7 ;

  {
#line 1895
  cmpl = 0U;
#line 1895
  timeo = 0U;
#line 1895
  num_wrbs = 0U;
  ldv_51822: 
#line 1902
  pending_txqs = (int )adapter->num_tx_qs;
#line 1904
  i = 0;
#line 1904
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 1904
  goto ldv_51815;
  ldv_51814: 
#line 1905
  txq = & txo->q;
#line 1906
  goto ldv_51812;
  ldv_51811: 
#line 1907
  tmp = amap_mask(16U);
#line 1907
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 1907
  end_idx = (u16 )tmp___0;
#line 1910
  tmp___1 = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 1910
  num_wrbs = (int )tmp___1 + (int )num_wrbs;
#line 1912
  cmpl = (u16 )((int )cmpl + 1);
  ldv_51812: 
#line 1906
  txcp = be_tx_compl_get(& txo->cq);
#line 1906
  if ((unsigned long )txcp != (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 1908
    goto ldv_51811;
  } else {

  }

#line 1914
  if ((unsigned int )cmpl != 0U) {
#line 1915
    be_cq_notify(adapter, (int )txo->cq.id, 0, (int )cmpl);
#line 1916
    atomic_sub((int )num_wrbs, & txq->used);
#line 1917
    cmpl = 0U;
#line 1918
    num_wrbs = 0U;
  } else {

  }
#line 1920
  tmp___2 = atomic_read((atomic_t const   *)(& txq->used));
#line 1920
  if (tmp___2 == 0) {
#line 1921
    pending_txqs = pending_txqs - 1;
  } else {

  }
#line 1904
  i = i + 1;
#line 1904
  txo = txo + 1;
  ldv_51815: ;
#line 1904
  if ((u32 )i < adapter->num_tx_qs) {
#line 1906
    goto ldv_51814;
  } else {

  }

#line 1924
  if (pending_txqs == 0) {
#line 1925
    goto ldv_51817;
  } else {
#line 1924
    timeo = (u16 )((int )timeo + 1);
#line 1924
    if ((unsigned int )timeo > 200U) {
#line 1925
      goto ldv_51817;
    } else {

    }
  }
#line 1927
  if (1) {
#line 1927
    __const_udelay(4295000UL);
  } else {
#line 1927
    __ms = 1UL;
#line 1927
    goto ldv_51820;
    ldv_51819: 
#line 1927
    __const_udelay(4295000UL);
    ldv_51820: 
#line 1927
    tmp___3 = __ms;
#line 1927
    __ms = __ms - 1UL;
#line 1927
    if (tmp___3 != 0UL) {
#line 1929
      goto ldv_51819;
    } else {

    }

  }
#line 1928
  goto ldv_51822;
  ldv_51817: 
#line 1930
  i = 0;
#line 1930
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 1930
  goto ldv_51827;
  ldv_51826: 
#line 1931
  txq = & txo->q;
#line 1932
  tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
#line 1932
  if (tmp___5 != 0) {
#line 1933
    tmp___4 = atomic_read((atomic_t const   *)(& txq->used));
#line 1933
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%d pending tx-compls\n",
            tmp___4);
  } else {

  }
#line 1937
  goto ldv_51824;
  ldv_51823: 
#line 1938
  sent_skb = txo->sent_skb_list[(int )txq->tail];
#line 1939
  end_idx = txq->tail;
#line 1940
  tmp___6 = wrb_cnt_for_skb(adapter, sent_skb, & dummy_wrb);
#line 1940
  num_wrbs = (u16 )tmp___6;
#line 1942
  index_adv(& end_idx, (int )((unsigned int )num_wrbs + 65535U), (int )txq->len);
#line 1943
  num_wrbs = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 1944
  atomic_sub((int )num_wrbs, & txq->used);
  ldv_51824: 
#line 1937
  tmp___7 = atomic_read((atomic_t const   *)(& txq->used));
#line 1937
  if (tmp___7 != 0) {
#line 1939
    goto ldv_51823;
  } else {

  }
#line 1930
  i = i + 1;
#line 1930
  txo = txo + 1;
  ldv_51827: ;
#line 1930
  if ((u32 )i < adapter->num_tx_qs) {
#line 1932
    goto ldv_51826;
  } else {

  }

#line 1937
  return;
}
}
#line 1949 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_evt_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 1954
  i = 0;
#line 1954
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 1954
  goto ldv_51835;
  ldv_51834: ;
#line 1955
  if ((int )eqo->q.created) {
#line 1956
    be_eq_clean(eqo);
#line 1957
    be_cmd_q_destroy(adapter, & eqo->q, 1);
  } else {

  }
#line 1959
  be_queue_free(adapter, & eqo->q);
#line 1954
  i = i + 1;
#line 1954
  eqo = eqo + 1;
  ldv_51835: ;
#line 1954
  if ((u32 )i < adapter->num_evt_qs) {
#line 1956
    goto ldv_51834;
  } else {

  }

#line 1961
  return;
}
}
#line 1963 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_evt_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_eq_obj *eqo ;
  int i ;
  int rc ;

  {
#line 1969
  adapter->num_evt_qs = adapter->num_msix_vec != 0U ? adapter->num_msix_vec : 1U;
#line 1971
  i = 0;
#line 1971
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 1971
  goto ldv_51845;
  ldv_51844: 
#line 1972
  eqo->adapter = adapter;
#line 1973
  eqo->tx_budget = 256U;
#line 1974
  eqo->idx = (u8 )i;
#line 1975
  eqo->max_eqd = 96U;
#line 1976
  eqo->enable_aic = 1;
#line 1978
  eq = & eqo->q;
#line 1979
  rc = be_queue_alloc(adapter, eq, 1024, 4);
#line 1981
  if (rc != 0) {
#line 1982
    return (rc);
  } else {

  }
#line 1984
  rc = be_cmd_eq_create(adapter, eq, (int )eqo->cur_eqd);
#line 1985
  if (rc != 0) {
#line 1986
    return (rc);
  } else {

  }
#line 1971
  i = i + 1;
#line 1971
  eqo = eqo + 1;
  ldv_51845: ;
#line 1971
  if ((u32 )i < adapter->num_evt_qs) {
#line 1973
    goto ldv_51844;
  } else {

  }

#line 1988
  return (0);
}
}
#line 1991 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_mcc_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;

  {
#line 1995
  q = & adapter->mcc_obj.q;
#line 1996
  if ((int )q->created) {
#line 1997
    be_cmd_q_destroy(adapter, q, 5);
  } else {

  }
#line 1998
  be_queue_free(adapter, q);
#line 2000
  q = & adapter->mcc_obj.cq;
#line 2001
  if ((int )q->created) {
#line 2002
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2003
  be_queue_free(adapter, q);
#line 2004
  return;
}
}
#line 2007 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_mcc_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2011
  cq = & adapter->mcc_obj.cq;
#line 2012
  tmp = be_queue_alloc(adapter, cq, 256, 16);
#line 2012
  if (tmp != 0) {
#line 2014
    goto err;
  } else {

  }
#line 2017
  tmp___0 = be_cmd_cq_create(adapter, cq, & ((struct be_eq_obj *)(& adapter->eq_obj))->q,
                             1, 0);
#line 2017
  if (tmp___0 != 0) {
#line 2018
    goto mcc_cq_free;
  } else {

  }
#line 2020
  q = & adapter->mcc_obj.q;
#line 2021
  tmp___1 = be_queue_alloc(adapter, q, 128, 256);
#line 2021
  if (tmp___1 != 0) {
#line 2022
    goto mcc_cq_destroy;
  } else {

  }
#line 2024
  tmp___2 = be_cmd_mccq_create(adapter, q, cq);
#line 2024
  if (tmp___2 != 0) {
#line 2025
    goto mcc_q_free;
  } else {

  }
#line 2027
  return (0);
  mcc_q_free: 
#line 2030
  be_queue_free(adapter, q);
  mcc_cq_destroy: 
#line 2032
  be_cmd_q_destroy(adapter, cq, 2);
  mcc_cq_free: 
#line 2034
  be_queue_free(adapter, cq);
  err: ;
#line 2036
  return (-1);
}
}
#line 2039 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_tx_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_tx_obj *txo ;
  u8 i ;

  {
#line 2045
  i = 0U;
#line 2045
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2045
  goto ldv_51867;
  ldv_51866: 
#line 2046
  q = & txo->q;
#line 2047
  if ((int )q->created) {
#line 2048
    be_cmd_q_destroy(adapter, q, 3);
  } else {

  }
#line 2049
  be_queue_free(adapter, q);
#line 2051
  q = & txo->cq;
#line 2052
  if ((int )q->created) {
#line 2053
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2054
  be_queue_free(adapter, q);
#line 2045
  i = (u8 )((int )i + 1);
#line 2045
  txo = txo + 1;
  ldv_51867: ;
#line 2045
  if ((u32 )i < adapter->num_tx_qs) {
#line 2047
    goto ldv_51866;
  } else {

  }

#line 2052
  return;
}
}
#line 2058 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_num_txqs_want(struct be_adapter *adapter ) 
{ 
  bool tmp ;

  {
#line 2060
  if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && ((adapter->dev_num_vfs != 0U && num_vfs != 0U) && (unsigned int )adapter->virtfn == 0U)) {
#line 2064
    return (1);
  } else {
#line 2060
    tmp = be_is_mc(adapter);
#line 2060
    if ((int )tmp) {
#line 2064
      return (1);
    } else
#line 2060
    if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 2064
      return (1);
    } else
#line 2060
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 2064
      return (1);
    } else {
#line 2066
      return ((int )adapter->max_tx_queues);
    }
  }
}
}
#line 2069 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_tx_cqs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *cq ;
  struct be_queue_info *eq ;
  int status ;
  struct be_tx_obj *txo ;
  u8 i ;
  int tmp ;

  {
#line 2076
  tmp = be_num_txqs_want(adapter);
#line 2076
  adapter->num_tx_qs = (u32 )tmp;
#line 2077
  if (adapter->num_tx_qs != 8U) {
#line 2078
    rtnl_lock();
#line 2079
    netif_set_real_num_tx_queues(adapter->netdev, adapter->num_tx_qs);
#line 2081
    rtnl_unlock();
  } else {

  }
#line 2084
  i = 0U;
#line 2084
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2084
  goto ldv_51881;
  ldv_51880: 
#line 2085
  cq = & txo->cq;
#line 2086
  status = be_queue_alloc(adapter, cq, 1024, 16);
#line 2088
  if (status != 0) {
#line 2089
    return (status);
  } else {

  }
#line 2094
  eq = & adapter->eq_obj[(u32 )i % adapter->num_evt_qs].q;
#line 2095
  status = be_cmd_cq_create(adapter, cq, eq, 0, 3);
#line 2096
  if (status != 0) {
#line 2097
    return (status);
  } else {

  }
#line 2084
  i = (u8 )((int )i + 1);
#line 2084
  txo = txo + 1;
  ldv_51881: ;
#line 2084
  if ((u32 )i < adapter->num_tx_qs) {
#line 2086
    goto ldv_51880;
  } else {

  }

#line 2099
  return (0);
}
}
#line 2102 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_tx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_tx_obj *txo ;
  int i ;
  int status ;

  {
#line 2107
  i = 0;
#line 2107
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2107
  goto ldv_51890;
  ldv_51889: 
#line 2108
  status = be_queue_alloc(adapter, & txo->q, 2048, 16);
#line 2110
  if (status != 0) {
#line 2111
    return (status);
  } else {

  }
#line 2113
  status = be_cmd_txq_create(adapter, txo);
#line 2114
  if (status != 0) {
#line 2115
    return (status);
  } else {

  }
#line 2107
  i = i + 1;
#line 2107
  txo = txo + 1;
  ldv_51890: ;
#line 2107
  if ((u32 )i < adapter->num_tx_qs) {
#line 2109
    goto ldv_51889;
  } else {

  }
#line 2118
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d TX queue(s)\n",
            adapter->num_tx_qs);
#line 2120
  return (0);
}
}
#line 2123 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_cqs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2129
  i = 0;
#line 2129
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2129
  goto ldv_51899;
  ldv_51898: 
#line 2130
  q = & rxo->cq;
#line 2131
  if ((int )q->created) {
#line 2132
    be_cmd_q_destroy(adapter, q, 2);
  } else {

  }
#line 2133
  be_queue_free(adapter, q);
#line 2129
  i = i + 1;
#line 2129
  rxo = rxo + 1;
  ldv_51899: ;
#line 2129
  if ((u32 )i < adapter->num_rx_qs) {
#line 2131
    goto ldv_51898;
  } else {

  }

#line 2136
  return;
}
}
#line 2137 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_rx_cqs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int tmp ;

  {
#line 2146
  adapter->num_rx_qs = adapter->num_msix_vec != 0U && adapter->num_msix_vec > 1U ? (adapter->num_msix_vec != 0U ? adapter->num_msix_vec + 1U : 2U) : 1U;
#line 2148
  if (adapter->num_rx_qs != 9U) {
#line 2149
    rtnl_lock();
#line 2150
    netif_set_real_num_rx_queues(adapter->netdev, adapter->num_rx_qs);
#line 2152
    rtnl_unlock();
  } else {

  }
#line 2155
  tmp = __get_order((unsigned long )rx_frag_size);
#line 2155
  adapter->big_page_size = (u32 )((unsigned long )(1 << tmp)) * 4096U;
#line 2156
  i = 0;
#line 2156
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2156
  goto ldv_51910;
  ldv_51909: 
#line 2157
  rxo->adapter = adapter;
#line 2158
  cq = & rxo->cq;
#line 2159
  rc = be_queue_alloc(adapter, cq, 1024, 16);
#line 2161
  if (rc != 0) {
#line 2162
    return (rc);
  } else {

  }
#line 2164
  eq = & adapter->eq_obj[(u32 )i % adapter->num_evt_qs].q;
#line 2165
  rc = be_cmd_cq_create(adapter, cq, eq, 0, 3);
#line 2166
  if (rc != 0) {
#line 2167
    return (rc);
  } else {

  }
#line 2156
  i = i + 1;
#line 2156
  rxo = rxo + 1;
  ldv_51910: ;
#line 2156
  if ((u32 )i < adapter->num_rx_qs) {
#line 2158
    goto ldv_51909;
  } else {

  }
#line 2170
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d RSS queue(s) and 1 default RX queue\n",
            adapter->num_rx_qs - 1U);
#line 2173
  return (0);
}
}
#line 2176 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static irqreturn_t be_intx(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;
  struct be_adapter *adapter ;
  int num_evts ;
  bool tmp ;
  u16 tmp___0 ;

  {
#line 2178
  eqo = (struct be_eq_obj *)dev;
#line 2179
  adapter = eqo->adapter;
#line 2180
  num_evts = 0;
#line 2190
  tmp = napi_schedule_prep(& eqo->napi);
#line 2190
  if ((int )tmp) {
#line 2191
    num_evts = events_get(eqo);
#line 2192
    __napi_schedule(& eqo->napi);
#line 2193
    if (num_evts != 0) {
#line 2194
      eqo->spurious_intr = 0U;
    } else {

    }
  } else {

  }
#line 2196
  be_eq_notify(adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num_evts));
#line 2202
  if (num_evts != 0) {
#line 2203
    return (1);
  } else {
#line 2202
    tmp___0 = eqo->spurious_intr;
#line 2202
    eqo->spurious_intr = (u16 )((int )eqo->spurious_intr + 1);
#line 2202
    if ((unsigned int )tmp___0 == 0U) {
#line 2203
      return (1);
    } else {
#line 2205
      return (0);
    }
  }
}
}
#line 2208 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static irqreturn_t be_msix(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;

  {
#line 2210
  eqo = (struct be_eq_obj *)dev;
#line 2212
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 2213
  napi_schedule(& eqo->napi);
#line 2214
  return (1);
}
}
#line 2217 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static bool do_gro(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 2219
  return ((bool )((unsigned int )rxcp->tcpf != 0U && (unsigned int )rxcp->err == 0U));
}
}
#line 2222 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_process_rx(struct be_rx_obj *rxo , struct napi_struct *napi , int budget ) 
{ 
  struct be_adapter *adapter ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  u32 work_done ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 2225
  adapter = rxo->adapter;
#line 2226
  rx_cq = & rxo->cq;
#line 2230
  work_done = 0U;
#line 2230
  goto ldv_51939;
  ldv_51938: 
#line 2231
  rxcp = be_rx_compl_get(rxo);
#line 2232
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2233
    goto ldv_51936;
  } else {

  }
#line 2236
  tmp = ldv__builtin_expect((unsigned int )rxcp->num_rcvd == 0U, 0L);
#line 2236
  if (tmp != 0L) {
#line 2237
    goto loop_continue;
  } else {

  }
#line 2240
  tmp___0 = ldv__builtin_expect((unsigned int )rxcp->pkt_size == 0U, 0L);
#line 2240
  if (tmp___0 != 0L) {
#line 2241
    be_rx_compl_discard(rxo, rxcp);
#line 2242
    goto loop_continue;
  } else {

  }
#line 2248
  tmp___1 = ldv__builtin_expect((u32 )rxcp->port != adapter->port_num, 0L);
#line 2248
  if (tmp___1 != 0L) {
#line 2248
    tmp___2 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 57888U, 0L);
#line 2248
    if (tmp___2 != 0L) {
#line 2248
      tmp___3 = ldv__builtin_expect((unsigned int )(adapter->pdev)->device != 57896U,
                                 0L);
#line 2248
      if (tmp___3 != 0L) {
#line 2248
        tmp___4 = 1;
      } else {
#line 2248
        tmp___4 = 0;
      }
    } else {
#line 2248
      tmp___4 = 0;
    }
#line 2248
    if (tmp___4 != 0) {
#line 2250
      be_rx_compl_discard(rxo, rxcp);
#line 2251
      goto loop_continue;
    } else {

    }
  } else {

  }
#line 2254
  tmp___5 = do_gro(rxcp);
#line 2254
  if ((int )tmp___5) {
#line 2255
    be_rx_compl_process_gro(rxo, napi, rxcp);
  } else {
#line 2257
    be_rx_compl_process(rxo, rxcp);
  }
  loop_continue: 
#line 2259
  be_rx_stats_update(rxo, rxcp);
#line 2230
  work_done = work_done + 1U;
  ldv_51939: ;
#line 2230
  if ((u32 )budget > work_done) {
#line 2232
    goto ldv_51938;
  } else {

  }
  ldv_51936: ;
#line 2262
  if (work_done != 0U) {
#line 2263
    be_cq_notify(adapter, (int )rx_cq->id, 1, (int )((u16 )work_done));
#line 2265
    tmp___6 = atomic_read((atomic_t const   *)(& rxo->q.used));
#line 2265
    if (tmp___6 <= 959) {
#line 2266
      be_post_rx_frags(rxo, 32U);
    } else {

    }
  } else {

  }
#line 2269
  return ((int )work_done);
}
}
#line 2272 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool be_process_tx(struct be_adapter *adapter , struct be_tx_obj *txo , int budget ,
                          int idx ) 
{ 
  struct be_eth_tx_compl *txcp ;
  int num_wrbs ;
  int work_done ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2276
  num_wrbs = 0;
#line 2278
  work_done = 0;
#line 2278
  goto ldv_51951;
  ldv_51950: 
#line 2279
  txcp = be_tx_compl_get(& txo->cq);
#line 2280
  if ((unsigned long )txcp == (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 2281
    goto ldv_51949;
  } else {

  }
#line 2282
  tmp = amap_mask(16U);
#line 2282
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 2282
  tmp___1 = be_tx_compl_process(adapter, txo, (int )((u16 )tmp___0));
#line 2282
  num_wrbs = (int )tmp___1 + num_wrbs;
#line 2278
  work_done = work_done + 1;
  ldv_51951: ;
#line 2278
  if (work_done < budget) {
#line 2280
    goto ldv_51950;
  } else {

  }
  ldv_51949: ;
#line 2287
  if (work_done != 0) {
#line 2288
    be_cq_notify(adapter, (int )txo->cq.id, 1, (int )((u16 )work_done));
#line 2289
    atomic_sub(num_wrbs, & txo->q.used);
#line 2293
    tmp___2 = __netif_subqueue_stopped((struct net_device  const  *)adapter->netdev,
                                       (int )((u16 )idx));
#line 2293
    if ((int )tmp___2) {
#line 2293
      tmp___3 = atomic_read((atomic_t const   *)(& txo->q.used));
#line 2293
      if (tmp___3 < (int )((unsigned int )txo->q.len / 2U)) {
#line 2295
        netif_wake_subqueue(adapter->netdev, (int )((u16 )idx));
      } else {

      }
    } else {

    }
#line 2298
    u64_stats_update_begin(& txo->stats.sync_compl);
#line 2299
    txo->stats.tx_compl = txo->stats.tx_compl + (u64 )work_done;
#line 2300
    u64_stats_update_begin(& txo->stats.sync_compl);
  } else {

  }
#line 2302
  return (work_done < budget);
}
}
#line 2305 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
int be_poll(struct napi_struct *napi , int budget ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  int max_work ;
  int work ;
  int i ;
  int num_evts ;
  bool tx_done ;
  int _max1 ;
  int _max2 ;

  {
#line 2307
  __mptr = (struct napi_struct  const  *)napi;
#line 2307
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffff98UL;
#line 2308
  adapter = eqo->adapter;
#line 2309
  max_work = 0;
#line 2312
  num_evts = events_get(eqo);
#line 2315
  i = (int )eqo->idx;
#line 2315
  goto ldv_51966;
  ldv_51965: 
#line 2316
  tx_done = be_process_tx(adapter, (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i,
                          (int )eqo->tx_budget, i);
#line 2318
  if (! tx_done) {
#line 2319
    max_work = budget;
  } else {

  }
#line 2315
  i = (int )(adapter->num_evt_qs + (u32 )i);
  ldv_51966: ;
#line 2315
  if ((u32 )i < adapter->num_tx_qs) {
#line 2317
    goto ldv_51965;
  } else {

  }
#line 2326
  i = (int )eqo->idx;
#line 2326
  goto ldv_51972;
  ldv_51971: 
#line 2327
  work = be_process_rx((struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i,
                       napi, budget);
#line 2328
  _max1 = work;
#line 2328
  _max2 = max_work;
#line 2328
  max_work = _max1 > _max2 ? _max1 : _max2;
#line 2326
  i = (int )(adapter->num_evt_qs + (u32 )i);
  ldv_51972: ;
#line 2326
  if ((u32 )i < adapter->num_rx_qs) {
#line 2328
    goto ldv_51971;
  } else {

  }

#line 2331
  if ((unsigned int )eqo->idx == 0U) {
#line 2332
    be_process_mcc(adapter);
  } else {

  }
#line 2334
  if (max_work < budget) {
#line 2335
    napi_complete(napi);
#line 2336
    be_eq_notify(adapter, (int )eqo->q.id, 1, 0, (int )((u16 )num_evts));
  } else {
#line 2339
    be_eq_notify(adapter, (int )eqo->q.id, 0, 0, (int )((u16 )num_evts));
  }
#line 2341
  return (max_work);
}
}
#line 2344 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void be_detect_error(struct be_adapter *adapter ) 
{ 
  u32 ue_lo ;
  u32 ue_hi ;
  u32 ue_lo_mask ;
  u32 ue_hi_mask ;
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;
  u32 i ;
  bool tmp ;

  {
#line 2346
  ue_lo = 0U;
#line 2346
  ue_hi = 0U;
#line 2346
  ue_lo_mask = 0U;
#line 2346
  ue_hi_mask = 0U;
#line 2347
  sliport_status = 0U;
#line 2347
  sliport_err1 = 0U;
#line 2347
  sliport_err2 = 0U;
#line 2350
  tmp = be_hw_error(adapter);
#line 2350
  if ((int )tmp) {
#line 2351
    return;
  } else {

  }
#line 2353
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2354
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 2355
    if ((int )sliport_status < 0) {
#line 2356
      sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 2358
      sliport_err2 = ioread32((void *)adapter->db + 1040U);
    } else {

    }
  } else {
#line 2362
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 160, & ue_lo);
#line 2364
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 164, & ue_hi);
#line 2366
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 168, & ue_lo_mask);
#line 2368
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 172, & ue_hi_mask);
#line 2371
    ue_lo = ~ ue_lo_mask & ue_lo;
#line 2372
    ue_hi = ~ ue_hi_mask & ue_hi;
  }
#line 2379
  if ((int )sliport_status < 0) {
#line 2380
    adapter->hw_error = 1;
#line 2381
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Error detected in the card\n");
  } else {

  }
#line 2385
  if ((int )sliport_status < 0) {
#line 2386
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport status 0x%x\n",
            sliport_status);
#line 2388
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport error1 0x%x\n",
            sliport_err1);
#line 2390
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport error2 0x%x\n",
            sliport_err2);
  } else {

  }
#line 2394
  if (ue_lo != 0U) {
#line 2395
    i = 0U;
#line 2395
    goto ldv_51986;
    ldv_51985: ;
#line 2396
    if ((int )ue_lo & 1) {
#line 2397
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UE: %s bit set\n",
              ue_status_low_desc[i]);
    } else {

    }
#line 2395
    ue_lo = ue_lo >> 1;
#line 2395
    i = i + 1U;
    ldv_51986: ;
#line 2395
    if (ue_lo != 0U) {
#line 2397
      goto ldv_51985;
    } else {

    }

  } else {

  }
#line 2402
  if (ue_hi != 0U) {
#line 2403
    i = 0U;
#line 2403
    goto ldv_51989;
    ldv_51988: ;
#line 2404
    if ((int )ue_hi & 1) {
#line 2405
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UE: %s bit set\n",
              ue_status_hi_desc[i]);
    } else {

    }
#line 2403
    ue_hi = ue_hi >> 1;
#line 2403
    i = i + 1U;
    ldv_51989: ;
#line 2403
    if (ue_hi != 0U) {
#line 2405
      goto ldv_51988;
    } else {

    }

  } else {

  }
#line 2411
  return;
}
}
#line 2412 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_msix_disable(struct be_adapter *adapter ) 
{ 


  {
#line 2414
  if (adapter->num_msix_vec != 0U) {
#line 2415
    pci_disable_msix(adapter->pdev);
#line 2416
    adapter->num_msix_vec = 0U;
  } else {

  }
#line 2418
  return;
}
}
#line 2420 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static uint be_num_rss_want(struct be_adapter *adapter ) 
{ 
  u32 num ;
  u32 __min1 ;
  u32 __min2 ;
  int tmp ;

  {
#line 2422
  num = 0U;
#line 2424
  if ((adapter->function_caps & 2U) != 0U && (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (((adapter->dev_num_vfs == 0U || num_vfs == 0U) || (unsigned int )adapter->virtfn != 0U) && (unsigned int )adapter->virtfn == 0U))) {
#line 2427
    num = (u32 )adapter->max_rss_queues;
#line 2428
    __min1 = num;
#line 2428
    tmp = netif_get_num_default_rss_queues();
#line 2428
    __min2 = (unsigned int )tmp;
#line 2428
    num = __min1 < __min2 ? __min1 : __min2;
  } else {

  }
#line 2430
  return (num);
}
}
#line 2433 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_msix_enable(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  int num_vec ;
  int num_roce_vec ;
  struct device *dev ;
  uint _min1 ;
  uint tmp ;
  unsigned int _min2 ;
  unsigned int tmp___0 ;
  u32 __min1 ;
  u32 __min2 ;
  unsigned int tmp___1 ;
  int _min1___0 ;
  int _min2___0 ;
  int _min1___1 ;
  int _min2___1 ;
  int _max1 ;
  int _max2 ;

  {
#line 2436
  num_roce_vec = 0;
#line 2437
  dev = & (adapter->pdev)->dev;
#line 2440
  tmp = be_num_rss_want(adapter);
#line 2440
  _min1 = tmp;
#line 2440
  tmp___0 = cpumask_weight(cpu_online_mask);
#line 2440
  _min2 = tmp___0;
#line 2440
  num_vec = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2441
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 2442
    __min1 = 16U;
#line 2442
    tmp___1 = cpumask_weight(cpu_online_mask);
#line 2442
    __min2 = tmp___1 + 1U;
#line 2442
    num_roce_vec = (int )(__min1 < __min2 ? __min1 : __min2);
#line 2444
    _min1___0 = num_roce_vec;
#line 2444
    _min2___0 = 5;
#line 2444
    num_roce_vec = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 2445
    num_vec = num_vec + num_roce_vec;
#line 2446
    _min1___1 = num_vec;
#line 2446
    _min2___1 = 13;
#line 2446
    num_vec = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
  } else {

  }
#line 2448
  _max1 = num_vec;
#line 2448
  _max2 = 1;
#line 2448
  num_vec = _max1 > _max2 ? _max1 : _max2;
#line 2450
  i = 0;
#line 2450
  goto ldv_52025;
  ldv_52024: 
#line 2451
  adapter->msix_entries[i].entry = (u16 )i;
#line 2450
  i = i + 1;
  ldv_52025: ;
#line 2450
  if (i < num_vec) {
#line 2452
    goto ldv_52024;
  } else {

  }
#line 2453
  status = pci_enable_msix(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                           num_vec);
#line 2454
  if (status == 0) {
#line 2455
    goto done;
  } else
#line 2456
  if (status > 0) {
#line 2457
    num_vec = status;
#line 2458
    status = pci_enable_msix(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                             num_vec);
#line 2460
    if (status == 0) {
#line 2461
      goto done;
    } else {

    }
  } else {

  }
#line 2464
  dev_warn((struct device  const  *)dev, "MSIx enable failed\n");
#line 2466
  if ((unsigned int )adapter->virtfn != 0U) {
#line 2467
    return (status);
  } else {

  }
#line 2468
  return (0);
  done: ;
#line 2470
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 2471
    if (num_vec > num_roce_vec) {
#line 2472
      adapter->num_msix_vec = (u32 )(num_vec - num_roce_vec);
#line 2473
      adapter->num_msix_roce_vec = (u32 )num_vec - adapter->num_msix_vec;
    } else {
#line 2476
      adapter->num_msix_vec = (u32 )num_vec;
#line 2477
      adapter->num_msix_roce_vec = 0U;
    }
  } else {
#line 2480
    adapter->num_msix_vec = (u32 )num_vec;
  }
#line 2481
  _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s)\n", adapter->num_msix_vec);
#line 2482
  return (0);
}
}
#line 2485 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static int be_msix_vec_get(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 


  {
#line 2488
  return ((int )adapter->msix_entries[(int )eqo->idx].vector);
}
}
#line 2491 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_msix_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int status ;
  int i ;
  int vec ;
  int tmp ;

  {
#line 2493
  netdev = adapter->netdev;
#line 2497
  i = 0;
#line 2497
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2497
  goto ldv_52042;
  ldv_52041: 
#line 2498
  sprintf((char *)(& eqo->desc), "%s-q%d", (char *)(& netdev->name), i);
#line 2499
  vec = be_msix_vec_get(adapter, eqo);
#line 2500
  status = request_irq((unsigned int )vec, & be_msix, 0UL, (char const   *)(& eqo->desc),
                       (void *)eqo);
#line 2501
  if (status != 0) {
#line 2502
    goto err_msix;
  } else {

  }
#line 2497
  i = i + 1;
#line 2497
  eqo = eqo + 1;
  ldv_52042: ;
#line 2497
  if ((u32 )i < adapter->num_evt_qs) {
#line 2499
    goto ldv_52041;
  } else {

  }

#line 2505
  return (0);
  err_msix: 
#line 2507
  i = i - 1;
#line 2507
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2507
  goto ldv_52045;
  ldv_52044: 
#line 2508
  tmp = be_msix_vec_get(adapter, eqo);
#line 2508
  free_irq((unsigned int )tmp, (void *)eqo);
#line 2507
  i = i - 1;
#line 2507
  eqo = eqo - 1;
  ldv_52045: ;
#line 2507
  if (i >= 0) {
#line 2509
    goto ldv_52044;
  } else {

  }
#line 2509
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "MSIX Request IRQ failed - err %d\n",
           status);
#line 2511
  be_msix_disable(adapter);
#line 2512
  return (status);
}
}
#line 2515 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_irq_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 2517
  netdev = adapter->netdev;
#line 2520
  if (adapter->num_msix_vec != 0U) {
#line 2521
    status = be_msix_register(adapter);
#line 2522
    if (status == 0) {
#line 2523
      goto done;
    } else {

    }
#line 2525
    if ((unsigned int )adapter->virtfn != 0U) {
#line 2526
      return (status);
    } else {

    }
  } else {

  }
#line 2530
  netdev->irq = (adapter->pdev)->irq;
#line 2531
  status = request_irq(netdev->irq, & be_intx, 128UL, (char const   *)(& netdev->name),
                       (void *)(& adapter->eq_obj));
#line 2533
  if (status != 0) {
#line 2534
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "INTx request IRQ failed - err %d\n",
            status);
#line 2536
    return (status);
  } else {

  }
  done: 
#line 2539
  adapter->isr_registered = 1;
#line 2540
  return (0);
}
}
#line 2543 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_irq_unregister(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp ;

  {
#line 2545
  netdev = adapter->netdev;
#line 2549
  if (! adapter->isr_registered) {
#line 2550
    return;
  } else {

  }
#line 2553
  if (adapter->num_msix_vec == 0U) {
#line 2554
    free_irq(netdev->irq, (void *)(& adapter->eq_obj));
#line 2555
    goto done;
  } else {

  }
#line 2559
  i = 0;
#line 2559
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2559
  goto ldv_52061;
  ldv_52060: 
#line 2560
  tmp = be_msix_vec_get(adapter, eqo);
#line 2560
  free_irq((unsigned int )tmp, (void *)eqo);
#line 2559
  i = i + 1;
#line 2559
  eqo = eqo + 1;
  ldv_52061: ;
#line 2559
  if ((u32 )i < adapter->num_evt_qs) {
#line 2561
    goto ldv_52060;
  } else {

  }

  done: 
#line 2563
  adapter->isr_registered = 0;
#line 2564
  return;
}
}
#line 2566 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_rx_qs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2572
  i = 0;
#line 2572
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2572
  goto ldv_52070;
  ldv_52069: 
#line 2573
  q = & rxo->q;
#line 2574
  if ((int )q->created) {
#line 2575
    be_cmd_rxq_destroy(adapter, q);
#line 2576
    be_rx_cq_clean(rxo);
  } else {

  }
#line 2578
  be_queue_free(adapter, q);
#line 2572
  i = i + 1;
#line 2572
  rxo = rxo + 1;
  ldv_52070: ;
#line 2572
  if ((u32 )i < adapter->num_rx_qs) {
#line 2574
    goto ldv_52069;
  } else {

  }

#line 2579
  return;
}
}
#line 2582 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_close(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp___0 ;

  {
#line 2584
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2584
  adapter = (struct be_adapter *)tmp;
#line 2588
  be_roce_dev_close(adapter);
#line 2590
  if ((adapter->flags & 512U) != 0U) {
#line 2591
    i = 0;
#line 2591
    eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2591
    goto ldv_52079;
    ldv_52078: 
#line 2592
    napi_disable(& eqo->napi);
#line 2591
    i = i + 1;
#line 2591
    eqo = eqo + 1;
    ldv_52079: ;
#line 2591
    if ((u32 )i < adapter->num_evt_qs) {
#line 2593
      goto ldv_52078;
    } else {

    }
#line 2593
    adapter->flags = adapter->flags & 4294966783U;
  } else {

  }
#line 2596
  be_async_mcc_disable(adapter);
#line 2601
  be_tx_compl_clean(adapter);
#line 2602
  netif_tx_disable(netdev);
#line 2604
  be_rx_qs_destroy(adapter);
#line 2606
  i = 0;
#line 2606
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2606
  goto ldv_52082;
  ldv_52081: ;
#line 2607
  if (adapter->num_msix_vec != 0U) {
#line 2608
    tmp___0 = be_msix_vec_get(adapter, eqo);
#line 2608
    synchronize_irq((unsigned int )tmp___0);
  } else {
#line 2610
    synchronize_irq(netdev->irq);
  }
#line 2611
  be_eq_clean(eqo);
#line 2606
  i = i + 1;
#line 2606
  eqo = eqo + 1;
  ldv_52082: ;
#line 2606
  if ((u32 )i < adapter->num_evt_qs) {
#line 2608
    goto ldv_52081;
  } else {

  }
#line 2614
  be_irq_unregister(adapter);
#line 2616
  return (0);
}
}
#line 2619 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_rx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  bool tmp ;

  {
#line 2625
  i = 0;
#line 2625
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2625
  goto ldv_52093;
  ldv_52092: 
#line 2626
  rc = be_queue_alloc(adapter, & rxo->q, 1024, 8);
#line 2628
  if (rc != 0) {
#line 2629
    return (rc);
  } else {

  }
#line 2625
  i = i + 1;
#line 2625
  rxo = rxo + 1;
  ldv_52093: ;
#line 2625
  if ((u32 )i < adapter->num_rx_qs) {
#line 2627
    goto ldv_52092;
  } else {

  }
#line 2633
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )(adapter->num_rx_qs - 1U);
#line 2634
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 0U, & rxo->rss_id);
#line 2636
  if (rc != 0) {
#line 2637
    return (rc);
  } else {

  }
#line 2639
  i = 0;
#line 2639
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2639
  goto ldv_52096;
  ldv_52095: 
#line 2640
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 1U, & rxo->rss_id);
#line 2643
  if (rc != 0) {
#line 2644
    return (rc);
  } else {

  }
#line 2639
  i = i + 1;
#line 2639
  rxo = rxo + 1;
  ldv_52096: ;
#line 2639
  if ((u32 )i < adapter->num_rx_qs - 1U) {
#line 2641
    goto ldv_52095;
  } else {

  }
#line 2647
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 2647
  if ((int )tmp) {
#line 2648
    j = 0;
#line 2648
    goto ldv_52102;
    ldv_52101: 
#line 2649
    i = 0;
#line 2649
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2649
    goto ldv_52100;
    ldv_52099: ;
#line 2650
    if (j + i > 127) {
#line 2651
      goto ldv_52098;
    } else {

    }
#line 2652
    rsstable[j + i] = rxo->rss_id;
#line 2649
    i = i + 1;
#line 2649
    rxo = rxo + 1;
    ldv_52100: ;
#line 2649
    if ((u32 )i < adapter->num_rx_qs - 1U) {
#line 2651
      goto ldv_52099;
    } else {

    }
    ldv_52098: 
#line 2648
    j = (int )((adapter->num_rx_qs + (u32 )j) - 1U);
    ldv_52102: ;
#line 2648
    if (j <= 127) {
#line 2650
      goto ldv_52101;
    } else {

    }
#line 2655
    adapter->rss_flags = 15ULL;
#line 2658
    if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 2659
      adapter->rss_flags = adapter->rss_flags | 48ULL;
    } else {

    }
#line 2662
    rc = be_cmd_rss_config(adapter, (u8 *)(& rsstable), (u32 )adapter->rss_flags,
                           128);
#line 2664
    if (rc != 0) {
#line 2665
      adapter->rss_flags = 0ULL;
#line 2666
      return (rc);
    } else {

    }
  } else {

  }
#line 2671
  i = 0;
#line 2671
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2671
  goto ldv_52105;
  ldv_52104: 
#line 2672
  be_post_rx_frags(rxo, 208U);
#line 2671
  i = i + 1;
#line 2671
  rxo = rxo + 1;
  ldv_52105: ;
#line 2671
  if ((u32 )i < adapter->num_rx_qs) {
#line 2673
    goto ldv_52104;
  } else {

  }

#line 2673
  return (0);
}
}
#line 2676 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_open(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u8 link_status ;
  int status ;
  int i ;

  {
#line 2678
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2678
  adapter = (struct be_adapter *)tmp;
#line 2685
  status = be_rx_qs_create(adapter);
#line 2686
  if (status != 0) {
#line 2687
    goto err;
  } else {

  }
#line 2689
  status = be_irq_register(adapter);
#line 2690
  if (status != 0) {
#line 2691
    goto err;
  } else {

  }
#line 2693
  i = 0;
#line 2693
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2693
  goto ldv_52119;
  ldv_52118: 
#line 2694
  be_cq_notify(adapter, (int )rxo->cq.id, 1, 0);
#line 2693
  i = i + 1;
#line 2693
  rxo = rxo + 1;
  ldv_52119: ;
#line 2693
  if ((u32 )i < adapter->num_rx_qs) {
#line 2695
    goto ldv_52118;
  } else {

  }
#line 2696
  i = 0;
#line 2696
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2696
  goto ldv_52122;
  ldv_52121: 
#line 2697
  be_cq_notify(adapter, (int )txo->cq.id, 1, 0);
#line 2696
  i = i + 1;
#line 2696
  txo = txo + 1;
  ldv_52122: ;
#line 2696
  if ((u32 )i < adapter->num_tx_qs) {
#line 2698
    goto ldv_52121;
  } else {

  }
#line 2699
  be_async_mcc_enable(adapter);
#line 2701
  i = 0;
#line 2701
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2701
  goto ldv_52125;
  ldv_52124: 
#line 2702
  napi_enable(& eqo->napi);
#line 2703
  be_eq_notify(adapter, (int )eqo->q.id, 1, 0, 0);
#line 2701
  i = i + 1;
#line 2701
  eqo = eqo + 1;
  ldv_52125: ;
#line 2701
  if ((u32 )i < adapter->num_evt_qs) {
#line 2703
    goto ldv_52124;
  } else {

  }
#line 2705
  adapter->flags = adapter->flags | 512U;
#line 2707
  status = be_cmd_link_status_query(adapter, 0, & link_status, 0U);
#line 2708
  if (status == 0) {
#line 2709
    be_link_status_update(adapter, (int )link_status);
  } else {

  }
#line 2711
  netif_tx_start_all_queues(netdev);
#line 2712
  be_roce_dev_open(adapter);
#line 2713
  return (0);
  err: 
#line 2715
  be_close(adapter->netdev);
#line 2716
  return (-5);
}
}
#line 2719 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_setup_wol(struct be_adapter *adapter , bool enable ) 
{ 
  struct be_dma_mem cmd ;
  int status ;
  u8 mac[6U] ;

  {
#line 2722
  status = 0;
#line 2725
  memset((void *)(& mac), 0, 6UL);
#line 2727
  cmd.size = 604U;
#line 2728
  cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma, 32976U,
                           0);
#line 2730
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2731
    return (-1);
  } else {

  }
#line 2733
  if ((int )enable) {
#line 2734
    status = pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 68, 264U);
#line 2736
    if (status != 0) {
#line 2737
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Could not enable Wake-on-lan\n");
#line 2739
      dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, 0);
#line 2741
      return (status);
    } else {

    }
#line 2743
    status = be_cmd_enable_magic_wol(adapter, (adapter->netdev)->dev_addr, & cmd);
#line 2745
    pci_enable_wake(adapter->pdev, 3, 1);
#line 2746
    pci_enable_wake(adapter->pdev, 4, 1);
  } else {
#line 2748
    status = be_cmd_enable_magic_wol(adapter, (u8 *)(& mac), & cmd);
#line 2749
    pci_enable_wake(adapter->pdev, 3, 0);
#line 2750
    pci_enable_wake(adapter->pdev, 4, 0);
  }
#line 2753
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, 0);
#line 2754
  return (status);
}
}
#line 2763 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vf_eth_addr_config(struct be_adapter *adapter ) 
{ 
  u32 vf ;
  int status ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;
  size_t __len ;
  void *__ret ;

  {
#line 2766
  status = 0;
#line 2770
  be_vf_eth_addr_generate(adapter, (u8 *)(& mac));
#line 2772
  vf = 0U;
#line 2772
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2772
  goto ldv_52145;
  ldv_52144: ;
#line 2773
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2774
    status = be_cmd_set_mac_list(adapter, (u8 *)(& mac), 1, vf + 1U);
  } else {
#line 2776
    status = be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             vf + 1U);
  }
#line 2781
  if (status != 0) {
#line 2782
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Mac address assignment failed for VF %d\n",
            vf);
  } else {
#line 2785
    __len = 6UL;
#line 2785
    if (__len > 63UL) {
#line 2785
      __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), __len);
    } else {
#line 2785
      __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac),
                               __len);
    }
  }
#line 2787
  mac[5] = (unsigned int )mac[5] + 1U;
#line 2772
  vf = vf + 1U;
#line 2772
  vf_cfg = vf_cfg + 1;
  ldv_52145: ;
#line 2772
  if (adapter->num_vfs > vf) {
#line 2774
    goto ldv_52144;
  } else {

  }

#line 2789
  return (status);
}
}
#line 2792 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vfs_mac_query(struct be_adapter *adapter ) 
{ 
  int status ;
  int vf ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;
  bool active ;
  size_t __len ;
  void *__ret ;

  {
#line 2799
  vf = 0;
#line 2799
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2799
  goto ldv_52159;
  ldv_52158: 
#line 2800
  be_cmd_get_mac_from_list(adapter, (u8 *)(& mac), & active, (u32 *)(& vf_cfg->pmac_id),
                           0);
#line 2803
  status = be_cmd_mac_addr_query(adapter, (u8 *)(& mac), 0, (u32 )vf_cfg->if_handle,
                                 0U);
#line 2805
  if (status != 0) {
#line 2806
    return (status);
  } else {

  }
#line 2807
  __len = 6UL;
#line 2807
  if (__len > 63UL) {
#line 2807
    __ret = __memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), __len);
  } else {
#line 2807
    __ret = __builtin_memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac),
                             __len);
  }
#line 2799
  vf = vf + 1;
#line 2799
  vf_cfg = vf_cfg + 1;
  ldv_52159: ;
#line 2799
  if ((u32 )vf < adapter->num_vfs) {
#line 2801
    goto ldv_52158;
  } else {

  }

#line 2809
  return (0);
}
}
#line 2812 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_vf_clear(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u32 vf ;
  int tmp ;

  {
#line 2817
  tmp = be_find_vfs(adapter, 1);
#line 2817
  if (tmp != 0) {
#line 2818
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VFs are assigned to VMs: not disabling VFs\n");
#line 2820
    goto done;
  } else {

  }
#line 2823
  pci_disable_sriov(adapter->pdev);
#line 2825
  vf = 0U;
#line 2825
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2825
  goto ldv_52168;
  ldv_52167: ;
#line 2826
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2827
    be_cmd_set_mac_list(adapter, 0, 0, vf + 1U);
  } else {
#line 2829
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, vf + 1U);
  }
#line 2832
  be_cmd_if_destroy(adapter, vf_cfg->if_handle, vf + 1U);
#line 2825
  vf = vf + 1U;
#line 2825
  vf_cfg = vf_cfg + 1;
  ldv_52168: ;
#line 2825
  if (adapter->num_vfs > vf) {
#line 2827
    goto ldv_52167;
  } else {

  }

  done: 
#line 2835
  kfree((void const   *)adapter->vf_cfg);
#line 2836
  adapter->num_vfs = 0U;
#line 2837
  return;
}
}
#line 2839 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_clear(struct be_adapter *adapter ) 
{ 
  int i ;

  {
#line 2841
  i = 1;
#line 2843
  if ((adapter->flags & 8U) != 0U) {
#line 2844
    cancel_delayed_work_sync(& adapter->work);
#line 2845
    adapter->flags = adapter->flags & 4294967287U;
  } else {

  }
#line 2848
  if (adapter->num_vfs != 0U) {
#line 2849
    be_vf_clear(adapter);
  } else {

  }
#line 2851
  goto ldv_52175;
  ldv_52174: 
#line 2852
  be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                  0U);
#line 2851
  adapter->uc_macs = adapter->uc_macs - 1U;
#line 2851
  i = i + 1;
  ldv_52175: ;
#line 2851
  if (adapter->uc_macs != 0U) {
#line 2853
    goto ldv_52174;
  } else {

  }
#line 2855
  be_cmd_if_destroy(adapter, adapter->if_handle, 0U);
#line 2857
  be_mcc_queues_destroy(adapter);
#line 2858
  be_rx_cqs_destroy(adapter);
#line 2859
  be_tx_queues_destroy(adapter);
#line 2860
  be_evt_queues_destroy(adapter);
#line 2862
  kfree((void const   *)adapter->pmac_id);
#line 2863
  adapter->pmac_id = 0;
#line 2865
  be_msix_disable(adapter);
#line 2866
  return (0);
}
}
#line 2869 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vfs_if_create(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u32 cap_flags ;
  u32 en_flags ;
  u32 vf ;
  int status ;

  {
#line 2875
  cap_flags = 4144U;
#line 2878
  vf = 0U;
#line 2878
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2878
  goto ldv_52187;
  ldv_52186: ;
#line 2879
  if ((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) {
#line 2880
    be_cmd_get_profile_config(adapter, & cap_flags, 0, (int )((unsigned int )((u8 )vf) + 1U));
  } else {

  }
#line 2884
  en_flags = cap_flags & 4144U;
#line 2886
  status = be_cmd_if_create(adapter, cap_flags, en_flags, (u32 *)(& vf_cfg->if_handle),
                            vf + 1U);
#line 2888
  if (status != 0) {
#line 2889
    goto err;
  } else {

  }
#line 2878
  vf = vf + 1U;
#line 2878
  vf_cfg = vf_cfg + 1;
  ldv_52187: ;
#line 2878
  if (adapter->num_vfs > vf) {
#line 2880
    goto ldv_52186;
  } else {

  }

  err: ;
#line 2892
  return (status);
}
}
#line 2895 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vf_setup_init(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  int vf ;
  void *tmp ;

  {
#line 2900
  tmp = kcalloc((size_t )adapter->num_vfs, 24UL, 208U);
#line 2900
  adapter->vf_cfg = (struct be_vf_cfg *)tmp;
#line 2902
  if ((unsigned long )adapter->vf_cfg == (unsigned long )((struct be_vf_cfg *)0)) {
#line 2903
    return (-12);
  } else {

  }
#line 2905
  vf = 0;
#line 2905
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2905
  goto ldv_52195;
  ldv_52194: 
#line 2906
  vf_cfg->if_handle = -1;
#line 2907
  vf_cfg->pmac_id = -1;
#line 2905
  vf = vf + 1;
#line 2905
  vf_cfg = vf_cfg + 1;
  ldv_52195: ;
#line 2905
  if ((u32 )vf < adapter->num_vfs) {
#line 2907
    goto ldv_52194;
  } else {

  }

#line 2909
  return (0);
}
}
#line 2912 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_vf_setup(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u16 def_vlan ;
  u16 lnk_speed ;
  int status ;
  int old_vfs ;
  int vf ;
  struct device *dev ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 2917
  dev = & (adapter->pdev)->dev;
#line 2919
  old_vfs = be_find_vfs(adapter, 0);
#line 2920
  if (old_vfs != 0) {
#line 2921
    _dev_info((struct device  const  *)dev, "%d VFs are already enabled\n", old_vfs);
#line 2922
    if ((unsigned int )old_vfs != num_vfs) {
#line 2923
      dev_warn((struct device  const  *)dev, "Ignoring num_vfs=%d setting\n", num_vfs);
    } else {

    }
#line 2924
    adapter->num_vfs = (u32 )old_vfs;
  } else {
#line 2926
    if (adapter->dev_num_vfs < num_vfs) {
#line 2927
      _dev_info((struct device  const  *)dev, "Device supports %d VFs and not %d\n",
                adapter->dev_num_vfs, num_vfs);
    } else {

    }
#line 2929
    __min1 = (u16 )num_vfs;
#line 2929
    __min2 = (u16 )adapter->dev_num_vfs;
#line 2929
    adapter->num_vfs = (u32 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 2930
    if (adapter->num_vfs == 0U) {
#line 2931
      return (0);
    } else {

    }
  }
#line 2934
  status = be_vf_setup_init(adapter);
#line 2935
  if (status != 0) {
#line 2936
    goto err;
  } else {

  }
#line 2938
  if (old_vfs != 0) {
#line 2939
    vf = 0;
#line 2939
    vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2939
    goto ldv_52212;
    ldv_52211: 
#line 2940
    status = be_cmd_get_if_id(adapter, vf_cfg, vf);
#line 2941
    if (status != 0) {
#line 2942
      goto err;
    } else {

    }
#line 2939
    vf = vf + 1;
#line 2939
    vf_cfg = vf_cfg + 1;
    ldv_52212: ;
#line 2939
    if ((u32 )vf < adapter->num_vfs) {
#line 2941
      goto ldv_52211;
    } else {

    }

  } else {
#line 2945
    status = be_vfs_if_create(adapter);
#line 2946
    if (status != 0) {
#line 2947
      goto err;
    } else {

    }
  }
#line 2950
  if (old_vfs != 0) {
#line 2951
    status = be_vfs_mac_query(adapter);
#line 2952
    if (status != 0) {
#line 2953
      goto err;
    } else {

    }
  } else {
#line 2955
    status = be_vf_eth_addr_config(adapter);
#line 2956
    if (status != 0) {
#line 2957
      goto err;
    } else {

    }
  }
#line 2960
  vf = 0;
#line 2960
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2960
  goto ldv_52215;
  ldv_52214: ;
#line 2964
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && old_vfs == 0) {
#line 2965
    be_cmd_set_qos(adapter, 1000U, (u32 )(vf + 1));
  } else {

  }
#line 2967
  status = be_cmd_link_status_query(adapter, & lnk_speed, 0, (u32 )(vf + 1));
#line 2969
  if (status == 0) {
#line 2970
    vf_cfg->tx_rate = (u32 )lnk_speed;
  } else {

  }
#line 2972
  status = be_cmd_get_hsw_config(adapter, & def_vlan, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle));
#line 2974
  if (status != 0) {
#line 2975
    goto err;
  } else {

  }
#line 2976
  vf_cfg->def_vid = def_vlan;
#line 2978
  be_cmd_enable_vf(adapter, (int )((unsigned int )((u8 )vf) + 1U));
#line 2960
  vf = vf + 1;
#line 2960
  vf_cfg = vf_cfg + 1;
  ldv_52215: ;
#line 2960
  if ((u32 )vf < adapter->num_vfs) {
#line 2962
    goto ldv_52214;
  } else {

  }

#line 2981
  if (old_vfs == 0) {
#line 2982
    status = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
#line 2983
    if (status != 0) {
#line 2984
      dev_err((struct device  const  *)dev, "SRIOV enable failed\n");
#line 2985
      adapter->num_vfs = 0U;
#line 2986
      goto err;
    } else {

    }
  } else {

  }
#line 2989
  return (0);
  err: 
#line 2991
  dev_err((struct device  const  *)dev, "VF setup failed\n");
#line 2992
  be_vf_clear(adapter);
#line 2993
  return (status);
}
}
#line 2996 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_setup_init(struct be_adapter *adapter ) 
{ 


  {
#line 2998
  adapter->vlan_prio_bmap = 255U;
#line 2999
  adapter->phy.link_speed = -1;
#line 3000
  adapter->if_handle = -1;
#line 3001
  adapter->be3_native = 0;
#line 3002
  adapter->promiscuous = 0;
#line 3003
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3004
    adapter->cmd_privileges = 1792U;
  } else {
#line 3006
    adapter->cmd_privileges = 1U;
  }
#line 3007
  return;
}
}
#line 3009 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_get_mac_addr(struct be_adapter *adapter , u8 *mac , u32 if_handle ,
                           bool *active_mac , u32 *pmac_id ) 
{ 
  int status ;
  size_t __len ;
  void *__ret ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3012
  status = 0;
#line 3014
  tmp = is_zero_ether_addr((u8 const   *)(& (adapter->netdev)->perm_addr));
#line 3014
  if (tmp) {
#line 3014
    tmp___0 = 0;
  } else {
#line 3014
    tmp___0 = 1;
  }
#line 3014
  if (tmp___0) {
#line 3015
    __len = 6UL;
#line 3015
    if (__len > 63UL) {
#line 3015
      __ret = __memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr, __len);
    } else {
#line 3015
      __ret = __builtin_memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr,
                               __len);
    }
#line 3016
    if (((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) && (unsigned int )adapter->virtfn != 0U) {
#line 3017
      *active_mac = 1;
    } else {
#line 3019
      *active_mac = 0;
    }
#line 3021
    return (status);
  } else {

  }
#line 3024
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 3025
    status = be_cmd_get_mac_from_list(adapter, mac, active_mac, pmac_id, 0);
#line 3027
    if ((int )*active_mac) {
#line 3028
      status = be_cmd_mac_addr_query(adapter, mac, 0, if_handle, *pmac_id);
    } else {

    }
  } else
#line 3031
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3033
    status = be_cmd_mac_addr_query(adapter, mac, 1, 0U, 0U);
#line 3034
    *active_mac = 0;
  } else {
#line 3037
    status = be_cmd_mac_addr_query(adapter, mac, 0, if_handle, 0U);
#line 3039
    *active_mac = 1;
  }
#line 3041
  return (status);
}
}
#line 3044 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_get_resources(struct be_adapter *adapter ) 
{ 
  u16 dev_num_vfs ;
  int pos ;
  int status ;
  bool profile_present ;
  u16 txq_count ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u16 __min1___2 ;
  u16 __min2___2 ;
  u16 __min1___3 ;
  u16 __min2___3 ;
  u16 __min1___4 ;
  u16 __min2___4 ;
  u16 __min1___5 ;
  u16 __min2___5 ;
  u16 __min1___6 ;
  u16 __min2___6 ;

  {
#line 3048
  profile_present = 0;
#line 3049
  txq_count = 0U;
#line 3051
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 3052
    status = be_cmd_get_func_config(adapter);
#line 3053
    if (status == 0) {
#line 3054
      profile_present = 1;
    } else {

    }
  } else
#line 3055
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )adapter->virtfn == 0U) {
#line 3056
    be_cmd_get_profile_config(adapter, 0, & txq_count, 0);
  } else {

  }
#line 3059
  if ((int )profile_present) {
#line 3061
    __min1 = adapter->max_pmac_cnt;
#line 3061
    __min2 = 30U;
#line 3061
    adapter->max_pmac_cnt = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 3063
    __min1___0 = adapter->max_vlans;
#line 3063
    __min2___0 = 64U;
#line 3063
    adapter->max_vlans = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
#line 3065
    __min1___1 = adapter->max_mcast_mac;
#line 3065
    __min2___1 = 64U;
#line 3065
    adapter->max_mcast_mac = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 3067
    __min1___2 = adapter->max_tx_queues;
#line 3067
    __min2___2 = 8U;
#line 3067
    adapter->max_tx_queues = (u16 )((int )__min1___2 < (int )__min2___2 ? __min1___2 : __min2___2);
#line 3069
    __min1___3 = adapter->max_rss_queues;
#line 3069
    __min2___3 = 8U;
#line 3069
    adapter->max_rss_queues = (u16 )((int )__min1___3 < (int )__min2___3 ? __min1___3 : __min2___3);
#line 3071
    __min1___4 = adapter->max_event_queues;
#line 3071
    __min2___4 = 8U;
#line 3071
    adapter->max_event_queues = (u16 )((int )__min1___4 < (int )__min2___4 ? __min1___4 : __min2___4);
#line 3075
    if ((unsigned int )adapter->max_rss_queues != 0U && (int )adapter->max_rss_queues == (int )adapter->max_rx_queues) {
#line 3077
      adapter->max_rss_queues = (unsigned int )adapter->max_rss_queues + 65535U;
    } else {

    }
#line 3079
    if ((int )adapter->max_event_queues < (int )adapter->max_rss_queues) {
#line 3080
      adapter->max_rss_queues = adapter->max_event_queues;
    } else {

    }
  } else {
#line 3083
    if ((unsigned int )adapter->virtfn == 0U) {
#line 3084
      adapter->max_pmac_cnt = 30U;
    } else {
#line 3086
      adapter->max_pmac_cnt = 2U;
    }
#line 3088
    if ((adapter->function_mode & 1024U) != 0U) {
#line 3089
      adapter->max_vlans = 8U;
    } else {
#line 3091
      adapter->max_vlans = 64U;
    }
#line 3093
    adapter->max_mcast_mac = 64U;
#line 3094
    adapter->max_tx_queues = (unsigned int )txq_count != 0U ? txq_count : 8U;
#line 3095
    __min1___5 = adapter->max_tx_queues;
#line 3095
    __min2___5 = 8U;
#line 3095
    adapter->max_tx_queues = (u16 )((int )__min1___5 < (int )__min2___5 ? __min1___5 : __min2___5);
#line 3097
    adapter->max_rss_queues = (int )adapter->be3_native ? 8U : 4U;
#line 3099
    adapter->max_event_queues = 8U;
#line 3101
    adapter->if_cap_flags = 6840U;
#line 3109
    if ((adapter->function_caps & 2U) != 0U) {
#line 3110
      adapter->if_cap_flags = adapter->if_cap_flags | 4U;
    } else {

    }
  }
#line 3113
  pos = pci_find_ext_capability(adapter->pdev, 16);
#line 3114
  if (pos != 0) {
#line 3115
    pci_read_config_word((struct pci_dev  const  *)adapter->pdev, pos + 14, & dev_num_vfs);
#line 3117
    if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3118
      __min1___6 = dev_num_vfs;
#line 3118
      __min2___6 = 30U;
#line 3118
      dev_num_vfs = (u16 )((int )__min1___6 < (int )__min2___6 ? __min1___6 : __min2___6);
    } else {

    }
#line 3119
    adapter->dev_num_vfs = (u32 )dev_num_vfs;
  } else {

  }
#line 3121
  return;
}
}
#line 3124 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_get_config(struct be_adapter *adapter ) 
{ 
  int status ;
  void *tmp ;

  {
#line 3128
  status = be_cmd_query_fw_cfg(adapter, & adapter->port_num, & adapter->function_mode,
                               & adapter->function_caps, & adapter->asic_rev);
#line 3132
  if (status != 0) {
#line 3133
    goto err;
  } else {

  }
#line 3135
  be_get_resources(adapter);
#line 3138
  tmp = kcalloc((size_t )((int )adapter->max_pmac_cnt + 1), 4UL, 208U);
#line 3138
  adapter->pmac_id = (u32 *)tmp;
#line 3140
  if ((unsigned long )adapter->pmac_id == (unsigned long )((u32 *)0)) {
#line 3141
    status = -12;
#line 3142
    goto err;
  } else {

  }
  err: ;
#line 3146
  return (status);
}
}
#line 3149 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  u32 en_flags ;
  u32 tx_fc ;
  u32 rx_fc ;
  int status ;
  u8 mac[6U] ;
  bool active_mac ;
  bool tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 3151
  dev = & (adapter->pdev)->dev;
#line 3158
  be_setup_init(adapter);
#line 3160
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3161
    be_cmd_req_native_mode(adapter);
  } else {

  }
#line 3163
  status = be_get_config(adapter);
#line 3164
  if (status != 0) {
#line 3165
    goto err;
  } else {

  }
#line 3167
  status = be_msix_enable(adapter);
#line 3168
  if (status != 0) {
#line 3169
    goto err;
  } else {

  }
#line 3171
  status = be_evt_queues_create(adapter);
#line 3172
  if (status != 0) {
#line 3173
    goto err;
  } else {

  }
#line 3175
  status = be_tx_cqs_create(adapter);
#line 3176
  if (status != 0) {
#line 3177
    goto err;
  } else {

  }
#line 3179
  status = be_rx_cqs_create(adapter);
#line 3180
  if (status != 0) {
#line 3181
    goto err;
  } else {

  }
#line 3183
  status = be_mcc_queues_create(adapter);
#line 3184
  if (status != 0) {
#line 3185
    goto err;
  } else {

  }
#line 3187
  be_cmd_get_fn_privileges(adapter, & adapter->cmd_privileges, 0U);
#line 3191
  tmp = be_is_mc(adapter);
#line 3191
  if ((int )tmp) {
#line 3192
    adapter->cmd_privileges = 1792U;
  } else {

  }
#line 3194
  en_flags = 6192U;
#line 3197
  if ((adapter->function_caps & 2U) != 0U) {
#line 3198
    en_flags = en_flags | 4U;
  } else {

  }
#line 3200
  en_flags = adapter->if_cap_flags & en_flags;
#line 3202
  status = be_cmd_if_create(adapter, adapter->if_cap_flags, en_flags, (u32 *)(& adapter->if_handle),
                            0U);
#line 3204
  if (status != 0) {
#line 3205
    goto err;
  } else {

  }
#line 3207
  memset((void *)(& mac), 0, 6UL);
#line 3208
  active_mac = 0;
#line 3209
  status = be_get_mac_addr(adapter, (u8 *)(& mac), (u32 )adapter->if_handle, & active_mac,
                           adapter->pmac_id);
#line 3211
  if (status != 0) {
#line 3212
    goto err;
  } else {

  }
#line 3214
  if (! active_mac) {
#line 3215
    status = be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )adapter->if_handle, adapter->pmac_id,
                             0U);
#line 3217
    if (status != 0) {
#line 3218
      goto err;
    } else {

    }
  } else {

  }
#line 3221
  tmp___0 = is_zero_ether_addr((u8 const   *)(adapter->netdev)->dev_addr);
#line 3221
  if ((int )tmp___0) {
#line 3222
    __len = 6UL;
#line 3222
    if (__len > 63UL) {
#line 3222
      __ret = __memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac),
                       __len);
    } else {
#line 3222
      __ret = __builtin_memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac),
                               __len);
    }
#line 3223
    __len___0 = 6UL;
#line 3223
    if (__len___0 > 63UL) {
#line 3223
      __ret___0 = __memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac),
                           __len___0);
    } else {
#line 3223
      __ret___0 = __builtin_memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac),
                                   __len___0);
    }
  } else {

  }
#line 3226
  status = be_tx_qs_create(adapter);
#line 3227
  if (status != 0) {
#line 3228
    goto err;
  } else {

  }
#line 3230
  be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), 0);
#line 3232
  if ((unsigned int )adapter->vlans_added != 0U) {
#line 3233
    be_vid_config(adapter);
  } else {

  }
#line 3235
  be_set_rx_mode(adapter->netdev);
#line 3237
  be_cmd_get_flow_control(adapter, & tx_fc, & rx_fc);
#line 3239
  if (adapter->rx_fc != rx_fc || adapter->tx_fc != tx_fc) {
#line 3240
    be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
  } else {

  }
#line 3243
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3244
    if (adapter->dev_num_vfs != 0U) {
#line 3245
      be_vf_setup(adapter);
    } else {
#line 3247
      dev_warn((struct device  const  *)dev, "device doesn\'t support SRIOV\n");
    }
  } else {

  }
#line 3250
  status = be_cmd_get_phy_info(adapter);
#line 3251
  if (status == 0) {
#line 3251
    tmp___1 = be_pause_supported(adapter);
#line 3251
    if ((int )tmp___1) {
#line 3252
      adapter->phy.fc_autoneg = 1U;
    } else {

    }
  } else {

  }
#line 3254
  tmp___2 = msecs_to_jiffies(1000U);
#line 3254
  schedule_delayed_work(& adapter->work, tmp___2);
#line 3255
  adapter->flags = adapter->flags | 8U;
#line 3256
  return (0);
  err: 
#line 3258
  be_clear(adapter);
#line 3259
  return (status);
}
}
#line 3263 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_netpoll(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 3265
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3265
  adapter = (struct be_adapter *)tmp;
#line 3269
  i = 0;
#line 3269
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3269
  goto ldv_52292;
  ldv_52291: 
#line 3270
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 3271
  napi_schedule(& eqo->napi);
#line 3269
  i = i + 1;
#line 3269
  eqo = eqo + 1;
  ldv_52292: ;
#line 3269
  if ((u32 )i < adapter->num_evt_qs) {
#line 3271
    goto ldv_52291;
  } else {

  }

#line 3274
  return;
}
}
#line 3279 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
char flash_cookie[2U][16U]  = { {        '*',        '*',        '*',        ' ', 
            'S',        'E',        ' ',        'F', 
            'L',        'A',        'S',        '\000'}, 
   {        'H',        ' ',        'D',        'I', 
            'R',        'E',        'C',        'T', 
            'O',        'R',        'Y',        ' ', 
            '*',        '*',        '*',        ' '}};
#line 3281 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool be_flash_redboot(struct be_adapter *adapter , u8 const   *p , u32 img_start ,
                             int image_size , int hdr_size ) 
{ 
  u32 crc_offset ;
  u8 flashed_crc[4U] ;
  int status ;
  int tmp ;

  {
#line 3289
  crc_offset = (((u32 )hdr_size + img_start) + (u32 )image_size) - 4U;
#line 3291
  p = p + (unsigned long )crc_offset;
#line 3293
  status = be_cmd_get_flash_crc(adapter, (u8 *)(& flashed_crc), image_size + -4);
#line 3295
  if (status != 0) {
#line 3296
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "could not get crc from flash, not flashing redboot\n");
#line 3298
    return (0);
  } else {

  }
#line 3302
  tmp = memcmp((void const   *)(& flashed_crc), (void const   *)p, 4UL);
#line 3302
  if (tmp == 0) {
#line 3303
    return (0);
  } else {
#line 3305
    return (1);
  }
}
}
#line 3308 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool phy_flashing_required(struct be_adapter *adapter ) 
{ 


  {
#line 3310
  return ((bool )((unsigned int )adapter->phy.phy_type == 13U && (unsigned int )adapter->phy.interface_type == 6U));
}
}
#line 3314 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool is_comp_in_ufi(struct be_adapter *adapter , struct flash_section_info *fsec ,
                           int type ) 
{ 
  int i ;
  int img_type ;
  struct flash_section_info_g2 *fsec_g2 ;

  {
#line 3317
  i = 0;
#line 3317
  img_type = 0;
#line 3318
  fsec_g2 = 0;
#line 3320
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 3321
    fsec_g2 = (struct flash_section_info_g2 *)fsec;
  } else {

  }
#line 3323
  i = 0;
#line 3323
  goto ldv_52317;
  ldv_52316: ;
#line 3324
  if ((unsigned long )fsec_g2 != (unsigned long )((struct flash_section_info_g2 *)0)) {
#line 3325
    img_type = (int )fsec_g2->fsec_entry[i].type;
  } else {
#line 3327
    img_type = (int )fsec->fsec_entry[i].type;
  }
#line 3329
  if (img_type == type) {
#line 3330
    return (1);
  } else {

  }
#line 3323
  i = i + 1;
  ldv_52317: ;
#line 3323
  if (i <= 31) {
#line 3325
    goto ldv_52316;
  } else {

  }

#line 3332
  return (0);
}
}
#line 3336 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
struct flash_section_info *get_fsec_info(struct be_adapter *adapter , int header_size ,
                                         struct firmware  const  *fw ) 
{ 
  struct flash_section_info *fsec ;
  u8 const   *p ;
  int tmp ;

  {
#line 3340
  fsec = 0;
#line 3341
  p = fw->data;
#line 3343
  p = p + (unsigned long )header_size;
#line 3344
  goto ldv_52327;
  ldv_52326: 
#line 3345
  fsec = (struct flash_section_info *)p;
#line 3346
  tmp = memcmp((void const   *)(& flash_cookie), (void const   *)(& fsec->cookie),
               32UL);
#line 3346
  if (tmp == 0) {
#line 3347
    return (fsec);
  } else {

  }
#line 3348
  p = p + 32UL;
  ldv_52327: ;
#line 3344
  if ((unsigned long )((unsigned char const   *)(fw->data + fw->size)) > (unsigned long )p) {
#line 3346
    goto ldv_52326;
  } else {

  }

#line 3350
  return (0);
}
}
#line 3353 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_flash(struct be_adapter *adapter , u8 const   *img , struct be_dma_mem *flash_cmd ,
                    int optype , int img_size ) 
{ 
  u32 total_bytes ;
  u32 flash_op ;
  u32 num_bytes ;
  int status ;
  struct be_cmd_write_flashrom *req ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 3356
  total_bytes = 0U;
#line 3356
  num_bytes = 0U;
#line 3357
  status = 0;
#line 3358
  req = (struct be_cmd_write_flashrom *)flash_cmd->va;
#line 3360
  total_bytes = (u32 )img_size;
#line 3361
  goto ldv_52349;
  ldv_52348: 
#line 3362
  __min1 = 32768U;
#line 3362
  __min2 = total_bytes;
#line 3362
  num_bytes = __min1 < __min2 ? __min1 : __min2;
#line 3364
  total_bytes = total_bytes - num_bytes;
#line 3366
  if (total_bytes == 0U) {
#line 3367
    if (optype == 99) {
#line 3368
      flash_op = 9U;
    } else {
#line 3370
      flash_op = 1U;
    }
  } else
#line 3372
  if (optype == 99) {
#line 3373
    flash_op = 10U;
  } else {
#line 3375
    flash_op = 2U;
  }
#line 3378
  __len = (size_t )num_bytes;
#line 3378
  __ret = __builtin_memcpy((void *)(& req->data_buf), (void const   *)img, __len);
#line 3379
  img = img + (unsigned long )num_bytes;
#line 3380
  status = be_cmd_write_flashrom(adapter, flash_cmd, (u32 )optype, flash_op, num_bytes);
#line 3382
  if (status != 0) {
#line 3383
    if (status == 2 && optype == 99) {
#line 3385
      goto ldv_52347;
    } else {

    }
#line 3386
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "cmd to write to flash rom failed.\n");
#line 3388
    return (status);
  } else {

  }
  ldv_52349: ;
#line 3361
  if (total_bytes != 0U) {
#line 3363
    goto ldv_52348;
  } else {

  }
  ldv_52347: ;
#line 3391
  return (0);
}
}
#line 3395 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_flash_BEx(struct be_adapter *adapter , struct firmware  const  *fw ,
                        struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int status ;
  int i ;
  int filehdr_size ;
  int img_hdrs_size ;
  u8 const   *p ;
  struct flash_comp  const  *pflashcomp ;
  int num_comp ;
  int redboot ;
  struct flash_section_info *fsec ;
  struct flash_comp gen3_flash_types[10U] ;
  struct flash_comp gen2_flash_types[8U] ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 3401
  status = 0;
#line 3401
  filehdr_size = 0;
#line 3402
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3403
  p = fw->data;
#line 3406
  fsec = 0;
#line 3408
  gen3_flash_types[0].offset = 2097152UL;
#line 3408
  gen3_flash_types[0].optype = 0;
#line 3408
  gen3_flash_types[0].size = 2097152;
#line 3408
  gen3_flash_types[0].img_type = 160;
#line 3408
  gen3_flash_types[1].offset = 262144UL;
#line 3408
  gen3_flash_types[1].optype = 1;
#line 3408
  gen3_flash_types[1].size = 1048576;
#line 3408
  gen3_flash_types[1].img_type = 224;
#line 3408
  gen3_flash_types[2].offset = 12582912UL;
#line 3408
  gen3_flash_types[2].optype = 2;
#line 3408
  gen3_flash_types[2].size = 524288;
#line 3408
  gen3_flash_types[2].img_type = 34;
#line 3408
  gen3_flash_types[3].offset = 13107200UL;
#line 3408
  gen3_flash_types[3].optype = 3;
#line 3408
  gen3_flash_types[3].size = 524288;
#line 3408
  gen3_flash_types[3].img_type = 32;
#line 3408
  gen3_flash_types[4].offset = 13631488UL;
#line 3408
  gen3_flash_types[4].optype = 8;
#line 3408
  gen3_flash_types[4].size = 524288;
#line 3408
  gen3_flash_types[4].img_type = 33;
#line 3408
  gen3_flash_types[5].offset = 4194304UL;
#line 3408
  gen3_flash_types[5].optype = 9;
#line 3408
  gen3_flash_types[5].size = 2097152;
#line 3408
  gen3_flash_types[5].img_type = 176;
#line 3408
  gen3_flash_types[6].offset = 6291456UL;
#line 3408
  gen3_flash_types[6].optype = 10;
#line 3408
  gen3_flash_types[6].size = 2097152;
#line 3408
  gen3_flash_types[6].img_type = 162;
#line 3408
  gen3_flash_types[7].offset = 8388608UL;
#line 3408
  gen3_flash_types[7].optype = 11;
#line 3408
  gen3_flash_types[7].size = 2097152;
#line 3408
  gen3_flash_types[7].img_type = 178;
#line 3408
  gen3_flash_types[8].offset = 15990784UL;
#line 3408
  gen3_flash_types[8].optype = 13;
#line 3408
  gen3_flash_types[8].size = 262144;
#line 3408
  gen3_flash_types[8].img_type = 16;
#line 3408
  gen3_flash_types[9].offset = 1310720UL;
#line 3408
  gen3_flash_types[9].optype = 99;
#line 3408
  gen3_flash_types[9].size = 262144;
#line 3408
  gen3_flash_types[9].img_type = 192;
#line 3431
  gen2_flash_types[0].offset = 1048576UL;
#line 3431
  gen2_flash_types[0].optype = 0;
#line 3431
  gen2_flash_types[0].size = 1310720;
#line 3431
  gen2_flash_types[0].img_type = 160;
#line 3431
  gen2_flash_types[1].offset = 0UL;
#line 3431
  gen2_flash_types[1].optype = 1;
#line 3431
  gen2_flash_types[1].size = 262144;
#line 3431
  gen2_flash_types[1].img_type = 224;
#line 3431
  gen2_flash_types[2].offset = 7340032UL;
#line 3431
  gen2_flash_types[2].optype = 2;
#line 3431
  gen2_flash_types[2].size = 262144;
#line 3431
  gen2_flash_types[2].img_type = 34;
#line 3431
  gen2_flash_types[3].offset = 7864320UL;
#line 3431
  gen2_flash_types[3].optype = 3;
#line 3431
  gen2_flash_types[3].size = 262144;
#line 3431
  gen2_flash_types[3].img_type = 32;
#line 3431
  gen2_flash_types[4].offset = 524288UL;
#line 3431
  gen2_flash_types[4].optype = 8;
#line 3431
  gen2_flash_types[4].size = 262144;
#line 3431
  gen2_flash_types[4].img_type = 33;
#line 3431
  gen2_flash_types[5].offset = 2359296UL;
#line 3431
  gen2_flash_types[5].optype = 9;
#line 3431
  gen2_flash_types[5].size = 1310720;
#line 3431
  gen2_flash_types[5].img_type = 176;
#line 3431
  gen2_flash_types[6].offset = 3670016UL;
#line 3431
  gen2_flash_types[6].optype = 10;
#line 3431
  gen2_flash_types[6].size = 1310720;
#line 3431
  gen2_flash_types[6].img_type = 162;
#line 3431
  gen2_flash_types[7].offset = 4980736UL;
#line 3431
  gen2_flash_types[7].optype = 11;
#line 3431
  gen2_flash_types[7].size = 1310720;
#line 3431
  gen2_flash_types[7].img_type = 178;
#line 3450
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3451
    pflashcomp = (struct flash_comp  const  *)(& gen3_flash_types);
#line 3452
    filehdr_size = 128;
#line 3453
    num_comp = 10;
  } else {
#line 3455
    pflashcomp = (struct flash_comp  const  *)(& gen2_flash_types);
#line 3456
    filehdr_size = 96;
#line 3457
    num_comp = 8;
  }
#line 3461
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 3462
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 3463
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Invalid Cookie. UFI corrupted ?\n");
#line 3465
    return (-1);
  } else {

  }
#line 3467
  i = 0;
#line 3467
  goto ldv_52373;
  ldv_52372: 
#line 3468
  tmp = is_comp_in_ufi(adapter, fsec, (pflashcomp + (unsigned long )i)->img_type);
#line 3468
  if (tmp) {
#line 3468
    tmp___0 = 0;
  } else {
#line 3468
    tmp___0 = 1;
  }
#line 3468
  if (tmp___0) {
#line 3469
    goto ldv_52371;
  } else {

  }
#line 3471
  if ((int )(pflashcomp + (unsigned long )i)->optype == 13) {
#line 3471
    tmp___1 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)"3.102.148.0",
                     11UL);
#line 3471
    if (tmp___1 < 0) {
#line 3473
      goto ldv_52371;
    } else {

    }
  } else {

  }
#line 3475
  if ((int )(pflashcomp + (unsigned long )i)->optype == 99) {
#line 3475
    tmp___2 = phy_flashing_required(adapter);
#line 3475
    if (tmp___2) {
#line 3475
      tmp___3 = 0;
    } else {
#line 3475
      tmp___3 = 1;
    }
#line 3475
    if (tmp___3) {
#line 3477
      goto ldv_52371;
    } else {

    }
  } else {

  }
#line 3479
  if ((int )(pflashcomp + (unsigned long )i)->optype == 1) {
#line 3480
    tmp___4 = be_flash_redboot(adapter, fw->data, (u32 )(pflashcomp + (unsigned long )i)->offset,
                               (pflashcomp + (unsigned long )i)->size, filehdr_size + img_hdrs_size);
#line 3480
    redboot = (int )tmp___4;
#line 3483
    if (redboot == 0) {
#line 3484
      goto ldv_52371;
    } else {

    }
  } else {

  }
#line 3487
  p = fw->data;
#line 3488
  p = p + (((unsigned long )filehdr_size + (unsigned long )(pflashcomp + (unsigned long )i)->offset) + (unsigned long )img_hdrs_size);
#line 3489
  if ((unsigned long )(p + (unsigned long )(pflashcomp + (unsigned long )i)->size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3490
    return (-1);
  } else {

  }
#line 3492
  status = be_flash(adapter, p, flash_cmd, (pflashcomp + (unsigned long )i)->optype,
                    (pflashcomp + (unsigned long )i)->size);
#line 3494
  if (status != 0) {
#line 3495
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Flashing section type %d failed.\n",
            (pflashcomp + (unsigned long )i)->img_type);
#line 3498
    return (status);
  } else {

  }
  ldv_52371: 
#line 3467
  i = i + 1;
  ldv_52373: ;
#line 3467
  if (i < num_comp) {
#line 3469
    goto ldv_52372;
  } else {

  }

#line 3501
  return (0);
}
}
#line 3504 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_flash_skyhawk(struct be_adapter *adapter , struct firmware  const  *fw ,
                            struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int status ;
  int i ;
  int filehdr_size ;
  int img_offset ;
  int img_size ;
  int img_optype ;
  int redboot ;
  int img_hdrs_size ;
  u8 const   *p ;
  struct flash_section_info *fsec ;
  bool tmp ;

  {
#line 3508
  status = 0;
#line 3508
  filehdr_size = 0;
#line 3510
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3511
  p = fw->data;
#line 3512
  fsec = 0;
#line 3514
  filehdr_size = 128;
#line 3515
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
#line 3516
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
#line 3517
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Invalid Cookie. UFI corrupted ?\n");
#line 3519
    return (-1);
  } else {

  }
#line 3522
  i = 0;
#line 3522
  goto ldv_52402;
  ldv_52401: 
#line 3523
  img_offset = (int )fsec->fsec_entry[i].offset;
#line 3524
  img_size = (int )fsec->fsec_entry[i].pad_size;
#line 3526
  switch (fsec->fsec_entry[i].type) {
  case 160U: 
#line 3528
  img_optype = 0;
#line 3529
  goto ldv_52392;
  case 224U: 
#line 3531
  img_optype = 1;
#line 3532
  goto ldv_52392;
  case 34U: 
#line 3534
  img_optype = 2;
#line 3535
  goto ldv_52392;
  case 32U: 
#line 3537
  img_optype = 3;
#line 3538
  goto ldv_52392;
  case 33U: 
#line 3540
  img_optype = 8;
#line 3541
  goto ldv_52392;
  case 176U: 
#line 3543
  img_optype = 9;
#line 3544
  goto ldv_52392;
  case 16U: 
#line 3546
  img_optype = 13;
#line 3547
  goto ldv_52392;
  default: ;
#line 3549
  goto ldv_52400;
  }
  ldv_52392: ;
#line 3552
  if (img_optype == 1) {
#line 3553
    tmp = be_flash_redboot(adapter, fw->data, (u32 )img_offset, img_size, filehdr_size + img_hdrs_size);
#line 3553
    redboot = (int )tmp;
#line 3556
    if (redboot == 0) {
#line 3557
      goto ldv_52400;
    } else {

    }
  } else {

  }
#line 3560
  p = fw->data;
#line 3561
  p = p + (unsigned long )((filehdr_size + img_offset) + img_hdrs_size);
#line 3562
  if ((unsigned long )(p + (unsigned long )img_size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3563
    return (-1);
  } else {

  }
#line 3565
  status = be_flash(adapter, p, flash_cmd, img_optype, img_size);
#line 3566
  if (status != 0) {
#line 3567
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Flashing section type %d failed.\n",
            fsec->fsec_entry[i].type);
#line 3570
    return (status);
  } else {

  }
  ldv_52400: 
#line 3522
  i = i + 1;
  ldv_52402: ;
#line 3522
  if ((u32 )i < fsec->fsec_hdr.num_images) {
#line 3524
    goto ldv_52401;
  } else {

  }

#line 3573
  return (0);
}
}
#line 3576 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int lancer_wait_idle(struct be_adapter *adapter ) 
{ 
  u32 reg_val ;
  int status ;
  int i ;

  {
#line 3580
  status = 0;
#line 3582
  i = 0;
#line 3582
  goto ldv_52412;
  ldv_52411: 
#line 3583
  reg_val = ioread32((void *)adapter->db + 1044U);
#line 3584
  if ((reg_val & 1073741824U) == 0U) {
#line 3585
    goto ldv_52410;
  } else {

  }
#line 3587
  ssleep(1U);
#line 3582
  i = i + 1;
  ldv_52412: ;
#line 3582
  if (i <= 29) {
#line 3584
    goto ldv_52411;
  } else {

  }
  ldv_52410: ;
#line 3590
  if (i == 30) {
#line 3591
    status = -1;
  } else {

  }
#line 3593
  return (status);
}
}
#line 3596 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int lancer_fw_reset(struct be_adapter *adapter ) 
{ 
  int status ;

  {
#line 3598
  status = 0;
#line 3600
  status = lancer_wait_idle(adapter);
#line 3601
  if (status != 0) {
#line 3602
    return (status);
  } else {

  }
#line 3604
  iowrite32(2U, (void *)adapter->db + 1044U);
#line 3607
  return (status);
}
}
#line 3610 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int lancer_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct be_dma_mem flash_cmd ;
  u8 const   *data_ptr ;
  u8 *dest_image_ptr ;
  size_t image_size ;
  u32 chunk_size ;
  u32 data_written ;
  u32 offset ;
  int status ;
  u8 add_status ;
  u8 change_status ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 3616
  data_ptr = 0;
#line 3617
  dest_image_ptr = 0;
#line 3618
  image_size = 0UL;
#line 3619
  chunk_size = 0U;
#line 3620
  data_written = 0U;
#line 3621
  offset = 0U;
#line 3622
  status = 0;
#line 3623
  add_status = 0U;
#line 3626
  if (((unsigned long )fw->size & 3UL) != 0UL) {
#line 3627
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW Image not properly aligned. Length must be 4 byte aligned.\n");
#line 3630
    status = -22;
#line 3631
    goto lancer_fw_exit;
  } else {

  }
#line 3634
  flash_cmd.size = 32912U;
#line 3636
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, 0);
#line 3638
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 3639
    status = -12;
#line 3640
    goto lancer_fw_exit;
  } else {

  }
#line 3643
  dest_image_ptr = (u8 *)flash_cmd.va + 144U;
#line 3645
  image_size = fw->size;
#line 3646
  data_ptr = fw->data;
#line 3648
  goto ldv_52440;
  ldv_52439: 
#line 3649
  __min1 = (u32 )image_size;
#line 3649
  __min2 = 32768U;
#line 3649
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 3652
  __len = (size_t )chunk_size;
#line 3652
  __ret = __builtin_memcpy((void *)dest_image_ptr, (void const   *)data_ptr, __len);
#line 3654
  status = lancer_cmd_write_object(adapter, & flash_cmd, chunk_size, offset, "/prg",
                                   & data_written, & change_status, & add_status);
#line 3659
  if (status != 0) {
#line 3660
    goto ldv_52438;
  } else {

  }
#line 3662
  offset = offset + data_written;
#line 3663
  data_ptr = data_ptr + (unsigned long )data_written;
#line 3664
  image_size = image_size - (size_t )data_written;
  ldv_52440: ;
#line 3648
  if (image_size != 0UL) {
#line 3650
    goto ldv_52439;
  } else {

  }
  ldv_52438: ;
#line 3667
  if (status == 0) {
#line 3669
    status = lancer_cmd_write_object(adapter, & flash_cmd, 0U, offset, "/prg", & data_written,
                                     & change_status, & add_status);
  } else {

  }
#line 3676
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 0);
#line 3678
  if (status != 0) {
#line 3679
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error. Status code: 0x%x Additional Status: 0x%x\n",
            status, (int )add_status);
#line 3683
    goto lancer_fw_exit;
  } else {

  }
#line 3686
  if ((unsigned int )change_status == 2U) {
#line 3687
    status = lancer_fw_reset(adapter);
#line 3688
    if (status != 0) {
#line 3689
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter busy for FW reset.\nNew FW will not be active.\n");
#line 3692
      goto lancer_fw_exit;
    } else {

    }
  } else
#line 3694
  if ((unsigned int )change_status != 0U) {
#line 3695
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "System reboot required for new FW to be active\n");
  } else {

  }
#line 3700
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  lancer_fw_exit: ;
#line 3702
  return (status);
}
}
#line 3709 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_get_ufi_type(struct be_adapter *adapter , struct flash_file_hdr_g3 *fhdr ) 
{ 


  {
#line 3712
  if ((unsigned long )fhdr == (unsigned long )((struct flash_file_hdr_g3 *)0)) {
#line 3713
    goto be_get_ufi_exit;
  } else {

  }
#line 3715
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (unsigned int )fhdr->build[0] == 52U) {
#line 3716
    return (4);
  } else
#line 3717
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )fhdr->build[0] == 51U) {
#line 3718
    if ((unsigned int )fhdr->asic_type_rev == 16U) {
#line 3719
      return (10);
    } else {
#line 3721
      return (3);
    }
  } else
#line 3722
  if (((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) && (unsigned int )fhdr->build[0] == 50U) {
#line 3723
    return (2);
  } else {

  }
  be_get_ufi_exit: 
#line 3726
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UFI and Interface are not compatible for flashing\n");
#line 3728
  return (-1);
}
}
#line 3731 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct flash_file_hdr_g3 *fhdr3 ;
  struct image_hdr *img_hdr_ptr ;
  struct be_dma_mem flash_cmd ;
  u8 const   *p ;
  int status ;
  int i ;
  int num_imgs ;
  int ufi_type ;

  {
#line 3734
  img_hdr_ptr = 0;
#line 3737
  status = 0;
#line 3737
  i = 0;
#line 3737
  num_imgs = 0;
#line 3737
  ufi_type = 0;
#line 3739
  flash_cmd.size = 32804U;
#line 3740
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, 0);
#line 3742
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 3743
    status = -12;
#line 3744
    goto be_fw_exit;
  } else {

  }
#line 3747
  p = fw->data;
#line 3748
  fhdr3 = (struct flash_file_hdr_g3 *)p;
#line 3750
  ufi_type = be_get_ufi_type(adapter, fhdr3);
#line 3752
  num_imgs = (int )fhdr3->num_imgs;
#line 3753
  i = 0;
#line 3753
  goto ldv_52464;
  ldv_52463: 
#line 3754
  img_hdr_ptr = (struct image_hdr *)(fw->data + ((unsigned long )i * 48UL + 128UL));
#line 3757
  if (img_hdr_ptr->imageid == 1U) {
#line 3758
    switch (ufi_type) {
    case 4: 
#line 3760
    status = be_flash_skyhawk(adapter, fw, & flash_cmd, num_imgs);
#line 3762
    goto ldv_52460;
    case 10: 
#line 3764
    status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
#line 3766
    goto ldv_52460;
    case 3: ;
#line 3769
    if ((unsigned int )adapter->asic_rev <= 15U) {
#line 3770
      status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
    } else {
#line 3774
      status = -1;
#line 3775
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Can\'t load BE3 UFI on BE3R\n");
    }
    }
    ldv_52460: ;
  } else {

  }
#line 3753
  i = i + 1;
  ldv_52464: ;
#line 3753
  if (i < num_imgs) {
#line 3755
    goto ldv_52463;
  } else {

  }

#line 3782
  if (ufi_type == 2) {
#line 3783
    status = be_flash_BEx(adapter, fw, & flash_cmd, 0);
  } else
#line 3784
  if (ufi_type == -1) {
#line 3785
    status = -1;
  } else {

  }
#line 3787
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 0);
#line 3789
  if (status != 0) {
#line 3790
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error\n");
#line 3791
    goto be_fw_exit;
  } else {

  }
#line 3794
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  be_fw_exit: ;
#line 3797
  return (status);
}
}
#line 3800 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) 
{ 
  struct firmware  const  *fw ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3805
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 3805
  if (tmp) {
#line 3805
    tmp___0 = 0;
  } else {
#line 3805
    tmp___0 = 1;
  }
#line 3805
  if (tmp___0) {
#line 3806
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load not allowed (interface is down)\n");
#line 3808
    return (-1);
  } else {

  }
#line 3811
  status = request_firmware(& fw, (char const   *)fw_file, & (adapter->pdev)->dev);
#line 3812
  if (status != 0) {
#line 3813
    goto fw_exit;
  } else {

  }
#line 3815
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Flashing firmware file %s\n",
            fw_file);
#line 3817
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 3818
    status = lancer_fw_download(adapter, fw);
  } else {
#line 3820
    status = be_fw_download(adapter, fw);
  }
  fw_exit: 
#line 3823
  release_firmware(fw);
#line 3824
  return (status);
}
}
#line 3827 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct net_device_ops  const  be_netdev_ops  = 
#line 3827
     {0, 0, & be_open, & be_close, & be_xmit, 0, 0, & be_set_rx_mode, & be_mac_addr_set,
    & eth_validate_addr, 0, 0, & be_change_mtu, 0, 0, & be_get_stats64, 0, & be_vlan_add_vid,
    & be_vlan_rem_vid, & be_netpoll, 0, 0, & be_set_vf_mac, & be_set_vf_vlan, & be_set_vf_tx_rate,
    0, & be_get_vf_config, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};
#line 3847 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_netdev_init(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  bool tmp___0 ;

  {
#line 3849
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3849
  adapter = (struct be_adapter *)tmp;
#line 3853
  netdev->hw_features = netdev->hw_features | 537985171ULL;
#line 3856
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 3856
  if ((int )tmp___0) {
#line 3857
    netdev->hw_features = netdev->hw_features | 268435456ULL;
  } else {

  }
#line 3859
  netdev->features = (netdev->features | netdev->hw_features) | 768ULL;
#line 3862
  netdev->vlan_features = netdev->vlan_features | 1114131ULL;
#line 3865
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 3867
  netdev->flags = netdev->flags | 4096U;
#line 3869
  netif_set_gso_max_size(netdev, 65521U);
#line 3871
  netdev->netdev_ops = & be_netdev_ops;
#line 3873
  netdev->ethtool_ops = & be_ethtool_ops;
#line 3875
  i = 0;
#line 3875
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 3875
  goto ldv_52481;
  ldv_52480: 
#line 3876
  netif_napi_add(netdev, & eqo->napi, & be_poll, 64);
#line 3875
  i = i + 1;
#line 3875
  eqo = eqo + 1;
  ldv_52481: ;
#line 3875
  if ((u32 )i < adapter->num_evt_qs) {
#line 3877
    goto ldv_52480;
  } else {

  }

#line 3882
  return;
}
}
#line 3879 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_unmap_pci_bars(struct be_adapter *adapter ) 
{ 


  {
#line 3881
  if ((unsigned long )adapter->csr != (unsigned long )((u8 *)0)) {
#line 3882
    pci_iounmap(adapter->pdev, (void *)adapter->csr);
  } else {

  }
#line 3883
  if ((unsigned long )adapter->db != (unsigned long )((u8 *)0)) {
#line 3884
    pci_iounmap(adapter->pdev, (void *)adapter->db);
  } else {

  }
#line 3885
  return;
}
}
#line 3887 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int db_bar(struct be_adapter *adapter ) 
{ 


  {
#line 3889
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (unsigned int )adapter->virtfn != 0U) {
#line 3890
    return (0);
  } else {
#line 3892
    return (4);
  }
}
}
#line 3895 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_roce_map_pci_bars(struct be_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 3897
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3898
    adapter->roce_db.size = 4096U;
#line 3899
    tmp = db_bar(adapter);
#line 3899
    adapter->roce_db.io_addr = (adapter->pdev)->resource[tmp].start;
#line 3901
    tmp___5 = db_bar(adapter);
#line 3901
    if ((adapter->pdev)->resource[tmp___5].start != 0ULL) {
#line 3901
      tmp___3 = db_bar(adapter);
#line 3901
      tmp___4 = db_bar(adapter);
#line 3901
      adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
    } else {
#line 3901
      tmp___6 = db_bar(adapter);
#line 3901
      tmp___7 = db_bar(adapter);
#line 3901
      if ((adapter->pdev)->resource[tmp___6].end != (adapter->pdev)->resource[tmp___7].start) {
#line 3901
        tmp___3 = db_bar(adapter);
#line 3901
        tmp___4 = db_bar(adapter);
#line 3901
        adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
      } else {
#line 3901
        adapter->roce_db.total_size = 0U;
      }
    }
  } else {

  }
#line 3904
  return (0);
}
}
#line 3907 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_map_pci_bars(struct be_adapter *adapter ) 
{ 
  u8 *addr ;
  u32 sli_intf ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 3912
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 88, & sli_intf);
#line 3913
  adapter->if_type = (sli_intf & 61440U) >> 12;
#line 3916
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) && (unsigned int )adapter->virtfn == 0U) {
#line 3917
    tmp = pci_iomap(adapter->pdev, 2, 0UL);
#line 3917
    adapter->csr = (u8 *)tmp;
#line 3918
    if ((unsigned long )adapter->csr == (unsigned long )((u8 *)0)) {
#line 3919
      return (-12);
    } else {

    }
  } else {

  }
#line 3922
  tmp___0 = db_bar(adapter);
#line 3922
  tmp___1 = pci_iomap(adapter->pdev, tmp___0, 0UL);
#line 3922
  addr = (u8 *)tmp___1;
#line 3923
  if ((unsigned long )addr == (unsigned long )((u8 *)0)) {
#line 3924
    goto pci_map_err;
  } else {

  }
#line 3925
  adapter->db = addr;
#line 3927
  be_roce_map_pci_bars(adapter);
#line 3928
  return (0);
  pci_map_err: 
#line 3931
  be_unmap_pci_bars(adapter);
#line 3932
  return (-12);
}
}
#line 3935 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_ctrl_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 3937
  mem = & adapter->mbox_mem_alloced;
#line 3939
  be_unmap_pci_bars(adapter);
#line 3941
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 3942
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   0);
  } else {

  }
#line 3945
  mem = & adapter->rx_filter;
#line 3946
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
#line 3947
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   0);
  } else {

  }
#line 3948
  return;
}
}
#line 3951 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_ctrl_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  struct be_dma_mem *rx_filter ;
  u32 sli_intf ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 3953
  mbox_mem_alloc = & adapter->mbox_mem_alloced;
#line 3954
  mbox_mem_align = & adapter->mbox_mem;
#line 3955
  rx_filter = & adapter->rx_filter;
#line 3959
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 88, & sli_intf);
#line 3960
  adapter->sli_family = (sli_intf & 3840U) >> 8;
#line 3962
  adapter->virtfn = (unsigned int )((u8 )sli_intf) & 1U;
#line 3964
  status = be_map_pci_bars(adapter);
#line 3965
  if (status != 0) {
#line 3966
    goto done;
  } else {

  }
#line 3968
  mbox_mem_alloc->size = 288U;
#line 3969
  mbox_mem_alloc->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size,
                                       & mbox_mem_alloc->dma, 208U, 0);
#line 3973
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
#line 3974
    status = -12;
#line 3975
    goto unmap_pci_bars;
  } else {

  }
#line 3977
  mbox_mem_align->size = 272U;
#line 3978
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 3979
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 3980
  memset(mbox_mem_align->va, 0, 272UL);
#line 3982
  rx_filter->size = 424U;
#line 3983
  rx_filter->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )rx_filter->size,
                                  & rx_filter->dma, 32976U, 0);
#line 3986
  if ((unsigned long )rx_filter->va == (unsigned long )((void *)0)) {
#line 3987
    status = -12;
#line 3988
    goto free_mbox;
  } else {

  }
#line 3991
  __mutex_init(& adapter->mbox_lock, "&adapter->mbox_lock", & __key);
#line 3992
  spinlock_check(& adapter->mcc_lock);
#line 3992
  __raw_spin_lock_init(& adapter->mcc_lock.ldv_6014.rlock, "&(&adapter->mcc_lock)->rlock",
                       & __key___0);
#line 3993
  spinlock_check(& adapter->mcc_cq_lock);
#line 3993
  __raw_spin_lock_init(& adapter->mcc_cq_lock.ldv_6014.rlock, "&(&adapter->mcc_cq_lock)->rlock",
                       & __key___1);
#line 3995
  init_completion(& adapter->flash_compl);
#line 3996
  pci_save_state(adapter->pdev);
#line 3997
  return (0);
  free_mbox: 
#line 4000
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size, mbox_mem_alloc->va,
                 mbox_mem_alloc->dma, 0);
  unmap_pci_bars: 
#line 4004
  be_unmap_pci_bars(adapter);
  done: ;
#line 4007
  return (status);
}
}
#line 4010 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_stats_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4012
  cmd = & adapter->stats_cmd;
#line 4014
  if ((unsigned long )cmd->va != (unsigned long )((void *)0)) {
#line 4015
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd->size, cmd->va, cmd->dma,
                   0);
  } else {

  }
#line 4016
  return;
}
}
#line 4019 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_stats_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4021
  cmd = & adapter->stats_cmd;
#line 4023
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4024
    cmd->size = 672U;
  } else
#line 4025
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 4026
    cmd->size = 1076U;
  } else {
#line 4029
    cmd->size = 1864U;
  }
#line 4031
  cmd->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )cmd->size, & cmd->dma,
                            32976U, 0);
#line 4033
  if ((unsigned long )cmd->va == (unsigned long )((void *)0)) {
#line 4034
    return (-1);
  } else {

  }
#line 4035
  return (0);
}
}
#line 4038 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_remove(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 4040
  tmp = pci_get_drvdata(pdev);
#line 4040
  adapter = (struct be_adapter *)tmp;
#line 4042
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 4043
    return;
  } else {

  }
#line 4045
  be_roce_dev_remove(adapter);
#line 4046
  be_intr_set(adapter, 0);
#line 4048
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4050
  unregister_netdev(adapter->netdev);
#line 4052
  be_clear(adapter);
#line 4055
  be_cmd_fw_clean(adapter);
#line 4057
  be_stats_cleanup(adapter);
#line 4059
  be_ctrl_cleanup(adapter);
#line 4061
  pci_disable_pcie_error_reporting(pdev);
#line 4063
  pci_set_drvdata(pdev, 0);
#line 4064
  pci_release_regions(pdev);
#line 4065
  pci_disable_device(pdev);
#line 4067
  free_netdev(adapter->netdev);
#line 4068
  return;
}
}
#line 4070 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
bool be_is_wol_supported(struct be_adapter *adapter ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4072
  if ((int )adapter->wol_cap & 1) {
#line 4072
    tmp = be_is_wol_excluded(adapter);
#line 4072
    if (tmp) {
#line 4072
      tmp___0 = 0;
    } else {
#line 4072
      tmp___0 = 1;
    }
#line 4072
    if (tmp___0) {
#line 4072
      tmp___1 = 1;
    } else {
#line 4072
      tmp___1 = 0;
    }
  } else {
#line 4072
    tmp___1 = 0;
  }
#line 4072
  return ((bool )tmp___1);
}
}
#line 4076 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
u32 be_get_fw_log_level(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  u32 level ;
  int j ;

  {
#line 4081
  level = 0U;
#line 4084
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4085
    return (0U);
  } else {

  }
#line 4087
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 4088
  extfat_cmd.size = 2844U;
#line 4089
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
#line 4092
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 4093
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%s: Memory allocation failure\n",
            "be_get_fw_log_level");
#line 4095
    goto err;
  } else {

  }
#line 4098
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 4099
  if (status == 0) {
#line 4100
    cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 4102
    j = 0;
#line 4102
    goto ldv_52542;
    ldv_52541: ;
#line 4103
    if ((unsigned int )cfgs->module[0].trace_lvl[j].mode == 0U) {
#line 4104
      level = cfgs->module[0].trace_lvl[j].dbg_lvl;
    } else {

    }
#line 4102
    j = j + 1;
    ldv_52542: ;
#line 4102
    if ((u32 )j < cfgs->module[0].num_modes) {
#line 4104
      goto ldv_52541;
    } else {

    }

  } else {

  }
#line 4107
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
  err: ;
#line 4110
  return (level);
}
}
#line 4113 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_get_initial_config(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 level ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 4118
  status = be_cmd_get_cntl_attributes(adapter);
#line 4119
  if (status != 0) {
#line 4120
    return (status);
  } else {

  }
#line 4122
  status = be_cmd_get_acpi_wol_cap(adapter);
#line 4123
  if (status != 0) {
#line 4126
    tmp = be_is_wol_excluded(adapter);
#line 4126
    if (tmp) {
#line 4126
      tmp___0 = 0;
    } else {
#line 4126
      tmp___0 = 1;
    }
#line 4126
    if (tmp___0) {
#line 4127
      adapter->wol_cap = (u8 )((unsigned int )adapter->wol_cap | 1U);
    } else {

    }
  } else {

  }
#line 4130
  tmp___1 = be_is_wol_supported(adapter);
#line 4130
  if ((int )tmp___1) {
#line 4131
    adapter->wol = 1;
  } else {

  }
#line 4134
  adapter->be_get_temp_freq = 64;
#line 4136
  level = be_get_fw_log_level(adapter);
#line 4137
  adapter->msg_enable = level <= 48U ? 8192U : 0U;
#line 4139
  return (0);
}
}
#line 4142 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int lancer_recover_func(struct be_adapter *adapter ) 
{ 
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 4146
  status = lancer_test_and_set_rdy_state(adapter);
#line 4147
  if (status != 0) {
#line 4148
    goto err;
  } else {

  }
#line 4150
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 4150
  if ((int )tmp) {
#line 4151
    be_close(adapter->netdev);
  } else {

  }
#line 4153
  be_clear(adapter);
#line 4155
  adapter->hw_error = 0;
#line 4156
  adapter->fw_timeout = 0;
#line 4158
  status = be_setup(adapter);
#line 4159
  if (status != 0) {
#line 4160
    goto err;
  } else {

  }
#line 4162
  tmp___0 = netif_running((struct net_device  const  *)adapter->netdev);
#line 4162
  if ((int )tmp___0) {
#line 4163
    status = be_open(adapter->netdev);
#line 4164
    if (status != 0) {
#line 4165
      goto err;
    } else {

    }
  } else {

  }
#line 4168
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter SLIPORT recovery succeeded\n");
#line 4170
  return (0);
  err: ;
#line 4172
  if ((int )adapter->eeh_error) {
#line 4173
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter SLIPORT recovery failed\n");
  } else {

  }
#line 4176
  return (status);
}
}
#line 4179 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_func_recovery_task(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int status ;
  unsigned long tmp ;

  {
#line 4182
  __mptr = (struct work_struct  const  *)work;
#line 4182
  adapter = (struct be_adapter *)__mptr + 0xfffffffffffa6e98UL;
#line 4185
  be_detect_error(adapter);
#line 4187
  if ((int )adapter->hw_error && ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 4189
    if ((int )adapter->eeh_error) {
#line 4190
      goto out;
    } else {

    }
#line 4192
    rtnl_lock();
#line 4193
    netif_device_detach(adapter->netdev);
#line 4194
    rtnl_unlock();
#line 4196
    status = lancer_recover_func(adapter);
#line 4198
    if (status == 0) {
#line 4199
      netif_device_attach(adapter->netdev);
    } else {

    }
  } else {

  }
  out: 
#line 4203
  tmp = msecs_to_jiffies(1000U);
#line 4203
  schedule_delayed_work(& adapter->func_recovery_work, tmp);
#line 4205
  return;
}
}
#line 4207 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_worker(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct be_rx_obj *rxo ;
  struct be_eq_obj *eqo ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 4210
  __mptr = (struct work_struct  const  *)work;
#line 4210
  adapter = (struct be_adapter *)__mptr + 0xfffffffffffa6f80UL;
#line 4217
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
#line 4217
  if (tmp) {
#line 4217
    tmp___0 = 0;
  } else {
#line 4217
    tmp___0 = 1;
  }
#line 4217
  if (tmp___0) {
#line 4218
    local_bh_disable();
#line 4219
    be_process_mcc(adapter);
#line 4220
    local_bh_enable();
#line 4221
    goto reschedule;
  } else {

  }
#line 4224
  if (! adapter->stats_cmd_sent) {
#line 4225
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4226
      lancer_cmd_get_pport_stats(adapter, & adapter->stats_cmd);
    } else {
#line 4229
      be_cmd_get_stats(adapter, & adapter->stats_cmd);
    }
  } else {

  }
#line 4232
  tmp___1 = MODULO((int )adapter->work_counter, (int )((u16 )adapter->be_get_temp_freq));
#line 4232
  if (tmp___1 == 0U) {
#line 4233
    be_cmd_get_die_temperature(adapter);
  } else {

  }
#line 4235
  i = 0;
#line 4235
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 4235
  goto ldv_52573;
  ldv_52572: ;
#line 4236
  if ((int )rxo->rx_post_starved) {
#line 4237
    rxo->rx_post_starved = 0;
#line 4238
    be_post_rx_frags(rxo, 208U);
  } else {

  }
#line 4235
  i = i + 1;
#line 4235
  rxo = rxo + 1;
  ldv_52573: ;
#line 4235
  if ((u32 )i < adapter->num_rx_qs) {
#line 4237
    goto ldv_52572;
  } else {

  }
#line 4242
  i = 0;
#line 4242
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 4242
  goto ldv_52576;
  ldv_52575: 
#line 4243
  be_eqd_update(adapter, eqo);
#line 4242
  i = i + 1;
#line 4242
  eqo = eqo + 1;
  ldv_52576: ;
#line 4242
  if ((u32 )i < adapter->num_evt_qs) {
#line 4244
    goto ldv_52575;
  } else {

  }

  reschedule: 
#line 4246
  adapter->work_counter = (u16 )((int )adapter->work_counter + 1);
#line 4247
  tmp___2 = msecs_to_jiffies(1000U);
#line 4247
  schedule_delayed_work(& adapter->work, tmp___2);
#line 4248
  return;
}
}
#line 4250 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static bool be_reset_required(struct be_adapter *adapter ) 
{ 
  int tmp ;

  {
#line 4252
  tmp = be_find_vfs(adapter, 0);
#line 4252
  return (tmp <= 0);
}
}
#line 4255 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static char *mc_name(struct be_adapter *adapter ) 
{ 


  {
#line 4257
  if ((adapter->function_mode & 1024U) != 0U) {
#line 4258
    return ((char *)"FLEX10");
  } else
#line 4259
  if ((adapter->function_mode & 131072U) != 0U) {
#line 4260
    return ((char *)"vNIC");
  } else
#line 4261
  if ((adapter->function_mode & 16777216U) != 0U) {
#line 4262
    return ((char *)"UMC");
  } else {
#line 4264
    return ((char *)"");
  }
}
}
#line 4267 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
__inline static char *func_name(struct be_adapter *adapter ) 
{ 


  {
#line 4269
  return ((unsigned int )adapter->virtfn == 0U ? (char *)"PF" : (char *)"VF");
}
}
#line 4272 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_probe(struct pci_dev *pdev , struct pci_device_id  const  *pdev_id ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  char port_name ;
  void *tmp ;
  bool tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 4274
  status = 0;
#line 4279
  status = pci_enable_device(pdev);
#line 4280
  if (status != 0) {
#line 4281
    goto do_none;
  } else {

  }
#line 4283
  status = pci_request_regions(pdev, "be2net");
#line 4284
  if (status != 0) {
#line 4285
    goto disable_dev;
  } else {

  }
#line 4286
  pci_set_master(pdev);
#line 4288
  netdev = alloc_etherdev_mqs(365504, 8U, 9U);
#line 4289
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 4290
    status = -12;
#line 4291
    goto rel_reg;
  } else {

  }
#line 4293
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4293
  adapter = (struct be_adapter *)tmp;
#line 4294
  adapter->pdev = pdev;
#line 4295
  pci_set_drvdata(pdev, (void *)adapter);
#line 4296
  adapter->netdev = netdev;
#line 4297
  netdev->dev.parent = & pdev->dev;
#line 4299
  status = dma_set_mask(& pdev->dev, 0xffffffffffffffffULL);
#line 4300
  if (status == 0) {
#line 4301
    status = dma_set_coherent_mask(& pdev->dev, 0xffffffffffffffffULL);
#line 4302
    if (status < 0) {
#line 4303
      dev_err((struct device  const  *)(& pdev->dev), "dma_set_coherent_mask failed\n");
#line 4304
      goto free_netdev;
    } else {

    }
#line 4306
    netdev->features = netdev->features | 32ULL;
  } else {
#line 4308
    status = dma_set_mask(& pdev->dev, 4294967295ULL);
#line 4309
    if (status != 0) {
#line 4310
      dev_err((struct device  const  *)(& pdev->dev), "Could not set PCI DMA Mask\n");
#line 4311
      goto free_netdev;
    } else {

    }
  }
#line 4315
  status = pci_enable_pcie_error_reporting(pdev);
#line 4316
  if (status != 0) {
#line 4317
    dev_err((struct device  const  *)(& pdev->dev), "Could not use PCIe error reporting\n");
  } else {

  }
#line 4319
  status = be_ctrl_init(adapter);
#line 4320
  if (status != 0) {
#line 4321
    goto free_netdev;
  } else {

  }
#line 4324
  if ((unsigned int )adapter->virtfn == 0U) {
#line 4325
    status = be_fw_wait_ready(adapter);
#line 4326
    if (status != 0) {
#line 4327
      goto ctrl_clean;
    } else {

    }
  } else {

  }
#line 4330
  tmp___0 = be_reset_required(adapter);
#line 4330
  if ((int )tmp___0) {
#line 4331
    status = be_cmd_reset_function(adapter);
#line 4332
    if (status != 0) {
#line 4333
      goto ctrl_clean;
    } else {

    }
#line 4336
    msleep(100U);
  } else {

  }
#line 4340
  be_intr_set(adapter, 1);
#line 4343
  status = be_cmd_fw_init(adapter);
#line 4344
  if (status != 0) {
#line 4345
    goto ctrl_clean;
  } else {

  }
#line 4347
  status = be_stats_init(adapter);
#line 4348
  if (status != 0) {
#line 4349
    goto ctrl_clean;
  } else {

  }
#line 4351
  status = be_get_initial_config(adapter);
#line 4352
  if (status != 0) {
#line 4353
    goto stats_clean;
  } else {

  }
#line 4355
  __init_work(& adapter->work.work, 0);
#line 4355
  __constr_expr_0.counter = 137438953408L;
#line 4355
  adapter->work.work.data = __constr_expr_0;
#line 4355
  lockdep_init_map(& adapter->work.work.lockdep_map, "(&(&adapter->work)->work)",
                   & __key, 0);
#line 4355
  INIT_LIST_HEAD(& adapter->work.work.entry);
#line 4355
  adapter->work.work.func = & be_worker;
#line 4355
  init_timer_key(& adapter->work.timer, 2U, "(&(&adapter->work)->timer)", & __key___0);
#line 4355
  adapter->work.timer.function = & delayed_work_timer_fn;
#line 4355
  adapter->work.timer.data = (unsigned long )(& adapter->work);
#line 4356
  __init_work(& adapter->func_recovery_work.work, 0);
#line 4356
  __constr_expr_1.counter = 137438953408L;
#line 4356
  adapter->func_recovery_work.work.data = __constr_expr_1;
#line 4356
  lockdep_init_map(& adapter->func_recovery_work.work.lockdep_map, "(&(&adapter->func_recovery_work)->work)",
                   & __key___1, 0);
#line 4356
  INIT_LIST_HEAD(& adapter->func_recovery_work.work.entry);
#line 4356
  adapter->func_recovery_work.work.func = & be_func_recovery_task;
#line 4356
  init_timer_key(& adapter->func_recovery_work.timer, 2U, "(&(&adapter->func_recovery_work)->timer)",
                 & __key___2);
#line 4356
  adapter->func_recovery_work.timer.function = & delayed_work_timer_fn;
#line 4356
  adapter->func_recovery_work.timer.data = (unsigned long )(& adapter->func_recovery_work);
#line 4357
  tmp___1 = 1U;
#line 4357
  adapter->tx_fc = tmp___1;
#line 4357
  adapter->rx_fc = tmp___1;
#line 4359
  status = be_setup(adapter);
#line 4360
  if (status != 0) {
#line 4361
    goto stats_clean;
  } else {

  }
#line 4363
  be_netdev_init(netdev);
#line 4364
  status = register_netdev(netdev);
#line 4365
  if (status != 0) {
#line 4366
    goto unsetup;
  } else {

  }
#line 4368
  be_roce_dev_add(adapter);
#line 4370
  tmp___2 = msecs_to_jiffies(1000U);
#line 4370
  schedule_delayed_work(& adapter->func_recovery_work, tmp___2);
#line 4373
  be_cmd_query_port_name(adapter, (u8 *)(& port_name));
#line 4375
  tmp___3 = mc_name(adapter);
#line 4375
  tmp___4 = func_name(adapter);
#line 4375
  tmp___5 = nic_name(pdev);
#line 4375
  _dev_info((struct device  const  *)(& pdev->dev), "%s: %s %s port %c\n", tmp___5,
            tmp___4, tmp___3, (int )port_name);
#line 4378
  return (0);
  unsetup: 
#line 4381
  be_clear(adapter);
  stats_clean: 
#line 4383
  be_stats_cleanup(adapter);
  ctrl_clean: 
#line 4385
  be_ctrl_cleanup(adapter);
  free_netdev: 
#line 4387
  free_netdev(netdev);
#line 4388
  pci_set_drvdata(pdev, 0);
  rel_reg: 
#line 4390
  pci_release_regions(pdev);
  disable_dev: 
#line 4392
  pci_disable_device(pdev);
  do_none: 
#line 4394
  tmp___6 = nic_name(pdev);
#line 4394
  dev_err((struct device  const  *)(& pdev->dev), "%s initialization failed\n", tmp___6);
#line 4395
  return (status);
}
}
#line 4398 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  pci_power_t tmp___1 ;

  {
#line 4400
  tmp = pci_get_drvdata(pdev);
#line 4400
  adapter = (struct be_adapter *)tmp;
#line 4401
  netdev = adapter->netdev;
#line 4403
  if ((int )adapter->wol) {
#line 4404
    be_setup_wol(adapter, 1);
  } else {

  }
#line 4406
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4408
  netif_device_detach(netdev);
#line 4409
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4409
  if ((int )tmp___0) {
#line 4410
    rtnl_lock();
#line 4411
    be_close(netdev);
#line 4412
    rtnl_unlock();
  } else {

  }
#line 4414
  be_clear(adapter);
#line 4416
  pci_save_state(pdev);
#line 4417
  pci_disable_device(pdev);
#line 4418
  tmp___1 = pci_choose_state(pdev, state);
#line 4418
  pci_set_power_state(pdev, tmp___1);
#line 4419
  return (0);
}
}
#line 4422 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4424
  status = 0;
#line 4425
  tmp = pci_get_drvdata(pdev);
#line 4425
  adapter = (struct be_adapter *)tmp;
#line 4426
  netdev = adapter->netdev;
#line 4428
  netif_device_detach(netdev);
#line 4430
  status = pci_enable_device(pdev);
#line 4431
  if (status != 0) {
#line 4432
    return (status);
  } else {

  }
#line 4434
  pci_set_power_state(pdev, 0);
#line 4435
  pci_restore_state(pdev);
#line 4438
  status = be_cmd_fw_init(adapter);
#line 4439
  if (status != 0) {
#line 4440
    return (status);
  } else {

  }
#line 4442
  be_setup(adapter);
#line 4443
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4443
  if ((int )tmp___0) {
#line 4444
    rtnl_lock();
#line 4445
    be_open(netdev);
#line 4446
    rtnl_unlock();
  } else {

  }
#line 4449
  tmp___1 = msecs_to_jiffies(1000U);
#line 4449
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 4451
  netif_device_attach(netdev);
#line 4453
  if ((int )adapter->wol) {
#line 4454
    be_setup_wol(adapter, 0);
  } else {

  }
#line 4456
  return (0);
}
}
#line 4462 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_shutdown(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 4464
  tmp = pci_get_drvdata(pdev);
#line 4464
  adapter = (struct be_adapter *)tmp;
#line 4466
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 4467
    return;
  } else {

  }
#line 4469
  cancel_delayed_work_sync(& adapter->work);
#line 4470
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4472
  netif_device_detach(adapter->netdev);
#line 4474
  be_cmd_reset_function(adapter);
#line 4476
  pci_disable_device(pdev);
#line 4477
  return;
}
}
#line 4479 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static pci_ers_result_t be_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;

  {
#line 4482
  tmp = pci_get_drvdata(pdev);
#line 4482
  adapter = (struct be_adapter *)tmp;
#line 4483
  netdev = adapter->netdev;
#line 4485
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH error detected\n");
#line 4487
  adapter->eeh_error = 1;
#line 4489
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4491
  rtnl_lock();
#line 4492
  netif_device_detach(netdev);
#line 4493
  rtnl_unlock();
#line 4495
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4495
  if ((int )tmp___0) {
#line 4496
    rtnl_lock();
#line 4497
    be_close(netdev);
#line 4498
    rtnl_unlock();
  } else {

  }
#line 4500
  be_clear(adapter);
#line 4502
  if (state == 3U) {
#line 4503
    return (4U);
  } else {

  }
#line 4505
  pci_disable_device(pdev);
#line 4513
  if (pdev->devfn == 0U) {
#line 4514
    ssleep(30U);
  } else {

  }
#line 4516
  return (3U);
}
}
#line 4519 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static pci_ers_result_t be_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 4521
  tmp = pci_get_drvdata(pdev);
#line 4521
  adapter = (struct be_adapter *)tmp;
#line 4524
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH reset\n");
#line 4525
  be_clear_all_error(adapter);
#line 4527
  status = pci_enable_device(pdev);
#line 4528
  if (status != 0) {
#line 4529
    return (4U);
  } else {

  }
#line 4531
  pci_set_master(pdev);
#line 4532
  pci_set_power_state(pdev, 0);
#line 4533
  pci_restore_state(pdev);
#line 4536
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Waiting for FW to be ready after EEH reset\n");
#line 4538
  status = be_fw_wait_ready(adapter);
#line 4539
  if (status != 0) {
#line 4540
    return (4U);
  } else {

  }
#line 4542
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 4543
  return (5U);
}
}
#line 4546 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_eeh_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4548
  status = 0;
#line 4549
  tmp = pci_get_drvdata(pdev);
#line 4549
  adapter = (struct be_adapter *)tmp;
#line 4550
  netdev = adapter->netdev;
#line 4552
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume\n");
#line 4554
  pci_save_state(pdev);
#line 4556
  status = be_cmd_reset_function(adapter);
#line 4557
  if (status != 0) {
#line 4558
    goto err;
  } else {

  }
#line 4561
  status = be_cmd_fw_init(adapter);
#line 4562
  if (status != 0) {
#line 4563
    goto err;
  } else {

  }
#line 4565
  status = be_setup(adapter);
#line 4566
  if (status != 0) {
#line 4567
    goto err;
  } else {

  }
#line 4569
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 4569
  if ((int )tmp___0) {
#line 4570
    status = be_open(netdev);
#line 4571
    if (status != 0) {
#line 4572
      goto err;
    } else {

    }
  } else {

  }
#line 4575
  tmp___1 = msecs_to_jiffies(1000U);
#line 4575
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 4577
  netif_device_attach(netdev);
#line 4578
  return;
  err: 
#line 4580
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume failed\n");
#line 4581
  return;
}
}
#line 4583 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct pci_error_handlers  const  be_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& be_eeh_err_detected),
    0, 0, & be_eeh_reset, & be_eeh_resume};
#line 4589 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static struct pci_driver be_driver  = 
#line 4589
     {{0, 0}, "be2net", (struct pci_device_id  const  *)(& be_dev_ids), & be_probe,
    & be_remove, & be_suspend, 0, 0, & be_resume, & be_shutdown, 0, & be_eeh_handlers,
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                           {0, 0}}};
#line 4600 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static int be_init_module(void) 
{ 
  int tmp ;

  {
#line 4602
  if (((unsigned int )rx_frag_size != 8192U && (unsigned int )rx_frag_size != 4096U) && (unsigned int )rx_frag_size != 2048U) {
#line 4604
    printk("\fbe2net : Module param rx_frag_size must be 2048/4096/8192. Using 2048\n");
#line 4607
    rx_frag_size = 2048U;
  } else {

  }
#line 4610
  tmp = __pci_register_driver(& be_driver, & __this_module, "be2net");
#line 4610
  return (tmp);
}
}
#line 4614 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
static void be_exit_module(void) 
{ 


  {
#line 4616
  pci_unregister_driver(& be_driver);
#line 4617
  return;
}
}
#line 4636
void ldv_check_final_state(void) ;
#line 4639
extern void ldv_check_return_value(int  ) ;
#line 4642
extern void ldv_check_return_value_probe(int  ) ;
#line 4645
void ldv_initialize(void) ;
#line 4648
extern void ldv_handler_precall(void) ;
#line 4651
extern int __VERIFIER_nondet_int(void) ;
#line 4654 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 4657 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void ldv_main0_sequence_infinite_withcheck_stateful(void) 
{ 
  struct net_device *var_group1 ;
  int res_be_open_88 ;
  int res_be_close_86 ;
  struct sk_buff *var_group2 ;
  void *var_be_mac_addr_set_9_p1 ;
  int var_be_change_mtu_32_p1 ;
  struct rtnl_link_stats64 *var_group3 ;
  __be16 var_be_vlan_add_vid_34_p1 ;
  u16 var_be_vlan_add_vid_34_p2 ;
  __be16 var_be_vlan_rem_vid_35_p1 ;
  u16 var_be_vlan_rem_vid_35_p2 ;
  int var_be_set_vf_mac_37_p1 ;
  u8 *var_be_set_vf_mac_37_p2 ;
  int var_be_set_vf_vlan_39_p1 ;
  u16 var_be_set_vf_vlan_39_p2 ;
  u8 var_be_set_vf_vlan_39_p3 ;
  int var_be_set_vf_tx_rate_40_p1 ;
  int var_be_set_vf_tx_rate_40_p2 ;
  int var_be_get_vf_config_38_p1 ;
  struct ifla_vf_info *var_be_get_vf_config_38_p2 ;
  struct pci_dev *var_group4 ;
  pci_channel_state_t var_be_eeh_err_detected_139_p1 ;
  struct pci_device_id  const  *var_be_probe_135_p1 ;
  int res_be_probe_135 ;
  pm_message_t var_be_suspend_136_p1 ;
  int var_be_intx_71_p0 ;
  void *var_be_intx_71_p1 ;
  int var_be_msix_72_p0 ;
  void *var_be_msix_72_p1 ;
  int ldv_s_be_netdev_ops_net_device_ops ;
  int ldv_s_be_driver_pci_driver ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5232
  ldv_s_be_netdev_ops_net_device_ops = 0;
#line 5237
  ldv_s_be_driver_pci_driver = 0;
#line 5198
  LDV_IN_INTERRUPT = 1;
#line 5207
  ldv_initialize();
#line 5229
  ldv_handler_precall();
#line 5230
  tmp = be_init_module();
#line 5230
  if (tmp != 0) {
#line 5231
    goto ldv_final;
  } else {

  }
#line 5243
  goto ldv_52736;
  ldv_52735: 
#line 5248
  tmp___0 = __VERIFIER_nondet_int();
#line 5248
  switch (tmp___0) {
  case 0: ;
#line 5253
  if (ldv_s_be_netdev_ops_net_device_ops == 0) {
#line 5262
    ldv_handler_precall();
#line 5263
    res_be_open_88 = be_open(var_group1);
#line 5264
    ldv_check_return_value(res_be_open_88);
#line 5265
    if (res_be_open_88 < 0) {
#line 5266
      goto ldv_module_exit;
    } else {

    }
#line 5281
    ldv_s_be_netdev_ops_net_device_ops = ldv_s_be_netdev_ops_net_device_ops + 1;
  } else {

  }
#line 5287
  goto ldv_52710;
  case 1: ;
#line 5291
  if (ldv_s_be_netdev_ops_net_device_ops == 1) {
#line 5300
    ldv_handler_precall();
#line 5301
    res_be_close_86 = be_close(var_group1);
#line 5302
    ldv_check_return_value(res_be_close_86);
#line 5303
    if (res_be_close_86 != 0) {
#line 5304
      goto ldv_module_exit;
    } else {

    }
#line 5319
    ldv_s_be_netdev_ops_net_device_ops = 0;
  } else {

  }
#line 5325
  goto ldv_52710;
  case 2: 
#line 5337
  ldv_handler_precall();
#line 5338
  be_xmit(var_group2, var_group1);
#line 5360
  goto ldv_52710;
  case 3: 
#line 5372
  ldv_handler_precall();
#line 5373
  be_set_rx_mode(var_group1);
#line 5395
  goto ldv_52710;
  case 4: 
#line 5404
  ldv_handler_precall();
#line 5405
  be_mac_addr_set(var_group1, var_be_mac_addr_set_9_p1);
#line 5429
  goto ldv_52710;
  case 5: 
#line 5441
  ldv_handler_precall();
#line 5442
  be_change_mtu(var_group1, var_be_change_mtu_32_p1);
#line 5464
  goto ldv_52710;
  case 6: 
#line 5476
  ldv_handler_precall();
#line 5477
  be_get_stats64(var_group1, var_group3);
#line 5499
  goto ldv_52710;
  case 7: 
#line 5511
  ldv_handler_precall();
#line 5512
  be_vlan_add_vid(var_group1, (int )var_be_vlan_add_vid_34_p1, (int )var_be_vlan_add_vid_34_p2);
#line 5534
  goto ldv_52710;
  case 8: 
#line 5546
  ldv_handler_precall();
#line 5547
  be_vlan_rem_vid(var_group1, (int )var_be_vlan_rem_vid_35_p1, (int )var_be_vlan_rem_vid_35_p2);
#line 5569
  goto ldv_52710;
  case 9: 
#line 5581
  ldv_handler_precall();
#line 5582
  be_set_vf_mac(var_group1, var_be_set_vf_mac_37_p1, var_be_set_vf_mac_37_p2);
#line 5604
  goto ldv_52710;
  case 10: 
#line 5616
  ldv_handler_precall();
#line 5617
  be_set_vf_vlan(var_group1, var_be_set_vf_vlan_39_p1, (int )var_be_set_vf_vlan_39_p2,
                 (int )var_be_set_vf_vlan_39_p3);
#line 5639
  goto ldv_52710;
  case 11: 
#line 5651
  ldv_handler_precall();
#line 5652
  be_set_vf_tx_rate(var_group1, var_be_set_vf_tx_rate_40_p1, var_be_set_vf_tx_rate_40_p2);
#line 5674
  goto ldv_52710;
  case 12: 
#line 5686
  ldv_handler_precall();
#line 5687
  be_get_vf_config(var_group1, var_be_get_vf_config_38_p1, var_be_get_vf_config_38_p2);
#line 5709
  goto ldv_52710;
  case 13: 
#line 5723
  ldv_handler_precall();
#line 5724
  be_netpoll(var_group1);
#line 5744
  goto ldv_52710;
  case 14: 
#line 5769
  ldv_handler_precall();
#line 5770
  be_eeh_err_detected(var_group4, var_be_eeh_err_detected_139_p1);
#line 5777
  goto ldv_52710;
  case 15: 
#line 5802
  ldv_handler_precall();
#line 5803
  be_eeh_reset(var_group4);
#line 5810
  goto ldv_52710;
  case 16: 
#line 5835
  ldv_handler_precall();
#line 5836
  be_eeh_resume(var_group4);
#line 5843
  goto ldv_52710;
  case 17: ;
#line 5847
  if (ldv_s_be_driver_pci_driver == 0) {
#line 5868
    res_be_probe_135 = be_probe(var_group4, var_be_probe_135_p1);
#line 5869
    ldv_check_return_value(res_be_probe_135);
#line 5870
    ldv_check_return_value_probe(res_be_probe_135);
#line 5871
    if (res_be_probe_135 != 0) {
#line 5872
      goto ldv_module_exit;
    } else {

    }
#line 5873
    ldv_s_be_driver_pci_driver = ldv_s_be_driver_pci_driver + 1;
  } else {

  }
#line 5879
  goto ldv_52710;
  case 18: ;
#line 5883
  if (ldv_s_be_driver_pci_driver == 1) {
#line 5904
    ldv_handler_precall();
#line 5905
    be_remove(var_group4);
#line 5906
    ldv_s_be_driver_pci_driver = 0;
  } else {

  }
#line 5912
  goto ldv_52710;
  case 19: 
#line 5937
  ldv_handler_precall();
#line 5938
  be_suspend(var_group4, var_be_suspend_136_p1);
#line 5945
  goto ldv_52710;
  case 20: 
#line 5970
  ldv_handler_precall();
#line 5971
  be_resume(var_group4);
#line 5978
  goto ldv_52710;
  case 21: 
#line 6003
  ldv_handler_precall();
#line 6004
  be_shutdown(var_group4);
#line 6011
  goto ldv_52710;
  case 22: 
#line 6015
  LDV_IN_INTERRUPT = 2;
#line 6023
  ldv_handler_precall();
#line 6024
  be_intx(var_be_intx_71_p0, var_be_intx_71_p1);
#line 6040
  LDV_IN_INTERRUPT = 1;
#line 6046
  goto ldv_52710;
  case 23: 
#line 6050
  LDV_IN_INTERRUPT = 2;
#line 6058
  ldv_handler_precall();
#line 6059
  be_msix(var_be_msix_72_p0, var_be_msix_72_p1);
#line 6075
  LDV_IN_INTERRUPT = 1;
#line 6081
  goto ldv_52710;
  default: ;
#line 6082
  goto ldv_52710;
  }
  ldv_52710: ;
  ldv_52736: 
#line 5243
  tmp___1 = __VERIFIER_nondet_int();
#line 5243
  if ((tmp___1 != 0 || ldv_s_be_netdev_ops_net_device_ops != 0) || ldv_s_be_driver_pci_driver != 0) {
#line 5247
    goto ldv_52735;
  } else {

  }

  ldv_module_exit: 
#line 6110
  ldv_handler_precall();
#line 6111
  be_exit_module();
  ldv_final: 
#line 6114
  ldv_check_final_state();
#line 6117
  return;
}
}
#line 6121 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 6126
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 6128
  mutex_lock(ldv_func_arg1);
#line 6129
  return;
}
}
#line 6131 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 6136
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 6138
  mutex_unlock(ldv_func_arg1);
#line 6139
  return;
}
}
#line 6141 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 6146
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 6148
  mutex_lock(ldv_func_arg1);
#line 6149
  return;
}
}
#line 6151 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 6156
  tmp = mutex_trylock(ldv_func_arg1);
#line 6156
  ldv_func_res = tmp;
#line 6158
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 6158
  return (tmp___0);
#line 6160
  return (ldv_func_res);
}
}
#line 6163 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_main.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 6168
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 6170
  mutex_unlock(ldv_func_arg1);
#line 6171
  return;
}
}
#line 447 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 461
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 474
  return (r + 1);
}
}
#line 32 "include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
#line 34
  tmp = fls((int )n);
#line 34
  return (tmp + -1);
}
}
#line 62 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 174 "include/linux/mutex.h"
int ldv_mutex_trylock_14(struct mutex *ldv_func_arg1 ) ;
#line 179
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 183
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 187
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 191
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 195
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) ;
#line 199
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) ;
#line 203
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) ;
#line 207
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
#line 211
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
#line 215
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) ;
#line 219
void ldv_mutex_unlock_33(struct mutex *ldv_func_arg1 ) ;
#line 223
void ldv_mutex_unlock_35(struct mutex *ldv_func_arg1 ) ;
#line 227
void ldv_mutex_unlock_37(struct mutex *ldv_func_arg1 ) ;
#line 231
void ldv_mutex_unlock_39(struct mutex *ldv_func_arg1 ) ;
#line 235
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) ;
#line 239
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 243
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) ;
#line 247
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) ;
#line 251
void ldv_mutex_unlock_49(struct mutex *ldv_func_arg1 ) ;
#line 5 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 8
int ldv_mutex_lock_interruptible_16(struct mutex *ldv_func_arg1 ) ;
#line 12
int ldv_mutex_lock_interruptible_18(struct mutex *ldv_func_arg1 ) ;
#line 16
int ldv_mutex_lock_interruptible_20(struct mutex *ldv_func_arg1 ) ;
#line 20
int ldv_mutex_lock_interruptible_22(struct mutex *ldv_func_arg1 ) ;
#line 24
int ldv_mutex_lock_interruptible_24(struct mutex *ldv_func_arg1 ) ;
#line 28
int ldv_mutex_lock_interruptible_26(struct mutex *ldv_func_arg1 ) ;
#line 32
int ldv_mutex_lock_interruptible_28(struct mutex *ldv_func_arg1 ) ;
#line 36
int ldv_mutex_lock_interruptible_30(struct mutex *ldv_func_arg1 ) ;
#line 40
int ldv_mutex_lock_interruptible_32(struct mutex *ldv_func_arg1 ) ;
#line 44
int ldv_mutex_lock_interruptible_34(struct mutex *ldv_func_arg1 ) ;
#line 48
int ldv_mutex_lock_interruptible_36(struct mutex *ldv_func_arg1 ) ;
#line 52
int ldv_mutex_lock_interruptible_38(struct mutex *ldv_func_arg1 ) ;
#line 56
int ldv_mutex_lock_interruptible_40(struct mutex *ldv_func_arg1 ) ;
#line 60
int ldv_mutex_lock_interruptible_42(struct mutex *ldv_func_arg1 ) ;
#line 64
int ldv_mutex_lock_interruptible_44(struct mutex *ldv_func_arg1 ) ;
#line 68
int ldv_mutex_lock_interruptible_46(struct mutex *ldv_func_arg1 ) ;
#line 72
int ldv_mutex_lock_interruptible_48(struct mutex *ldv_func_arg1 ) ;
#line 78
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 82
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 100
int ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(struct mutex *lock ) ;
#line 107
void ldv_mutex_unlock_mbox_lock_of_be_adapter(struct mutex *lock ) ;
#line 28 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 288 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 290
  _raw_spin_lock_bh(& lock->ldv_6014.rlock);
#line 291
  return;
}
}
#line 328 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 330
  _raw_spin_unlock_bh(& lock->ldv_6014.rlock);
#line 331
  return;
}
}
#line 83 "include/linux/completion.h"
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 94
extern void complete(struct completion * ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 72 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) ;
#line 134 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO___0(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
#line 136
  tmp = ldv__builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
#line 136
  if (tmp != 0L) {
#line 136
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (136), "i" (12UL));
    ldv_49493: ;
#line 136
    goto ldv_49493;
  } else {

  }
#line 137
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 145 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc___0(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 147
  tmp = MODULO___0((int )((unsigned int )*index + 1U), (int )limit);
#line 147
  *index = (u16 )tmp;
#line 148
  return;
}
}
#line 160 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_index_node(struct be_queue_info *q , u16 index ) 
{ 


  {
#line 162
  return (q->dma_mem.va + (unsigned long )((int )index * (int )q->entry_size));
}
}
#line 165 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 167
  index_inc___0(& q->head, (int )q->len);
#line 168
  return;
}
}
#line 170 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_dec(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
#line 172
  tmp = MODULO___0((int )((unsigned int )*index + 65535U), (int )limit);
#line 172
  *index = (u16 )tmp;
#line 173
  return;
}
}
#line 175 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc___0(struct be_queue_info *q ) 
{ 


  {
#line 177
  index_inc___0(& q->tail, (int )q->len);
#line 178
  return;
}
}
#line 622 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_error(struct be_adapter *adapter ) 
{ 


  {
#line 624
  return ((bool )(((int )adapter->eeh_error || (int )adapter->hw_error) || (int )adapter->fw_timeout));
}
}
#line 1881 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) ;
#line 1883
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) ;
#line 1894
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) ;
#line 1905
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) ;
#line 1908
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) ;
#line 1910
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 1912
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) ;
#line 1920
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) ;
#line 1921
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) ;
#line 1936
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) ;
#line 1939
int lancer_wait_ready(struct be_adapter *adapter ) ;
#line 61 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static struct be_cmd_priv_map cmd_priv_map[5U]  = {      {12U, 3U, 1800U}, 
        {37U, 1U, 1794U}, 
        {36U, 1U, 1800U}, 
        {18U, 3U, 1800U}, 
        {102U, 1U, 1800U}};
#line 94 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static bool be_cmd_allowed(struct be_adapter *adapter , u8 opcode , u8 subsystem ) 
{ 
  int i ;
  int num_entries ;
  u32 cmd_privileges ;

  {
#line 98
  num_entries = 5;
#line 99
  cmd_privileges = adapter->cmd_privileges;
#line 101
  i = 0;
#line 101
  goto ldv_51314;
  ldv_51313: ;
#line 102
  if ((int )cmd_priv_map[i].opcode == (int )opcode && (int )cmd_priv_map[i].subsystem == (int )subsystem) {
#line 104
    if ((cmd_priv_map[i].priv_mask & cmd_privileges) == 0U) {
#line 105
      return (0);
    } else {

    }
  } else {

  }
#line 101
  i = i + 1;
  ldv_51314: ;
#line 101
  if (i < num_entries) {
#line 103
    goto ldv_51313;
  } else {

  }

#line 107
  return (1);
}
}
#line 110 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 112
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 115 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_mcc_notify(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;
  bool tmp ;

  {
#line 117
  mccq = & adapter->mcc_obj.q;
#line 118
  val = 0U;
#line 120
  tmp = be_error(adapter);
#line 120
  if ((int )tmp) {
#line 121
    return;
  } else {

  }
#line 123
  val = ((u32 )mccq->id & 2047U) | val;
#line 124
  val = val | 65536U;
#line 126
  __asm__  volatile   ("sfence": : : "memory");
#line 127
  iowrite32(val, (void *)adapter->db + 320U);
#line 128
  return;
}
}
#line 133 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  u32 flags ;

  {
#line 137
  if (compl->flags != 0U) {
#line 138
    flags = compl->flags;
#line 139
    if ((int )flags < 0) {
#line 140
      compl->flags = flags;
#line 141
      return (1);
    } else {

    }
  } else {

  }
#line 144
  return (0);
}
}
#line 148 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 150
  compl->flags = 0U;
#line 151
  return;
}
}
#line 153 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0 , u32 tag1 ) 
{ 
  unsigned long addr ;

  {
#line 157
  addr = (unsigned long )tag1;
#line 158
  addr = (addr << 32UL) | (unsigned long )tag0;
#line 159
  return ((struct be_cmd_resp_hdr *)addr);
}
}
#line 162 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mcc_compl_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  u16 compl_status ;
  u16 extd_status ;
  struct be_cmd_resp_hdr *resp_hdr ;
  u8 opcode ;
  u8 subsystem ;
  struct be_cmd_resp_get_cntl_addnl_attribs *resp ;

  {
#line 167
  opcode = 0U;
#line 167
  subsystem = 0U;
#line 171
  swap_dws((void *)compl, 4);
#line 173
  compl_status = (u16 )compl->status;
#line 176
  resp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);
#line 178
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 179
    opcode = resp_hdr->opcode;
#line 180
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 183
  if (((unsigned int )opcode == 7U || (unsigned int )opcode == 172U) && (unsigned int )subsystem == 1U) {
#line 186
    adapter->flash_status = (u32 )compl_status;
#line 187
    complete(& adapter->flash_compl);
  } else {

  }
#line 190
  if ((unsigned int )compl_status == 0U) {
#line 191
    if (((unsigned int )opcode == 4U || (unsigned int )opcode == 18U) && (unsigned int )subsystem == 3U) {
#line 194
      be_parse_stats(adapter);
#line 195
      adapter->stats_cmd_sent = 0;
    } else {

    }
#line 197
    if ((unsigned int )opcode == 121U && (unsigned int )subsystem == 1U) {
#line 199
      resp = (struct be_cmd_resp_get_cntl_addnl_attribs *)resp_hdr;
#line 201
      adapter->drv_stats.be_on_die_temperature = (u32 )resp->on_die_temperature;
    } else {

    }
  } else {
#line 205
    if ((unsigned int )opcode == 121U) {
#line 206
      adapter->be_get_temp_freq = 0;
    } else {

    }
#line 208
    if ((unsigned int )compl_status == 66U || (unsigned int )compl_status == 2U) {
#line 210
      goto done;
    } else {

    }
#line 212
    if ((unsigned int )compl_status == 5U) {
#line 213
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF is not privileged to issue opcode %d-%d\n",
               (int )opcode, (int )subsystem);
    } else {
#line 217
      extd_status = (u16 )(compl->status >> 16);
#line 219
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "opcode %d-%d failed:status %d-%d\n",
              (int )opcode, (int )subsystem, (int )compl_status, (int )extd_status);
    }
  }
  done: ;
#line 225
  return ((int )compl_status);
}
}
#line 229 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_link_state_process(struct be_adapter *adapter , struct be_async_event_link_state *evt ) 
{ 


  {
#line 233
  adapter->phy.link_speed = -1;
#line 236
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && ((int )evt->port_link_status & 2) == 0) {
#line 238
    return;
  } else {

  }
#line 243
  if ((int )adapter->flags & 1) {
#line 244
    be_link_status_update(adapter, (int )evt->port_link_status);
  } else {

  }
#line 245
  return;
}
}
#line 248 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_grp5_cos_priority_process(struct be_adapter *adapter , struct be_async_event_grp5_cos_priority *evt ) 
{ 


  {
#line 251
  if ((unsigned int )evt->valid != 0U) {
#line 252
    adapter->vlan_prio_bmap = evt->available_priority_bmap;
#line 253
    adapter->recommended_prio = (unsigned int )adapter->recommended_prio & 8191U;
#line 254
    adapter->recommended_prio = (int )((u16 )evt->reco_default_priority) << 13U;
  } else {

  }
#line 257
  return;
}
}
#line 260 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_grp5_qos_speed_process(struct be_adapter *adapter , struct be_async_event_grp5_qos_link_speed *evt ) 
{ 


  {
#line 263
  if (adapter->phy.link_speed >= 0 && (u32 )evt->physical_port == adapter->port_num) {
#line 265
    adapter->phy.link_speed = (int )evt->qos_link_speed * 10;
  } else {

  }
#line 266
  return;
}
}
#line 269 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_grp5_pvid_state_process(struct be_adapter *adapter , struct be_async_event_grp5_pvid_state *evt ) 
{ 


  {
#line 272
  if ((unsigned int )evt->enabled != 0U) {
#line 273
    adapter->pvid = (unsigned int )evt->tag & 4095U;
  } else {
#line 275
    adapter->pvid = 0U;
  }
#line 276
  return;
}
}
#line 278 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_grp5_evt_process(struct be_adapter *adapter , u32 trailer , struct be_mcc_compl *evt ) 
{ 
  u8 event_type ;

  {
#line 281
  event_type = 0U;
#line 283
  event_type = (u8 )(trailer >> 16);
#line 286
  switch ((int )event_type) {
  case 2: 
#line 288
  be_async_grp5_cos_priority_process(adapter, (struct be_async_event_grp5_cos_priority *)evt);
#line 290
  goto ldv_51370;
  case 1: 
#line 292
  be_async_grp5_qos_speed_process(adapter, (struct be_async_event_grp5_qos_link_speed *)evt);
#line 294
  goto ldv_51370;
  case 3: 
#line 296
  be_async_grp5_pvid_state_process(adapter, (struct be_async_event_grp5_pvid_state *)evt);
#line 298
  goto ldv_51370;
  default: 
#line 300
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown grp5 event!\n");
#line 301
  goto ldv_51370;
  }
  ldv_51370: ;
#line 304
  return;
}
}
#line 305 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_async_dbg_evt_process(struct be_adapter *adapter , u32 trailer , struct be_mcc_compl *cmp ) 
{ 
  u8 event_type ;
  struct be_async_event_qnq *evt ;

  {
#line 308
  event_type = 0U;
#line 309
  evt = (struct be_async_event_qnq *)cmp;
#line 311
  event_type = (u8 )(trailer >> 16);
#line 314
  switch ((int )event_type) {
  case 1: ;
#line 316
  if ((unsigned int )evt->valid != 0U) {
#line 317
    adapter->qnq_vid = evt->vlan_tag;
  } else {

  }
#line 318
  adapter->flags = adapter->flags | 2048U;
#line 319
  goto ldv_51382;
  default: 
#line 321
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown debug event\n");
#line 322
  goto ldv_51382;
  }
  ldv_51382: ;
#line 325
  return;
}
}
#line 326 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static bool is_link_state_evt(u32 trailer ) 
{ 


  {
#line 328
  return (((trailer >> 8) & 255U) == 1U);
}
}
#line 333 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static bool is_grp5_evt(u32 trailer ) 
{ 


  {
#line 335
  return (((trailer >> 8) & 255U) == 5U);
}
}
#line 340 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static bool is_dbg_evt(u32 trailer ) 
{ 


  {
#line 342
  return (((trailer >> 8) & 255U) == 6U);
}
}
#line 347 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 349
  mcc_cq = & adapter->mcc_obj.cq;
#line 350
  tmp = queue_tail_node(mcc_cq);
#line 350
  compl = (struct be_mcc_compl *)tmp;
#line 352
  tmp___0 = be_mcc_compl_is_new(compl);
#line 352
  if ((int )tmp___0) {
#line 353
    queue_tail_inc___0(mcc_cq);
#line 354
    return (compl);
  } else {

  }
#line 356
  return (0);
}
}
#line 359 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void be_async_mcc_enable(struct be_adapter *adapter ) 
{ 


  {
#line 361
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 363
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 1, 0);
#line 364
  adapter->mcc_obj.rearm_cq = 1;
#line 366
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 367
  return;
}
}
#line 369 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void be_async_mcc_disable(struct be_adapter *adapter ) 
{ 


  {
#line 371
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 373
  adapter->mcc_obj.rearm_cq = 0;
#line 374
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 0, 0);
#line 376
  spin_unlock_bh(& adapter->mcc_cq_lock);
#line 377
  return;
}
}
#line 379 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_process_mcc(struct be_adapter *adapter ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 382
  num = 0;
#line 382
  status = 0;
#line 383
  mcc_obj = & adapter->mcc_obj;
#line 385
  spin_lock(& adapter->mcc_cq_lock);
#line 386
  goto ldv_51412;
  ldv_51411: ;
#line 387
  if ((compl->flags & 1073741824U) != 0U) {
#line 389
    tmp___1 = is_link_state_evt(compl->flags);
#line 389
    if ((int )tmp___1) {
#line 390
      be_async_link_state_process(adapter, (struct be_async_event_link_state *)compl);
    } else {
#line 392
      tmp___0 = is_grp5_evt(compl->flags);
#line 392
      if ((int )tmp___0) {
#line 393
        be_async_grp5_evt_process(adapter, compl->flags, compl);
      } else {
#line 395
        tmp = is_dbg_evt(compl->flags);
#line 395
        if ((int )tmp) {
#line 396
          be_async_dbg_evt_process(adapter, compl->flags, compl);
        } else {

        }
      }
    }
  } else
#line 398
  if ((compl->flags & 268435456U) != 0U) {
#line 399
    status = be_mcc_compl_process(adapter, compl);
#line 400
    atomic_dec(& mcc_obj->q.used);
  } else {

  }
#line 402
  be_mcc_compl_use(compl);
#line 403
  num = num + 1;
  ldv_51412: 
#line 386
  compl = be_mcc_compl_get(adapter);
#line 386
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 388
    goto ldv_51411;
  } else {

  }

#line 406
  if (num != 0) {
#line 407
    be_cq_notify(adapter, (int )mcc_obj->cq.id, (int )mcc_obj->rearm_cq, (int )((u16 )num));
  } else {

  }
#line 409
  spin_unlock(& adapter->mcc_cq_lock);
#line 410
  return (status);
}
}
#line 414 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mcc_wait_compl(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  bool tmp ;
  int tmp___0 ;

  {
#line 417
  status = 0;
#line 418
  mcc_obj = & adapter->mcc_obj;
#line 420
  i = 0;
#line 420
  goto ldv_51422;
  ldv_51421: 
#line 421
  tmp = be_error(adapter);
#line 421
  if ((int )tmp) {
#line 422
    return (-5);
  } else {

  }
#line 424
  local_bh_disable();
#line 425
  status = be_process_mcc(adapter);
#line 426
  local_bh_enable();
#line 428
  tmp___0 = atomic_read((atomic_t const   *)(& mcc_obj->q.used));
#line 428
  if (tmp___0 == 0) {
#line 429
    goto ldv_51420;
  } else {

  }
#line 430
  __const_udelay(429500UL);
#line 420
  i = i + 1;
  ldv_51422: ;
#line 420
  if (i <= 119999) {
#line 422
    goto ldv_51421;
  } else {

  }
  ldv_51420: ;
#line 432
  if (i == 120000) {
#line 433
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 434
    adapter->fw_timeout = 1;
#line 435
    return (-5);
  } else {

  }
#line 437
  return (status);
}
}
#line 441 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mcc_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_obj *mcc_obj ;
  u16 index ;
  struct be_cmd_resp_hdr *resp ;
  void *tmp ;

  {
#line 445
  mcc_obj = & adapter->mcc_obj;
#line 446
  index = mcc_obj->q.head;
#line 449
  index_dec(& index, (int )mcc_obj->q.len);
#line 450
  tmp = queue_index_node(& mcc_obj->q, (int )index);
#line 450
  wrb = (struct be_mcc_wrb *)tmp;
#line 452
  resp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);
#line 454
  be_mcc_notify(adapter);
#line 456
  status = be_mcc_wait_compl(adapter);
#line 457
  if (status == -5) {
#line 458
    goto out;
  } else {

  }
#line 460
  status = (int )resp->status;
  out: ;
#line 462
  return (status);
}
}
#line 465 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mbox_db_ready_wait(struct be_adapter *adapter , void *db ) 
{ 
  int msecs ;
  u32 ready ;
  bool tmp ;

  {
#line 467
  msecs = 0;
  ldv_51439: 
#line 471
  tmp = be_error(adapter);
#line 471
  if ((int )tmp) {
#line 472
    return (-5);
  } else {

  }
#line 474
  ready = ioread32(db);
#line 475
  if (ready == 4294967295U) {
#line 476
    return (-1);
  } else {

  }
#line 478
  ready = ready & 1U;
#line 479
  if (ready != 0U) {
#line 480
    goto ldv_51438;
  } else {

  }
#line 482
  if (msecs > 4000) {
#line 483
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 484
    adapter->fw_timeout = 1;
#line 485
    be_detect_error(adapter);
#line 486
    return (-1);
  } else {

  }
#line 489
  msleep(1U);
#line 490
  msecs = msecs + 1;
#line 491
  goto ldv_51439;
  ldv_51438: ;
#line 493
  return (0);
}
}
#line 500 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mbox_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  bool tmp ;

  {
#line 503
  val = 0U;
#line 504
  db = (void *)adapter->db + 352U;
#line 505
  mbox_mem = & adapter->mbox_mem;
#line 506
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 507
  compl = & mbox->compl;
#line 510
  status = be_mbox_db_ready_wait(adapter, db);
#line 511
  if (status != 0) {
#line 512
    return (status);
  } else {

  }
#line 514
  val = val | 2U;
#line 516
  val = ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U) | val;
#line 517
  iowrite32(val, db);
#line 520
  status = be_mbox_db_ready_wait(adapter, db);
#line 521
  if (status != 0) {
#line 522
    return (status);
  } else {

  }
#line 524
  val = 0U;
#line 526
  val = ((unsigned int )(mbox_mem->dma >> 4) << 2) | val;
#line 527
  iowrite32(val, db);
#line 529
  status = be_mbox_db_ready_wait(adapter, db);
#line 530
  if (status != 0) {
#line 531
    return (status);
  } else {

  }
#line 534
  tmp = be_mcc_compl_is_new(compl);
#line 534
  if ((int )tmp) {
#line 535
    status = be_mcc_compl_process(adapter, & mbox->compl);
#line 536
    be_mcc_compl_use(compl);
#line 537
    if (status != 0) {
#line 538
      return (status);
    } else {

    }
  } else {
#line 540
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid mailbox completion\n");
#line 541
    return (-1);
  }
#line 543
  return (0);
}
}
#line 546 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static u16 be_POST_stage_get(struct be_adapter *adapter ) 
{ 
  u32 sem ;

  {
#line 550
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 551
    sem = ioread32((void *)adapter->csr + 172U);
  } else {
#line 553
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 148, & sem);
  }
#line 556
  return ((u16 )sem);
}
}
#line 559 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int lancer_wait_ready(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  int status ;
  int i ;

  {
#line 563
  status = 0;
#line 565
  i = 0;
#line 565
  goto ldv_51461;
  ldv_51460: 
#line 566
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 567
  if ((sliport_status & 8388608U) != 0U) {
#line 568
    goto ldv_51459;
  } else {

  }
#line 570
  msleep(1000U);
#line 565
  i = i + 1;
  ldv_51461: ;
#line 565
  if (i <= 29) {
#line 567
    goto ldv_51460;
  } else {

  }
  ldv_51459: ;
#line 573
  if (i == 30) {
#line 574
    status = -1;
  } else {

  }
#line 576
  return (status);
}
}
#line 579 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static bool lancer_provisioning_error(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;

  {
#line 581
  sliport_status = 0U;
#line 581
  sliport_err1 = 0U;
#line 581
  sliport_err2 = 0U;
#line 582
  sliport_status = ioread32((void *)adapter->db + 1028U);
#line 583
  if ((int )sliport_status < 0) {
#line 584
    sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 586
    sliport_err2 = ioread32((void *)adapter->db + 1040U);
#line 589
    if (sliport_err1 == 2U && sliport_err2 == 9U) {
#line 591
      return (1);
    } else {

    }
  } else {

  }
#line 593
  return (0);
}
}
#line 596 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 sliport_status ;
  u32 err ;
  u32 reset_needed ;
  bool resource_error ;

  {
#line 602
  resource_error = lancer_provisioning_error(adapter);
#line 603
  if ((int )resource_error) {
#line 604
    return (-1);
  } else {

  }
#line 606
  status = lancer_wait_ready(adapter);
#line 607
  if (status == 0) {
#line 608
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 609
    err = sliport_status & 2147483648U;
#line 610
    reset_needed = sliport_status & 16777216U;
#line 611
    if (err != 0U && reset_needed != 0U) {
#line 612
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 616
      status = lancer_wait_ready(adapter);
#line 617
      sliport_status = ioread32((void *)adapter->db + 1028U);
#line 619
      sliport_status = sliport_status & 2164260864U;
#line 621
      if (status != 0 || sliport_status != 0U) {
#line 622
        status = -1;
      } else {

      }
    } else
#line 623
    if (err != 0U || reset_needed != 0U) {
#line 624
      status = -1;
    } else {

    }
  } else {

  }
#line 631
  resource_error = lancer_provisioning_error(adapter);
#line 632
  if (status == -1 && ! resource_error) {
#line 633
    adapter->eeh_error = 1;
  } else {

  }
#line 635
  return (status);
}
}
#line 638 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_fw_wait_ready(struct be_adapter *adapter ) 
{ 
  u16 stage ;
  int status ;
  int timeout ;
  struct device *dev ;
  unsigned long tmp ;

  {
#line 641
  timeout = 0;
#line 642
  dev = & (adapter->pdev)->dev;
#line 644
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 645
    status = lancer_wait_ready(adapter);
#line 646
    return (status);
  } else {

  }
  ldv_51483: 
#line 650
  stage = be_POST_stage_get(adapter);
#line 651
  if ((unsigned int )stage == 49152U) {
#line 652
    return (0);
  } else {

  }
#line 654
  _dev_info((struct device  const  *)dev, "Waiting for POST, %ds elapsed\n", timeout);
#line 656
  tmp = msleep_interruptible(2000U);
#line 656
  if (tmp != 0UL) {
#line 657
    dev_err((struct device  const  *)dev, "Waiting for POST aborted\n");
#line 658
    return (-4);
  } else {

  }
#line 660
  timeout = timeout + 2;
#line 661
  if (timeout <= 59) {
#line 663
    goto ldv_51483;
  } else {

  }
#line 663
  dev_err((struct device  const  *)dev, "POST timeout; stage=0x%x\n", (int )stage);
#line 664
  return (-1);
}
}
#line 668 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 670
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 676 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem ,
                                   u8 opcode , int cmd_len , struct be_mcc_wrb *wrb ,
                                   struct be_dma_mem *mem ) 
{ 
  struct be_sge *sge ;
  unsigned long addr ;
  u64 req_addr ;

  {
#line 681
  addr = (unsigned long )req_hdr;
#line 682
  req_addr = (u64 )addr;
#line 684
  req_hdr->opcode = opcode;
#line 685
  req_hdr->subsystem = subsystem;
#line 686
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 687
  req_hdr->version = 0U;
#line 689
  wrb->tag0 = (u32 )req_addr;
#line 690
  wrb->tag1 = (unsigned int )(req_addr >> 32ULL);
#line 692
  wrb->payload_length = (u32 )cmd_len;
#line 693
  if ((unsigned long )mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 694
    wrb->embedded = wrb->embedded | 8U;
#line 696
    sge = nonembedded_sgl(wrb);
#line 697
    sge->pa_hi = (unsigned int )(mem->dma >> 32ULL);
#line 698
    sge->pa_lo = (unsigned int )mem->dma;
#line 699
    sge->len = mem->size;
  } else {
#line 701
    wrb->embedded = wrb->embedded | 1U;
  }
#line 702
  swap_dws((void *)wrb, 8);
#line 703
  return;
}
}
#line 705 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  unsigned int _min1 ;
  u32 _min2 ;
  u64 dma ;

  {
#line 708
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 708
  _min2 = max_pages;
#line 708
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 709
  dma = mem->dma;
#line 711
  i = 0;
#line 711
  goto ldv_51511;
  ldv_51510: 
#line 712
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 713
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 714
  dma = dma + 4096ULL;
#line 711
  i = i + 1;
  ldv_51511: ;
#line 711
  if (i < buf_pages) {
#line 713
    goto ldv_51510;
  } else {

  }

#line 718
  return;
}
}
#line 719 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static u32 eq_delay_to_mult(u32 usec_delay ) 
{ 
  u32 round ;
  u32 multiplier ;
  u32 interrupt_rate ;
  u32 _min1 ;
  unsigned int _min2 ;

  {
#line 722
  round = 10U;
#line 725
  if (usec_delay == 0U) {
#line 726
    multiplier = 0U;
  } else {
#line 728
    interrupt_rate = 1000000U / usec_delay;
#line 730
    if (interrupt_rate == 0U) {
#line 731
      multiplier = 1023U;
    } else {
#line 733
      multiplier = (651042U - interrupt_rate) * round;
#line 734
      multiplier = multiplier / interrupt_rate;
#line 736
      multiplier = (round / 2U + multiplier) / round;
#line 737
      _min1 = multiplier;
#line 737
      _min2 = 1023U;
#line 737
      multiplier = _min1 < _min2 ? _min1 : _min2;
    }
  }
#line 740
  return (multiplier);
}
}
#line 743 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
__inline static struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_wrb *wrb ;

  {
#line 745
  mbox_mem = & adapter->mbox_mem;
#line 746
  wrb = & ((struct be_mcc_mailbox *)mbox_mem->va)->wrb;
#line 748
  memset((void *)wrb, 0, 256UL);
#line 749
  return (wrb);
}
}
#line 752 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int tmp ;
  void *tmp___0 ;

  {
#line 754
  mccq = & adapter->mcc_obj.q;
#line 757
  if (! mccq->created) {
#line 758
    return (0);
  } else {

  }
#line 760
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
#line 760
  if (tmp >= (int )mccq->len) {
#line 761
    return (0);
  } else {

  }
#line 763
  tmp___0 = queue_head_node(mccq);
#line 763
  wrb = (struct be_mcc_wrb *)tmp___0;
#line 764
  queue_head_inc___0(mccq);
#line 765
  atomic_inc(& mccq->used);
#line 766
  memset((void *)wrb, 0, 256UL);
#line 767
  return (wrb);
}
}
#line 773 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_fw_init(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 778
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 779
    return (0);
  } else {

  }
#line 781
  tmp = ldv_mutex_lock_interruptible_16(& adapter->mbox_lock);
#line 781
  if (tmp != 0) {
#line 782
    return (-1);
  } else {

  }
#line 784
  tmp___0 = wrb_from_mbox(adapter);
#line 784
  wrb = (u8 *)tmp___0;
#line 785
  tmp___1 = wrb;
#line 785
  wrb = wrb + 1;
#line 785
  *tmp___1 = 255U;
#line 786
  tmp___2 = wrb;
#line 786
  wrb = wrb + 1;
#line 786
  *tmp___2 = 18U;
#line 787
  tmp___3 = wrb;
#line 787
  wrb = wrb + 1;
#line 787
  *tmp___3 = 52U;
#line 788
  tmp___4 = wrb;
#line 788
  wrb = wrb + 1;
#line 788
  *tmp___4 = 255U;
#line 789
  tmp___5 = wrb;
#line 789
  wrb = wrb + 1;
#line 789
  *tmp___5 = 255U;
#line 790
  tmp___6 = wrb;
#line 790
  wrb = wrb + 1;
#line 790
  *tmp___6 = 86U;
#line 791
  tmp___7 = wrb;
#line 791
  wrb = wrb + 1;
#line 791
  *tmp___7 = 120U;
#line 792
  *wrb = 255U;
#line 794
  status = be_mbox_notify_wait(adapter);
#line 796
  ldv_mutex_unlock_17(& adapter->mbox_lock);
#line 797
  return (status);
}
}
#line 803 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_fw_clean(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 808
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 809
    return (0);
  } else {

  }
#line 811
  tmp = ldv_mutex_lock_interruptible_18(& adapter->mbox_lock);
#line 811
  if (tmp != 0) {
#line 812
    return (-1);
  } else {

  }
#line 814
  tmp___0 = wrb_from_mbox(adapter);
#line 814
  wrb = (u8 *)tmp___0;
#line 815
  tmp___1 = wrb;
#line 815
  wrb = wrb + 1;
#line 815
  *tmp___1 = 255U;
#line 816
  tmp___2 = wrb;
#line 816
  wrb = wrb + 1;
#line 816
  *tmp___2 = 170U;
#line 817
  tmp___3 = wrb;
#line 817
  wrb = wrb + 1;
#line 817
  *tmp___3 = 187U;
#line 818
  tmp___4 = wrb;
#line 818
  wrb = wrb + 1;
#line 818
  *tmp___4 = 255U;
#line 819
  tmp___5 = wrb;
#line 819
  wrb = wrb + 1;
#line 819
  *tmp___5 = 255U;
#line 820
  tmp___6 = wrb;
#line 820
  wrb = wrb + 1;
#line 820
  *tmp___6 = 204U;
#line 821
  tmp___7 = wrb;
#line 821
  wrb = wrb + 1;
#line 821
  *tmp___7 = 221U;
#line 822
  *wrb = 255U;
#line 824
  status = be_mbox_notify_wait(adapter);
#line 826
  ldv_mutex_unlock_19(& adapter->mbox_lock);
#line 827
  return (status);
}
}
#line 830 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_eq_create(struct be_adapter *adapter , struct be_queue_info *eq , int eq_delay ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eq_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___7 ;

  {
#line 835
  q_mem = & eq->dma_mem;
#line 838
  tmp = ldv_mutex_lock_interruptible_20(& adapter->mbox_lock);
#line 838
  if (tmp != 0) {
#line 839
    return (-1);
  } else {

  }
#line 841
  wrb = wrb_from_mbox(adapter);
#line 842
  tmp___0 = embedded_payload(wrb);
#line 842
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 844
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 13, 100, wrb, 0);
#line 847
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 849
  tmp___1 = amap_mask(1U);
#line 849
  amap_set((void *)(& req->context), 0U, tmp___1, 29U, 1U);
#line 851
  tmp___2 = amap_mask(1U);
#line 851
  amap_set((void *)(& req->context), 0U, tmp___2, 31U, 0U);
#line 852
  tmp___3 = __ilog2_u32((unsigned int )eq->len / 256U);
#line 852
  tmp___4 = amap_mask(3U);
#line 852
  amap_set((void *)(& req->context), 1U, tmp___4, 26U, (u32 )tmp___3);
#line 854
  tmp___5 = eq_delay_to_mult((u32 )eq_delay);
#line 854
  tmp___6 = amap_mask(10U);
#line 854
  amap_set((void *)(& req->context), 2U, tmp___6, 13U, tmp___5);
#line 856
  swap_dws((void *)(& req->context), 16);
#line 858
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 860
  status = be_mbox_notify_wait(adapter);
#line 861
  if (status == 0) {
#line 862
    tmp___7 = embedded_payload(wrb);
#line 862
    resp = (struct be_cmd_resp_eq_create *)tmp___7;
#line 863
    eq->id = resp->eq_id;
#line 864
    eq->created = 1;
  } else {

  }
#line 867
  ldv_mutex_unlock_21(& adapter->mbox_lock);
#line 868
  return (status);
}
}
#line 872 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mac_query *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_mac_query *resp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 879
  spin_lock_bh(& adapter->mcc_lock);
#line 881
  wrb = wrb_from_mccq(adapter);
#line 882
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 883
    status = -16;
#line 884
    goto err;
  } else {

  }
#line 886
  tmp = embedded_payload(wrb);
#line 886
  req = (struct be_cmd_req_mac_query *)tmp;
#line 888
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 1, 24, wrb, 0);
#line 890
  req->type = 1U;
#line 891
  if ((int )permanent) {
#line 892
    req->permanent = 1U;
  } else {
#line 894
    req->if_id = (unsigned short )if_handle;
#line 895
    req->pmac_id = pmac_id;
#line 896
    req->permanent = 0U;
  }
#line 899
  status = be_mcc_notify_wait(adapter);
#line 900
  if (status == 0) {
#line 901
    tmp___0 = embedded_payload(wrb);
#line 901
    resp = (struct be_cmd_resp_mac_query *)tmp___0;
#line 902
    __len = 6UL;
#line 902
    if (__len > 63UL) {
#line 902
      __ret = __memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr), __len);
    } else {
#line 902
      __ret = __builtin_memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr),
                               __len);
    }
  } else {

  }
  err: 
#line 906
  spin_unlock_bh(& adapter->mcc_lock);
#line 907
  return (status);
}
}
#line 911 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_add *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  struct be_cmd_resp_pmac_add *resp ;
  void *tmp___0 ;

  {
#line 918
  spin_lock_bh(& adapter->mcc_lock);
#line 920
  wrb = wrb_from_mccq(adapter);
#line 921
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 922
    status = -16;
#line 923
    goto err;
  } else {

  }
#line 925
  tmp = embedded_payload(wrb);
#line 925
  req = (struct be_cmd_req_pmac_add *)tmp;
#line 927
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 59, 28, wrb, 0);
#line 930
  req->hdr.domain = (u8 )domain;
#line 931
  req->if_id = if_id;
#line 932
  __len = 6UL;
#line 932
  if (__len > 63UL) {
#line 932
    __ret = __memcpy((void *)(& req->mac_address), (void const   *)mac_addr, __len);
  } else {
#line 932
    __ret = __builtin_memcpy((void *)(& req->mac_address), (void const   *)mac_addr,
                             __len);
  }
#line 934
  status = be_mcc_notify_wait(adapter);
#line 935
  if (status == 0) {
#line 936
    tmp___0 = embedded_payload(wrb);
#line 936
    resp = (struct be_cmd_resp_pmac_add *)tmp___0;
#line 937
    *pmac_id = resp->pmac_id;
  } else {

  }
  err: 
#line 941
  spin_unlock_bh(& adapter->mcc_lock);
#line 943
  if (status == 5) {
#line 944
    status = -1;
  } else {

  }
#line 946
  return (status);
}
}
#line 950 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_del *req ;
  int status ;
  void *tmp ;

  {
#line 956
  if (pmac_id == -1) {
#line 957
    return (0);
  } else {

  }
#line 959
  spin_lock_bh(& adapter->mcc_lock);
#line 961
  wrb = wrb_from_mccq(adapter);
#line 962
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 963
    status = -16;
#line 964
    goto err;
  } else {

  }
#line 966
  tmp = embedded_payload(wrb);
#line 966
  req = (struct be_cmd_req_pmac_del *)tmp;
#line 968
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 60, 24, wrb, 0);
#line 971
  req->hdr.domain = (u8 )dom;
#line 972
  req->if_id = if_id;
#line 973
  req->pmac_id = (unsigned int )pmac_id;
#line 975
  status = be_mcc_notify_wait(adapter);
  err: 
#line 978
  spin_unlock_bh(& adapter->mcc_lock);
#line 979
  return (status);
}
}
#line 983 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cq_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  int tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___14 ;

  {
#line 988
  q_mem = & cq->dma_mem;
#line 992
  tmp = ldv_mutex_lock_interruptible_22(& adapter->mbox_lock);
#line 992
  if (tmp != 0) {
#line 993
    return (-1);
  } else {

  }
#line 995
  wrb = wrb_from_mbox(adapter);
#line 996
  tmp___0 = embedded_payload(wrb);
#line 996
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 997
  ctxt = (void *)(& req->context);
#line 999
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 12, 100, wrb, 0);
#line 1002
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1004
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1005
    tmp___1 = amap_mask(2U);
#line 1005
    amap_set(ctxt, 0U, tmp___1, 12U, (u32 )coalesce_wm);
#line 1007
    tmp___2 = amap_mask(1U);
#line 1007
    amap_set(ctxt, 0U, tmp___2, 14U, (u32 )no_delay);
#line 1009
    tmp___3 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1009
    tmp___4 = amap_mask(2U);
#line 1009
    amap_set(ctxt, 0U, tmp___4, 27U, (u32 )tmp___3);
#line 1011
    tmp___5 = amap_mask(1U);
#line 1011
    amap_set(ctxt, 0U, tmp___5, 29U, 1U);
#line 1012
    tmp___6 = amap_mask(1U);
#line 1012
    amap_set(ctxt, 0U, tmp___6, 31U, 1U);
#line 1013
    tmp___7 = amap_mask(8U);
#line 1013
    amap_set(ctxt, 1U, tmp___7, 22U, (u32 )eq->id);
  } else {
#line 1015
    req->hdr.version = 2U;
#line 1016
    req->page_size = 1U;
#line 1017
    tmp___8 = amap_mask(1U);
#line 1017
    amap_set(ctxt, 0U, tmp___8, 14U, (u32 )no_delay);
#line 1019
    tmp___9 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1019
    tmp___10 = amap_mask(2U);
#line 1019
    amap_set(ctxt, 0U, tmp___10, 27U, (u32 )tmp___9);
#line 1021
    tmp___11 = amap_mask(1U);
#line 1021
    amap_set(ctxt, 0U, tmp___11, 29U, 1U);
#line 1022
    tmp___12 = amap_mask(1U);
#line 1022
    amap_set(ctxt, 0U, tmp___12, 31U, 1U);
#line 1024
    tmp___13 = amap_mask(16U);
#line 1024
    amap_set(ctxt, 1U, tmp___13, 0U, (u32 )eq->id);
  }
#line 1028
  swap_dws(ctxt, 16);
#line 1030
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1032
  status = be_mbox_notify_wait(adapter);
#line 1033
  if (status == 0) {
#line 1034
    tmp___14 = embedded_payload(wrb);
#line 1034
    resp = (struct be_cmd_resp_cq_create *)tmp___14;
#line 1035
    cq->id = resp->cq_id;
#line 1036
    cq->created = 1;
  } else {

  }
#line 1039
  ldv_mutex_unlock_23(& adapter->mbox_lock);
#line 1041
  return (status);
}
}
#line 1044 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
#line 1046
  tmp = fls(q_len);
#line 1046
  len_encoded = (u32 )tmp;
#line 1047
  if (len_encoded == 16U) {
#line 1048
    len_encoded = 0U;
  } else {

  }
#line 1049
  return (len_encoded);
}
}
#line 1052 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_mccq_ext_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                           struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_ext_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___10 ;

  {
#line 1058
  q_mem = & mccq->dma_mem;
#line 1062
  tmp = ldv_mutex_lock_interruptible_24(& adapter->mbox_lock);
#line 1062
  if (tmp != 0) {
#line 1063
    return (-1);
  } else {

  }
#line 1065
  wrb = wrb_from_mbox(adapter);
#line 1066
  tmp___0 = embedded_payload(wrb);
#line 1066
  req = (struct be_cmd_req_mcc_ext_create *)tmp___0;
#line 1067
  ctxt = (void *)(& req->context);
#line 1069
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 90, 104, wrb, 0);
#line 1072
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1073
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1074
    req->hdr.version = 1U;
#line 1075
    req->cq_id = cq->id;
#line 1077
    tmp___1 = be_encoded_q_len((int )mccq->len);
#line 1077
    tmp___2 = amap_mask(4U);
#line 1077
    amap_set(ctxt, 0U, tmp___2, 16U, tmp___1);
#line 1079
    tmp___3 = amap_mask(1U);
#line 1079
    amap_set(ctxt, 1U, tmp___3, 31U, 1U);
#line 1080
    tmp___4 = amap_mask(16U);
#line 1080
    amap_set(ctxt, 0U, tmp___4, 0U, (u32 )cq->id);
#line 1082
    tmp___5 = amap_mask(1U);
#line 1082
    amap_set(ctxt, 2U, tmp___5, 0U, 1U);
  } else {
#line 1086
    tmp___6 = amap_mask(1U);
#line 1086
    amap_set(ctxt, 1U, tmp___6, 31U, 1U);
#line 1087
    tmp___7 = be_encoded_q_len((int )mccq->len);
#line 1087
    tmp___8 = amap_mask(4U);
#line 1087
    amap_set(ctxt, 0U, tmp___8, 16U, tmp___7);
#line 1089
    tmp___9 = amap_mask(10U);
#line 1089
    amap_set(ctxt, 0U, tmp___9, 22U, (u32 )cq->id);
  }
#line 1093
  req->async_event_bitmap[0] = 34U;
#line 1094
  req->async_event_bitmap[0] = req->async_event_bitmap[0] | 64U;
#line 1095
  swap_dws(ctxt, 16);
#line 1097
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1099
  status = be_mbox_notify_wait(adapter);
#line 1100
  if (status == 0) {
#line 1101
    tmp___10 = embedded_payload(wrb);
#line 1101
    resp = (struct be_cmd_resp_mcc_create *)tmp___10;
#line 1102
    mccq->id = resp->id;
#line 1103
    mccq->created = 1;
  } else {

  }
#line 1105
  ldv_mutex_unlock_25(& adapter->mbox_lock);
#line 1107
  return (status);
}
}
#line 1110 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_mccq_org_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                           struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
#line 1116
  q_mem = & mccq->dma_mem;
#line 1120
  tmp = ldv_mutex_lock_interruptible_26(& adapter->mbox_lock);
#line 1120
  if (tmp != 0) {
#line 1121
    return (-1);
  } else {

  }
#line 1123
  wrb = wrb_from_mbox(adapter);
#line 1124
  tmp___0 = embedded_payload(wrb);
#line 1124
  req = (struct be_cmd_req_mcc_create *)tmp___0;
#line 1125
  ctxt = (void *)(& req->context);
#line 1127
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 21, 100, wrb, 0);
#line 1130
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1132
  tmp___1 = amap_mask(1U);
#line 1132
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1133
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1133
  tmp___3 = amap_mask(4U);
#line 1133
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1135
  tmp___4 = amap_mask(10U);
#line 1135
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1137
  swap_dws(ctxt, 16);
#line 1139
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1141
  status = be_mbox_notify_wait(adapter);
#line 1142
  if (status == 0) {
#line 1143
    tmp___5 = embedded_payload(wrb);
#line 1143
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1144
    mccq->id = resp->id;
#line 1145
    mccq->created = 1;
  } else {

  }
#line 1148
  ldv_mutex_unlock_27(& adapter->mbox_lock);
#line 1149
  return (status);
}
}
#line 1152 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) 
{ 
  int status ;

  {
#line 1158
  status = be_cmd_mccq_ext_create(adapter, mccq, cq);
#line 1159
  if (status != 0 && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 1160
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Upgrade to F/W ver 2.102.235.0 or newer to avoid conflicting priorities between NIC and FCoE traffic");
#line 1163
    status = be_cmd_mccq_org_create(adapter, mccq, cq);
  } else {

  }
#line 1165
  return (status);
}
}
#line 1168 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eth_tx_create *req ;
  struct be_queue_info *txq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  void *tmp ;
  u32 tmp___0 ;
  struct be_cmd_resp_eth_tx_create *resp ;
  void *tmp___1 ;

  {
#line 1172
  txq = & txo->q;
#line 1173
  cq = & txo->cq;
#line 1174
  q_mem = & txq->dma_mem;
#line 1175
  ver = 0;
#line 1177
  spin_lock_bh(& adapter->mcc_lock);
#line 1179
  wrb = wrb_from_mccq(adapter);
#line 1180
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1181
    status = -16;
#line 1182
    goto err;
  } else {

  }
#line 1185
  tmp = embedded_payload(wrb);
#line 1185
  req = (struct be_cmd_req_eth_tx_create *)tmp;
#line 1187
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 7, 148, wrb, 0);
#line 1190
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1191
    req->hdr.version = 1U;
#line 1192
    req->if_id = (unsigned short )adapter->if_handle;
  } else
#line 1193
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1194
    if ((adapter->function_caps & 64U) != 0U) {
#line 1195
      req->hdr.version = 2U;
    } else {

    }
  } else {
#line 1197
    req->hdr.version = 2U;
  }
#line 1200
  req->num_pages = (u8 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1201
  req->ulp_num = 1U;
#line 1202
  req->type = 2U;
#line 1203
  req->cq_id = cq->id;
#line 1204
  tmp___0 = be_encoded_q_len((int )txq->len);
#line 1204
  req->queue_size = (u8 )tmp___0;
#line 1205
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1207
  ver = (int )req->hdr.version;
#line 1209
  status = be_mcc_notify_wait(adapter);
#line 1210
  if (status == 0) {
#line 1211
    tmp___1 = embedded_payload(wrb);
#line 1211
    resp = (struct be_cmd_resp_eth_tx_create *)tmp___1;
#line 1212
    txq->id = resp->cid;
#line 1213
    if (ver == 2) {
#line 1214
      txo->db_offset = resp->db_offset;
    } else {
#line 1216
      txo->db_offset = 96U;
    }
#line 1217
    txq->created = 1;
  } else {

  }
  err: 
#line 1221
  spin_unlock_bh(& adapter->mcc_lock);
#line 1223
  return (status);
}
}
#line 1227 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eth_rx_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  void *tmp ;
  int tmp___0 ;
  struct be_cmd_resp_eth_rx_create *resp ;
  void *tmp___1 ;

  {
#line 1233
  q_mem = & rxq->dma_mem;
#line 1236
  spin_lock_bh(& adapter->mcc_lock);
#line 1238
  wrb = wrb_from_mccq(adapter);
#line 1239
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1240
    status = -16;
#line 1241
    goto err;
  } else {

  }
#line 1243
  tmp = embedded_payload(wrb);
#line 1243
  req = (struct be_cmd_req_eth_rx_create *)tmp;
#line 1245
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 8, 48, wrb, 0);
#line 1248
  req->cq_id = cq_id;
#line 1249
  tmp___0 = fls((int )frag_size);
#line 1249
  req->frag_size = (unsigned int )((u8 )tmp___0) + 255U;
#line 1250
  req->num_pages = 2U;
#line 1251
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 2U, q_mem);
#line 1252
  req->interface_id = if_id;
#line 1253
  req->max_frame_size = 9018U;
#line 1254
  req->rss_queue = rss;
#line 1256
  status = be_mcc_notify_wait(adapter);
#line 1257
  if (status == 0) {
#line 1258
    tmp___1 = embedded_payload(wrb);
#line 1258
    resp = (struct be_cmd_resp_eth_rx_create *)tmp___1;
#line 1259
    rxq->id = resp->id;
#line 1260
    rxq->created = 1;
#line 1261
    *rss_id = resp->rss_id;
  } else {

  }
  err: 
#line 1265
  spin_unlock_bh(& adapter->mcc_lock);
#line 1266
  return (status);
}
}
#line 1272 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1277
  subsys = 0U;
#line 1277
  opcode = 0U;
#line 1280
  tmp = ldv_mutex_lock_interruptible_28(& adapter->mbox_lock);
#line 1280
  if (tmp != 0) {
#line 1281
    return (-1);
  } else {

  }
#line 1283
  wrb = wrb_from_mbox(adapter);
#line 1284
  tmp___0 = embedded_payload(wrb);
#line 1284
  req = (struct be_cmd_req_q_destroy *)tmp___0;
#line 1286
  switch (queue_type) {
  case 1: 
#line 1288
  subsys = 1U;
#line 1289
  opcode = 55U;
#line 1290
  goto ldv_51688;
  case 2: 
#line 1292
  subsys = 1U;
#line 1293
  opcode = 54U;
#line 1294
  goto ldv_51688;
  case 3: 
#line 1296
  subsys = 3U;
#line 1297
  opcode = 9U;
#line 1298
  goto ldv_51688;
  case 4: 
#line 1300
  subsys = 3U;
#line 1301
  opcode = 10U;
#line 1302
  goto ldv_51688;
  case 5: 
#line 1304
  subsys = 1U;
#line 1305
  opcode = 53U;
#line 1306
  goto ldv_51688;
  default: 
#line 1308
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"),
                       "i" (1308), "i" (12UL));
  ldv_51694: ;
#line 1308
  goto ldv_51694;
  }
  ldv_51688: 
#line 1311
  be_wrb_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20, wrb, 0);
#line 1313
  req->id = q->id;
#line 1315
  status = be_mbox_notify_wait(adapter);
#line 1316
  q->created = 0;
#line 1318
  ldv_mutex_unlock_29(& adapter->mbox_lock);
#line 1319
  return (status);
}
}
#line 1323 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1329
  spin_lock_bh(& adapter->mcc_lock);
#line 1331
  wrb = wrb_from_mccq(adapter);
#line 1332
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1333
    status = -16;
#line 1334
    goto err;
  } else {

  }
#line 1336
  tmp = embedded_payload(wrb);
#line 1336
  req = (struct be_cmd_req_q_destroy *)tmp;
#line 1338
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 10, 20, wrb, 0);
#line 1340
  req->id = q->id;
#line 1342
  status = be_mcc_notify_wait(adapter);
#line 1343
  q->created = 0;
  err: 
#line 1346
  spin_unlock_bh(& adapter->mcc_lock);
#line 1347
  return (status);
}
}
#line 1353 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_if_create *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_if_create *resp ;
  void *tmp___0 ;

  {
#line 1360
  spin_lock_bh(& adapter->mcc_lock);
#line 1362
  wrb = wrb_from_mccq(adapter);
#line 1363
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1364
    status = -16;
#line 1365
    goto err;
  } else {

  }
#line 1367
  tmp = embedded_payload(wrb);
#line 1367
  req = (struct be_cmd_req_if_create *)tmp;
#line 1369
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 50, 40, wrb, 0);
#line 1371
  req->hdr.domain = (u8 )domain;
#line 1372
  req->capability_flags = cap_flags;
#line 1373
  req->enable_flags = en_flags;
#line 1375
  req->pmac_invalid = 1U;
#line 1377
  status = be_mcc_notify_wait(adapter);
#line 1378
  if (status == 0) {
#line 1379
    tmp___0 = embedded_payload(wrb);
#line 1379
    resp = (struct be_cmd_resp_if_create *)tmp___0;
#line 1380
    *if_handle = resp->interface_id;
  } else {

  }
  err: 
#line 1384
  spin_unlock_bh(& adapter->mcc_lock);
#line 1385
  return (status);
}
}
#line 1389 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_if_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1395
  if (interface_id == -1) {
#line 1396
    return (0);
  } else {

  }
#line 1398
  spin_lock_bh(& adapter->mcc_lock);
#line 1400
  wrb = wrb_from_mccq(adapter);
#line 1401
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1402
    status = -16;
#line 1403
    goto err;
  } else {

  }
#line 1405
  tmp = embedded_payload(wrb);
#line 1405
  req = (struct be_cmd_req_if_destroy *)tmp;
#line 1407
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 51, 20, wrb, 0);
#line 1409
  req->hdr.domain = (u8 )domain;
#line 1410
  req->interface_id = (unsigned int )interface_id;
#line 1412
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1414
  spin_unlock_bh(& adapter->mcc_lock);
#line 1415
  return (status);
}
}
#line 1422 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  int status ;

  {
#line 1426
  status = 0;
#line 1428
  spin_lock_bh(& adapter->mcc_lock);
#line 1430
  wrb = wrb_from_mccq(adapter);
#line 1431
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1432
    status = -16;
#line 1433
    goto err;
  } else {

  }
#line 1435
  hdr = (struct be_cmd_req_hdr *)nonemb_cmd->va;
#line 1437
  be_wrb_cmd_hdr_prepare(hdr, 3, 4, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1441
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 1442
    hdr->version = 1U;
  } else {

  }
#line 1444
  be_mcc_notify(adapter);
#line 1445
  adapter->stats_cmd_sent = 1;
  err: 
#line 1448
  spin_unlock_bh(& adapter->mcc_lock);
#line 1449
  return (status);
}
}
#line 1453 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_pport_stats *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1459
  status = 0;
#line 1461
  tmp = be_cmd_allowed(adapter, 18, 3);
#line 1461
  if (tmp) {
#line 1461
    tmp___0 = 0;
  } else {
#line 1461
    tmp___0 = 1;
  }
#line 1461
  if (tmp___0) {
#line 1463
    return (-1);
  } else {

  }
#line 1465
  spin_lock_bh(& adapter->mcc_lock);
#line 1467
  wrb = wrb_from_mccq(adapter);
#line 1468
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1469
    status = -16;
#line 1470
    goto err;
  } else {

  }
#line 1472
  req = (struct lancer_cmd_req_pport_stats *)nonemb_cmd->va;
#line 1474
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 18, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1478
  req->cmd_params.params.pport_num = (unsigned short )adapter->hba_port_num;
#line 1479
  req->cmd_params.params.reset_stats = 0U;
#line 1481
  be_mcc_notify(adapter);
#line 1482
  adapter->stats_cmd_sent = 1;
  err: 
#line 1485
  spin_unlock_bh(& adapter->mcc_lock);
#line 1486
  return (status);
}
}
#line 1489 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static int be_mac_to_link_speed(int mac_speed ) 
{ 


  {
#line 1491
  switch (mac_speed) {
  case 0: ;
#line 1493
  return (0);
  case 1: ;
#line 1495
  return (10);
  case 2: ;
#line 1497
  return (100);
  case 3: ;
#line 1499
  return (1000);
  case 4: ;
#line 1501
  return (10000);
  }
#line 1503
  return (0);
}
}
#line 1509 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_link_status *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_link_status *resp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1516
  spin_lock_bh(& adapter->mcc_lock);
#line 1518
  if ((unsigned long )link_status != (unsigned long )((u8 *)0)) {
#line 1519
    *link_status = 0U;
  } else {

  }
#line 1521
  wrb = wrb_from_mccq(adapter);
#line 1522
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1523
    status = -16;
#line 1524
    goto err;
  } else {

  }
#line 1526
  tmp = embedded_payload(wrb);
#line 1526
  req = (struct be_cmd_req_link_status *)tmp;
#line 1528
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 5, 20, wrb, 0);
#line 1532
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 1533
    req->hdr.version = 1U;
  } else {

  }
#line 1535
  req->hdr.domain = (u8 )dom;
#line 1537
  status = be_mcc_notify_wait(adapter);
#line 1538
  if (status == 0) {
#line 1539
    tmp___0 = embedded_payload(wrb);
#line 1539
    resp = (struct be_cmd_resp_link_status *)tmp___0;
#line 1540
    if ((unsigned long )link_speed != (unsigned long )((u16 *)0)) {
#line 1541
      if ((unsigned int )resp->link_speed != 0U) {
#line 1541
        *link_speed = (unsigned int )resp->link_speed * 10U;
      } else {
#line 1541
        tmp___1 = be_mac_to_link_speed((int )resp->mac_speed);
#line 1541
        *link_speed = (u16 )tmp___1;
      }
#line 1545
      if ((unsigned int )resp->logical_link_status == 0U) {
#line 1546
        *link_speed = 0U;
      } else {

      }
    } else {

    }
#line 1548
    if ((unsigned long )link_status != (unsigned long )((u8 *)0)) {
#line 1549
      *link_status = resp->logical_link_status;
    } else {

    }
  } else {

  }
  err: 
#line 1553
  spin_unlock_bh(& adapter->mcc_lock);
#line 1554
  return (status);
}
}
#line 1558 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_die_temperature(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_cntl_addnl_attribs *req ;
  int status ;
  void *tmp ;

  {
#line 1564
  spin_lock_bh(& adapter->mcc_lock);
#line 1566
  wrb = wrb_from_mccq(adapter);
#line 1567
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1568
    status = -16;
#line 1569
    goto err;
  } else {

  }
#line 1571
  tmp = embedded_payload(wrb);
#line 1571
  req = (struct be_cmd_req_get_cntl_addnl_attribs *)tmp;
#line 1573
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 121, 24, wrb, 0);
#line 1577
  be_mcc_notify(adapter);
  err: 
#line 1580
  spin_unlock_bh(& adapter->mcc_lock);
#line 1581
  return (status);
}
}
#line 1585 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fat *resp ;
  void *tmp___0 ;

  {
#line 1591
  spin_lock_bh(& adapter->mcc_lock);
#line 1593
  wrb = wrb_from_mccq(adapter);
#line 1594
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1595
    status = -16;
#line 1596
    goto err;
  } else {

  }
#line 1598
  tmp = embedded_payload(wrb);
#line 1598
  req = (struct be_cmd_req_get_fat *)tmp;
#line 1600
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, 36, wrb, 0);
#line 1602
  req->fat_operation = 1U;
#line 1603
  status = be_mcc_notify_wait(adapter);
#line 1604
  if (status == 0) {
#line 1605
    tmp___0 = embedded_payload(wrb);
#line 1605
    resp = (struct be_cmd_resp_get_fat *)tmp___0;
#line 1606
    if ((unsigned long )log_size != (unsigned long )((u32 *)0) && resp->log_size != 0U) {
#line 1607
      *log_size = resp->log_size - 4U;
    } else {

    }
  } else {

  }
  err: 
#line 1611
  spin_unlock_bh(& adapter->mcc_lock);
#line 1612
  return (status);
}
}
#line 1615 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) 
{ 
  struct be_dma_mem get_fat_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  u32 offset ;
  u32 total_size ;
  u32 buf_size ;
  u32 log_offset ;
  u32 payload_len ;
  int status ;
  u32 _min1 ;
  unsigned int _min2 ;
  struct be_cmd_resp_get_fat *resp ;
  size_t __len ;
  void *__ret ;

  {
#line 1620
  offset = 0U;
#line 1621
  log_offset = 4U;
#line 1624
  if (buf_len == 0U) {
#line 1625
    return;
  } else {

  }
#line 1627
  total_size = buf_len;
#line 1629
  get_fat_cmd.size = 61476U;
#line 1630
  get_fat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_fat_cmd.size,
                                        & get_fat_cmd.dma);
#line 1633
  if ((unsigned long )get_fat_cmd.va == (unsigned long )((void *)0)) {
#line 1634
    status = -12;
#line 1635
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while retrieving FAT data\n");
#line 1637
    return;
  } else {

  }
#line 1640
  spin_lock_bh(& adapter->mcc_lock);
#line 1642
  goto ldv_51798;
  ldv_51797: 
#line 1643
  _min1 = total_size;
#line 1643
  _min2 = 61440U;
#line 1643
  buf_size = _min1 < _min2 ? _min1 : _min2;
#line 1644
  total_size = total_size - buf_size;
#line 1646
  wrb = wrb_from_mccq(adapter);
#line 1647
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1648
    status = -16;
#line 1649
    goto err;
  } else {

  }
#line 1651
  req = (struct be_cmd_req_get_fat *)get_fat_cmd.va;
#line 1653
  payload_len = buf_size + 36U;
#line 1654
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, (int )payload_len, wrb, & get_fat_cmd);
#line 1658
  req->fat_operation = 0U;
#line 1659
  req->read_log_offset = log_offset;
#line 1660
  req->read_log_length = buf_size;
#line 1661
  req->data_buffer_size = buf_size;
#line 1663
  status = be_mcc_notify_wait(adapter);
#line 1664
  if (status == 0) {
#line 1665
    resp = (struct be_cmd_resp_get_fat *)get_fat_cmd.va;
#line 1666
    __len = (size_t )resp->read_log_length;
#line 1666
    __ret = __builtin_memcpy(buf + (unsigned long )offset, (void const   *)(& resp->data_buffer),
                             __len);
  } else {
#line 1670
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FAT Table Retrieve error\n");
#line 1671
    goto err;
  }
#line 1673
  offset = offset + buf_size;
#line 1674
  log_offset = log_offset + buf_size;
  ldv_51798: ;
#line 1642
  if (total_size != 0U) {
#line 1644
    goto ldv_51797;
  } else {

  }

  err: 
#line 1677
  pci_free_consistent(adapter->pdev, (size_t )get_fat_cmd.size, get_fat_cmd.va, get_fat_cmd.dma);
#line 1680
  spin_unlock_bh(& adapter->mcc_lock);
#line 1681
  return;
}
}
#line 1684 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fw_version *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fw_version *resp ;
  void *tmp___0 ;

  {
#line 1691
  spin_lock_bh(& adapter->mcc_lock);
#line 1693
  wrb = wrb_from_mccq(adapter);
#line 1694
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1695
    status = -16;
#line 1696
    goto err;
  } else {

  }
#line 1699
  tmp = embedded_payload(wrb);
#line 1699
  req = (struct be_cmd_req_get_fw_version *)tmp;
#line 1701
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 35, 80, wrb, 0);
#line 1703
  status = be_mcc_notify_wait(adapter);
#line 1704
  if (status == 0) {
#line 1705
    tmp___0 = embedded_payload(wrb);
#line 1705
    resp = (struct be_cmd_resp_get_fw_version *)tmp___0;
#line 1706
    strcpy(fw_ver, (char const   *)(& resp->firmware_version_string));
#line 1707
    if ((unsigned long )fw_on_flash != (unsigned long )((char *)0)) {
#line 1708
      strcpy(fw_on_flash, (char const   *)(& resp->fw_on_flash_version_string));
    } else {

    }
  } else {

  }
  err: 
#line 1711
  spin_unlock_bh(& adapter->mcc_lock);
#line 1712
  return (status);
}
}
#line 1718 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_modify_eqd(struct be_adapter *adapter , u32 eq_id , u32 eqd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  int status ;
  void *tmp ;

  {
#line 1722
  status = 0;
#line 1724
  spin_lock_bh(& adapter->mcc_lock);
#line 1726
  wrb = wrb_from_mccq(adapter);
#line 1727
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1728
    status = -16;
#line 1729
    goto err;
  } else {

  }
#line 1731
  tmp = embedded_payload(wrb);
#line 1731
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 1733
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 41, 116, wrb, 0);
#line 1736
  req->num_eq = 1U;
#line 1737
  req->delay[0].eq_id = eq_id;
#line 1738
  req->delay[0].phase = 0U;
#line 1739
  req->delay[0].delay_multiplier = eqd;
#line 1741
  be_mcc_notify(adapter);
  err: 
#line 1744
  spin_unlock_bh(& adapter->mcc_lock);
#line 1745
  return (status);
}
}
#line 1749 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , bool untagged , bool promiscuous ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_vlan_config *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1756
  spin_lock_bh(& adapter->mcc_lock);
#line 1758
  wrb = wrb_from_mccq(adapter);
#line 1759
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1760
    status = -16;
#line 1761
    goto err;
  } else {

  }
#line 1763
  tmp = embedded_payload(wrb);
#line 1763
  req = (struct be_cmd_req_vlan_config *)tmp;
#line 1765
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 4, 148, wrb, 0);
#line 1768
  req->interface_id = (u8 )if_id;
#line 1769
  req->promiscuous = (u8 )promiscuous;
#line 1770
  req->untagged = (u8 )untagged;
#line 1771
  req->num_vlan = (u8 )num;
#line 1772
  if (! promiscuous) {
#line 1773
    __len = (unsigned long )req->num_vlan * 2UL;
#line 1773
    __ret = __builtin_memcpy((void *)(& req->normal_vlan), (void const   *)vtag_array,
                             __len);
  } else {

  }
#line 1777
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1780
  spin_unlock_bh(& adapter->mcc_lock);
#line 1781
  return (status);
}
}
#line 1784 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_dma_mem *mem ;
  struct be_cmd_req_rx_filter *req ;
  int status ;
  u32 tmp ;
  struct netdev_hw_addr *ha ;
  int i ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1787
  mem = & adapter->rx_filter;
#line 1788
  req = (struct be_cmd_req_rx_filter *)mem->va;
#line 1791
  spin_lock_bh(& adapter->mcc_lock);
#line 1793
  wrb = wrb_from_mccq(adapter);
#line 1794
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1795
    status = -16;
#line 1796
    goto err;
  } else {

  }
#line 1798
  memset((void *)req, 0, 424UL);
#line 1799
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 34, 424, wrb, mem);
#line 1803
  req->if_id = (unsigned int )adapter->if_handle;
#line 1804
  if ((flags & 256U) != 0U) {
#line 1805
    req->if_flags_mask = 648U;
#line 1808
    if (value == 1U) {
#line 1809
      req->if_flags = 648U;
    } else {

    }
  } else
#line 1812
  if ((flags & 512U) != 0U) {
#line 1813
    tmp = 512U;
#line 1813
    req->if_flags = tmp;
#line 1813
    req->if_flags_mask = tmp;
  } else {
#line 1817
    i = 0;
#line 1819
    tmp___0 = 4096U;
#line 1819
    req->if_flags = tmp___0;
#line 1819
    req->if_flags_mask = tmp___0;
#line 1825
    req->if_flags_mask = req->if_flags_mask | (adapter->if_cap_flags & 512U);
#line 1829
    req->mcast_num = (unsigned int )(adapter->netdev)->mc.count;
#line 1830
    __mptr = (struct list_head  const  *)(adapter->netdev)->mc.list.next;
#line 1830
    ha = (struct netdev_hw_addr *)__mptr;
#line 1830
    goto ldv_51854;
    ldv_51853: 
#line 1831
    __len = 6UL;
#line 1831
    if (__len > 63UL) {
#line 1831
      tmp___1 = i;
#line 1831
      i = i + 1;
#line 1831
      __ret = __memcpy((void *)(& req->mcast_mac[tmp___1].byte), (void const   *)(& ha->addr),
                       __len);
    } else {
#line 1831
      tmp___2 = i;
#line 1831
      i = i + 1;
#line 1831
      __ret = __builtin_memcpy((void *)(& req->mcast_mac[tmp___2].byte), (void const   *)(& ha->addr),
                               __len);
    }
#line 1830
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1830
    ha = (struct netdev_hw_addr *)__mptr___0;
    ldv_51854: ;
#line 1830
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->mc.list)) {
#line 1832
      goto ldv_51853;
    } else {

    }

  }
#line 1834
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1836
  spin_unlock_bh(& adapter->mcc_lock);
#line 1837
  return (status);
}
}
#line 1841 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1847
  tmp = be_cmd_allowed(adapter, 36, 1);
#line 1847
  if (tmp) {
#line 1847
    tmp___0 = 0;
  } else {
#line 1847
    tmp___0 = 1;
  }
#line 1847
  if (tmp___0) {
#line 1849
    return (-1);
  } else {

  }
#line 1851
  spin_lock_bh(& adapter->mcc_lock);
#line 1853
  wrb = wrb_from_mccq(adapter);
#line 1854
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1855
    status = -16;
#line 1856
    goto err;
  } else {

  }
#line 1858
  tmp___1 = embedded_payload(wrb);
#line 1858
  req = (struct be_cmd_req_set_flow_control *)tmp___1;
#line 1860
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 36, 20, wrb, 0);
#line 1863
  req->tx_flow_control = (unsigned short )tx_fc;
#line 1864
  req->rx_flow_control = (unsigned short )rx_fc;
#line 1866
  status = be_mcc_notify_wait(adapter);
  err: 
#line 1869
  spin_unlock_bh(& adapter->mcc_lock);
#line 1870
  return (status);
}
}
#line 1874 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct be_cmd_resp_get_flow_control *resp ;
  void *tmp___2 ;

  {
#line 1880
  tmp = be_cmd_allowed(adapter, 37, 1);
#line 1880
  if (tmp) {
#line 1880
    tmp___0 = 0;
  } else {
#line 1880
    tmp___0 = 1;
  }
#line 1880
  if (tmp___0) {
#line 1882
    return (-1);
  } else {

  }
#line 1884
  spin_lock_bh(& adapter->mcc_lock);
#line 1886
  wrb = wrb_from_mccq(adapter);
#line 1887
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1888
    status = -16;
#line 1889
    goto err;
  } else {

  }
#line 1891
  tmp___1 = embedded_payload(wrb);
#line 1891
  req = (struct be_cmd_req_get_flow_control *)tmp___1;
#line 1893
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 37, 20, wrb, 0);
#line 1896
  status = be_mcc_notify_wait(adapter);
#line 1897
  if (status == 0) {
#line 1898
    tmp___2 = embedded_payload(wrb);
#line 1898
    resp = (struct be_cmd_resp_get_flow_control *)tmp___2;
#line 1900
    *tx_fc = (u32 )resp->tx_flow_control;
#line 1901
    *rx_fc = (u32 )resp->rx_flow_control;
  } else {

  }
  err: 
#line 1905
  spin_unlock_bh(& adapter->mcc_lock);
#line 1906
  return (status);
}
}
#line 1910 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_query_fw_cfg *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_query_fw_cfg *resp ;
  void *tmp___1 ;

  {
#line 1917
  tmp = ldv_mutex_lock_interruptible_30(& adapter->mbox_lock);
#line 1917
  if (tmp != 0) {
#line 1918
    return (-1);
  } else {

  }
#line 1920
  wrb = wrb_from_mbox(adapter);
#line 1921
  tmp___0 = embedded_payload(wrb);
#line 1921
  req = (struct be_cmd_req_query_fw_cfg *)tmp___0;
#line 1923
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 58, 140, wrb, 0);
#line 1926
  status = be_mbox_notify_wait(adapter);
#line 1927
  if (status == 0) {
#line 1928
    tmp___1 = embedded_payload(wrb);
#line 1928
    resp = (struct be_cmd_resp_query_fw_cfg *)tmp___1;
#line 1929
    *port_num = resp->phys_port;
#line 1930
    *mode = resp->function_mode;
#line 1931
    *caps = resp->function_caps;
#line 1932
    *asic_rev = (unsigned int )((u16 )resp->asic_revision) & 255U;
  } else {

  }
#line 1935
  ldv_mutex_unlock_31(& adapter->mbox_lock);
#line 1936
  return (status);
}
}
#line 1940 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_reset_function(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1946
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1947
    status = lancer_wait_ready(adapter);
#line 1948
    if (status == 0) {
#line 1949
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 1951
      status = lancer_test_and_set_rdy_state(adapter);
    } else {

    }
#line 1953
    if (status != 0) {
#line 1954
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter in non recoverable error\n");
    } else {

    }
#line 1957
    return (status);
  } else {

  }
#line 1960
  tmp = ldv_mutex_lock_interruptible_32(& adapter->mbox_lock);
#line 1960
  if (tmp != 0) {
#line 1961
    return (-1);
  } else {

  }
#line 1963
  wrb = wrb_from_mbox(adapter);
#line 1964
  tmp___0 = embedded_payload(wrb);
#line 1964
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 1966
  be_wrb_cmd_hdr_prepare(req, 1, 61, 16, wrb, 0);
#line 1969
  status = be_mbox_notify_wait(adapter);
#line 1971
  ldv_mutex_unlock_33(& adapter->mbox_lock);
#line 1972
  return (status);
}
}
#line 1975 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_rss_config *req ;
  u32 myhash[10U] ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1980
  myhash[0] = 366231461U;
#line 1980
  myhash[1] = 624191578U;
#line 1980
  myhash[2] = 1602709818U;
#line 1980
  myhash[3] = 1449675086U;
#line 1980
  myhash[4] = 869231187U;
#line 1980
  myhash[5] = 942879942U;
#line 1980
  myhash[6] = 1991000663U;
#line 1980
  myhash[7] = 1504854706U;
#line 1980
  myhash[8] = 1051212802U;
#line 1980
  myhash[9] = 1242628868U;
#line 1985
  tmp = ldv_mutex_lock_interruptible_34(& adapter->mbox_lock);
#line 1985
  if (tmp != 0) {
#line 1986
    return (-1);
  } else {

  }
#line 1988
  wrb = wrb_from_mbox(adapter);
#line 1989
  tmp___0 = embedded_payload(wrb);
#line 1989
  req = (struct be_cmd_req_rss_config *)tmp___0;
#line 1991
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 1, 196, wrb, 0);
#line 1994
  req->if_id = (unsigned int )adapter->if_handle;
#line 1995
  req->enable_rss = (unsigned short )rss_hash_opts;
#line 1996
  tmp___1 = fls((int )table_size);
#line 1996
  req->cpu_table_size_log2 = (unsigned int )((unsigned short )tmp___1) - 1U;
#line 1998
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U)) {
#line 1999
    req->hdr.version = 1U;
  } else {

  }
#line 2001
  __len = (size_t )table_size;
#line 2001
  __ret = __builtin_memcpy((void *)(& req->cpu_table), (void const   *)rsstable, __len);
#line 2002
  __len___0 = 40UL;
#line 2002
  if (__len___0 > 63UL) {
#line 2002
    __ret___0 = __memcpy((void *)(& req->hash), (void const   *)(& myhash), __len___0);
  } else {
#line 2002
    __ret___0 = __builtin_memcpy((void *)(& req->hash), (void const   *)(& myhash),
                                 __len___0);
  }
#line 2003
  swap_dws((void *)(& req->hash), 40);
#line 2005
  status = be_mbox_notify_wait(adapter);
#line 2007
  ldv_mutex_unlock_35(& adapter->mbox_lock);
#line 2008
  return (status);
}
}
#line 2012 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_enable_disable_beacon *req ;
  int status ;
  void *tmp ;

  {
#line 2019
  spin_lock_bh(& adapter->mcc_lock);
#line 2021
  wrb = wrb_from_mccq(adapter);
#line 2022
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2023
    status = -16;
#line 2024
    goto err;
  } else {

  }
#line 2026
  tmp = embedded_payload(wrb);
#line 2026
  req = (struct be_cmd_req_enable_disable_beacon *)tmp;
#line 2028
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 69, 20, wrb, 0);
#line 2031
  req->port_num = port_num;
#line 2032
  req->beacon_state = state;
#line 2033
  req->beacon_duration = bcn;
#line 2034
  req->status_duration = sts;
#line 2036
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2039
  spin_unlock_bh(& adapter->mcc_lock);
#line 2040
  return (status);
}
}
#line 2044 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_beacon_state *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_beacon_state *resp ;
  void *tmp___0 ;

  {
#line 2050
  spin_lock_bh(& adapter->mcc_lock);
#line 2052
  wrb = wrb_from_mccq(adapter);
#line 2053
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2054
    status = -16;
#line 2055
    goto err;
  } else {

  }
#line 2057
  tmp = embedded_payload(wrb);
#line 2057
  req = (struct be_cmd_req_get_beacon_state *)tmp;
#line 2059
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 70, 20, wrb, 0);
#line 2062
  req->port_num = port_num;
#line 2064
  status = be_mcc_notify_wait(adapter);
#line 2065
  if (status == 0) {
#line 2066
    tmp___0 = embedded_payload(wrb);
#line 2066
    resp = (struct be_cmd_resp_get_beacon_state *)tmp___0;
#line 2068
    *state = (u32 )resp->beacon_state;
  } else {

  }
  err: 
#line 2072
  spin_unlock_bh(& adapter->mcc_lock);
#line 2073
  return (status);
}
}
#line 2076 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_write_object *req ;
  struct lancer_cmd_resp_write_object *resp ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;

  {
#line 2084
  ctxt = 0;
#line 2087
  spin_lock_bh(& adapter->mcc_lock);
#line 2088
  adapter->flash_status = 0U;
#line 2090
  wrb = wrb_from_mccq(adapter);
#line 2091
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2092
    status = -16;
#line 2093
    goto err_unlock;
  } else {

  }
#line 2096
  tmp = embedded_payload(wrb);
#line 2096
  req = (struct lancer_cmd_req_write_object *)tmp;
#line 2098
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 172, 144, wrb, 0);
#line 2103
  ctxt = (void *)(& req->context);
#line 2104
  tmp___0 = amap_mask(24U);
#line 2104
  amap_set(ctxt, 0U, tmp___0, 0U, data_size);
#line 2107
  if (data_size == 0U) {
#line 2108
    tmp___1 = amap_mask(1U);
#line 2108
    amap_set(ctxt, 0U, tmp___1, 31U, 1U);
  } else {
#line 2111
    tmp___2 = amap_mask(1U);
#line 2111
    amap_set(ctxt, 0U, tmp___2, 31U, 0U);
  }
#line 2114
  swap_dws(ctxt, 4);
#line 2115
  req->write_offset = data_offset;
#line 2116
  strcpy((char *)(& req->object_name), obj_name);
#line 2117
  req->descriptor_count = 1U;
#line 2118
  req->buf_len = data_size;
#line 2119
  req->addr_low = (unsigned int )cmd->dma + 144U;
#line 2122
  req->addr_high = (unsigned int )((cmd->dma + 144ULL) >> 32ULL);
#line 2125
  be_mcc_notify(adapter);
#line 2126
  spin_unlock_bh(& adapter->mcc_lock);
#line 2128
  tmp___3 = msecs_to_jiffies(60000U);
#line 2128
  tmp___4 = wait_for_completion_timeout(& adapter->flash_compl, tmp___3);
#line 2128
  if (tmp___4 == 0UL) {
#line 2130
    status = -1;
  } else {
#line 2132
    status = (int )adapter->flash_status;
  }
#line 2134
  tmp___5 = embedded_payload(wrb);
#line 2134
  resp = (struct lancer_cmd_resp_write_object *)tmp___5;
#line 2135
  if (status == 0) {
#line 2136
    *data_written = resp->actual_write_len;
#line 2137
    *change_status = resp->change_status;
  } else {
#line 2139
    *addn_status = resp->additional_status;
  }
#line 2142
  return (status);
  err_unlock: 
#line 2145
  spin_unlock_bh(& adapter->mcc_lock);
#line 2146
  return (status);
}
}
#line 2149 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_read_object *req ;
  struct lancer_cmd_resp_read_object *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2158
  spin_lock_bh(& adapter->mcc_lock);
#line 2160
  wrb = wrb_from_mccq(adapter);
#line 2161
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2162
    status = -16;
#line 2163
    goto err_unlock;
  } else {

  }
#line 2166
  tmp = embedded_payload(wrb);
#line 2166
  req = (struct lancer_cmd_req_read_object *)tmp;
#line 2168
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 171, 144, wrb, 0);
#line 2173
  req->desired_read_len = data_size;
#line 2174
  req->read_offset = data_offset;
#line 2175
  strcpy((char *)(& req->object_name), obj_name);
#line 2176
  req->descriptor_count = 1U;
#line 2177
  req->buf_len = data_size;
#line 2178
  req->addr_low = (unsigned int )cmd->dma;
#line 2179
  req->addr_high = (unsigned int )(cmd->dma >> 32ULL);
#line 2181
  status = be_mcc_notify_wait(adapter);
#line 2183
  tmp___0 = embedded_payload(wrb);
#line 2183
  resp = (struct lancer_cmd_resp_read_object *)tmp___0;
#line 2184
  if (status == 0) {
#line 2185
    *data_read = resp->actual_read_len;
#line 2186
    *eof = resp->eof;
  } else {
#line 2188
    *addn_status = resp->additional_status;
  }
  err_unlock: 
#line 2192
  spin_unlock_bh(& adapter->mcc_lock);
#line 2193
  return (status);
}
}
#line 2196 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_write_flashrom *req ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 2203
  spin_lock_bh(& adapter->mcc_lock);
#line 2204
  adapter->flash_status = 0U;
#line 2206
  wrb = wrb_from_mccq(adapter);
#line 2207
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2208
    status = -16;
#line 2209
    goto err_unlock;
  } else {

  }
#line 2211
  req = (struct be_cmd_write_flashrom *)cmd->va;
#line 2213
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 7, (int )cmd->size, wrb, cmd);
#line 2216
  req->params.op_type = flash_type;
#line 2217
  req->params.op_code = flash_opcode;
#line 2218
  req->params.data_buf_size = buf_size;
#line 2220
  be_mcc_notify(adapter);
#line 2221
  spin_unlock_bh(& adapter->mcc_lock);
#line 2223
  tmp = msecs_to_jiffies(40000U);
#line 2223
  tmp___0 = wait_for_completion_timeout(& adapter->flash_compl, tmp);
#line 2223
  if (tmp___0 == 0UL) {
#line 2225
    status = -1;
  } else {
#line 2227
    status = (int )adapter->flash_status;
  }
#line 2229
  return (status);
  err_unlock: 
#line 2232
  spin_unlock_bh(& adapter->mcc_lock);
#line 2233
  return (status);
}
}
#line 2236 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , int offset ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_read_flash_crc *req ;
  int status ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2243
  spin_lock_bh(& adapter->mcc_lock);
#line 2245
  wrb = wrb_from_mccq(adapter);
#line 2246
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2247
    status = -16;
#line 2248
    goto err;
  } else {

  }
#line 2250
  tmp = embedded_payload(wrb);
#line 2250
  req = (struct be_cmd_read_flash_crc *)tmp;
#line 2252
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 6, 40, wrb, 0);
#line 2256
  req->params.op_type = 1U;
#line 2257
  req->params.op_code = 4U;
#line 2258
  req->params.offset = (unsigned int )offset;
#line 2259
  req->params.data_buf_size = 4U;
#line 2261
  status = be_mcc_notify_wait(adapter);
#line 2262
  if (status == 0) {
#line 2263
    __len = 4UL;
#line 2263
    if (__len > 63UL) {
#line 2263
      __ret = __memcpy((void *)flashed_crc, (void const   *)(& req->crc), __len);
    } else {
#line 2263
      __ret = __builtin_memcpy((void *)flashed_crc, (void const   *)(& req->crc),
                               __len);
    }
  } else {

  }
  err: 
#line 2266
  spin_unlock_bh(& adapter->mcc_lock);
#line 2267
  return (status);
}
}
#line 2270 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config *req ;
  int status ;
  size_t __len ;
  void *__ret ;

  {
#line 2277
  spin_lock_bh(& adapter->mcc_lock);
#line 2279
  wrb = wrb_from_mccq(adapter);
#line 2280
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2281
    status = -16;
#line 2282
    goto err;
  } else {

  }
#line 2284
  req = (struct be_cmd_req_acpi_wol_magic_config *)nonemb_cmd->va;
#line 2286
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 604, wrb, nonemb_cmd);
#line 2289
  __len = 6UL;
#line 2289
  if (__len > 63UL) {
#line 2289
    __ret = __memcpy((void *)(& req->magic_mac), (void const   *)mac, __len);
  } else {
#line 2289
    __ret = __builtin_memcpy((void *)(& req->magic_mac), (void const   *)mac, __len);
  }
#line 2291
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2294
  spin_unlock_bh(& adapter->mcc_lock);
#line 2295
  return (status);
}
}
#line 2298 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_lmode *req ;
  int status ;
  void *tmp ;

  {
#line 2305
  spin_lock_bh(& adapter->mcc_lock);
#line 2307
  wrb = wrb_from_mccq(adapter);
#line 2308
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2309
    status = -16;
#line 2310
    goto err;
  } else {

  }
#line 2313
  tmp = embedded_payload(wrb);
#line 2313
  req = (struct be_cmd_req_set_lmode *)tmp;
#line 2315
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 19, 20, wrb, 0);
#line 2319
  req->src_port = port_num;
#line 2320
  req->dest_port = port_num;
#line 2321
  req->loopback_type = loopback_type;
#line 2322
  req->loopback_state = enable;
#line 2324
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2326
  spin_unlock_bh(& adapter->mcc_lock);
#line 2327
  return (status);
}
}
#line 2330 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_loopback_test *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_loopback_test *resp ;
  void *tmp___0 ;

  {
#line 2337
  spin_lock_bh(& adapter->mcc_lock);
#line 2339
  wrb = wrb_from_mccq(adapter);
#line 2340
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2341
    status = -16;
#line 2342
    goto err;
  } else {

  }
#line 2345
  tmp = embedded_payload(wrb);
#line 2345
  req = (struct be_cmd_req_loopback_test *)tmp;
#line 2347
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 18, 48, wrb, 0);
#line 2349
  req->hdr.timeout = 4U;
#line 2351
  req->pattern = pattern;
#line 2352
  req->src_port = port_num;
#line 2353
  req->dest_port = port_num;
#line 2354
  req->pkt_size = pkt_size;
#line 2355
  req->num_pkts = num_pkts;
#line 2356
  req->loopback_type = loopback_type;
#line 2358
  status = be_mcc_notify_wait(adapter);
#line 2359
  if (status == 0) {
#line 2360
    tmp___0 = embedded_payload(wrb);
#line 2360
    resp = (struct be_cmd_resp_loopback_test *)tmp___0;
#line 2361
    status = (int )resp->status;
  } else {

  }
  err: 
#line 2365
  spin_unlock_bh(& adapter->mcc_lock);
#line 2366
  return (status);
}
}
#line 2369 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_ddrdma_test *req ;
  int status ;
  int i ;
  int j ;
  struct be_cmd_resp_ddrdma_test *resp ;
  int tmp ;

  {
#line 2375
  j = 0;
#line 2377
  spin_lock_bh(& adapter->mcc_lock);
#line 2379
  wrb = wrb_from_mccq(adapter);
#line 2380
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2381
    status = -16;
#line 2382
    goto err;
  } else {

  }
#line 2384
  req = (struct be_cmd_req_ddrdma_test *)cmd->va;
#line 2385
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 17, (int )cmd->size, wrb, cmd);
#line 2388
  req->pattern = pattern;
#line 2389
  req->byte_count = byte_cnt;
#line 2390
  i = 0;
#line 2390
  goto ldv_52031;
  ldv_52030: 
#line 2391
  req->snd_buff[i] = (unsigned char )(pattern >> j * 8);
#line 2392
  j = j + 1;
#line 2393
  if (j > 7) {
#line 2394
    j = 0;
  } else {

  }
#line 2390
  i = i + 1;
  ldv_52031: ;
#line 2390
  if ((u32 )i < byte_cnt) {
#line 2392
    goto ldv_52030;
  } else {

  }
#line 2397
  status = be_mcc_notify_wait(adapter);
#line 2399
  if (status == 0) {
#line 2401
    resp = (struct be_cmd_resp_ddrdma_test *)cmd->va;
#line 2402
    tmp = memcmp((void const   *)(& resp->rcv_buff), (void const   *)(& req->snd_buff),
                 (size_t )byte_cnt);
#line 2402
    if (tmp != 0 || resp->snd_err != 0U) {
#line 2404
      status = -1;
    } else {

    }
  } else {

  }
  err: 
#line 2409
  spin_unlock_bh(& adapter->mcc_lock);
#line 2410
  return (status);
}
}
#line 2413 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_seeprom_read *req ;
  int status ;

  {
#line 2420
  spin_lock_bh(& adapter->mcc_lock);
#line 2422
  wrb = wrb_from_mccq(adapter);
#line 2423
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2424
    status = -16;
#line 2425
    goto err;
  } else {

  }
#line 2427
  req = (struct be_cmd_req_seeprom_read *)nonemb_cmd->va;
#line 2429
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 30, 1040, wrb, nonemb_cmd);
#line 2433
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2436
  spin_unlock_bh(& adapter->mcc_lock);
#line 2437
  return (status);
}
}
#line 2440 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_phy_info(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_phy_info *req ;
  struct be_dma_mem cmd ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  struct be_phy_info *resp_phy_info ;

  {
#line 2447
  tmp = be_cmd_allowed(adapter, 102, 1);
#line 2447
  if (tmp) {
#line 2447
    tmp___0 = 0;
  } else {
#line 2447
    tmp___0 = 1;
  }
#line 2447
  if (tmp___0) {
#line 2449
    return (-1);
  } else {

  }
#line 2451
  spin_lock_bh(& adapter->mcc_lock);
#line 2453
  wrb = wrb_from_mccq(adapter);
#line 2454
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2455
    status = -16;
#line 2456
    goto err;
  } else {

  }
#line 2458
  cmd.size = 40U;
#line 2459
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 2461
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2462
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 2463
    status = -12;
#line 2464
    goto err;
  } else {

  }
#line 2467
  req = (struct be_cmd_req_get_phy_info *)cmd.va;
#line 2469
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 102, 40, wrb, & cmd);
#line 2473
  status = be_mcc_notify_wait(adapter);
#line 2474
  if (status == 0) {
#line 2475
    resp_phy_info = (struct be_phy_info *)cmd.va + 16U;
#line 2477
    adapter->phy.phy_type = resp_phy_info->phy_type;
#line 2478
    adapter->phy.interface_type = resp_phy_info->interface_type;
#line 2480
    adapter->phy.auto_speeds_supported = resp_phy_info->auto_speeds_supported;
#line 2482
    adapter->phy.fixed_speeds_supported = resp_phy_info->fixed_speeds_supported;
#line 2484
    adapter->phy.misc_params = resp_phy_info->misc_params;
  } else {

  }
#line 2487
  pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  err: 
#line 2490
  spin_unlock_bh(& adapter->mcc_lock);
#line 2491
  return (status);
}
}
#line 2494 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_qos *req ;
  int status ;
  void *tmp ;

  {
#line 2500
  spin_lock_bh(& adapter->mcc_lock);
#line 2502
  wrb = wrb_from_mccq(adapter);
#line 2503
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2504
    status = -16;
#line 2505
    goto err;
  } else {

  }
#line 2508
  tmp = embedded_payload(wrb);
#line 2508
  req = (struct be_cmd_req_set_qos *)tmp;
#line 2510
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 28, 52, wrb, 0);
#line 2513
  req->hdr.domain = (u8 )domain;
#line 2514
  req->valid_bits = 1U;
#line 2515
  req->max_bps_nic = bps;
#line 2517
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2520
  spin_unlock_bh(& adapter->mcc_lock);
#line 2521
  return (status);
}
}
#line 2524 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cntl_attribs *req ;
  int status ;
  int payload_len ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct mgmt_controller_attrib *attribs ;
  struct be_dma_mem attribs_cmd ;
  int tmp ;

  {
#line 2530
  _max1 = 16UL;
#line 2530
  _max2 = 560UL;
#line 2530
  payload_len = (int )(_max1 > _max2 ? _max1 : _max2);
#line 2534
  tmp = ldv_mutex_lock_interruptible_36(& adapter->mbox_lock);
#line 2534
  if (tmp != 0) {
#line 2535
    return (-1);
  } else {

  }
#line 2537
  memset((void *)(& attribs_cmd), 0, 24UL);
#line 2538
  attribs_cmd.size = 560U;
#line 2539
  attribs_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )attribs_cmd.size,
                                        & attribs_cmd.dma);
#line 2541
  if ((unsigned long )attribs_cmd.va == (unsigned long )((void *)0)) {
#line 2542
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 2544
    status = -12;
#line 2545
    goto err;
  } else {

  }
#line 2548
  wrb = wrb_from_mbox(adapter);
#line 2549
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2550
    status = -16;
#line 2551
    goto err;
  } else {

  }
#line 2553
  req = (struct be_cmd_req_cntl_attribs *)attribs_cmd.va;
#line 2555
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 32, payload_len, wrb, & attribs_cmd);
#line 2559
  status = be_mbox_notify_wait(adapter);
#line 2560
  if (status == 0) {
#line 2561
    attribs = (struct mgmt_controller_attrib *)attribs_cmd.va + 16U;
#line 2562
    adapter->hba_port_num = attribs->hba_attribs.phy_port;
  } else {

  }
  err: 
#line 2566
  ldv_mutex_unlock_37(& adapter->mbox_lock);
#line 2567
  if ((unsigned long )attribs_cmd.va != (unsigned long )((void *)0)) {
#line 2568
    pci_free_consistent(adapter->pdev, (size_t )attribs_cmd.size, attribs_cmd.va,
                        attribs_cmd.dma);
  } else {

  }
#line 2570
  return (status);
}
}
#line 2574 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_req_native_mode(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_func_cap *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_set_func_cap *resp ;
  void *tmp___1 ;

  {
#line 2580
  tmp = ldv_mutex_lock_interruptible_38(& adapter->mbox_lock);
#line 2580
  if (tmp != 0) {
#line 2581
    return (-1);
  } else {

  }
#line 2583
  wrb = wrb_from_mbox(adapter);
#line 2584
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2585
    status = -16;
#line 2586
    goto err;
  } else {

  }
#line 2589
  tmp___0 = embedded_payload(wrb);
#line 2589
  req = (struct be_cmd_req_set_func_cap *)tmp___0;
#line 2591
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 103, 236, wrb, 0);
#line 2594
  req->valid_cap_flags = 6U;
#line 2596
  req->cap_flags = 4U;
#line 2598
  status = be_mbox_notify_wait(adapter);
#line 2599
  if (status == 0) {
#line 2600
    tmp___1 = embedded_payload(wrb);
#line 2600
    resp = (struct be_cmd_resp_set_func_cap *)tmp___1;
#line 2601
    adapter->be3_native = (resp->cap_flags & 4U) != 0U;
#line 2603
    if (! adapter->be3_native) {
#line 2604
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "adapter not in advanced mode\n");
    } else {

    }
  } else {

  }
  err: 
#line 2608
  ldv_mutex_unlock_39(& adapter->mbox_lock);
#line 2609
  return (status);
}
}
#line 2613 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fn_privileges *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fn_privileges *resp ;
  void *tmp___0 ;

  {
#line 2620
  spin_lock_bh(& adapter->mcc_lock);
#line 2622
  wrb = wrb_from_mccq(adapter);
#line 2623
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2624
    status = -16;
#line 2625
    goto err;
  } else {

  }
#line 2628
  tmp = embedded_payload(wrb);
#line 2628
  req = (struct be_cmd_req_get_fn_privileges *)tmp;
#line 2630
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 170, 20, wrb, 0);
#line 2634
  req->hdr.domain = (u8 )domain;
#line 2636
  status = be_mcc_notify_wait(adapter);
#line 2637
  if (status == 0) {
#line 2638
    tmp___0 = embedded_payload(wrb);
#line 2638
    resp = (struct be_cmd_resp_get_fn_privileges *)tmp___0;
#line 2640
    *privilege = resp->privilege_mask;
  } else {

  }
  err: 
#line 2644
  spin_unlock_bh(& adapter->mcc_lock);
#line 2645
  return (status);
}
}
#line 2649 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_active ,
                             u32 *pmac_id , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_mac_list *req ;
  int status ;
  int mac_count ;
  struct be_dma_mem get_mac_list_cmd ;
  int i ;
  struct be_cmd_resp_get_mac_list *resp ;
  struct get_list_macaddr *mac_entry ;
  u16 mac_addr_size ;
  u32 mac_id ;
  size_t __len ;
  void *__ret ;

  {
#line 2659
  memset((void *)(& get_mac_list_cmd), 0, 24UL);
#line 2660
  get_mac_list_cmd.size = 548U;
#line 2661
  get_mac_list_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size,
                                             & get_mac_list_cmd.dma);
#line 2665
  if ((unsigned long )get_mac_list_cmd.va == (unsigned long )((void *)0)) {
#line 2666
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure during GET_MAC_LIST\n");
#line 2668
    return (-12);
  } else {

  }
#line 2671
  spin_lock_bh(& adapter->mcc_lock);
#line 2673
  wrb = wrb_from_mccq(adapter);
#line 2674
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2675
    status = -16;
#line 2676
    goto out;
  } else {

  }
#line 2679
  req = (struct be_cmd_req_get_mac_list *)get_mac_list_cmd.va;
#line 2681
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 147, (int )get_mac_list_cmd.size, wrb, & get_mac_list_cmd);
#line 2684
  req->hdr.domain = domain;
#line 2685
  req->mac_type = 1U;
#line 2686
  req->perm_override = 1U;
#line 2688
  status = be_mcc_notify_wait(adapter);
#line 2689
  if (status == 0) {
#line 2690
    resp = (struct be_cmd_resp_get_mac_list *)get_mac_list_cmd.va;
#line 2692
    mac_count = (int )resp->true_mac_count + (int )resp->pseudo_mac_count;
#line 2698
    i = 0;
#line 2698
    goto ldv_52111;
    ldv_52110: 
#line 2703
    mac_entry = (struct get_list_macaddr *)(& resp->macaddr_list) + (unsigned long )i;
#line 2704
    mac_addr_size = mac_entry->mac_addr_size;
#line 2708
    if ((unsigned int )mac_addr_size == 4U) {
#line 2709
      *pmac_id_active = 1;
#line 2710
      mac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;
#line 2711
      *pmac_id = mac_id;
#line 2712
      goto out;
    } else {

    }
#line 2698
    i = i + 1;
    ldv_52111: ;
#line 2698
    if (i < mac_count) {
#line 2700
      goto ldv_52110;
    } else {

    }
#line 2716
    *pmac_id_active = 0;
#line 2717
    __len = 6UL;
#line 2717
    if (__len > 63UL) {
#line 2717
      __ret = __memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
                       __len);
    } else {
#line 2717
      __ret = __builtin_memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
                               __len);
    }
  } else {

  }
  out: 
#line 2722
  spin_unlock_bh(& adapter->mcc_lock);
#line 2723
  pci_free_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size, get_mac_list_cmd.va,
                      get_mac_list_cmd.dma);
#line 2725
  return (status);
}
}
#line 2729 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_mac_list *req ;
  int status ;
  struct be_dma_mem cmd ;
  size_t __len ;
  void *__ret ;

  {
#line 2737
  memset((void *)(& cmd), 0, 24UL);
#line 2738
  cmd.size = 404U;
#line 2739
  cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma, 208U,
                           0);
#line 2741
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2742
    return (-12);
  } else {

  }
#line 2744
  spin_lock_bh(& adapter->mcc_lock);
#line 2746
  wrb = wrb_from_mccq(adapter);
#line 2747
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2748
    status = -16;
#line 2749
    goto err;
  } else {

  }
#line 2752
  req = (struct be_cmd_req_set_mac_list *)cmd.va;
#line 2753
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 148, 404, wrb, & cmd);
#line 2757
  req->hdr.domain = (u8 )domain;
#line 2758
  req->mac_count = mac_count;
#line 2759
  if ((unsigned int )mac_count != 0U) {
#line 2760
    __len = (size_t )((int )mac_count * 6);
#line 2760
    __ret = __builtin_memcpy((void *)(& req->mac), (void const   *)mac_array, __len);
  } else {

  }
#line 2762
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2765
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, 0);
#line 2767
  spin_unlock_bh(& adapter->mcc_lock);
#line 2768
  return (status);
}
}
#line 2771 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_hsw_config *req ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 2779
  spin_lock_bh(& adapter->mcc_lock);
#line 2781
  wrb = wrb_from_mccq(adapter);
#line 2782
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2783
    status = -16;
#line 2784
    goto err;
  } else {

  }
#line 2787
  tmp = embedded_payload(wrb);
#line 2787
  req = (struct be_cmd_req_set_hsw_config *)tmp;
#line 2788
  ctxt = (void *)(& req->context);
#line 2790
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 153, 36, wrb, 0);
#line 2793
  req->hdr.domain = (u8 )domain;
#line 2794
  tmp___0 = amap_mask(16U);
#line 2794
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 2795
  if ((unsigned int )pvid != 0U) {
#line 2796
    tmp___1 = amap_mask(1U);
#line 2796
    amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 2797
    tmp___2 = amap_mask(16U);
#line 2797
    amap_set(ctxt, 1U, tmp___2, 16U, (u32 )pvid);
  } else {

  }
#line 2800
  swap_dws((void *)(& req->context), 20);
#line 2801
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2804
  spin_unlock_bh(& adapter->mcc_lock);
#line 2805
  return (status);
}
}
#line 2809 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_hsw_config *req ;
  void *ctxt ;
  int status ;
  u16 vid ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  struct be_cmd_resp_get_hsw_config *resp ;
  void *tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;

  {
#line 2818
  spin_lock_bh(& adapter->mcc_lock);
#line 2820
  wrb = wrb_from_mccq(adapter);
#line 2821
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2822
    status = -16;
#line 2823
    goto err;
  } else {

  }
#line 2826
  tmp = embedded_payload(wrb);
#line 2826
  req = (struct be_cmd_req_get_hsw_config *)tmp;
#line 2827
  ctxt = (void *)(& req->context);
#line 2829
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 152, 20, wrb, 0);
#line 2832
  req->hdr.domain = (u8 )domain;
#line 2833
  tmp___0 = amap_mask(16U);
#line 2833
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 2835
  tmp___1 = amap_mask(1U);
#line 2835
  amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 2836
  swap_dws((void *)(& req->context), 4);
#line 2838
  status = be_mcc_notify_wait(adapter);
#line 2839
  if (status == 0) {
#line 2840
    tmp___2 = embedded_payload(wrb);
#line 2840
    resp = (struct be_cmd_resp_get_hsw_config *)tmp___2;
#line 2842
    swap_dws((void *)(& resp->context), 16);
#line 2844
    tmp___3 = amap_mask(16U);
#line 2844
    tmp___4 = amap_get((void *)(& resp->context), 0U, tmp___3, 16U);
#line 2844
    vid = (u16 )tmp___4;
#line 2846
    *pvid = vid;
  } else {

  }
  err: 
#line 2850
  spin_unlock_bh(& adapter->mcc_lock);
#line 2851
  return (status);
}
}
#line 2854 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config_v1 *req ;
  int status ;
  int payload_len ;
  struct be_dma_mem cmd ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct be_cmd_resp_acpi_wol_magic_config_v1 *resp ;

  {
#line 2859
  payload_len = 1204;
#line 2862
  tmp = be_cmd_allowed(adapter, 12, 3);
#line 2862
  if (tmp) {
#line 2862
    tmp___0 = 0;
  } else {
#line 2862
    tmp___0 = 1;
  }
#line 2862
  if (tmp___0) {
#line 2864
    return (-1);
  } else {

  }
#line 2866
  tmp___1 = ldv_mutex_lock_interruptible_40(& adapter->mbox_lock);
#line 2866
  if (tmp___1 != 0) {
#line 2867
    return (-1);
  } else {

  }
#line 2869
  memset((void *)(& cmd), 0, 24UL);
#line 2870
  cmd.size = 1204U;
#line 2871
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 2873
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2874
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 2876
    status = -12;
#line 2877
    goto err;
  } else {

  }
#line 2880
  wrb = wrb_from_mbox(adapter);
#line 2881
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2882
    status = -16;
#line 2883
    goto err;
  } else {

  }
#line 2886
  req = (struct be_cmd_req_acpi_wol_magic_config_v1 *)cmd.va;
#line 2888
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, payload_len, wrb, & cmd);
#line 2892
  req->hdr.version = 1U;
#line 2893
  req->query_options = 2U;
#line 2895
  status = be_mbox_notify_wait(adapter);
#line 2896
  if (status == 0) {
#line 2898
    resp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;
#line 2902
    if (resp->hdr.response_length < (u32 )payload_len) {
#line 2903
      status = -1;
#line 2904
      goto err;
    } else {

    }
#line 2906
    adapter->wol_cap = resp->wol_settings;
  } else {

  }
  err: 
#line 2909
  ldv_mutex_unlock_41(& adapter->mbox_lock);
#line 2910
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 2911
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 2912
  return (status);
}
}
#line 2915 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_ext_fat_caps *req ;
  int status ;
  int tmp ;

  {
#line 2922
  tmp = ldv_mutex_lock_interruptible_42(& adapter->mbox_lock);
#line 2922
  if (tmp != 0) {
#line 2923
    return (-1);
  } else {

  }
#line 2925
  wrb = wrb_from_mbox(adapter);
#line 2926
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2927
    status = -16;
#line 2928
    goto err;
  } else {

  }
#line 2931
  req = (struct be_cmd_req_get_ext_fat_caps *)cmd->va;
#line 2932
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 125, (int )cmd->size, wrb, cmd);
#line 2935
  req->parameter_type = 1U;
#line 2937
  status = be_mbox_notify_wait(adapter);
  err: 
#line 2939
  ldv_mutex_unlock_43(& adapter->mbox_lock);
#line 2940
  return (status);
}
}
#line 2943 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ext_fat_caps *req ;
  int status ;
  size_t __len ;
  void *__ret ;

  {
#line 2951
  spin_lock_bh(& adapter->mcc_lock);
#line 2953
  wrb = wrb_from_mccq(adapter);
#line 2954
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2955
    status = -16;
#line 2956
    goto err;
  } else {

  }
#line 2959
  req = (struct be_cmd_req_set_ext_fat_caps *)cmd->va;
#line 2960
  __len = 2828UL;
#line 2960
  if (__len > 63UL) {
#line 2960
    __ret = __memcpy((void *)(& req->set_params), (void const   *)configs, __len);
  } else {
#line 2960
    __ret = __builtin_memcpy((void *)(& req->set_params), (void const   *)configs,
                             __len);
  }
#line 2961
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 126, (int )cmd->size, wrb, cmd);
#line 2965
  status = be_mcc_notify_wait(adapter);
  err: 
#line 2967
  spin_unlock_bh(& adapter->mcc_lock);
#line 2968
  return (status);
}
}
#line 2971 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_port_name *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_port_name *resp ;
  void *tmp___0 ;

  {
#line 2977
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 2978
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
#line 2979
    return (0);
  } else {

  }
#line 2982
  spin_lock_bh(& adapter->mcc_lock);
#line 2984
  wrb = wrb_from_mccq(adapter);
#line 2985
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2986
    status = -16;
#line 2987
    goto err;
  } else {

  }
#line 2990
  tmp = embedded_payload(wrb);
#line 2990
  req = (struct be_cmd_req_get_port_name *)tmp;
#line 2992
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 77, 20, wrb, 0);
#line 2995
  req->hdr.version = 1U;
#line 2997
  status = be_mcc_notify_wait(adapter);
#line 2998
  if (status == 0) {
#line 2999
    tmp___0 = embedded_payload(wrb);
#line 2999
    resp = (struct be_cmd_resp_get_port_name *)tmp___0;
#line 3000
    *port_name = resp->port_name[(int )adapter->hba_port_num];
  } else {
#line 3002
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
  }
  err: 
#line 3005
  spin_unlock_bh(& adapter->mcc_lock);
#line 3006
  return (status);
}
}
#line 3009 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
static struct be_nic_resource_desc *be_get_nic_desc(u8 *buf , u32 desc_count , u32 max_buf_size ) 
{ 
  struct be_nic_resource_desc *desc ;
  int i ;

  {
#line 3012
  desc = (struct be_nic_resource_desc *)buf;
#line 3015
  i = 0;
#line 3015
  goto ldv_52202;
  ldv_52201: 
#line 3016
  desc->desc_len = (int )desc->desc_len != 0 ? (u8 )((int )desc->desc_len) : 88U;
#line 3017
  if ((unsigned long )((void *)desc + (unsigned long )desc->desc_len) > (unsigned long )((void *)buf + (unsigned long )max_buf_size)) {
#line 3019
    desc = 0;
#line 3020
    goto ldv_52200;
  } else {

  }
#line 3023
  if ((unsigned int )desc->desc_type == 65U || (unsigned int )desc->desc_type == 81U) {
#line 3025
    goto ldv_52200;
  } else {

  }
#line 3027
  desc = desc + (unsigned long )desc->desc_len;
#line 3015
  i = i + 1;
  ldv_52202: ;
#line 3015
  if ((u32 )i < desc_count) {
#line 3017
    goto ldv_52201;
  } else {

  }
  ldv_52200: ;
#line 3030
  if ((unsigned long )desc == (unsigned long )((struct be_nic_resource_desc *)0) || i == 4) {
#line 3031
    return (0);
  } else {

  }
#line 3033
  return (desc);
}
}
#line 3037 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_func_config(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_func_config *req ;
  int status ;
  struct be_dma_mem cmd ;
  int tmp ;
  struct be_cmd_resp_get_func_config *resp ;
  u32 desc_count ;
  struct be_nic_resource_desc *desc ;

  {
#line 3044
  tmp = ldv_mutex_lock_interruptible_44(& adapter->mbox_lock);
#line 3044
  if (tmp != 0) {
#line 3045
    return (-1);
  } else {

  }
#line 3047
  memset((void *)(& cmd), 0, 24UL);
#line 3048
  cmd.size = 372U;
#line 3049
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 3051
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3052
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 3053
    status = -12;
#line 3054
    goto err;
  } else {

  }
#line 3057
  wrb = wrb_from_mbox(adapter);
#line 3058
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3059
    status = -16;
#line 3060
    goto err;
  } else {

  }
#line 3063
  req = (struct be_cmd_req_get_func_config *)cmd.va;
#line 3065
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 160, (int )cmd.size, wrb, & cmd);
#line 3069
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3070
    req->hdr.version = 1U;
  } else {

  }
#line 3072
  status = be_mbox_notify_wait(adapter);
#line 3073
  if (status == 0) {
#line 3074
    resp = (struct be_cmd_resp_get_func_config *)cmd.va;
#line 3075
    desc_count = resp->desc_count;
#line 3078
    desc = be_get_nic_desc((u8 *)(& resp->func_param), desc_count, 352U);
#line 3080
    if ((unsigned long )desc == (unsigned long )((struct be_nic_resource_desc *)0)) {
#line 3081
      status = -22;
#line 3082
      goto err;
    } else {

    }
#line 3085
    adapter->pf_number = desc->pf_num;
#line 3086
    adapter->max_pmac_cnt = desc->unicast_mac_count;
#line 3087
    adapter->max_vlans = desc->vlan_count;
#line 3088
    adapter->max_mcast_mac = desc->mcast_mac_count;
#line 3089
    adapter->max_tx_queues = desc->txq_count;
#line 3090
    adapter->max_rss_queues = desc->rssq_count;
#line 3091
    adapter->max_rx_queues = desc->rq_count;
#line 3093
    adapter->max_event_queues = desc->eq_count;
#line 3094
    adapter->if_cap_flags = desc->cap_flags;
  } else {

  }
  err: 
#line 3097
  ldv_mutex_unlock_45(& adapter->mbox_lock);
#line 3098
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3099
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 3100
  return (status);
}
}
#line 3104 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_profile_config_mbox(struct be_adapter *adapter , u8 domain , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;
  int tmp ;

  {
#line 3111
  tmp = ldv_mutex_lock_interruptible_46(& adapter->mbox_lock);
#line 3111
  if (tmp != 0) {
#line 3112
    return (-1);
  } else {

  }
#line 3113
  wrb = wrb_from_mbox(adapter);
#line 3115
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3116
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3120
  req->type = 2U;
#line 3121
  req->hdr.domain = domain;
#line 3122
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3123
    req->hdr.version = 1U;
  } else {

  }
#line 3125
  status = be_mbox_notify_wait(adapter);
#line 3127
  ldv_mutex_unlock_47(& adapter->mbox_lock);
#line 3128
  return (status);
}
}
#line 3132 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_profile_config_mccq(struct be_adapter *adapter , u8 domain , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;

  {
#line 3139
  spin_lock_bh(& adapter->mcc_lock);
#line 3141
  wrb = wrb_from_mccq(adapter);
#line 3142
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3143
    status = -16;
#line 3144
    goto err;
  } else {

  }
#line 3147
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3148
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3152
  req->type = 2U;
#line 3153
  req->hdr.domain = domain;
#line 3154
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3155
    req->hdr.version = 1U;
  } else {

  }
#line 3157
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3160
  spin_unlock_bh(& adapter->mcc_lock);
#line 3161
  return (status);
}
}
#line 3165 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_profile_config(struct be_adapter *adapter , u32 *cap_flags , u16 *txq_count ,
                              u8 domain ) 
{ 
  struct be_queue_info *mccq ;
  struct be_dma_mem cmd ;
  int status ;
  struct be_cmd_resp_get_profile_config *resp ;
  u32 desc_count ;
  struct be_nic_resource_desc *desc ;

  {
#line 3168
  mccq = & adapter->mcc_obj.q;
#line 3172
  memset((void *)(& cmd), 0, 24UL);
#line 3173
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3174
    cmd.size = 2836U;
  } else {
#line 3176
    cmd.size = 372U;
  }
#line 3177
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
#line 3179
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3180
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 3181
    return (-12);
  } else {

  }
#line 3184
  if (! mccq->created) {
#line 3185
    status = be_cmd_get_profile_config_mbox(adapter, (int )domain, & cmd);
  } else {
#line 3187
    status = be_cmd_get_profile_config_mccq(adapter, (int )domain, & cmd);
  }
#line 3188
  if (status == 0) {
#line 3189
    resp = (struct be_cmd_resp_get_profile_config *)cmd.va;
#line 3190
    desc_count = resp->desc_count;
#line 3193
    desc = be_get_nic_desc((u8 *)(& resp->func_param), desc_count, 352U);
#line 3196
    if ((unsigned long )desc == (unsigned long )((struct be_nic_resource_desc *)0)) {
#line 3197
      status = -22;
#line 3198
      goto err;
    } else {

    }
#line 3200
    if ((unsigned long )cap_flags != (unsigned long )((u32 *)0)) {
#line 3201
      *cap_flags = desc->cap_flags;
    } else {

    }
#line 3202
    if ((unsigned long )txq_count != (unsigned long )((u16 *)0)) {
#line 3203
      *txq_count = desc->txq_count;
    } else {

    }
  } else {

  }
  err: ;
#line 3206
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
#line 3207
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  } else {

  }
#line 3209
  return (status);
}
}
#line 3213 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_set_profile_config(struct be_adapter *adapter , u32 bps , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_profile_config *req ;
  int status ;
  void *tmp ;

  {
#line 3220
  spin_lock_bh(& adapter->mcc_lock);
#line 3222
  wrb = wrb_from_mccq(adapter);
#line 3223
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3224
    status = -16;
#line 3225
    goto err;
  } else {

  }
#line 3228
  tmp = embedded_payload(wrb);
#line 3228
  req = (struct be_cmd_req_set_profile_config *)tmp;
#line 3230
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 165, 96, wrb, 0);
#line 3234
  req->hdr.domain = domain;
#line 3235
  req->desc_count = 1U;
#line 3237
  req->nic_desc.desc_type = 65U;
#line 3238
  req->nic_desc.desc_len = 88U;
#line 3239
  req->nic_desc.flags = 208U;
#line 3240
  req->nic_desc.pf_num = adapter->pf_number;
#line 3241
  req->nic_desc.vf_num = domain;
#line 3244
  req->nic_desc.unicast_mac_count = 65535U;
#line 3245
  req->nic_desc.mcc_count = 65535U;
#line 3246
  req->nic_desc.vlan_count = 65535U;
#line 3247
  req->nic_desc.mcast_mac_count = 65535U;
#line 3248
  req->nic_desc.txq_count = 65535U;
#line 3249
  req->nic_desc.rq_count = 65535U;
#line 3250
  req->nic_desc.rssq_count = 65535U;
#line 3251
  req->nic_desc.lro_count = 65535U;
#line 3252
  req->nic_desc.cq_count = 65535U;
#line 3253
  req->nic_desc.toe_conn_count = 65535U;
#line 3254
  req->nic_desc.eq_count = 65535U;
#line 3255
  req->nic_desc.link_param = 255U;
#line 3256
  req->nic_desc.bw_min = 4294967295U;
#line 3257
  req->nic_desc.acpi_params = 255U;
#line 3258
  req->nic_desc.wol_param = 15U;
#line 3261
  req->nic_desc.bw_min = bps;
#line 3262
  req->nic_desc.bw_max = bps;
#line 3263
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3265
  spin_unlock_bh(& adapter->mcc_lock);
#line 3266
  return (status);
}
}
#line 3269 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_iface_list *req ;
  struct be_cmd_resp_get_iface_list *resp ;
  int status ;
  void *tmp ;

  {
#line 3277
  spin_lock_bh(& adapter->mcc_lock);
#line 3279
  wrb = wrb_from_mccq(adapter);
#line 3280
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3281
    status = -16;
#line 3282
    goto err;
  } else {

  }
#line 3284
  tmp = embedded_payload(wrb);
#line 3284
  req = (struct be_cmd_req_get_iface_list *)tmp;
#line 3286
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 194, 32, wrb, 0);
#line 3289
  req->hdr.domain = (unsigned int )((u8 )vf_num) + 1U;
#line 3291
  status = be_mcc_notify_wait(adapter);
#line 3292
  if (status == 0) {
#line 3293
    resp = (struct be_cmd_resp_get_iface_list *)req;
#line 3294
    vf_cfg->if_handle = (int )resp->if_desc.if_id;
  } else {

  }
  err: 
#line 3298
  spin_unlock_bh(& adapter->mcc_lock);
#line 3299
  return (status);
}
}
#line 3303 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_enable_disable_vf *req ;
  int status ;
  void *tmp ;

  {
#line 3309
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3310
    return (0);
  } else {

  }
#line 3312
  spin_lock_bh(& adapter->mcc_lock);
#line 3314
  wrb = wrb_from_mccq(adapter);
#line 3315
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3316
    status = -16;
#line 3317
    goto err;
  } else {

  }
#line 3320
  tmp = embedded_payload(wrb);
#line 3320
  req = (struct be_cmd_enable_disable_vf *)tmp;
#line 3322
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 196, 20, wrb, 0);
#line 3326
  req->hdr.domain = domain;
#line 3327
  req->enable = 1U;
#line 3328
  status = be_mcc_notify_wait(adapter);
  err: 
#line 3330
  spin_unlock_bh(& adapter->mcc_lock);
#line 3331
  return (status);
}
}
#line 3334 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_intr_set *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 3340
  tmp = ldv_mutex_lock_interruptible_48(& adapter->mbox_lock);
#line 3340
  if (tmp != 0) {
#line 3341
    return (-1);
  } else {

  }
#line 3343
  wrb = wrb_from_mbox(adapter);
#line 3345
  tmp___0 = embedded_payload(wrb);
#line 3345
  req = (struct be_cmd_req_intr_set *)tmp___0;
#line 3347
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 89, 20, wrb, 0);
#line 3351
  req->intr_enabled = (u8 )intr_enable;
#line 3353
  status = be_mbox_notify_wait(adapter);
#line 3355
  ldv_mutex_unlock_49(& adapter->mbox_lock);
#line 3356
  return (status);
}
}
#line 3359 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  struct be_cmd_req_hdr *req ;
  struct be_cmd_resp_hdr *resp ;
  int status ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 3362
  tmp = netdev_priv((struct net_device  const  *)netdev_handle);
#line 3362
  adapter = (struct be_adapter *)tmp;
#line 3364
  hdr = (struct be_cmd_req_hdr *)wrb_payload;
#line 3369
  spin_lock_bh(& adapter->mcc_lock);
#line 3371
  wrb = wrb_from_mccq(adapter);
#line 3372
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3373
    status = -16;
#line 3374
    goto err;
  } else {

  }
#line 3376
  tmp___0 = embedded_payload(wrb);
#line 3376
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 3377
  tmp___1 = embedded_payload(wrb);
#line 3377
  resp = (struct be_cmd_resp_hdr *)tmp___1;
#line 3379
  be_wrb_cmd_hdr_prepare(req, (int )hdr->subsystem, (int )hdr->opcode, wrb_payload_size,
                         wrb, 0);
#line 3381
  __len = (size_t )wrb_payload_size;
#line 3381
  __ret = __builtin_memcpy((void *)req, (void const   *)wrb_payload, __len);
#line 3382
  swap_dws((void *)req, wrb_payload_size);
#line 3384
  status = be_mcc_notify_wait(adapter);
#line 3385
  if ((unsigned long )cmd_status != (unsigned long )((u16 *)0)) {
#line 3386
    *cmd_status = (u16 )status;
  } else {

  }
#line 3387
  if ((unsigned long )ext_status != (unsigned long )((u16 *)0)) {
#line 3388
    *ext_status = 0U;
  } else {

  }
#line 3389
  __len___0 = (unsigned long )resp->response_length + 16UL;
#line 3389
  __ret___0 = __builtin_memcpy(wrb_payload, (void const   *)resp, __len___0);
#line 3390
  swap_dws(wrb_payload, (int )(resp->response_length + 16U));
  err: 
#line 3392
  spin_unlock_bh(& adapter->mcc_lock);
#line 3393
  return (status);
}
}
#line 3397 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3402
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 3404
  mutex_lock(ldv_func_arg1);
#line 3405
  return;
}
}
#line 3407 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3412
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 3414
  mutex_unlock(ldv_func_arg1);
#line 3415
  return;
}
}
#line 3417 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3422
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 3424
  mutex_lock(ldv_func_arg1);
#line 3425
  return;
}
}
#line 3427 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_trylock_14(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3432
  tmp = mutex_trylock(ldv_func_arg1);
#line 3432
  ldv_func_res = tmp;
#line 3434
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 3434
  return (tmp___0);
#line 3436
  return (ldv_func_res);
}
}
#line 3439 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3444
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 3446
  mutex_unlock(ldv_func_arg1);
#line 3447
  return;
}
}
#line 3449 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_16(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3454
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3454
  ldv_func_res = tmp;
#line 3456
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3456
  return (tmp___0);
#line 3458
  return (ldv_func_res);
}
}
#line 3461 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3466
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3468
  mutex_unlock(ldv_func_arg1);
#line 3469
  return;
}
}
#line 3471 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_18(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3476
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3476
  ldv_func_res = tmp;
#line 3478
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3478
  return (tmp___0);
#line 3480
  return (ldv_func_res);
}
}
#line 3483 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3488
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3490
  mutex_unlock(ldv_func_arg1);
#line 3491
  return;
}
}
#line 3493 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_20(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3498
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3498
  ldv_func_res = tmp;
#line 3500
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3500
  return (tmp___0);
#line 3502
  return (ldv_func_res);
}
}
#line 3505 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3510
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3512
  mutex_unlock(ldv_func_arg1);
#line 3513
  return;
}
}
#line 3515 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_22(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3520
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3520
  ldv_func_res = tmp;
#line 3522
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3522
  return (tmp___0);
#line 3524
  return (ldv_func_res);
}
}
#line 3527 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3532
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3534
  mutex_unlock(ldv_func_arg1);
#line 3535
  return;
}
}
#line 3537 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_24(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3542
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3542
  ldv_func_res = tmp;
#line 3544
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3544
  return (tmp___0);
#line 3546
  return (ldv_func_res);
}
}
#line 3549 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3554
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3556
  mutex_unlock(ldv_func_arg1);
#line 3557
  return;
}
}
#line 3559 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_26(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3564
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3564
  ldv_func_res = tmp;
#line 3566
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3566
  return (tmp___0);
#line 3568
  return (ldv_func_res);
}
}
#line 3571 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3576
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3578
  mutex_unlock(ldv_func_arg1);
#line 3579
  return;
}
}
#line 3581 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_28(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3586
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3586
  ldv_func_res = tmp;
#line 3588
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3588
  return (tmp___0);
#line 3590
  return (ldv_func_res);
}
}
#line 3593 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3598
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3600
  mutex_unlock(ldv_func_arg1);
#line 3601
  return;
}
}
#line 3603 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_30(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3608
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3608
  ldv_func_res = tmp;
#line 3610
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3610
  return (tmp___0);
#line 3612
  return (ldv_func_res);
}
}
#line 3615 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3620
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3622
  mutex_unlock(ldv_func_arg1);
#line 3623
  return;
}
}
#line 3625 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_32(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3630
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3630
  ldv_func_res = tmp;
#line 3632
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3632
  return (tmp___0);
#line 3634
  return (ldv_func_res);
}
}
#line 3637 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_33(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3642
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3644
  mutex_unlock(ldv_func_arg1);
#line 3645
  return;
}
}
#line 3647 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_34(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3652
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3652
  ldv_func_res = tmp;
#line 3654
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3654
  return (tmp___0);
#line 3656
  return (ldv_func_res);
}
}
#line 3659 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_35(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3664
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3666
  mutex_unlock(ldv_func_arg1);
#line 3667
  return;
}
}
#line 3669 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_36(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___24 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3674
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3674
  ldv_func_res = tmp;
#line 3676
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3676
  return (tmp___0);
#line 3678
  return (ldv_func_res);
}
}
#line 3681 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_37(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3686
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3688
  mutex_unlock(ldv_func_arg1);
#line 3689
  return;
}
}
#line 3691 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_38(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___26 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3696
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3696
  ldv_func_res = tmp;
#line 3698
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3698
  return (tmp___0);
#line 3700
  return (ldv_func_res);
}
}
#line 3703 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_39(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3708
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3710
  mutex_unlock(ldv_func_arg1);
#line 3711
  return;
}
}
#line 3713 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_40(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___28 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3718
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3718
  ldv_func_res = tmp;
#line 3720
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3720
  return (tmp___0);
#line 3722
  return (ldv_func_res);
}
}
#line 3725 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3730
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3732
  mutex_unlock(ldv_func_arg1);
#line 3733
  return;
}
}
#line 3735 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_42(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___30 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3740
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3740
  ldv_func_res = tmp;
#line 3742
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3742
  return (tmp___0);
#line 3744
  return (ldv_func_res);
}
}
#line 3747 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3752
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3754
  mutex_unlock(ldv_func_arg1);
#line 3755
  return;
}
}
#line 3757 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_44(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___32 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3762
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3762
  ldv_func_res = tmp;
#line 3764
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3764
  return (tmp___0);
#line 3766
  return (ldv_func_res);
}
}
#line 3769 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3774
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3776
  mutex_unlock(ldv_func_arg1);
#line 3777
  return;
}
}
#line 3779 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_46(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___34 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3784
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3784
  ldv_func_res = tmp;
#line 3786
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3786
  return (tmp___0);
#line 3788
  return (ldv_func_res);
}
}
#line 3791 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3796
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3798
  mutex_unlock(ldv_func_arg1);
#line 3799
  return;
}
}
#line 3801 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
int ldv_mutex_lock_interruptible_48(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___36 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3806
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 3806
  ldv_func_res = tmp;
#line 3808
  tmp___0 = ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3808
  return (tmp___0);
#line 3810
  return (ldv_func_res);
}
}
#line 3813 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_cmds.c.prepared"
void ldv_mutex_unlock_49(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3818
  ldv_mutex_unlock_mbox_lock_of_be_adapter(ldv_func_arg1);
#line 3820
  mutex_unlock(ldv_func_arg1);
#line 3821
  return;
}
}
#line 361 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 174 "include/linux/mutex.h"
int ldv_mutex_trylock_92(struct mutex *ldv_func_arg1 ) ;
#line 179
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 183
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) ;
#line 80 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 82
  return ((char const   *)kobj->name);
}
}
#line 741 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 744
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 745
    return ((char const   *)dev->init_name);
  } else {

  }
#line 747
  tmp = kobject_name(& dev->kobj);
#line 747
  return (tmp);
}
}
#line 1487 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1489
  tmp = dev_name(& pdev->dev);
#line 1489
  return (tmp);
}
}
#line 53 "include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 57
  ep->speed = (unsigned short )speed;
#line 58
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 59
  return;
}
}
#line 61 "include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 63
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 65 "include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 2290 "include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 2292
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& dev->state));
#line 2292
  return (tmp == 0);
}
}
#line 1805 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool check_privilege(struct be_adapter *adapter , u32 flags ) 
{ 


  {
#line 1807
  return ((adapter->cmd_privileges & flags) != 0U);
}
}
#line 79 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static struct be_ethtool_stat  const  et_stats[32U]  = 
#line 79 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
  {      {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2,
      4, 36}, 
        {{'r', 'x', '_', 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', '_', 's', 'y',
       'm', 'b', 'o', 'l', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2, 4, 40}, 
        {{'r', 'x', '_', 'p', 'a', 'u', 's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's',
       '\000'}, 2, 4, 44}, 
        {{'r', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', '_', 'f', 'r', 'a', 'm',
       'e', 's', '\000'}, 2, 4, 52}, 
        {{'r', 'x', '_', 'i', 'n', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r', 'r',
       'o', 'r', 's', '\000'}, 2, 4, 56}, 
        {{'r', 'x', '_', 'o', 'u', 't', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 2, 4, 60}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 't', 'o', 'o', '_', 'l', 'o',
       'n', 'g', '\000'}, 2, 4, 64}, 
        {{'r', 'x', '_', 'a', 'd', 'd', 'r', 'e', 's', 's', '_', 'f', 'i', 'l', 't',
       'e', 'r', 'e', 'd', '\000'}, 2, 4, 68}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'm', 'a', 'l', 'l', '\000'}, 2, 4, 72}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'h', 'o', 'r', 't', '\000'}, 2, 4, 76}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'h', 'e', 'a', 'd',
       'e', 'r', '_', 't', 'o', 'o', '_', 's', 'm', 'a', 'l', 'l', '\000'}, 2, 4,
      80}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'c', 'p', '_',
       'l', 'e', 'n', 'g', 't', 'h', '\000'}, 2, 4, 84}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'r', 'u', 'n', 't',
       '\000'}, 2, 4, 88}, 
        {{'r', 'x', 'p', 'p', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 116}, 
        {{'r', 'x', '_', 'i', 'n', 'p', 'u', 't', '_', 'f', 'i', 'f', 'o', '_', 'o',
       'v', 'e', 'r', 'f', 'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4,
      120}, 
        {{'r', 'x', '_', 'i', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm', '_',
       'e', 'r', 'r', 's', '\000'}, 2, 4, 92}, 
        {{'r', 'x', '_', 't', 'c', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 96}, 
        {{'r', 'x', '_', 'u', 'd', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 100}, 
        {{'t', 'x', '_', 'p', 'a', 'u', 's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 104}, 
        {{'t', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', 'f', 'r', 'a', 'm', 'e',
       's', '\000'}, 2, 4, 112}, 
        {{'r', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 48}, 
        {{'t', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 108}, 
        {{'p', 'm', 'e', 'm', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 124}, 
        {{'j', 'a', 'b', 'b', 'e', 'r', '_', 'e', 'v', 'e', 'n', 't', 's', '\000'}, 2,
      4, 128}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'p', 'b', 'u',
       'f', '\000'}, 2, 4, 8}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'e', 'r', 'x',
       '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 't', 'p', 'r',
       'e', '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 20}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 't', 'o', 'o', '_', 'm', 'a',
       'n', 'y', '_', 'f', 'r', 'a', 'g', 's', '\000'}, 2, 4, 24}, 
        {{'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'd', '_', 'p', 'a', 'c', 'k', 'e',
       't', 's', '\000'}, 2, 4, 28}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'm', 't', 'u', '\000'}, 2, 4,
      32}, 
        {{'e', 't', 'h', '_', 'r', 'e', 'd', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 2,
      4, 4}, 
        {{'b', 'e', '_', 'o', 'n', '_', 'd', 'i', 'e', '_', 't', 'e', 'm', 'p', 'e',
       'r', 'a', 't', 'u', 'r', 'e', '\000'}, 2, 4, 0}};
#line 166 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static struct be_ethtool_stat  const  et_rx_stats[7U]  = {      {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 1, 8, 0}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '\000'}, 1, 8, 8}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 1, 4, 44}, 
        {{'r', 'x', '_', 'm', 'c', 'a', 's', 't', '_', 'p', 'k', 't', 's', '\000'}, 1,
      4, 48}, 
        {{'r', 'x', '_', 'p', 'o', 's', 't', '_', 'f', 'a', 'i', 'l', '\000'}, 1, 4,
      40}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 's', 'k', 'b',
       's', '\000'}, 1, 4, 32}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'f', 'r', 'a',
       'g', 's', '\000'}, 1, 4, 36}};
#line 187 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static struct be_ethtool_stat  const  et_tx_stats[6U]  = {      {{'t', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 0, 8, 32}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'k', 't', 's', '\000'}, 0, 8, 8}, 
        {{'t', 'x', '_', 'r', 'e', 'q', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 'w', 'r', 'b', 's', '\000'}, 0, 8, 24}, 
        {{'t', 'x', '_', 's', 't', 'o', 'p', 's', '\000'}, 0, 4, 48}};
#line 202 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static char const   et_self_tests[5U][32U]  = { {        'M',        'A',        'C',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'P',        'H',        'Y',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'E',        'x',        't',        'e', 
            'r',        'n',        'a',        'l', 
            ' ',        'L',        'o',        'o', 
            'p',        'b',        'a',        'c', 
            'k',        ' ',        't',        'e', 
            's',        't',        '\000'}, 
   {        'D',        'D',        'R',        ' ', 
            'D',        'M',        'A',        ' ', 
            't',        'e',        's',        't', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}};
#line 216 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  char fw_on_flash[32U] ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 219
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 219
  adapter = (struct be_adapter *)tmp;
#line 222
  memset((void *)(& fw_on_flash), 0, 32UL);
#line 223
  be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), (char *)(& fw_on_flash));
#line 225
  strlcpy((char *)(& drvinfo->driver), "be2net", 32UL);
#line 226
  strlcpy((char *)(& drvinfo->version), "4.6.62.0u", 32UL);
#line 227
  tmp___0 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)(& fw_on_flash),
                   32UL);
#line 227
  if (tmp___0 == 0) {
#line 228
    strlcpy((char *)(& drvinfo->fw_version), (char const   *)(& adapter->fw_ver),
            32UL);
  } else {
#line 231
    snprintf((char *)(& drvinfo->fw_version), 32UL, "%s [%s]", (char *)(& adapter->fw_ver),
             (char *)(& fw_on_flash));
  }
#line 234
  tmp___1 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 234
  strlcpy((char *)(& drvinfo->bus_info), tmp___1, 32UL);
#line 236
  drvinfo->testinfo_len = 0U;
#line 237
  drvinfo->regdump_len = 0U;
#line 238
  drvinfo->eedump_len = 0U;
#line 239
  return;
}
}
#line 242 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u32 lancer_cmd_get_file_len(struct be_adapter *adapter , u8 *file_name ) 
{ 
  u32 data_read ;
  u32 eof ;
  u8 addn_status ;
  struct be_dma_mem data_len_cmd ;
  int status ;

  {
#line 244
  data_read = 0U;
#line 249
  memset((void *)(& data_len_cmd), 0, 24UL);
#line 251
  status = lancer_cmd_read_object(adapter, & data_len_cmd, 0U, 0U, (char const   *)file_name,
                                  & data_read, & eof, & addn_status);
#line 254
  return (data_read);
}
}
#line 258 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int lancer_cmd_read_file(struct be_adapter *adapter , u8 *file_name , u32 buf_len ,
                                void *buf ) 
{ 
  struct be_dma_mem read_cmd ;
  u32 read_len ;
  u32 total_read_len ;
  u32 chunk_size ;
  u32 eof ;
  u8 addn_status ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;
  size_t __len ;
  void *__ret ;

  {
#line 262
  read_len = 0U;
#line 262
  total_read_len = 0U;
#line 263
  eof = 0U;
#line 265
  status = 0;
#line 267
  read_cmd.size = 32768U;
#line 268
  read_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )read_cmd.size, & read_cmd.dma);
#line 271
  if ((unsigned long )read_cmd.va == (unsigned long )((void *)0)) {
#line 272
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while reading dump\n");
#line 274
    return (-12);
  } else {

  }
#line 277
  goto ldv_50428;
  ldv_50427: 
#line 278
  __min1 = buf_len - total_read_len;
#line 278
  __min2 = 32768U;
#line 278
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 280
  chunk_size = (chunk_size + 3U) & 4294967292U;
#line 281
  status = lancer_cmd_read_object(adapter, & read_cmd, chunk_size, total_read_len,
                                  (char const   *)file_name, & read_len, & eof, & addn_status);
#line 284
  if (status == 0) {
#line 285
    __len = (size_t )read_len;
#line 285
    __ret = __builtin_memcpy(buf + (unsigned long )total_read_len, (void const   *)read_cmd.va,
                             __len);
#line 286
    total_read_len = total_read_len + read_len;
#line 287
    eof = eof & 2147483648U;
  } else {
#line 289
    status = -5;
#line 290
    goto ldv_50426;
  }
  ldv_50428: ;
#line 277
  if (total_read_len < buf_len && eof == 0U) {
#line 279
    goto ldv_50427;
  } else {

  }
  ldv_50426: 
#line 293
  pci_free_consistent(adapter->pdev, (size_t )read_cmd.size, read_cmd.va, read_cmd.dma);
#line 296
  return (status);
}
}
#line 300 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_reg_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u32 log_size ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 302
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 302
  adapter = (struct be_adapter *)tmp;
#line 303
  log_size = 0U;
#line 305
  tmp___0 = check_privilege(adapter, 1792U);
#line 305
  if (tmp___0) {
#line 305
    tmp___1 = 0;
  } else {
#line 305
    tmp___1 = 1;
  }
#line 305
  if (tmp___1) {
#line 306
    return (0);
  } else {

  }
#line 308
  if ((unsigned int )adapter->virtfn == 0U) {
#line 309
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 310
      log_size = lancer_cmd_get_file_len(adapter, (u8 *)"/dbg/dump.bin");
    } else {
#line 313
      be_cmd_get_reg_len(adapter, & log_size);
    }
  } else {

  }
#line 315
  return ((int )log_size);
}
}
#line 319 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_regs(struct net_device *netdev , struct ethtool_regs *regs , void *buf ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 321
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 321
  adapter = (struct be_adapter *)tmp;
#line 323
  if ((unsigned int )adapter->virtfn == 0U) {
#line 324
    memset(buf, 0, (size_t )regs->len);
#line 325
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 326
      lancer_cmd_read_file(adapter, (u8 *)"/dbg/dump.bin", regs->len, buf);
    } else {
#line 329
      be_cmd_get_regs(adapter, regs->len, buf);
    }
  } else {

  }
#line 331
  return;
}
}
#line 333 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;

  {
#line 336
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 336
  adapter = (struct be_adapter *)tmp;
#line 337
  eqo = (struct be_eq_obj *)(& adapter->eq_obj);
#line 340
  et->rx_coalesce_usecs = eqo->cur_eqd;
#line 341
  et->rx_coalesce_usecs_high = eqo->max_eqd;
#line 342
  et->rx_coalesce_usecs_low = eqo->min_eqd;
#line 344
  et->tx_coalesce_usecs = eqo->cur_eqd;
#line 345
  et->tx_coalesce_usecs_high = eqo->max_eqd;
#line 346
  et->tx_coalesce_usecs_low = eqo->min_eqd;
#line 348
  et->use_adaptive_rx_coalesce = (__u32 )eqo->enable_aic;
#line 349
  et->use_adaptive_tx_coalesce = (__u32 )eqo->enable_aic;
#line 351
  return (0);
}
}
#line 357 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  __u32 _min1 ;
  unsigned int _min2 ;
  __u32 _min1___0 ;
  u32 _min2___0 ;

  {
#line 360
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 360
  adapter = (struct be_adapter *)tmp;
#line 364
  i = 0;
#line 364
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 364
  goto ldv_50460;
  ldv_50459: 
#line 365
  eqo->enable_aic = et->use_adaptive_rx_coalesce != 0U;
#line 366
  _min1 = et->rx_coalesce_usecs_high;
#line 366
  _min2 = 96U;
#line 366
  eqo->max_eqd = _min1 < _min2 ? _min1 : _min2;
#line 367
  _min1___0 = et->rx_coalesce_usecs_low;
#line 367
  _min2___0 = eqo->max_eqd;
#line 367
  eqo->min_eqd = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 368
  eqo->eqd = et->rx_coalesce_usecs;
#line 364
  i = i + 1;
#line 364
  eqo = eqo + 1;
  ldv_50460: ;
#line 364
  if ((u32 )i < adapter->num_evt_qs) {
#line 366
    goto ldv_50459;
  } else {

  }

#line 371
  return (0);
}
}
#line 375 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                 uint64_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  void *p ;
  unsigned int i ;
  unsigned int j ;
  unsigned int base ;
  unsigned int start ;
  struct be_rx_stats *stats___0 ;
  bool tmp___0 ;
  struct be_tx_stats *stats___1 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 378
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 378
  adapter = (struct be_adapter *)tmp;
#line 382
  base = 0U;
#line 384
  i = 0U;
#line 384
  goto ldv_50478;
  ldv_50477: 
#line 385
  p = (void *)(& adapter->drv_stats) + (unsigned long )et_stats[i].offset;
#line 386
  *(data + (unsigned long )i) = (uint64_t )*((u32 *)p);
#line 384
  i = i + 1U;
  ldv_50478: ;
#line 384
  if (i <= 31U) {
#line 386
    goto ldv_50477;
  } else {

  }
#line 388
  base = base + 32U;
#line 390
  j = 0U;
#line 390
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 390
  goto ldv_50493;
  ldv_50492: 
#line 391
  stats___0 = & rxo->stats;
  ldv_50483: 
#line 394
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___0->sync));
#line 395
  *(data + (unsigned long )base) = stats___0->rx_bytes;
#line 396
  *(data + (unsigned long )(base + 1U)) = stats___0->rx_pkts;
#line 397
  tmp___0 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___0->sync),
                                     start);
#line 397
  if ((int )tmp___0) {
#line 399
    goto ldv_50483;
  } else {

  }
#line 399
  i = 2U;
#line 399
  goto ldv_50488;
  ldv_50487: 
#line 400
  p = (void *)stats___0 + (unsigned long )et_rx_stats[i].offset;
#line 401
  *(data + (unsigned long )(base + i)) = (uint64_t )*((u32 *)p);
#line 399
  i = i + 1U;
  ldv_50488: ;
#line 399
  if (i <= 6U) {
#line 401
    goto ldv_50487;
  } else {

  }
#line 403
  base = base + 7U;
#line 390
  j = j + 1U;
#line 390
  rxo = rxo + 1;
  ldv_50493: ;
#line 390
  if (adapter->num_rx_qs > j) {
#line 392
    goto ldv_50492;
  } else {

  }
#line 406
  j = 0U;
#line 406
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )j;
#line 406
  goto ldv_50508;
  ldv_50507: 
#line 407
  stats___1 = & txo->stats;
  ldv_50496: 
#line 410
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___1->sync_compl));
#line 411
  *(data + (unsigned long )base) = stats___1->tx_compl;
#line 412
  tmp___1 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___1->sync_compl),
                                     start);
#line 412
  if ((int )tmp___1) {
#line 414
    goto ldv_50496;
  } else {

  }

  ldv_50503: 
#line 415
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___1->sync));
#line 416
  i = 1U;
#line 416
  goto ldv_50501;
  ldv_50500: 
#line 417
  p = (void *)stats___1 + (unsigned long )et_tx_stats[i].offset;
#line 418
  *(data + (unsigned long )(base + i)) = et_tx_stats[i].size == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
#line 416
  i = i + 1U;
  ldv_50501: ;
#line 416
  if (i <= 5U) {
#line 418
    goto ldv_50500;
  } else {

  }
#line 422
  tmp___2 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___1->sync),
                                     start);
#line 422
  if ((int )tmp___2) {
#line 424
    goto ldv_50503;
  } else {

  }
#line 423
  base = base + 6U;
#line 406
  j = j + 1U;
#line 406
  txo = txo + 1;
  ldv_50508: ;
#line 406
  if (adapter->num_tx_qs > j) {
#line 408
    goto ldv_50507;
  } else {

  }

#line 413
  return;
}
}
#line 428 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_stat_strings(struct net_device *netdev , uint32_t stringset , uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 431
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 431
  adapter = (struct be_adapter *)tmp;
#line 434
  switch (stringset) {
  case 1U: 
#line 436
  i = 0;
#line 436
  goto ldv_50525;
  ldv_50524: 
#line 437
  __len = 32UL;
#line 437
  if (__len > 63UL) {
#line 437
    __ret = __memcpy((void *)data, (void const   *)(& et_stats[i].desc), __len);
  } else {
#line 437
    __ret = __builtin_memcpy((void *)data, (void const   *)(& et_stats[i].desc), __len);
  }
#line 438
  data = data + 32UL;
#line 436
  i = i + 1;
  ldv_50525: ;
#line 436
  if ((unsigned int )i <= 31U) {
#line 438
    goto ldv_50524;
  } else {

  }
#line 440
  i = 0;
#line 440
  goto ldv_50533;
  ldv_50532: 
#line 441
  j = 0;
#line 441
  goto ldv_50530;
  ldv_50529: 
#line 442
  sprintf((char *)data, "rxq%d: %s", i, (char const   *)(& et_rx_stats[j].desc));
#line 444
  data = data + 32UL;
#line 441
  j = j + 1;
  ldv_50530: ;
#line 441
  if ((unsigned int )j <= 6U) {
#line 443
    goto ldv_50529;
  } else {

  }
#line 440
  i = i + 1;
  ldv_50533: ;
#line 440
  if ((u32 )i < adapter->num_rx_qs) {
#line 442
    goto ldv_50532;
  } else {

  }
#line 447
  i = 0;
#line 447
  goto ldv_50541;
  ldv_50540: 
#line 448
  j = 0;
#line 448
  goto ldv_50538;
  ldv_50537: 
#line 449
  sprintf((char *)data, "txq%d: %s", i, (char const   *)(& et_tx_stats[j].desc));
#line 451
  data = data + 32UL;
#line 448
  j = j + 1;
  ldv_50538: ;
#line 448
  if ((unsigned int )j <= 5U) {
#line 450
    goto ldv_50537;
  } else {

  }
#line 447
  i = i + 1;
  ldv_50541: ;
#line 447
  if ((u32 )i < adapter->num_tx_qs) {
#line 449
    goto ldv_50540;
  } else {

  }

#line 454
  goto ldv_50543;
  case 0U: 
#line 456
  i = 0;
#line 456
  goto ldv_50551;
  ldv_50550: 
#line 457
  __len___0 = 32UL;
#line 457
  if (__len___0 > 63UL) {
#line 457
    __ret___0 = __memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i,
                         __len___0);
  } else {
#line 457
    __ret___0 = __builtin_memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i,
                                 __len___0);
  }
#line 458
  data = data + 32UL;
#line 456
  i = i + 1;
  ldv_50551: ;
#line 456
  if ((unsigned int )i <= 4U) {
#line 458
    goto ldv_50550;
  } else {

  }

#line 460
  goto ldv_50543;
  }
  ldv_50543: ;
#line 463
  return;
}
}
#line 464 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_sset_count(struct net_device *netdev , int stringset ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 466
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 466
  adapter = (struct be_adapter *)tmp;
#line 468
  switch (stringset) {
  case 0: ;
#line 470
  return (5);
  case 1: ;
#line 472
  return ((int )((adapter->num_rx_qs * 7U + adapter->num_tx_qs * 6U) + 32U));
  default: ;
#line 476
  return (-22);
  }
}
}
#line 480 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u32 be_get_port_type(u32 phy_type , u32 dac_cable_len ) 
{ 
  u32 port ;

  {
#line 484
  switch (phy_type) {
  case 7U: ;
  case 8U: ;
  case 9U: 
#line 488
  port = 0U;
#line 489
  goto ldv_50577;
  case 3U: 
#line 491
  port = dac_cable_len != 0U ? 5U : 3U;
#line 492
  goto ldv_50577;
  case 1U: ;
  case 2U: 
#line 495
  port = 3U;
#line 496
  goto ldv_50577;
  case 6U: 
#line 498
  port = 0U;
#line 499
  goto ldv_50577;
  default: 
#line 501
  port = 255U;
  }
  ldv_50577: ;
#line 504
  return (port);
}
}
#line 507 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u32 convert_to_et_setting(u32 if_type , u32 if_speeds ) 
{ 
  u32 val ;

  {
#line 509
  val = 0U;
#line 511
  switch (if_type) {
  case 7U: ;
  case 8U: ;
  case 9U: 
#line 515
  val = val | 128U;
#line 516
  if ((if_speeds & 4U) != 0U) {
#line 517
    val = val | 32U;
  } else {

  }
#line 518
  if ((if_speeds & 2U) != 0U) {
#line 519
    val = val | 8U;
  } else {

  }
#line 520
  if ((int )if_speeds & 1) {
#line 521
    val = val | 2U;
  } else {

  }
#line 522
  goto ldv_50591;
  case 5U: 
#line 524
  val = val | 65536U;
#line 525
  if ((if_speeds & 4U) != 0U) {
#line 526
    val = val | 131072U;
  } else {

  }
#line 527
  if ((if_speeds & 8U) != 0U) {
#line 528
    val = val | 262144U;
  } else {

  }
#line 529
  goto ldv_50591;
  case 4U: 
#line 531
  val = val | 589824U;
#line 533
  goto ldv_50591;
  case 3U: ;
  case 1U: ;
  case 2U: 
#line 537
  val = val | 1024U;
#line 538
  if ((if_speeds & 8U) != 0U) {
#line 539
    val = val | 4096U;
  } else {

  }
#line 540
  if ((if_speeds & 4U) != 0U) {
#line 541
    val = val | 32U;
  } else {

  }
#line 542
  goto ldv_50591;
  case 6U: 
#line 544
  val = val | 128U;
#line 545
  if ((if_speeds & 8U) != 0U) {
#line 546
    val = val | 4096U;
  } else {

  }
#line 547
  if ((if_speeds & 4U) != 0U) {
#line 548
    val = val | 32U;
  } else {

  }
#line 549
  if ((if_speeds & 2U) != 0U) {
#line 550
    val = val | 8U;
  } else {

  }
#line 551
  goto ldv_50591;
  default: 
#line 553
  val = val | 128U;
  }
  ldv_50591: ;
#line 556
  return (val);
}
}
#line 559 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
bool be_pause_supported(struct be_adapter *adapter ) 
{ 


  {
#line 561
  return ((bool )((unsigned int )adapter->phy.interface_type != 3U && (unsigned int )adapter->phy.interface_type != 1U));
}
}
#line 566 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 link_status ;
  u16 link_speed ;
  int status ;
  u32 auto_speeds ;
  u32 fixed_speeds ;
  u32 dac_cable_len ;
  u16 interface_type ;
  u32 tmp___0 ;
  bool tmp___1 ;
  __u32 tmp___2 ;
  bool tmp___3 ;

  {
#line 568
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 568
  adapter = (struct be_adapter *)tmp;
#line 570
  link_speed = 0U;
#line 577
  if (adapter->phy.link_speed < 0) {
#line 578
    status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
#line 580
    if (status == 0) {
#line 581
      be_link_status_update(adapter, (int )link_status);
    } else {

    }
#line 582
    ethtool_cmd_speed_set(ecmd, (__u32 )link_speed);
#line 584
    status = be_cmd_get_phy_info(adapter);
#line 585
    if (status == 0) {
#line 586
      interface_type = adapter->phy.interface_type;
#line 587
      auto_speeds = (u32 )adapter->phy.auto_speeds_supported;
#line 588
      fixed_speeds = (u32 )adapter->phy.fixed_speeds_supported;
#line 589
      dac_cable_len = adapter->phy.dac_cable_len;
#line 591
      ecmd->supported = convert_to_et_setting((u32 )interface_type, auto_speeds | fixed_speeds);
#line 595
      ecmd->advertising = convert_to_et_setting((u32 )interface_type, auto_speeds);
#line 599
      tmp___0 = be_get_port_type((u32 )interface_type, dac_cable_len);
#line 599
      ecmd->port = (__u8 )tmp___0;
#line 602
      if ((unsigned int )adapter->phy.auto_speeds_supported != 0U) {
#line 603
        ecmd->supported = ecmd->supported | 64U;
#line 604
        ecmd->autoneg = 1U;
#line 605
        ecmd->advertising = ecmd->advertising | 64U;
      } else {

      }
#line 608
      ecmd->supported = ecmd->supported | 8192U;
#line 609
      tmp___1 = be_pause_supported(adapter);
#line 609
      if ((int )tmp___1) {
#line 610
        ecmd->advertising = ecmd->advertising | 8192U;
      } else {

      }
#line 612
      switch ((int )adapter->phy.interface_type) {
      case 4: ;
      case 5: 
#line 615
      ecmd->transceiver = 0U;
#line 616
      goto ldv_50616;
      default: 
#line 618
      ecmd->transceiver = 1U;
#line 619
      goto ldv_50616;
      }
      ldv_50616: ;
    } else {
#line 622
      ecmd->port = 255U;
#line 623
      ecmd->autoneg = 0U;
#line 624
      ecmd->transceiver = 2U;
    }
#line 628
    tmp___2 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 628
    adapter->phy.link_speed = (int )tmp___2;
#line 629
    adapter->phy.port_type = ecmd->port;
#line 630
    adapter->phy.transceiver = ecmd->transceiver;
#line 631
    adapter->phy.autoneg = ecmd->autoneg;
#line 632
    adapter->phy.advertising = ecmd->advertising;
#line 633
    adapter->phy.supported = ecmd->supported;
  } else {
#line 635
    ethtool_cmd_speed_set(ecmd, (__u32 )adapter->phy.link_speed);
#line 636
    ecmd->port = adapter->phy.port_type;
#line 637
    ecmd->transceiver = adapter->phy.transceiver;
#line 638
    ecmd->autoneg = adapter->phy.autoneg;
#line 639
    ecmd->advertising = adapter->phy.advertising;
#line 640
    ecmd->supported = adapter->phy.supported;
  }
#line 643
  tmp___3 = netif_carrier_ok((struct net_device  const  *)netdev);
#line 643
  ecmd->duplex = (int )tmp___3 ? 1U : 255U;
#line 644
  ecmd->phy_address = (__u8 )adapter->port_num;
#line 646
  return (0);
}
}
#line 649 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 652
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 652
  adapter = (struct be_adapter *)tmp;
#line 654
  tmp___0 = (__u32 )adapter->rx_obj[0].q.len;
#line 654
  ring->rx_pending = tmp___0;
#line 654
  ring->rx_max_pending = tmp___0;
#line 655
  tmp___1 = (__u32 )adapter->tx_obj[0].q.len;
#line 655
  ring->tx_pending = tmp___1;
#line 655
  ring->tx_max_pending = tmp___1;
#line 656
  return;
}
}
#line 659 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 661
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 661
  adapter = (struct be_adapter *)tmp;
#line 663
  be_cmd_get_flow_control(adapter, & ecmd->tx_pause, & ecmd->rx_pause);
#line 664
  ecmd->autoneg = (__u32 )adapter->phy.fc_autoneg;
#line 665
  return;
}
}
#line 668 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
#line 670
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 670
  adapter = (struct be_adapter *)tmp;
#line 673
  if (ecmd->autoneg != (__u32 )adapter->phy.fc_autoneg) {
#line 674
    return (-22);
  } else {

  }
#line 675
  adapter->tx_fc = ecmd->tx_pause;
#line 676
  adapter->rx_fc = ecmd->rx_pause;
#line 678
  status = be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
#line 680
  if (status != 0) {
#line 681
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Pause param set failed.\n");
  } else {

  }
#line 683
  return (status);
}
}
#line 687 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 690
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 690
  adapter = (struct be_adapter *)tmp;
#line 692
  switch ((unsigned int )state) {
  case 1U: 
#line 694
  be_cmd_get_beacon_state(adapter, (int )adapter->hba_port_num, & adapter->beacon_state);
#line 696
  return (1);
  case 2U: 
#line 699
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 1);
#line 701
  goto ldv_50641;
  case 3U: 
#line 704
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 0);
#line 706
  goto ldv_50641;
  case 0U: 
#line 709
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, (int )((u8 )adapter->beacon_state));
  }
  ldv_50641: ;
#line 713
  return (0);
}
}
#line 718 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 720
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 720
  adapter = (struct be_adapter *)tmp;
#line 722
  tmp___0 = be_is_wol_supported(adapter);
#line 722
  if ((int )tmp___0) {
#line 723
    wol->supported = wol->supported | 32U;
#line 724
    if ((int )adapter->wol) {
#line 725
      wol->wolopts = wol->wolopts | 32U;
    } else {

    }
  } else {
#line 727
    wol->wolopts = 0U;
  }
#line 728
  memset((void *)(& wol->sopass), 0, 6UL);
#line 729
  return;
}
}
#line 732 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 734
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 734
  adapter = (struct be_adapter *)tmp;
#line 736
  if ((wol->wolopts & 4294967263U) != 0U) {
#line 737
    return (-95);
  } else {

  }
#line 739
  tmp___0 = be_is_wol_supported(adapter);
#line 739
  if (tmp___0) {
#line 739
    tmp___1 = 0;
  } else {
#line 739
    tmp___1 = 1;
  }
#line 739
  if (tmp___1) {
#line 740
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "WOL not supported\n");
#line 741
    return (-95);
  } else {

  }
#line 744
  if ((wol->wolopts & 32U) != 0U) {
#line 745
    adapter->wol = 1;
  } else {
#line 747
    adapter->wol = 0;
  }
#line 749
  return (0);
}
}
#line 753 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_test_ddr_dma(struct be_adapter *adapter ) 
{ 
  int ret ;
  int i ;
  struct be_dma_mem ddrdma_cmd ;
  u64 pattern[2U] ;

  {
#line 757
  pattern[0] = 6510615555426900570ULL;
#line 757
  pattern[1] = 0xa5a5a5a5a5a5a5a5ULL;
#line 761
  ddrdma_cmd.size = 8224U;
#line 762
  ddrdma_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size,
                                  & ddrdma_cmd.dma, 208U, 0);
#line 764
  if ((unsigned long )ddrdma_cmd.va == (unsigned long )((void *)0)) {
#line 765
    return (-12);
  } else {

  }
#line 767
  i = 0;
#line 767
  goto ldv_50663;
  ldv_50662: 
#line 768
  ret = be_cmd_ddr_dma_test(adapter, pattern[i], 4096U, & ddrdma_cmd);
#line 770
  if (ret != 0) {
#line 771
    goto err;
  } else {

  }
#line 767
  i = i + 1;
  ldv_50663: ;
#line 767
  if (i <= 1) {
#line 769
    goto ldv_50662;
  } else {

  }

  err: 
#line 775
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size, ddrdma_cmd.va,
                 ddrdma_cmd.dma, 0);
#line 777
  return (ret);
}
}
#line 780 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u64 be_loopback_test(struct be_adapter *adapter , u8 loopback_type , u64 *status ) 
{ 
  int tmp ;

  {
#line 783
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, (int )loopback_type, 1);
#line 785
  tmp = be_cmd_loopback_test(adapter, (u32 )adapter->hba_port_num, (u32 )loopback_type,
                             1500U, 2U, 2748ULL);
#line 785
  *status = (u64 )tmp;
#line 788
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, 255, 1);
#line 790
  return (*status);
}
}
#line 794 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_self_test(struct net_device *netdev , struct ethtool_test *test , u64 *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 link_status ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  int tmp___3 ;

  {
#line 796
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 796
  adapter = (struct be_adapter *)tmp;
#line 798
  link_status = 0U;
#line 800
  if ((adapter->function_caps & 64U) != 0U) {
#line 801
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Self test not supported\n");
#line 802
    test->flags = test->flags | 2U;
#line 803
    return;
  } else {

  }
#line 806
  memset((void *)data, 0, 40UL);
#line 808
  if ((int )test->flags & 1) {
#line 809
    tmp___0 = be_loopback_test(adapter, 0, data);
#line 809
    if (tmp___0 != 0ULL) {
#line 811
      test->flags = test->flags | 2U;
    } else {

    }
#line 813
    tmp___1 = be_loopback_test(adapter, 1, data + 1UL);
#line 813
    if (tmp___1 != 0ULL) {
#line 815
      test->flags = test->flags | 2U;
    } else {

    }
#line 817
    tmp___2 = be_loopback_test(adapter, 2, data + 2UL);
#line 817
    if (tmp___2 != 0ULL) {
#line 819
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
#line 823
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 823
    tmp___3 = be_test_ddr_dma(adapter);
#line 823
    if (tmp___3 != 0) {
#line 824
      *(data + 3UL) = 1ULL;
#line 825
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
#line 828
  status = be_cmd_link_status_query(adapter, 0, & link_status, 0U);
#line 829
  if (status != 0) {
#line 830
    test->flags = test->flags | 2U;
#line 831
    *(data + 4UL) = 0xffffffffffffffffULL;
  } else
#line 832
  if ((unsigned int )link_status == 0U) {
#line 833
    test->flags = test->flags | 2U;
#line 834
    *(data + 4UL) = 1ULL;
  } else {

  }
#line 836
  return;
}
}
#line 839 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_do_flash(struct net_device *netdev , struct ethtool_flash *efl ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 841
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 841
  adapter = (struct be_adapter *)tmp;
#line 843
  tmp___0 = be_load_fw(adapter, (u8 *)(& efl->data));
#line 843
  return (tmp___0);
}
}
#line 847 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
#line 849
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 849
  adapter = (struct be_adapter *)tmp;
#line 851
  tmp___0 = check_privilege(adapter, 1792U);
#line 851
  if (tmp___0) {
#line 851
    tmp___1 = 0;
  } else {
#line 851
    tmp___1 = 1;
  }
#line 851
  if (tmp___1) {
#line 852
    return (0);
  } else {

  }
#line 854
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 855
    if ((unsigned int )adapter->virtfn == 0U) {
#line 856
      tmp___2 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_pf.vpd");
#line 856
      return ((int )tmp___2);
    } else {
#line 859
      tmp___3 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_vf.vpd");
#line 859
      return ((int )tmp___3);
    }
  } else {
#line 862
    return (1024);
  }
}
}
#line 867 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_read_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                          uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_dma_mem eeprom_cmd ;
  struct be_cmd_resp_seeprom_read *resp ;
  int status ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 870
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 870
  adapter = (struct be_adapter *)tmp;
#line 875
  if (eeprom->len == 0U) {
#line 876
    return (-22);
  } else {

  }
#line 878
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 879
    if ((unsigned int )adapter->virtfn == 0U) {
#line 880
      tmp___0 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_pf.vpd", eeprom->len,
                                     (void *)data);
#line 880
      return (tmp___0);
    } else {
#line 883
      tmp___1 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_vf.vpd", eeprom->len,
                                     (void *)data);
#line 883
      return (tmp___1);
    }
  } else {

  }
#line 887
  eeprom->magic = (__u32 )(((int )(adapter->pdev)->device << 16) | 6562);
#line 889
  memset((void *)(& eeprom_cmd), 0, 24UL);
#line 890
  eeprom_cmd.size = 1040U;
#line 891
  eeprom_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size,
                                  & eeprom_cmd.dma, 208U, 0);
#line 894
  if ((unsigned long )eeprom_cmd.va == (unsigned long )((void *)0)) {
#line 895
    return (-12);
  } else {

  }
#line 897
  status = be_cmd_get_seeprom_data(adapter, & eeprom_cmd);
#line 899
  if (status == 0) {
#line 900
    resp = (struct be_cmd_resp_seeprom_read *)eeprom_cmd.va;
#line 901
    __len = (size_t )eeprom->len;
#line 901
    __ret = __builtin_memcpy((void *)data, (void const   *)(& resp->seeprom_data) + (unsigned long )eeprom->offset,
                             __len);
  } else {

  }
#line 903
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size, eeprom_cmd.va,
                 eeprom_cmd.dma, 0);
#line 906
  return (status);
}
}
#line 909 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u32 be_get_msg_level(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 911
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 911
  adapter = (struct be_adapter *)tmp;
#line 913
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 914
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Operation not supported\n");
#line 915
    return (4294967201U);
  } else {

  }
#line 918
  return (adapter->msg_enable);
}
}
#line 921 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_set_fw_log_level(struct be_adapter *adapter , u32 level ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int i ;
  int j ;
  u32 num_modes ;

  {
#line 928
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 929
  extfat_cmd.size = 2844U;
#line 930
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
#line 932
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 933
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%s: Memory allocation failure\n",
            "be_set_fw_log_level");
#line 935
    goto err;
  } else {

  }
#line 937
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
#line 938
  if (status == 0) {
#line 939
    cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 941
    i = 0;
#line 941
    goto ldv_50721;
    ldv_50720: 
#line 942
    num_modes = cfgs->module[i].num_modes;
#line 943
    j = 0;
#line 943
    goto ldv_50718;
    ldv_50717: ;
#line 944
    if ((unsigned int )cfgs->module[i].trace_lvl[j].mode == 0U) {
#line 946
      cfgs->module[i].trace_lvl[j].dbg_lvl = level;
    } else {

    }
#line 943
    j = j + 1;
    ldv_50718: ;
#line 943
    if ((u32 )j < num_modes) {
#line 945
      goto ldv_50717;
    } else {

    }
#line 941
    i = i + 1;
    ldv_50721: ;
#line 941
    if ((u32 )i < cfgs->num_modules) {
#line 943
      goto ldv_50720;
    } else {

    }
#line 950
    status = be_cmd_set_ext_fat_capabilites(adapter, & extfat_cmd, cfgs);
#line 952
    if (status != 0) {
#line 953
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Message level set failed\n");
    } else {

    }
  } else {
#line 956
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Message level get failed\n");
  }
#line 959
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
  err: ;
#line 962
  return;
}
}
#line 965 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static void be_set_msg_level(struct net_device *netdev , u32 level ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
#line 967
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 967
  adapter = (struct be_adapter *)tmp;
#line 969
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 970
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Operation not supported\n");
#line 971
    return;
  } else {

  }
#line 974
  if (adapter->msg_enable == level) {
#line 975
    return;
  } else {

  }
#line 977
  if (((adapter->msg_enable ^ level) & 8192U) != 0U) {
#line 978
    be_set_fw_log_level(adapter, (level & 8192U) != 0U ? 48U : 64U);
  } else {

  }
#line 980
  adapter->msg_enable = level;
#line 982
  return;
}
}
#line 985 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static u64 be_get_rss_hash_opts(struct be_adapter *adapter , u64 flow_type ) 
{ 
  u64 data ;

  {
#line 987
  data = 0ULL;
#line 989
  switch (flow_type) {
  case 1ULL: ;
#line 991
  if ((int )adapter->rss_flags & 1) {
#line 992
    data = data | 48ULL;
  } else {

  }
#line 993
  if ((adapter->rss_flags & 2ULL) != 0ULL) {
#line 994
    data = data | 192ULL;
  } else {

  }
#line 995
  goto ldv_50734;
  case 2ULL: ;
#line 997
  if ((int )adapter->rss_flags & 1) {
#line 998
    data = data | 48ULL;
  } else {

  }
#line 999
  if ((adapter->rss_flags & 16ULL) != 0ULL) {
#line 1000
    data = data | 192ULL;
  } else {

  }
#line 1001
  goto ldv_50734;
  case 5ULL: ;
#line 1003
  if ((adapter->rss_flags & 4ULL) != 0ULL) {
#line 1004
    data = data | 48ULL;
  } else {

  }
#line 1005
  if ((adapter->rss_flags & 8ULL) != 0ULL) {
#line 1006
    data = data | 192ULL;
  } else {

  }
#line 1007
  goto ldv_50734;
  case 6ULL: ;
#line 1009
  if ((adapter->rss_flags & 4ULL) != 0ULL) {
#line 1010
    data = data | 48ULL;
  } else {

  }
#line 1011
  if ((adapter->rss_flags & 32ULL) != 0ULL) {
#line 1012
    data = data | 192ULL;
  } else {

  }
#line 1013
  goto ldv_50734;
  }
  ldv_50734: ;
#line 1016
  return (data);
}
}
#line 1019 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_get_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1022
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1022
  adapter = (struct be_adapter *)tmp;
#line 1024
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1024
  if (tmp___0) {
#line 1024
    tmp___1 = 0;
  } else {
#line 1024
    tmp___1 = 1;
  }
#line 1024
  if (tmp___1) {
#line 1025
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::get_rxnfc: RX flow hashing is disabled\n");
#line 1027
    return (-22);
  } else {

  }
#line 1030
  switch (cmd->cmd) {
  case 41U: 
#line 1032
  cmd->data = be_get_rss_hash_opts(adapter, (u64 )cmd->flow_type);
#line 1033
  goto ldv_50745;
  case 45U: 
#line 1035
  cmd->data = (__u64 )(adapter->num_rx_qs - 1U);
#line 1036
  goto ldv_50745;
  default: ;
#line 1038
  return (-22);
  }
  ldv_50745: ;
#line 1041
  return (0);
}
}
#line 1044 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_rss_hash_opts(struct be_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_rx_obj *rxo ;
  int status ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  u32 rss_flags ;
  bool tmp ;

  {
#line 1048
  status = 0;
#line 1050
  rss_flags = (u32 )adapter->rss_flags;
#line 1052
  if (cmd->data != 48ULL && cmd->data != 240ULL) {
#line 1054
    return (-22);
  } else {

  }
#line 1056
  switch (cmd->flow_type) {
  case 1U: ;
#line 1058
  if (cmd->data == 48ULL) {
#line 1059
    rss_flags = rss_flags & 4294967293U;
  } else
#line 1060
  if (cmd->data == 240ULL) {
#line 1061
    rss_flags = rss_flags | 3U;
  } else {

  }
#line 1063
  goto ldv_50759;
  case 5U: ;
#line 1065
  if (cmd->data == 48ULL) {
#line 1066
    rss_flags = rss_flags & 4294967287U;
  } else
#line 1067
  if (cmd->data == 240ULL) {
#line 1068
    rss_flags = rss_flags | 12U;
  } else {

  }
#line 1070
  goto ldv_50759;
  case 2U: ;
#line 1072
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1074
    return (-22);
  } else {

  }
#line 1076
  if (cmd->data == 48ULL) {
#line 1077
    rss_flags = rss_flags & 4294967279U;
  } else
#line 1078
  if (cmd->data == 240ULL) {
#line 1079
    rss_flags = rss_flags | 17U;
  } else {

  }
#line 1081
  goto ldv_50759;
  case 6U: ;
#line 1083
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1085
    return (-22);
  } else {

  }
#line 1087
  if (cmd->data == 48ULL) {
#line 1088
    rss_flags = rss_flags & 4294967263U;
  } else
#line 1089
  if (cmd->data == 240ULL) {
#line 1090
    rss_flags = rss_flags | 36U;
  } else {

  }
#line 1092
  goto ldv_50759;
  default: ;
#line 1094
  return (-22);
  }
  ldv_50759: ;
#line 1097
  if ((u64 )rss_flags == adapter->rss_flags) {
#line 1098
    return (status);
  } else {

  }
#line 1100
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1100
  if ((int )tmp) {
#line 1101
    j = 0;
#line 1101
    goto ldv_50768;
    ldv_50767: 
#line 1102
    i = 0;
#line 1102
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 1102
    goto ldv_50766;
    ldv_50765: ;
#line 1103
    if (j + i > 127) {
#line 1104
      goto ldv_50764;
    } else {

    }
#line 1105
    rsstable[j + i] = rxo->rss_id;
#line 1102
    i = i + 1;
#line 1102
    rxo = rxo + 1;
    ldv_50766: ;
#line 1102
    if ((u32 )i < adapter->num_rx_qs - 1U) {
#line 1104
      goto ldv_50765;
    } else {

    }
    ldv_50764: 
#line 1101
    j = (int )((adapter->num_rx_qs + (u32 )j) - 1U);
    ldv_50768: ;
#line 1101
    if (j <= 127) {
#line 1103
      goto ldv_50767;
    } else {

    }

  } else {

  }
#line 1109
  status = be_cmd_rss_config(adapter, (u8 *)(& rsstable), rss_flags, 128);
#line 1110
  if (status == 0) {
#line 1111
    adapter->rss_flags = (u64 )rss_flags;
  } else {

  }
#line 1113
  return (status);
}
}
#line 1116 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
static int be_set_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1118
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1118
  adapter = (struct be_adapter *)tmp;
#line 1119
  status = 0;
#line 1121
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
#line 1121
  if (tmp___0) {
#line 1121
    tmp___1 = 0;
  } else {
#line 1121
    tmp___1 = 1;
  }
#line 1121
  if (tmp___1) {
#line 1122
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::set_rxnfc: RX flow hashing is disabled\n");
#line 1124
    return (-22);
  } else {

  }
#line 1127
  switch (cmd->cmd) {
  case 42U: 
#line 1129
  status = be_set_rss_hash_opts(adapter, cmd);
#line 1130
  goto ldv_50777;
  default: ;
#line 1132
  return (-22);
  }
  ldv_50777: ;
#line 1135
  return (status);
}
}
#line 1138 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
struct ethtool_ops  const  be_ethtool_ops  = 
#line 1138
     {& be_get_settings, 0, & be_get_drvinfo, & be_get_reg_len, & be_get_regs, & be_get_wol,
    & be_set_wol, & be_get_msg_level, & be_set_msg_level, 0, & ethtool_op_get_link,
    & be_get_eeprom_len, & be_read_eeprom, 0, & be_get_coalesce, & be_set_coalesce,
    & be_get_ringparam, 0, & be_get_pauseparam, & be_set_pauseparam, & be_self_test,
    & be_get_stat_strings, & be_set_phys_id, & be_get_ethtool_stats, 0, 0, 0, 0, & be_get_sset_count,
    & be_get_rxnfc, & be_set_rxnfc, & be_do_flash, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0};
#line 1202 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void main(void) 
{ 
  struct net_device *var_group1 ;
  struct ethtool_cmd *var_group2 ;
  struct ethtool_drvinfo *var_group3 ;
  struct ethtool_wolinfo *var_group4 ;
  struct ethtool_eeprom *var_group5 ;
  uint8_t *var_be_read_eeprom_25_p2 ;
  struct ethtool_coalesce *var_group6 ;
  struct ethtool_ringparam *var_group7 ;
  struct ethtool_pauseparam *var_group8 ;
  uint32_t var_be_get_stat_strings_8_p1 ;
  uint8_t *var_be_get_stat_strings_8_p2 ;
  enum ethtool_phys_id_state var_be_set_phys_id_17_p1 ;
  u32 var_be_set_msg_level_28_p1 ;
  int var_be_get_sset_count_9_p1 ;
  struct ethtool_stats *var_group9 ;
  uint64_t *var_be_get_ethtool_stats_7_p2 ;
  struct ethtool_regs *var_group10 ;
  void *var_be_get_regs_4_p2 ;
  struct ethtool_flash *var_group11 ;
  struct ethtool_test *var_group12 ;
  u64 *var_be_self_test_22_p2 ;
  struct ethtool_rxnfc *var_group13 ;
  u32 *var_be_get_rxnfc_30_p2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1699
  LDV_IN_INTERRUPT = 1;
#line 1708
  ldv_initialize();
#line 1712
  goto ldv_50845;
  ldv_50844: 
#line 1715
  tmp = __VERIFIER_nondet_int();
#line 1715
  switch (tmp) {
  case 0: 
#line 1742
  ldv_handler_precall();
#line 1743
  be_get_settings(var_group1, var_group2);
#line 1750
  goto ldv_50820;
  case 1: 
#line 1776
  ldv_handler_precall();
#line 1777
  be_get_drvinfo(var_group1, var_group3);
#line 1784
  goto ldv_50820;
  case 2: 
#line 1810
  ldv_handler_precall();
#line 1811
  be_get_wol(var_group1, var_group4);
#line 1818
  goto ldv_50820;
  case 3: 
#line 1844
  ldv_handler_precall();
#line 1845
  be_set_wol(var_group1, var_group4);
#line 1852
  goto ldv_50820;
  case 4: 
#line 1878
  ldv_handler_precall();
#line 1879
  be_get_eeprom_len(var_group1);
#line 1886
  goto ldv_50820;
  case 5: 
#line 1912
  ldv_handler_precall();
#line 1913
  be_read_eeprom(var_group1, var_group5, var_be_read_eeprom_25_p2);
#line 1920
  goto ldv_50820;
  case 6: 
#line 1946
  ldv_handler_precall();
#line 1947
  be_get_coalesce(var_group1, var_group6);
#line 1954
  goto ldv_50820;
  case 7: 
#line 1980
  ldv_handler_precall();
#line 1981
  be_set_coalesce(var_group1, var_group6);
#line 1988
  goto ldv_50820;
  case 8: 
#line 2014
  ldv_handler_precall();
#line 2015
  be_get_ringparam(var_group1, var_group7);
#line 2022
  goto ldv_50820;
  case 9: 
#line 2048
  ldv_handler_precall();
#line 2049
  be_get_pauseparam(var_group1, var_group8);
#line 2056
  goto ldv_50820;
  case 10: 
#line 2082
  ldv_handler_precall();
#line 2083
  be_set_pauseparam(var_group1, var_group8);
#line 2090
  goto ldv_50820;
  case 11: 
#line 2116
  ldv_handler_precall();
#line 2117
  be_get_stat_strings(var_group1, var_be_get_stat_strings_8_p1, var_be_get_stat_strings_8_p2);
#line 2124
  goto ldv_50820;
  case 12: 
#line 2150
  ldv_handler_precall();
#line 2151
  be_set_phys_id(var_group1, var_be_set_phys_id_17_p1);
#line 2158
  goto ldv_50820;
  case 13: 
#line 2184
  ldv_handler_precall();
#line 2185
  be_get_msg_level(var_group1);
#line 2192
  goto ldv_50820;
  case 14: 
#line 2218
  ldv_handler_precall();
#line 2219
  be_set_msg_level(var_group1, var_be_set_msg_level_28_p1);
#line 2226
  goto ldv_50820;
  case 15: 
#line 2252
  ldv_handler_precall();
#line 2253
  be_get_sset_count(var_group1, var_be_get_sset_count_9_p1);
#line 2260
  goto ldv_50820;
  case 16: 
#line 2286
  ldv_handler_precall();
#line 2287
  be_get_ethtool_stats(var_group1, var_group9, var_be_get_ethtool_stats_7_p2);
#line 2294
  goto ldv_50820;
  case 17: 
#line 2320
  ldv_handler_precall();
#line 2321
  be_get_reg_len(var_group1);
#line 2328
  goto ldv_50820;
  case 18: 
#line 2354
  ldv_handler_precall();
#line 2355
  be_get_regs(var_group1, var_group10, var_be_get_regs_4_p2);
#line 2362
  goto ldv_50820;
  case 19: 
#line 2388
  ldv_handler_precall();
#line 2389
  be_do_flash(var_group1, var_group11);
#line 2396
  goto ldv_50820;
  case 20: 
#line 2422
  ldv_handler_precall();
#line 2423
  be_self_test(var_group1, var_group12, var_be_self_test_22_p2);
#line 2430
  goto ldv_50820;
  case 21: 
#line 2456
  ldv_handler_precall();
#line 2457
  be_get_rxnfc(var_group1, var_group13, var_be_get_rxnfc_30_p2);
#line 2464
  goto ldv_50820;
  case 22: 
#line 2490
  ldv_handler_precall();
#line 2491
  be_set_rxnfc(var_group1, var_group13);
#line 2498
  goto ldv_50820;
  default: ;
#line 2499
  goto ldv_50820;
  }
  ldv_50820: ;
  ldv_50845: 
#line 1712
  tmp___0 = __VERIFIER_nondet_int();
#line 1712
  if (tmp___0 != 0) {
#line 1714
    goto ldv_50844;
  } else {

  }


#line 2508
  ldv_check_final_state();
#line 2511
  return;
}
}
#line 2515 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2520
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2522
  mutex_lock(ldv_func_arg1);
#line 2523
  return;
}
}
#line 2525 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2530
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2532
  mutex_unlock(ldv_func_arg1);
#line 2533
  return;
}
}
#line 2535 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2540
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2542
  mutex_lock(ldv_func_arg1);
#line 2543
  return;
}
}
#line 2545 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
int ldv_mutex_trylock_92(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2550
  tmp = mutex_trylock(ldv_func_arg1);
#line 2550
  ldv_func_res = tmp;
#line 2552
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2552
  return (tmp___0);
#line 2554
  return (ldv_func_res);
}
}
#line 2557 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_ethtool.c.prepared"
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2562
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2564
  mutex_unlock(ldv_func_arg1);
#line 2565
  return;
}
}
#line 47 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 174 "include/linux/mutex.h"
int ldv_mutex_trylock_102(struct mutex *ldv_func_arg1 ) ;
#line 179
void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) ;
#line 183
void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) ;
#line 187
void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) ;
#line 191
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) ;
#line 195
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) ;
#line 199
void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1 ) ;
#line 203
void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) ;
#line 207
void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) ;
#line 211
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_101(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_108(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_112(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) ;
#line 43
void ldv_mutex_lock_be_adapter_list_lock(struct mutex *lock ) ;
#line 47
void ldv_mutex_unlock_be_adapter_list_lock(struct mutex *lock ) ;
#line 2352 "include/linux/netdevice.h"
__inline static bool netif_oper_up(struct net_device  const  *dev ) 
{ 


  {
#line 2354
  return ((bool )((unsigned int )((unsigned char )dev->operstate) == 6U || (unsigned int )((unsigned char )dev->operstate) == 0U));
}
}
#line 68 "/work/ldvuser/exper_fp/inst/current/envs/linux-3.10-rc1.tar/linux-3.10-rc1/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_register_driver(struct ocrdma_driver *drv ) ;
#line 69
void be_roce_unregister_driver(struct ocrdma_driver *drv ) ;
#line 65 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
static struct ocrdma_driver *ocrdma_drv  ;
#line 66 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
static struct list_head be_adapter_list  =    {& be_adapter_list, & be_adapter_list};
#line 67 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
static struct mutex be_adapter_list_lock  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "be_adapter_list_lock.wait_lock",
                                                                     0, 0UL}}}}, {& be_adapter_list_lock.wait_list,
                                                                                  & be_adapter_list_lock.wait_list},
    0, 0, (void *)(& be_adapter_list_lock), {0, {0, 0}, "be_adapter_list_lock", 0,
                                             0UL}};
#line 69 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
static void _be_roce_dev_add(struct be_adapter *adapter ) 
{ 
  struct be_dev_info dev_info ;
  int i ;
  int num_vec ;
  struct pci_dev *pdev ;
  size_t __len ;
  void *__ret ;
  int _min1 ;
  int _min2 ;

  {
#line 73
  pdev = adapter->pdev;
#line 75
  if ((unsigned long )ocrdma_drv == (unsigned long )((struct ocrdma_driver *)0)) {
#line 76
    return;
  } else {

  }
#line 77
  if ((unsigned int )pdev->device == 1824U) {
#line 79
    if (adapter->num_msix_vec == 0U) {
#line 80
      return;
    } else {

    }
#line 82
    dev_info.dpp_unmapped_addr = pdev->resource[2].start;
#line 83
    dev_info.dpp_unmapped_len = pdev->resource[2].start != 0ULL || pdev->resource[2].end != pdev->resource[2].start ? ((u32 )pdev->resource[2].end - (u32 )pdev->resource[2].start) + 1U : 0U;
  } else {
#line 85
    dev_info.dpp_unmapped_addr = 0ULL;
#line 86
    dev_info.dpp_unmapped_len = 0U;
  }
#line 88
  dev_info.pdev = adapter->pdev;
#line 89
  dev_info.db = adapter->db;
#line 90
  dev_info.unmapped_db = adapter->roce_db.io_addr;
#line 91
  dev_info.db_page_size = adapter->roce_db.size;
#line 92
  dev_info.db_total_size = adapter->roce_db.total_size;
#line 93
  dev_info.netdev = adapter->netdev;
#line 94
  __len = 6UL;
#line 94
  if (__len > 63UL) {
#line 94
    __ret = __memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
                     __len);
  } else {
#line 94
    __ret = __builtin_memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
                             __len);
  }
#line 95
  dev_info.dev_family = adapter->sli_family;
#line 96
  if (adapter->num_msix_vec != 0U) {
#line 100
    num_vec = (int )(adapter->num_msix_vec + adapter->num_msix_roce_vec);
#line 101
    dev_info.intr_mode = 0;
#line 102
    _min1 = num_vec;
#line 102
    _min2 = 16;
#line 102
    dev_info.msix.num_vectors = _min1 < _min2 ? _min1 : _min2;
#line 107
    dev_info.msix.start_vector = (int )adapter->num_evt_qs;
#line 108
    i = 0;
#line 108
    goto ldv_51238;
    ldv_51237: 
#line 109
    dev_info.msix.vector_list[i] = adapter->msix_entries[i].vector;
#line 108
    i = i + 1;
    ldv_51238: ;
#line 108
    if (dev_info.msix.num_vectors > i) {
#line 110
      goto ldv_51237;
    } else {

    }

  } else {
#line 113
    dev_info.msix.num_vectors = 0;
#line 114
    dev_info.intr_mode = 1;
  }
#line 116
  adapter->ocrdma_dev = (*(ocrdma_drv->add))(& dev_info);
#line 117
  return;
}
}
#line 119 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void be_roce_dev_add(struct be_adapter *adapter ) 
{ 


  {
#line 121
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 122
    INIT_LIST_HEAD(& adapter->entry);
#line 123
    ldv_mutex_lock_104(& be_adapter_list_lock);
#line 124
    list_add_tail(& adapter->entry, & be_adapter_list);
#line 130
    _be_roce_dev_add(adapter);
#line 131
    ldv_mutex_unlock_105(& be_adapter_list_lock);
  } else {

  }
#line 133
  return;
}
}
#line 135 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void _be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 137
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )ocrdma_drv->remove != (unsigned long )((void (*)(struct ocrdma_dev * ))0)) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 138
    (*(ocrdma_drv->remove))(adapter->ocrdma_dev);
  } else {

  }
#line 139
  adapter->ocrdma_dev = 0;
#line 140
  return;
}
}
#line 142 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 144
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 145
    ldv_mutex_lock_106(& be_adapter_list_lock);
#line 146
    _be_roce_dev_remove(adapter);
#line 147
    list_del(& adapter->entry);
#line 148
    ldv_mutex_unlock_107(& be_adapter_list_lock);
  } else {

  }
#line 150
  return;
}
}
#line 152 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void _be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 154
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 156
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 0U);
  } else {

  }
#line 157
  return;
}
}
#line 159 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 161
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 162
    ldv_mutex_lock_108(& be_adapter_list_lock);
#line 163
    _be_roce_dev_open(adapter);
#line 164
    ldv_mutex_unlock_109(& be_adapter_list_lock);
  } else {

  }
#line 166
  return;
}
}
#line 168 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void _be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 170
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
#line 172
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 1U);
  } else {

  }
#line 173
  return;
}
}
#line 175 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 177
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 178
    ldv_mutex_lock_110(& be_adapter_list_lock);
#line 179
    _be_roce_dev_close(adapter);
#line 180
    ldv_mutex_unlock_111(& be_adapter_list_lock);
  } else {

  }
#line 182
  return;
}
}
#line 184 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
int be_roce_register_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct net_device *netdev ;
  bool tmp ;
  bool tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 188
  ldv_mutex_lock_112(& be_adapter_list_lock);
#line 189
  if ((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0)) {
#line 190
    ldv_mutex_unlock_113(& be_adapter_list_lock);
#line 191
    return (-22);
  } else {

  }
#line 193
  ocrdma_drv = drv;
#line 194
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 194
  dev = (struct be_adapter *)__mptr + 0xfffffffffffa6d38UL;
#line 194
  goto ldv_51271;
  ldv_51270: 
#line 196
  _be_roce_dev_add(dev);
#line 197
  netdev = dev->netdev;
#line 198
  tmp = netif_running((struct net_device  const  *)netdev);
#line 198
  if ((int )tmp) {
#line 198
    tmp___0 = netif_oper_up((struct net_device  const  *)netdev);
#line 198
    if ((int )tmp___0) {
#line 199
      _be_roce_dev_open(dev);
    } else {

    }
  } else {

  }
#line 194
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 194
  dev = (struct be_adapter *)__mptr___0 + 0xfffffffffffa6d38UL;
  ldv_51271: ;
#line 194
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 196
    goto ldv_51270;
  } else {

  }
#line 201
  ldv_mutex_unlock_114(& be_adapter_list_lock);
#line 202
  return (0);
}
}
#line 206 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void be_roce_unregister_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 210
  ldv_mutex_lock_115(& be_adapter_list_lock);
#line 211
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 211
  dev = (struct be_adapter *)__mptr + 0xfffffffffffa6d38UL;
#line 211
  goto ldv_51288;
  ldv_51287: ;
#line 212
  if ((unsigned long )dev->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
#line 213
    _be_roce_dev_remove(dev);
  } else {

  }
#line 211
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 211
  dev = (struct be_adapter *)__mptr___0 + 0xfffffffffffa6d38UL;
  ldv_51288: ;
#line 211
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 213
    goto ldv_51287;
  } else {

  }
#line 215
  ocrdma_drv = 0;
#line 216
  ldv_mutex_unlock_116(& be_adapter_list_lock);
#line 217
  return;
}
}
#line 220 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 225
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 227
  mutex_lock(ldv_func_arg1);
#line 228
  return;
}
}
#line 230 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 235
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 237
  mutex_unlock(ldv_func_arg1);
#line 238
  return;
}
}
#line 240 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 245
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 247
  mutex_lock(ldv_func_arg1);
#line 248
  return;
}
}
#line 250 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
int ldv_mutex_trylock_102(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 255
  tmp = mutex_trylock(ldv_func_arg1);
#line 255
  ldv_func_res = tmp;
#line 257
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 257
  return (tmp___0);
#line 259
  return (ldv_func_res);
}
}
#line 262 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 267
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 269
  mutex_unlock(ldv_func_arg1);
#line 270
  return;
}
}
#line 272 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 277
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 279
  mutex_lock(ldv_func_arg1);
#line 280
  return;
}
}
#line 282 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 287
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 289
  mutex_unlock(ldv_func_arg1);
#line 290
  return;
}
}
#line 292 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 297
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 299
  mutex_lock(ldv_func_arg1);
#line 300
  return;
}
}
#line 302 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 307
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 309
  mutex_unlock(ldv_func_arg1);
#line 310
  return;
}
}
#line 312 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 317
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 319
  mutex_lock(ldv_func_arg1);
#line 320
  return;
}
}
#line 322 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 327
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 329
  mutex_unlock(ldv_func_arg1);
#line 330
  return;
}
}
#line 332 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 337
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 339
  mutex_lock(ldv_func_arg1);
#line 340
  return;
}
}
#line 342 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 347
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 349
  mutex_unlock(ldv_func_arg1);
#line 350
  return;
}
}
#line 352 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_112(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 357
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 359
  mutex_lock(ldv_func_arg1);
#line 360
  return;
}
}
#line 362 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 367
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 369
  mutex_unlock(ldv_func_arg1);
#line 370
  return;
}
}
#line 372 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 377
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 379
  mutex_unlock(ldv_func_arg1);
#line 380
  return;
}
}
#line 382 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 387
  ldv_mutex_lock_be_adapter_list_lock(ldv_func_arg1);
#line 389
  mutex_lock(ldv_func_arg1);
#line 390
  return;
}
}
#line 392 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/dscv/ri/32_7a/drivers/net/ethernet/emulex/benet/be_roce.c.prepared"
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 397
  ldv_mutex_unlock_be_adapter_list_lock(ldv_func_arg1);
#line 399
  mutex_unlock(ldv_func_arg1);
#line 400
  return;
}
}
#line 10 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_be_adapter_list_lock  ;
#line 11 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_be_adapter_list_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_be_adapter_list_lock = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_be_adapter_list_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_be_adapter_list_lock = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_be_adapter_list_lock(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_be_adapter_list_lock = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_be_adapter_list_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_be_adapter_list_lock = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_be_adapter_list_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_be_adapter_list_lock = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_be_adapter_list_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_be_adapter_list_lock == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_be_adapter_list_lock(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_be_adapter_list_lock == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_be_adapter_list_lock = 1;
#line 158
  return;
}
}
#line 160 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 163 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_lock == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_lock = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_lock == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_lock = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_lock == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_lock = 2;
#line 221
  return;
}
}
#line 224 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_lock == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_lock = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_lock == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_lock = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_lock == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_lock == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_lock = 1;
#line 310
  return;
}
}
#line 312 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mbox_lock_of_be_adapter  ;
#line 315 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 320
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_mbox_lock_of_be_adapter = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 346
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_mbox_lock_of_be_adapter = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 


  {
#line 370
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_mbox_lock_of_be_adapter = 2;
#line 373
  return;
}
}
#line 376 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_mbox_lock_of_be_adapter = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mbox_lock_of_be_adapter(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_mbox_lock_of_be_adapter = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 431
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mbox_lock_of_be_adapter(struct mutex *lock ) 
{ 


  {
#line 459
  if (ldv_mutex_mbox_lock_of_be_adapter == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_mbox_lock_of_be_adapter = 1;
#line 462
  return;
}
}
#line 464 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  ;
#line 467 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 472
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_mutex_of_device = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 498
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_mutex_of_device = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 522
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_mutex_of_device = 2;
#line 525
  return;
}
}
#line 528 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_mutex_of_device = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_mutex_of_device = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 583
  if (ldv_mutex_mutex_of_device == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 611
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_mutex_of_device = 1;
#line 614
  return;
}
}
#line 618 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 621
  ldv_mutex_be_adapter_list_lock = 1;
#line 623
  ldv_mutex_lock = 1;
#line 625
  ldv_mutex_mbox_lock_of_be_adapter = 1;
#line 627
  ldv_mutex_mutex_of_device = 1;
#line 628
  return;
}
}
#line 631 "/work/ldvuser/exper_fp/work/current--X--drivers--X--defaultlinux-3.10-rc1.tar--X--32_7a--X--cpachecker/linux-3.10-rc1.tar/csd_deg_dscv/8517/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 634
  if (ldv_mutex_be_adapter_list_lock == 1) {

  } else {
#line 634
    ldv_error();
  }
#line 636
  if (ldv_mutex_lock == 1) {

  } else {
#line 636
    ldv_error();
  }
#line 638
  if (ldv_mutex_mbox_lock_of_be_adapter == 1) {

  } else {
#line 638
    ldv_error();
  }
#line 640
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 640
    ldv_error();
  }
#line 641
  return;
}
}
