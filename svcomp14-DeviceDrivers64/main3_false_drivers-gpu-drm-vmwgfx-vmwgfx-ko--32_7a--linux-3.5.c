/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 86 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 27 "include/linux/types.h"
typedef unsigned short umode_t;
#line 28 "include/linux/types.h"
typedef __u32 nlink_t;
#line 29 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 30 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 35 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 38 "include/linux/types.h"
typedef _Bool bool;
#line 40 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 41 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 54 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 63 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 68 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 78 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 111 "include/linux/types.h"
typedef __s32 int32_t;
#line 115 "include/linux/types.h"
typedef __u8 uint8_t;
#line 116 "include/linux/types.h"
typedef __u16 uint16_t;
#line 117 "include/linux/types.h"
typedef __u32 uint32_t;
#line 120 "include/linux/types.h"
typedef __u64 uint64_t;
#line 142 "include/linux/types.h"
typedef unsigned long sector_t;
#line 143 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 180 "include/linux/types.h"
typedef __u32 __le32;
#line 202 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 203 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 206 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 211 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 221 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 221 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 226 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 226 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 227 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 232
struct hlist_node;
#line 232 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 236 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 247 "include/linux/types.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head * ) ;
};
#line 55 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/alternative.h"
struct module;
#line 303 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 60
struct completion;
#line 61
struct pt_regs;
#line 351 "include/linux/kernel.h"
struct pid;
#line 14 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2007_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2007_8 ldv_2007 ;
};
#line 27 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2014_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2014_10 ldv_2014 ;
};
#line 33 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 125 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2131_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 125 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2146_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 125 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2147_11 {
   struct __anonstruct_ldv_2131_12 ldv_2131 ;
   struct __anonstruct_ldv_2146_13 ldv_2146 ;
};
#line 125 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2147_11 ldv_2147 ;
};
#line 13 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 192 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 194 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 194 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 282
struct page;
#line 282 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 290
struct file;
#line 305
struct seq_file;
#line 337
struct thread_struct;
#line 339
struct cpumask;
#line 300 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/ptrace.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 203 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2775_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 203 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2775_18 ldv_2775 ;
};
#line 96 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 637 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 153 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 287 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 305 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5149_23 {
   u64 rip ;
   u64 rdp ;
};
#line 305 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5155_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 305 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5156_22 {
   struct __anonstruct_ldv_5149_23 ldv_5149 ;
   struct __anonstruct_ldv_5155_24 ldv_5155 ;
};
#line 305 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5165_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 305 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5156_22 ldv_5156 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5165_25 ldv_5165 ;
};
#line 339 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 360 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 365 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 371 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 377 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 385 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 433
struct kmem_cache;
#line 434
struct perf_event;
#line 435 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5987_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5988_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5987_29 ldv_5987 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5988_28 ldv_5988 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 40 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint32_t uint32;
#line 42 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef int32_t int32;
#line 286 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestPtr {
   uint32 gmrId ;
   uint32 offset ;
};
#line 291 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestPtr SVGAGuestPtr;
#line 292 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_ldv_6407_32 {
   unsigned char bitsPerPixel ;
   unsigned char colorDepth ;
   unsigned short reserved ;
};
#line 292 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
union __anonunion_ldv_6409_31 {
   struct __anonstruct_ldv_6407_32 ldv_6407 ;
   uint32 value ;
};
#line 292 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGMRImageFormat {
   union __anonunion_ldv_6409_31 ldv_6409 ;
};
#line 325 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGMRImageFormat SVGAGMRImageFormat;
#line 370 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedRect {
   int32 left ;
   int32 top ;
   int32 right ;
   int32 bottom ;
};
#line 391 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedRect SVGASignedRect;
#line 1331 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 {
   SVGAGuestPtr ptr ;
   uint32 bytesPerLine ;
   SVGAGMRImageFormat format ;
};
#line 1331 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 SVGAFifoCmdDefineGMRFB;
#line 612 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_9249 {
    SVGA3D_RT_DEPTH = 0,
    SVGA3D_RT_STENCIL = 1,
    SVGA3D_RT_COLOR0 = 2,
    SVGA3D_RT_COLOR1 = 3,
    SVGA3D_RT_COLOR2 = 4,
    SVGA3D_RT_COLOR3 = 5,
    SVGA3D_RT_COLOR4 = 6,
    SVGA3D_RT_COLOR5 = 7,
    SVGA3D_RT_COLOR6 = 8,
    SVGA3D_RT_COLOR7 = 9,
    SVGA3D_RT_MAX = 10,
    SVGA3D_RT_INVALID = 4294967295L
} ;
#line 626 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9249 SVGA3dRenderTargetType;
#line 655
enum ldv_9258 {
    SVGA3D_TS_INVALID = 0,
    SVGA3D_TS_BIND_TEXTURE = 1,
    SVGA3D_TS_COLOROP = 2,
    SVGA3D_TS_COLORARG1 = 3,
    SVGA3D_TS_COLORARG2 = 4,
    SVGA3D_TS_ALPHAOP = 5,
    SVGA3D_TS_ALPHAARG1 = 6,
    SVGA3D_TS_ALPHAARG2 = 7,
    SVGA3D_TS_ADDRESSU = 8,
    SVGA3D_TS_ADDRESSV = 9,
    SVGA3D_TS_MIPFILTER = 10,
    SVGA3D_TS_MAGFILTER = 11,
    SVGA3D_TS_MINFILTER = 12,
    SVGA3D_TS_BORDERCOLOR = 13,
    SVGA3D_TS_TEXCOORDINDEX = 14,
    SVGA3D_TS_TEXTURETRANSFORMFLAGS = 15,
    SVGA3D_TS_TEXCOORDGEN = 16,
    SVGA3D_TS_BUMPENVMAT00 = 17,
    SVGA3D_TS_BUMPENVMAT01 = 18,
    SVGA3D_TS_BUMPENVMAT10 = 19,
    SVGA3D_TS_BUMPENVMAT11 = 20,
    SVGA3D_TS_TEXTURE_MIPMAP_LEVEL = 21,
    SVGA3D_TS_TEXTURE_LOD_BIAS = 22,
    SVGA3D_TS_TEXTURE_ANISOTROPIC_LEVEL = 23,
    SVGA3D_TS_ADDRESSW = 24,
    SVGA3D_TS_GAMMA = 25,
    SVGA3D_TS_BUMPENVLSCALE = 26,
    SVGA3D_TS_BUMPENVLOFFSET = 27,
    SVGA3D_TS_COLORARG0 = 28,
    SVGA3D_TS_ALPHAARG0 = 29,
    SVGA3D_TS_MAX = 30
} ;
#line 703 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9258 SVGA3dTextureStateName;
#line 804
enum ldv_9274 {
    SVGA3D_DECLUSAGE_POSITION = 0,
    SVGA3D_DECLUSAGE_BLENDWEIGHT = 1,
    SVGA3D_DECLUSAGE_BLENDINDICES = 2,
    SVGA3D_DECLUSAGE_NORMAL = 3,
    SVGA3D_DECLUSAGE_PSIZE = 4,
    SVGA3D_DECLUSAGE_TEXCOORD = 5,
    SVGA3D_DECLUSAGE_TANGENT = 6,
    SVGA3D_DECLUSAGE_BINORMAL = 7,
    SVGA3D_DECLUSAGE_TESSFACTOR = 8,
    SVGA3D_DECLUSAGE_POSITIONT = 9,
    SVGA3D_DECLUSAGE_COLOR = 10,
    SVGA3D_DECLUSAGE_FOG = 11,
    SVGA3D_DECLUSAGE_DEPTH = 12,
    SVGA3D_DECLUSAGE_SAMPLE = 13,
    SVGA3D_DECLUSAGE_MAX = 14
} ;
#line 843 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9274 SVGA3dDeclUsage;
#line 844
enum ldv_9276 {
    SVGA3D_DECLMETHOD_DEFAULT = 0,
    SVGA3D_DECLMETHOD_PARTIALU = 1,
    SVGA3D_DECLMETHOD_PARTIALV = 2,
    SVGA3D_DECLMETHOD_CROSSUV = 3,
    SVGA3D_DECLMETHOD_UV = 4,
    SVGA3D_DECLMETHOD_LOOKUP = 5,
    SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED = 6
} ;
#line 853 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9276 SVGA3dDeclMethod;
#line 854
enum ldv_9278 {
    SVGA3D_DECLTYPE_FLOAT1 = 0,
    SVGA3D_DECLTYPE_FLOAT2 = 1,
    SVGA3D_DECLTYPE_FLOAT3 = 2,
    SVGA3D_DECLTYPE_FLOAT4 = 3,
    SVGA3D_DECLTYPE_D3DCOLOR = 4,
    SVGA3D_DECLTYPE_UBYTE4 = 5,
    SVGA3D_DECLTYPE_SHORT2 = 6,
    SVGA3D_DECLTYPE_SHORT4 = 7,
    SVGA3D_DECLTYPE_UBYTE4N = 8,
    SVGA3D_DECLTYPE_SHORT2N = 9,
    SVGA3D_DECLTYPE_SHORT4N = 10,
    SVGA3D_DECLTYPE_USHORT2N = 11,
    SVGA3D_DECLTYPE_USHORT4N = 12,
    SVGA3D_DECLTYPE_UDEC3 = 13,
    SVGA3D_DECLTYPE_DEC3N = 14,
    SVGA3D_DECLTYPE_FLOAT16_2 = 15,
    SVGA3D_DECLTYPE_FLOAT16_4 = 16,
    SVGA3D_DECLTYPE_MAX = 17
} ;
#line 874 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9278 SVGA3dDeclType;
#line 903
enum ldv_9284 {
    SVGA3D_PRIMITIVE_INVALID = 0,
    SVGA3D_PRIMITIVE_TRIANGLELIST = 1,
    SVGA3D_PRIMITIVE_POINTLIST = 2,
    SVGA3D_PRIMITIVE_LINELIST = 3,
    SVGA3D_PRIMITIVE_LINESTRIP = 4,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP = 5,
    SVGA3D_PRIMITIVE_TRIANGLEFAN = 6,
    SVGA3D_PRIMITIVE_MAX = 7
} ;
#line 913 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9284 SVGA3dPrimitiveType;
#line 970
enum ldv_9298 {
    SVGA3D_STRETCH_BLT_POINT = 0,
    SVGA3D_STRETCH_BLT_LINEAR = 1,
    SVGA3D_STRETCH_BLT_MAX = 2
} ;
#line 977 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9298 SVGA3dStretchBltMode;
#line 978
enum ldv_9300 {
    SVGA3D_QUERYTYPE_OCCLUSION = 0,
    SVGA3D_QUERYTYPE_MAX = 1
} ;
#line 982 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9300 SVGA3dQueryType;
#line 990
enum ldv_9304 {
    SVGA3D_WRITE_HOST_VRAM = 1,
    SVGA3D_READ_HOST_VRAM = 2
} ;
#line 994 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9304 SVGA3dTransferType;
#line 1077 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dSurfaceImageId {
   uint32 sid ;
   uint32 face ;
   uint32 mipmap ;
};
#line 1088 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dSurfaceImageId SVGA3dSurfaceImageId;
#line 1089 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 1110 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dGuestImage SVGA3dGuestImage;
#line 1124 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdHeader_60 {
   uint32 id ;
   uint32 size ;
};
#line 1124 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdHeader_60 SVGA3dCmdHeader;
#line 1269 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dBox_70 {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
};
#line 1269 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dBox_70 SVGA3dBox;
#line 1300 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdPresent_73 {
   uint32 sid ;
};
#line 1300 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdPresent_73 SVGA3dCmdPresent;
#line 1322 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetRenderTarget_77 {
   uint32 cid ;
   SVGA3dRenderTargetType type ;
   SVGA3dSurfaceImageId target ;
};
#line 1322 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetRenderTarget_77 SVGA3dCmdSetRenderTarget;
#line 1329 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceCopy_78 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
};
#line 1329 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceCopy_78 SVGA3dCmdSurfaceCopy;
#line 1338 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
   SVGA3dBox boxSrc ;
   SVGA3dBox boxDest ;
   SVGA3dStretchBltMode mode ;
};
#line 1338 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 SVGA3dCmdSurfaceStretchBlt;
#line 1378 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMA_81 {
   SVGA3dGuestImage guest ;
   SVGA3dSurfaceImageId host ;
   SVGA3dTransferType transfer ;
};
#line 1378 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMA_81 SVGA3dCmdSurfaceDMA;
#line 1444 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArrayRangeHint_83 {
   uint32 first ;
   uint32 last ;
};
#line 1444 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArrayRangeHint_83 SVGA3dArrayRangeHint;
#line 1462 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArray_84 {
   uint32 surfaceId ;
   uint32 offset ;
   uint32 stride ;
};
#line 1462 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArray_84 SVGA3dArray;
#line 1476 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexArrayIdentity_85 {
   SVGA3dDeclType type ;
   SVGA3dDeclMethod method ;
   SVGA3dDeclUsage usage ;
   uint32 usageIndex ;
};
#line 1476 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexArrayIdentity_85 SVGA3dVertexArrayIdentity;
#line 1483 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexDecl_86 {
   SVGA3dVertexArrayIdentity identity ;
   SVGA3dArray array ;
   SVGA3dArrayRangeHint rangeHint ;
};
#line 1483 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexDecl_86 SVGA3dVertexDecl;
#line 1533 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dPrimitiveRange_87 {
   SVGA3dPrimitiveType primType ;
   uint32 primitiveCount ;
   SVGA3dArray indexArray ;
   uint32 indexWidth ;
   int32 indexBias ;
};
#line 1533 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dPrimitiveRange_87 SVGA3dPrimitiveRange;
#line 1553 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDrawPrimitives_88 {
   uint32 cid ;
   uint32 numVertexDecls ;
   uint32 numRanges ;
};
#line 1553 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDrawPrimitives_88 SVGA3dCmdDrawPrimitives;
#line 1563 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_7489_90 {
   uint32 value ;
   float floatValue ;
};
#line 1563 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dTextureState_89 {
   uint32 stage ;
   SVGA3dTextureStateName name ;
   union __anonunion_ldv_7489_90 ldv_7489 ;
};
#line 1563 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dTextureState_89 SVGA3dTextureState;
#line 1681 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdEndQuery_107 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1681 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdEndQuery_107 SVGA3dCmdEndQuery;
#line 1688 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdWaitForQuery_108 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1688 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdWaitForQuery_108 SVGA3dCmdWaitForQuery;
#line 1743 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 {
   SVGA3dSurfaceImageId srcImage ;
   SVGASignedRect srcRect ;
   uint32 destScreenId ;
   SVGASignedRect destRect ;
};
#line 1743 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 SVGA3dCmdBlitSurfaceToScreen;
#line 66 "include/linux/miscdevice.h"
struct block_device;
#line 67
struct io_context;
#line 68
struct cgroup_subsys_state;
#line 57 "include/linux/fs.h"
struct timespec;
#line 48 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 53 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 188 "include/linux/rcupdate.h"
struct notifier_block;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_8997_120 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_8999_119 {
   struct __anonstruct_ldv_8997_120 ldv_8997 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_8999_119 ldv_8999 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct inode;
#line 87
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_121 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_121 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 417 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 133 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 18 "include/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380
struct prio_tree_node;
#line 380 "include/linux/radix-tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 19 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 27 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 111
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 118
struct pid_namespace;
#line 118 "include/linux/prio_tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct rcu_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 93 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 96 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "include/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 49
struct export_operations;
#line 51
struct iovec;
#line 52
struct kiocb;
#line 53
struct kobject;
#line 54
struct pipe_inode_info;
#line 55
struct poll_table_struct;
#line 56
struct kstatfs;
#line 57
struct vm_area_struct;
#line 58
struct cred;
#line 445 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 119 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
struct rw_semaphore;
#line 153 "include/linux/quota.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 139 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 181 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 15 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 312 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 341
struct tvec_base;
#line 342 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 289 "include/linux/timer.h"
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 301
struct workqueue_struct;
#line 302
struct work_struct;
#line 45 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 86 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos_request;
#line 499
struct pm_qos_constraints;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct dev_pm_qos_request *pq_req ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_constraints *constraints ;
};
#line 556 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_187 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_187 nodemask_t;
#line 135 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_188 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_188 mm_context_t;
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 185 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "include/linux/quota.h"
typedef long long qsize_t;
#line 189 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 211
struct quota_format_type;
#line 212 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 275 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 303 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 314 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 328 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 344 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 390 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 421
struct address_space;
#line 422
struct writeback_control;
#line 595 "include/linux/fs.h"
union __anonunion_arg_216 {
   char *buf ;
   void *data ;
};
#line 595 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_215 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_216 arg ;
   int error ;
};
#line 595 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_215 read_descriptor_t;
#line 598 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 652
struct backing_dev_info;
#line 653 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
};
#line 674
struct request_queue;
#line 675
struct hd_struct;
#line 675
struct gendisk;
#line 675 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 747
struct posix_acl;
#line 748
struct inode_operations;
#line 748 "include/linux/fs.h"
union __anonunion_ldv_14286_217 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 748 "include/linux/fs.h"
union __anonunion_ldv_14306_218 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 748
struct file_lock;
#line 748
struct cdev;
#line 748 "include/linux/fs.h"
union __anonunion_ldv_14322_219 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 748 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_14286_217 ldv_14286 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_14306_218 ldv_14306 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_14322_219 ldv_14322 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 976 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 984 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 1007 "include/linux/fs.h"
union __anonunion_f_u_220 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 1007 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_220 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1146
struct files_struct;
#line 1146 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1147 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1152 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 1169
struct nlm_lockowner;
#line 1170 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_222 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_221 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_222 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_221 fl_u ;
};
#line 1256 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1452
struct file_system_type;
#line 1452
struct super_operations;
#line 1452
struct xattr_handler;
#line 1452
struct mtd_info;
#line 1452 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1592 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1631 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
};
#line 1666 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
};
#line 1710 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1870 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 269 "include/linux/srcu.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 164 "include/linux/slab.h"
struct sock;
#line 165
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 171 "include/linux/slab.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[26U] ;
};
#line 55 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 66 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 76 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 46 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 48 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
#line 49 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 121
struct tty_driver;
#line 241
struct nsproxy;
#line 41 "include/linux/file.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 17
struct device_private;
#line 18
struct device_driver;
#line 19
struct driver_private;
#line 20
struct class;
#line 21
struct subsys_private;
#line 22
struct bus_type;
#line 23
struct device_node;
#line 24
struct iommu_ops;
#line 25 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 52 "include/linux/device.h"
struct device_attribute;
#line 52
struct driver_attribute;
#line 52 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 126
struct device_type;
#line 183
struct of_device_id;
#line 183 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 246 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 300
struct class_attribute;
#line 300 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 395 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 448 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 475 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 563 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 573
struct dma_coherent_mem;
#line 573 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
};
#line 691 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 217 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 494 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 586
struct mfd_cell;
#line 587 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 117 "include/linux/pci.h"
typedef int pci_power_t;
#line 143 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 144
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 169 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 186 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 229
struct pcie_link_state;
#line 230
struct pci_vpd;
#line 231
struct pci_sriov;
#line 232
struct pci_ats;
#line 233
struct pci_driver;
#line 233 "include/linux/pci.h"
union __anonunion_ldv_19267_224 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 233 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_type : 4 ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_19267_224 ldv_19267 ;
   struct pci_ats *ats ;
};
#line 410
struct pci_ops;
#line 410 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 462 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 497 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 510 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 519 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 547 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 993 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 1141 "include/linux/pci.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 108 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 42 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_trap_nr ;
   unsigned long saved_scratch_register ;
};
#line 58 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_BP_HIT = 1,
    UTASK_SSTEP = 2,
    UTASK_SSTEP_ACK = 3,
    UTASK_SSTEP_TRAPPED = 4
} ;
#line 66
struct uprobe;
#line 66 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 80 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 99 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
   atomic_t count ;
};
#line 121 "include/linux/uprobes.h"
union __anonunion_ldv_20249_226 {
   unsigned long index ;
   void *freelist ;
};
#line 121 "include/linux/uprobes.h"
struct __anonstruct_ldv_20259_230 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 121 "include/linux/uprobes.h"
union __anonunion_ldv_20260_229 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_20259_230 ldv_20259 ;
};
#line 121 "include/linux/uprobes.h"
struct __anonstruct_ldv_20262_228 {
   union __anonunion_ldv_20260_229 ldv_20260 ;
   atomic_t _count ;
};
#line 121 "include/linux/uprobes.h"
union __anonunion_ldv_20263_227 {
   unsigned long counters ;
   struct __anonstruct_ldv_20262_228 ldv_20262 ;
};
#line 121 "include/linux/uprobes.h"
struct __anonstruct_ldv_20264_225 {
   union __anonunion_ldv_20249_226 ldv_20249 ;
   union __anonunion_ldv_20263_227 ldv_20263 ;
};
#line 121 "include/linux/uprobes.h"
struct __anonstruct_ldv_20271_232 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 121 "include/linux/uprobes.h"
union __anonunion_ldv_20272_231 {
   struct list_head lru ;
   struct __anonstruct_ldv_20271_232 ldv_20271 ;
};
#line 121 "include/linux/uprobes.h"
union __anonunion_ldv_20277_233 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 121 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_20264_225 ldv_20264 ;
   union __anonunion_ldv_20272_231 ldv_20272 ;
   union __anonunion_ldv_20277_233 ldv_20277 ;
   unsigned long debug_flags ;
};
#line 203 "include/linux/mm_types.h"
struct __anonstruct_vm_set_235 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 203 "include/linux/mm_types.h"
union __anonunion_shared_234 {
   struct __anonstruct_vm_set_235 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 203
struct anon_vma;
#line 203
struct vm_operations_struct;
#line 203
struct mempolicy;
#line 203 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_234 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 266 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 272 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 285 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 298
struct linux_binfmt;
#line 298
struct mmu_notifier_mm;
#line 298 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   struct uprobes_state uprobes_state ;
};
#line 30 "include/linux/range.h"
struct user_struct;
#line 178 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 195 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
};
#line 31 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 67 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 74 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 268 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1730 "include/linux/pci.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 98 "include/linux/sem.h"
struct sem_undo_list;
#line 98 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 18 "include/linux/socket.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 44 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 15
struct siginfo;
#line 32 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_247 {
   unsigned long sig[1U] ;
};
#line 32 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_247 sigset_t;
#line 17 "include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 126 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 173 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 185 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_249 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_250 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_251 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_252 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_253 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_254 {
   long _band ;
   int _fd ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigsys_255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/asm-generic/siginfo.h"
union __anonunion__sifields_248 {
   int _pad[28U] ;
   struct __anonstruct__kill_249 _kill ;
   struct __anonstruct__timer_250 _timer ;
   struct __anonstruct__rt_251 _rt ;
   struct __anonstruct__sigchld_252 _sigchld ;
   struct __anonstruct__sigfault_253 _sigfault ;
   struct __anonstruct__sigpoll_254 _sigpoll ;
   struct __anonstruct__sigsys_255 _sigsys ;
};
#line 11 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_248 _sifields ;
};
#line 109 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 46 "include/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 122 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 85 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 460 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 29 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 33
struct key;
#line 34
struct signal_struct;
#line 35
struct key_type;
#line 37
struct keyring_list;
#line 115 "include/linux/key.h"
union __anonunion_ldv_26123_260 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 115
struct key_user;
#line 115 "include/linux/key.h"
union __anonunion_ldv_26132_261 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 115 "include/linux/key.h"
union __anonunion_type_data_262 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 115 "include/linux/key.h"
union __anonunion_payload_263 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 115 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_26123_260 ldv_26123 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_26132_261 ldv_26132 ;
   time_t last_used_at ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_262 type_data ;
   union __anonunion_payload_263 payload ;
};
#line 319
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 92 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 358
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 151 "include/linux/sched.h"
struct cfs_rq;
#line 387
struct kioctx;
#line 388 "include/linux/sched.h"
union __anonunion_ki_obj_264 {
   void *user ;
   struct task_struct *tsk ;
};
#line 388
struct eventfd_ctx;
#line 388 "include/linux/sched.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_264 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 163 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 179 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 408 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 452 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 460 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 467 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 484 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 520
struct autogroup;
#line 521
struct tty_struct;
#line 521
struct taskstats;
#line 521
struct tty_audit_buf;
#line 521 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 702 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 746
struct reclaim_state;
#line 747 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 762 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1064
struct rq;
#line 1065 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1131 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1197
struct rt_rq;
#line 1197 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1220
struct mem_cgroup;
#line 1220 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1578
struct css_set;
#line 1578
struct compat_robust_list_head;
#line 1578 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct hlist_head task_works ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
   int uprobe_srcu_id ;
};
#line 39 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 212 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 225 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 229 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 195 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/mtrr.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 200 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/mtrr.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 44 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 58
struct agp_bridge_data;
#line 34 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "include/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 75 "include/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 110 "include/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
#line 139 "include/drm/drm.h"
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
#line 173
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
#line 183
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
#line 234
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
#line 399
enum drm_ctx_flags {
    _DRM_CONTEXT_PRESERVED = 1,
    _DRM_CONTEXT_2DONLY = 2
} ;
#line 450 "include/drm/drm.h"
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
#line 575 "include/drm/drm.h"
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
#line 288 "include/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
};
#line 432 "include/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 461 "include/drm/drm_mode.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 763 "include/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 775 "include/drm/drm.h"
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[64U] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
#line 58 "include/linux/idr.h"
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
#line 116 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 133 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 154
struct drm_file;
#line 155
struct drm_device;
#line 54 "include/linux/delay.h"
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
#line 46 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 63 "include/drm/drm_hashtab.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 30 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 158
struct drm_mm;
#line 158 "include/linux/seq_file.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
#line 57 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
};
#line 295 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
#line 299 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
#line 345 "include/drm/drmP.h"
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   wait_queue_head_t dma_wait ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   int list ;
   int dev_priv_size ;
   void *dev_private ;
};
#line 367 "include/drm/drmP.h"
struct drm_waitlist {
   int count ;
   struct drm_buf **bufs ;
   struct drm_buf **rp ;
   struct drm_buf **wp ;
   struct drm_buf **end ;
   spinlock_t read_lock ;
   spinlock_t write_lock ;
};
#line 378 "include/drm/drmP.h"
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
#line 390 "include/drm/drmP.h"
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
#line 396 "include/drm/drmP.h"
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
#line 410 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
#line 420 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 426
struct drm_minor;
#line 426
struct drm_master;
#line 426 "include/drm/drmP.h"
struct drm_file {
   int authenticated ;
   pid_t pid ;
   uid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 457 "include/drm/drmP.h"
struct drm_queue {
   atomic_t use_count ;
   atomic_t finalization ;
   atomic_t block_count ;
   atomic_t block_read ;
   wait_queue_head_t read_queue ;
   atomic_t block_write ;
   wait_queue_head_t write_queue ;
   atomic_t total_queued ;
   atomic_t total_flushed ;
   atomic_t total_locks ;
   enum drm_ctx_flags flags ;
   struct drm_waitlist waitlist ;
   wait_queue_head_t flush_queue ;
};
#line 474 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 496 "include/drm/drmP.h"
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   int flags ;
};
#line 521 "include/drm/drmP.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 539 "include/drm/drmP.h"
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
#line 550 "include/drm/drmP.h"
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 555 "include/drm/drmP.h"
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
#line 571 "include/drm/drmP.h"
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
#line 619
struct dma_buf;
#line 619
struct dma_buf_attachment;
#line 619 "include/drm/drmP.h"
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 28 "include/linux/of.h"
typedef u32 phandle;
#line 30 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 39 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 186 "include/linux/serial.h"
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9U] ;
};
#line 6 "include/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "include/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "include/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "include/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "include/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 138 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 27 "include/linux/export.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 293 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 48 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 116 "include/linux/pps_kernel.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
#line 154 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
   wait_queue_head_t wq_idle ;
};
#line 160 "include/linux/tty_ldisc.h"
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
#line 75 "include/linux/tty.h"
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
#line 95
struct tty_port;
#line 96 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 222 "include/linux/tty.h"
struct tty_port {
   struct tty_struct *tty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 244 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned char echo_overrun : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[4U] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[64U] ;
   unsigned char *echo_buf ;
   unsigned int echo_pos ;
   unsigned int echo_cnt ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   struct mutex output_lock ;
   struct mutex echo_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 1178 "include/linux/fb.h"
struct drm_mode_set;
#line 1179
struct drm_framebuffer;
#line 1180
struct drm_object_properties;
#line 1181 "include/linux/fb.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
#line 56 "include/drm/drm_crtc.h"
struct drm_object_properties {
   int count ;
   uint32_t ids[24U] ;
   uint64_t values[24U] ;
};
#line 63
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 104 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int crtc_hadjusted ;
   int crtc_vadjusted ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
#line 180
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 186
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 195 "include/drm/drm_crtc.h"
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
   char *raw_edid ;
};
#line 222 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
#line 242 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 264 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
#line 277 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
#line 288
struct drm_crtc;
#line 289
struct drm_connector;
#line 290
struct drm_encoder;
#line 291
struct drm_pending_vblank_event;
#line 293 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
};
#line 353 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
   struct drm_object_properties properties ;
};
#line 411 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
#line 449 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
#line 461 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs  const  *funcs ;
   void *helper_private ;
};
#line 494
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 501 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
};
#line 661 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct list_head head ;
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 691 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
#line 706 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
#line 728 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
#line 1064 "include/drm/drm_crtc.h"
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 705 "include/drm/drmP.h"
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device * ) ;
   char const   *(*get_name)(struct drm_device * ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   int (*set_unique)(struct drm_device * , struct drm_master * , struct drm_unique * ) ;
   int (*irq_by_busid)(struct drm_device * , struct drm_irq_busid * ) ;
   int (*agp_init)(struct drm_device * ) ;
};
#line 732
struct usb_driver;
#line 732 "include/drm/drmP.h"
union __anonunion_kdriver_274 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
#line 732 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , int * , int * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   void (*reclaim_buffers)(struct drm_device * , struct drm_file * ) ;
   void (*reclaim_buffers_locked)(struct drm_device * , struct drm_file * ) ;
   void (*reclaim_buffers_idlelocked)(struct drm_device * , struct drm_file * ) ;
   void (*set_version)(struct drm_device * , struct drm_set_version * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   int (*gem_init_object)(struct drm_gem_object * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   union __anonunion_kdriver_274 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
#line 994 "include/drm/drmP.h"
struct drm_info_list {
   char const   *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
#line 1005 "include/drm/drmP.h"
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
#line 1015 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
#line 1052 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 1059
struct usb_device;
#line 1059 "include/drm/drmP.h"
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15U] ;
   atomic_t counts[15U] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   int queue_count ;
   int queue_reserved ;
   int queue_slots ;
   struct drm_queue **queuelist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
#line 1626
enum drm_global_types {
    DRM_GLOBAL_TTM_MEM = 0,
    DRM_GLOBAL_TTM_BO = 1,
    DRM_GLOBAL_TTM_OBJECT = 2,
    DRM_GLOBAL_NUM = 3
} ;
#line 1633 "include/drm/drmP.h"
struct drm_global_reference {
   enum drm_global_types global_type ;
   size_t size ;
   void *object ;
   int (*init)(struct drm_global_reference * ) ;
   void (*release)(struct drm_global_reference * ) ;
};
#line 177 "include/drm/vmwgfx_drm.h"
struct drm_vmw_size {
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
   uint32_t pad64 ;
};
#line 237 "include/drm/vmwgfx_drm.h"
struct drm_vmw_execbuf_arg {
   uint64_t commands ;
   uint32_t command_size ;
   uint32_t throttle_us ;
   uint64_t fence_rep ;
   uint32_t version ;
   uint32_t flags ;
};
#line 286 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_rep {
   uint32_t handle ;
   uint32_t mask ;
   uint32_t seqno ;
   uint32_t passed_seqno ;
   uint32_t pad64 ;
   int32_t error ;
};
#line 789 "include/drm/vmwgfx_drm.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "include/linux/prio_heap.h"
struct cgroupfs_root;
#line 57
struct cgroup;
#line 58
struct css_id;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
#line 150 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[64U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct rcu_head rcu_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
};
#line 220 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[64U] ;
   struct rcu_head rcu_head ;
};
#line 108 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 455 "include/linux/suspend.h"
struct ttm_bo_device;
#line 456 "include/linux/suspend.h"
struct ttm_placement {
   unsigned int fpfn ;
   unsigned int lpfn ;
   unsigned int num_placement ;
   uint32_t const   *placement ;
   unsigned int num_busy_placement ;
   uint32_t const   *busy_placement ;
};
#line 68 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bus_placement {
   void *addr ;
   unsigned long base ;
   unsigned long size ;
   unsigned long offset ;
   bool is_iomem ;
   bool io_reserved_vm ;
   uint64_t io_reserved_count ;
};
#line 91 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_reg {
   void *mm_node ;
   unsigned long start ;
   unsigned long size ;
   unsigned long num_pages ;
   uint32_t page_alignment ;
   uint32_t mem_type ;
   uint32_t placement ;
   struct ttm_bus_placement bus ;
};
#line 117
enum ttm_bo_type {
    ttm_bo_type_device = 0,
    ttm_bo_type_kernel = 1,
    ttm_bo_type_sg = 2
} ;
#line 123
struct ttm_tt;
#line 124
struct ttm_bo_global;
#line 124 "include/drm/ttm/ttm_bo_api.h"
struct ttm_buffer_object {
   struct ttm_bo_global *glob ;
   struct ttm_bo_device *bdev ;
   unsigned long buffer_start ;
   enum ttm_bo_type type ;
   void (*destroy)(struct ttm_buffer_object * ) ;
   unsigned long num_pages ;
   uint64_t addr_space_offset ;
   size_t acc_size ;
   struct kref kref ;
   struct kref list_kref ;
   wait_queue_head_t event_queue ;
   struct ttm_mem_reg mem ;
   struct file *persistent_swap_storage ;
   struct ttm_tt *ttm ;
   bool evicted ;
   atomic_t cpu_writers ;
   struct list_head lru ;
   struct list_head ddestroy ;
   struct list_head swap ;
   struct list_head io_reserve_lru ;
   uint32_t val_seq ;
   bool seq_valid ;
   atomic_t reserved ;
   void *sync_obj_arg ;
   void *sync_obj ;
   unsigned long priv_flags ;
   struct rb_node vm_rb ;
   struct drm_mm_node *vm_node ;
   unsigned long offset ;
   uint32_t cur_placement ;
   struct sg_table *sg ;
};
#line 738 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_shrink {
   int (*do_shrink)(struct ttm_mem_shrink * ) ;
};
#line 52 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_zone;
#line 53 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_global {
   struct kobject kobj ;
   struct ttm_mem_shrink *shrink ;
   struct workqueue_struct *swap_queue ;
   struct work_struct work ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   struct ttm_mem_zone *zones[2U] ;
   unsigned int num_zones ;
   struct ttm_mem_zone *zone_kernel ;
   struct ttm_mem_zone *zone_dma32 ;
};
#line 39 "include/drm/ttm/ttm_module.h"
struct ttm_backend;
#line 40 "include/drm/ttm/ttm_module.h"
struct ttm_backend_func {
   int (*bind)(struct ttm_tt * , struct ttm_mem_reg * ) ;
   int (*unbind)(struct ttm_tt * ) ;
   void (*destroy)(struct ttm_tt * ) ;
};
#line 78 "include/drm/ttm/ttm_bo_driver.h"
enum ttm_caching_state {
    tt_uncached = 0,
    tt_wc = 1,
    tt_cached = 2
} ;
#line 84
enum ldv_27045 {
    tt_bound = 0,
    tt_unbound = 1,
    tt_unpopulated = 2
} ;
#line 90 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_tt {
   struct ttm_bo_device *bdev ;
   struct ttm_backend_func *func ;
   struct page *dummy_read_page ;
   struct page **pages ;
   uint32_t page_flags ;
   unsigned long num_pages ;
   struct sg_table *sg ;
   struct ttm_bo_global *glob ;
   struct ttm_backend *be ;
   struct file *swap_storage ;
   enum ttm_caching_state caching_state ;
   enum ldv_27045 state ;
};
#line 148
struct ttm_mem_type_manager;
#line 149 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager_func {
   int (*init)(struct ttm_mem_type_manager * , unsigned long  ) ;
   int (*takedown)(struct ttm_mem_type_manager * ) ;
   int (*get_node)(struct ttm_mem_type_manager * , struct ttm_buffer_object * , struct ttm_placement * ,
                   struct ttm_mem_reg * ) ;
   void (*put_node)(struct ttm_mem_type_manager * , struct ttm_mem_reg * ) ;
   void (*debug)(struct ttm_mem_type_manager * , char const   * ) ;
};
#line 236 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager {
   struct ttm_bo_device *bdev ;
   bool has_type ;
   bool use_type ;
   uint32_t flags ;
   unsigned long gpu_offset ;
   uint64_t size ;
   uint32_t available_caching ;
   uint32_t default_caching ;
   struct ttm_mem_type_manager_func  const  *func ;
   void *priv ;
   struct mutex io_reserve_mutex ;
   bool use_io_reserve_lru ;
   bool io_reserve_fastpath ;
   struct list_head io_reserve_lru ;
   struct list_head lru ;
};
#line 299 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_driver {
   struct ttm_tt *(*ttm_tt_create)(struct ttm_bo_device * , unsigned long  , uint32_t  ,
                                   struct page * ) ;
   int (*ttm_tt_populate)(struct ttm_tt * ) ;
   void (*ttm_tt_unpopulate)(struct ttm_tt * ) ;
   int (*invalidate_caches)(struct ttm_bo_device * , uint32_t  ) ;
   int (*init_mem_type)(struct ttm_bo_device * , uint32_t  , struct ttm_mem_type_manager * ) ;
   void (*evict_flags)(struct ttm_buffer_object * , struct ttm_placement * ) ;
   int (*move)(struct ttm_buffer_object * , bool  , bool  , bool  , bool  , struct ttm_mem_reg * ) ;
   int (*verify_access)(struct ttm_buffer_object * , struct file * ) ;
   bool (*sync_obj_signaled)(void * , void * ) ;
   int (*sync_obj_wait)(void * , void * , bool  , bool  ) ;
   int (*sync_obj_flush)(void * , void * ) ;
   void (*sync_obj_unref)(void ** ) ;
   void *(*sync_obj_ref)(void * ) ;
   void (*move_notify)(struct ttm_buffer_object * , struct ttm_mem_reg * ) ;
   int (*fault_reserve_notify)(struct ttm_buffer_object * ) ;
   void (*swap_notify)(struct ttm_buffer_object * ) ;
   int (*io_mem_reserve)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
   void (*io_mem_free)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
};
#line 457 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global_ref {
   struct drm_global_reference ref ;
   struct ttm_mem_global *mem_glob ;
};
#line 466 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global {
   struct kobject kobj ;
   struct ttm_mem_global *mem_glob ;
   struct page *dummy_read_page ;
   struct ttm_mem_shrink shrink ;
   struct mutex device_list_mutex ;
   spinlock_t lru_lock ;
   struct list_head device_list ;
   struct list_head swap_lru ;
   atomic_t bo_count ;
};
#line 509 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_device {
   struct list_head device_list ;
   struct ttm_bo_global *glob ;
   struct ttm_bo_driver *driver ;
   rwlock_t vm_lock ;
   struct ttm_mem_type_manager man[8U] ;
   spinlock_t fence_lock ;
   struct rb_root addr_space_rb ;
   struct drm_mm addr_space_mm ;
   struct list_head ddestroy ;
   uint32_t val_seq ;
   bool nice_mode ;
   struct address_space *dev_mapping ;
   struct delayed_work wq ;
   bool need_dma32 ;
};
#line 1037
enum ttm_ref_type {
    TTM_REF_USAGE = 0,
    TTM_REF_SYNCCPU_READ = 1,
    TTM_REF_SYNCCPU_WRITE = 2,
    TTM_REF_NUM = 3
} ;
#line 1044
enum ttm_object_type {
    ttm_fence_type = 0,
    ttm_buffer_type = 1,
    ttm_lock_type = 2,
    ttm_driver_type0 = 256,
    ttm_driver_type1 = 257,
    ttm_driver_type2 = 258,
    ttm_driver_type3 = 259,
    ttm_driver_type4 = 260,
    ttm_driver_type5 = 261
} ;
#line 1056
struct ttm_object_file;
#line 1057
struct ttm_object_device;
#line 1058 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_base_object {
   struct drm_hash_item hash ;
   enum ttm_object_type object_type ;
   bool shareable ;
   struct ttm_object_file *tfile ;
   struct kref refcount ;
   void (*refcount_release)(struct ttm_base_object ** ) ;
   void (*ref_obj_release)(struct ttm_base_object * , enum ttm_ref_type  ) ;
};
#line 270 "include/drm/ttm/ttm_object.h"
struct ttm_lock {
   struct ttm_base_object base ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   int32_t rw ;
   uint32_t flags ;
   bool kill_takers ;
   int signal ;
   struct ttm_object_file *vt_holder ;
};
#line 246 "include/drm/ttm/ttm_lock.h"
struct ttm_validate_buffer {
   struct list_head head ;
   struct ttm_buffer_object *bo ;
   void *new_sync_obj_arg ;
   bool reserved ;
   bool removed ;
   int put_count ;
   void *old_sync_obj ;
};
#line 111 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_private;
#line 112
struct vmw_fence_manager;
#line 51 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj {
   struct kref kref ;
   u32 seqno ;
   struct vmw_fence_manager *fman ;
   struct list_head head ;
   uint32_t signaled ;
   uint32_t signal_mask ;
   struct list_head seq_passed_actions ;
   void (*destroy)(struct vmw_fence_obj * ) ;
   wait_queue_head_t queue ;
};
#line 115 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fpriv {
   struct drm_master *locked_master ;
   struct ttm_object_file *tfile ;
   struct list_head fence_events ;
};
#line 67 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_dma_buffer {
   struct ttm_buffer_object base ;
   struct list_head validate_list ;
   bool gmr_bound ;
   uint32_t cur_validate_node ;
   bool on_validate_list ;
};
#line 75 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource {
   struct kref kref ;
   struct vmw_private *dev_priv ;
   struct idr *idr ;
   int id ;
   enum ttm_object_type res_type ;
   bool avail ;
   void (*remove_from_lists)(struct vmw_resource * ) ;
   void (*hw_destroy)(struct vmw_resource * ) ;
   void (*res_free)(struct vmw_resource * ) ;
   struct list_head validate_head ;
   struct list_head query_head ;
};
#line 89 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_cursor_snooper {
   struct drm_crtc *crtc ;
   size_t age ;
   uint32_t *image ;
};
#line 103
struct vmw_surface_offset;
#line 104 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_surface {
   struct vmw_resource res ;
   struct list_head lru_head ;
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   struct drm_vmw_size *sizes ;
   uint32_t num_sizes ;
   bool scanout ;
   struct vmw_cursor_snooper snooper ;
   struct ttm_buffer_object *backup ;
   struct vmw_surface_offset *offsets ;
   uint32_t backup_size ;
};
#line 123 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker_queue {
   struct list_head head ;
   struct timespec lag ;
   struct timespec lag_time ;
   spinlock_t lock ;
};
#line 130 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fifo_state {
   unsigned long reserved_size ;
   __le32 *dynamic_buffer ;
   __le32 *static_buffer ;
   unsigned long static_buffer_size ;
   bool using_bounce_buffer ;
   uint32_t capabilities ;
   struct mutex fifo_mutex ;
   struct rw_semaphore rwsem ;
   struct vmw_marker_queue marker_queue ;
};
#line 142 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_relocation {
   SVGAGuestPtr *location ;
   uint32_t index ;
};
#line 147 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_sw_context {
   struct ida bo_list ;
   uint32_t last_cid ;
   bool cid_valid ;
   bool kernel ;
   struct vmw_resource *cur_ctx ;
   uint32_t last_sid ;
   uint32_t sid_translation ;
   bool sid_valid ;
   struct ttm_object_file *tfile ;
   struct list_head validate_nodes ;
   struct vmw_relocation relocs[2048U] ;
   uint32_t cur_reloc ;
   struct ttm_validate_buffer val_bufs[2048U] ;
   uint32_t cur_val_buf ;
   uint32_t *cmd_bounce ;
   uint32_t cmd_bounce_size ;
   struct list_head resource_list ;
   uint32_t fence_flags ;
   struct list_head query_list ;
   struct ttm_buffer_object *cur_query_bo ;
   uint32_t cur_query_cid ;
   bool query_cid_valid ;
};
#line 172
struct vmw_legacy_display;
#line 173
struct vmw_overlay;
#line 174 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_master {
   struct ttm_lock lock ;
   struct mutex fb_surf_mutex ;
   struct list_head fb_surf ;
};
#line 181 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_vga_topology_state {
   uint32_t width ;
   uint32_t height ;
   uint32_t primary ;
   uint32_t pos_x ;
   uint32_t pos_y ;
};
#line 189
struct vmw_screen_object_display;
#line 189 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_private {
   struct ttm_bo_device bdev ;
   struct ttm_bo_global_ref bo_global_ref ;
   struct drm_global_reference mem_global_ref ;
   struct vmw_fifo_state fifo ;
   struct drm_device *dev ;
   unsigned long vmw_chipset ;
   unsigned int io_start ;
   uint32_t vram_start ;
   uint32_t vram_size ;
   uint32_t mmio_start ;
   uint32_t mmio_size ;
   uint32_t fb_max_width ;
   uint32_t fb_max_height ;
   uint32_t initial_width ;
   uint32_t initial_height ;
   __le32 *mmio_virt ;
   int mmio_mtrr ;
   uint32_t capabilities ;
   uint32_t max_gmr_descriptors ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t memory_size ;
   bool has_gmr ;
   struct mutex hw_mutex ;
   struct vmw_vga_topology_state vga_save[16U] ;
   uint32_t vga_width ;
   uint32_t vga_height ;
   uint32_t vga_bpp ;
   uint32_t vga_bpl ;
   uint32_t vga_pitchlock ;
   uint32_t num_displays ;
   void *fb_info ;
   struct vmw_legacy_display *ldu_priv ;
   struct vmw_screen_object_display *sou_priv ;
   struct vmw_overlay *overlay_priv ;
   rwlock_t resource_lock ;
   struct idr context_idr ;
   struct idr surface_idr ;
   struct idr stream_idr ;
   struct mutex init_mutex ;
   struct ttm_object_device *tdev ;
   atomic_t marker_seq ;
   wait_queue_head_t fence_queue ;
   wait_queue_head_t fifo_queue ;
   int fence_queue_waiters ;
   int goal_queue_waiters ;
   atomic_t fifo_queue_waiters ;
   uint32_t last_read_seqno ;
   spinlock_t irq_lock ;
   struct vmw_fence_manager *fman ;
   uint32_t irq_mask ;
   uint32_t traces_state ;
   uint32_t enable_state ;
   uint32_t config_done_state ;
   struct vmw_sw_context ctx ;
   struct mutex cmdbuf_mutex ;
   bool stealth ;
   bool is_opened ;
   bool enable_fb ;
   struct vmw_master *active_master ;
   struct vmw_master fbdev_master ;
   struct notifier_block pm_nb ;
   bool suspended ;
   struct mutex release_mutex ;
   uint32_t num_3d_resources ;
   struct ttm_buffer_object *dummy_query_bo ;
   struct ttm_buffer_object *pinned_bo ;
   uint32_t query_cid ;
   bool dummy_query_bo_pinned ;
   struct list_head surface_lru ;
   uint32_t used_memory_size ;
};
#line 214 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_cid_cmd {
   SVGA3dCmdHeader header ;
   __le32 cid ;
};
#line 291 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetRenderTarget body ;
};
#line 310 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceCopy body ;
};
#line 327 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceStretchBlt body ;
};
#line 344 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 363 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___3 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdPresent body ;
};
#line 590 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdEndQuery q ;
};
#line 619 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery q ;
};
#line 658 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_dma_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA dma ;
};
#line 709 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_draw_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDrawPrimitives body ;
};
#line 801 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_cmd_279 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 801 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_282 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 857 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int (*vmw_cmd_func)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * );
#line 1499 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___0;
#line 1611 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___11;
#line 193 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/special_insns.h"
struct exec_domain;
#line 91 "include/linux/personality.h"
struct map_segment;
#line 91 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 576 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 576 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 132 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
struct svga_guest_mem_descriptor {
   __le32 ppn ;
   __le32 num_pages ;
};
#line 1498 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMR2_45 {
   uint32 gmrId ;
   uint32 numPages ;
};
#line 1498 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMR2_45 SVGAFifoCmdDefineGMR2;
#line 1499
enum ldv_9192 {
    SVGA_REMAP_GMR2_PPN32 = 0,
    SVGA_REMAP_GMR2_VIA_GMR = 1,
    SVGA_REMAP_GMR2_PPN64 = 2,
    SVGA_REMAP_GMR2_SINGLE_PPN = 4
} ;
#line 1534 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef enum ldv_9192 SVGARemapGMR2Flags;
#line 1550 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdRemapGMR2_46 {
   uint32 gmrId ;
   SVGARemapGMR2Flags flags ;
   uint32 offsetPages ;
   uint32 numPages ;
};
#line 1550 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdRemapGMR2_46 SVGAFifoCmdRemapGMR2;
#line 58 "include/linux/fs.h"
struct compat_timespec;
#line 59 "include/linux/fs.h"
struct __anonstruct_futex_115 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 59 "include/linux/fs.h"
struct __anonstruct_nanosleep_116 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 59
struct pollfd;
#line 59 "include/linux/fs.h"
struct __anonstruct_poll_117 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 59 "include/linux/fs.h"
union __anonunion_ldv_7799_114 {
   struct __anonstruct_futex_115 futex ;
   struct __anonstruct_nanosleep_116 nanosleep ;
   struct __anonstruct_poll_117 poll ;
};
#line 59 "include/linux/fs.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_7799_114 ldv_7799 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 18 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 44 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 108 "include/linux/agp_backend.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 278 "include/drm/drm_mode.h"
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
#line 392 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedPoint {
   int32 x ;
   int32 y ;
};
#line 397 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedPoint SVGASignedPoint;
#line 1028 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdUpdate {
   uint32 x ;
   uint32 y ;
   uint32 width ;
   uint32 height ;
};
#line 1066 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdUpdate SVGAFifoCmdUpdate;
#line 1117 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdDefineAlphaCursor {
   uint32 id ;
   uint32 hotspotX ;
   uint32 hotspotY ;
   uint32 width ;
   uint32 height ;
};
#line 1140 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdDefineAlphaCursor SVGAFifoCmdDefineAlphaCursor;
#line 1368 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_202 {
   SVGASignedPoint srcOrigin ;
   SVGASignedRect destRect ;
   uint32 destScreenId ;
};
#line 1368 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_202 SVGAFifoCmdBlitGMRFBToScreen;
#line 1416 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_203 {
   SVGASignedPoint destOrigin ;
   SVGASignedRect srcRect ;
   uint32 srcScreenId ;
};
#line 1416 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_203 SVGAFifoCmdBlitScreenToGMRFB;
#line 69 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum SVGA3dSurfaceFormat {
    SVGA3D_FORMAT_INVALID = 0,
    SVGA3D_X8R8G8B8 = 1,
    SVGA3D_A8R8G8B8 = 2,
    SVGA3D_R5G6B5 = 3,
    SVGA3D_X1R5G5B5 = 4,
    SVGA3D_A1R5G5B5 = 5,
    SVGA3D_A4R4G4B4 = 6,
    SVGA3D_Z_D32 = 7,
    SVGA3D_Z_D16 = 8,
    SVGA3D_Z_D24S8 = 9,
    SVGA3D_Z_D15S1 = 10,
    SVGA3D_LUMINANCE8 = 11,
    SVGA3D_LUMINANCE4_ALPHA4 = 12,
    SVGA3D_LUMINANCE16 = 13,
    SVGA3D_LUMINANCE8_ALPHA8 = 14,
    SVGA3D_DXT1 = 15,
    SVGA3D_DXT2 = 16,
    SVGA3D_DXT3 = 17,
    SVGA3D_DXT4 = 18,
    SVGA3D_DXT5 = 19,
    SVGA3D_BUMPU8V8 = 20,
    SVGA3D_BUMPL6V5U5 = 21,
    SVGA3D_BUMPX8L8V8U8 = 22,
    SVGA3D_BUMPL8V8U8 = 23,
    SVGA3D_ARGB_S10E5 = 24,
    SVGA3D_ARGB_S23E8 = 25,
    SVGA3D_A2R10G10B10 = 26,
    SVGA3D_V8U8 = 27,
    SVGA3D_Q8W8V8U8 = 28,
    SVGA3D_CxV8U8 = 29,
    SVGA3D_X8L8V8U8 = 30,
    SVGA3D_A2W10V10U10 = 31,
    SVGA3D_ALPHA8 = 32,
    SVGA3D_R_S10E5 = 33,
    SVGA3D_R_S23E8 = 34,
    SVGA3D_RG_S10E5 = 35,
    SVGA3D_RG_S23E8 = 36,
    SVGA3D_BUFFER = 37,
    SVGA3D_Z_D24X8 = 38,
    SVGA3D_V16U16 = 39,
    SVGA3D_G16R16 = 40,
    SVGA3D_A16B16G16R16 = 41,
    SVGA3D_UYVY = 42,
    SVGA3D_YUY2 = 43,
    SVGA3D_NV12 = 44,
    SVGA3D_AYUV = 45,
    SVGA3D_BC4_UNORM = 108,
    SVGA3D_BC5_UNORM = 111,
    SVGA3D_Z_DF16 = 118,
    SVGA3D_Z_DF24 = 119,
    SVGA3D_Z_D24S8_INT = 120,
    SVGA3D_FORMAT_MAX = 121
} ;
#line 1239 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dCopyBox {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
   uint32 srcx ;
   uint32 srcy ;
   uint32 srcz ;
};
#line 1251 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dCopyBox SVGA3dCopyBox;
#line 406 "include/drm/vmwgfx_drm.h"
struct drm_vmw_rect {
   int32_t x ;
   int32_t y ;
   uint32_t w ;
   uint32_t h ;
};
#line 470 "include/drm/vmwgfx_drm.h"
struct drm_vmw_cursor_bypass_arg {
   uint32_t flags ;
   uint32_t crtc_id ;
   int32_t xpos ;
   int32_t ypos ;
   int32_t xhot ;
   int32_t yhot ;
};
#line 766 "include/drm/vmwgfx_drm.h"
struct drm_vmw_update_layout_arg {
   uint32_t num_outputs ;
   uint32_t pad64 ;
   uint64_t rects ;
};
#line 281 "include/drm/ttm/ttm_bo_api.h"
enum ldv_27039 {
    ttm_bo_map_iomap = 129,
    ttm_bo_map_vmap = 2,
    ttm_bo_map_kmap = 3,
    ttm_bo_map_premapped = 132
} ;
#line 288 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bo_kmap_obj {
   void *virtual ;
   struct page *page ;
   enum ldv_27039 bo_kmap_type ;
   struct ttm_buffer_object *bo ;
};
#line 102 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer;
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer {
   struct drm_framebuffer base ;
   int (*pin)(struct vmw_framebuffer * ) ;
   int (*unpin)(struct vmw_framebuffer * ) ;
   bool dmabuf ;
   struct ttm_base_object *user_obj ;
   uint32_t user_handle ;
};
#line 71 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_display_unit {
   struct drm_crtc crtc ;
   struct drm_encoder encoder ;
   struct drm_connector connector ;
   struct vmw_surface *cursor_surface ;
   struct vmw_dma_buffer *cursor_dmabuf ;
   size_t cursor_age ;
   int cursor_x ;
   int cursor_y ;
   int hotspot_x ;
   int hotspot_y ;
   unsigned int unit ;
   unsigned int pref_width ;
   unsigned int pref_height ;
   bool pref_active ;
   struct drm_display_mode *pref_mode ;
   int gui_x ;
   int gui_y ;
   bool is_implicit ;
};
#line 163 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_clip_rect {
   int x1 ;
   int x2 ;
   int y1 ;
   int y2 ;
};
#line 198 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_279___0 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 205 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_281 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 489 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_surface {
   struct vmw_framebuffer base ;
   struct vmw_surface *surface ;
   struct vmw_dma_buffer *buffer ;
   struct list_head head ;
   struct drm_master *master ;
};
#line 544 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_283 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 564 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_285 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 824 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_dmabuf {
   struct vmw_framebuffer base ;
   struct vmw_dma_buffer *buffer ;
};
#line 861 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_287 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 864 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_289 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 894 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_291 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 904 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_293 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 944 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_295 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 951 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_297 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 1309 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_299 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1329 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_301 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1443 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_303 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1447 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_305 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 1461 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_307 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1476 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_309 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 146 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 234 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 18 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 19 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 23 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 24 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 193 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 201 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 215 "include/linux/kobject.h"
struct kernel_param;
#line 216 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 49 "include/linux/moduleparam.h"
struct kparam_string;
#line 49
struct kparam_array;
#line 49 "include/linux/moduleparam.h"
union __anonunion_ldv_13860_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 49 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_13860_134 ldv_13860 ;
};
#line 61 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 67 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 459 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 225 "include/linux/jump_label.h"
struct tracepoint;
#line 226 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 34 "include/linux/module.h"
struct module_param_attrs;
#line 34 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 43 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 69
struct exception_table_entry;
#line 198
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 204 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 219
struct module_sect_attrs;
#line 219
struct module_notes_attrs;
#line 219
struct ftrace_event_call;
#line 219 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 34 "include/linux/cdev.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 983 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_26597 {
    SVGA3D_QUERYSTATE_PENDING = 0,
    SVGA3D_QUERYSTATE_SUCCEEDED = 1,
    SVGA3D_QUERYSTATE_FAILED = 2,
    SVGA3D_QUERYSTATE_NEW = 3
} ;
#line 989 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_26597 SVGA3dQueryState;
#line 1697 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_37270_276 {
   uint32 result32 ;
};
#line 1697 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dQueryResult_275 {
   uint32 totalSize ;
   SVGA3dQueryState state ;
   union __anonunion_ldv_37270_276 ldv_37270 ;
};
#line 1697 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dQueryResult_275 SVGA3dQueryResult;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 309 "include/linux/kgdb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 181 "include/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 197 "include/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 284 "include/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 340 "include/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 353 "include/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 362 "include/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
#line 374 "include/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 390 "include/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 404
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 411
struct backlight_device;
#line 412
struct fb_info;
#line 413 "include/linux/fb.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 59 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 78 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
#line 136 "include/linux/backlight.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 457 "include/linux/fb.h"
struct fb_videomode;
#line 457 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 566 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 577 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
#line 606 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
#line 617 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
#line 705 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
#line 721 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 733 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 742 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 753 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 762 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
#line 781 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 900 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 901 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
#line 1150 "include/linux/fb.h"
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct __anonstruct_dirty_278 {
   spinlock_t lock ;
   bool active ;
   unsigned int x1 ;
   unsigned int y1 ;
   unsigned int x2 ;
   unsigned int y2 ;
};
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fb_par {
   struct vmw_private *vmw_priv ;
   void *vmalloc ;
   struct vmw_dma_buffer *vmw_bo ;
   struct ttm_bo_kmap_obj map ;
   u32 pseudo_palette[17U] ;
   unsigned int depth ;
   unsigned int bpp ;
   unsigned int max_width ;
   unsigned int max_height ;
   void *bo_ptr ;
   unsigned int bo_size ;
   bool bo_iowrite ;
   struct __anonstruct_dirty_278 dirty ;
};
#line 323 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_cmd_280 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 350 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_282___0 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 1779 "include/drm/drmP.h"
struct drm_vmw_getparam_arg {
   uint64_t value ;
   uint32_t param ;
   uint32_t pad64 ;
};
#line 520 "include/drm/vmwgfx_drm.h"
struct drm_vmw_get_3d_cap_arg {
   uint64_t buffer ;
   uint32_t max_size ;
   uint32_t pad64 ;
};
#line 704 "include/drm/vmwgfx_drm.h"
struct drm_vmw_present_arg {
   uint32_t fb_id ;
   uint32_t sid ;
   int32_t dest_x ;
   int32_t dest_y ;
   uint64_t clips_ptr ;
   uint32_t num_clips ;
   uint32_t pad64 ;
};
#line 739 "include/drm/vmwgfx_drm.h"
struct drm_vmw_present_readback_arg {
   uint32_t fb_id ;
   uint32_t num_clips ;
   uint64_t clips_ptr ;
   uint64_t fence_rep ;
};
#line 580 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
typedef int ldv_func_ret_type___13;
#line 171 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum SVGA3dSurfaceFormat SVGA3dSurfaceFormat;
#line 1136 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSize_61 {
   uint32 width ;
   uint32 height ;
   uint32 depth ;
};
#line 1136 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSize_61 SVGA3dSize;
#line 1137
enum ldv_9310 {
    SVGA3D_SURFACE_CUBEMAP = 1,
    SVGA3D_SURFACE_HINT_STATIC = 2,
    SVGA3D_SURFACE_HINT_DYNAMIC = 4,
    SVGA3D_SURFACE_HINT_INDEXBUFFER = 8,
    SVGA3D_SURFACE_HINT_VERTEXBUFFER = 16,
    SVGA3D_SURFACE_HINT_TEXTURE = 32,
    SVGA3D_SURFACE_HINT_RENDERTARGET = 64,
    SVGA3D_SURFACE_HINT_DEPTHSTENCIL = 128,
    SVGA3D_SURFACE_HINT_WRITEONLY = 256,
    SVGA3D_SURFACE_MASKABLE_ANTIALIAS = 512,
    SVGA3D_SURFACE_AUTOGENMIPMAPS = 1024
} ;
#line 1150 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9310 SVGA3dSurfaceFlags;
#line 1155 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceFace_62 {
   uint32 numMipLevels ;
};
#line 1155 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceFace_62 SVGA3dSurfaceFace;
#line 1178 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineSurface_63 {
   uint32 sid ;
   SVGA3dSurfaceFlags surfaceFlags ;
   SVGA3dSurfaceFormat format ;
   SVGA3dSurfaceFace face[6U] ;
};
#line 1178 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineSurface_63 SVGA3dCmdDefineSurface;
#line 1208 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroySurface_65 {
   uint32 sid ;
};
#line 1208 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroySurface_65 SVGA3dCmdDestroySurface;
#line 1213 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineContext_66 {
   uint32 cid ;
};
#line 1213 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineContext_66 SVGA3dCmdDefineContext;
#line 1218 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroyContext_67 {
   uint32 cid ;
};
#line 1218 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroyContext_67 SVGA3dCmdDestroyContext;
#line 1360 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceDMAFlags_80 {
   unsigned char discard : 1 ;
   unsigned char unsynchronized : 1 ;
   unsigned int reserved : 30 ;
};
#line 1360 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceDMAFlags_80 SVGA3dSurfaceDMAFlags;
#line 1412 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 {
   uint32 suffixSize ;
   uint32 maximumOffset ;
   SVGA3dSurfaceDMAFlags flags ;
};
#line 1412 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 SVGA3dCmdSurfaceDMASuffix;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 93 "include/drm/vmwgfx_drm.h"
struct drm_vmw_context_arg {
   int32_t cid ;
   uint32_t pad64 ;
};
#line 115 "include/drm/vmwgfx_drm.h"
struct drm_vmw_surface_create_req {
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   uint64_t size_addr ;
   int32_t shareable ;
   int32_t scanout ;
};
#line 162 "include/drm/vmwgfx_drm.h"
struct drm_vmw_surface_arg {
   int32_t sid ;
   uint32_t pad64 ;
};
#line 195 "include/drm/vmwgfx_drm.h"
union drm_vmw_surface_create_arg {
   struct drm_vmw_surface_arg rep ;
   struct drm_vmw_surface_create_req req ;
};
#line 209 "include/drm/vmwgfx_drm.h"
union drm_vmw_surface_reference_arg {
   struct drm_vmw_surface_create_req rep ;
   struct drm_vmw_surface_arg req ;
};
#line 320 "include/drm/vmwgfx_drm.h"
struct drm_vmw_alloc_dmabuf_req {
   uint32_t size ;
   uint32_t pad64 ;
};
#line 351 "include/drm/vmwgfx_drm.h"
struct drm_vmw_dmabuf_rep {
   uint64_t map_handle ;
   uint32_t handle ;
   uint32_t cur_gmr_id ;
   uint32_t cur_gmr_offset ;
   uint32_t pad64 ;
};
#line 372 "include/drm/vmwgfx_drm.h"
union drm_vmw_alloc_dmabuf_arg {
   struct drm_vmw_alloc_dmabuf_req req ;
   struct drm_vmw_dmabuf_rep rep ;
};
#line 386 "include/drm/vmwgfx_drm.h"
struct drm_vmw_unref_dmabuf_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 501 "include/drm/vmwgfx_drm.h"
struct drm_vmw_stream_arg {
   uint32_t stream_id ;
   uint32_t pad64 ;
};
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_user_context {
   struct ttm_base_object base ;
   struct vmw_resource res ;
};
#line 141 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_user_surface {
   struct ttm_base_object base ;
   struct vmw_surface srf ;
   uint32_t size ;
};
#line 147 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_user_dma_buffer {
   struct ttm_base_object base ;
   struct vmw_dma_buffer dma ;
};
#line 157 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_stream {
   struct vmw_resource res ;
   uint32_t stream_id ;
};
#line 162 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_user_stream {
   struct ttm_base_object base ;
   struct vmw_stream stream ;
};
#line 167 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_surface_offset {
   uint32_t face ;
   uint32_t mip ;
   uint32_t bo_offset ;
};
#line 366 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct __anonstruct_cmd_279___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 371 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct __anonstruct_281___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 395 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct __anonstruct_cmd_283___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 411 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct __anonstruct_285___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 605 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_bpp {
   uint8_t bpp ;
   uint8_t s_bpp ;
};
#line 625 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_surface_dma {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA body ;
   SVGA3dCopyBox cb ;
   SVGA3dCmdSurfaceDMASuffix suffix ;
};
#line 688 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_surface_define {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineSurface body ;
};
#line 693 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_surface_destroy {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroySurface body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 245 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct vmw_ttm_tt {
   struct ttm_tt ttm ;
   struct vmw_private *dev_priv ;
   int gmr_id ;
};
#line 45 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_reg.h"
struct svga_fifo_cmd_fence {
   __le32 fence ;
};
#line 27 "include/linux/wait.h"
struct __wait_queue;
#line 27 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 30 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 646 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_cmd_279___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 648 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_281___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 290
enum hrtimer_restart;
#line 163 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_legacy_display {
   struct list_head active ;
   unsigned int num_active ;
   unsigned int last_num_active ;
   struct vmw_framebuffer *fb ;
};
#line 150 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct vmw_legacy_display_unit {
   struct vmw_display_unit base ;
   struct list_head active ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 290
enum hrtimer_restart;
#line 1210 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdEscape {
   uint32 nsid ;
   uint32 size ;
};
#line 1228 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdEscape SVGAFifoCmdEscape;
#line 432 "include/drm/vmwgfx_drm.h"
struct drm_vmw_control_stream_arg {
   uint32_t stream_id ;
   uint32_t enabled ;
   uint32_t flags ;
   uint32_t color_key ;
   uint32_t handle ;
   uint32_t offset ;
   int32_t format ;
   uint32_t size ;
   uint32_t width ;
   uint32_t height ;
   uint32_t pitch[3U] ;
   uint32_t pad64 ;
   struct drm_vmw_rect src ;
   struct drm_vmw_rect dst ;
};
#line 51 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_header_278 {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 51 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_items_279 {
   uint32 registerId ;
   uint32 value ;
};
#line 51 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoSetRegs {
   struct __anonstruct_header_278 header ;
   struct __anonstruct_items_279 items[1U] ;
};
#line 76 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoSetRegs SVGAEscapeVideoSetRegs;
#line 77 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoFlush {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 82 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoFlush SVGAEscapeVideoFlush;
#line 88 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_escape.h"
struct vmw_stream___0 {
   struct vmw_dma_buffer *buf ;
   bool claimed ;
   bool paused ;
   struct drm_vmw_control_stream_arg saved ;
};
#line 148 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_overlay {
   struct mutex mutex ;
   struct vmw_stream___0 stream[1U] ;
};
#line 165 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_header {
   uint32_t cmd ;
   SVGAFifoCmdEscape body ;
};
#line 170 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_video_flush {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoFlush flush ;
};
#line 215 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_292 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 215 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_291 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_292 header ;
};
#line 219 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_items_294 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 229 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_298 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 229 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_297___0 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_298 header ;
};
#line 234 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_300 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 295 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_302 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 299 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_304 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker {
   struct list_head head ;
   uint32_t seqno ;
   struct timespec submitted ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmwgfx_gmrid_man {
   spinlock_t lock ;
   struct ida gmr_ida ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t used_gmr_pages ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 552 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_wait_arg {
   uint32_t handle ;
   int32_t cookie_valid ;
   uint64_t kernel_cookie ;
   uint64_t timeout_us ;
   int32_t lazy ;
   int32_t flags ;
   int32_t wait_options ;
   int32_t pad64 ;
};
#line 608 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_signaled_arg {
   uint32_t handle ;
   uint32_t flags ;
   int32_t signaled ;
   uint32_t passed_seqno ;
   uint32_t signaled_flags ;
   uint32_t pad64 ;
};
#line 637 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 659 "include/drm/vmwgfx_drm.h"
struct drm_vmw_event_fence {
   struct drm_event base ;
   uint64_t user_data ;
   uint32_t tv_sec ;
   uint32_t tv_usec ;
};
#line 682 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_event_arg {
   uint64_t fence_rep ;
   uint64_t user_data ;
   uint32_t handle ;
   uint32_t flags ;
};
#line 113 "include/drm/ttm/ttm_execbuf_util.h"
enum vmw_action_type {
    VMW_ACTION_EVENT = 0,
    VMW_ACTION_MAX = 1
} ;
#line 118 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_fence_action {
   struct list_head head ;
   enum vmw_action_type type ;
   void (*seq_passed)(struct vmw_fence_action * ) ;
   void (*cleanup)(struct vmw_fence_action * ) ;
};
#line 709 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fence_manager {
   int num_fence_objects ;
   struct vmw_private *dev_priv ;
   spinlock_t lock ;
   struct list_head fence_list ;
   struct work_struct work ;
   u32 user_fence_size ;
   u32 fence_size ;
   u32 event_fence_action_size ;
   bool fifo_down ;
   struct list_head cleanup_list ;
   uint32_t pending_actions[1U] ;
   struct mutex goal_irq_mutex ;
   bool goal_irq_on ;
   bool seqno_valid ;
};
#line 152 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_user_fence {
   struct ttm_base_object base ;
   struct vmw_fence_obj fence ;
};
#line 158 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_action {
   struct vmw_fence_action action ;
   struct list_head fpriv_head ;
   struct drm_pending_event *event ;
   struct vmw_fence_obj *fence ;
   struct drm_device *dev ;
   uint32_t *tv_sec ;
   uint32_t *tv_usec ;
};
#line 1093 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_pending {
   struct drm_pending_event base ;
   struct drm_vmw_event_fence event ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 290
enum hrtimer_restart;
#line 326 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 347 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestImage SVGAGuestImage;
#line 908 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_size_196 {
   uint32 width ;
   uint32 height ;
};
#line 908 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_root_197 {
   int32 x ;
   int32 y ;
};
#line 908 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAScreenObject {
   uint32 structSize ;
   uint32 id ;
   uint32 flags ;
   struct __anonstruct_size_196 size ;
   struct __anonstruct_root_197 root ;
   SVGAGuestImage backingStore ;
   uint32 cloneCount ;
};
#line 987 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAScreenObject SVGAScreenObject;
#line 1276 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDestroyScreen_200 {
   uint32 screenId ;
};
#line 1276 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDestroyScreen_200 SVGAFifoCmdDestroyScreen;
#line 163 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_screen_object_display {
   unsigned int num_implicit ;
   struct vmw_framebuffer *implicit_fb ;
};
#line 147 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct vmw_screen_object_unit {
   struct vmw_display_unit base ;
   unsigned long buffer_size ;
   struct vmw_dma_buffer *buffer ;
   bool defined ;
   bool active_implicit ;
};
#line 219 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_282 {
   uint32_t cmdType ;
};
#line 219 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_281 {
   struct __anonstruct_header_282 header ;
   SVGAScreenObject obj ;
};
#line 224 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_286 {
   uint32_t cmdType ;
};
#line 224 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_285___1 {
   struct __anonstruct_header_286 header ;
   SVGAScreenObject obj ;
};
#line 272 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_291 {
   uint32_t cmdType ;
};
#line 272 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_290 {
   struct __anonstruct_header_291 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 279 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_295 {
   uint32_t cmdType ;
};
#line 279 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_294 {
   struct __anonstruct_header_295 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 112 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 195 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 55 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 93 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 168 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_2(struct mutex *ldv_func_arg1 ) ;
#line 173
extern void mutex_unlock(struct mutex * ) ;
#line 176
void ldv_mutex_unlock_3(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_8(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 5 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 8
int ldv_mutex_lock_interruptible_13(struct mutex *ldv_func_arg1 ) ;
#line 11
extern void mutex_lock(struct mutex * ) ;
#line 14
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_4(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) ;
#line 36
int ldv_mutex_lock_interruptible_cmdbuf_mutex(struct mutex *lock ) ;
#line 39
void ldv_mutex_lock_cmdbuf_mutex(struct mutex *lock ) ;
#line 43
void ldv_mutex_unlock_cmdbuf_mutex(struct mutex *lock ) ;
#line 47
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) ;
#line 51
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) ;
#line 91
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 95
void ldv_mutex_lock_mutex(struct mutex *lock ) ;
#line 96
int ldv_mutex_trylock_mutex(struct mutex *lock ) ;
#line 99
void ldv_mutex_unlock_mutex(struct mutex *lock ) ;
#line 103
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) ;
#line 107
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) ;
#line 119
void ldv_mutex_lock_struct_mutex(struct mutex *lock ) ;
#line 123
void ldv_mutex_unlock_struct_mutex(struct mutex *lock ) ;
#line 127
void ldv_mutex_lock_update_lock(struct mutex *lock ) ;
#line 131
void ldv_mutex_unlock_update_lock(struct mutex *lock ) ;
#line 552 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 54 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 66
extern void vfree(void const   * ) ;
#line 39 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 41
  tmp = atomic_read((atomic_t const   *)(& kref->refcount));
#line 41
  __ret_warn_on = tmp == 0;
#line 41
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 41
  if (tmp___0 != 0L) {
#line 41
    warn_slowpath_null("include/linux/kref.h", 41);
  } else {

  }
#line 41
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 42
  atomic_inc(& kref->refcount);
#line 43
  return;
}
}
#line 40 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 42
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 46 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 50
  tmp = __builtin_object_size((void const   *)to, 0);
#line 50
  sz = (int )tmp;
#line 52
  might_fault();
#line 53
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 53
  if (tmp___1 != 0L) {
#line 54
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 53
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 53
    if (tmp___2 != 0L) {
#line 54
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 57
      __ret_warn_on = 1;
#line 57
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 57
      if (tmp___0 != 0L) {
#line 57
        warn_slowpath_fmt("/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/uaccess_64.h",
                          57, "Buffer overflow detected!\n");
      } else {

      }
#line 57
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 59
  return (n);
}
}
#line 63 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
#line 65
  might_fault();
#line 67
  tmp = _copy_to_user(dst, src, size);
#line 67
  return ((int )tmp);
}
}
#line 133 "include/drm/drmP.h"
extern int drm_err(char const   * , char const   *  , ...) ;
#line 317 "include/drm/ttm/ttm_bo_api.h"
__inline static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo ) 
{ 


  {
#line 319
  kref_get(& bo->kref);
#line 320
  return (bo);
}
}
#line 356
extern int ttm_bo_validate(struct ttm_buffer_object * , struct ttm_placement * , bool  ,
                           bool  , bool  ) ;
#line 368
extern void ttm_bo_unref(struct ttm_buffer_object ** ) ;
#line 216 "include/drm/ttm/ttm_object.h"
extern int ttm_ref_object_base_unref(struct ttm_object_file * , unsigned long  , enum ttm_ref_type  ) ;
#line 96 "include/drm/ttm/ttm_lock.h"
extern void ttm_read_unlock(struct ttm_lock * ) ;
#line 108
extern int ttm_read_lock(struct ttm_lock * , bool  ) ;
#line 69 "include/drm/ttm/ttm_execbuf_util.h"
extern void ttm_eu_backoff_reservation(struct list_head * ) ;
#line 96
extern int ttm_eu_reserve_buffers(struct list_head * ) ;
#line 110
extern void ttm_eu_fence_buffer_objects(struct list_head * , void * ) ;
#line 70 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) ;
#line 80
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) ;
#line 86
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) ;
#line 91
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) ;
#line 336 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_private *vmw_priv(struct drm_device *dev ) 
{ 


  {
#line 338
  return ((struct vmw_private *)dev->dev_private);
}
}
#line 341 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv ) 
{ 


  {
#line 343
  return ((struct vmw_fpriv *)file_priv->driver_priv);
}
}
#line 346 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_master *vmw_master(struct drm_master *master ) 
{ 


  {
#line 348
  return ((struct vmw_master *)master->driver_priv);
}
}
#line 386
void vmw_resource_unreference(struct vmw_resource **p_res ) ;
#line 392
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) ;
#line 405
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) ;
#line 418
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) ;
#line 430
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) ;
#line 432
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) ;
#line 433
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) ;
#line 443
void vmw_resource_unreserve(struct list_head *list ) ;
#line 466
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) ;
#line 493
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 494
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 495
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) ;
#line 500
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) ;
#line 515
struct ttm_placement vmw_vram_placement ;
#line 518
struct ttm_placement vmw_vram_gmr_placement ;
#line 530
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 532
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) ;
#line 543
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) ;
#line 546
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) ;
#line 550
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) ;
#line 571
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) ;
#line 577
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) ;
#line 595
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) ;
#line 617
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) ;
#line 618
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) ;
#line 674 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_surface_unreference(struct vmw_surface **srf ) 
{ 
  struct vmw_surface *tmp_srf ;
  struct vmw_resource *res ;

  {
#line 676
  tmp_srf = *srf;
#line 677
  res = & tmp_srf->res;
#line 678
  *srf = 0;
#line 680
  vmw_resource_unreference(& res);
#line 681
  return;
}
}
#line 689 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf ) 
{ 
  struct vmw_dma_buffer *tmp_buf ;
  struct ttm_buffer_object *bo ;

  {
#line 691
  tmp_buf = *buf;
#line 692
  bo = & tmp_buf->base;
#line 693
  *buf = 0;
#line 695
  ttm_bo_unref(& bo);
#line 696
  return;
}
}
#line 136 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_invalid(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                           SVGA3dCmdHeader *header ) 
{ 
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 140
  tmp___2 = capable(21);
#line 140
  if ((int )tmp___2 != 0) {
#line 140
    tmp___0 = capable(21);
#line 140
    tmp___1 = (int )tmp___0;
  } else {
#line 140
    tmp___1 = -22;
  }
#line 140
  return (tmp___1);
}
}
#line 143 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_ok(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                      SVGA3dCmdHeader *header ) 
{ 


  {
#line 147
  return (0);
}
}
#line 150 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_to_validate_list(struct vmw_sw_context *sw_context , struct vmw_resource **p_res ) 
{ 
  struct vmw_resource *res ;
  int tmp ;

  {
#line 153
  res = *p_res;
#line 155
  tmp = list_empty((struct list_head  const  *)(& res->validate_head));
#line 155
  if (tmp != 0) {
#line 156
    list_add_tail(& res->validate_head, & sw_context->resource_list);
#line 157
    *p_res = 0;
  } else {
#line 159
    vmw_resource_unreference(p_res);
  }
#line 160
  return;
}
}
#line 175 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_bo_to_validate_list(struct vmw_sw_context *sw_context , struct ttm_buffer_object *bo ,
                                   uint32_t fence_flags , uint32_t *p_val_node ) 
{ 
  uint32_t val_node ;
  struct ttm_validate_buffer *val_buf ;
  long tmp ;
  long tmp___0 ;

  {
#line 183
  val_node = vmw_dmabuf_validate_node(bo, sw_context->cur_val_buf);
#line 185
  tmp = ldv__builtin_expect(val_node > 2047U, 0L);
#line 185
  if (tmp != 0L) {
#line 186
    drm_err("vmw_bo_to_validate_list", "Max number of DMA buffers per submission exceeded.\n");
#line 188
    return (-22);
  } else {

  }
#line 191
  val_buf = (struct ttm_validate_buffer *)(& sw_context->val_bufs) + (unsigned long )val_node;
#line 192
  tmp___0 = ldv__builtin_expect(sw_context->cur_val_buf == val_node, 0L);
#line 192
  if (tmp___0 != 0L) {
#line 193
    val_buf->new_sync_obj_arg = 0;
#line 194
    val_buf->bo = ttm_bo_reference(bo);
#line 195
    list_add_tail(& val_buf->head, & sw_context->validate_nodes);
#line 196
    sw_context->cur_val_buf = sw_context->cur_val_buf + (uint32_t )1;
  } else {

  }
#line 199
  val_buf->new_sync_obj_arg = (void *)((unsigned long )val_buf->new_sync_obj_arg | (unsigned long )fence_flags);
#line 201
  sw_context->fence_flags = sw_context->fence_flags | fence_flags;
#line 203
  if ((unsigned long )p_val_node != (unsigned long )((uint32_t *)0)) {
#line 204
    *p_val_node = val_node;
  } else {

  }
#line 206
  return (0);
}
}
#line 209 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_cid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  struct vmw_resource *ctx ;
  struct vmw_cid_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 221
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 221
  cmd = (struct vmw_cid_cmd *)__mptr;
#line 222
  tmp = ldv__builtin_expect((long )sw_context->cid_valid, 1L);
#line 222
  if (tmp != 0L) {
#line 222
    tmp___0 = ldv__builtin_expect(cmd->cid == sw_context->last_cid, 1L);
#line 222
    if (tmp___0 != 0L) {
#line 223
      return (0);
    } else {

    }
  } else {

  }
#line 225
  ret = vmw_context_check(dev_priv, sw_context->tfile, (int )cmd->cid, & ctx);
#line 227
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 227
  if (tmp___1 != 0L) {
#line 228
    drm_err("vmw_cmd_cid_check", "Could not find or use context %u\n", cmd->cid);
#line 230
    return (ret);
  } else {

  }
#line 233
  sw_context->last_cid = cmd->cid;
#line 234
  sw_context->cid_valid = 1;
#line 235
  sw_context->cur_ctx = ctx;
#line 236
  vmw_resource_to_validate_list(sw_context, & ctx);
#line 238
  return (0);
}
}
#line 241 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_sid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             uint32_t *sid ) 
{ 
  struct vmw_surface *srf ;
  int ret ;
  struct vmw_resource *res ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 249
  if (*sid == 4294967295U) {
#line 250
    return (0);
  } else {

  }
#line 252
  tmp = ldv__builtin_expect((long )sw_context->sid_valid, 1L);
#line 252
  if (tmp != 0L) {
#line 252
    tmp___0 = ldv__builtin_expect(*sid == sw_context->last_sid, 1L);
#line 252
    if (tmp___0 != 0L) {
#line 254
      *sid = sw_context->sid_translation;
#line 255
      return (0);
    } else {

    }
  } else {

  }
#line 258
  ret = vmw_user_surface_lookup_handle(dev_priv, sw_context->tfile, *sid, & srf);
#line 261
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 261
  if (tmp___1 != 0L) {
#line 262
    drm_err("vmw_cmd_sid_check", "Could ot find or use surface 0x%08x address 0x%08lx\n",
            *sid, (unsigned long )sid);
#line 266
    return (ret);
  } else {

  }
#line 269
  ret = vmw_surface_validate(dev_priv, srf);
#line 270
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 270
  if (tmp___2 != 0L) {
#line 271
    if (ret != -512) {
#line 272
      drm_err("vmw_cmd_sid_check", "Could not validate surface.\n");
    } else {

    }
#line 273
    vmw_surface_unreference(& srf);
#line 274
    return (ret);
  } else {

  }
#line 277
  sw_context->last_sid = *sid;
#line 278
  sw_context->sid_valid = 1;
#line 279
  sw_context->sid_translation = (uint32_t )srf->res.id;
#line 280
  *sid = sw_context->sid_translation;
#line 282
  res = & srf->res;
#line 283
  vmw_resource_to_validate_list(sw_context, & res);
#line 285
  return (0);
}
}
#line 289 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                           SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd *cmd ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;

  {
#line 299
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 300
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 300
  if (tmp != 0L) {
#line 301
    return (ret);
  } else {

  }
#line 303
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 303
  cmd = (struct vmw_sid_cmd *)__mptr;
#line 304
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.target.sid);
#line 305
  return (ret);
}
}
#line 308 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 318
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 318
  cmd = (struct vmw_sid_cmd___0 *)__mptr;
#line 319
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.src.sid);
#line 320
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 320
  if (tmp != 0L) {
#line 321
    return (ret);
  } else {

  }
#line 322
  tmp___0 = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.dest.sid);
#line 322
  return (tmp___0);
}
}
#line 325 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                     SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___1 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 335
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 335
  cmd = (struct vmw_sid_cmd___1 *)__mptr;
#line 336
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.src.sid);
#line 337
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 337
  if (tmp != 0L) {
#line 338
    return (ret);
  } else {

  }
#line 339
  tmp___0 = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.dest.sid);
#line 339
  return (tmp___0);
}
}
#line 342 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                         SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___2 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 351
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 351
  cmd = (struct vmw_sid_cmd___2 *)__mptr;
#line 353
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 353
  if (tmp != 0L) {
#line 354
    drm_err("vmw_cmd_blt_surf_screen_check", "Kernel only SVGA3d command: %u.\n",
            cmd->header.id);
#line 355
    return (-1);
  } else {

  }
#line 358
  tmp___0 = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.srcImage.sid);
#line 358
  return (tmp___0);
}
}
#line 361 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_present_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                 SVGA3dCmdHeader *header ) 
{ 
  struct vmw_sid_cmd___3 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 371
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 371
  cmd = (struct vmw_sid_cmd___3 *)__mptr;
#line 373
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 373
  if (tmp != 0L) {
#line 374
    drm_err("vmw_cmd_present_check", "Kernel only SVGA3d command: %u.\n", cmd->header.id);
#line 375
    return (-1);
  } else {

  }
#line 378
  tmp___0 = vmw_cmd_sid_check(dev_priv, sw_context, & cmd->body.sid);
#line 378
  return (tmp___0);
}
}
#line 397 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv , uint32_t cid ,
                                       struct ttm_buffer_object *new_query_bo , struct vmw_sw_context *sw_context ) 
{ 
  int ret ;
  bool add_cid ;
  uint32_t cid_to_add ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  struct vmw_resource *ctx ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 403
  add_cid = 0;
#line 406
  tmp___4 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )new_query_bo,
                             0L);
#line 406
  if (tmp___4 != 0L) {
#line 408
    tmp = ldv__builtin_expect(new_query_bo->num_pages > 4UL, 0L);
#line 408
    if (tmp != 0L) {
#line 409
      drm_err("vmw_query_bo_switch_prepare", "Query buffer too large.\n");
#line 410
      return (-22);
    } else {

    }
#line 413
    tmp___2 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )((struct ttm_buffer_object *)0),
                               0L);
#line 413
    if (tmp___2 != 0L) {
#line 414
      tmp___0 = ldv__builtin_expect((long )(! sw_context->query_cid_valid), 0L);
#line 414
      if (tmp___0 != 0L) {
#line 414
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                             "i" (414), "i" (12UL));
        ldv_39147: ;
#line 414
        goto ldv_39147;
      } else {

      }
#line 415
      add_cid = 1;
#line 416
      cid_to_add = sw_context->cur_query_cid;
#line 417
      ret = vmw_bo_to_validate_list(sw_context, sw_context->cur_query_bo, 1U, 0);
#line 421
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 421
      if (tmp___1 != 0L) {
#line 422
        return (ret);
      } else {

      }
    } else {

    }
#line 424
    sw_context->cur_query_bo = new_query_bo;
#line 426
    ret = vmw_bo_to_validate_list(sw_context, dev_priv->dummy_query_bo, 1U, 0);
#line 430
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 430
    if (tmp___3 != 0L) {
#line 431
      return (ret);
    } else {

    }
  } else {

  }
#line 435
  tmp___5 = ldv__builtin_expect(sw_context->cur_query_cid != cid, 0L);
#line 435
  if (tmp___5 != 0L) {
#line 435
    tmp___6 = ldv__builtin_expect((long )sw_context->query_cid_valid, 0L);
#line 435
    if (tmp___6 != 0L) {
#line 437
      add_cid = 1;
#line 438
      cid_to_add = sw_context->cur_query_cid;
    } else {

    }
  } else {

  }
#line 441
  sw_context->cur_query_cid = cid;
#line 442
  sw_context->query_cid_valid = 1;
#line 444
  if ((int )add_cid) {
#line 445
    ctx = sw_context->cur_ctx;
#line 447
    tmp___7 = list_empty((struct list_head  const  *)(& ctx->query_head));
#line 447
    if (tmp___7 != 0) {
#line 448
      list_add_tail(& ctx->query_head, & sw_context->query_list);
    } else {

    }
#line 450
    ret = vmw_bo_to_validate_list(sw_context, dev_priv->dummy_query_bo, 1U, 0);
#line 454
    tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 454
    if (tmp___8 != 0L) {
#line 455
      return (ret);
    } else {

    }
  } else {

  }
#line 457
  return (0);
}
}
#line 479 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_query_bo_switch_commit(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ 
  struct vmw_resource *ctx ;
  struct vmw_resource *next_ctx ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 491
  __mptr = (struct list_head  const  *)sw_context->query_list.next;
#line 491
  ctx = (struct vmw_resource *)__mptr + 0xffffffffffffffb0UL;
#line 491
  __mptr___0 = (struct list_head  const  *)ctx->query_head.next;
#line 491
  next_ctx = (struct vmw_resource *)__mptr___0 + 0xffffffffffffffb0UL;
#line 491
  goto ldv_39165;
  ldv_39164: 
#line 493
  list_del_init(& ctx->query_head);
#line 495
  tmp = list_empty((struct list_head  const  *)(& ctx->validate_head));
#line 495
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 495
  if (tmp___0 != 0L) {
#line 495
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (495), "i" (12UL));
    ldv_39162: ;
#line 495
    goto ldv_39162;
  } else {

  }
#line 497
  ret = vmw_fifo_emit_dummy_query(dev_priv, (uint32_t )ctx->id);
#line 499
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 499
  if (tmp___1 != 0L) {
#line 500
    drm_err("vmw_query_bo_switch_commit", "Out of fifo space for dummy query.\n");
  } else {

  }
#line 491
  ctx = next_ctx;
#line 491
  __mptr___1 = (struct list_head  const  *)next_ctx->query_head.next;
#line 491
  next_ctx = (struct vmw_resource *)__mptr___1 + 0xffffffffffffffb0UL;
  ldv_39165: ;
#line 491
  if ((unsigned long )(& ctx->query_head) != (unsigned long )(& sw_context->query_list)) {
#line 492
    goto ldv_39164;
  } else {

  }

#line 503
  if ((unsigned long )dev_priv->pinned_bo != (unsigned long )sw_context->cur_query_bo) {
#line 504
    if ((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 505
      vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 506
      ttm_bo_unref(& dev_priv->pinned_bo);
    } else {

    }
#line 509
    vmw_bo_pin(sw_context->cur_query_bo, 1);
#line 517
    vmw_bo_pin(dev_priv->dummy_query_bo, 1);
#line 518
    dev_priv->dummy_query_bo_pinned = 1;
#line 520
    dev_priv->query_cid = sw_context->cur_query_cid;
#line 521
    dev_priv->pinned_bo = ttm_bo_reference(sw_context->cur_query_bo);
  } else {

  }
#line 524
  return;
}
}
#line 534 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_query_switch_backoff(struct vmw_sw_context *sw_context ) 
{ 
  struct list_head *list ;
  struct list_head *next ;

  {
#line 538
  list = sw_context->query_list.next;
#line 538
  next = list->next;
#line 538
  goto ldv_39173;
  ldv_39172: 
#line 539
  list_del_init(list);
#line 538
  list = next;
#line 538
  next = list->next;
  ldv_39173: ;
#line 538
  if ((unsigned long )(& sw_context->query_list) != (unsigned long )list) {
#line 539
    goto ldv_39172;
  } else {

  }

#line 543
  return;
}
}
#line 543 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_translate_guest_ptr(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                   SVGAGuestPtr *ptr , struct vmw_dma_buffer **vmw_bo_p ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  uint32_t handle ;
  struct vmw_relocation *reloc ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 548
  vmw_bo = 0;
#line 550
  handle = ptr->gmrId;
#line 554
  ret = vmw_user_dmabuf_lookup(sw_context->tfile, handle, & vmw_bo);
#line 555
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 555
  if (tmp != 0L) {
#line 556
    drm_err("vmw_translate_guest_ptr", "Could not find or use GMR region.\n");
#line 557
    return (-22);
  } else {

  }
#line 559
  bo = & vmw_bo->base;
#line 561
  tmp___0 = ldv__builtin_expect(sw_context->cur_reloc > 2047U, 0L);
#line 561
  if (tmp___0 != 0L) {
#line 562
    drm_err("vmw_translate_guest_ptr", "Max number relocations per submission exceeded\n");
#line 564
    ret = -22;
#line 565
    goto out_no_reloc;
  } else {

  }
#line 568
  tmp___1 = sw_context->cur_reloc;
#line 568
  sw_context->cur_reloc = sw_context->cur_reloc + (uint32_t )1;
#line 568
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )tmp___1;
#line 569
  reloc->location = ptr;
#line 571
  ret = vmw_bo_to_validate_list(sw_context, bo, 1U, & reloc->index);
#line 573
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 573
  if (tmp___2 != 0L) {
#line 574
    goto out_no_reloc;
  } else {

  }
#line 576
  *vmw_bo_p = vmw_bo;
#line 577
  return (0);
  out_no_reloc: 
#line 580
  vmw_dmabuf_unreference(& vmw_bo);
#line 581
  vmw_bo_p = 0;
#line 582
  return (ret);
}
}
#line 585 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_end_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 596
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 596
  cmd = (struct vmw_query_cmd *)__mptr;
#line 597
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 598
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 598
  if (tmp != 0L) {
#line 599
    return (ret);
  } else {

  }
#line 601
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 604
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 604
  if (tmp___0 != 0L) {
#line 605
    return (ret);
  } else {

  }
#line 607
  ret = vmw_query_bo_switch_prepare(dev_priv, cmd->q.cid, & vmw_bo->base, sw_context);
#line 610
  vmw_dmabuf_unreference(& vmw_bo);
#line 611
  return (ret);
}
}
#line 614 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_wait_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd___0 *cmd ;
  int ret ;
  struct vmw_resource *ctx ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 626
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 626
  cmd = (struct vmw_query_cmd___0 *)__mptr;
#line 627
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 628
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 628
  if (tmp != 0L) {
#line 629
    return (ret);
  } else {

  }
#line 631
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 634
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 634
  if (tmp___0 != 0L) {
#line 635
    return (ret);
  } else {

  }
#line 637
  vmw_dmabuf_unreference(& vmw_bo);
#line 644
  ctx = sw_context->cur_ctx;
#line 645
  tmp___1 = list_empty((struct list_head  const  *)(& ctx->query_head));
#line 645
  if (tmp___1 == 0) {
#line 646
    list_del_init(& ctx->query_head);
  } else {

  }
#line 648
  return (0);
}
}
#line 651 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_dma(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                       SVGA3dCmdHeader *header ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  struct vmw_surface *srf ;
  struct vmw_dma_cmd *cmd ;
  int ret ;
  struct vmw_resource *res ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 655
  vmw_bo = 0;
#line 657
  srf = 0;
#line 665
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 665
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 666
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->dma.guest.ptr, & vmw_bo);
#line 669
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 669
  if (tmp != 0L) {
#line 670
    return (ret);
  } else {

  }
#line 672
  bo = & vmw_bo->base;
#line 673
  ret = vmw_user_surface_lookup_handle(dev_priv, sw_context->tfile, cmd->dma.host.sid,
                                       & srf);
#line 675
  if (ret != 0) {
#line 676
    drm_err("vmw_cmd_dma", "could not find surface\n");
#line 677
    goto out_no_reloc;
  } else {

  }
#line 680
  ret = vmw_surface_validate(dev_priv, srf);
#line 681
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 681
  if (tmp___0 != 0L) {
#line 682
    if (ret != -512) {
#line 683
      drm_err("vmw_cmd_dma", "Culd not validate surface.\n");
    } else {

    }
#line 684
    goto out_no_validate;
  } else {

  }
#line 690
  cmd->dma.host.sid = (uint32 )srf->res.id;
#line 691
  vmw_kms_cursor_snoop(srf, sw_context->tfile, bo, header);
#line 693
  vmw_dmabuf_unreference(& vmw_bo);
#line 695
  res = & srf->res;
#line 696
  vmw_resource_to_validate_list(sw_context, & res);
#line 698
  return (0);
  out_no_validate: 
#line 701
  vmw_surface_unreference(& srf);
  out_no_reloc: 
#line 703
  vmw_dmabuf_unreference(& vmw_bo);
#line 704
  return (ret);
}
}
#line 707 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_draw(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                        SVGA3dCmdHeader *header ) 
{ 
  struct vmw_draw_cmd *cmd ;
  SVGA3dVertexDecl *decl ;
  SVGA3dPrimitiveRange *range ;
  uint32_t i ;
  uint32_t maxnum ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 715
  decl = (SVGA3dVertexDecl *)((unsigned long )header + 20UL);
#line 722
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 723
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 723
  if (tmp != 0L) {
#line 724
    return (ret);
  } else {

  }
#line 726
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 726
  cmd = (struct vmw_draw_cmd *)__mptr;
#line 727
  maxnum = (uint32_t )(((unsigned long )header->size - 12UL) / 36UL);
#line 729
  tmp___0 = ldv__builtin_expect(cmd->body.numVertexDecls > maxnum, 0L);
#line 729
  if (tmp___0 != 0L) {
#line 730
    drm_err("vmw_cmd_draw", "Illegal number of vertex declarations.\n");
#line 731
    return (-22);
  } else {

  }
#line 734
  i = 0U;
#line 734
  goto ldv_39252;
  ldv_39251: 
#line 735
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & decl->array.surfaceId);
#line 737
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 737
  if (tmp___1 != 0L) {
#line 738
    return (ret);
  } else {

  }
#line 734
  i = i + (uint32_t )1;
#line 734
  decl = decl + 1;
  ldv_39252: ;
#line 734
  if (cmd->body.numVertexDecls > i) {
#line 735
    goto ldv_39251;
  } else {

  }
#line 741
  maxnum = (uint32_t )((((unsigned long )header->size - (unsigned long )cmd->body.numVertexDecls * 36UL) - 12UL) / 28UL);
#line 743
  tmp___2 = ldv__builtin_expect(cmd->body.numRanges > maxnum, 0L);
#line 743
  if (tmp___2 != 0L) {
#line 744
    drm_err("vmw_cmd_draw", "Illegal number of index ranges.\n");
#line 745
    return (-22);
  } else {

  }
#line 748
  range = (SVGA3dPrimitiveRange *)decl;
#line 749
  i = 0U;
#line 749
  goto ldv_39255;
  ldv_39254: 
#line 750
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & range->indexArray.surfaceId);
#line 752
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 752
  if (tmp___3 != 0L) {
#line 753
    return (ret);
  } else {

  }
#line 749
  i = i + (uint32_t )1;
#line 749
  range = range + 1;
  ldv_39255: ;
#line 749
  if (cmd->body.numRanges > i) {
#line 750
    goto ldv_39254;
  } else {

  }

#line 755
  return (0);
}
}
#line 759 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_tex_state(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ 
  SVGA3dTextureState *last_state ;
  SVGA3dTextureState *cur_state ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 768
  last_state = (SVGA3dTextureState *)(((unsigned long )header->size + (unsigned long )header) + 8UL);
#line 770
  cur_state = (SVGA3dTextureState *)((unsigned long )header + 12UL);
#line 774
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 775
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 775
  if (tmp != 0L) {
#line 776
    return (ret);
  } else {

  }
#line 778
  goto ldv_39270;
  ldv_39269: 
#line 779
  tmp___0 = ldv__builtin_expect((unsigned int )cur_state->name != 1U, 1L);
#line 779
  if (tmp___0 != 0L) {
#line 780
    goto ldv_39268;
  } else {

  }
#line 782
  ret = vmw_cmd_sid_check(dev_priv, sw_context, & cur_state->ldv_7489.value);
#line 784
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 784
  if (tmp___1 != 0L) {
#line 785
    return (ret);
  } else {

  }
  ldv_39268: 
#line 778
  cur_state = cur_state + 1;
  ldv_39270: ;
#line 778
  if ((unsigned long )cur_state < (unsigned long )last_state) {
#line 779
    goto ldv_39269;
  } else {

  }

#line 788
  return (0);
}
}
#line 791 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      void *buf ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  int ret ;
  struct __anonstruct_cmd_279 *cmd ;
  long tmp ;

  {
#line 801
  cmd = (struct __anonstruct_282 *)buf;
#line 803
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->body.ptr, & vmw_bo);
#line 806
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 806
  if (tmp != 0L) {
#line 807
    return (ret);
  } else {

  }
#line 809
  vmw_dmabuf_unreference(& vmw_bo);
#line 811
  return (ret);
}
}
#line 814 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_not_3d(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                void *buf , uint32_t *size ) 
{ 
  uint32_t size_remaining ;
  uint32_t cmd_id ;
  long tmp ;
  int tmp___0 ;

  {
#line 818
  size_remaining = *size;
#line 821
  cmd_id = *((uint32_t *)buf);
#line 822
  switch (cmd_id) {
  case (uint32_t )1: 
#line 824
  *size = 20U;
#line 825
  goto ldv_39292;
  case (uint32_t )36: 
#line 827
  *size = 20U;
#line 828
  goto ldv_39292;
  case (uint32_t )37: 
#line 830
  *size = 32U;
#line 831
  goto ldv_39292;
  case (uint32_t )38: 
#line 833
  *size = 32U;
#line 834
  goto ldv_39292;
  default: 
#line 836
  drm_err("vmw_cmd_check_not_3d", "Unsupported SVGA command: %u.\n", cmd_id);
#line 837
  return (-22);
  }
  ldv_39292: ;
#line 840
  if (*size > size_remaining) {
#line 841
    drm_err("vmw_cmd_check_not_3d", "Invalid SVGA command (size mismatch): %u.\n",
            cmd_id);
#line 843
    return (-22);
  } else {

  }
#line 846
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 846
  if (tmp != 0L) {
#line 847
    drm_err("vmw_cmd_check_not_3d", "Kernel only SVGA command: %u.\n", cmd_id);
#line 848
    return (-1);
  } else {

  }
#line 851
  if (cmd_id == 36U) {
#line 852
    tmp___0 = vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);
#line 852
    return (tmp___0);
  } else {

  }
#line 854
  return (0);
}
}
#line 864 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static vmw_cmd_func vmw_cmd_funcs[1082U]  = 
#line 864
  {      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_surface_copy_check,      & vmw_cmd_stretch_blt_check, 
        & vmw_cmd_dma,      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_set_render_target_check,      & vmw_cmd_tex_state, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_present_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_draw, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_end_query,      & vmw_cmd_wait_query, 
        & vmw_cmd_ok,      & vmw_cmd_blt_surf_screen_check};
#line 899 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                         void *buf , uint32_t *size ) 
{ 
  uint32_t cmd_id ;
  uint32_t size_remaining ;
  SVGA3dCmdHeader *header ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 904
  size_remaining = *size;
#line 905
  header = (SVGA3dCmdHeader *)buf;
#line 908
  cmd_id = *((uint32_t *)buf);
#line 910
  tmp___0 = ldv__builtin_expect(cmd_id <= 42U, 0L);
#line 910
  if (tmp___0 != 0L) {
#line 911
    tmp = vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);
#line 911
    return (tmp);
  } else {

  }
#line 914
  cmd_id = header->id;
#line 915
  *size = header->size + 8U;
#line 917
  cmd_id = cmd_id - 1040U;
#line 918
  tmp___1 = ldv__builtin_expect(*size > size_remaining, 0L);
#line 918
  if (tmp___1 != 0L) {
#line 919
    goto out_err;
  } else {

  }
#line 921
  tmp___2 = ldv__builtin_expect(cmd_id > 41U, 0L);
#line 921
  if (tmp___2 != 0L) {
#line 922
    goto out_err;
  } else {

  }
#line 924
  ret = (*(vmw_cmd_funcs[cmd_id]))(dev_priv, sw_context, header);
#line 925
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 925
  if (tmp___3 != 0L) {
#line 926
    goto out_err;
  } else {

  }
#line 928
  return (0);
  out_err: 
#line 930
  drm_err("vmw_cmd_check", "Illegal / Invalid SVGA3D command: %d\n", cmd_id + 1040U);
#line 932
  return (-22);
}
}
#line 935 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_all(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             void *buf , uint32_t size ) 
{ 
  int32_t cur_size ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 940
  cur_size = (int32_t )size;
#line 943
  goto ldv_39324;
  ldv_39323: 
#line 944
  size = (uint32_t )cur_size;
#line 945
  ret = vmw_cmd_check(dev_priv, sw_context, buf, & size);
#line 946
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 946
  if (tmp != 0L) {
#line 947
    return (ret);
  } else {

  }
#line 948
  buf = (void *)((unsigned long )size + (unsigned long )buf);
#line 949
  cur_size = (int32_t )((uint32_t )cur_size - size);
  ldv_39324: ;
#line 943
  if (cur_size > 0) {
#line 944
    goto ldv_39323;
  } else {

  }
#line 952
  tmp___0 = ldv__builtin_expect(cur_size != 0, 0L);
#line 952
  if (tmp___0 != 0L) {
#line 953
    drm_err("vmw_cmd_check_all", "Command verifier out of sync.\n");
#line 954
    return (-22);
  } else {

  }
#line 957
  return (0);
}
}
#line 960 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_free_relocations(struct vmw_sw_context *sw_context ) 
{ 


  {
#line 962
  sw_context->cur_reloc = 0U;
#line 963
  return;
}
}
#line 965 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_apply_relocations(struct vmw_sw_context *sw_context ) 
{ 
  uint32_t i ;
  struct vmw_relocation *reloc ;
  struct ttm_validate_buffer *validate ;
  struct ttm_buffer_object *bo ;

  {
#line 972
  i = 0U;
#line 972
  goto ldv_39338;
  ldv_39337: 
#line 973
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )i;
#line 974
  validate = (struct ttm_validate_buffer *)(& sw_context->val_bufs) + (unsigned long )reloc->index;
#line 975
  bo = validate->bo;
#line 976
  if (bo->mem.mem_type == 2U) {
#line 977
    (reloc->location)->offset = (reloc->location)->offset + (uint32 )bo->offset;
#line 978
    (reloc->location)->gmrId = 4294967294U;
  } else {
#line 980
    (reloc->location)->gmrId = (uint32 )bo->mem.start;
  }
#line 972
  i = i + (uint32_t )1;
  ldv_39338: ;
#line 972
  if (sw_context->cur_reloc > i) {
#line 973
    goto ldv_39337;
  } else {

  }
#line 982
  vmw_free_relocations(sw_context);
#line 983
  return;
}
}
#line 985 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_clear_validations(struct vmw_sw_context *sw_context ) 
{ 
  struct ttm_validate_buffer *entry ;
  struct ttm_validate_buffer *next ;
  struct vmw_resource *res ;
  struct vmw_resource *res_next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
#line 993
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 993
  entry = (struct ttm_validate_buffer *)__mptr;
#line 993
  __mptr___0 = (struct list_head  const  *)entry->head.next;
#line 993
  next = (struct ttm_validate_buffer *)__mptr___0;
#line 993
  goto ldv_39354;
  ldv_39353: 
#line 995
  list_del(& entry->head);
#line 996
  vmw_dmabuf_validate_clear(entry->bo);
#line 997
  ttm_bo_unref(& entry->bo);
#line 998
  sw_context->cur_val_buf = sw_context->cur_val_buf - (uint32_t )1;
#line 993
  entry = next;
#line 993
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 993
  next = (struct ttm_validate_buffer *)__mptr___1;
  ldv_39354: ;
#line 993
  if ((unsigned long )(& entry->head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 994
    goto ldv_39353;
  } else {

  }
#line 1000
  tmp = ldv__builtin_expect(sw_context->cur_val_buf != 0U, 0L);
#line 1000
  if (tmp != 0L) {
#line 1000
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (1000), "i" (12UL));
    ldv_39356: ;
#line 1000
    goto ldv_39356;
  } else {

  }
#line 1005
  vmw_resource_unreserve(& sw_context->resource_list);
#line 1006
  __mptr___2 = (struct list_head  const  *)sw_context->resource_list.next;
#line 1006
  res = (struct vmw_resource *)__mptr___2 + 0xffffffffffffffc0UL;
#line 1006
  __mptr___3 = (struct list_head  const  *)res->validate_head.next;
#line 1006
  res_next = (struct vmw_resource *)__mptr___3 + 0xffffffffffffffc0UL;
#line 1006
  goto ldv_39364;
  ldv_39363: 
#line 1008
  list_del_init(& res->validate_head);
#line 1009
  vmw_resource_unreference(& res);
#line 1006
  res = res_next;
#line 1006
  __mptr___4 = (struct list_head  const  *)res_next->validate_head.next;
#line 1006
  res_next = (struct vmw_resource *)__mptr___4 + 0xffffffffffffffc0UL;
  ldv_39364: ;
#line 1006
  if ((unsigned long )(& res->validate_head) != (unsigned long )(& sw_context->resource_list)) {
#line 1007
    goto ldv_39363;
  } else {

  }

#line 1011
  return;
}
}
#line 1013 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_single_buffer(struct vmw_private *dev_priv , struct ttm_buffer_object *bo ) 
{ 
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1023
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )bo || ((unsigned long )dev_priv->dummy_query_bo == (unsigned long )bo && (int )dev_priv->dummy_query_bo_pinned)) {
#line 1026
    return (0);
  } else {

  }
#line 1035
  ret = ttm_bo_validate(bo, & vmw_vram_gmr_placement, 1, 0, 0);
#line 1036
  tmp = ldv__builtin_expect(ret == 0, 1L);
#line 1036
  if (tmp != 0L) {
#line 1037
    return (ret);
  } else {
#line 1036
    tmp___0 = ldv__builtin_expect(ret == -512, 1L);
#line 1036
    if (tmp___0 != 0L) {
#line 1037
      return (ret);
    } else {

    }
  }
#line 1044
  printk("<6>[drm] Falling through to VRAM.\n");
#line 1045
  ret = ttm_bo_validate(bo, & vmw_vram_placement, 1, 0, 0);
#line 1046
  return (ret);
}
}
#line 1050 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_buffers(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ 
  struct ttm_validate_buffer *entry ;
  int ret ;
  struct list_head  const  *__mptr ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1056
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 1056
  entry = (struct ttm_validate_buffer *)__mptr;
#line 1056
  goto ldv_39382;
  ldv_39381: 
#line 1057
  ret = vmw_validate_single_buffer(dev_priv, entry->bo);
#line 1058
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1058
  if (tmp != 0L) {
#line 1059
    return (ret);
  } else {

  }
#line 1056
  __mptr___0 = (struct list_head  const  *)entry->head.next;
#line 1056
  entry = (struct ttm_validate_buffer *)__mptr___0;
  ldv_39382: ;
#line 1056
  if ((unsigned long )(& entry->head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 1057
    goto ldv_39381;
  } else {

  }

#line 1061
  return (0);
}
}
#line 1064 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context , uint32_t size ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 1067
  tmp = ldv__builtin_expect(sw_context->cmd_bounce_size >= size, 1L);
#line 1067
  if (tmp != 0L) {
#line 1068
    return (0);
  } else {

  }
#line 1070
  if (sw_context->cmd_bounce_size == 0U) {
#line 1071
    sw_context->cmd_bounce_size = 32768U;
  } else {

  }
#line 1073
  goto ldv_39389;
  ldv_39388: 
#line 1074
  sw_context->cmd_bounce_size = ((sw_context->cmd_bounce_size + (sw_context->cmd_bounce_size >> 1)) + 4095U) & 4294963200U;
  ldv_39389: ;
#line 1073
  if (sw_context->cmd_bounce_size < size) {
#line 1074
    goto ldv_39388;
  } else {

  }

#line 1079
  if ((unsigned long )sw_context->cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 1080
    vfree((void const   *)sw_context->cmd_bounce);
  } else {

  }
#line 1082
  tmp___0 = vmalloc((unsigned long )sw_context->cmd_bounce_size);
#line 1082
  sw_context->cmd_bounce = (uint32_t *)tmp___0;
#line 1084
  if ((unsigned long )sw_context->cmd_bounce == (unsigned long )((uint32_t *)0)) {
#line 1085
    drm_err("vmw_resize_cmd_bounce", "Failed to allocate command bounce buffer.\n");
#line 1086
    sw_context->cmd_bounce_size = 0U;
#line 1087
    return (-12);
  } else {

  }
#line 1090
  return (0);
}
}
#line 1104 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) 
{ 
  uint32_t sequence ;
  int ret ;
  bool synced ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1111
  synced = 0;
#line 1114
  tmp = ldv__builtin_expect((unsigned long )p_handle != (unsigned long )((uint32_t *)0),
                         0L);
#line 1114
  if (tmp != 0L) {
#line 1114
    tmp___0 = ldv__builtin_expect((unsigned long )file_priv == (unsigned long )((struct drm_file *)0),
                               0L);
#line 1114
    if (tmp___0 != 0L) {
#line 1114
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1114), "i" (12UL));
      ldv_39401: ;
#line 1114
      goto ldv_39401;
    } else {

    }
  } else {

  }
#line 1116
  ret = vmw_fifo_send_fence(dev_priv, & sequence);
#line 1117
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1117
  if (tmp___1 != 0L) {
#line 1118
    drm_err("vmw_execbuf_fence_commands", "Fence submission error. Syncing.\n");
#line 1119
    synced = 1;
  } else {

  }
#line 1122
  if ((unsigned long )p_handle != (unsigned long )((uint32_t *)0)) {
#line 1123
    ret = vmw_user_fence_create(file_priv, dev_priv->fman, sequence, 1U, p_fence,
                                p_handle);
  } else {
#line 1128
    ret = vmw_fence_create(dev_priv->fman, sequence, 1U, p_fence);
  }
#line 1132
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1132
  if (tmp___2 != 0L) {
#line 1132
    tmp___3 = ldv__builtin_expect((long )(! synced), 0L);
#line 1132
    if (tmp___3 != 0L) {
#line 1133
      vmw_fallback_wait(dev_priv, 0, 0, sequence, 0, 1250UL);
#line 1136
      *p_fence = 0;
    } else {

    }
  } else {

  }
#line 1139
  return (0);
}
}
#line 1163 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) 
{ 
  struct drm_vmw_fence_rep fence_rep ;
  long tmp ;
  long tmp___0 ;

  {
#line 1172
  if ((unsigned long )user_fence_rep == (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1173
    return;
  } else {

  }
#line 1175
  memset((void *)(& fence_rep), 0, 24UL);
#line 1177
  fence_rep.error = ret;
#line 1178
  if (ret == 0) {
#line 1179
    tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                           0L);
#line 1179
    if (tmp != 0L) {
#line 1179
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1179), "i" (12UL));
      ldv_39412: ;
#line 1179
      goto ldv_39412;
    } else {

    }
#line 1181
    fence_rep.handle = fence_handle;
#line 1182
    fence_rep.seqno = fence->seqno;
#line 1183
    vmw_update_seqno(dev_priv, & dev_priv->fifo);
#line 1184
    fence_rep.passed_seqno = dev_priv->last_read_seqno;
  } else {

  }
#line 1192
  ret = copy_to_user((void *)user_fence_rep, (void const   *)(& fence_rep), 24U);
#line 1199
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1199
  if (tmp___0 != 0L && fence_rep.error == 0) {
#line 1200
    ttm_ref_object_base_unref(vmw_fp->tfile, (unsigned long )fence_handle, TTM_REF_USAGE);
#line 1202
    drm_err("vmw_execbuf_copy_fence_user", "Fence copy error. Syncing.\n");
#line 1203
    vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
  } else {

  }
#line 1205
  return;
}
}
#line 1209 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_sw_context *sw_context ;
  struct vmw_fence_obj *fence ;
  uint32_t handle ;
  void *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;
  struct vmw_fpriv *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  size_t __len ;
  void *__ret ;
  struct vmw_fpriv *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 1218
  sw_context = & dev_priv->ctx;
#line 1219
  fence = 0;
#line 1224
  ret = ldv_mutex_lock_interruptible_13(& dev_priv->cmdbuf_mutex);
#line 1225
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1225
  if (tmp != 0L) {
#line 1226
    return (-512);
  } else {

  }
#line 1228
  if ((unsigned long )kernel_commands == (unsigned long )((void *)0)) {
#line 1229
    sw_context->kernel = 0;
#line 1231
    ret = vmw_resize_cmd_bounce(sw_context, command_size);
#line 1232
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1232
    if (tmp___0 != 0L) {
#line 1233
      goto out_unlock;
    } else {

    }
#line 1236
    tmp___1 = copy_from_user((void *)sw_context->cmd_bounce, (void const   *)user_commands,
                             (unsigned long )command_size);
#line 1236
    ret = (int )tmp___1;
#line 1239
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1239
    if (tmp___2 != 0L) {
#line 1240
      ret = -14;
#line 1241
      drm_err("vmw_execbuf_process", "Failed copying commands.\n");
#line 1242
      goto out_unlock;
    } else {

    }
#line 1244
    kernel_commands = (void *)sw_context->cmd_bounce;
  } else {
#line 1246
    sw_context->kernel = 1;
  }
#line 1248
  tmp___3 = vmw_fpriv(file_priv);
#line 1248
  sw_context->tfile = tmp___3->tfile;
#line 1249
  sw_context->cid_valid = 0;
#line 1250
  sw_context->sid_valid = 0;
#line 1251
  sw_context->cur_reloc = 0U;
#line 1252
  sw_context->cur_val_buf = 0U;
#line 1253
  sw_context->fence_flags = 0U;
#line 1254
  INIT_LIST_HEAD(& sw_context->query_list);
#line 1255
  INIT_LIST_HEAD(& sw_context->resource_list);
#line 1256
  sw_context->cur_query_bo = dev_priv->pinned_bo;
#line 1257
  sw_context->cur_query_cid = dev_priv->query_cid;
#line 1258
  sw_context->query_cid_valid = (unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0);
#line 1260
  INIT_LIST_HEAD(& sw_context->validate_nodes);
#line 1262
  ret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands, command_size);
#line 1264
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1264
  if (tmp___4 != 0L) {
#line 1265
    goto out_err;
  } else {

  }
#line 1267
  ret = ttm_eu_reserve_buffers(& sw_context->validate_nodes);
#line 1268
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1268
  if (tmp___5 != 0L) {
#line 1269
    goto out_err;
  } else {

  }
#line 1271
  ret = vmw_validate_buffers(dev_priv, sw_context);
#line 1272
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 1272
  if (tmp___6 != 0L) {
#line 1273
    goto out_err;
  } else {

  }
#line 1275
  vmw_apply_relocations(sw_context);
#line 1277
  if (throttle_us != 0ULL) {
#line 1278
    ret = vmw_wait_lag(dev_priv, & dev_priv->fifo.marker_queue, (uint32_t )throttle_us);
#line 1281
    tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1281
    if (tmp___7 != 0L) {
#line 1282
      goto out_throttle;
    } else {

    }
  } else {

  }
#line 1285
  cmd = vmw_fifo_reserve(dev_priv, command_size);
#line 1286
  tmp___8 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0), 0L);
#line 1286
  if (tmp___8 != 0L) {
#line 1287
    drm_err("vmw_execbuf_process", "Failed reserving fifo space for commands.\n");
#line 1288
    ret = -12;
#line 1289
    goto out_throttle;
  } else {

  }
#line 1292
  __len = (size_t )command_size;
#line 1292
  __ret = __builtin_memcpy(cmd, (void const   *)kernel_commands, __len);
#line 1293
  vmw_fifo_commit(dev_priv, command_size);
#line 1295
  vmw_query_bo_switch_commit(dev_priv, sw_context);
#line 1296
  ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, (unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0) ? & handle : 0);
#line 1305
  if (ret != 0) {
#line 1306
    drm_err("vmw_execbuf_process", "Fence submission error. Syncing.\n");
  } else {

  }
#line 1308
  ttm_eu_fence_buffer_objects(& sw_context->validate_nodes, (void *)fence);
#line 1311
  vmw_clear_validations(sw_context);
#line 1312
  tmp___9 = vmw_fpriv(file_priv);
#line 1312
  vmw_execbuf_copy_fence_user(dev_priv, tmp___9, ret, user_fence_rep, fence, handle);
#line 1316
  tmp___11 = ldv__builtin_expect((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0),
                              0L);
#line 1316
  if (tmp___11 != 0L) {
#line 1317
    *out_fence = fence;
#line 1318
    fence = 0;
  } else {
#line 1319
    tmp___10 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                                1L);
#line 1319
    if (tmp___10 != 0L) {
#line 1320
      vmw_fence_obj_unreference(& fence);
    } else {

    }
  }
#line 1323
  ldv_mutex_unlock_14(& dev_priv->cmdbuf_mutex);
#line 1324
  return (0);
  out_err: 
#line 1327
  vmw_free_relocations(sw_context);
  out_throttle: 
#line 1329
  vmw_query_switch_backoff(sw_context);
#line 1330
  ttm_eu_backoff_reservation(& sw_context->validate_nodes);
#line 1331
  vmw_clear_validations(sw_context);
  out_unlock: 
#line 1333
  ldv_mutex_unlock_15(& dev_priv->cmdbuf_mutex);
#line 1334
  return (ret);
}
}
#line 1346 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv ) 
{ 


  {
#line 1348
  drm_err("vmw_execbuf_unpin_panic", "Can\'t unpin query buffer. Trying to recover.\n");
#line 1350
  vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
#line 1351
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1352
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1353
  dev_priv->dummy_query_bo_pinned = 0;
#line 1354
  return;
}
}
#line 1378 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) 
{ 
  int ret ;
  struct list_head validate_list ;
  struct ttm_validate_buffer pinned_val ;
  struct ttm_validate_buffer query_val ;
  struct vmw_fence_obj *fence ;
  long tmp ;
  long tmp___0 ;

  {
#line 1381
  ret = 0;
#line 1386
  ldv_mutex_lock_16(& dev_priv->cmdbuf_mutex);
#line 1388
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1389
    goto out_unlock;
  } else {

  }
#line 1391
  if ((int )only_on_cid_match && dev_priv->query_cid != cid) {
#line 1392
    goto out_unlock;
  } else {

  }
#line 1394
  INIT_LIST_HEAD(& validate_list);
#line 1396
  pinned_val.new_sync_obj_arg = 1;
#line 1398
  pinned_val.bo = ttm_bo_reference(dev_priv->pinned_bo);
#line 1399
  list_add_tail(& pinned_val.head, & validate_list);
#line 1401
  query_val.new_sync_obj_arg = pinned_val.new_sync_obj_arg;
#line 1402
  query_val.bo = ttm_bo_reference(dev_priv->dummy_query_bo);
#line 1403
  list_add_tail(& query_val.head, & validate_list);
  ldv_39451: 
#line 1406
  ret = ttm_eu_reserve_buffers(& validate_list);
#line 1407
  if (ret == -512) {
#line 1408
    goto ldv_39451;
  } else {

  }
#line 1409
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1409
  if (tmp != 0L) {
#line 1410
    vmw_execbuf_unpin_panic(dev_priv);
#line 1411
    goto out_no_reserve;
  } else {

  }
#line 1414
  ret = vmw_fifo_emit_dummy_query(dev_priv, dev_priv->query_cid);
#line 1415
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1415
  if (tmp___0 != 0L) {
#line 1416
    vmw_execbuf_unpin_panic(dev_priv);
#line 1417
    goto out_no_emit;
  } else {

  }
#line 1420
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1421
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1422
  dev_priv->dummy_query_bo_pinned = 0;
#line 1424
  vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
#line 1425
  ttm_eu_fence_buffer_objects(& validate_list, (void *)fence);
#line 1427
  ttm_bo_unref(& query_val.bo);
#line 1428
  ttm_bo_unref(& pinned_val.bo);
#line 1429
  ttm_bo_unref(& dev_priv->pinned_bo);
  out_unlock: 
#line 1432
  ldv_mutex_unlock_17(& dev_priv->cmdbuf_mutex);
#line 1433
  return;
  out_no_emit: 
#line 1436
  ttm_eu_backoff_reservation(& validate_list);
  out_no_reserve: 
#line 1438
  ttm_bo_unref(& query_val.bo);
#line 1439
  ttm_bo_unref(& pinned_val.bo);
#line 1440
  ttm_bo_unref(& dev_priv->pinned_bo);
#line 1441
  ldv_mutex_unlock_18(& dev_priv->cmdbuf_mutex);
#line 1442
  return;
}
}
#line 1445 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_execbuf_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  int ret ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1448
  tmp = vmw_priv(dev);
#line 1448
  dev_priv = tmp;
#line 1449
  arg = (struct drm_vmw_execbuf_arg *)data;
#line 1450
  tmp___0 = vmw_master(file_priv->master);
#line 1450
  vmaster = tmp___0;
#line 1460
  tmp___1 = ldv__builtin_expect(arg->version != 1U, 0L);
#line 1460
  if (tmp___1 != 0L) {
#line 1461
    drm_err("vmw_execbuf_ioctl", "Incorrect execbuf version.\n");
#line 1462
    drm_err("vmw_execbuf_ioctl", "You\'re running outdated experimental vmwgfx user-space drivers.");
#line 1464
    return (-22);
  } else {

  }
#line 1467
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1468
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1468
  if (tmp___2 != 0L) {
#line 1469
    return (ret);
  } else {

  }
#line 1471
  ret = vmw_execbuf_process(file_priv, dev_priv, (void *)arg->commands, 0, arg->command_size,
                            (uint64_t )arg->throttle_us, (struct drm_vmw_fence_rep *)arg->fence_rep,
                            0);
#line 1477
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1477
  if (tmp___3 != 0L) {
#line 1478
    goto out_unlock;
  } else {

  }
#line 1480
  vmw_kms_cursor_post_execbuf(dev_priv);
  out_unlock: 
#line 1483
  ttm_read_unlock(& vmaster->lock);
#line 1484
  return (ret);
}
}
#line 1487 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1492
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1494
  mutex_lock(ldv_func_arg1);
#line 1495
  return;
}
}
#line 1497 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_trylock_2(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1502
  tmp = mutex_trylock(ldv_func_arg1);
#line 1502
  ldv_func_res = tmp;
#line 1504
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1504
  return (tmp___0);
#line 1506
  return (ldv_func_res);
}
}
#line 1509 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1514
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1516
  mutex_unlock(ldv_func_arg1);
#line 1517
  return;
}
}
#line 1519 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_4(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1524
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1526
  mutex_lock(ldv_func_arg1);
#line 1527
  return;
}
}
#line 1529 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1534
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1536
  mutex_unlock(ldv_func_arg1);
#line 1537
  return;
}
}
#line 1539 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1544
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1546
  mutex_lock(ldv_func_arg1);
#line 1547
  return;
}
}
#line 1549 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1554
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1556
  mutex_unlock(ldv_func_arg1);
#line 1557
  return;
}
}
#line 1559 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_8(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1564
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1566
  mutex_unlock(ldv_func_arg1);
#line 1567
  return;
}
}
#line 1569 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1574
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1576
  mutex_lock(ldv_func_arg1);
#line 1577
  return;
}
}
#line 1579 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1584
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1586
  mutex_unlock(ldv_func_arg1);
#line 1587
  return;
}
}
#line 1589 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1594
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1596
  mutex_lock(ldv_func_arg1);
#line 1597
  return;
}
}
#line 1599 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1604
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1606
  mutex_unlock(ldv_func_arg1);
#line 1607
  return;
}
}
#line 1609 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_lock_interruptible_13(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1614
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 1614
  ldv_func_res = tmp;
#line 1616
  tmp___0 = ldv_mutex_lock_interruptible_cmdbuf_mutex(ldv_func_arg1);
#line 1616
  return (tmp___0);
#line 1618
  return (ldv_func_res);
}
}
#line 1621 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1626
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1628
  mutex_unlock(ldv_func_arg1);
#line 1629
  return;
}
}
#line 1631 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1636
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1638
  mutex_unlock(ldv_func_arg1);
#line 1639
  return;
}
}
#line 1641 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1646
  ldv_mutex_lock_cmdbuf_mutex(ldv_func_arg1);
#line 1648
  mutex_lock(ldv_func_arg1);
#line 1649
  return;
}
}
#line 1651 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1656
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1658
  mutex_unlock(ldv_func_arg1);
#line 1659
  return;
}
}
#line 1661 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1666
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 1668
  mutex_unlock(ldv_func_arg1);
#line 1669
  return;
}
}
#line 88 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 34 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_38(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_39(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_46(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_37(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_40(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_42(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_45(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_47(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
#line 79
void ldv_mutex_lock_hw_mutex(struct mutex *lock ) ;
#line 83
void ldv_mutex_unlock_hw_mutex(struct mutex *lock ) ;
#line 204 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 206 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 209
  switch (8UL) {
  case 1UL: 
#line 209
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 209
  goto ldv_7822;
  case 2UL: 
#line 209
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 209
  goto ldv_7822;
  case 4UL: 
#line 209
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 209
  goto ldv_7822;
  case 8UL: 
#line 209
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 209
  goto ldv_7822;
  default: 
#line 209
  __bad_percpu_size();
  }
  ldv_7822: 
#line 209
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 211
  return (ti);
}
}
#line 310 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 310
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 311
  return;
}
}
#line 324 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 327 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 329
  tmp = alloc_pages_current(gfp_mask, order);
#line 329
  return (tmp);
}
}
#line 360
extern void __free_pages(struct page * , unsigned int  ) ;
#line 739 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 741
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 18
  tmp = current_thread_info();
#line 18
  tmp->preempt_count = tmp->preempt_count + 1;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  tmp = current_thread_info();
#line 33
  tmp->preempt_count = tmp->preempt_count + -1;
#line 37
  __asm__  volatile   ("": : : "memory");
#line 38
  return;
}
}
#line 59 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 61
  pagefault_disable();
#line 62
  tmp = lowmem_page_address((struct page  const  *)page);
#line 62
  return (tmp);
}
}
#line 66 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 68
  pagefault_enable();
#line 69
  return;
}
}
#line 351 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value ) 
{ 


  {
#line 354
  outl(offset, (int )dev_priv->io_start);
#line 355
  outl(value, (int )(dev_priv->io_start + 1U));
#line 356
  return;
}
}
#line 375
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) ;
#line 379
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) ;
#line 137 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr2_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                         int gmr_id ) 
{ 
  SVGAFifoCmdDefineGMR2 define_cmd ;
  SVGAFifoCmdRemapGMR2 remap_cmd ;
  uint32_t define_size ;
  uint32_t remap_size ;
  uint32_t *cmd ;
  uint32_t *cmd_orig ;
  uint32_t i ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct page **tmp___4 ;

  {
#line 144
  define_size = 12U;
#line 145
  remap_size = (uint32_t )(num_pages + 2UL) * 8U + 4U;
#line 150
  tmp = vmw_fifo_reserve(dev_priv, define_size + remap_size);
#line 150
  cmd = (uint32_t *)tmp;
#line 150
  cmd_orig = cmd;
#line 151
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 151
  if (tmp___0 != 0L) {
#line 152
    return (-12);
  } else {

  }
#line 154
  define_cmd.gmrId = (uint32 )gmr_id;
#line 155
  define_cmd.numPages = (uint32 )num_pages;
#line 157
  remap_cmd.gmrId = (uint32 )gmr_id;
#line 158
  remap_cmd.flags = SVGA_REMAP_GMR2_PPN64;
#line 160
  remap_cmd.offsetPages = 0U;
#line 161
  remap_cmd.numPages = (uint32 )num_pages;
#line 163
  tmp___1 = cmd;
#line 163
  cmd = cmd + 1;
#line 163
  *tmp___1 = 41U;
#line 164
  __len = 8UL;
#line 164
  if (__len > 63UL) {
#line 164
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 164
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 165
  cmd = cmd + 2UL;
#line 167
  tmp___2 = cmd;
#line 167
  cmd = cmd + 1;
#line 167
  *tmp___2 = 42U;
#line 168
  __len___0 = 16UL;
#line 168
  if (__len___0 > 63UL) {
#line 168
    __ret___0 = __memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  } else {
#line 168
    __ret___0 = __builtin_memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  }
#line 169
  cmd = cmd + 4UL;
#line 171
  i = 0U;
#line 171
  goto ldv_39042;
  ldv_39041: 
#line 175
  tmp___4 = pages;
#line 175
  pages = pages + 1;
#line 175
  *((uint64_t *)cmd) = (uint64_t )(((long )*tmp___4 + 24189255811072L) / 64L);
#line 177
  cmd = cmd + 2UL;
#line 171
  i = i + (uint32_t )1;
  ldv_39042: ;
#line 171
  if ((unsigned long )i < num_pages) {
#line 172
    goto ldv_39041;
  } else {

  }
#line 180
  vmw_fifo_commit(dev_priv, define_size + remap_size);
#line 182
  return (0);
}
}
#line 185 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr2_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ 
  SVGAFifoCmdDefineGMR2 define_cmd ;
  uint32_t define_size ;
  uint32_t *cmd ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 189
  define_size = 12U;
#line 192
  tmp = vmw_fifo_reserve(dev_priv, define_size);
#line 192
  cmd = (uint32_t *)tmp;
#line 193
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 193
  if (tmp___0 != 0L) {
#line 194
    drm_err("vmw_gmr2_unbind", "GMR2 unbind failed.\n");
#line 195
    return;
  } else {

  }
#line 197
  define_cmd.gmrId = (uint32 )gmr_id;
#line 198
  define_cmd.numPages = 0U;
#line 200
  tmp___1 = cmd;
#line 200
  cmd = cmd + 1;
#line 200
  *tmp___1 = 41U;
#line 201
  __len = 8UL;
#line 201
  if (__len > 63UL) {
#line 201
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 201
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 203
  vmw_fifo_commit(dev_priv, define_size);
#line 204
  return;
}
}
#line 211 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr_build_descriptors(struct list_head *desc_pages , struct page **pages ,
                                     unsigned long num_pages ) 
{ 
  struct page *page ;
  struct page *next ;
  struct svga_guest_mem_descriptor *page_virtual ;
  struct svga_guest_mem_descriptor *desc_virtual ;
  unsigned int desc_per_page ;
  unsigned long prev_pfn ;
  unsigned long pfn ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 216
  page_virtual = 0;
#line 217
  desc_virtual = 0;
#line 223
  desc_per_page = 511U;
#line 226
  goto ldv_39074;
  ldv_39073: 
#line 227
  page = alloc_pages(2U, 0U);
#line 228
  tmp = ldv__builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                         0L);
#line 228
  if (tmp != 0L) {
#line 229
    ret = -12;
#line 230
    goto out_err;
  } else {

  }
#line 233
  list_add_tail(& page->ldv_20272.lru, desc_pages);
#line 240
  tmp___0 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 240
  if (tmp___0 != 0L) {
#line 241
    desc_virtual->ppn = (__le32 )(((long )page + 24189255811072L) / 64L);
#line 242
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 245
  tmp___1 = kmap_atomic(page);
#line 245
  page_virtual = (struct svga_guest_mem_descriptor *)tmp___1;
#line 246
  desc_virtual = page_virtual + 0xffffffffffffffffUL;
#line 247
  prev_pfn = 0xffffffffffffffffUL;
#line 249
  goto ldv_39072;
  ldv_39071: 
#line 250
  pfn = (unsigned long )(((long )*pages + 24189255811072L) / 64L);
#line 252
  if (prev_pfn + 1UL != pfn) {
#line 254
    if (((long )desc_virtual - (long )page_virtual) / 8L == (long )(desc_per_page - 1U)) {
#line 256
      goto ldv_39069;
    } else {

    }
#line 258
    desc_virtual = desc_virtual + 1;
#line 258
    desc_virtual->ppn = (unsigned int )pfn;
#line 259
    desc_virtual->num_pages = 1U;
  } else {
#line 261
    tmp___2 = desc_virtual->num_pages;
#line 263
    desc_virtual->num_pages = tmp___2 + 1U;
  }
#line 265
  prev_pfn = pfn;
#line 266
  num_pages = num_pages - 1UL;
#line 267
  pages = pages + 1;
  ldv_39072: 
#line 249
  tmp___3 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 249
  if (tmp___3 != 0L) {
#line 250
    goto ldv_39071;
  } else {

  }
  ldv_39069: 
#line 270
  desc_virtual = desc_virtual + 1;
#line 270
  desc_virtual->ppn = 0U;
#line 271
  desc_virtual->num_pages = 0U;
  ldv_39074: 
#line 226
  tmp___4 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 226
  if (tmp___4 != 0L) {
#line 227
    goto ldv_39073;
  } else {

  }
#line 274
  tmp___5 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 274
  if (tmp___5 != 0L) {
#line 275
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 277
  return (0);
  out_err: 
#line 279
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 279
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 279
  __mptr___0 = (struct list_head  const  *)page->ldv_20272.lru.next;
#line 279
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 279
  goto ldv_39083;
  ldv_39082: 
#line 280
  list_del_init(& page->ldv_20272.lru);
#line 281
  __free_pages(page, 0U);
#line 279
  page = next;
#line 279
  __mptr___1 = (struct list_head  const  *)next->ldv_20272.lru.next;
#line 279
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_39083: ;
#line 279
  if ((unsigned long )(& page->ldv_20272.lru) != (unsigned long )desc_pages) {
#line 280
    goto ldv_39082;
  } else {

  }

#line 283
  return (ret);
}
}
#line 286 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
__inline static void vmw_gmr_free_descriptors(struct list_head *desc_pages ) 
{ 
  struct page *page ;
  struct page *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 290
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 290
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 290
  __mptr___0 = (struct list_head  const  *)page->ldv_20272.lru.next;
#line 290
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 290
  goto ldv_39097;
  ldv_39096: 
#line 291
  list_del_init(& page->ldv_20272.lru);
#line 292
  __free_pages(page, 0U);
#line 290
  page = next;
#line 290
  __mptr___1 = (struct list_head  const  *)next->ldv_20272.lru.next;
#line 290
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_39097: ;
#line 290
  if ((unsigned long )(& page->ldv_20272.lru) != (unsigned long )desc_pages) {
#line 291
    goto ldv_39096;
  } else {

  }

#line 295
  return;
}
}
#line 296 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr_fire_descriptors(struct vmw_private *dev_priv , int gmr_id , struct list_head *desc_pages ) 
{ 
  struct page *page ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;

  {
#line 301
  tmp = list_empty((struct list_head  const  *)desc_pages);
#line 301
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 301
  if (tmp___0 != 0L) {
#line 302
    return;
  } else {

  }
#line 304
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 304
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 306
  ldv_mutex_lock_49(& dev_priv->hw_mutex);
#line 308
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 309
  __asm__  volatile   ("sfence": : : "memory");
#line 310
  vmw_write(dev_priv, 42U, (uint32_t )(((long )page + 24189255811072L) / 64L));
#line 311
  __asm__  volatile   ("mfence": : : "memory");
#line 313
  ldv_mutex_unlock_50(& dev_priv->hw_mutex);
#line 314
  return;
}
}
#line 322 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static unsigned long vmw_gmr_count_descriptors(struct page **pages , unsigned long num_pages ) 
{ 
  unsigned long prev_pfn ;
  unsigned long pfn ;
  unsigned long descriptors ;
  struct page **tmp ;
  unsigned long tmp___0 ;

  {
#line 325
  prev_pfn = 0xffffffffffffffffUL;
#line 327
  descriptors = 0UL;
#line 329
  goto ldv_39115;
  ldv_39114: 
#line 330
  tmp = pages;
#line 330
  pages = pages + 1;
#line 330
  pfn = (unsigned long )(((long )*tmp + 24189255811072L) / 64L);
#line 331
  if (prev_pfn + 1UL != pfn) {
#line 332
    descriptors = descriptors + 1UL;
  } else {

  }
#line 333
  prev_pfn = pfn;
  ldv_39115: 
#line 329
  tmp___0 = num_pages;
#line 329
  num_pages = num_pages - 1UL;
#line 329
  if (tmp___0 != 0UL) {
#line 330
    goto ldv_39114;
  } else {

  }

#line 336
  return (descriptors);
}
}
#line 339 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) 
{ 
  struct list_head desc_pages ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;

  {
#line 347
  tmp___0 = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 347
  if (tmp___0 != 0L) {
#line 348
    tmp = vmw_gmr2_bind(dev_priv, pages, num_pages, gmr_id);
#line 348
    return (tmp);
  } else {

  }
#line 350
  tmp___1 = ldv__builtin_expect((dev_priv->capabilities & 1048576U) == 0U, 0L);
#line 350
  if (tmp___1 != 0L) {
#line 351
    return (-22);
  } else {

  }
#line 353
  tmp___2 = vmw_gmr_count_descriptors(pages, num_pages);
#line 353
  if (tmp___2 > (unsigned long )dev_priv->max_gmr_descriptors) {
#line 355
    return (-22);
  } else {

  }
#line 357
  INIT_LIST_HEAD(& desc_pages);
#line 359
  ret = vmw_gmr_build_descriptors(& desc_pages, pages, num_pages);
#line 360
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 360
  if (tmp___3 != 0L) {
#line 361
    return (ret);
  } else {

  }
#line 363
  vmw_gmr_fire_descriptors(dev_priv, gmr_id, & desc_pages);
#line 364
  vmw_gmr_free_descriptors(& desc_pages);
#line 366
  return (0);
}
}
#line 370 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ 
  long tmp ;

  {
#line 372
  tmp = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 372
  if (tmp != 0L) {
#line 373
    vmw_gmr2_unbind(dev_priv, gmr_id);
#line 374
    return;
  } else {

  }
#line 377
  ldv_mutex_lock_51(& dev_priv->hw_mutex);
#line 378
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 379
  __asm__  volatile   ("sfence": : : "memory");
#line 380
  vmw_write(dev_priv, 42U, 0U);
#line 381
  __asm__  volatile   ("mfence": : : "memory");
#line 382
  ldv_mutex_unlock_52(& dev_priv->hw_mutex);
#line 383
  return;
}
}
#line 385 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_37(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 390
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 392
  mutex_lock(ldv_func_arg1);
#line 393
  return;
}
}
#line 395 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int ldv_mutex_trylock_38(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 400
  tmp = mutex_trylock(ldv_func_arg1);
#line 400
  ldv_func_res = tmp;
#line 402
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 402
  return (tmp___0);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_39(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 412
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 414
  mutex_unlock(ldv_func_arg1);
#line 415
  return;
}
}
#line 417 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_40(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 422
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 424
  mutex_lock(ldv_func_arg1);
#line 425
  return;
}
}
#line 427 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_41(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 432
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 434
  mutex_unlock(ldv_func_arg1);
#line 435
  return;
}
}
#line 437 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_42(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 442
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 444
  mutex_lock(ldv_func_arg1);
#line 445
  return;
}
}
#line 447 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 452
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 454
  mutex_unlock(ldv_func_arg1);
#line 455
  return;
}
}
#line 457 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 462
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 464
  mutex_unlock(ldv_func_arg1);
#line 465
  return;
}
}
#line 467 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_45(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 474
  mutex_lock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_46(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 482
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 484
  mutex_unlock(ldv_func_arg1);
#line 485
  return;
}
}
#line 487 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_47(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 492
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 494
  mutex_lock(ldv_func_arg1);
#line 495
  return;
}
}
#line 497 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 502
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 504
  mutex_unlock(ldv_func_arg1);
#line 505
  return;
}
}
#line 507 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 522
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 524
  mutex_unlock(ldv_func_arg1);
#line 525
  return;
}
}
#line 527 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 532
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 534
  mutex_lock(ldv_func_arg1);
#line 535
  return;
}
}
#line 537 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 542
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 544
  mutex_unlock(ldv_func_arg1);
#line 545
  return;
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
#line 157
  return;
}
}
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 24
  return ((void *)error);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_70(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_71(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_72(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_74(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_81(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) ;
#line 71
void ldv_mutex_lock_fb_surf_mutex(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_fb_surf_mutex(struct mutex *lock ) ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 310 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
#line 310
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 161 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 221 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 268 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 283
  tmp___2 = __kmalloc(size, flags);
#line 283
  return (tmp___2);
}
}
#line 243 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 245
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 246
    return (0);
  } else {

  }
#line 247
  tmp = __kmalloc(n * size, flags);
#line 247
  return (tmp);
}
}
#line 256 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 258
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 258
  return (tmp);
}
}
#line 349 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 351
  tmp = kmalloc(size, flags | 32768U);
#line 351
  return (tmp);
}
}
#line 128 "include/drm/drmP.h"
extern void drm_ut_debug_printk(unsigned int  , char const   * , char const   * ,
                                char const   *  , ...) ;
#line 834 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
#line 841
extern void drm_connector_cleanup(struct drm_connector * ) ;
#line 858
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
#line 871
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
#line 874
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
#line 877
extern void drm_mode_config_init(struct drm_device * ) ;
#line 879
extern void drm_mode_config_cleanup(struct drm_device * ) ;
#line 892
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
#line 902
extern int drm_mode_vrefresh(struct drm_display_mode  const  * ) ;
#line 905
extern void drm_mode_connector_list_update(struct drm_connector * ) ;
#line 923
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
#line 926
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
#line 967
extern struct drm_mode_object *drm_mode_object_find(struct drm_device * , uint32_t  ,
                                                    uint32_t  ) ;
#line 1058
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
#line 1505 "include/drm/drmP.h"
extern struct drm_master *drm_master_get(struct drm_master * ) ;
#line 1506
extern void drm_master_put(struct drm_master ** ) ;
#line 647 "include/drm/ttm/ttm_bo_api.h"
__inline static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem ) 
{ 


  {
#line 650
  *is_iomem = ((unsigned int )map->bo_kmap_type & 128U) != 0U;
#line 651
  return (map->virtual);
}
}
#line 671
extern int ttm_bo_kmap(struct ttm_buffer_object * , unsigned long  , unsigned long  ,
                       struct ttm_bo_kmap_obj * ) ;
#line 682
extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj * ) ;
#line 850 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_reserve(struct ttm_buffer_object * , bool  , bool  , bool  , uint32_t  ) ;
#line 891
extern void ttm_bo_unreserve(struct ttm_buffer_object * ) ;
#line 169 "include/drm/ttm/ttm_object.h"
extern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file * , uint32_t  ) ;
#line 181
extern void ttm_base_object_unref(struct ttm_base_object ** ) ;
#line 114 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) ;
#line 358 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset ) 
{ 
  uint32_t val ;

  {
#line 363
  outl(offset, (int )dev_priv->io_start);
#line 364
  val = inl((int )(dev_priv->io_start + 1U));
#line 365
  return (val);
}
}
#line 387
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) ;
#line 396
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) ;
#line 458
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) ;
#line 461
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) ;
#line 499
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) ;
#line 611
int vmw_kms_init(struct vmw_private *dev_priv ) ;
#line 612
int vmw_kms_close(struct vmw_private *dev_priv ) ;
#line 613
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) ;
#line 614
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) ;
#line 615
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 622
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) ;
#line 626
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) ;
#line 629
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) ;
#line 630
int vmw_enable_vblank(struct drm_device *dev , int crtc ) ;
#line 631
void vmw_disable_vblank(struct drm_device *dev , int crtc ) ;
#line 632
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) ;
#line 639
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) ;
#line 645
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 657
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) ;
#line 658
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) ;
#line 683 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf ) 
{ 


  {
#line 685
  vmw_resource_reference(& srf->res);
#line 686
  return (srf);
}
}
#line 698 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf ) 
{ 
  struct ttm_buffer_object *tmp ;

  {
#line 700
  tmp = ttm_bo_reference(& buf->base);
#line 700
  if ((unsigned long )tmp != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 701
    return (buf);
  } else {

  }
#line 702
  return (0);
}
}
#line 63 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 66
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 70
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) ;
#line 123
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) ;
#line 124
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
#line 127
void vmw_du_crtc_save(struct drm_crtc *crtc ) ;
#line 128
void vmw_du_crtc_restore(struct drm_crtc *crtc ) ;
#line 129
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) ;
#line 132
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) ;
#line 134
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 135
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) ;
#line 136
void vmw_du_connector_save(struct drm_connector *connector ) ;
#line 137
void vmw_du_connector_restore(struct drm_connector *connector ) ;
#line 139
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) ;
#line 140
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) ;
#line 142
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) ;
#line 150
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 151
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 156
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) ;
#line 157
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) ;
#line 160
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 162
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 147 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_clip_cliprects(struct drm_clip_rect *rects , int num_rects , struct vmw_clip_rect clip ,
                        SVGASignedRect *out_rects , int *out_num ) 
{ 
  int i ;
  int k ;
  int x1 ;
  int __max1 ;
  int __max2 ;
  int y1 ;
  int __max1___0 ;
  int __max2___0 ;
  int x2 ;
  int __min1 ;
  int __min2 ;
  int y2 ;
  int __min1___0 ;
  int __min2___0 ;

  {
#line 155
  i = 0;
#line 155
  k = 0;
#line 155
  goto ldv_39319;
  ldv_39318: 
#line 156
  __max1 = clip.x1;
#line 156
  __max2 = (int )(rects + (unsigned long )i)->x1;
#line 156
  x1 = __max1 > __max2 ? __max1 : __max2;
#line 157
  __max1___0 = clip.y1;
#line 157
  __max2___0 = (int )(rects + (unsigned long )i)->y1;
#line 157
  y1 = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 158
  __min1 = clip.x2;
#line 158
  __min2 = (int )(rects + (unsigned long )i)->x2;
#line 158
  x2 = __min1 < __min2 ? __min1 : __min2;
#line 159
  __min1___0 = clip.y2;
#line 159
  __min2___0 = (int )(rects + (unsigned long )i)->y2;
#line 159
  y2 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 161
  if (x1 >= x2) {
#line 162
    goto ldv_39317;
  } else {

  }
#line 163
  if (y1 >= y2) {
#line 164
    goto ldv_39317;
  } else {

  }
#line 166
  (out_rects + (unsigned long )k)->left = x1;
#line 167
  (out_rects + (unsigned long )k)->top = y1;
#line 168
  (out_rects + (unsigned long )k)->right = x2;
#line 169
  (out_rects + (unsigned long )k)->bottom = y2;
#line 170
  k = k + 1;
  ldv_39317: 
#line 155
  i = i + 1;
  ldv_39319: ;
#line 155
  if (i < num_rects) {
#line 156
    goto ldv_39318;
  } else {

  }
#line 173
  *out_num = k;
#line 174
  return;
}
}
#line 176 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) 
{ 


  {
#line 178
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 179
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 180
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 181
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 182
  drm_crtc_cleanup(& du->crtc);
#line 183
  drm_encoder_cleanup(& du->encoder);
#line 184
  drm_connector_cleanup(& du->connector);
#line 185
  return;
}
}
#line 191 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) 
{ 
  struct __anonstruct_cmd_279___0 *cmd ;
  u32 image_size ;
  u32 cmd_size ;
  void *tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 199
  image_size = (width * height) * 4U;
#line 200
  cmd_size = image_size + 24U;
#line 202
  if ((unsigned long )image == (unsigned long )((u32 *)0)) {
#line 203
    return (-22);
  } else {

  }
#line 205
  tmp = vmw_fifo_reserve(dev_priv, cmd_size);
#line 205
  cmd = (struct __anonstruct_281 *)tmp;
#line 206
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_279___0 *)0),
                             0L);
#line 206
  if (tmp___0 != 0L) {
#line 207
    drm_err("vmw_cursor_update_image", "Fifo reserve failed.\n");
#line 208
    return (-12);
  } else {

  }
#line 211
  memset((void *)cmd, 0, 24UL);
#line 213
  __len = (size_t )image_size;
#line 213
  __ret = __builtin_memcpy((void *)cmd + 1U, (void const   *)image, __len);
#line 215
  cmd->cmd = 22U;
#line 216
  cmd->cursor.id = 0U;
#line 217
  cmd->cursor.width = width;
#line 218
  cmd->cursor.height = height;
#line 219
  cmd->cursor.hotspotX = hotspotX;
#line 220
  cmd->cursor.hotspotY = hotspotY;
#line 222
  vmw_fifo_commit(dev_priv, cmd_size);
#line 224
  return (0);
}
}
#line 227 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) 
{ 
  struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  void *virtual ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 239
  kmap_offset = 0UL;
#line 240
  kmap_num = ((unsigned long )((width * height) * 4U) + 4095UL) >> 12;
#line 242
  ret = ttm_bo_reserve(& dmabuf->base, 1, 0, 0, 0U);
#line 243
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 243
  if (tmp != 0L) {
#line 244
    drm_err("vmw_cursor_update_dmabuf", "reserve failed\n");
#line 245
    return (-22);
  } else {

  }
#line 248
  ret = ttm_bo_kmap(& dmabuf->base, kmap_offset, kmap_num, & map);
#line 249
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 249
  if (tmp___0 != 0L) {
#line 250
    goto err_unreserve;
  } else {

  }
#line 252
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 253
  ret = vmw_cursor_update_image(dev_priv, (u32 *)virtual, width, height, hotspotX,
                                hotspotY);
#line 256
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 258
  ttm_bo_unreserve(& dmabuf->base);
#line 260
  return (ret);
}
}
#line 264 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) 
{ 
  __le32 *fifo_mem ;
  uint32_t count ;

  {
#line 267
  fifo_mem = dev_priv->mmio_virt;
#line 270
  iowrite32((u32 )show, (void *)fifo_mem + 9U);
#line 271
  iowrite32((u32 )x, (void *)fifo_mem + 10U);
#line 272
  iowrite32((u32 )y, (void *)fifo_mem + 11U);
#line 273
  count = ioread32((void *)fifo_mem + 12U);
#line 274
  count = count + (uint32_t )1;
#line 274
  iowrite32(count, (void *)fifo_mem + 12U);
#line 275
  return;
}
}
#line 277 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *dmabuf ;
  int ret ;

  {
#line 280
  tmp = vmw_priv(crtc->dev);
#line 280
  dev_priv = tmp;
#line 281
  tmp___0 = vmw_fpriv(file_priv);
#line 281
  tfile = tmp___0->tfile;
#line 282
  __mptr = (struct drm_crtc  const  *)crtc;
#line 282
  du = (struct vmw_display_unit *)__mptr;
#line 283
  surface = 0;
#line 284
  dmabuf = 0;
#line 288
  if (handle != 0U && (width != 64U || height != 64U)) {
#line 289
    return (-22);
  } else {

  }
#line 291
  if (handle != 0U) {
#line 292
    ret = vmw_user_lookup_handle(dev_priv, tfile, handle, & surface, & dmabuf);
#line 294
    if (ret != 0) {
#line 295
      drm_err("vmw_du_crtc_cursor_set", "failed to find surface or dmabuf: %i\n",
              ret);
#line 296
      return (-22);
    } else {

    }
  } else {

  }
#line 301
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0) && (unsigned long )surface->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 302
    drm_err("vmw_du_crtc_cursor_set", "surface not suitable for cursor\n");
#line 303
    vmw_surface_unreference(& surface);
#line 304
    return (-22);
  } else {

  }
#line 308
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 309
    (du->cursor_surface)->snooper.crtc = 0;
#line 310
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 312
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 313
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 316
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 318
    du->cursor_surface = surface;
#line 320
    (du->cursor_surface)->snooper.crtc = crtc;
#line 321
    du->cursor_age = (du->cursor_surface)->snooper.age;
#line 322
    vmw_cursor_update_image(dev_priv, surface->snooper.image, 64U, 64U, (u32 )du->hotspot_x,
                            (u32 )du->hotspot_y);
  } else
#line 324
  if ((unsigned long )dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 326
    du->cursor_dmabuf = dmabuf;
#line 328
    ret = vmw_cursor_update_dmabuf(dev_priv, dmabuf, width, height, (u32 )du->hotspot_x,
                                   (u32 )du->hotspot_y);
  } else {
#line 331
    vmw_cursor_update_position(dev_priv, 0, 0, 0);
#line 332
    return (0);
  }
#line 335
  vmw_cursor_update_position(dev_priv, 1, du->cursor_x + du->hotspot_x, du->cursor_y + du->hotspot_y);
#line 339
  return (0);
}
}
#line 342 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  bool shown ;

  {
#line 344
  tmp = vmw_priv(crtc->dev);
#line 344
  dev_priv = tmp;
#line 345
  __mptr = (struct drm_crtc  const  *)crtc;
#line 345
  du = (struct vmw_display_unit *)__mptr;
#line 346
  shown = (bool )((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0) || (unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0));
#line 348
  du->cursor_x = crtc->x + x;
#line 349
  du->cursor_y = crtc->y + y;
#line 351
  vmw_cursor_update_position(dev_priv, (int )shown, du->cursor_x + du->hotspot_x,
                             du->cursor_y + du->hotspot_y);
#line 355
  return (0);
}
}
#line 358 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) 
{ 
  struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  SVGA3dCopyBox *box ;
  unsigned int box_count ;
  void *virtual ;
  bool dummy ;
  struct vmw_dma_cmd *cmd ;
  int i ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 376
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 376
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 379
  if ((unsigned long )srf->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 380
    return;
  } else {

  }
#line 382
  if (cmd->dma.host.face != 0U || cmd->dma.host.mipmap != 0U) {
#line 383
    drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
#line 384
    return;
  } else {

  }
#line 387
  if (cmd->header.size <= 63U) {
#line 388
    drm_err("vmw_kms_cursor_snoop", "at least one full copy box must be given\n");
#line 389
    return;
  } else {

  }
#line 392
  box = (SVGA3dCopyBox *)cmd + 1U;
#line 393
  box_count = (unsigned int )(((unsigned long )cmd->header.size - 28UL) / 36UL);
#line 396
  if (((((((((cmd->dma.guest.ptr.offset & 4095U) != 0U || box->x != 0U) || box->y != 0U) || box->z != 0U) || box->srcx != 0U) || box->srcy != 0U) || box->srcz != 0U) || box->d != 1U) || box_count != 1U) {
#line 403
    drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 404
    drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
            box->srcx, box->srcy, box->srcz, box->x, box->y, box->z, box->w, box->h,
            box->d, box_count, cmd->dma.guest.ptr.offset);
#line 409
    return;
  } else {

  }
#line 412
  kmap_offset = (unsigned long )(cmd->dma.guest.ptr.offset >> 12);
#line 413
  kmap_num = 4UL;
#line 415
  ret = ttm_bo_reserve(bo, 1, 0, 0, 0U);
#line 416
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 416
  if (tmp != 0L) {
#line 417
    drm_err("vmw_kms_cursor_snoop", "reserve failed\n");
#line 418
    return;
  } else {

  }
#line 421
  ret = ttm_bo_kmap(bo, kmap_offset, kmap_num, & map);
#line 422
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 422
  if (tmp___0 != 0L) {
#line 423
    goto err_unreserve;
  } else {

  }
#line 425
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 427
  if (box->w == 64U && cmd->dma.guest.pitch == 256U) {
#line 428
    __len = 16384UL;
#line 428
    if (__len > 63UL) {
#line 428
      __ret = __memcpy((void *)srf->snooper.image, (void const   *)virtual, __len);
    } else {
#line 428
      __ret = __builtin_memcpy((void *)srf->snooper.image, (void const   *)virtual,
                               __len);
    }
  } else {
#line 431
    i = 0;
#line 431
    goto ldv_39422;
    ldv_39421: 
#line 432
    __len___0 = (size_t )(box->w * 4U);
#line 432
    __ret___0 = __builtin_memcpy((void *)srf->snooper.image + (unsigned long )(i * 64),
                                 (void const   *)virtual + (unsigned long )(cmd->dma.guest.pitch * (uint32 )i),
                                 __len___0);
#line 431
    i = i + 1;
    ldv_39422: ;
#line 431
    if ((uint32 )i < box->h) {
#line 432
      goto ldv_39421;
    } else {

    }

  }
#line 437
  srf->snooper.age = srf->snooper.age + (size_t )1;
#line 448
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 450
  ttm_bo_unreserve(bo);
#line 451
  return;
}
}
#line 453 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 455
  dev = dev_priv->dev;
#line 459
  ldv_mutex_lock_81(& dev->mode_config.mutex);
#line 461
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 461
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 461
  goto ldv_39438;
  ldv_39437: 
#line 462
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 462
  du = (struct vmw_display_unit *)__mptr___0;
#line 463
  if ((unsigned long )du->cursor_surface == (unsigned long )((struct vmw_surface *)0) || du->cursor_age == (du->cursor_surface)->snooper.age) {
#line 465
    goto ldv_39436;
  } else {

  }
#line 467
  du->cursor_age = (du->cursor_surface)->snooper.age;
#line 468
  vmw_cursor_update_image(dev_priv, (du->cursor_surface)->snooper.image, 64U, 64U,
                          (u32 )du->hotspot_x, (u32 )du->hotspot_y);
  ldv_39436: 
#line 461
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 461
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39438: ;
#line 461
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 462
    goto ldv_39437;
  } else {

  }
#line 473
  ldv_mutex_unlock_82(& dev->mode_config.mutex);
#line 474
  return;
}
}
#line 480 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                  unsigned int *handle ) 
{ 


  {
#line 484
  if ((unsigned long )handle != (unsigned long )((unsigned int *)0)) {
#line 485
    *handle = 0U;
  } else {

  }
#line 487
  return (0);
}
}
#line 505 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer ) 
{ 
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 508
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 508
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 509
  tmp = vmw_master(vfbs->master);
#line 509
  vmaster = tmp;
#line 512
  ldv_mutex_lock_83(& vmaster->fb_surf_mutex);
#line 513
  list_del(& vfbs->head);
#line 514
  ldv_mutex_unlock_84(& vmaster->fb_surf_mutex);
#line 516
  drm_master_put(& vfbs->master);
#line 517
  drm_framebuffer_cleanup(framebuffer);
#line 518
  vmw_surface_unreference(& vfbs->surface);
#line 519
  ttm_base_object_unref(& vfbs->base.user_obj);
#line 521
  kfree((void const   *)vfbs);
#line 522
  return;
}
}
#line 524 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_surface_dirty_sou(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                struct vmw_framebuffer *framebuffer , unsigned int flags ,
                                unsigned int color , struct drm_clip_rect *clips ,
                                unsigned int num_clips , int inc , struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_283 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  int __min1 ;
  int __min2 ;
  int __max1 ;
  int __max2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __max1___0 ;
  int __max2___0 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___7 ;

  {
#line 538
  ret = 0;
#line 547
  num_units = 0;
#line 548
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 548
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 548
  goto ldv_39494;
  ldv_39493: ;
#line 550
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 551
    goto ldv_39490;
  } else {

  }
#line 552
  tmp___0 = num_units;
#line 552
  num_units = num_units + 1;
#line 552
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 552
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_39490: 
#line 548
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 548
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39494: ;
#line 548
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 549
    goto ldv_39493;
  } else {

  }
#line 555
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 555
  if (tmp___1 != 0L) {
#line 555
    goto _L;
  } else {
#line 555
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 555
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 555
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (555), "i" (12UL));
      ldv_39496: ;
#line 555
      goto ldv_39496;
    } else {

    }
  }
#line 557
  tmp___3 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 557
  tmp = (struct drm_clip_rect *)tmp___3;
#line 558
  tmp___4 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 558
  if (tmp___4 != 0L) {
#line 559
    drm_err("do_surface_dirty_sou", "Temporary cliprect memory alloc failed.\n");
#line 560
    return (-12);
  } else {

  }
#line 563
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 564
  tmp___5 = kzalloc(fifo_size, 208U);
#line 564
  cmd = (struct __anonstruct_285 *)tmp___5;
#line 565
  tmp___6 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_283 *)0),
                             0L);
#line 565
  if (tmp___6 != 0L) {
#line 566
    drm_err("do_surface_dirty_sou", "Temporary fifo memory alloc failed.\n");
#line 567
    ret = -12;
#line 568
    goto out_free_tmp;
  } else {

  }
#line 572
  blits = (SVGASignedRect *)cmd + 1U;
#line 575
  left = (int )clips->x1;
#line 576
  right = (int )clips->x2;
#line 577
  top = (int )clips->y1;
#line 578
  bottom = (int )clips->y2;
#line 581
  i = 1;
#line 581
  clips_ptr = clips + (unsigned long )inc;
#line 581
  goto ldv_39512;
  ldv_39511: 
#line 583
  __min1 = left;
#line 583
  __min2 = (int )clips_ptr->x1;
#line 583
  left = __min1 < __min2 ? __min1 : __min2;
#line 584
  __max1 = right;
#line 584
  __max2 = (int )clips_ptr->x2;
#line 584
  right = __max1 > __max2 ? __max1 : __max2;
#line 585
  __min1___0 = top;
#line 585
  __min2___0 = (int )clips_ptr->y1;
#line 585
  top = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 586
  __max1___0 = bottom;
#line 586
  __max2___0 = (int )clips_ptr->y2;
#line 586
  bottom = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 582
  i = i + 1;
#line 582
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_39512: ;
#line 581
  if ((unsigned int )i < num_clips) {
#line 583
    goto ldv_39511;
  } else {

  }
#line 590
  memset((void *)cmd, 0, fifo_size);
#line 591
  cmd->header.id = 1069U;
#line 592
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 594
  cmd->body.srcRect.left = left;
#line 595
  cmd->body.srcRect.right = right;
#line 596
  cmd->body.srcRect.top = top;
#line 597
  cmd->body.srcRect.bottom = bottom;
#line 599
  clips_ptr = clips;
#line 600
  i = 0;
#line 600
  goto ldv_39515;
  ldv_39514: 
#line 601
  (tmp + (unsigned long )i)->x1 = (int )clips_ptr->x1 - (int )((unsigned short )left);
#line 602
  (tmp + (unsigned long )i)->x2 = (int )clips_ptr->x2 - (int )((unsigned short )left);
#line 603
  (tmp + (unsigned long )i)->y1 = (int )clips_ptr->y1 - (int )((unsigned short )top);
#line 604
  (tmp + (unsigned long )i)->y2 = (int )clips_ptr->y2 - (int )((unsigned short )top);
#line 600
  i = i + 1;
#line 600
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_39515: ;
#line 600
  if ((unsigned int )i < num_clips) {
#line 601
    goto ldv_39514;
  } else {

  }
#line 608
  i = 0;
#line 608
  goto ldv_39523;
  ldv_39522: 
#line 609
  unit = units[i];
#line 613
  clip.x1 = left - unit->crtc.x;
#line 614
  clip.y1 = top - unit->crtc.y;
#line 615
  clip.x2 = right - unit->crtc.x;
#line 616
  clip.y2 = bottom - unit->crtc.y;
#line 619
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 622
    goto ldv_39520;
  } else {

  }
#line 628
  cmd->body.destRect.left = clip.x1;
#line 629
  cmd->body.destRect.right = clip.x2;
#line 630
  cmd->body.destRect.top = clip.y1;
#line 631
  cmd->body.destRect.bottom = clip.y2;
#line 634
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 635
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 636
  clip.x1 = - clip.x1;
#line 637
  clip.y1 = - clip.y1;
#line 640
  cmd->body.srcImage.sid = framebuffer->user_handle;
#line 641
  cmd->body.destScreenId = unit->unit;
#line 644
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 647
  if (num == 0) {
#line 648
    goto ldv_39520;
  } else {

  }
#line 651
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 652
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 655
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 656
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 657
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 660
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 660
  if (tmp___7 != 0L) {
#line 661
    goto ldv_39521;
  } else {

  }
  ldv_39520: 
#line 608
  i = i + 1;
  ldv_39523: ;
#line 608
  if (i < num_units) {
#line 609
    goto ldv_39522;
  } else {

  }
  ldv_39521: 
#line 665
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 667
  kfree((void const   *)tmp);
#line 669
  return (ret);
}
}
#line 672 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                  unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                  unsigned int num_clips ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int inc ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 678
  tmp = vmw_priv(framebuffer->dev);
#line 678
  dev_priv = tmp;
#line 679
  tmp___0 = vmw_master(file_priv->master);
#line 679
  vmaster = tmp___0;
#line 681
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 681
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 683
  inc = 1;
#line 685
  tmp___1 = ldv__builtin_expect((unsigned long )vfbs->master != (unsigned long )file_priv->master,
                             0L);
#line 685
  if (tmp___1 != 0L) {
#line 686
    return (-22);
  } else {

  }
#line 689
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 690
    return (-22);
  } else {

  }
#line 692
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 693
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 693
  if (tmp___2 != 0L) {
#line 694
    return (ret);
  } else {

  }
#line 696
  if (num_clips == 0U) {
#line 697
    num_clips = 1U;
#line 698
    clips = & norect;
#line 699
    norect.y1 = 0U;
#line 699
    norect.x1 = norect.y1;
#line 700
    norect.x2 = (unsigned short )framebuffer->width;
#line 701
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 702
  if ((int )flags & 1) {
#line 703
    num_clips = num_clips / 2U;
#line 704
    inc = 2;
  } else {

  }
#line 707
  ret = do_surface_dirty_sou(dev_priv, file_priv, & vfbs->base, flags, color, clips,
                             num_clips, inc, 0);
#line 711
  ttm_read_unlock(& vmaster->lock);
#line 712
  return (0);
}
}
#line 715 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs  =    {& vmw_framebuffer_surface_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_surface_dirty};
#line 721 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                           struct vmw_surface *surface , struct vmw_framebuffer **out ,
                                           struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ 
  struct drm_device *dev ;
  struct vmw_framebuffer_surface *vfbs ;
  enum SVGA3dSurfaceFormat format ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  struct vmw_surface *tmp___11 ;

  {
#line 729
  dev = dev_priv->dev;
#line 732
  tmp = vmw_master(file_priv->master);
#line 732
  vmaster = tmp;
#line 736
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 737
    return (-38);
  } else {

  }
#line 744
  tmp___0 = ldv__builtin_expect((long )(! surface->scanout), 0L);
#line 744
  if (tmp___0 != 0L) {
#line 745
    return (-22);
  } else {

  }
#line 747
  tmp___1 = ldv__builtin_expect(surface->mip_levels[0] != 1U, 0L);
#line 747
  if (tmp___1 != 0L) {
#line 747
    tmp___3 = 1;
  } else {
#line 747
    tmp___2 = ldv__builtin_expect(surface->num_sizes != 1U, 0L);
#line 747
    if (tmp___2 != 0L) {
#line 747
      tmp___3 = 1;
    } else {
#line 747
      tmp___3 = 0;
    }
  }
#line 747
  if (tmp___3 != 0) {
#line 747
    tmp___5 = 1;
  } else {
#line 747
    tmp___4 = ldv__builtin_expect((surface->sizes)->width < (uint32_t )mode_cmd->width,
                               0L);
#line 747
    if (tmp___4 != 0L) {
#line 747
      tmp___5 = 1;
    } else {
#line 747
      tmp___5 = 0;
    }
  }
#line 747
  if (tmp___5 != 0) {
#line 747
    tmp___7 = 1;
  } else {
#line 747
    tmp___6 = ldv__builtin_expect((surface->sizes)->height < (uint32_t )mode_cmd->height,
                               0L);
#line 747
    if (tmp___6 != 0L) {
#line 747
      tmp___7 = 1;
    } else {
#line 747
      tmp___7 = 0;
    }
  }
#line 747
  if (tmp___7 != 0) {
#line 752
    drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 754
    return (-22);
  } else {
#line 747
    tmp___8 = ldv__builtin_expect((surface->sizes)->depth != 1U, 0L);
#line 747
    if (tmp___8 != 0L) {
#line 752
      drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 754
      return (-22);
    } else {

    }
  }
#line 757
  switch (mode_cmd->depth) {
  case (__u32 const   )32: 
#line 759
  format = SVGA3D_A8R8G8B8;
#line 760
  goto ldv_39555;
  case (__u32 const   )24: 
#line 762
  format = SVGA3D_X8R8G8B8;
#line 763
  goto ldv_39555;
  case (__u32 const   )16: 
#line 765
  format = SVGA3D_R5G6B5;
#line 766
  goto ldv_39555;
  case (__u32 const   )15: 
#line 768
  format = SVGA3D_A1R5G5B5;
#line 769
  goto ldv_39555;
  case (__u32 const   )8: 
#line 771
  format = SVGA3D_LUMINANCE8;
#line 772
  goto ldv_39555;
  default: 
#line 774
  drm_err("vmw_kms_new_framebuffer_surface", "Invalid color depth: %d\n", mode_cmd->depth);
#line 775
  return (-22);
  }
  ldv_39555: 
#line 778
  tmp___9 = ldv__builtin_expect(surface->format != (unsigned int )format, 0L);
#line 778
  if (tmp___9 != 0L) {
#line 779
    drm_err("vmw_kms_new_framebuffer_surface", "Invalid surface format for requested mode.\n");
#line 780
    return (-22);
  } else {

  }
#line 783
  tmp___10 = kzalloc(208UL, 208U);
#line 783
  vfbs = (struct vmw_framebuffer_surface *)tmp___10;
#line 784
  if ((unsigned long )vfbs == (unsigned long )((struct vmw_framebuffer_surface *)0)) {
#line 785
    ret = -12;
#line 786
    goto out_err1;
  } else {

  }
#line 789
  ret = drm_framebuffer_init(dev, & vfbs->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_surface_funcs));
#line 791
  if (ret != 0) {
#line 792
    goto out_err2;
  } else {

  }
#line 794
  tmp___11 = vmw_surface_reference(surface);
#line 794
  if ((unsigned long )tmp___11 == (unsigned long )((struct vmw_surface *)0)) {
#line 795
    drm_err("vmw_kms_new_framebuffer_surface", "failed to reference surface %p\n",
            surface);
#line 796
    goto out_err3;
  } else {

  }
#line 800
  vfbs->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 801
  vfbs->base.base.pitches[0] = mode_cmd->pitch;
#line 802
  vfbs->base.base.depth = mode_cmd->depth;
#line 803
  vfbs->base.base.width = mode_cmd->width;
#line 804
  vfbs->base.base.height = mode_cmd->height;
#line 805
  vfbs->surface = surface;
#line 806
  vfbs->base.user_handle = mode_cmd->handle;
#line 807
  vfbs->master = drm_master_get(file_priv->master);
#line 809
  ldv_mutex_lock_85(& vmaster->fb_surf_mutex);
#line 810
  list_add_tail(& vfbs->head, & vmaster->fb_surf);
#line 811
  ldv_mutex_unlock_86(& vmaster->fb_surf_mutex);
#line 813
  *out = & vfbs->base;
#line 815
  return (0);
  out_err3: 
#line 818
  drm_framebuffer_cleanup(& vfbs->base.base);
  out_err2: 
#line 820
  kfree((void const   *)vfbs);
  out_err1: ;
#line 822
  return (ret);
}
}
#line 837 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer ) 
{ 
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;

  {
#line 840
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 840
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 842
  drm_framebuffer_cleanup(framebuffer);
#line 843
  vmw_dmabuf_unreference(& vfbd->buffer);
#line 844
  ttm_base_object_unref(& vfbd->base.user_obj);
#line 846
  kfree((void const   *)vfbd);
#line 847
  return;
}
}
#line 849 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv , struct vmw_framebuffer *framebuffer ,
                               unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment ) 
{ 
  size_t fifo_size ;
  int i ;
  struct __anonstruct_cmd_287 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 863
  fifo_size = (unsigned long )num_clips * 20UL;
#line 864
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 864
  cmd = (struct __anonstruct_289 *)tmp;
#line 865
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_287 *)0),
                             0L);
#line 865
  if (tmp___0 != 0L) {
#line 866
    drm_err("do_dmabuf_dirty_ldu", "Fifo reserve failed.\n");
#line 867
    return (-12);
  } else {

  }
#line 870
  memset((void *)cmd, 0, fifo_size);
#line 871
  i = 0;
#line 871
  goto ldv_39590;
  ldv_39589: 
#line 872
  (cmd + (unsigned long )i)->header = 1U;
#line 873
  (cmd + (unsigned long )i)->body.x = (unsigned int )clips->x1;
#line 874
  (cmd + (unsigned long )i)->body.y = (unsigned int )clips->y1;
#line 875
  (cmd + (unsigned long )i)->body.width = (unsigned int )((int )clips->x2 - (int )clips->x1);
#line 876
  (cmd + (unsigned long )i)->body.height = (unsigned int )((int )clips->y2 - (int )clips->y1);
#line 871
  i = i + 1;
#line 871
  clips = clips + (unsigned long )increment;
  ldv_39590: ;
#line 871
  if ((unsigned int )i < num_clips) {
#line 872
    goto ldv_39589;
  } else {

  }
#line 879
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 880
  return (0);
}
}
#line 883 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_define_gmrfb(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                                  struct vmw_framebuffer *framebuffer ) 
{ 
  int depth ;
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_291 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 887
  depth = (int )framebuffer->base.depth;
#line 900
  if (depth == 32) {
#line 901
    depth = 24;
  } else {

  }
#line 903
  fifo_size = 20UL;
#line 904
  tmp = kmalloc(fifo_size, 208U);
#line 904
  cmd = (struct __anonstruct_293 *)tmp;
#line 905
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291 *)0),
                             0L);
#line 905
  if (tmp___0 != 0L) {
#line 906
    drm_err("do_dmabuf_define_gmrfb", "Failed to allocate temporary cmd buffer.\n");
#line 907
    return (-12);
  } else {

  }
#line 910
  memset((void *)cmd, 0, fifo_size);
#line 911
  cmd->header = 36U;
#line 912
  cmd->body.format.ldv_6409.ldv_6407.bitsPerPixel = (unsigned char )framebuffer->base.bits_per_pixel;
#line 913
  cmd->body.format.ldv_6409.ldv_6407.colorDepth = (unsigned char )depth;
#line 914
  cmd->body.format.ldv_6409.ldv_6407.reserved = 0U;
#line 915
  cmd->body.bytesPerLine = framebuffer->base.pitches[0];
#line 916
  cmd->body.ptr.gmrId = framebuffer->user_handle;
#line 917
  cmd->body.ptr.offset = 0U;
#line 919
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 922
  kfree((void const   *)cmd);
#line 924
  return (ret);
}
}
#line 927 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_sou(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_framebuffer *framebuffer , unsigned int flags ,
                               unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment , struct vmw_fence_obj **out_fence ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  struct __anonstruct_blits_295 *blits ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  int tmp___2 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct vmw_display_unit *unit ;
  int hit_num ;
  int clip_x1 ;
  int clip_y1 ;
  int clip_x2 ;
  int clip_y2 ;
  int move_x ;
  int move_y ;
  int __min1 ;
  int __min2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __min1___1 ;
  int __min2___1 ;
  int __min1___2 ;
  int __min2___2 ;
  long tmp___3 ;

  {
#line 946
  ret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);
#line 947
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 947
  if (tmp != 0L) {
#line 948
    return (ret);
  } else {

  }
#line 950
  fifo_size = (unsigned long )num_clips * 32UL;
#line 951
  tmp___0 = kmalloc(fifo_size, 208U);
#line 951
  blits = (struct __anonstruct_297 *)tmp___0;
#line 952
  tmp___1 = ldv__builtin_expect((unsigned long )blits == (unsigned long )((struct __anonstruct_blits_295 *)0),
                             0L);
#line 952
  if (tmp___1 != 0L) {
#line 953
    drm_err("do_dmabuf_dirty_sou", "Failed to allocate temporary cmd buffer.\n");
#line 954
    return (-12);
  } else {

  }
#line 957
  num_units = 0;
#line 958
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 958
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 958
  goto ldv_39637;
  ldv_39636: ;
#line 959
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 960
    goto ldv_39633;
  } else {

  }
#line 961
  tmp___2 = num_units;
#line 961
  num_units = num_units + 1;
#line 961
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 961
  units[tmp___2] = (struct vmw_display_unit *)__mptr___0;
  ldv_39633: 
#line 958
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 958
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39637: ;
#line 958
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 959
    goto ldv_39636;
  } else {

  }
#line 964
  k = 0;
#line 964
  goto ldv_39666;
  ldv_39665: 
#line 965
  unit = units[k];
#line 966
  hit_num = 0;
#line 968
  clips_ptr = clips;
#line 969
  i = 0;
#line 969
  goto ldv_39661;
  ldv_39660: 
#line 970
  clip_x1 = (int )clips_ptr->x1 - unit->crtc.x;
#line 971
  clip_y1 = (int )clips_ptr->y1 - unit->crtc.y;
#line 972
  clip_x2 = (int )clips_ptr->x2 - unit->crtc.x;
#line 973
  clip_y2 = (int )clips_ptr->y2 - unit->crtc.y;
#line 977
  if (((unit->crtc.mode.hdisplay <= clip_x1 || unit->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 980
    goto ldv_39647;
  } else {

  }
#line 983
  __min1 = clip_x2;
#line 983
  __min2 = unit->crtc.mode.hdisplay;
#line 983
  clip_x2 = __min1 < __min2 ? __min1 : __min2;
#line 984
  __min1___0 = clip_y2;
#line 984
  __min2___0 = unit->crtc.mode.vdisplay;
#line 984
  clip_y2 = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 987
  __min1___1 = clip_x1;
#line 987
  __min2___1 = 0;
#line 987
  move_x = __min1___1 < __min2___1 ? __min1___1 : __min2___1;
#line 988
  __min1___2 = clip_y1;
#line 988
  __min2___2 = 0;
#line 988
  move_y = __min1___2 < __min2___2 ? __min1___2 : __min2___2;
#line 991
  (blits + (unsigned long )hit_num)->header = 37U;
#line 992
  (blits + (unsigned long )hit_num)->body.destScreenId = unit->unit;
#line 993
  (blits + (unsigned long )hit_num)->body.srcOrigin.x = (int )clips_ptr->x1 - move_x;
#line 994
  (blits + (unsigned long )hit_num)->body.srcOrigin.y = (int )clips_ptr->y1 - move_y;
#line 995
  (blits + (unsigned long )hit_num)->body.destRect.left = clip_x1 - move_x;
#line 996
  (blits + (unsigned long )hit_num)->body.destRect.top = clip_y1 - move_y;
#line 997
  (blits + (unsigned long )hit_num)->body.destRect.right = clip_x2;
#line 998
  (blits + (unsigned long )hit_num)->body.destRect.bottom = clip_y2;
#line 999
  hit_num = hit_num + 1;
  ldv_39647: 
#line 969
  i = i + 1;
#line 969
  clips_ptr = clips_ptr + (unsigned long )increment;
  ldv_39661: ;
#line 969
  if ((unsigned int )i < num_clips) {
#line 970
    goto ldv_39660;
  } else {

  }

#line 1003
  if (hit_num == 0) {
#line 1004
    goto ldv_39663;
  } else {

  }
#line 1007
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1008
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 1010
  fifo_size = (unsigned long )hit_num * 32UL;
#line 1011
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)blits, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 1014
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1014
  if (tmp___3 != 0L) {
#line 1015
    goto ldv_39664;
  } else {

  }
  ldv_39663: 
#line 964
  k = k + 1;
  ldv_39666: ;
#line 964
  if (k < num_units) {
#line 965
    goto ldv_39665;
  } else {

  }
  ldv_39664: 
#line 1018
  kfree((void const   *)blits);
#line 1020
  return (ret);
}
}
#line 1023 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                 unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                 unsigned int num_clips ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int increment ;
  long tmp___1 ;

  {
#line 1029
  tmp = vmw_priv(framebuffer->dev);
#line 1029
  dev_priv = tmp;
#line 1030
  tmp___0 = vmw_master(file_priv->master);
#line 1030
  vmaster = tmp___0;
#line 1032
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 1032
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1034
  increment = 1;
#line 1036
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1037
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1037
  if (tmp___1 != 0L) {
#line 1038
    return (ret);
  } else {

  }
#line 1040
  if (num_clips == 0U) {
#line 1041
    num_clips = 1U;
#line 1042
    clips = & norect;
#line 1043
    norect.y1 = 0U;
#line 1043
    norect.x1 = norect.y1;
#line 1044
    norect.x2 = (unsigned short )framebuffer->width;
#line 1045
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 1046
  if ((int )flags & 1) {
#line 1047
    num_clips = num_clips / 2U;
#line 1048
    increment = 2;
  } else {

  }
#line 1051
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 1052
    ret = do_dmabuf_dirty_ldu(dev_priv, & vfbd->base, flags, color, clips, num_clips,
                              increment);
  } else {
#line 1056
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, & vfbd->base, flags, color, clips,
                              num_clips, increment, 0);
  }
#line 1061
  ttm_read_unlock(& vmaster->lock);
#line 1062
  return (ret);
}
}
#line 1065 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_dmabuf_funcs  =    {& vmw_framebuffer_dmabuf_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_dmabuf_dirty};
#line 1074 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int ret ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 1076
  tmp = vmw_priv(vfb->base.dev);
#line 1076
  dev_priv = tmp;
#line 1078
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1078
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1082
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 1082
  if (tmp___0 != 0L) {
#line 1082
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1082), "i" (12UL));
    ldv_39692: ;
#line 1082
    goto ldv_39692;
  } else {

  }
#line 1084
  vmw_overlay_pause_all(dev_priv);
#line 1086
  ret = vmw_dmabuf_to_start_of_vram(dev_priv, vfbd->buffer, 1, 0);
#line 1088
  vmw_overlay_resume_all(dev_priv);
#line 1090
  __ret_warn_on = ret != 0;
#line 1090
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1090
  if (tmp___1 != 0L) {
#line 1090
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                       1090);
  } else {

  }
#line 1090
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1092
  return (0);
}
}
#line 1095 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1097
  tmp = vmw_priv(vfb->base.dev);
#line 1097
  dev_priv = tmp;
#line 1099
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1099
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1101
  if ((unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1102
    __ret_warn_on = (unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0);
#line 1102
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1102
    if (tmp___0 != 0L) {
#line 1102
      warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                         1102);
    } else {

    }
#line 1102
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1103
    return (0);
  } else {

  }
#line 1106
  tmp___1 = vmw_dmabuf_unpin(dev_priv, vfbd->buffer, 0);
#line 1106
  return (tmp___1);
}
}
#line 1109 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                                          struct vmw_framebuffer **out , struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ 
  struct drm_device *dev ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  unsigned int requested_size ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  struct vmw_dma_buffer *tmp___1 ;

  {
#line 1116
  dev = dev_priv->dev;
#line 1121
  requested_size = (unsigned int )mode_cmd->height * (unsigned int )mode_cmd->pitch;
#line 1122
  tmp = ldv__builtin_expect((unsigned long )requested_size > dmabuf->base.num_pages * 4096UL,
                         0L);
#line 1122
  if (tmp != 0L) {
#line 1123
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Screen buffer object size is too small for requested mode.\n");
#line 1125
    return (-22);
  } else {

  }
#line 1129
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1130
    switch (mode_cmd->depth) {
    case (__u32 const   )32: ;
    case (__u32 const   )24: ;
#line 1134
    if ((unsigned int )mode_cmd->bpp == 32U) {
#line 1135
      goto ldv_39717;
    } else {

    }
#line 1137
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1139
    return (-22);
    case (__u32 const   )16: ;
    case (__u32 const   )15: ;
#line 1143
    if ((unsigned int )mode_cmd->bpp == 16U) {
#line 1144
      goto ldv_39717;
    } else {

    }
#line 1146
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1148
    return (-22);
    default: 
#line 1150
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth: %d\n", mode_cmd->depth);
#line 1151
    return (-22);
    }
    ldv_39717: ;
  } else {

  }
#line 1155
  tmp___0 = kzalloc(176UL, 208U);
#line 1155
  vfbd = (struct vmw_framebuffer_dmabuf *)tmp___0;
#line 1156
  if ((unsigned long )vfbd == (unsigned long )((struct vmw_framebuffer_dmabuf *)0)) {
#line 1157
    ret = -12;
#line 1158
    goto out_err1;
  } else {

  }
#line 1161
  ret = drm_framebuffer_init(dev, & vfbd->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_dmabuf_funcs));
#line 1163
  if (ret != 0) {
#line 1164
    goto out_err2;
  } else {

  }
#line 1166
  tmp___1 = vmw_dmabuf_reference(dmabuf);
#line 1166
  if ((unsigned long )tmp___1 == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1167
    drm_err("vmw_kms_new_framebuffer_dmabuf", "failed to reference dmabuf %p\n", dmabuf);
#line 1168
    goto out_err3;
  } else {

  }
#line 1171
  vfbd->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 1172
  vfbd->base.base.pitches[0] = mode_cmd->pitch;
#line 1173
  vfbd->base.base.depth = mode_cmd->depth;
#line 1174
  vfbd->base.base.width = mode_cmd->width;
#line 1175
  vfbd->base.base.height = mode_cmd->height;
#line 1176
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1177
    vfbd->base.pin = & vmw_framebuffer_dmabuf_pin;
#line 1178
    vfbd->base.unpin = & vmw_framebuffer_dmabuf_unpin;
  } else {

  }
#line 1180
  vfbd->base.dmabuf = 1;
#line 1181
  vfbd->buffer = dmabuf;
#line 1182
  vfbd->base.user_handle = mode_cmd->handle;
#line 1183
  *out = & vfbd->base;
#line 1185
  return (0);
  out_err3: 
#line 1188
  drm_framebuffer_cleanup(& vfbd->base.base);
  out_err2: 
#line 1190
  kfree((void const   *)vfbd);
  out_err1: ;
#line 1192
  return (ret);
}
}
#line 1199 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev , struct drm_file *file_priv ,
                                                 struct drm_mode_fb_cmd2 *mode_cmd2 ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_framebuffer *vfb ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *bo ;
  struct ttm_base_object *user_obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  int ret ;
  void *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;

  {
#line 1203
  tmp = vmw_priv(dev);
#line 1203
  dev_priv = tmp;
#line 1204
  tmp___0 = vmw_fpriv(file_priv);
#line 1204
  tfile = tmp___0->tfile;
#line 1205
  vfb = 0;
#line 1206
  surface = 0;
#line 1207
  bo = 0;
#line 1212
  mode_cmd.width = mode_cmd2->width;
#line 1213
  mode_cmd.height = mode_cmd2->height;
#line 1214
  mode_cmd.pitch = mode_cmd2->pitches[0];
#line 1215
  mode_cmd.handle = mode_cmd2->handles[0];
#line 1216
  drm_fb_get_bpp_depth(mode_cmd2->pixel_format, & mode_cmd.depth, (int *)(& mode_cmd.bpp));
#line 1225
  tmp___2 = vmw_kms_validate_mode_vram(dev_priv, mode_cmd.pitch, mode_cmd.height);
#line 1225
  if (tmp___2) {
#line 1225
    tmp___3 = 0;
  } else {
#line 1225
    tmp___3 = 1;
  }
#line 1225
  if (tmp___3) {
#line 1228
    drm_err("vmw_kms_fb_create", "VRAM size is too small for requested mode.\n");
#line 1229
    tmp___1 = ERR_PTR(-12L);
#line 1229
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
#line 1241
  user_obj = ttm_base_object_lookup(tfile, mode_cmd.handle);
#line 1242
  tmp___5 = ldv__builtin_expect((unsigned long )user_obj == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 1242
  if (tmp___5 != 0L) {
#line 1243
    drm_err("vmw_kms_fb_create", "Could not locate requested kms frame buffer.\n");
#line 1244
    tmp___4 = ERR_PTR(-2L);
#line 1244
    return ((struct drm_framebuffer *)tmp___4);
  } else {

  }
#line 1252
  ret = vmw_user_lookup_handle(dev_priv, tfile, mode_cmd.handle, & surface, & bo);
#line 1255
  if (ret != 0) {
#line 1256
    goto err_out;
  } else {

  }
#line 1259
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1260
    ret = vmw_kms_new_framebuffer_dmabuf(dev_priv, bo, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else
#line 1262
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1263
    ret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, surface, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else {
#line 1266
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1266), "i" (12UL));
    ldv_39739: ;
#line 1266
    goto ldv_39739;
  }
  err_out: ;
#line 1270
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1271
    vmw_dmabuf_unreference(& bo);
  } else {

  }
#line 1272
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1273
    vmw_surface_unreference(& surface);
  } else {

  }
#line 1275
  if (ret != 0) {
#line 1276
    drm_err("vmw_kms_fb_create", "failed to create vmw_framebuffer: %i\n", ret);
#line 1277
    ttm_base_object_unref(& user_obj);
#line 1278
    tmp___6 = ERR_PTR((long )ret);
#line 1278
    return ((struct drm_framebuffer *)tmp___6);
  } else {
#line 1280
    vfb->user_obj = user_obj;
  }
#line 1282
  return (& vfb->base);
}
}
#line 1285 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_mode_config_funcs  const  vmw_kms_funcs  =    {& vmw_kms_fb_create, 0};
#line 1289 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) 
{ 
  struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_299 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int __min1 ;
  int __min2 ;
  int __max1 ;
  int __max2 ;
  int __min1___0 ;
  int __min2___0 ;
  int __max1___0 ;
  int __max2___0 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___8 ;

  {
#line 1303
  ret = 0;
#line 1312
  num_units = 0;
#line 1313
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1313
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1313
  goto ldv_39777;
  ldv_39776: ;
#line 1314
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1315
    goto ldv_39773;
  } else {

  }
#line 1316
  tmp___0 = num_units;
#line 1316
  num_units = num_units + 1;
#line 1316
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1316
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_39773: 
#line 1313
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1313
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39777: ;
#line 1313
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1314
    goto ldv_39776;
  } else {

  }
#line 1319
  tmp___1 = ldv__builtin_expect((unsigned long )surface == (unsigned long )((struct vmw_surface *)0),
                             0L);
#line 1319
  if (tmp___1 != 0L) {
#line 1319
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1319), "i" (12UL));
    ldv_39779: ;
#line 1319
    goto ldv_39779;
  } else {

  }
#line 1320
  tmp___2 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1320
  if (tmp___2 != 0L) {
#line 1320
    goto _L;
  } else {
#line 1320
    tmp___3 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1320
    if (tmp___3 != 0L) {
      _L: /* CIL Label */ 
#line 1320
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1320), "i" (12UL));
      ldv_39780: ;
#line 1320
      goto ldv_39780;
    } else {

    }
  }
#line 1322
  tmp___4 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 1322
  tmp = (struct drm_clip_rect *)tmp___4;
#line 1323
  tmp___5 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 1323
  if (tmp___5 != 0L) {
#line 1324
    drm_err("vmw_kms_present", "Temporary cliprect memory alloc failed.\n");
#line 1325
    return (-12);
  } else {

  }
#line 1328
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 1329
  tmp___6 = kmalloc(fifo_size, 208U);
#line 1329
  cmd = (struct __anonstruct_301 *)tmp___6;
#line 1330
  tmp___7 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_299 *)0),
                             0L);
#line 1330
  if (tmp___7 != 0L) {
#line 1331
    drm_err("vmw_kms_present", "Failed to allocate temporary fifo memory.\n");
#line 1332
    ret = -12;
#line 1333
    goto out_free_tmp;
  } else {

  }
#line 1336
  left = clips->x;
#line 1337
  right = (int )((uint32_t )clips->x + clips->w);
#line 1338
  top = clips->y;
#line 1339
  bottom = (int )((uint32_t )clips->y + clips->h);
#line 1341
  i = 1;
#line 1341
  goto ldv_39796;
  ldv_39795: 
#line 1342
  __min1 = left;
#line 1342
  __min2 = (clips + (unsigned long )i)->x;
#line 1342
  left = __min1 < __min2 ? __min1 : __min2;
#line 1343
  __max1 = right;
#line 1343
  __max2 = (int )((uint32_t )(clips + (unsigned long )i)->x + (clips + (unsigned long )i)->w);
#line 1343
  right = __max1 > __max2 ? __max1 : __max2;
#line 1344
  __min1___0 = top;
#line 1344
  __min2___0 = (clips + (unsigned long )i)->y;
#line 1344
  top = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 1345
  __max1___0 = bottom;
#line 1345
  __max2___0 = (int )((uint32_t )(clips + (unsigned long )i)->y + (clips + (unsigned long )i)->h);
#line 1345
  bottom = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 1341
  i = i + 1;
  ldv_39796: ;
#line 1341
  if ((uint32_t )i < num_clips) {
#line 1342
    goto ldv_39795;
  } else {

  }
#line 1349
  memset((void *)cmd, 0, fifo_size);
#line 1350
  cmd->header.id = 1069U;
#line 1352
  blits = (SVGASignedRect *)cmd + 1U;
#line 1354
  cmd->body.srcRect.left = left;
#line 1355
  cmd->body.srcRect.right = right;
#line 1356
  cmd->body.srcRect.top = top;
#line 1357
  cmd->body.srcRect.bottom = bottom;
#line 1359
  i = 0;
#line 1359
  goto ldv_39799;
  ldv_39798: 
#line 1360
  (tmp + (unsigned long )i)->x1 = (int )((unsigned short )(clips + (unsigned long )i)->x) - (int )((unsigned short )left);
#line 1361
  (tmp + (unsigned long )i)->x2 = ((int )((unsigned short )(clips + (unsigned long )i)->x) + (int )((unsigned short )(clips + (unsigned long )i)->w)) - (int )((unsigned short )left);
#line 1362
  (tmp + (unsigned long )i)->y1 = (int )((unsigned short )(clips + (unsigned long )i)->y) - (int )((unsigned short )top);
#line 1363
  (tmp + (unsigned long )i)->y2 = ((int )((unsigned short )(clips + (unsigned long )i)->y) + (int )((unsigned short )(clips + (unsigned long )i)->h)) - (int )((unsigned short )top);
#line 1359
  i = i + 1;
  ldv_39799: ;
#line 1359
  if ((uint32_t )i < num_clips) {
#line 1360
    goto ldv_39798;
  } else {

  }
#line 1366
  k = 0;
#line 1366
  goto ldv_39807;
  ldv_39806: 
#line 1367
  unit = units[k];
#line 1371
  clip.x1 = (left + destX) - unit->crtc.x;
#line 1372
  clip.y1 = (top + destY) - unit->crtc.y;
#line 1373
  clip.x2 = (right + destX) - unit->crtc.x;
#line 1374
  clip.y2 = (bottom + destY) - unit->crtc.y;
#line 1377
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 1380
    goto ldv_39804;
  } else {

  }
#line 1386
  cmd->body.destRect.left = clip.x1;
#line 1387
  cmd->body.destRect.right = clip.x2;
#line 1388
  cmd->body.destRect.top = clip.y1;
#line 1389
  cmd->body.destRect.bottom = clip.y2;
#line 1392
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 1393
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 1394
  clip.x1 = - clip.x1;
#line 1395
  clip.y1 = - clip.y1;
#line 1398
  cmd->body.srcImage.sid = sid;
#line 1399
  cmd->body.destScreenId = unit->unit;
#line 1402
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 1405
  if (num == 0) {
#line 1406
    goto ldv_39804;
  } else {

  }
#line 1409
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 1410
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 1411
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 1414
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 1414
  if (tmp___8 != 0L) {
#line 1415
    goto ldv_39805;
  } else {

  }
  ldv_39804: 
#line 1366
  k = k + 1;
  ldv_39807: ;
#line 1366
  if (k < num_units) {
#line 1367
    goto ldv_39806;
  } else {

  }
  ldv_39805: 
#line 1418
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 1420
  kfree((void const   *)tmp);
#line 1422
  return (ret);
}
}
#line 1425 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) 
{ 
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_dma_buffer *dmabuf ;
  struct vmw_display_unit *units[8U] ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int ret ;
  int num_units ;
  int blits_pos ;
  struct __anonstruct_cmd_303 *cmd ;
  struct __anonstruct_blits_305 *blits ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct drm_crtc  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  struct drm_vmw_rect *c ;
  int clip_x1 ;
  int clip_x2 ;
  int clip_y1 ;
  int clip_y2 ;
  int dest_x ;
  int dest_y ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int _min1 ;
  int _min2 ;
  int _min1___0 ;
  int _min2___0 ;

  {
#line 1433
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1433
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1434
  dmabuf = vfbd->buffer;
#line 1449
  num_units = 0;
#line 1450
  __mptr___0 = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1450
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
#line 1450
  goto ldv_39844;
  ldv_39843: ;
#line 1451
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1452
    goto ldv_39840;
  } else {

  }
#line 1453
  tmp = num_units;
#line 1453
  num_units = num_units + 1;
#line 1453
  __mptr___1 = (struct drm_crtc  const  *)crtc;
#line 1453
  units[tmp] = (struct vmw_display_unit *)__mptr___1;
  ldv_39840: 
#line 1450
  __mptr___2 = (struct list_head  const  *)crtc->head.next;
#line 1450
  crtc = (struct drm_crtc *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_39844: ;
#line 1450
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1451
    goto ldv_39843;
  } else {

  }
#line 1456
  tmp___0 = ldv__builtin_expect((unsigned long )dmabuf == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1456
  if (tmp___0 != 0L) {
#line 1456
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1456), "i" (12UL));
    ldv_39846: ;
#line 1456
    goto ldv_39846;
  } else {

  }
#line 1457
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1457
  if (tmp___1 != 0L) {
#line 1457
    goto _L;
  } else {
#line 1457
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1457
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 1457
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1457), "i" (12UL));
      ldv_39847: ;
#line 1457
      goto ldv_39847;
    } else {

    }
  }
#line 1460
  fifo_size = ((unsigned long )num_clips * (unsigned long )num_units) * 32UL + 20UL;
#line 1461
  tmp___3 = kmalloc(fifo_size, 208U);
#line 1461
  cmd = (struct __anonstruct_307 *)tmp___3;
#line 1462
  tmp___4 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_303 *)0),
                             0L);
#line 1462
  if (tmp___4 != 0L) {
#line 1463
    drm_err("vmw_kms_readback", "Failed to allocate temporary fifo memory.\n");
#line 1464
    return (-12);
  } else {

  }
#line 1467
  memset((void *)cmd, 0, fifo_size);
#line 1468
  cmd->header = 36U;
#line 1469
  cmd->body.format.ldv_6409.ldv_6407.bitsPerPixel = (unsigned char )vfb->base.bits_per_pixel;
#line 1470
  cmd->body.format.ldv_6409.ldv_6407.colorDepth = (unsigned char )vfb->base.depth;
#line 1471
  cmd->body.format.ldv_6409.ldv_6407.reserved = 0U;
#line 1472
  cmd->body.bytesPerLine = vfb->base.pitches[0];
#line 1473
  cmd->body.ptr.gmrId = vfb->user_handle;
#line 1474
  cmd->body.ptr.offset = 0U;
#line 1476
  blits = (struct __anonstruct_309 *)cmd + 1U;
#line 1477
  blits_pos = 0;
#line 1478
  i = 0;
#line 1478
  goto ldv_39873;
  ldv_39872: 
#line 1479
  c = clips;
#line 1480
  k = 0;
#line 1480
  goto ldv_39870;
  ldv_39869: 
#line 1482
  clip_x1 = c->x - (units[i])->crtc.x;
#line 1483
  clip_x2 = (int )((uint32_t )(c->x - (units[i])->crtc.x) + c->w);
#line 1484
  clip_y1 = c->y - (units[i])->crtc.y;
#line 1485
  clip_y2 = (int )((uint32_t )(c->y - (units[i])->crtc.y) + c->h);
#line 1486
  dest_x = c->x;
#line 1487
  dest_y = c->y;
#line 1492
  if (clip_x1 < 0) {
#line 1493
    dest_x = dest_x - clip_x1;
  } else {

  }
#line 1494
  if (clip_y1 < 0) {
#line 1495
    dest_y = dest_y - clip_y1;
  } else {

  }
#line 1498
  _max1 = clip_x1;
#line 1498
  _max2 = 0;
#line 1498
  clip_x1 = _max1 > _max2 ? _max1 : _max2;
#line 1499
  _max1___0 = clip_y1;
#line 1499
  _max2___0 = 0;
#line 1499
  clip_y1 = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 1500
  _min1 = clip_x2;
#line 1500
  _min2 = (units[i])->crtc.mode.hdisplay;
#line 1500
  clip_x2 = _min1 < _min2 ? _min1 : _min2;
#line 1501
  _min1___0 = clip_y2;
#line 1501
  _min2___0 = (units[i])->crtc.mode.vdisplay;
#line 1501
  clip_y2 = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 1504
  if ((((units[i])->crtc.mode.hdisplay <= clip_x1 || (units[i])->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 1507
    goto ldv_39868;
  } else {

  }
#line 1509
  (blits + (unsigned long )blits_pos)->header = 38U;
#line 1510
  (blits + (unsigned long )blits_pos)->body.srcScreenId = (units[i])->unit;
#line 1511
  (blits + (unsigned long )blits_pos)->body.destOrigin.x = dest_x;
#line 1512
  (blits + (unsigned long )blits_pos)->body.destOrigin.y = dest_y;
#line 1514
  (blits + (unsigned long )blits_pos)->body.srcRect.left = clip_x1;
#line 1515
  (blits + (unsigned long )blits_pos)->body.srcRect.top = clip_y1;
#line 1516
  (blits + (unsigned long )blits_pos)->body.srcRect.right = clip_x2;
#line 1517
  (blits + (unsigned long )blits_pos)->body.srcRect.bottom = clip_y2;
#line 1518
  blits_pos = blits_pos + 1;
  ldv_39868: 
#line 1480
  k = k + 1;
#line 1480
  c = c + 1;
  ldv_39870: ;
#line 1480
  if ((uint32_t )k < num_clips) {
#line 1481
    goto ldv_39869;
  } else {

  }
#line 1478
  i = i + 1;
  ldv_39873: ;
#line 1478
  if (i < num_units) {
#line 1479
    goto ldv_39872;
  } else {

  }
#line 1522
  fifo_size = (unsigned long )blits_pos * 32UL + 20UL;
#line 1524
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, user_fence_rep, 0);
#line 1527
  kfree((void const   *)cmd);
#line 1529
  return (ret);
}
}
#line 1532 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_init(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int ret ;

  {
#line 1534
  dev = dev_priv->dev;
#line 1537
  drm_mode_config_init(dev);
#line 1538
  dev->mode_config.funcs = & vmw_kms_funcs;
#line 1539
  dev->mode_config.min_width = 1;
#line 1540
  dev->mode_config.min_height = 1;
#line 1542
  dev->mode_config.max_width = 8192;
#line 1543
  dev->mode_config.max_height = 8192;
#line 1545
  ret = vmw_kms_init_screen_object_display(dev_priv);
#line 1546
  if (ret != 0) {
#line 1547
    vmw_kms_init_legacy_display_system(dev_priv);
  } else {

  }
#line 1549
  return (0);
}
}
#line 1552 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_close(struct vmw_private *dev_priv ) 
{ 


  {
#line 1559
  drm_mode_config_cleanup(dev_priv->dev);
#line 1560
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1561
    vmw_kms_close_screen_object_display(dev_priv);
  } else {
#line 1563
    vmw_kms_close_legacy_display_system(dev_priv);
  }
#line 1564
  return (0);
}
}
#line 1567 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_cursor_bypass_arg *arg ;
  struct vmw_display_unit *du ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct drm_mode_object  const  *__mptr___2 ;
  struct drm_crtc  const  *__mptr___3 ;

  {
#line 1570
  arg = (struct drm_vmw_cursor_bypass_arg *)data;
#line 1574
  ret = 0;
#line 1577
  ldv_mutex_lock_87(& dev->mode_config.mutex);
#line 1578
  if ((int )arg->flags & 1) {
#line 1580
    __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 1580
    crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1580
    goto ldv_39900;
    ldv_39899: 
#line 1581
    __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1581
    du = (struct vmw_display_unit *)__mptr___0;
#line 1582
    du->hotspot_x = arg->xhot;
#line 1583
    du->hotspot_y = arg->yhot;
#line 1580
    __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1580
    crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
    ldv_39900: ;
#line 1580
    if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 1581
      goto ldv_39899;
    } else {

    }
#line 1586
    ldv_mutex_unlock_88(& dev->mode_config.mutex);
#line 1587
    return (0);
  } else {

  }
#line 1590
  obj = drm_mode_object_find(dev, arg->crtc_id, 3435973836U);
#line 1591
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 1592
    ret = -22;
#line 1593
    goto out;
  } else {

  }
#line 1596
  __mptr___2 = (struct drm_mode_object  const  *)obj;
#line 1596
  crtc = (struct drm_crtc *)__mptr___2 + 0xffffffffffffffe8UL;
#line 1597
  __mptr___3 = (struct drm_crtc  const  *)crtc;
#line 1597
  du = (struct vmw_display_unit *)__mptr___3;
#line 1599
  du->hotspot_x = arg->xhot;
#line 1600
  du->hotspot_y = arg->yhot;
  out: 
#line 1603
  ldv_mutex_unlock_89(& dev->mode_config.mutex);
#line 1605
  return (ret);
}
}
#line 1608 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) 
{ 
  bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1612
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1613
    vmw_write(vmw_priv___0, 32U, pitch);
  } else {
#line 1614
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1614
    if ((int )tmp) {
#line 1615
      iowrite32(pitch, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1616
  vmw_write(vmw_priv___0, 2U, width);
#line 1617
  vmw_write(vmw_priv___0, 3U, height);
#line 1618
  vmw_write(vmw_priv___0, 7U, bpp);
#line 1620
  tmp___1 = vmw_read(vmw_priv___0, 6U);
#line 1620
  if (tmp___1 != depth) {
#line 1621
    tmp___0 = vmw_read(vmw_priv___0, 6U);
#line 1621
    drm_err("vmw_kms_write_svga", "Invalid depth %u for %u bpp, host expects %u\n",
            depth, bpp, tmp___0);
#line 1623
    return (-22);
  } else {

  }
#line 1626
  return (0);
}
}
#line 1629 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) 
{ 
  struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1634
  vmw_priv___0->vga_width = vmw_read(vmw_priv___0, 2U);
#line 1635
  vmw_priv___0->vga_height = vmw_read(vmw_priv___0, 3U);
#line 1636
  vmw_priv___0->vga_bpp = vmw_read(vmw_priv___0, 7U);
#line 1637
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1638
    vmw_priv___0->vga_pitchlock = vmw_read(vmw_priv___0, 32U);
  } else {
#line 1640
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1640
    if ((int )tmp) {
#line 1641
      vmw_priv___0->vga_pitchlock = ioread32((void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1644
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1645
    return (0);
  } else {

  }
#line 1647
  vmw_priv___0->num_displays = vmw_read(vmw_priv___0, 34U);
#line 1650
  if (vmw_priv___0->num_displays == 0U) {
#line 1651
    vmw_priv___0->num_displays = 1U;
  } else {

  }
#line 1653
  i = 0U;
#line 1653
  goto ldv_39922;
  ldv_39921: 
#line 1654
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1655
  vmw_write(vmw_priv___0, 35U, i);
#line 1656
  save->primary = vmw_read(vmw_priv___0, 36U);
#line 1657
  save->pos_x = vmw_read(vmw_priv___0, 37U);
#line 1658
  save->pos_y = vmw_read(vmw_priv___0, 38U);
#line 1659
  save->width = vmw_read(vmw_priv___0, 39U);
#line 1660
  save->height = vmw_read(vmw_priv___0, 40U);
#line 1661
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1662
  if (((i == 0U && vmw_priv___0->num_displays == 1U) && save->width == 0U) && save->height == 0U) {
#line 1670
    save->width = vmw_priv___0->vga_width - save->pos_x;
#line 1671
    save->height = vmw_priv___0->vga_height - save->pos_y;
  } else {

  }
#line 1653
  i = i + (uint32_t )1;
  ldv_39922: ;
#line 1653
  if (vmw_priv___0->num_displays > i) {
#line 1654
    goto ldv_39921;
  } else {

  }

#line 1675
  return (0);
}
}
#line 1678 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) 
{ 
  struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1683
  vmw_write(vmw_priv___0, 2U, vmw_priv___0->vga_width);
#line 1684
  vmw_write(vmw_priv___0, 3U, vmw_priv___0->vga_height);
#line 1685
  vmw_write(vmw_priv___0, 7U, vmw_priv___0->vga_bpp);
#line 1686
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1687
    vmw_write(vmw_priv___0, 32U, vmw_priv___0->vga_pitchlock);
  } else {
#line 1689
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1689
    if ((int )tmp) {
#line 1690
      iowrite32(vmw_priv___0->vga_pitchlock, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1693
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1694
    return (0);
  } else {

  }
#line 1696
  i = 0U;
#line 1696
  goto ldv_39930;
  ldv_39929: 
#line 1697
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1698
  vmw_write(vmw_priv___0, 35U, i);
#line 1699
  vmw_write(vmw_priv___0, 36U, save->primary);
#line 1700
  vmw_write(vmw_priv___0, 37U, save->pos_x);
#line 1701
  vmw_write(vmw_priv___0, 38U, save->pos_y);
#line 1702
  vmw_write(vmw_priv___0, 39U, save->width);
#line 1703
  vmw_write(vmw_priv___0, 40U, save->height);
#line 1704
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1696
  i = i + (uint32_t )1;
  ldv_39930: ;
#line 1696
  if (vmw_priv___0->num_displays > i) {
#line 1697
    goto ldv_39929;
  } else {

  }

#line 1707
  return (0);
}
}
#line 1710 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) 
{ 


  {
#line 1714
  return ((unsigned long long )pitch * (unsigned long long )height < (unsigned long long )dev_priv->vram_size);
}
}
#line 1721 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1723
  return (0U);
}
}
#line 1729 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_enable_vblank(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1731
  return (-38);
}
}
#line 1737 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_disable_vblank(struct drm_device *dev , int crtc ) 
{ 


  {
#line 1739
  return;
}
}
#line 1746 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_update_layout(struct vmw_private *dev_priv , unsigned int num , struct drm_vmw_rect *rects ) 
{ 
  struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_connector *con ;
  struct list_head  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1749
  dev = dev_priv->dev;
#line 1753
  ldv_mutex_lock_90(& dev->mode_config.mutex);
#line 1767
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 1767
  con = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
#line 1767
  goto ldv_39964;
  ldv_39963: 
#line 1768
  __mptr___0 = (struct drm_connector  const  *)con;
#line 1768
  du = (struct vmw_display_unit *)__mptr___0 + 0xfffffffffffffc50UL;
#line 1769
  if (du->unit < num) {
#line 1770
    du->pref_width = (rects + (unsigned long )du->unit)->w;
#line 1771
    du->pref_height = (rects + (unsigned long )du->unit)->h;
#line 1772
    du->pref_active = 1;
#line 1773
    du->gui_x = (rects + (unsigned long )du->unit)->x;
#line 1774
    du->gui_y = (rects + (unsigned long )du->unit)->y;
  } else {
#line 1776
    du->pref_width = 800U;
#line 1777
    du->pref_height = 600U;
#line 1778
    du->pref_active = 0;
  }
#line 1780
  con->status = vmw_du_connector_detect(con, 1);
#line 1767
  __mptr___1 = (struct list_head  const  *)con->head.next;
#line 1767
  con = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_39964: ;
#line 1767
  if ((unsigned long )(& con->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 1768
    goto ldv_39963;
  } else {

  }
#line 1783
  ldv_mutex_unlock_91(& dev->mode_config.mutex);
#line 1785
  return (0);
}
}
#line 1788 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_framebuffer *old_fb ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_file *file_priv ;
  struct vmw_fence_obj *fence ;
  struct drm_clip_rect clips ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  struct drm_crtc  const  *__mptr___0 ;

  {
#line 1792
  tmp = vmw_priv(crtc->dev);
#line 1792
  dev_priv = tmp;
#line 1793
  old_fb = crtc->fb;
#line 1794
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 1794
  vfb = (struct vmw_framebuffer *)__mptr;
#line 1795
  file_priv = event->base.file_priv;
#line 1796
  fence = 0;
#line 1801
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1802
    return (-38);
  } else {

  }
#line 1804
  tmp___0 = vmw_kms_screen_object_flippable(dev_priv, crtc);
#line 1804
  if (tmp___0) {
#line 1804
    tmp___1 = 0;
  } else {
#line 1804
    tmp___1 = 1;
  }
#line 1804
  if (tmp___1) {
#line 1805
    return (-22);
  } else {

  }
#line 1807
  crtc->fb = fb;
#line 1810
  clips.y1 = 0U;
#line 1810
  clips.x1 = clips.y1;
#line 1811
  clips.x2 = (unsigned short )fb->width;
#line 1812
  clips.y2 = (unsigned short )fb->height;
#line 1814
  if ((int )vfb->dmabuf) {
#line 1815
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  } else {
#line 1818
    ret = do_surface_dirty_sou(dev_priv, file_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  }
#line 1822
  if (ret != 0) {
#line 1823
    goto out_no_fence;
  } else {

  }
#line 1824
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1825
    ret = -22;
#line 1826
    goto out_no_fence;
  } else {

  }
#line 1829
  ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                     & event->event.tv_usec, 1);
#line 1839
  vmw_fence_obj_unreference(& fence);
#line 1841
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1841
  if ((int )((struct vmw_display_unit *)__mptr___0)->is_implicit) {
#line 1842
    vmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);
  } else {

  }
#line 1844
  return (ret);
  out_no_fence: 
#line 1847
  crtc->fb = old_fb;
#line 1848
  return (ret);
}
}
#line 1852 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_save(struct drm_crtc *crtc ) 
{ 


  {
#line 1854
  return;
}
}
#line 1856 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_restore(struct drm_crtc *crtc ) 
{ 


  {
#line 1858
  return;
}
}
#line 1860 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  int i ;

  {
#line 1864
  tmp = vmw_priv(crtc->dev);
#line 1864
  dev_priv = tmp;
#line 1867
  i = 0;
#line 1867
  goto ldv_40001;
  ldv_40000: 
#line 1868
  drm_ut_debug_printk(1U, "drm", "vmw_du_crtc_gamma_set", "%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n",
                      i, (int )*(r + (unsigned long )i), (int )*(g + (unsigned long )i),
                      (int )*(b + (unsigned long )i));
#line 1870
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1024), (uint32_t )((int )*(r + (unsigned long )i) >> 8));
#line 1871
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1025), (uint32_t )((int )*(g + (unsigned long )i) >> 8));
#line 1872
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1026), (uint32_t )((int )*(b + (unsigned long )i) >> 8));
#line 1867
  i = i + 1;
  ldv_40001: ;
#line 1867
  if ((uint32_t )i < size) {
#line 1868
    goto ldv_40000;
  } else {

  }

#line 1872
  return;
}
}
#line 1876 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) 
{ 


  {
#line 1878
  return;
}
}
#line 1880 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_save(struct drm_connector *connector ) 
{ 


  {
#line 1882
  return;
}
}
#line 1884 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_restore(struct drm_connector *connector ) 
{ 


  {
#line 1886
  return;
}
}
#line 1889 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) 
{ 
  uint32_t num_displays ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;

  {
#line 1892
  dev = connector->dev;
#line 1893
  tmp = vmw_priv(dev);
#line 1893
  dev_priv = tmp;
#line 1894
  __mptr = (struct drm_connector  const  *)connector;
#line 1894
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc50UL;
#line 1896
  ldv_mutex_lock_92(& dev_priv->hw_mutex);
#line 1897
  num_displays = vmw_read(dev_priv, 31U);
#line 1898
  ldv_mutex_unlock_93(& dev_priv->hw_mutex);
#line 1900
  __mptr___0 = (struct drm_connector  const  *)connector;
#line 1900
  return (((struct vmw_display_unit *)__mptr___0 + 0xfffffffffffffc50UL)->unit < num_displays && (int )du->pref_active ? connector_status_connected : connector_status_disconnected);
}
}
#line 1905 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_display_mode vmw_kms_connector_builtin[19U]  = 
#line 1905
  {      {{0, 0}, {0U, 0U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0, 64U, 25175,
      640, 656, 752, 800, 0, 480, 489, 492, 525, 0, 10U, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0, 64U, 40000,
      800, 840, 968, 1056, 0, 600, 601, 605, 628, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'}, 0, 64U,
      65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, 10U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '1', '5', '2', 'x', '8', '6', '4', '\000'}, 0, 64U,
      108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '2', '8', '0', 'x', '7', '6', '8', '\000'}, 0, 64U,
      79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798, 0, 6U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '2', '8', '0', 'x', '8', '0', '0', '\000'}, 0, 64U,
      83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831, 0, 9U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '2', '8', '0', 'x', '9', '6', '0', '\000'}, 0, 64U,
      108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4', '\000'},
      0, 64U, 108000, 1280, 1328, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, 5U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '3', '6', '0', 'x', '7', '6', '8', '\000'}, 0, 64U,
      85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '4', '0', '0', 'x', '1', '0', '5', '0', '\000'},
      0, 64U, 121750, 1400, 1488, 1632, 1864, 0, 1050, 1053, 1057, 1089, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '4', '4', '0', 'x', '9', '0', '0', '\000'}, 0, 64U,
      106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934, 0, 6U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '6', '0', '0', 'x', '1', '2', '0', '0', '\000'},
      0, 64U, 162000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, 5U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '6', '8', '0', 'x', '1', '0', '5', '0', '\000'},
      0, 64U, 146250, 1680, 1784, 1960, 2240, 0, 1050, 1053, 1059, 1089, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '7', '9', '2', 'x', '1', '3', '4', '4', '\000'},
      0, 64U, 204750, 1792, 1920, 2120, 2448, 0, 1344, 1345, 1348, 1394, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '8', '5', '6', 'x', '1', '3', '9', '2', '\000'},
      0, 64U, 218250, 1856, 1952, 2176, 2528, 0, 1392, 1393, 1396, 1439, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '9', '2', '0', 'x', '1', '2', '0', '0', '\000'},
      0, 64U, 193250, 1920, 2056, 2256, 2592, 0, 1200, 1203, 1209, 1245, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'1', '9', '2', '0', 'x', '1', '4', '4', '0', '\000'},
      0, 64U, 234000, 1920, 2048, 2256, 2600, 0, 1440, 1441, 1444, 1500, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'2', '5', '6', '0', 'x', '1', '6', '0', '0', '\000'},
      0, 64U, 348500, 2560, 2752, 3032, 3504, 0, 1600, 1603, 1609, 1658, 0, 6U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 0U, 0}, {'\000'}, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
#line 1989 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static void vmw_guess_mode_timing(struct drm_display_mode *mode ) 
{ 


  {
#line 1991
  mode->hsync_start = mode->hdisplay + 50;
#line 1992
  mode->hsync_end = mode->hsync_start + 50;
#line 1993
  mode->htotal = mode->hsync_end + 50;
#line 1995
  mode->vsync_start = mode->vdisplay + 50;
#line 1996
  mode->vsync_end = mode->vsync_start + 50;
#line 1997
  mode->vtotal = mode->vsync_end + 50;
#line 1999
  mode->clock = (int )((((unsigned int )mode->htotal * (unsigned int )mode->vtotal) / 100U) * 6U);
#line 2000
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2001
  return;
}
}
#line 2004 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) 
{ 
  struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *bmode ;
  struct drm_display_mode prefmode ;
  unsigned int tmp___0 ;
  int i ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2007
  __mptr = (struct drm_connector  const  *)connector;
#line 2007
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc50UL;
#line 2008
  dev = connector->dev;
#line 2009
  tmp = vmw_priv(dev);
#line 2009
  dev_priv = tmp;
#line 2010
  mode = 0;
#line 2012
  prefmode.head.next = 0;
#line 2012
  prefmode.head.prev = 0;
#line 2012
  prefmode.base.id = 0U;
#line 2012
  prefmode.base.type = 0U;
#line 2012
  prefmode.base.properties = 0;
#line 2012
  prefmode.name[0] = 'p';
#line 2012
  prefmode.name[1] = 'r';
#line 2012
  prefmode.name[2] = 'e';
#line 2012
  prefmode.name[3] = 'f';
#line 2012
  prefmode.name[4] = 'e';
#line 2012
  prefmode.name[5] = 'r';
#line 2012
  prefmode.name[6] = 'r';
#line 2012
  prefmode.name[7] = 'e';
#line 2012
  prefmode.name[8] = 'd';
#line 2012
  prefmode.name[9] = '\000';
#line 2012
  tmp___0 = 10U;
#line 2012
  while (1) {
#line 2012
    if (tmp___0 >= 32U) {
#line 2012
      break;
    } else {

    }
#line 2012
    prefmode.name[tmp___0] = (char)0;
#line 2012
    tmp___0 = tmp___0 + 1U;
  }
#line 2012
  prefmode.status = 0;
#line 2012
  prefmode.type = 72U;
#line 2012
  prefmode.clock = 0;
#line 2012
  prefmode.hdisplay = 0;
#line 2012
  prefmode.hsync_start = 0;
#line 2012
  prefmode.hsync_end = 0;
#line 2012
  prefmode.htotal = 0;
#line 2012
  prefmode.hskew = 0;
#line 2012
  prefmode.vdisplay = 0;
#line 2012
  prefmode.vsync_start = 0;
#line 2012
  prefmode.vsync_end = 0;
#line 2012
  prefmode.vtotal = 0;
#line 2012
  prefmode.vscan = 0;
#line 2012
  prefmode.flags = 6U;
#line 2012
  prefmode.width_mm = 0;
#line 2012
  prefmode.height_mm = 0;
#line 2012
  prefmode.clock_index = 0;
#line 2012
  prefmode.synth_clock = 0;
#line 2012
  prefmode.crtc_hdisplay = 0;
#line 2012
  prefmode.crtc_hblank_start = 0;
#line 2012
  prefmode.crtc_hblank_end = 0;
#line 2012
  prefmode.crtc_hsync_start = 0;
#line 2012
  prefmode.crtc_hsync_end = 0;
#line 2012
  prefmode.crtc_htotal = 0;
#line 2012
  prefmode.crtc_hskew = 0;
#line 2012
  prefmode.crtc_vdisplay = 0;
#line 2012
  prefmode.crtc_vblank_start = 0;
#line 2012
  prefmode.crtc_vblank_end = 0;
#line 2012
  prefmode.crtc_vsync_start = 0;
#line 2012
  prefmode.crtc_vsync_end = 0;
#line 2012
  prefmode.crtc_vtotal = 0;
#line 2012
  prefmode.crtc_hadjusted = 0;
#line 2012
  prefmode.crtc_vadjusted = 0;
#line 2012
  prefmode.private_size = 0;
#line 2012
  prefmode.private = 0;
#line 2012
  prefmode.private_flags = 0;
#line 2012
  prefmode.vrefresh = 0;
#line 2012
  prefmode.hsync = 0;
#line 2021
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)(& prefmode));
#line 2022
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2023
    return (0);
  } else {

  }
#line 2024
  mode->hdisplay = (int )du->pref_width;
#line 2025
  mode->vdisplay = (int )du->pref_height;
#line 2026
  vmw_guess_mode_timing(mode);
#line 2028
  tmp___1 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(mode->hdisplay * 2),
                                       (uint32_t )mode->vdisplay);
#line 2028
  if ((int )tmp___1) {
#line 2030
    drm_mode_probed_add(connector, mode);
  } else {
#line 2032
    drm_mode_destroy(dev, mode);
#line 2033
    mode = 0;
  }
#line 2036
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2037
    list_del_init(& (du->pref_mode)->head);
#line 2038
    drm_mode_destroy(dev, du->pref_mode);
  } else {

  }
#line 2042
  du->pref_mode = mode;
#line 2045
  i = 0;
#line 2045
  goto ldv_40045;
  ldv_40044: 
#line 2046
  bmode = (struct drm_display_mode *)(& vmw_kms_connector_builtin) + (unsigned long )i;
#line 2047
  if ((uint32_t )bmode->hdisplay > max_width || (uint32_t )bmode->vdisplay > max_height) {
#line 2049
    goto ldv_40043;
  } else {

  }
#line 2051
  tmp___2 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(bmode->hdisplay * 2),
                                       (uint32_t )bmode->vdisplay);
#line 2051
  if (tmp___2) {
#line 2051
    tmp___3 = 0;
  } else {
#line 2051
    tmp___3 = 1;
  }
#line 2051
  if (tmp___3) {
#line 2053
    goto ldv_40043;
  } else {

  }
#line 2055
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)bmode);
#line 2056
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2057
    return (0);
  } else {

  }
#line 2058
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2060
  drm_mode_probed_add(connector, mode);
  ldv_40043: 
#line 2045
  i = i + 1;
  ldv_40045: ;
#line 2045
  if (vmw_kms_connector_builtin[i].type != 0U) {
#line 2046
    goto ldv_40044;
  } else {

  }

#line 2064
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2065
    list_move(& (du->pref_mode)->head, & connector->probed_modes);
  } else {

  }
#line 2067
  drm_mode_connector_list_update(connector);
#line 2069
  return (1);
}
}
#line 2072 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) 
{ 


  {
#line 2076
  return (0);
}
}
#line 2080 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_update_layout_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  void *user_rects ;
  struct drm_vmw_rect *rects ;
  unsigned int rects_size ;
  int ret ;
  int i ;
  struct drm_mode_config *mode_config ;
  long tmp___1 ;
  struct drm_vmw_rect def_rect ;
  void *tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;

  {
#line 2083
  tmp = vmw_priv(dev);
#line 2083
  dev_priv = tmp;
#line 2084
  arg = (struct drm_vmw_update_layout_arg *)data;
#line 2086
  tmp___0 = vmw_master(file_priv->master);
#line 2086
  vmaster = tmp___0;
#line 2092
  mode_config = & dev->mode_config;
#line 2094
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 2095
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 2095
  if (tmp___1 != 0L) {
#line 2096
    return (ret);
  } else {

  }
#line 2098
  if (arg->num_outputs == 0U) {
#line 2099
    def_rect.x = 0;
#line 2099
    def_rect.y = 0;
#line 2099
    def_rect.w = 800U;
#line 2099
    def_rect.h = 600U;
#line 2100
    vmw_du_update_layout(dev_priv, 1U, & def_rect);
#line 2101
    goto out_unlock;
  } else {

  }
#line 2104
  rects_size = arg->num_outputs * 16U;
#line 2105
  tmp___2 = kcalloc((size_t )arg->num_outputs, 16UL, 208U);
#line 2105
  rects = (struct drm_vmw_rect *)tmp___2;
#line 2107
  tmp___3 = ldv__builtin_expect((unsigned long )rects == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 2107
  if (tmp___3 != 0L) {
#line 2108
    ret = -12;
#line 2109
    goto out_unlock;
  } else {

  }
#line 2112
  user_rects = (void *)arg->rects;
#line 2113
  tmp___4 = copy_from_user((void *)rects, (void const   *)user_rects, (unsigned long )rects_size);
#line 2113
  ret = (int )tmp___4;
#line 2114
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 2114
  if (tmp___5 != 0L) {
#line 2115
    drm_err("vmw_kms_update_layout_ioctl", "Failed to get rects.\n");
#line 2116
    ret = -14;
#line 2117
    goto out_free;
  } else {

  }
#line 2120
  i = 0;
#line 2120
  goto ldv_40071;
  ldv_40070: ;
#line 2121
  if ((((rects + (unsigned long )i)->x < 0 || (rects + (unsigned long )i)->y < 0) || (uint32_t )(rects + (unsigned long )i)->x + (rects + (unsigned long )i)->w > (uint32_t )mode_config->max_width) || (uint32_t )(rects + (unsigned long )i)->y + (rects + (unsigned long )i)->h > (uint32_t )mode_config->max_height) {
#line 2125
    drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2126
    ret = -22;
#line 2127
    goto out_free;
  } else {

  }
#line 2120
  i = i + 1;
  ldv_40071: ;
#line 2120
  if ((uint32_t )i < arg->num_outputs) {
#line 2121
    goto ldv_40070;
  } else {

  }
#line 2131
  vmw_du_update_layout(dev_priv, arg->num_outputs, rects);
  out_free: 
#line 2134
  kfree((void const   *)rects);
  out_unlock: 
#line 2136
  ttm_read_unlock(& vmaster->lock);
#line 2137
  return (ret);
}
}
#line 2156
void ldv_check_final_state(void) ;
#line 2165
void ldv_initialize(void) ;
#line 2168
extern void ldv_handler_precall(void) ;
#line 2171
extern int __VERIFIER_nondet_int(void) ;
#line 2174 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 2177 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_main2_sequence_infinite_withcheck_stateful(void) 
{ 
  struct drm_framebuffer *var_group1 ;
  struct drm_file *var_group2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_surface_dirty_12_p4 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p5 ;
  unsigned int *var_vmw_framebuffer_create_handle_9_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_dmabuf_dirty_18_p4 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p5 ;
  struct drm_device *var_group3 ;
  struct drm_mode_fb_cmd2 *var_vmw_kms_fb_create_22_p2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2305
  LDV_IN_INTERRUPT = 1;
#line 2314
  ldv_initialize();
#line 2322
  goto ldv_40112;
  ldv_40111: 
#line 2325
  tmp = __VERIFIER_nondet_int();
#line 2325
  switch (tmp) {
  case 0: 
#line 2339
  ldv_handler_precall();
#line 2340
  vmw_framebuffer_surface_destroy(var_group1);
#line 2353
  goto ldv_40103;
  case 1: 
#line 2366
  ldv_handler_precall();
#line 2367
  vmw_framebuffer_surface_dirty(var_group1, var_group2, var_vmw_framebuffer_surface_dirty_12_p2,
                                var_vmw_framebuffer_surface_dirty_12_p3, var_vmw_framebuffer_surface_dirty_12_p4,
                                var_vmw_framebuffer_surface_dirty_12_p5);
#line 2380
  goto ldv_40103;
  case 2: 
#line 2391
  ldv_handler_precall();
#line 2392
  vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
#line 2407
  goto ldv_40103;
  case 3: 
#line 2422
  ldv_handler_precall();
#line 2423
  vmw_framebuffer_dmabuf_destroy(var_group1);
#line 2434
  goto ldv_40103;
  case 4: 
#line 2449
  ldv_handler_precall();
#line 2450
  vmw_framebuffer_dmabuf_dirty(var_group1, var_group2, var_vmw_framebuffer_dmabuf_dirty_18_p2,
                               var_vmw_framebuffer_dmabuf_dirty_18_p3, var_vmw_framebuffer_dmabuf_dirty_18_p4,
                               var_vmw_framebuffer_dmabuf_dirty_18_p5);
#line 2461
  goto ldv_40103;
  case 5: 
#line 2472
  ldv_handler_precall();
#line 2473
  vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
#line 2488
  goto ldv_40103;
  case 6: 
#line 2503
  ldv_handler_precall();
#line 2504
  vmw_kms_fb_create(var_group3, var_group2, var_vmw_kms_fb_create_22_p2);
#line 2515
  goto ldv_40103;
  default: ;
#line 2516
  goto ldv_40103;
  }
  ldv_40103: ;
  ldv_40112: 
#line 2322
  tmp___0 = __VERIFIER_nondet_int();
#line 2322
  if (tmp___0 != 0) {
#line 2323
    goto ldv_40111;
  } else {

  }


#line 2525
  ldv_check_final_state();
#line 2528
  return;
}
}
#line 2532 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_69(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2537
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2539
  mutex_lock(ldv_func_arg1);
#line 2540
  return;
}
}
#line 2542 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int ldv_mutex_trylock_70(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2547
  tmp = mutex_trylock(ldv_func_arg1);
#line 2547
  ldv_func_res = tmp;
#line 2549
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 2549
  return (tmp___0);
#line 2551
  return (ldv_func_res);
}
}
#line 2554 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_71(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2559
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2561
  mutex_unlock(ldv_func_arg1);
#line 2562
  return;
}
}
#line 2564 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_72(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2569
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2571
  mutex_lock(ldv_func_arg1);
#line 2572
  return;
}
}
#line 2574 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2579
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2581
  mutex_unlock(ldv_func_arg1);
#line 2582
  return;
}
}
#line 2584 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_74(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2589
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 2591
  mutex_lock(ldv_func_arg1);
#line 2592
  return;
}
}
#line 2594 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2599
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 2601
  mutex_unlock(ldv_func_arg1);
#line 2602
  return;
}
}
#line 2604 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2609
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2611
  mutex_unlock(ldv_func_arg1);
#line 2612
  return;
}
}
#line 2614 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2619
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 2621
  mutex_lock(ldv_func_arg1);
#line 2622
  return;
}
}
#line 2624 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2629
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 2631
  mutex_unlock(ldv_func_arg1);
#line 2632
  return;
}
}
#line 2634 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2639
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2641
  mutex_lock(ldv_func_arg1);
#line 2642
  return;
}
}
#line 2644 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2649
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2651
  mutex_unlock(ldv_func_arg1);
#line 2652
  return;
}
}
#line 2654 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_81(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2659
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2661
  mutex_lock(ldv_func_arg1);
#line 2662
  return;
}
}
#line 2664 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2669
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2671
  mutex_unlock(ldv_func_arg1);
#line 2672
  return;
}
}
#line 2674 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2679
  ldv_mutex_lock_fb_surf_mutex(ldv_func_arg1);
#line 2681
  mutex_lock(ldv_func_arg1);
#line 2682
  return;
}
}
#line 2684 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2689
  ldv_mutex_unlock_fb_surf_mutex(ldv_func_arg1);
#line 2691
  mutex_unlock(ldv_func_arg1);
#line 2692
  return;
}
}
#line 2694 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2699
  ldv_mutex_lock_fb_surf_mutex(ldv_func_arg1);
#line 2701
  mutex_lock(ldv_func_arg1);
#line 2702
  return;
}
}
#line 2704 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2709
  ldv_mutex_unlock_fb_surf_mutex(ldv_func_arg1);
#line 2711
  mutex_unlock(ldv_func_arg1);
#line 2712
  return;
}
}
#line 2714 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2719
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2721
  mutex_lock(ldv_func_arg1);
#line 2722
  return;
}
}
#line 2724 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2729
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2731
  mutex_unlock(ldv_func_arg1);
#line 2732
  return;
}
}
#line 2734 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2739
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2741
  mutex_unlock(ldv_func_arg1);
#line 2742
  return;
}
}
#line 2744 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2749
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2751
  mutex_lock(ldv_func_arg1);
#line 2752
  return;
}
}
#line 2754 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2759
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2761
  mutex_unlock(ldv_func_arg1);
#line 2762
  return;
}
}
#line 2764 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2769
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 2771
  mutex_lock(ldv_func_arg1);
#line 2772
  return;
}
}
#line 2774 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2779
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 2781
  mutex_unlock(ldv_func_arg1);
#line 2782
  return;
}
}
#line 35 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 171
int ldv_mutex_trylock_120(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_124(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_132(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) ;
#line 135
void ldv_mutex_lock_release_mutex(struct mutex *lock ) ;
#line 139
void ldv_mutex_unlock_release_mutex(struct mutex *lock ) ;
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 285
  _raw_spin_lock(& lock->ldv_5988.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 325
  _raw_spin_unlock(& lock->ldv_5988.rlock);
#line 326
  return;
}
}
#line 79 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 187 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/io.h"
extern void iounmap(void volatile   * ) ;
#line 317
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 2437 "include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 802 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 780 "include/linux/pci.h"
extern int pci_enable_device(struct pci_dev * ) ;
#line 797
extern void pci_disable_device(struct pci_dev * ) ;
#line 800
extern void pci_set_master(struct pci_dev * ) ;
#line 839
extern int pci_save_state(struct pci_dev * ) ;
#line 840
extern void pci_restore_state(struct pci_dev * ) ;
#line 846
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 911
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 913
extern void pci_release_regions(struct pci_dev * ) ;
#line 914
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
#line 916
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 1365 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1367
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1367
  return (tmp);
}
}
#line 123 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/mtrr.h"
extern int mtrr_add(unsigned long  , unsigned long  , unsigned int  , bool  ) ;
#line 127
extern int mtrr_del(int  , unsigned long  , unsigned long  ) ;
#line 114 "include/linux/idr.h"
extern void idr_destroy(struct idr * ) ;
#line 115
extern void idr_init(struct idr * ) ;
#line 1246 "include/drm/drmP.h"
__inline static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags ) 
{ 
  int tmp ;

  {
#line 1249
  tmp = mtrr_add(offset, size, flags, 1);
#line 1249
  return (tmp);
}
}
#line 1252 "include/drm/drmP.h"
__inline static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags ) 
{ 
  int tmp ;

  {
#line 1255
  tmp = mtrr_del(handle, offset, size);
#line 1255
  return (tmp);
}
}
#line 1294
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1296
extern long drm_compat_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1302
extern int drm_open(struct inode * , struct file * ) ;
#line 1304
extern int drm_fasync(int  , struct file * , int  ) ;
#line 1307
extern int drm_release(struct inode * , struct file * ) ;
#line 1433
extern int drm_irq_install(struct drm_device * ) ;
#line 1434
extern int drm_irq_uninstall(struct drm_device * ) ;
#line 1508
extern void drm_put_dev(struct drm_device * ) ;
#line 1758
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
#line 1759
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
#line 1760
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
#line 346 "include/linux/suspend.h"
extern int register_pm_notifier(struct notifier_block * ) ;
#line 347
extern int unregister_pm_notifier(struct notifier_block * ) ;
#line 337 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_wait(struct ttm_buffer_object * , bool  , bool  , bool  ) ;
#line 543
extern int ttm_bo_create(struct ttm_bo_device * , unsigned long  , enum ttm_bo_type  ,
                         struct ttm_placement * , uint32_t  , unsigned long  , bool  ,
                         struct file * , struct ttm_buffer_object ** ) ;
#line 583
extern int ttm_bo_init_mm(struct ttm_bo_device * , unsigned int  , unsigned long  ) ;
#line 612
extern int ttm_bo_clean_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 633
extern int ttm_bo_evict_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 737
extern void ttm_bo_swapout_all(struct ttm_bo_device * ) ;
#line 752 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_device_release(struct ttm_bo_device * ) ;
#line 768
extern int ttm_bo_device_init(struct ttm_bo_device * , struct ttm_bo_global * , struct ttm_bo_driver * ,
                              uint64_t  , bool  ) ;
#line 229 "include/drm/ttm/ttm_object.h"
extern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device * , unsigned int  ) ;
#line 244
extern void ttm_object_file_release(struct ttm_object_file ** ) ;
#line 255
extern struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global * ,
                                                        unsigned int  ) ;
#line 269
extern void ttm_object_device_release(struct ttm_object_device ** ) ;
#line 87 "include/drm/ttm/ttm_lock.h"
extern void ttm_lock_init(struct ttm_lock * ) ;
#line 164
extern void ttm_suspend_lock(struct ttm_lock * ) ;
#line 173
extern void ttm_suspend_unlock(struct ttm_lock * ) ;
#line 187
extern int ttm_vt_lock(struct ttm_lock * , bool  , struct ttm_object_file * ) ;
#line 199
extern int ttm_vt_unlock(struct ttm_lock * ) ;
#line 239 "include/drm/ttm/ttm_lock.h"
__inline static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal ) 
{ 


  {
#line 242
  lock->kill_takers = val;
#line 243
  if ((int )val) {
#line 244
    lock->signal = signal;
  } else {

  }
#line 245
  return;
}
}
#line 66 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) ;
#line 68
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) ;
#line 98
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) ;
#line 100
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) ;
#line 102
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 105
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 108
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 110
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 112
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) ;
#line 368 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) ;
#line 369
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) ;
#line 388
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 390
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 409
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 411
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 413
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 426
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 428
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 435
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 437
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 472
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 474
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 476
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 478
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 480
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) ;
#line 482
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
#line 489
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 491
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 498
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) ;
#line 507
int vmw_ttm_global_init(struct vmw_private *dev_priv ) ;
#line 508
void vmw_ttm_global_release(struct vmw_private *dev_priv ) ;
#line 509
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) ;
#line 517
struct ttm_placement vmw_vram_sys_placement ;
#line 523
struct ttm_bo_driver vmw_bo_driver ;
#line 562
irqreturn_t vmw_irq_handler(int irq , void *arg ) ;
#line 566
void vmw_irq_preinstall(struct drm_device *dev ) ;
#line 567
int vmw_irq_postinstall(struct drm_device *dev ) ;
#line 568
void vmw_irq_uninstall(struct drm_device *dev ) ;
#line 602
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) ;
#line 603
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) ;
#line 605
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) ;
#line 652
int vmw_overlay_init(struct vmw_private *dev_priv ) ;
#line 653
int vmw_overlay_close(struct vmw_private *dev_priv ) ;
#line 654
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 231 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_ioctl_desc vmw_ioctls[21U]  = 
#line 231 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
  {      {0U, 17, & vmw_getparam_ioctl, 3222299712U}, 
        {1U, 17, & vmw_dmabuf_alloc_ioctl, 3222824001U}, 
        {2U, 17, & vmw_dmabuf_unref_ioctl, 1074291778U}, 
        {3U, 26, & vmw_kms_cursor_bypass_ioctl, 1075340355U}, 
        {4U, 26, & vmw_overlay_ioctl, 1079534660U}, 
        {5U, 26, & vmw_stream_claim_ioctl, 2148033605U}, 
        {6U, 26, & vmw_stream_unref_ioctl, 1074291782U}, 
        {7U, 17, & vmw_context_define_ioctl, 2148033607U}, 
        {8U, 17, & vmw_context_destroy_ioctl, 1074291784U}, 
        {9U, 17, & vmw_surface_define_ioctl, 3224396873U}, 
        {10U, 17, & vmw_surface_destroy_ioctl, 1074291786U}, 
        {11U, 17, & vmw_surface_reference_ioctl, 3224396875U}, 
        {12U, 17, & vmw_execbuf_ioctl, 1075864652U}, 
        {13U, 17, & vmw_get_cap_3d_ioctl, 1074816077U}, 
        {14U, 17, & vmw_fence_obj_wait_ioctl, 3223872590U}, 
        {15U, 17, & vmw_fence_obj_signaled_ioctl, 3222824015U}, 
        {16U, 17, & vmw_fence_obj_unref_ioctl, 1074291792U}, 
        {17U, 17, & vmw_fence_event_ioctl, 1075340369U}, 
        {18U, 19, & vmw_present_ioctl, 1075864658U}, 
        {19U, 19, & vmw_present_readback_ioctl, 1075340371U}, 
        {20U, 18, & vmw_kms_update_layout_ioctl, 1074816084U}};
#line 285 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_device_id vmw_pci_id_list[2U]  = {      {5549U, 1029U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 290 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int enable_fbdev  ;
#line 292
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
#line 293
static void vmw_master_init(struct vmw_master *vmaster ) ;
#line 294
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) ;
#line 300 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_print_capabilities(uint32_t capabilities ) 
{ 


  {
#line 302
  printk("<6>[drm] Capabilities:\n");
#line 303
  if ((capabilities & 2U) != 0U) {
#line 304
    printk("<6>[drm]   Rect copy.\n");
  } else {

  }
#line 305
  if ((capabilities & 32U) != 0U) {
#line 306
    printk("<6>[drm]   Cursor.\n");
  } else {

  }
#line 307
  if ((capabilities & 64U) != 0U) {
#line 308
    printk("<6>[drm]   Cursor bypass.\n");
  } else {

  }
#line 309
  if ((capabilities & 128U) != 0U) {
#line 310
    printk("<6>[drm]   Cursor bypass 2.\n");
  } else {

  }
#line 311
  if ((capabilities & 256U) != 0U) {
#line 312
    printk("<6>[drm]   8bit emulation.\n");
  } else {

  }
#line 313
  if ((capabilities & 512U) != 0U) {
#line 314
    printk("<6>[drm]   Alpha cursor.\n");
  } else {

  }
#line 315
  if ((capabilities & 16384U) != 0U) {
#line 316
    printk("<6>[drm]   3D.\n");
  } else {

  }
#line 317
  if ((capabilities & 32768U) != 0U) {
#line 318
    printk("<6>[drm]   Extended Fifo.\n");
  } else {

  }
#line 319
  if ((capabilities & 65536U) != 0U) {
#line 320
    printk("<6>[drm]   Multimon.\n");
  } else {

  }
#line 321
  if ((capabilities & 131072U) != 0U) {
#line 322
    printk("<6>[drm]   Pitchlock.\n");
  } else {

  }
#line 323
  if ((capabilities & 262144U) != 0U) {
#line 324
    printk("<6>[drm]   Irq mask.\n");
  } else {

  }
#line 325
  if ((capabilities & 524288U) != 0U) {
#line 326
    printk("<6>[drm]   Display Topology.\n");
  } else {

  }
#line 327
  if ((capabilities & 1048576U) != 0U) {
#line 328
    printk("<6>[drm]   GMR.\n");
  } else {

  }
#line 329
  if ((capabilities & 2097152U) != 0U) {
#line 330
    printk("<6>[drm]   Traces.\n");
  } else {

  }
#line 331
  if ((capabilities & 4194304U) != 0U) {
#line 332
    printk("<6>[drm]   GMR2.\n");
  } else {

  }
#line 333
  if ((capabilities & 8388608U) != 0U) {
#line 334
    printk("<6>[drm]   Screen Object 2.\n");
  } else {

  }
#line 335
  return;
}
}
#line 351 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_dummy_query_bo_prepare(struct vmw_private *dev_priv ) 
{ 
  struct ttm_bo_kmap_obj map ;
  SVGA3dQueryResult volatile   *result ;
  bool dummy ;
  int ret ;
  struct ttm_bo_device *bdev ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 357
  bdev = & dev_priv->bdev;
#line 358
  bo = dev_priv->dummy_query_bo;
#line 360
  ttm_bo_reserve(bo, 0, 0, 0, 0U);
#line 361
  spin_lock(& bdev->fence_lock);
#line 362
  ret = ttm_bo_wait(bo, 0, 0, 0);
#line 363
  spin_unlock(& bdev->fence_lock);
#line 364
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 364
  if (tmp != 0L) {
#line 365
    vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
  } else {

  }
#line 368
  ret = ttm_bo_kmap(bo, 0UL, 1UL, & map);
#line 369
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 369
  if (tmp___1 != 0L) {
#line 370
    tmp___0 = ttm_kmap_obj_virtual(& map, & dummy);
#line 370
    result = (SVGA3dQueryResult volatile   *)tmp___0;
#line 371
    result->totalSize = 12U;
#line 372
    result->state = SVGA3D_QUERYSTATE_PENDING;
#line 373
    result->ldv_37270.result32 = 255U;
#line 374
    ttm_bo_kunmap(& map);
  } else {
#line 376
    drm_err("vmw_dummy_query_bo_prepare", "Dummy query buffer map failed.\n");
  }
#line 377
  ttm_bo_unreserve(bo);
#line 378
  return;
}
}
#line 392 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_dummy_query_bo_create(struct vmw_private *dev_priv ) 
{ 
  int tmp ;

  {
#line 394
  tmp = ttm_bo_create(& dev_priv->bdev, 4096UL, ttm_bo_type_device, & vmw_vram_sys_placement,
                      0U, 0UL, 0, 0, & dev_priv->dummy_query_bo);
#line 394
  return (tmp);
}
}
#line 403 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_request_device(struct vmw_private *dev_priv ) 
{ 
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 407
  ret = vmw_fifo_init(dev_priv, & dev_priv->fifo);
#line 408
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 408
  if (tmp != 0L) {
#line 409
    drm_err("vmw_request_device", "Unable to initialize FIFO.\n");
#line 410
    return (ret);
  } else {

  }
#line 412
  vmw_fence_fifo_up(dev_priv->fman);
#line 413
  ret = vmw_dummy_query_bo_create(dev_priv);
#line 414
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 414
  if (tmp___0 != 0L) {
#line 415
    goto out_no_query_bo;
  } else {

  }
#line 416
  vmw_dummy_query_bo_prepare(dev_priv);
#line 418
  return (0);
  out_no_query_bo: 
#line 421
  vmw_fence_fifo_down(dev_priv->fman);
#line 422
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 423
  return (ret);
}
}
#line 426 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_release_device(struct vmw_private *dev_priv ) 
{ 
  long tmp ;

  {
#line 433
  tmp = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                         0L);
#line 433
  if (tmp != 0L) {
#line 433
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (433), "i" (12UL));
    ldv_39960: ;
#line 433
    goto ldv_39960;
  } else {

  }
#line 435
  ttm_bo_unref(& dev_priv->dummy_query_bo);
#line 436
  vmw_fence_fifo_down(dev_priv->fman);
#line 437
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 438
  return;
}
}
#line 446 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) 
{ 
  int ret ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 449
  ret = 0;
#line 451
  ldv_mutex_lock_131(& dev_priv->release_mutex);
#line 452
  tmp___1 = dev_priv->num_3d_resources;
#line 452
  dev_priv->num_3d_resources = dev_priv->num_3d_resources + (uint32_t )1;
#line 452
  tmp___2 = ldv__builtin_expect(tmp___1 == 0U, 0L);
#line 452
  if (tmp___2 != 0L) {
#line 453
    ret = vmw_request_device(dev_priv);
#line 454
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 454
    if (tmp != 0L) {
#line 455
      dev_priv->num_3d_resources = dev_priv->num_3d_resources - (uint32_t )1;
    } else {

    }
  } else
#line 456
  if ((int )unhide_svga) {
#line 457
    ldv_mutex_lock_132(& dev_priv->hw_mutex);
#line 458
    tmp___0 = vmw_read(dev_priv, 1U);
#line 458
    vmw_write(dev_priv, 1U, tmp___0 & 4294967293U);
#line 461
    ldv_mutex_unlock_133(& dev_priv->hw_mutex);
  } else {

  }
#line 464
  ldv_mutex_unlock_134(& dev_priv->release_mutex);
#line 465
  return (ret);
}
}
#line 476 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) 
{ 
  int32_t n3d ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 481
  ldv_mutex_lock_135(& dev_priv->release_mutex);
#line 482
  dev_priv->num_3d_resources = dev_priv->num_3d_resources - (uint32_t )1;
#line 482
  tmp___0 = ldv__builtin_expect(dev_priv->num_3d_resources == 0U, 0L);
#line 482
  if (tmp___0 != 0L) {
#line 483
    vmw_release_device(dev_priv);
  } else
#line 484
  if ((int )hide_svga) {
#line 485
    ldv_mutex_lock_136(& dev_priv->hw_mutex);
#line 486
    tmp = vmw_read(dev_priv, 1U);
#line 486
    vmw_write(dev_priv, 1U, tmp | 2U);
#line 489
    ldv_mutex_unlock_137(& dev_priv->hw_mutex);
  } else {

  }
#line 492
  n3d = (int )dev_priv->num_3d_resources;
#line 493
  ldv_mutex_unlock_138(& dev_priv->release_mutex);
#line 495
  tmp___1 = ldv__builtin_expect(n3d < 0, 0L);
#line 495
  if (tmp___1 != 0L) {
#line 495
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (495), "i" (12UL));
    ldv_39971: ;
#line 495
    goto ldv_39971;
  } else {

  }
#line 497
  return;
}
}
#line 507 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_get_initial_size(struct vmw_private *dev_priv ) 
{ 
  uint32_t width ;
  uint32_t height ;
  uint32_t __max1 ;
  uint32_t __max2 ;
  uint32_t __max1___0 ;
  uint32_t __max2___0 ;

  {
#line 512
  width = vmw_read(dev_priv, 2U);
#line 513
  height = vmw_read(dev_priv, 3U);
#line 515
  __max1 = width;
#line 515
  __max2 = 800U;
#line 515
  width = __max1 > __max2 ? __max1 : __max2;
#line 516
  __max1___0 = height;
#line 516
  __max2___0 = 600U;
#line 516
  height = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 518
  if (dev_priv->fb_max_width < width || dev_priv->fb_max_height < height) {
#line 525
    width = 800U;
#line 526
    height = 600U;
  } else {

  }
#line 529
  dev_priv->initial_width = width;
#line 530
  dev_priv->initial_height = height;
#line 531
  return;
}
}
#line 533 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ 
  struct vmw_private *dev_priv ;
  int ret ;
  uint32_t svga_id ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  bool tmp___14 ;
  long tmp___15 ;

  {
#line 539
  tmp = kzalloc(137000UL, 208U);
#line 539
  dev_priv = (struct vmw_private *)tmp;
#line 540
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv == (unsigned long )((struct vmw_private *)0),
                             0L);
#line 540
  if (tmp___0 != 0L) {
#line 541
    drm_err("vmw_driver_load", "Failed allocating a device private struct.\n");
#line 542
    return (-12);
  } else {

  }
#line 544
  memset((void *)dev_priv, 0, 137000UL);
#line 546
  pci_set_master(dev->pdev);
#line 548
  dev_priv->dev = dev;
#line 549
  dev_priv->vmw_chipset = chipset;
#line 550
  dev_priv->last_read_seqno = 4294967196U;
#line 551
  __mutex_init(& dev_priv->hw_mutex, "&dev_priv->hw_mutex", & __key);
#line 552
  __mutex_init(& dev_priv->cmdbuf_mutex, "&dev_priv->cmdbuf_mutex", & __key___0);
#line 553
  __mutex_init(& dev_priv->release_mutex, "&dev_priv->release_mutex", & __key___1);
#line 554
  __rwlock_init(& dev_priv->resource_lock, "&dev_priv->resource_lock", & __key___2);
#line 555
  idr_init(& dev_priv->context_idr);
#line 556
  idr_init(& dev_priv->surface_idr);
#line 557
  idr_init(& dev_priv->stream_idr);
#line 558
  __mutex_init(& dev_priv->init_mutex, "&dev_priv->init_mutex", & __key___3);
#line 559
  __init_waitqueue_head(& dev_priv->fence_queue, "&dev_priv->fence_queue", & __key___4);
#line 560
  __init_waitqueue_head(& dev_priv->fifo_queue, "&dev_priv->fifo_queue", & __key___5);
#line 561
  dev_priv->fence_queue_waiters = 0;
#line 562
  atomic_set(& dev_priv->fifo_queue_waiters, 0);
#line 563
  INIT_LIST_HEAD(& dev_priv->surface_lru);
#line 564
  dev_priv->used_memory_size = 0U;
#line 566
  dev_priv->io_start = (unsigned int )(dev->pdev)->resource[0].start;
#line 567
  dev_priv->vram_start = (uint32_t )(dev->pdev)->resource[1].start;
#line 568
  dev_priv->mmio_start = (uint32_t )(dev->pdev)->resource[2].start;
#line 570
  dev_priv->enable_fb = enable_fbdev != 0;
#line 572
  ldv_mutex_lock_139(& dev_priv->hw_mutex);
#line 574
  vmw_write(dev_priv, 0U, 2415919106U);
#line 575
  svga_id = vmw_read(dev_priv, 0U);
#line 576
  if (svga_id != 2415919106U) {
#line 577
    ret = -38;
#line 578
    drm_err("vmw_driver_load", "Unsupported SVGA ID 0x%x\n", svga_id);
#line 579
    ldv_mutex_unlock_140(& dev_priv->hw_mutex);
#line 580
    goto out_err0;
  } else {

  }
#line 583
  dev_priv->capabilities = vmw_read(dev_priv, 17U);
#line 585
  dev_priv->vram_size = vmw_read(dev_priv, 15U);
#line 586
  dev_priv->mmio_size = vmw_read(dev_priv, 19U);
#line 587
  dev_priv->fb_max_width = vmw_read(dev_priv, 4U);
#line 588
  dev_priv->fb_max_height = vmw_read(dev_priv, 5U);
#line 590
  vmw_get_initial_size(dev_priv);
#line 592
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 593
    dev_priv->max_gmr_descriptors = vmw_read(dev_priv, 44U);
#line 596
    dev_priv->max_gmr_ids = vmw_read(dev_priv, 43U);
  } else {

  }
#line 599
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 600
    dev_priv->max_gmr_pages = vmw_read(dev_priv, 46U);
#line 602
    dev_priv->memory_size = vmw_read(dev_priv, 47U);
#line 604
    dev_priv->memory_size = dev_priv->memory_size - dev_priv->vram_size;
  } else {
#line 610
    dev_priv->memory_size = 536870912U;
  }
#line 613
  ldv_mutex_unlock_141(& dev_priv->hw_mutex);
#line 615
  vmw_print_capabilities(dev_priv->capabilities);
#line 617
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 618
    printk("<6>[drm] Max GMR ids is %u\n", dev_priv->max_gmr_ids);
#line 620
    printk("<6>[drm] Max GMR descriptors is %u\n", dev_priv->max_gmr_descriptors);
  } else {

  }
#line 623
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 624
    printk("<6>[drm] Max number of GMR pages is %u\n", dev_priv->max_gmr_pages);
#line 626
    printk("<6>[drm] Max dedicated hypervisor surface memory is %u kiB\n", dev_priv->memory_size / 1024U);
  } else {

  }
#line 629
  printk("<6>[drm] VRAM at 0x%08x size is %u kiB\n", dev_priv->vram_start, dev_priv->vram_size / 1024U);
#line 631
  printk("<6>[drm] MMIO at 0x%08x size is %u kiB\n", dev_priv->mmio_start, dev_priv->mmio_size / 1024U);
#line 634
  ret = vmw_ttm_global_init(dev_priv);
#line 635
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 635
  if (tmp___1 != 0L) {
#line 636
    goto out_err0;
  } else {

  }
#line 639
  vmw_master_init(& dev_priv->fbdev_master);
#line 640
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 641
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 644
  ret = ttm_bo_device_init(& dev_priv->bdev, (struct ttm_bo_global *)dev_priv->bo_global_ref.ref.object,
                           & vmw_bo_driver, 1048576ULL, 0);
#line 648
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 648
  if (tmp___2 != 0L) {
#line 649
    drm_err("vmw_driver_load", "Failed initializing TTM buffer object driver.\n");
#line 650
    goto out_err1;
  } else {

  }
#line 653
  ret = ttm_bo_init_mm(& dev_priv->bdev, 2U, (unsigned long )(dev_priv->vram_size >> 12));
#line 655
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 655
  if (tmp___3 != 0L) {
#line 656
    drm_err("vmw_driver_load", "Failed initializing memory manager for VRAM.\n");
#line 657
    goto out_err2;
  } else {

  }
#line 660
  dev_priv->has_gmr = 1;
#line 661
  tmp___4 = ttm_bo_init_mm(& dev_priv->bdev, 3U, (unsigned long )dev_priv->max_gmr_ids);
#line 661
  if (tmp___4 != 0) {
#line 663
    printk("<6>[drm] No GMR memory available. Graphics memory resources are very limited.\n");
#line 665
    dev_priv->has_gmr = 0;
  } else {

  }
#line 668
  dev_priv->mmio_mtrr = drm_mtrr_add((unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
                                     1U);
#line 671
  tmp___5 = ioremap_wc((resource_size_t )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size);
#line 671
  dev_priv->mmio_virt = (__le32 *)tmp___5;
#line 674
  tmp___6 = ldv__builtin_expect((unsigned long )dev_priv->mmio_virt == (unsigned long )((__le32 *)0),
                             0L);
#line 674
  if (tmp___6 != 0L) {
#line 675
    ret = -12;
#line 676
    drm_err("vmw_driver_load", "Failed mapping MMIO.\n");
#line 677
    goto out_err3;
  } else {

  }
#line 681
  if ((dev_priv->capabilities & 524288U) == 0U && (dev_priv->capabilities & 131072U) == 0U) {
#line 681
    tmp___7 = vmw_fifo_have_pitchlock(dev_priv);
#line 681
    if (tmp___7) {
#line 681
      tmp___8 = 0;
    } else {
#line 681
      tmp___8 = 1;
    }
#line 681
    if (tmp___8) {
#line 684
      ret = -38;
#line 685
      drm_err("vmw_driver_load", "Hardware has no pitchlock\n");
#line 686
      goto out_err4;
    } else {

    }
  } else {

  }
#line 689
  dev_priv->tdev = ttm_object_device_init((struct ttm_mem_global *)dev_priv->mem_global_ref.object,
                                          12U);
#line 692
  tmp___9 = ldv__builtin_expect((unsigned long )dev_priv->tdev == (unsigned long )((struct ttm_object_device *)0),
                             0L);
#line 692
  if (tmp___9 != 0L) {
#line 693
    drm_err("vmw_driver_load", "Unable to initialize TTM object management.\n");
#line 694
    ret = -12;
#line 695
    goto out_err4;
  } else {

  }
#line 698
  dev->dev_private = (void *)dev_priv;
#line 700
  ret = pci_request_regions(dev->pdev, "vmwgfx probe");
#line 701
  dev_priv->stealth = ret != 0;
#line 702
  if ((int )dev_priv->stealth) {
#line 707
    printk("<6>[drm] It appears like vesafb is loaded. Ignore above error if any.\n");
#line 709
    ret = pci_request_region(dev->pdev, 2, "vmwgfx stealth probe");
#line 710
    tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 710
    if (tmp___10 != 0L) {
#line 711
      drm_err("vmw_driver_load", "Failed reserving the SVGA MMIO resource.\n");
#line 712
      goto out_no_device;
    } else {

    }
  } else {

  }
#line 716
  dev_priv->fman = vmw_fence_manager_init(dev_priv);
#line 717
  tmp___11 = ldv__builtin_expect((unsigned long )dev_priv->fman == (unsigned long )((struct vmw_fence_manager *)0),
                              0L);
#line 717
  if (tmp___11 != 0L) {
#line 718
    goto out_no_fman;
  } else {

  }
#line 721
  ret = vmw_3d_resource_inc(dev_priv, 1);
#line 722
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 722
  if (tmp___12 != 0L) {
#line 723
    goto out_no_fifo;
  } else {

  }
#line 724
  vmw_kms_save_vga(dev_priv);
#line 727
  ret = vmw_kms_init(dev_priv);
#line 728
  tmp___13 = ldv__builtin_expect(ret != 0, 0L);
#line 728
  if (tmp___13 != 0L) {
#line 729
    goto out_no_kms;
  } else {

  }
#line 730
  vmw_overlay_init(dev_priv);
#line 733
  tmp___14 = vmw_fifo_have_3d(dev_priv);
#line 733
  printk("<6>[drm] Detected %sdevice 3D availability.\n", (int )tmp___14 ? (char *)"" : (char *)"no ");
#line 738
  if ((int )dev_priv->enable_fb) {
#line 739
    vmw_fb_init(dev_priv);
  } else {
#line 741
    vmw_kms_restore_vga(dev_priv);
#line 742
    vmw_3d_resource_dec(dev_priv, 1);
  }
#line 745
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 746
    ret = drm_irq_install(dev);
#line 747
    tmp___15 = ldv__builtin_expect(ret != 0, 0L);
#line 747
    if (tmp___15 != 0L) {
#line 748
      drm_err("vmw_driver_load", "Failed installing irq: %d\n", ret);
#line 749
      goto out_no_irq;
    } else {

    }
  } else {

  }
#line 753
  dev_priv->pm_nb.notifier_call = & vmwgfx_pm_notifier;
#line 754
  register_pm_notifier(& dev_priv->pm_nb);
#line 756
  return (0);
  out_no_irq: ;
#line 759
  if ((int )dev_priv->enable_fb) {
#line 760
    vmw_fb_close(dev_priv);
  } else {

  }
#line 761
  vmw_overlay_close(dev_priv);
#line 762
  vmw_kms_close(dev_priv);
  out_no_kms: ;
#line 765
  if ((int )dev_priv->enable_fb) {
#line 766
    vmw_kms_restore_vga(dev_priv);
#line 767
    vmw_3d_resource_dec(dev_priv, 0);
  } else {

  }
  out_no_fifo: 
#line 770
  vmw_fence_manager_takedown(dev_priv->fman);
  out_no_fman: ;
#line 772
  if ((int )dev_priv->stealth) {
#line 773
    pci_release_region(dev->pdev, 2);
  } else {
#line 775
    pci_release_regions(dev->pdev);
  }
  out_no_device: 
#line 777
  ttm_object_device_release(& dev_priv->tdev);
  out_err4: 
#line 779
  iounmap((void volatile   *)dev_priv->mmio_virt);
  out_err3: 
#line 781
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 783
  if ((int )dev_priv->has_gmr) {
#line 784
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 785
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
  out_err2: 
#line 787
  ttm_bo_device_release(& dev_priv->bdev);
  out_err1: 
#line 789
  vmw_ttm_global_release(dev_priv);
  out_err0: 
#line 791
  idr_destroy(& dev_priv->surface_idr);
#line 792
  idr_destroy(& dev_priv->context_idr);
#line 793
  idr_destroy(& dev_priv->stream_idr);
#line 794
  kfree((void const   *)dev_priv);
#line 795
  return (ret);
}
}
#line 798 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_unload(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;

  {
#line 800
  tmp = vmw_priv(dev);
#line 800
  dev_priv = tmp;
#line 802
  unregister_pm_notifier(& dev_priv->pm_nb);
#line 804
  if ((unsigned long )dev_priv->ctx.cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 805
    vfree((void const   *)dev_priv->ctx.cmd_bounce);
  } else {

  }
#line 806
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 807
    drm_irq_uninstall(dev_priv->dev);
  } else {

  }
#line 808
  if ((int )dev_priv->enable_fb) {
#line 809
    vmw_fb_close(dev_priv);
#line 810
    vmw_kms_restore_vga(dev_priv);
#line 811
    vmw_3d_resource_dec(dev_priv, 0);
  } else {

  }
#line 813
  vmw_kms_close(dev_priv);
#line 814
  vmw_overlay_close(dev_priv);
#line 815
  vmw_fence_manager_takedown(dev_priv->fman);
#line 816
  if ((int )dev_priv->stealth) {
#line 817
    pci_release_region(dev->pdev, 2);
  } else {
#line 819
    pci_release_regions(dev->pdev);
  }
#line 821
  ttm_object_device_release(& dev_priv->tdev);
#line 822
  iounmap((void volatile   *)dev_priv->mmio_virt);
#line 823
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 825
  if ((int )dev_priv->has_gmr) {
#line 826
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 827
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
#line 828
  ttm_bo_device_release(& dev_priv->bdev);
#line 829
  vmw_ttm_global_release(dev_priv);
#line 830
  idr_destroy(& dev_priv->surface_idr);
#line 831
  idr_destroy(& dev_priv->context_idr);
#line 832
  idr_destroy(& dev_priv->stream_idr);
#line 834
  kfree((void const   *)dev_priv);
#line 836
  return (0);
}
}
#line 839 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_preclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 842
  tmp = vmw_fpriv(file_priv);
#line 842
  vmw_fp = tmp;
#line 843
  tmp___0 = vmw_priv(dev);
#line 843
  dev_priv = tmp___0;
#line 845
  vmw_event_fence_fpriv_gone(dev_priv->fman, & vmw_fp->fence_events);
#line 846
  return;
}
}
#line 848 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_postclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_fpriv *vmw_fp ;

  {
#line 853
  vmw_fp = vmw_fpriv(file_priv);
#line 854
  ttm_object_file_release(& vmw_fp->tfile);
#line 855
  if ((unsigned long )vmw_fp->locked_master != (unsigned long )((struct drm_master *)0)) {
#line 856
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 857
  kfree((void const   *)vmw_fp);
#line 858
  return;
}
}
#line 860 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_open(struct drm_device *dev , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 862
  tmp = vmw_priv(dev);
#line 862
  dev_priv = tmp;
#line 864
  ret = -12;
#line 866
  tmp___0 = kzalloc(32UL, 208U);
#line 866
  vmw_fp = (struct vmw_fpriv *)tmp___0;
#line 867
  tmp___1 = ldv__builtin_expect((unsigned long )vmw_fp == (unsigned long )((struct vmw_fpriv *)0),
                             0L);
#line 867
  if (tmp___1 != 0L) {
#line 868
    return (ret);
  } else {

  }
#line 870
  INIT_LIST_HEAD(& vmw_fp->fence_events);
#line 871
  vmw_fp->tfile = ttm_object_file_init(dev_priv->tdev, 10U);
#line 872
  tmp___2 = ldv__builtin_expect((unsigned long )vmw_fp->tfile == (unsigned long )((struct ttm_object_file *)0),
                             0L);
#line 872
  if (tmp___2 != 0L) {
#line 873
    goto out_no_tfile;
  } else {

  }
#line 875
  file_priv->driver_priv = (void *)vmw_fp;
#line 877
  tmp___3 = ldv__builtin_expect((unsigned long )dev_priv->bdev.dev_mapping == (unsigned long )((struct address_space *)0),
                             0L);
#line 877
  if (tmp___3 != 0L) {
#line 878
    dev_priv->bdev.dev_mapping = (((file_priv->filp)->f_path.dentry)->d_inode)->i_mapping;
  } else {

  }
#line 881
  return (0);
  out_no_tfile: 
#line 884
  kfree((void const   *)vmw_fp);
#line 885
  return (ret);
}
}
#line 888 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static long vmw_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ 
  struct drm_file *file_priv ;
  struct drm_device *dev ;
  unsigned int nr ;
  struct drm_ioctl_desc *ioctl ;
  long tmp ;
  long tmp___0 ;

  {
#line 891
  file_priv = (struct drm_file *)filp->private_data;
#line 892
  dev = (file_priv->minor)->dev;
#line 893
  nr = cmd & 255U;
#line 899
  if ((nr > 63U && nr <= 159U) && (unsigned int )((dev->driver)->num_ioctls + 64) > nr) {
#line 901
    ioctl = (struct drm_ioctl_desc *)(& vmw_ioctls) + (unsigned long )(nr - 64U);
#line 904
    tmp = ldv__builtin_expect(ioctl->cmd_drv != cmd, 0L);
#line 904
    if (tmp != 0L) {
#line 905
      drm_err("vmw_unlocked_ioctl", "Invalid command format, ioctl %d\n", nr - 64U);
#line 907
      return (-22L);
    } else {

    }
  } else {

  }
#line 911
  tmp___0 = drm_ioctl(filp, cmd, arg);
#line 911
  return (tmp___0);
}
}
#line 914 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_firstopen(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;

  {
#line 916
  tmp = vmw_priv(dev);
#line 916
  dev_priv = tmp;
#line 917
  dev_priv->is_opened = 1;
#line 919
  return (0);
}
}
#line 922 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_lastclose(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_crtc *crtc ;
  struct drm_mode_set set ;
  int ret ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 924
  tmp = vmw_priv(dev);
#line 924
  dev_priv = tmp;
#line 933
  if (! dev_priv->is_opened) {
#line 934
    return;
  } else {

  }
#line 936
  dev_priv->is_opened = 0;
#line 937
  set.x = 0U;
#line 938
  set.y = 0U;
#line 939
  set.fb = 0;
#line 940
  set.mode = 0;
#line 941
  set.connectors = 0;
#line 942
  set.num_connectors = 0UL;
#line 944
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 944
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 944
  goto ldv_40059;
  ldv_40058: 
#line 945
  set.crtc = crtc;
#line 946
  ret = (*((crtc->funcs)->set_config))(& set);
#line 947
  __ret_warn_on = ret != 0;
#line 947
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 947
  if (tmp___0 != 0L) {
#line 947
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared",
                       947);
  } else {

  }
#line 947
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 944
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 944
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_40059: ;
#line 944
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 945
    goto ldv_40058;
  } else {

  }

#line 949
  return;
}
}
#line 952 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_init(struct vmw_master *vmaster ) 
{ 
  struct lock_class_key __key ;

  {
#line 954
  ttm_lock_init(& vmaster->lock);
#line 955
  INIT_LIST_HEAD(& vmaster->fb_surf);
#line 956
  __mutex_init(& vmaster->fb_surf_mutex, "&vmaster->fb_surf_mutex", & __key);
#line 958
  return;
}
}
#line 959 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_create(struct drm_device *dev , struct drm_master *master ) 
{ 
  struct vmw_master *vmaster ;
  void *tmp ;
  long tmp___0 ;

  {
#line 964
  tmp = kzalloc(432UL, 208U);
#line 964
  vmaster = (struct vmw_master *)tmp;
#line 965
  tmp___0 = ldv__builtin_expect((unsigned long )vmaster == (unsigned long )((struct vmw_master *)0),
                             0L);
#line 965
  if (tmp___0 != 0L) {
#line 966
    return (-12);
  } else {

  }
#line 968
  vmw_master_init(vmaster);
#line 969
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 970
  master->driver_priv = (void *)vmaster;
#line 972
  return (0);
}
}
#line 975 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_destroy(struct drm_device *dev , struct drm_master *master ) 
{ 
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 978
  tmp = vmw_master(master);
#line 978
  vmaster = tmp;
#line 980
  master->driver_priv = 0;
#line 981
  kfree((void const   *)vmaster);
#line 982
  return;
}
}
#line 985 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_set(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *active ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 989
  tmp = vmw_priv(dev);
#line 989
  dev_priv = tmp;
#line 990
  tmp___0 = vmw_fpriv(file_priv);
#line 990
  vmw_fp = tmp___0;
#line 991
  active = dev_priv->active_master;
#line 992
  tmp___1 = vmw_master(file_priv->master);
#line 992
  vmaster = tmp___1;
#line 993
  ret = 0;
#line 995
  if (! dev_priv->enable_fb) {
#line 996
    ret = vmw_3d_resource_inc(dev_priv, 1);
#line 997
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 997
    if (tmp___2 != 0L) {
#line 998
      return (ret);
    } else {

    }
#line 999
    vmw_kms_save_vga(dev_priv);
#line 1000
    ldv_mutex_lock_142(& dev_priv->hw_mutex);
#line 1001
    vmw_write(dev_priv, 45U, 0U);
#line 1002
    ldv_mutex_unlock_143(& dev_priv->hw_mutex);
  } else {

  }
#line 1005
  if ((unsigned long )active != (unsigned long )((struct vmw_master *)0)) {
#line 1006
    tmp___3 = ldv__builtin_expect((unsigned long )(& dev_priv->fbdev_master) != (unsigned long )active,
                               0L);
#line 1006
    if (tmp___3 != 0L) {
#line 1006
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (1006), "i" (12UL));
      ldv_40085: ;
#line 1006
      goto ldv_40085;
    } else {

    }
#line 1007
    ret = ttm_vt_lock(& active->lock, 0, vmw_fp->tfile);
#line 1008
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1008
    if (tmp___4 != 0L) {
#line 1009
      goto out_no_active_lock;
    } else {

    }
#line 1011
    ttm_lock_set_kill(& active->lock, 1, 15);
#line 1012
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1013
    tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1013
    if (tmp___5 != 0L) {
#line 1014
      drm_err("vmw_master_set", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1018
    dev_priv->active_master = 0;
  } else {

  }
#line 1021
  ttm_lock_set_kill(& vmaster->lock, 0, 15);
#line 1022
  if (! from_open) {
#line 1023
    ttm_vt_unlock(& vmaster->lock);
#line 1024
    tmp___6 = ldv__builtin_expect((unsigned long )vmw_fp->locked_master != (unsigned long )file_priv->master,
                               0L);
#line 1024
    if (tmp___6 != 0L) {
#line 1024
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (1024), "i" (12UL));
      ldv_40088: ;
#line 1024
      goto ldv_40088;
    } else {

    }
#line 1025
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1028
  dev_priv->active_master = vmaster;
#line 1030
  return (0);
  out_no_active_lock: ;
#line 1033
  if (! dev_priv->enable_fb) {
#line 1034
    ldv_mutex_lock_144(& dev_priv->hw_mutex);
#line 1035
    vmw_write(dev_priv, 45U, 1U);
#line 1036
    ldv_mutex_unlock_145(& dev_priv->hw_mutex);
#line 1037
    vmw_kms_restore_vga(dev_priv);
#line 1038
    vmw_3d_resource_dec(dev_priv, 1);
  } else {

  }
#line 1040
  return (ret);
}
}
#line 1043 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_drop(struct drm_device *dev , struct drm_file *file_priv ,
                            bool from_release ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1047
  tmp = vmw_priv(dev);
#line 1047
  dev_priv = tmp;
#line 1048
  tmp___0 = vmw_fpriv(file_priv);
#line 1048
  vmw_fp = tmp___0;
#line 1049
  tmp___1 = vmw_master(file_priv->master);
#line 1049
  vmaster = tmp___1;
#line 1057
  vmw_fp->locked_master = drm_master_get(file_priv->master);
#line 1058
  ret = ttm_vt_lock(& vmaster->lock, 0, vmw_fp->tfile);
#line 1059
  vmw_execbuf_release_pinned_bo(dev_priv, 0, 0U);
#line 1061
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1061
  if (tmp___2 != 0L) {
#line 1062
    drm_err("vmw_master_drop", "Unable to lock TTM at VT switch.\n");
#line 1063
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1066
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 1068
  if (! dev_priv->enable_fb) {
#line 1069
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1070
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1070
    if (tmp___3 != 0L) {
#line 1071
      drm_err("vmw_master_drop", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1072
    ldv_mutex_lock_146(& dev_priv->hw_mutex);
#line 1073
    vmw_write(dev_priv, 45U, 1U);
#line 1074
    ldv_mutex_unlock_147(& dev_priv->hw_mutex);
#line 1075
    vmw_kms_restore_vga(dev_priv);
#line 1076
    vmw_3d_resource_dec(dev_priv, 1);
  } else {

  }
#line 1079
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 1080
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 1081
  ttm_vt_unlock(& dev_priv->fbdev_master.lock);
#line 1083
  if ((int )dev_priv->enable_fb) {
#line 1084
    vmw_fb_on(dev_priv);
  } else {

  }
#line 1085
  return;
}
}
#line 1088 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_remove(struct pci_dev *pdev ) 
{ 
  struct drm_device *dev ;
  void *tmp ;

  {
#line 1090
  tmp = pci_get_drvdata(pdev);
#line 1090
  dev = (struct drm_device *)tmp;
#line 1092
  drm_put_dev(dev);
#line 1093
  return;
}
}
#line 1095 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) 
{ 
  struct vmw_private *dev_priv ;
  struct notifier_block  const  *__mptr ;
  struct vmw_master *vmaster ;

  {
#line 1099
  __mptr = (struct notifier_block  const  *)nb;
#line 1099
  dev_priv = (struct vmw_private *)__mptr + 0xfffffffffffde9d8UL;
#line 1100
  vmaster = dev_priv->active_master;
#line 1102
  switch (val) {
  case 1UL: ;
  case 3UL: 
#line 1105
  ttm_suspend_lock(& vmaster->lock);
#line 1111
  vmw_execbuf_release_pinned_bo(dev_priv, 0, 0U);
#line 1112
  ttm_bo_swapout_all(& dev_priv->bdev);
#line 1114
  goto ldv_40114;
  case 2UL: ;
  case 4UL: ;
  case 6UL: 
#line 1118
  ttm_suspend_unlock(& vmaster->lock);
#line 1120
  goto ldv_40114;
  case 5UL: ;
#line 1122
  goto ldv_40114;
  default: ;
#line 1124
  goto ldv_40114;
  }
  ldv_40114: ;
#line 1126
  return (0);
}
}
#line 1133 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1135
  tmp = pci_get_drvdata(pdev);
#line 1135
  dev = (struct drm_device *)tmp;
#line 1136
  tmp___0 = vmw_priv(dev);
#line 1136
  dev_priv = tmp___0;
#line 1138
  if (dev_priv->num_3d_resources != 0U) {
#line 1139
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1141
    return (-16);
  } else {

  }
#line 1144
  pci_save_state(pdev);
#line 1145
  pci_disable_device(pdev);
#line 1146
  pci_set_power_state(pdev, 3);
#line 1147
  return (0);
}
}
#line 1150 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_resume(struct pci_dev *pdev ) 
{ 
  int tmp ;

  {
#line 1152
  pci_set_power_state(pdev, 0);
#line 1153
  pci_restore_state(pdev);
#line 1154
  tmp = pci_enable_device(pdev);
#line 1154
  return (tmp);
}
}
#line 1157 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_suspend(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct pm_message dummy ;
  int tmp ;

  {
#line 1159
  __mptr = (struct device  const  *)kdev;
#line 1159
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff70UL;
#line 1162
  dummy.event = 0;
#line 1164
  tmp = vmw_pci_suspend(pdev, dummy);
#line 1164
  return (tmp);
}
}
#line 1167 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_resume(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1169
  __mptr = (struct device  const  *)kdev;
#line 1169
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff70UL;
#line 1171
  tmp = vmw_pci_resume(pdev);
#line 1171
  return (tmp);
}
}
#line 1174 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_prepare(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1176
  __mptr = (struct device  const  *)kdev;
#line 1176
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff70UL;
#line 1177
  tmp = pci_get_drvdata(pdev);
#line 1177
  dev = (struct drm_device *)tmp;
#line 1178
  tmp___0 = vmw_priv(dev);
#line 1178
  dev_priv = tmp___0;
#line 1184
  dev_priv->suspended = 1;
#line 1185
  if ((int )dev_priv->enable_fb) {
#line 1186
    vmw_3d_resource_dec(dev_priv, 1);
  } else {

  }
#line 1188
  if (dev_priv->num_3d_resources != 0U) {
#line 1190
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1193
    if ((int )dev_priv->enable_fb) {
#line 1194
      vmw_3d_resource_inc(dev_priv, 1);
    } else {

    }
#line 1195
    dev_priv->suspended = 0;
#line 1196
    return (-16);
  } else {

  }
#line 1199
  return (0);
}
}
#line 1202 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_pm_complete(struct device *kdev ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1204
  __mptr = (struct device  const  *)kdev;
#line 1204
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff70UL;
#line 1205
  tmp = pci_get_drvdata(pdev);
#line 1205
  dev = (struct drm_device *)tmp;
#line 1206
  tmp___0 = vmw_priv(dev);
#line 1206
  dev_priv = tmp___0;
#line 1212
  if ((int )dev_priv->enable_fb) {
#line 1213
    vmw_3d_resource_inc(dev_priv, 0);
  } else {

  }
#line 1215
  dev_priv->suspended = 0;
#line 1216
  return;
}
}
#line 1218 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct dev_pm_ops  const  vmw_pm_ops  = 
#line 1218
     {& vmw_pm_prepare, & vmw_pm_complete, & vmw_pm_suspend, & vmw_pm_resume, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1225 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct file_operations  const  vmwgfx_driver_fops  = 
#line 1225
     {& __this_module, & noop_llseek, & vmw_fops_read, 0, 0, 0, 0, & vmw_fops_poll,
    & vmw_unlocked_ioctl, & drm_compat_ioctl, & vmw_mmap, & drm_open, 0, & drm_release,
    0, 0, & drm_fasync, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1240 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_driver driver  = 
#line 1240
     {& vmw_driver_load, & vmw_firstopen, & vmw_driver_open, & vmw_preclose, & vmw_postclose,
    & vmw_lastclose, & vmw_driver_unload, 0, 0, 0, 0, 0, & vmw_get_vblank_counter,
    & vmw_enable_vblank, & vmw_disable_vblank, 0, 0, 0, & vmw_irq_handler, & vmw_irq_preinstall,
    & vmw_irq_postinstall, & vmw_irq_uninstall, 0, 0, 0, 0, & vmw_master_create, & vmw_master_destroy,
    & vmw_master_set, & vmw_master_drop, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 0, (char *)"vmwgfx", (char *)"Linux drm driver for VMware graphics devices",
    (char *)"20120209", 8384U, 0, (struct drm_ioctl_desc *)(& vmw_ioctls), 21, & vmwgfx_driver_fops,
    {0}, 0, {0, 0}};
#line 1274 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_driver vmw_pci_driver  = 
#line 1274
     {{0, 0}, "vmwgfx", (struct pci_device_id  const  *)(& vmw_pci_id_list), & vmw_probe,
    & vmw_remove, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, & vmw_pm_ops,
                                     0}, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0,
                                                                 0UL}}}}, {0, 0}}};
#line 1284 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  int tmp ;

  {
#line 1286
  tmp = drm_get_pci_dev(pdev, ent, & driver);
#line 1286
  return (tmp);
}
}
#line 1289 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_init(void) 
{ 
  int ret ;

  {
#line 1292
  ret = drm_pci_init(& driver, & vmw_pci_driver);
#line 1293
  if (ret != 0) {
#line 1294
    drm_err("vmwgfx_init", "Failed initializing DRM.\n");
  } else {

  }
#line 1295
  return (ret);
}
}
#line 1298 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmwgfx_exit(void) 
{ 


  {
#line 1300
  drm_pci_exit(& driver, & vmw_pci_driver);
#line 1301
  return;
}
}
#line 1333
extern void ldv_check_return_value(int  ) ;
#line 1336
extern void ldv_check_return_value_probe(int  ) ;
#line 1351 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void main(void) 
{ 
  struct device *var_group1 ;
  struct file *var_group2 ;
  unsigned int var_vmw_unlocked_ioctl_13_p1 ;
  unsigned long var_vmw_unlocked_ioctl_13_p2 ;
  struct drm_device *var_group3 ;
  unsigned long var_vmw_driver_load_8_p1 ;
  struct drm_master *var_group4 ;
  struct drm_file *var_group5 ;
  bool var_vmw_master_set_19_p2 ;
  bool var_vmw_master_drop_20_p2 ;
  int res_vmw_driver_open_12 ;
  struct pci_dev *var_group6 ;
  struct pci_device_id  const  *var_vmw_probe_29_p1 ;
  int res_vmw_probe_29 ;
  int ldv_s_driver_drm_driver ;
  int ldv_s_vmw_pci_driver_pci_driver ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2897
  ldv_s_driver_drm_driver = 0;
#line 2900
  ldv_s_vmw_pci_driver_pci_driver = 0;
#line 2801
  LDV_IN_INTERRUPT = 1;
#line 2810
  ldv_initialize();
#line 2890
  ldv_handler_precall();
#line 2891
  tmp = vmwgfx_init();
#line 2891
  if (tmp != 0) {
#line 2892
    goto ldv_final;
  } else {

  }
#line 2903
  goto ldv_40245;
  ldv_40244: 
#line 2908
  tmp___0 = __VERIFIER_nondet_int();
#line 2908
  switch (tmp___0) {
  case 0: 
#line 2990
  ldv_handler_precall();
#line 2991
  vmw_pm_prepare(var_group1);
#line 3002
  goto ldv_40224;
  case 1: 
#line 3083
  ldv_handler_precall();
#line 3084
  vmw_pm_complete(var_group1);
#line 3095
  goto ldv_40224;
  case 2: 
#line 3176
  ldv_handler_precall();
#line 3177
  vmw_pm_suspend(var_group1);
#line 3188
  goto ldv_40224;
  case 3: 
#line 3269
  ldv_handler_precall();
#line 3270
  vmw_pm_resume(var_group1);
#line 3281
  goto ldv_40224;
  case 4: 
#line 3362
  ldv_handler_precall();
#line 3363
  vmw_unlocked_ioctl(var_group2, var_vmw_unlocked_ioctl_13_p1, var_vmw_unlocked_ioctl_13_p2);
#line 3374
  goto ldv_40224;
  case 5: ;
#line 3378
  if (ldv_s_driver_drm_driver == 0) {
#line 3455
    ldv_handler_precall();
#line 3456
    res_vmw_driver_open_12 = vmw_driver_open(var_group3, var_group5);
#line 3457
    ldv_check_return_value(res_vmw_driver_open_12);
#line 3458
    if (res_vmw_driver_open_12 != 0) {
#line 3459
      goto ldv_module_exit;
    } else {

    }
#line 3464
    ldv_s_driver_drm_driver = 0;
  } else {

  }
#line 3470
  goto ldv_40224;
  case 6: 
#line 3551
  ldv_handler_precall();
#line 3552
  vmw_driver_load(var_group3, var_vmw_driver_load_8_p1);
#line 3563
  goto ldv_40224;
  case 7: 
#line 3644
  ldv_handler_precall();
#line 3645
  vmw_driver_unload(var_group3);
#line 3656
  goto ldv_40224;
  case 8: 
#line 3737
  ldv_handler_precall();
#line 3738
  vmw_firstopen(var_group3);
#line 3749
  goto ldv_40224;
  case 9: 
#line 3830
  ldv_handler_precall();
#line 3831
  vmw_lastclose(var_group3);
#line 3842
  goto ldv_40224;
  case 10: 
#line 3923
  ldv_handler_precall();
#line 3924
  vmw_master_create(var_group3, var_group4);
#line 3935
  goto ldv_40224;
  case 11: 
#line 4016
  ldv_handler_precall();
#line 4017
  vmw_master_destroy(var_group3, var_group4);
#line 4028
  goto ldv_40224;
  case 12: 
#line 4109
  ldv_handler_precall();
#line 4110
  vmw_master_set(var_group3, var_group5, (int )var_vmw_master_set_19_p2);
#line 4121
  goto ldv_40224;
  case 13: 
#line 4202
  ldv_handler_precall();
#line 4203
  vmw_master_drop(var_group3, var_group5, (int )var_vmw_master_drop_20_p2);
#line 4214
  goto ldv_40224;
  case 14: 
#line 4295
  ldv_handler_precall();
#line 4296
  vmw_preclose(var_group3, var_group5);
#line 4307
  goto ldv_40224;
  case 15: 
#line 4388
  ldv_handler_precall();
#line 4389
  vmw_postclose(var_group3, var_group5);
#line 4400
  goto ldv_40224;
  case 16: ;
#line 4404
  if (ldv_s_vmw_pci_driver_pci_driver == 0) {
#line 4483
    res_vmw_probe_29 = vmw_probe(var_group6, var_vmw_probe_29_p1);
#line 4484
    ldv_check_return_value(res_vmw_probe_29);
#line 4485
    ldv_check_return_value_probe(res_vmw_probe_29);
#line 4486
    if (res_vmw_probe_29 != 0) {
#line 4487
      goto ldv_module_exit;
    } else {

    }
#line 4488
    ldv_s_vmw_pci_driver_pci_driver = ldv_s_vmw_pci_driver_pci_driver + 1;
  } else {

  }
#line 4494
  goto ldv_40224;
  case 17: ;
#line 4498
  if (ldv_s_vmw_pci_driver_pci_driver == 1) {
#line 4575
    ldv_handler_precall();
#line 4576
    vmw_remove(var_group6);
#line 4581
    ldv_s_vmw_pci_driver_pci_driver = 0;
  } else {

  }
#line 4587
  goto ldv_40224;
  default: ;
#line 4588
  goto ldv_40224;
  }
  ldv_40224: ;
  ldv_40245: 
#line 2903
  tmp___1 = __VERIFIER_nondet_int();
#line 2903
  if ((tmp___1 != 0 || ldv_s_driver_drm_driver != 0) || ldv_s_vmw_pci_driver_pci_driver != 0) {
#line 2906
    goto ldv_40244;
  } else {

  }

  ldv_module_exit: 
#line 4674
  ldv_handler_precall();
#line 4675
  vmwgfx_exit();
  ldv_final: 
#line 4678
  ldv_check_final_state();
#line 4681
  return;
}
}
#line 4685 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4690
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 4692
  mutex_lock(ldv_func_arg1);
#line 4693
  return;
}
}
#line 4695 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_mutex_trylock_120(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 4700
  tmp = mutex_trylock(ldv_func_arg1);
#line 4700
  ldv_func_res = tmp;
#line 4702
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 4702
  return (tmp___0);
#line 4704
  return (ldv_func_res);
}
}
#line 4707 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4712
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 4714
  mutex_unlock(ldv_func_arg1);
#line 4715
  return;
}
}
#line 4717 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4722
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 4724
  mutex_lock(ldv_func_arg1);
#line 4725
  return;
}
}
#line 4727 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4732
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 4734
  mutex_unlock(ldv_func_arg1);
#line 4735
  return;
}
}
#line 4737 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4742
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 4744
  mutex_lock(ldv_func_arg1);
#line 4745
  return;
}
}
#line 4747 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4752
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 4754
  mutex_unlock(ldv_func_arg1);
#line 4755
  return;
}
}
#line 4757 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4762
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 4764
  mutex_unlock(ldv_func_arg1);
#line 4765
  return;
}
}
#line 4767 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4772
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 4774
  mutex_lock(ldv_func_arg1);
#line 4775
  return;
}
}
#line 4777 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4782
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 4784
  mutex_unlock(ldv_func_arg1);
#line 4785
  return;
}
}
#line 4787 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4792
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 4794
  mutex_lock(ldv_func_arg1);
#line 4795
  return;
}
}
#line 4797 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4802
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 4804
  mutex_unlock(ldv_func_arg1);
#line 4805
  return;
}
}
#line 4807 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4812
  ldv_mutex_lock_release_mutex(ldv_func_arg1);
#line 4814
  mutex_lock(ldv_func_arg1);
#line 4815
  return;
}
}
#line 4817 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4822
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4824
  mutex_lock(ldv_func_arg1);
#line 4825
  return;
}
}
#line 4827 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4832
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4834
  mutex_unlock(ldv_func_arg1);
#line 4835
  return;
}
}
#line 4837 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4842
  ldv_mutex_unlock_release_mutex(ldv_func_arg1);
#line 4844
  mutex_unlock(ldv_func_arg1);
#line 4845
  return;
}
}
#line 4847 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4852
  ldv_mutex_lock_release_mutex(ldv_func_arg1);
#line 4854
  mutex_lock(ldv_func_arg1);
#line 4855
  return;
}
}
#line 4857 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4862
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4864
  mutex_lock(ldv_func_arg1);
#line 4865
  return;
}
}
#line 4867 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4872
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4874
  mutex_unlock(ldv_func_arg1);
#line 4875
  return;
}
}
#line 4877 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4882
  ldv_mutex_unlock_release_mutex(ldv_func_arg1);
#line 4884
  mutex_unlock(ldv_func_arg1);
#line 4885
  return;
}
}
#line 4887 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4892
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4894
  mutex_lock(ldv_func_arg1);
#line 4895
  return;
}
}
#line 4897 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4902
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4904
  mutex_unlock(ldv_func_arg1);
#line 4905
  return;
}
}
#line 4907 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4912
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4914
  mutex_unlock(ldv_func_arg1);
#line 4915
  return;
}
}
#line 4917 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4922
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4924
  mutex_lock(ldv_func_arg1);
#line 4925
  return;
}
}
#line 4927 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4932
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4934
  mutex_unlock(ldv_func_arg1);
#line 4935
  return;
}
}
#line 4937 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4942
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4944
  mutex_lock(ldv_func_arg1);
#line 4945
  return;
}
}
#line 4947 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4952
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4954
  mutex_unlock(ldv_func_arg1);
#line 4955
  return;
}
}
#line 4957 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4962
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 4964
  mutex_lock(ldv_func_arg1);
#line 4965
  return;
}
}
#line 4967 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 4972
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 4974
  mutex_unlock(ldv_func_arg1);
#line 4975
  return;
}
}
#line 62 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_178(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_179(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_180(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_182(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->ldv_5988.rlock);
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5988.rlock, flags);
#line 341
  return;
}
}
#line 382 "include/linux/workqueue.h"
extern int schedule_delayed_work(struct delayed_work * , unsigned long  ) ;
#line 395
extern bool flush_delayed_work_sync(struct delayed_work * ) ;
#line 903 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ 
  struct apertures_struct *a ;
  void *tmp ;

  {
#line 904
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
#line 904
  a = (struct apertures_struct *)tmp;
#line 906
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
#line 907
    return (0);
  } else {

  }
#line 908
  a->count = max_num;
#line 909
  return (a);
}
}
#line 993
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
#line 994
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
#line 995
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
#line 1008
extern int register_framebuffer(struct fb_info * ) ;
#line 1009
extern int unregister_framebuffer(struct fb_info * ) ;
#line 1052
extern void fb_deferred_io_init(struct fb_info * ) ;
#line 1056
extern void fb_deferred_io_cleanup(struct fb_info * ) ;
#line 1080
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
#line 1081
extern void framebuffer_release(struct fb_info * ) ;
#line 134 "include/drm/ttm/ttm_lock.h"
extern void ttm_write_unlock(struct ttm_lock * ) ;
#line 146
extern int ttm_write_lock(struct ttm_lock * , bool  ) ;
#line 420 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) ;
#line 421
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) ;
#line 516
struct ttm_placement vmw_vram_ne_placement ;
#line 604
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) ;
#line 656
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) ;
#line 172 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                            unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ 
  struct vmw_fb_par *par ;
  u32 *pal ;

  {
#line 176
  par = (struct vmw_fb_par *)info->par;
#line 177
  pal = (u32 *)(& par->pseudo_palette);
#line 179
  if (regno > 15U) {
#line 180
    drm_err("vmw_fb_setcolreg", "Bad regno %u.\n", regno);
#line 181
    return (1);
  } else {

  }
#line 184
  switch (par->depth) {
  case 24U: ;
  case 32U: 
#line 187
  *(pal + (unsigned long )regno) = (((red & 65280U) << 8) | (green & 65280U)) | ((blue & 65280U) >> 8);
#line 190
  goto ldv_39040;
  default: 
#line 192
  drm_err("vmw_fb_setcolreg", "Bad depth %u, bpp %u.\n", par->depth, par->bpp);
#line 193
  return (1);
  }
  ldv_39040: ;
#line 196
  return (0);
}
}
#line 199 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_check_var(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 
  int depth ;
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 202
  depth = (int )var->bits_per_pixel;
#line 203
  par = (struct vmw_fb_par *)info->par;
#line 204
  vmw_priv___0 = par->vmw_priv;
#line 206
  switch (var->bits_per_pixel) {
  case (__u32 )32: 
#line 208
  depth = var->transp.length != 0U ? 32 : 24;
#line 209
  goto ldv_39050;
  default: 
#line 211
  drm_err("vmw_fb_check_var", "Bad bpp %u.\n", var->bits_per_pixel);
#line 212
  return (-22);
  }
  ldv_39050: ;
#line 215
  switch (depth) {
  case 24: 
#line 217
  var->red.offset = 16U;
#line 218
  var->green.offset = 8U;
#line 219
  var->blue.offset = 0U;
#line 220
  var->red.length = 8U;
#line 221
  var->green.length = 8U;
#line 222
  var->blue.length = 8U;
#line 223
  var->transp.length = 0U;
#line 224
  var->transp.offset = 0U;
#line 225
  goto ldv_39054;
  case 32: 
#line 227
  var->red.offset = 16U;
#line 228
  var->green.offset = 8U;
#line 229
  var->blue.offset = 0U;
#line 230
  var->red.length = 8U;
#line 231
  var->green.length = 8U;
#line 232
  var->blue.length = 8U;
#line 233
  var->transp.length = 8U;
#line 234
  var->transp.offset = 24U;
#line 235
  goto ldv_39054;
  default: 
#line 237
  drm_err("vmw_fb_check_var", "Bad depth %u.\n", depth);
#line 238
  return (-22);
  }
  ldv_39054: ;
#line 241
  if ((vmw_priv___0->capabilities & 524288U) == 0U && (var->xoffset != 0U || var->yoffset != 0U)) {
#line 243
    drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
#line 244
    return (-22);
  } else {

  }
#line 247
  if (var->xoffset + var->xres > par->max_width || var->yoffset + var->yres > par->max_height) {
#line 249
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 250
    return (-22);
  } else {

  }
#line 253
  tmp = vmw_kms_validate_mode_vram(vmw_priv___0, info->fix.line_length, var->yoffset + var->yres);
#line 253
  if (tmp) {
#line 253
    tmp___0 = 0;
  } else {
#line 253
    tmp___0 = 1;
  }
#line 253
  if (tmp___0) {
#line 256
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 257
    return (-22);
  } else {

  }
#line 260
  return (0);
}
}
#line 263 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_set_par(struct fb_info *info ) 
{ 
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  int ret ;
  int __ret_warn_on ;
  uint32_t tmp ;
  long tmp___0 ;

  {
#line 265
  par = (struct vmw_fb_par *)info->par;
#line 266
  vmw_priv___0 = par->vmw_priv;
#line 269
  ret = vmw_kms_write_svga(vmw_priv___0, info->var.xres, info->var.yres, info->fix.line_length,
                           par->bpp, par->depth);
#line 272
  if (ret != 0) {
#line 273
    return (ret);
  } else {

  }
#line 275
  if ((vmw_priv___0->capabilities & 524288U) != 0U) {
#line 277
    vmw_write(vmw_priv___0, 34U, 1U);
#line 278
    vmw_write(vmw_priv___0, 35U, 0U);
#line 279
    vmw_write(vmw_priv___0, 36U, 1U);
#line 280
    vmw_write(vmw_priv___0, 37U, info->var.xoffset);
#line 281
    vmw_write(vmw_priv___0, 38U, info->var.yoffset);
#line 282
    vmw_write(vmw_priv___0, 39U, info->var.xres);
#line 283
    vmw_write(vmw_priv___0, 40U, info->var.yres);
#line 284
    vmw_write(vmw_priv___0, 35U, 4294967295U);
  } else {

  }
#line 290
  tmp = vmw_read(vmw_priv___0, 14U);
#line 290
  __ret_warn_on = tmp != 0U;
#line 290
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 290
  if (tmp___0 != 0L) {
#line 290
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared",
                       290);
  } else {

  }
#line 290
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 292
  return (0);
}
}
#line 295 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_pan_display(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 


  {
#line 298
  return (0);
}
}
#line 301 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_blank(int blank , struct fb_info *info ) 
{ 


  {
#line 303
  return (0);
}
}
#line 310 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_flush(struct vmw_fb_par *par ) 
{ 
  struct vmw_private *vmw_priv___0 ;
  struct fb_info *info ;
  int stride ;
  int *src ;
  __le32 *vram_mem ;
  unsigned long flags ;
  unsigned int x ;
  unsigned int y ;
  unsigned int w ;
  unsigned int h ;
  int i ;
  int k ;
  struct __anonstruct_cmd_280 *cmd ;
  raw_spinlock_t *tmp ;
  unsigned int _min1 ;
  __u32 _min2 ;
  unsigned int _min1___0 ;
  __u32 _min2___0 ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 312
  vmw_priv___0 = par->vmw_priv;
#line 313
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 314
  stride = (int )(info->fix.line_length / 4U);
#line 315
  src = (int *)info->screen_base;
#line 316
  vram_mem = (__le32 *)par->bo_ptr;
#line 325
  if ((int )vmw_priv___0->suspended) {
#line 326
    return;
  } else {

  }
#line 328
  tmp = spinlock_check(& par->dirty.lock);
#line 328
  flags = _raw_spin_lock_irqsave(tmp);
#line 329
  if (! par->dirty.active) {
#line 330
    spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 331
    return;
  } else {

  }
#line 333
  x = par->dirty.x1;
#line 334
  y = par->dirty.y1;
#line 335
  _min1 = par->dirty.x2;
#line 335
  _min2 = info->var.xres;
#line 335
  w = (_min1 < _min2 ? _min1 : _min2) - x;
#line 336
  _min1___0 = par->dirty.y2;
#line 336
  _min2___0 = info->var.yres;
#line 336
  h = (_min1___0 < _min2___0 ? _min1___0 : _min2___0) - y;
#line 337
  tmp___0 = 0U;
#line 337
  par->dirty.x2 = tmp___0;
#line 337
  par->dirty.x1 = tmp___0;
#line 338
  tmp___1 = 0U;
#line 338
  par->dirty.y2 = tmp___1;
#line 338
  par->dirty.y1 = tmp___1;
#line 339
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 341
  i = (int )(y * (unsigned int )stride);
#line 341
  goto ldv_39105;
  ldv_39104: 
#line 342
  k = (int )((unsigned int )i + x);
#line 342
  goto ldv_39102;
  ldv_39101: 
#line 343
  iowrite32((u32 )*(src + (unsigned long )k), (void *)vram_mem + (unsigned long )k);
#line 342
  k = k + 1;
  ldv_39102: ;
#line 342
  if ((unsigned int )k < ((unsigned int )i + x) + w && (__u32 )k < info->fix.smem_len / 4U) {
#line 343
    goto ldv_39101;
  } else {

  }
#line 341
  i = i + stride;
  ldv_39105: ;
#line 341
  if ((__u32 )i < info->fix.smem_len / 4U) {
#line 342
    goto ldv_39104;
  } else {

  }
#line 350
  tmp___2 = vmw_fifo_reserve(vmw_priv___0, 20U);
#line 350
  cmd = (struct __anonstruct_282___0 *)tmp___2;
#line 351
  tmp___3 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_280 *)0),
                             0L);
#line 351
  if (tmp___3 != 0L) {
#line 352
    drm_err("vmw_fb_dirty_flush", "Fifo reserve failed.\n");
#line 353
    return;
  } else {

  }
#line 356
  cmd->header = 1U;
#line 357
  cmd->body.x = x;
#line 358
  cmd->body.y = y;
#line 359
  cmd->body.width = w;
#line 360
  cmd->body.height = h;
#line 361
  vmw_fifo_commit(vmw_priv___0, 20U);
#line 362
  return;
}
}
#line 364 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_mark(struct vmw_fb_par *par , unsigned int x1 , unsigned int y1 ,
                              unsigned int width , unsigned int height ) 
{ 
  struct fb_info *info ;
  unsigned long flags ;
  unsigned int x2 ;
  unsigned int y2 ;
  raw_spinlock_t *tmp ;

  {
#line 368
  info = (struct fb_info *)(par->vmw_priv)->fb_info;
#line 370
  x2 = x1 + width;
#line 371
  y2 = y1 + height;
#line 373
  tmp = spinlock_check(& par->dirty.lock);
#line 373
  flags = _raw_spin_lock_irqsave(tmp);
#line 374
  if (par->dirty.x1 == par->dirty.x2) {
#line 375
    par->dirty.x1 = x1;
#line 376
    par->dirty.y1 = y1;
#line 377
    par->dirty.x2 = x2;
#line 378
    par->dirty.y2 = y2;
#line 381
    if ((int )par->dirty.active) {
#line 382
      schedule_delayed_work(& info->deferred_work, 8UL);
    } else {

    }
  } else {
#line 384
    if (par->dirty.x1 > x1) {
#line 385
      par->dirty.x1 = x1;
    } else {

    }
#line 386
    if (par->dirty.y1 > y1) {
#line 387
      par->dirty.y1 = y1;
    } else {

    }
#line 388
    if (par->dirty.x2 < x2) {
#line 389
      par->dirty.x2 = x2;
    } else {

    }
#line 390
    if (par->dirty.y2 < y2) {
#line 391
      par->dirty.y2 = y2;
    } else {

    }
  }
#line 393
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 394
  return;
}
}
#line 396 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_deferred_io(struct fb_info *info , struct list_head *pagelist ) 
{ 
  struct vmw_fb_par *par ;
  unsigned long start ;
  unsigned long end ;
  unsigned long min ;
  unsigned long max ;
  unsigned long flags ;
  struct page *page ;
  int y1 ;
  int y2 ;
  struct list_head  const  *__mptr ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp ;

  {
#line 399
  par = (struct vmw_fb_par *)info->par;
#line 405
  min = 0xffffffffffffffffUL;
#line 406
  max = 0UL;
#line 407
  __mptr = (struct list_head  const  *)pagelist->next;
#line 407
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 407
  goto ldv_39146;
  ldv_39145: 
#line 408
  start = page->ldv_20264.ldv_20249.index << 12;
#line 409
  end = start + 4095UL;
#line 410
  _min1 = min;
#line 410
  _min2 = start;
#line 410
  min = _min1 < _min2 ? _min1 : _min2;
#line 411
  _max1 = max;
#line 411
  _max2 = end;
#line 411
  max = _max1 > _max2 ? _max1 : _max2;
#line 407
  __mptr___0 = (struct list_head  const  *)page->ldv_20272.lru.next;
#line 407
  page = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
  ldv_39146: ;
#line 407
  if ((unsigned long )(& page->ldv_20272.lru) != (unsigned long )pagelist) {
#line 408
    goto ldv_39145;
  } else {

  }

#line 414
  if (min < max) {
#line 415
    y1 = (int )(min / (unsigned long )info->fix.line_length);
#line 416
    y2 = (int )((unsigned int )(max / (unsigned long )info->fix.line_length) + 1U);
#line 418
    tmp = spinlock_check(& par->dirty.lock);
#line 418
    flags = _raw_spin_lock_irqsave(tmp);
#line 419
    par->dirty.x1 = 0U;
#line 420
    par->dirty.y1 = (unsigned int )y1;
#line 421
    par->dirty.x2 = info->var.xres;
#line 422
    par->dirty.y2 = (unsigned int )y2;
#line 423
    spin_unlock_irqrestore(& par->dirty.lock, flags);
  } else {

  }
#line 426
  vmw_fb_dirty_flush(par);
#line 427
  return;
}
}
#line 429 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_deferred_io vmw_defio  =    {8UL, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
    {0, 0}, 0, & vmw_deferred_io};
#line 438 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_fillrect(struct fb_info *info , struct fb_fillrect  const  *rect ) 
{ 


  {
#line 440
  cfb_fillrect(info, rect);
#line 441
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, rect->dx, rect->dy, rect->width,
                    rect->height);
#line 443
  return;
}
}
#line 445 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ 


  {
#line 447
  cfb_copyarea(info, region);
#line 448
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, region->dx, region->dy, region->width,
                    region->height);
#line 450
  return;
}
}
#line 452 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_imageblit(struct fb_info *info , struct fb_image  const  *image ) 
{ 


  {
#line 454
  cfb_imageblit(info, image);
#line 455
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, image->dx, image->dy, image->width,
                    image->height);
#line 457
  return;
}
}
#line 463 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static struct fb_ops vmw_fb_ops  = 
#line 463
     {& __this_module, 0, 0, 0, 0, & vmw_fb_check_var, & vmw_fb_set_par, & vmw_fb_setcolreg,
    0, & vmw_fb_blank, & vmw_fb_pan_display, & vmw_fb_fillrect, & vmw_fb_copyarea,
    & vmw_fb_imageblit, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 475 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_create_bo(struct vmw_private *vmw_priv___0 , size_t size , struct vmw_dma_buffer **out ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct ttm_placement ne_placement ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 479
  ne_placement = vmw_vram_ne_placement;
#line 482
  ne_placement.lpfn = (unsigned int )((size + 4095UL) >> 12);
#line 485
  ret = ttm_write_lock(& vmw_priv___0->fbdev_master.lock, 0);
#line 486
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 486
  if (tmp != 0L) {
#line 487
    return (ret);
  } else {

  }
#line 489
  tmp___0 = kmalloc(472UL, 208U);
#line 489
  vmw_bo = (struct vmw_dma_buffer *)tmp___0;
#line 490
  if ((unsigned long )vmw_bo == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 491
    goto err_unlock;
  } else {

  }
#line 493
  ret = vmw_dmabuf_init(vmw_priv___0, vmw_bo, size, & ne_placement, 0, & vmw_dmabuf_bo_free);
#line 497
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 497
  if (tmp___1 != 0L) {
#line 498
    goto err_unlock;
  } else {

  }
#line 500
  *out = vmw_bo;
#line 502
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 504
  return (0);
  err_unlock: 
#line 507
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 508
  return (ret);
}
}
#line 511 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) 
{ 
  struct device *device ;
  struct vmw_fb_par *par ;
  struct fb_info *info ;
  unsigned int initial_width ;
  unsigned int initial_height ;
  unsigned int fb_width ;
  unsigned int fb_height ;
  unsigned int fb_bpp ;
  unsigned int fb_depth ;
  unsigned int fb_offset ;
  unsigned int fb_pitch ;
  unsigned int fb_size ;
  int ret ;
  uint32_t _min1 ;
  unsigned int _min2 ;
  uint32_t _min1___0 ;
  unsigned int _min2___0 ;
  uint32_t _min1___1 ;
  unsigned int _min2___1 ;
  uint32_t _min1___2 ;
  unsigned int _min2___2 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  struct lock_class_key __key ;
  long tmp___4 ;

  {
#line 513
  device = & ((vmw_priv___0->dev)->pdev)->dev;
#line 521
  fb_bpp = 32U;
#line 522
  fb_depth = 24U;
#line 525
  _min1 = vmw_priv___0->fb_max_width;
#line 525
  _min2 = 2048U;
#line 525
  fb_width = _min1 < _min2 ? _min1 : _min2;
#line 526
  _min1___0 = vmw_priv___0->fb_max_height;
#line 526
  _min2___0 = 2048U;
#line 526
  fb_height = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 528
  _min1___1 = vmw_priv___0->initial_width;
#line 528
  _min2___1 = fb_width;
#line 528
  initial_width = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 529
  _min1___2 = vmw_priv___0->initial_height;
#line 529
  _min2___2 = fb_height;
#line 529
  initial_height = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
#line 531
  fb_pitch = (fb_width * fb_bpp) / 8U;
#line 532
  fb_size = fb_pitch * fb_height;
#line 533
  fb_offset = vmw_read(vmw_priv___0, 14U);
#line 535
  info = framebuffer_alloc(256UL, device);
#line 536
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
#line 537
    return (-12);
  } else {

  }
#line 542
  vmw_priv___0->fb_info = (void *)info;
#line 543
  par = (struct vmw_fb_par *)info->par;
#line 544
  par->vmw_priv = vmw_priv___0;
#line 545
  par->depth = fb_depth;
#line 546
  par->bpp = fb_bpp;
#line 547
  par->vmalloc = 0;
#line 548
  par->max_width = fb_width;
#line 549
  par->max_height = fb_height;
#line 554
  par->vmalloc = vmalloc((unsigned long )fb_size);
#line 555
  tmp = ldv__builtin_expect((unsigned long )par->vmalloc == (unsigned long )((void *)0),
                         0L);
#line 555
  if (tmp != 0L) {
#line 556
    ret = -12;
#line 557
    goto err_free;
  } else {

  }
#line 560
  ret = vmw_fb_create_bo(vmw_priv___0, (size_t )fb_size, & par->vmw_bo);
#line 561
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 561
  if (tmp___0 != 0L) {
#line 562
    goto err_free;
  } else {

  }
#line 564
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 568
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 568
  if (tmp___1 != 0L) {
#line 569
    goto err_unref;
  } else {

  }
#line 570
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & par->bo_iowrite);
#line 571
  par->bo_size = fb_size;
#line 576
  strcpy((char *)(& info->fix.id), "svgadrmfb");
#line 577
  info->fix.type = 0U;
#line 578
  info->fix.visual = 2U;
#line 579
  info->fix.type_aux = 0U;
#line 580
  info->fix.xpanstep = 1U;
#line 581
  info->fix.ypanstep = 1U;
#line 582
  info->fix.ywrapstep = 0U;
#line 583
  info->fix.accel = 0U;
#line 584
  info->fix.line_length = fb_pitch;
#line 586
  info->fix.smem_start = 0UL;
#line 587
  info->fix.smem_len = fb_size;
#line 589
  info->pseudo_palette = (void *)(& par->pseudo_palette);
#line 590
  info->screen_base = (char *)par->vmalloc;
#line 591
  info->screen_size = (unsigned long )fb_size;
#line 593
  info->flags = 1;
#line 594
  info->fbops = & vmw_fb_ops;
#line 597
  info->var.red.offset = 16U;
#line 598
  info->var.green.offset = 8U;
#line 599
  info->var.blue.offset = 0U;
#line 600
  info->var.red.length = 8U;
#line 601
  info->var.green.length = 8U;
#line 602
  info->var.blue.length = 8U;
#line 603
  info->var.transp.offset = 0U;
#line 604
  info->var.transp.length = 0U;
#line 606
  info->var.xres_virtual = fb_width;
#line 607
  info->var.yres_virtual = fb_height;
#line 608
  info->var.bits_per_pixel = par->bpp;
#line 609
  info->var.xoffset = 0U;
#line 610
  info->var.yoffset = 0U;
#line 611
  info->var.activate = 0U;
#line 612
  info->var.height = 4294967295U;
#line 613
  info->var.width = 4294967295U;
#line 615
  info->var.xres = initial_width;
#line 616
  info->var.yres = initial_height;
#line 620
  info->apertures = alloc_apertures(1U);
#line 621
  if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
#line 622
    ret = -12;
#line 623
    goto err_aper;
  } else {

  }
#line 625
  (info->apertures)->ranges[0].base = (resource_size_t )vmw_priv___0->vram_start;
#line 626
  (info->apertures)->ranges[0].size = (resource_size_t )vmw_priv___0->vram_size;
#line 631
  tmp___2 = 0U;
#line 631
  par->dirty.x2 = tmp___2;
#line 631
  par->dirty.x1 = tmp___2;
#line 632
  tmp___3 = 0U;
#line 632
  par->dirty.y2 = tmp___3;
#line 632
  par->dirty.y1 = tmp___3;
#line 633
  par->dirty.active = 1;
#line 634
  spinlock_check(& par->dirty.lock);
#line 634
  __raw_spin_lock_init(& par->dirty.lock.ldv_5988.rlock, "&(&par->dirty.lock)->rlock",
                       & __key);
#line 635
  info->fbdefio = & vmw_defio;
#line 636
  fb_deferred_io_init(info);
#line 638
  ret = register_framebuffer(info);
#line 639
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 639
  if (tmp___4 != 0L) {
#line 640
    goto err_defio;
  } else {

  }
#line 642
  return (0);
  err_defio: 
#line 645
  fb_deferred_io_cleanup(info);
  err_aper: 
#line 647
  ttm_bo_kunmap(& par->map);
  err_unref: 
#line 649
  ttm_bo_unref((struct ttm_buffer_object **)(& par->vmw_bo));
  err_free: 
#line 651
  vfree((void const   *)par->vmalloc);
#line 652
  framebuffer_release(info);
#line 653
  vmw_priv___0->fb_info = 0;
#line 655
  return (ret);
}
}
#line 658 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  struct ttm_buffer_object *bo ;

  {
#line 664
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 665
    return (0);
  } else {

  }
#line 667
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 668
  par = (struct vmw_fb_par *)info->par;
#line 669
  bo = & (par->vmw_bo)->base;
#line 670
  par->vmw_bo = 0;
#line 673
  fb_deferred_io_cleanup(info);
#line 674
  unregister_framebuffer(info);
#line 676
  ttm_bo_kunmap(& par->map);
#line 677
  ttm_bo_unref(& bo);
#line 679
  vfree((void const   *)par->vmalloc);
#line 680
  framebuffer_release(info);
#line 682
  return (0);
}
}
#line 685 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 691
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 692
    return (-22);
  } else {

  }
#line 694
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 695
  par = (struct vmw_fb_par *)info->par;
#line 697
  tmp = spinlock_check(& par->dirty.lock);
#line 697
  flags = _raw_spin_lock_irqsave(tmp);
#line 698
  par->dirty.active = 0;
#line 699
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 701
  flush_delayed_work_sync(& info->deferred_work);
#line 703
  par->bo_ptr = 0;
#line 704
  ttm_bo_kunmap(& par->map);
#line 706
  vmw_dmabuf_unpin(vmw_priv___0, par->vmw_bo, 0);
#line 708
  return (0);
}
}
#line 711 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) 
{ 
  struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 719
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 720
    return (-22);
  } else {

  }
#line 722
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 723
  par = (struct vmw_fb_par *)info->par;
#line 726
  if ((unsigned long )par->bo_ptr != (unsigned long )((void *)0)) {
#line 727
    return (0);
  } else {

  }
#line 730
  vmw_overlay_stop_all(vmw_priv___0);
#line 732
  ret = vmw_dmabuf_to_start_of_vram(vmw_priv___0, par->vmw_bo, 1, 0);
#line 733
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 733
  if (tmp != 0L) {
#line 734
    drm_err("vmw_fb_on", "could not move buffer to start of VRAM\n");
#line 735
    goto err_no_buffer;
  } else {

  }
#line 738
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 742
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 742
  if (tmp___0 != 0L) {
#line 742
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"),
                         "i" (742), "i" (12UL));
    ldv_39232: ;
#line 742
    goto ldv_39232;
  } else {

  }
#line 743
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & dummy);
#line 745
  tmp___1 = spinlock_check(& par->dirty.lock);
#line 745
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 746
  par->dirty.active = 1;
#line 747
  spin_unlock_irqrestore(& par->dirty.lock, flags);
  err_no_buffer: 
#line 750
  vmw_fb_set_par(info);
#line 752
  vmw_fb_dirty_mark(par, 0U, 0U, info->var.xres, info->var.yres);
#line 756
  schedule_delayed_work(& info->deferred_work, 0UL);
#line 758
  return (0);
}
}
#line 798 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_main4_sequence_infinite_withcheck_stateful(void) 
{ 
  struct fb_info *var_group1 ;
  struct list_head *var_group2 ;
  struct fb_var_screeninfo *var_group3 ;
  unsigned int var_vmw_fb_setcolreg_0_p0 ;
  unsigned int var_vmw_fb_setcolreg_0_p1 ;
  unsigned int var_vmw_fb_setcolreg_0_p2 ;
  unsigned int var_vmw_fb_setcolreg_0_p3 ;
  unsigned int var_vmw_fb_setcolreg_0_p4 ;
  struct fb_info *var_vmw_fb_setcolreg_0_p5 ;
  struct fb_fillrect  const  *var_vmw_fb_fillrect_8_p1 ;
  struct fb_copyarea  const  *var_vmw_fb_copyarea_9_p1 ;
  struct fb_image  const  *var_vmw_fb_imageblit_10_p1 ;
  int var_vmw_fb_blank_4_p0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 904
  LDV_IN_INTERRUPT = 1;
#line 913
  ldv_initialize();
#line 919
  goto ldv_39277;
  ldv_39276: 
#line 922
  tmp = __VERIFIER_nondet_int();
#line 922
  switch (tmp) {
  case 0: 
#line 936
  ldv_handler_precall();
#line 937
  vmw_deferred_io(var_group1, var_group2);
#line 944
  goto ldv_39266;
  case 1: 
#line 955
  ldv_handler_precall();
#line 956
  vmw_fb_check_var(var_group3, var_group1);
#line 967
  goto ldv_39266;
  case 2: 
#line 978
  ldv_handler_precall();
#line 979
  vmw_fb_set_par(var_group1);
#line 990
  goto ldv_39266;
  case 3: 
#line 1001
  ldv_handler_precall();
#line 1002
  vmw_fb_setcolreg(var_vmw_fb_setcolreg_0_p0, var_vmw_fb_setcolreg_0_p1, var_vmw_fb_setcolreg_0_p2,
                   var_vmw_fb_setcolreg_0_p3, var_vmw_fb_setcolreg_0_p4, var_vmw_fb_setcolreg_0_p5);
#line 1013
  goto ldv_39266;
  case 4: 
#line 1026
  ldv_handler_precall();
#line 1027
  vmw_fb_fillrect(var_group1, var_vmw_fb_fillrect_8_p1);
#line 1034
  goto ldv_39266;
  case 5: 
#line 1047
  ldv_handler_precall();
#line 1048
  vmw_fb_copyarea(var_group1, var_vmw_fb_copyarea_9_p1);
#line 1055
  goto ldv_39266;
  case 6: 
#line 1068
  ldv_handler_precall();
#line 1069
  vmw_fb_imageblit(var_group1, var_vmw_fb_imageblit_10_p1);
#line 1076
  goto ldv_39266;
  case 7: 
#line 1087
  ldv_handler_precall();
#line 1088
  vmw_fb_pan_display(var_group3, var_group1);
#line 1099
  goto ldv_39266;
  case 8: 
#line 1110
  ldv_handler_precall();
#line 1111
  vmw_fb_blank(var_vmw_fb_blank_4_p0, var_group1);
#line 1122
  goto ldv_39266;
  default: ;
#line 1123
  goto ldv_39266;
  }
  ldv_39266: ;
  ldv_39277: 
#line 919
  tmp___0 = __VERIFIER_nondet_int();
#line 919
  if (tmp___0 != 0) {
#line 920
    goto ldv_39276;
  } else {

  }


#line 1132
  ldv_check_final_state();
#line 1135
  return;
}
}
#line 1139 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1144
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1146
  mutex_lock(ldv_func_arg1);
#line 1147
  return;
}
}
#line 1149 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int ldv_mutex_trylock_178(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1154
  tmp = mutex_trylock(ldv_func_arg1);
#line 1154
  ldv_func_res = tmp;
#line 1156
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1156
  return (tmp___0);
#line 1158
  return (ldv_func_res);
}
}
#line 1161 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_179(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1166
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1168
  mutex_unlock(ldv_func_arg1);
#line 1169
  return;
}
}
#line 1171 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_180(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1176
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1178
  mutex_lock(ldv_func_arg1);
#line 1179
  return;
}
}
#line 1181 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1186
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1188
  mutex_unlock(ldv_func_arg1);
#line 1189
  return;
}
}
#line 1191 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_182(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1196
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1198
  mutex_lock(ldv_func_arg1);
#line 1199
  return;
}
}
#line 1201 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_183(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1206
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1208
  mutex_unlock(ldv_func_arg1);
#line 1209
  return;
}
}
#line 1211 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_184(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1216
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1218
  mutex_unlock(ldv_func_arg1);
#line 1219
  return;
}
}
#line 1221 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_185(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1226
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1228
  mutex_lock(ldv_func_arg1);
#line 1229
  return;
}
}
#line 1231 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1236
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1238
  mutex_unlock(ldv_func_arg1);
#line 1239
  return;
}
}
#line 1241 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1246
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1248
  mutex_lock(ldv_func_arg1);
#line 1249
  return;
}
}
#line 1251 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1256
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1258
  mutex_unlock(ldv_func_arg1);
#line 1259
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_202(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) ;
#line 8 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_213(struct mutex *ldv_func_arg1 ) ;
#line 12
int ldv_mutex_lock_interruptible_215(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_201(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_204(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_209(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_211(struct mutex *ldv_func_arg1 ) ;
#line 92
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) ;
#line 209 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 211
  __len = count;
#line 211
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 213
  return;
}
}
#line 1305 "include/drm/drmP.h"
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1314
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
#line 497 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) ;
#line 661
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) ;
#line 662
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) ;
#line 135 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_getparam_arg *param ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  __le32 *fifo_mem ;
  struct vmw_fifo_state  const  *fifo ;
  unsigned int tmp___3 ;

  {
#line 138
  tmp = vmw_priv(dev);
#line 138
  dev_priv = tmp;
#line 139
  param = (struct drm_vmw_getparam_arg *)data;
#line 142
  switch (param->param) {
  case (uint32_t )0: 
#line 144
  tmp___0 = vmw_overlay_num_overlays(dev_priv);
#line 144
  param->value = (uint64_t )tmp___0;
#line 145
  goto ldv_39259;
  case (uint32_t )1: 
#line 147
  tmp___1 = vmw_overlay_num_free_overlays(dev_priv);
#line 147
  param->value = (uint64_t )tmp___1;
#line 148
  goto ldv_39259;
  case (uint32_t )2: 
#line 150
  tmp___2 = vmw_fifo_have_3d(dev_priv);
#line 150
  param->value = (uint64_t )tmp___2;
#line 151
  goto ldv_39259;
  case (uint32_t )3: 
#line 153
  param->value = (uint64_t )dev_priv->capabilities;
#line 154
  goto ldv_39259;
  case (uint32_t )4: 
#line 156
  param->value = (uint64_t )dev_priv->fifo.capabilities;
#line 157
  goto ldv_39259;
  case (uint32_t )5: 
#line 159
  param->value = (uint64_t )dev_priv->vram_size;
#line 160
  goto ldv_39259;
  case (uint32_t )6: 
#line 163
  fifo_mem = dev_priv->mmio_virt;
#line 164
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 166
  tmp___3 = ioread32((void *)(fifo_mem + (((unsigned int )fifo->capabilities & 256U) != 0U ? 17UL : 7UL)));
#line 166
  param->value = (uint64_t )tmp___3;
#line 172
  goto ldv_39259;
  default: 
#line 175
  drm_err("vmw_getparam_ioctl", "Illegal vmwgfx get param request: %d\n", param->param);
#line 177
  return (-22);
  }
  ldv_39259: ;
#line 180
  return (0);
}
}
#line 184 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_get_3d_cap_arg *arg ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t size ;
  __le32 *fifo_mem ;
  void *buffer ;
  void *bounce ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 187
  arg = (struct drm_vmw_get_3d_cap_arg *)data;
#line 189
  tmp = vmw_priv(dev);
#line 189
  dev_priv = tmp;
#line 192
  buffer = (void *)arg->buffer;
#line 196
  tmp___0 = ldv__builtin_expect(arg->pad64 != 0U, 0L);
#line 196
  if (tmp___0 != 0L) {
#line 197
    drm_err("vmw_get_cap_3d_ioctl", "Illegal GET_3D_CAP argument.\n");
#line 198
    return (-22);
  } else {

  }
#line 201
  size = 1024U;
#line 203
  if (arg->max_size < size) {
#line 204
    size = arg->max_size;
  } else {

  }
#line 206
  bounce = vmalloc((unsigned long )size);
#line 207
  tmp___1 = ldv__builtin_expect((unsigned long )bounce == (unsigned long )((void *)0),
                             0L);
#line 207
  if (tmp___1 != 0L) {
#line 208
    drm_err("vmw_get_cap_3d_ioctl", "Failed to allocate bounce buffer for 3D caps.\n");
#line 209
    return (-12);
  } else {

  }
#line 212
  fifo_mem = dev_priv->mmio_virt;
#line 213
  memcpy_fromio(bounce, (void const volatile   *)fifo_mem + 32U, (size_t )size);
#line 215
  ret = copy_to_user(buffer, (void const   *)bounce, size);
#line 216
  vfree((void const   *)bounce);
#line 218
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 218
  if (tmp___2 != 0L) {
#line 219
    drm_err("vmw_get_cap_3d_ioctl", "Failed to report 3D caps info.\n");
  } else {

  }
#line 221
  return (ret);
}
}
#line 224 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct drm_vmw_present_arg *arg ;
  struct vmw_surface *surface ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___6 ;

  {
#line 227
  tmp = vmw_fpriv(file_priv);
#line 227
  tfile = tmp->tfile;
#line 228
  tmp___0 = vmw_priv(dev);
#line 228
  dev_priv = tmp___0;
#line 229
  arg = (struct drm_vmw_present_arg *)data;
#line 232
  tmp___1 = vmw_master(file_priv->master);
#line 232
  vmaster = tmp___1;
#line 234
  clips = 0;
#line 240
  num_clips = arg->num_clips;
#line 241
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 243
  tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 243
  if (tmp___2 != 0L) {
#line 244
    return (0);
  } else {

  }
#line 246
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 247
    drm_err("vmw_present_ioctl", "Variable clips_ptr must be specified.\n");
#line 248
    ret = -22;
#line 249
    goto out_clips;
  } else {

  }
#line 252
  tmp___3 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 252
  clips = (struct drm_vmw_rect *)tmp___3;
#line 253
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 254
    drm_err("vmw_present_ioctl", "Failed to allocate clip rect list.\n");
#line 255
    ret = -12;
#line 256
    goto out_clips;
  } else {

  }
#line 259
  tmp___4 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 259
  ret = (int )tmp___4;
#line 260
  if (ret != 0) {
#line 261
    drm_err("vmw_present_ioctl", "Failed to copy clip rects from userspace.\n");
#line 262
    ret = -14;
#line 263
    goto out_no_copy;
  } else {

  }
#line 266
  ret = ldv_mutex_lock_interruptible_213(& dev->mode_config.mutex);
#line 267
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 267
  if (tmp___5 != 0L) {
#line 268
    ret = -512;
#line 269
    goto out_no_mode_mutex;
  } else {

  }
#line 272
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 273
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 274
    drm_err("vmw_present_ioctl", "Invalid framebuffer id.\n");
#line 275
    ret = -22;
#line 276
    goto out_no_fb;
  } else {

  }
#line 278
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 278
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe8UL);
#line 278
  vfb = (struct vmw_framebuffer *)__mptr;
#line 280
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 281
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 281
  if (tmp___6 != 0L) {
#line 282
    goto out_no_ttm_lock;
  } else {

  }
#line 284
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, arg->sid, & surface);
#line 286
  if (ret != 0) {
#line 287
    goto out_no_surface;
  } else {

  }
#line 289
  ret = vmw_kms_present(dev_priv, file_priv, vfb, surface, arg->sid, arg->dest_x,
                        arg->dest_y, clips, num_clips);
#line 295
  vmw_surface_unreference(& surface);
  out_no_surface: 
#line 298
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 301
  ldv_mutex_unlock_214(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 304
  kfree((void const   *)clips);
  out_clips: ;
#line 306
  return (ret);
}
}
#line 309 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_present_readback_arg *arg ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  long tmp___4 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___5 ;

  {
#line 312
  tmp = vmw_priv(dev);
#line 312
  dev_priv = tmp;
#line 313
  arg = (struct drm_vmw_present_readback_arg *)data;
#line 315
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 318
  tmp___0 = vmw_master(file_priv->master);
#line 318
  vmaster = tmp___0;
#line 320
  clips = 0;
#line 326
  num_clips = arg->num_clips;
#line 327
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 329
  tmp___1 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 329
  if (tmp___1 != 0L) {
#line 330
    return (0);
  } else {

  }
#line 332
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 333
    drm_err("vmw_present_readback_ioctl", "Argument clips_ptr must be specified.\n");
#line 334
    ret = -22;
#line 335
    goto out_clips;
  } else {

  }
#line 338
  tmp___2 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 338
  clips = (struct drm_vmw_rect *)tmp___2;
#line 339
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 340
    drm_err("vmw_present_readback_ioctl", "Failed to allocate clip rect list.\n");
#line 341
    ret = -12;
#line 342
    goto out_clips;
  } else {

  }
#line 345
  tmp___3 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 345
  ret = (int )tmp___3;
#line 346
  if (ret != 0) {
#line 347
    drm_err("vmw_present_readback_ioctl", "Failed to copy clip rects from userspace.\n");
#line 348
    ret = -14;
#line 349
    goto out_no_copy;
  } else {

  }
#line 352
  ret = ldv_mutex_lock_interruptible_215(& dev->mode_config.mutex);
#line 353
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 353
  if (tmp___4 != 0L) {
#line 354
    ret = -512;
#line 355
    goto out_no_mode_mutex;
  } else {

  }
#line 358
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 359
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 360
    drm_err("vmw_present_readback_ioctl", "Invalid framebuffer id.\n");
#line 361
    ret = -22;
#line 362
    goto out_no_fb;
  } else {

  }
#line 365
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 365
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe8UL);
#line 365
  vfb = (struct vmw_framebuffer *)__mptr;
#line 366
  if (! vfb->dmabuf) {
#line 367
    drm_err("vmw_present_readback_ioctl", "Framebuffer not dmabuf backed.\n");
#line 368
    ret = -22;
#line 369
    goto out_no_fb;
  } else {

  }
#line 372
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 373
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 373
  if (tmp___5 != 0L) {
#line 374
    goto out_no_ttm_lock;
  } else {

  }
#line 376
  ret = vmw_kms_readback(dev_priv, file_priv, vfb, user_fence_rep, clips, num_clips);
#line 380
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 383
  ldv_mutex_unlock_216(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 386
  kfree((void const   *)clips);
  out_clips: ;
#line 388
  return (ret);
}
}
#line 401 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  unsigned int tmp___0 ;

  {
#line 403
  file_priv = (struct drm_file *)filp->private_data;
#line 404
  tmp = vmw_priv((file_priv->minor)->dev);
#line 404
  dev_priv = tmp;
#line 407
  vmw_fifo_ping_host(dev_priv, 1U);
#line 408
  tmp___0 = drm_poll(filp, wait);
#line 408
  return (tmp___0);
}
}
#line 423 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  ssize_t tmp___0 ;

  {
#line 426
  file_priv = (struct drm_file *)filp->private_data;
#line 427
  tmp = vmw_priv((file_priv->minor)->dev);
#line 427
  dev_priv = tmp;
#line 430
  vmw_fifo_ping_host(dev_priv, 1U);
#line 431
  tmp___0 = drm_read(filp, buffer, count, offset);
#line 431
  return (tmp___0);
}
}
#line 434 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 439
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 441
  mutex_lock(ldv_func_arg1);
#line 442
  return;
}
}
#line 444 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_trylock_202(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 449
  tmp = mutex_trylock(ldv_func_arg1);
#line 449
  ldv_func_res = tmp;
#line 451
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 451
  return (tmp___0);
#line 453
  return (ldv_func_res);
}
}
#line 456 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 461
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 463
  mutex_unlock(ldv_func_arg1);
#line 464
  return;
}
}
#line 466 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_204(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 471
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 473
  mutex_lock(ldv_func_arg1);
#line 474
  return;
}
}
#line 476 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 481
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 483
  mutex_unlock(ldv_func_arg1);
#line 484
  return;
}
}
#line 486 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 493
  mutex_lock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 501
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 503
  mutex_unlock(ldv_func_arg1);
#line 504
  return;
}
}
#line 506 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 511
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 513
  mutex_unlock(ldv_func_arg1);
#line 514
  return;
}
}
#line 516 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_209(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 521
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 523
  mutex_lock(ldv_func_arg1);
#line 524
  return;
}
}
#line 526 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 531
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 533
  mutex_unlock(ldv_func_arg1);
#line 534
  return;
}
}
#line 536 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_211(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 541
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 543
  mutex_lock(ldv_func_arg1);
#line 544
  return;
}
}
#line 546 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 551
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 553
  mutex_unlock(ldv_func_arg1);
#line 554
  return;
}
}
#line 556 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_213(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 561
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 561
  ldv_func_res = tmp;
#line 563
  tmp___0 = ldv_mutex_lock_interruptible_mutex(ldv_func_arg1);
#line 563
  return (tmp___0);
#line 565
  return (ldv_func_res);
}
}
#line 568 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 573
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 575
  mutex_unlock(ldv_func_arg1);
#line 576
  return;
}
}
#line 578 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_215(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 583
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 583
  ldv_func_res = tmp;
#line 585
  tmp___0 = ldv_mutex_lock_interruptible_mutex(ldv_func_arg1);
#line 585
  return (tmp___0);
#line 587
  return (ldv_func_res);
}
}
#line 590 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_216(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 595
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 597
  mutex_unlock(ldv_func_arg1);
#line 598
  return;
}
}
#line 77 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 81
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; subl %2,%0; sete %1": "+m" (v->counter),
                       "=qm" (c): "ir" (i): "memory");
#line 84
  return ((int )c);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_234(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_235(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_237(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_236(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_241(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) ;
#line 18 "include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t * ) ;
#line 19
extern void _raw_write_lock(rwlock_t * ) ;
#line 30
extern void _raw_read_unlock(rwlock_t * ) ;
#line 31
extern void _raw_write_unlock(rwlock_t * ) ;
#line 30 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 32
  atomic_set(& kref->refcount, 1);
#line 33
  return;
}
}
#line 63 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 66
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 66
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
  if (tmp != 0L) {
#line 66
    warn_slowpath_null("include/linux/kref.h", 66);
  } else {

  }
#line 66
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 68
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 68
  if (tmp___0 != 0) {
#line 69
    (*release)(kref);
#line 70
    return (1);
  } else {

  }
#line 72
  return (0);
}
}
#line 92 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 94
  tmp = kref_sub(kref, 1U, release);
#line 94
  return (tmp);
}
}
#line 104 "include/linux/idr.h"
extern void *idr_find(struct idr * , int  ) ;
#line 105
extern int idr_pre_get(struct idr * , gfp_t  ) ;
#line 107
extern int idr_get_new_above(struct idr * , void * , int  , int * ) ;
#line 112
extern void idr_remove(struct idr * , int  ) ;
#line 459 "include/drm/ttm/ttm_bo_api.h"
extern size_t ttm_bo_acc_size(struct ttm_bo_device * , unsigned long  , unsigned int  ) ;
#line 502
extern int ttm_bo_init(struct ttm_bo_device * , struct ttm_buffer_object * , unsigned long  ,
                       enum ttm_bo_type  , struct ttm_placement * , uint32_t  , unsigned long  ,
                       bool  , struct file * , size_t  , struct sg_table * , void (*)(struct ttm_buffer_object * ) ) ;
#line 150 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_alloc(struct ttm_mem_global * , uint64_t  , bool  , bool  ) ;
#line 152
extern void ttm_mem_global_free(struct ttm_mem_global * , uint64_t  ) ;
#line 159
extern size_t ttm_round_pot(size_t  ) ;
#line 147 "include/drm/ttm/ttm_object.h"
extern int ttm_base_object_init(struct ttm_object_file * , struct ttm_base_object * ,
                                bool  , enum ttm_object_type  , void (*)(struct ttm_base_object ** ) ,
                                void (*)(struct ttm_base_object * , enum ttm_ref_type  ) ) ;
#line 202
extern int ttm_ref_object_add(struct ttm_object_file * , struct ttm_base_object * ,
                              enum ttm_ref_type  , bool * ) ;
#line 385 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) ;
#line 401
void vmw_surface_res_free(struct vmw_resource *res ) ;
#line 402
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource * ) ) ;
#line 415
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) ;
#line 439
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) ;
#line 464
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) ;
#line 522
struct ttm_placement vmw_srf_placement ;
#line 659
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) ;
#line 660
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) ;
#line 705 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv ) 
{ 


  {
#line 707
  return ((struct ttm_mem_global *)dev_priv->mem_global_ref.object);
}
}
#line 175 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static uint64_t vmw_user_context_size  ;
#line 176 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static uint64_t vmw_user_surface_size  ;
#line 177 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static uint64_t vmw_user_stream_size  ;
#line 180 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo ) 
{ 
  struct ttm_buffer_object  const  *__mptr ;

  {
#line 182
  __mptr = (struct ttm_buffer_object  const  *)bo;
#line 182
  return ((struct vmw_dma_buffer *)__mptr);
}
}
#line 186 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;
  struct vmw_dma_buffer  const  *__mptr ;

  {
#line 188
  tmp = vmw_dma_buffer(bo);
#line 188
  vmw_bo = tmp;
#line 189
  __mptr = (struct vmw_dma_buffer  const  *)vmw_bo;
#line 189
  return ((struct vmw_user_dma_buffer *)__mptr + 0xffffffffffffffc0UL);
}
}
#line 192 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) 
{ 


  {
#line 194
  kref_get(& res->kref);
#line 195
  return (res);
}
}
#line 206 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_release_id(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;

  {
#line 208
  dev_priv = res->dev_priv;
#line 210
  _raw_write_lock(& dev_priv->resource_lock);
#line 211
  if (res->id != -1) {
#line 212
    idr_remove(res->idr, res->id);
  } else {

  }
#line 213
  res->id = -1;
#line 214
  _raw_write_unlock(& dev_priv->resource_lock);
#line 215
  return;
}
}
#line 217 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_release(struct kref *kref ) 
{ 
  struct vmw_resource *res ;
  struct kref  const  *__mptr ;
  struct vmw_private *dev_priv ;
  int id ;
  struct idr *idr ;
  long tmp ;

  {
#line 220
  __mptr = (struct kref  const  *)kref;
#line 220
  res = (struct vmw_resource *)__mptr;
#line 221
  dev_priv = res->dev_priv;
#line 222
  id = res->id;
#line 223
  idr = res->idr;
#line 225
  res->avail = 0;
#line 226
  if ((unsigned long )res->remove_from_lists != (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 227
    (*(res->remove_from_lists))(res);
  } else {

  }
#line 228
  _raw_write_unlock(& dev_priv->resource_lock);
#line 230
  tmp = ldv__builtin_expect((unsigned long )res->hw_destroy != (unsigned long )((void (*)(struct vmw_resource * ))0),
                         1L);
#line 230
  if (tmp != 0L) {
#line 231
    (*(res->hw_destroy))(res);
  } else {

  }
#line 233
  if ((unsigned long )res->res_free != (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 234
    (*(res->res_free))(res);
  } else {
#line 236
    kfree((void const   *)res);
  }
#line 238
  _raw_write_lock(& dev_priv->resource_lock);
#line 240
  if (id != -1) {
#line 241
    idr_remove(idr, id);
  } else {

  }
#line 242
  return;
}
}
#line 244 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreference(struct vmw_resource **p_res ) 
{ 
  struct vmw_resource *res ;
  struct vmw_private *dev_priv ;

  {
#line 246
  res = *p_res;
#line 247
  dev_priv = res->dev_priv;
#line 249
  *p_res = 0;
#line 250
  _raw_write_lock(& dev_priv->resource_lock);
#line 251
  kref_put(& res->kref, & vmw_resource_release);
#line 252
  _raw_write_unlock(& dev_priv->resource_lock);
#line 253
  return;
}
}
#line 265 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_alloc_id(struct vmw_private *dev_priv , struct vmw_resource *res ) 
{ 
  int ret ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 270
  tmp = ldv__builtin_expect(res->id != -1, 0L);
#line 270
  if (tmp != 0L) {
#line 270
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (270), "i" (12UL));
    ldv_39076: ;
#line 270
    goto ldv_39076;
  } else {

  }
  ldv_39077: 
#line 273
  tmp___0 = idr_pre_get(res->idr, 208U);
#line 273
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 273
  if (tmp___1 != 0L) {
#line 274
    return (-12);
  } else {

  }
#line 276
  _raw_write_lock(& dev_priv->resource_lock);
#line 277
  ret = idr_get_new_above(res->idr, (void *)res, 1, & res->id);
#line 278
  _raw_write_unlock(& dev_priv->resource_lock);
#line 280
  if (ret == -11) {
#line 281
    goto ldv_39077;
  } else {

  }

#line 282
  return (ret);
}
}
#line 286 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                             struct idr *idr , enum ttm_object_type obj_type , bool delay_id ,
                             void (*res_free)(struct vmw_resource * ) , void (*remove_from_lists)(struct vmw_resource * ) ) 
{ 
  int tmp ;

  {
#line 295
  kref_init(& res->kref);
#line 296
  res->hw_destroy = 0;
#line 297
  res->res_free = res_free;
#line 298
  res->remove_from_lists = remove_from_lists;
#line 299
  res->res_type = obj_type;
#line 300
  res->idr = idr;
#line 301
  res->avail = 0;
#line 302
  res->dev_priv = dev_priv;
#line 303
  INIT_LIST_HEAD(& res->query_head);
#line 304
  INIT_LIST_HEAD(& res->validate_head);
#line 305
  res->id = -1;
#line 306
  if ((int )delay_id) {
#line 307
    return (0);
  } else {
#line 309
    tmp = vmw_resource_alloc_id(dev_priv, res);
#line 309
    return (tmp);
  }
}
}
#line 325 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) 
{ 
  struct vmw_private *dev_priv ;

  {
#line 328
  dev_priv = res->dev_priv;
#line 330
  _raw_write_lock(& dev_priv->resource_lock);
#line 331
  res->avail = 1;
#line 332
  res->hw_destroy = hw_destroy;
#line 333
  _raw_write_unlock(& dev_priv->resource_lock);
#line 334
  return;
}
}
#line 336 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv , struct idr *idr ,
                                         int id ) 
{ 
  struct vmw_resource *res ;
  void *tmp ;
  long tmp___0 ;

  {
#line 341
  _raw_read_lock(& dev_priv->resource_lock);
#line 342
  tmp = idr_find(idr, id);
#line 342
  res = (struct vmw_resource *)tmp;
#line 343
  if ((unsigned long )res != (unsigned long )((struct vmw_resource *)0) && (int )res->avail) {
#line 344
    kref_get(& res->kref);
  } else {
#line 346
    res = 0;
  }
#line 347
  _raw_read_unlock(& dev_priv->resource_lock);
#line 349
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 349
  if (tmp___0 != 0L) {
#line 350
    return (0);
  } else {

  }
#line 352
  return (res);
}
}
#line 359 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_hw_context_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct __anonstruct_cmd_279___1 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 362
  dev_priv = res->dev_priv;
#line 369
  vmw_execbuf_release_pinned_bo(dev_priv, 1, (uint32_t )res->id);
#line 371
  tmp = vmw_fifo_reserve(dev_priv, 12U);
#line 371
  cmd = (struct __anonstruct_281___0 *)tmp;
#line 372
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_279___1 *)0),
                             0L);
#line 372
  if (tmp___0 != 0L) {
#line 373
    drm_err("vmw_hw_context_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 375
    return;
  } else {

  }
#line 378
  cmd->header.id = 1046U;
#line 379
  cmd->header.size = 4U;
#line 380
  cmd->body.cid = (unsigned int )res->id;
#line 382
  vmw_fifo_commit(dev_priv, 12U);
#line 383
  vmw_3d_resource_dec(dev_priv, 0);
#line 384
  return;
}
}
#line 386 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_context_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                            void (*res_free)(struct vmw_resource * ) ) 
{ 
  int ret ;
  struct __anonstruct_cmd_283___0 *cmd ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 397
  ret = vmw_resource_init(dev_priv, res, & dev_priv->context_idr, ttm_driver_type0,
                          0, res_free, 0);
#line 400
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 400
  if (tmp != 0L) {
#line 401
    drm_err("vmw_context_init", "Failed to allocate a resource id.\n");
#line 402
    goto out_early;
  } else {

  }
#line 405
  tmp___0 = ldv__builtin_expect(res->id > 255, 0L);
#line 405
  if (tmp___0 != 0L) {
#line 406
    drm_err("vmw_context_init", "Out of hw context ids.\n");
#line 407
    vmw_resource_unreference(& res);
#line 408
    return (-12);
  } else {

  }
#line 411
  tmp___1 = vmw_fifo_reserve(dev_priv, 12U);
#line 411
  cmd = (struct __anonstruct_285___0 *)tmp___1;
#line 412
  tmp___2 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_283___0 *)0),
                             0L);
#line 412
  if (tmp___2 != 0L) {
#line 413
    drm_err("vmw_context_init", "Fifo reserve failed.\n");
#line 414
    vmw_resource_unreference(& res);
#line 415
    return (-12);
  } else {

  }
#line 418
  cmd->header.id = 1045U;
#line 419
  cmd->header.size = 4U;
#line 420
  cmd->body.cid = (unsigned int )res->id;
#line 422
  vmw_fifo_commit(dev_priv, 12U);
#line 423
  vmw_3d_resource_inc(dev_priv, 0);
#line 424
  vmw_resource_activate(res, & vmw_hw_context_destroy);
#line 425
  return (0);
  out_early: ;
#line 428
  if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 429
    kfree((void const   *)res);
  } else {
#line 431
    (*res_free)(res);
  }
#line 432
  return (ret);
}
}
#line 435 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) 
{ 
  struct vmw_resource *res ;
  void *tmp ;
  int ret ;
  long tmp___0 ;

  {
#line 437
  tmp = kmalloc(96UL, 208U);
#line 437
  res = (struct vmw_resource *)tmp;
#line 440
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 440
  if (tmp___0 != 0L) {
#line 441
    return (0);
  } else {

  }
#line 443
  ret = vmw_context_init(dev_priv, res, 0);
#line 444
  return (ret == 0 ? res : 0);
}
}
#line 451 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_context_free(struct vmw_resource *res ) 
{ 
  struct vmw_user_context *ctx ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 454
  __mptr = (struct vmw_resource  const  *)res;
#line 454
  ctx = (struct vmw_user_context *)__mptr + 0xffffffffffffffc0UL;
#line 455
  dev_priv = res->dev_priv;
#line 457
  kfree((void const   *)ctx);
#line 458
  tmp = vmw_mem_glob(dev_priv);
#line 458
  ttm_mem_global_free(tmp, vmw_user_context_size);
#line 459
  return;
}
}
#line 467 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_context_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_context *ctx ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 469
  base = *p_base;
#line 471
  __mptr = (struct ttm_base_object  const  *)base;
#line 471
  ctx = (struct vmw_user_context *)__mptr;
#line 472
  res = & ctx->res;
#line 474
  *p_base = 0;
#line 475
  vmw_resource_unreference(& res);
#line 476
  return;
}
}
#line 478 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_resource *res ;
  struct vmw_user_context *ctx ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  int ret ;
  long tmp___1 ;
  struct vmw_resource  const  *__mptr ;

  {
#line 481
  tmp = vmw_priv(dev);
#line 481
  dev_priv = tmp;
#line 484
  arg = (struct drm_vmw_context_arg *)data;
#line 485
  tmp___0 = vmw_fpriv(file_priv);
#line 485
  tfile = tmp___0->tfile;
#line 486
  ret = 0;
#line 488
  res = vmw_resource_lookup(dev_priv, & dev_priv->context_idr, arg->cid);
#line 489
  tmp___1 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 489
  if (tmp___1 != 0L) {
#line 490
    return (-22);
  } else {

  }
#line 492
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_context_free)) {
#line 493
    ret = -22;
#line 494
    goto out;
  } else {

  }
#line 497
  __mptr = (struct vmw_resource  const  *)res;
#line 497
  ctx = (struct vmw_user_context *)__mptr + 0xffffffffffffffc0UL;
#line 498
  if ((unsigned long )ctx->base.tfile != (unsigned long )tfile && ! ctx->base.shareable) {
#line 499
    ret = -1;
#line 500
    goto out;
  } else {

  }
#line 503
  ttm_ref_object_base_unref(tfile, ctx->base.hash.key, TTM_REF_USAGE);
  out: 
#line 505
  vmw_resource_unreference(& res);
#line 506
  return (ret);
}
}
#line 509 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 512
  tmp = vmw_priv(dev);
#line 512
  dev_priv = tmp;
#line 516
  arg = (struct drm_vmw_context_arg *)data;
#line 517
  tmp___1 = vmw_fpriv(file_priv);
#line 517
  tfile = tmp___1->tfile;
#line 518
  tmp___2 = vmw_master(file_priv->master);
#line 518
  vmaster = tmp___2;
#line 527
  tmp___4 = ldv__builtin_expect(vmw_user_context_size == 0ULL, 0L);
#line 527
  if (tmp___4 != 0L) {
#line 528
    tmp___3 = ttm_round_pot(160UL);
#line 528
    vmw_user_context_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 530
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 531
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 531
  if (tmp___5 != 0L) {
#line 532
    return (ret);
  } else {

  }
#line 534
  tmp___6 = vmw_mem_glob(dev_priv);
#line 534
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_context_size, 0, 1);
#line 537
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 537
  if (tmp___7 != 0L) {
#line 538
    if (ret != -512) {
#line 539
      drm_err("vmw_context_define_ioctl", "Out of graphics memory for context creation.\n");
    } else {

    }
#line 541
    goto out_unlock;
  } else {

  }
#line 544
  tmp___8 = kmalloc(160UL, 208U);
#line 544
  ctx = (struct vmw_user_context *)tmp___8;
#line 545
  tmp___10 = ldv__builtin_expect((unsigned long )ctx == (unsigned long )((struct vmw_user_context *)0),
                              0L);
#line 545
  if (tmp___10 != 0L) {
#line 546
    tmp___9 = vmw_mem_glob(dev_priv);
#line 546
    ttm_mem_global_free(tmp___9, vmw_user_context_size);
#line 548
    ret = -12;
#line 549
    goto out_unlock;
  } else {

  }
#line 552
  res = & ctx->res;
#line 553
  ctx->base.shareable = 0;
#line 554
  ctx->base.tfile = 0;
#line 560
  ret = vmw_context_init(dev_priv, res, & vmw_user_context_free);
#line 561
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 561
  if (tmp___11 != 0L) {
#line 562
    goto out_unlock;
  } else {

  }
#line 564
  tmp___0 = vmw_resource_reference(& ctx->res);
#line 565
  ret = ttm_base_object_init(tfile, & ctx->base, 0, ttm_driver_type0, & vmw_user_context_base_release,
                             0);
#line 568
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 568
  if (tmp___12 != 0L) {
#line 569
    vmw_resource_unreference(& tmp___0);
#line 570
    goto out_err;
  } else {

  }
#line 573
  arg->cid = res->id;
  out_err: 
#line 575
  vmw_resource_unreference(& res);
  out_unlock: 
#line 577
  ttm_read_unlock(& vmaster->lock);
#line 578
  return (ret);
}
}
#line 582 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) 
{ 
  struct vmw_resource *res ;
  int ret ;
  void *tmp ;
  struct vmw_user_context *ctx ;
  struct vmw_resource  const  *__mptr ;

  {
#line 588
  ret = 0;
#line 590
  _raw_read_lock(& dev_priv->resource_lock);
#line 591
  tmp = idr_find(& dev_priv->context_idr, id);
#line 591
  res = (struct vmw_resource *)tmp;
#line 592
  if ((unsigned long )res != (unsigned long )((struct vmw_resource *)0) && (int )res->avail) {
#line 594
    __mptr = (struct vmw_resource  const  *)res;
#line 594
    ctx = (struct vmw_user_context *)__mptr + 0xffffffffffffffc0UL;
#line 595
    if ((unsigned long )ctx->base.tfile != (unsigned long )tfile && ! ctx->base.shareable) {
#line 596
      ret = -1;
    } else {

    }
#line 597
    if ((unsigned long )p_res != (unsigned long )((struct vmw_resource **)0)) {
#line 598
      *p_res = vmw_resource_reference(res);
    } else {

    }
  } else {
#line 600
    ret = -22;
  }
#line 601
  _raw_read_unlock(& dev_priv->resource_lock);
#line 603
  return (ret);
}
}
#line 624 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static struct vmw_bpp  const  vmw_sf_bpp[121U]  = 
#line 624
  {      {0U, 0U}, 
        {32U, 32U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {16U, 16U}, 
        {16U, 16U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {8U, 8U}, 
        {8U, 8U}, 
        {16U, 16U}, 
        {16U, 16U}, 
        {4U, 16U}, 
        {8U, 32U}, 
        {8U, 32U}, 
        {8U, 32U}, 
        {8U, 32U}, 
        {16U, 16U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {(unsigned char)0, (unsigned char)0}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {32U, 32U}, 
        {8U, 8U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {16U, 16U}, 
        {32U, 32U}, 
        {8U, 8U}, 
        {32U, 32U}, 
        {32U, 32U}, 
        {32U, 32U}, 
        {64U, 64U}, 
        {12U, 12U}, 
        {12U, 12U}, 
        {12U, 8U}, 
        {32U, 32U}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {4U, 16U}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {8U, 32U}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {16U, 16U}, 
        {24U, 24U}, 
        {32U, 32U}};
#line 708 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static uint32_t vmw_surface_dma_size(struct vmw_surface  const  *srf ) 
{ 


  {
#line 710
  return ((uint32_t )srf->num_sizes * 84U);
}
}
#line 722 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static uint32_t vmw_surface_define_size(struct vmw_surface  const  *srf ) 
{ 


  {
#line 724
  return ((uint32_t )srf->num_sizes * 12U + 44U);
}
}
#line 735 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static uint32_t vmw_surface_destroy_size(void) 
{ 


  {
#line 737
  return (12U);
}
}
#line 746 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_surface_destroy_encode(uint32_t id , void *cmd_space ) 
{ 
  struct vmw_surface_destroy *cmd ;

  {
#line 749
  cmd = (struct vmw_surface_destroy *)cmd_space;
#line 752
  cmd->header.id = 1041U;
#line 753
  cmd->header.size = 4U;
#line 754
  cmd->body.sid = id;
#line 755
  return;
}
}
#line 763 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_surface_define_encode(struct vmw_surface  const  *srf , void *cmd_space ) 
{ 
  struct vmw_surface_define *cmd ;
  struct drm_vmw_size *src_size ;
  SVGA3dSize *cmd_size ;
  uint32_t cmd_len ;
  int i ;

  {
#line 766
  cmd = (struct vmw_surface_define *)cmd_space;
#line 773
  cmd_len = (uint32_t )srf->num_sizes * 12U + 36U;
#line 775
  cmd->header.id = 1040U;
#line 776
  cmd->header.size = cmd_len;
#line 777
  cmd->body.sid = (uint32 )srf->res.id;
#line 778
  cmd->body.surfaceFlags = (SVGA3dSurfaceFlags )srf->flags;
#line 779
  cmd->body.format = (SVGA3dSurfaceFormat )srf->format;
#line 780
  i = 0;
#line 780
  goto ldv_39224;
  ldv_39223: 
#line 781
  cmd->body.face[i].numMipLevels = srf->mip_levels[i];
#line 780
  i = i + 1;
  ldv_39224: ;
#line 780
  if (i <= 5) {
#line 781
    goto ldv_39223;
  } else {

  }
#line 783
  cmd = cmd + 1UL;
#line 784
  cmd_size = (SVGA3dSize *)cmd;
#line 785
  src_size = srf->sizes;
#line 787
  i = 0;
#line 787
  goto ldv_39227;
  ldv_39226: 
#line 788
  cmd_size->width = src_size->width;
#line 789
  cmd_size->height = src_size->height;
#line 790
  cmd_size->depth = src_size->depth;
#line 787
  i = i + 1;
#line 787
  cmd_size = cmd_size + 1;
#line 787
  src_size = src_size + 1;
  ldv_39227: ;
#line 787
  if ((unsigned int )i < (unsigned int )srf->num_sizes) {
#line 788
    goto ldv_39226;
  } else {

  }

#line 792
  return;
}
}
#line 804 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_surface_dma_encode(struct vmw_surface *srf , void *cmd_space , SVGAGuestPtr const   *ptr ,
                                   bool to_surface ) 
{ 
  uint32_t i ;
  uint32_t bpp ;
  uint32_t stride_bpp ;
  struct vmw_surface_dma *cmd ;
  SVGA3dCmdHeader *header ;
  SVGA3dCmdSurfaceDMA *body ;
  SVGA3dCopyBox *cb ;
  SVGA3dCmdSurfaceDMASuffix *suffix ;
  struct vmw_surface_offset  const  *cur_offset ;
  struct drm_vmw_size  const  *cur_size ;

  {
#line 810
  bpp = (uint32_t )vmw_sf_bpp[srf->format].bpp;
#line 811
  stride_bpp = (uint32_t )vmw_sf_bpp[srf->format].s_bpp;
#line 812
  cmd = (struct vmw_surface_dma *)cmd_space;
#line 814
  i = 0U;
#line 814
  goto ldv_39246;
  ldv_39245: 
#line 815
  header = & cmd->header;
#line 816
  body = & cmd->body;
#line 817
  cb = & cmd->cb;
#line 818
  suffix = & cmd->suffix;
#line 819
  cur_offset = (struct vmw_surface_offset  const  *)srf->offsets + (unsigned long )i;
#line 820
  cur_size = (struct drm_vmw_size  const  *)srf->sizes + (unsigned long )i;
#line 822
  header->id = 1044U;
#line 823
  header->size = 76U;
#line 825
  body->guest.ptr = *ptr;
#line 826
  body->guest.ptr.offset = body->guest.ptr.offset + (uint32 )cur_offset->bo_offset;
#line 827
  body->guest.pitch = ((unsigned int )cur_size->width * stride_bpp + 7U) >> 3;
#line 828
  body->host.sid = (uint32 )srf->res.id;
#line 829
  body->host.face = cur_offset->face;
#line 830
  body->host.mipmap = cur_offset->mip;
#line 831
  body->transfer = (int )to_surface ? SVGA3D_WRITE_HOST_VRAM : SVGA3D_READ_HOST_VRAM;
#line 833
  cb->x = 0U;
#line 834
  cb->y = 0U;
#line 835
  cb->z = 0U;
#line 836
  cb->srcx = 0U;
#line 837
  cb->srcy = 0U;
#line 838
  cb->srcz = 0U;
#line 839
  cb->w = cur_size->width;
#line 840
  cb->h = cur_size->height;
#line 841
  cb->d = cur_size->depth;
#line 843
  suffix->suffixSize = 12U;
#line 844
  suffix->maximumOffset = (((body->guest.pitch * (uint32 )cur_size->height) * (uint32 )cur_size->depth) * bpp) / stride_bpp;
#line 846
  suffix->flags.discard = 0U;
#line 847
  suffix->flags.unsynchronized = 0U;
#line 848
  suffix->flags.reserved = 0U;
#line 849
  cmd = cmd + 1;
#line 814
  i = i + (uint32_t )1;
  ldv_39246: ;
#line 814
  if (srf->num_sizes > i) {
#line 815
    goto ldv_39245;
  } else {

  }

#line 819
  return;
}
}
#line 854 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_hw_surface_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  void *cmd ;
  uint32_t tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  struct vmw_resource  const  *__mptr ;

  {
#line 857
  dev_priv = res->dev_priv;
#line 861
  if (res->id != -1) {
#line 863
    tmp = vmw_surface_destroy_size();
#line 863
    cmd = vmw_fifo_reserve(dev_priv, tmp);
#line 864
    tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0),
                               0L);
#line 864
    if (tmp___0 != 0L) {
#line 865
      drm_err("vmw_hw_surface_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 867
      return;
    } else {

    }
#line 870
    vmw_surface_destroy_encode((uint32_t )res->id, cmd);
#line 871
    tmp___1 = vmw_surface_destroy_size();
#line 871
    vmw_fifo_commit(dev_priv, tmp___1);
#line 879
    ldv_mutex_lock_245(& dev_priv->cmdbuf_mutex);
#line 880
    __mptr = (struct vmw_resource  const  *)res;
#line 880
    srf = (struct vmw_surface *)__mptr;
#line 881
    dev_priv->used_memory_size = dev_priv->used_memory_size - srf->backup_size;
#line 882
    ldv_mutex_unlock_246(& dev_priv->cmdbuf_mutex);
  } else {

  }
#line 885
  vmw_3d_resource_dec(dev_priv, 0);
#line 886
  return;
}
}
#line 888 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_surface_res_free(struct vmw_resource *res ) 
{ 
  struct vmw_surface *srf ;
  struct vmw_resource  const  *__mptr ;

  {
#line 890
  __mptr = (struct vmw_resource  const  *)res;
#line 890
  srf = (struct vmw_surface *)__mptr;
#line 892
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 893
    ttm_bo_unref(& srf->backup);
  } else {

  }
#line 894
  kfree((void const   *)srf->offsets);
#line 895
  kfree((void const   *)srf->sizes);
#line 896
  kfree((void const   *)srf->snooper.image);
#line 897
  kfree((void const   *)srf);
#line 898
  return;
}
}
#line 915 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_do_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ 
  struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  SVGAGuestPtr ptr ;
  uint32_t tmp___8 ;
  struct vmw_fence_obj *fence ;
  long tmp___9 ;

  {
#line 918
  res = & srf->res;
#line 925
  tmp = ldv__builtin_expect(res->id != -1, 1L);
#line 925
  if (tmp != 0L) {
#line 926
    return (0);
  } else {

  }
#line 928
  tmp___0 = ldv__builtin_expect(dev_priv->used_memory_size + srf->backup_size >= dev_priv->memory_size,
                             0L);
#line 928
  if (tmp___0 != 0L) {
#line 930
    return (-16);
  } else {

  }
#line 936
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 937
    INIT_LIST_HEAD(& val_list);
#line 938
    val_buf.bo = ttm_bo_reference(srf->backup);
#line 939
    val_buf.new_sync_obj_arg = 1;
#line 941
    list_add_tail(& val_buf.head, & val_list);
#line 942
    ret = ttm_eu_reserve_buffers(& val_list);
#line 943
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 943
    if (tmp___1 != 0L) {
#line 944
      goto out_no_reserve;
    } else {

    }
#line 946
    ret = ttm_bo_validate(srf->backup, & vmw_srf_placement, 1, 0, 0);
#line 948
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 948
    if (tmp___2 != 0L) {
#line 949
      goto out_no_validate;
    } else {

    }
  } else {

  }
#line 956
  ret = vmw_resource_alloc_id(dev_priv, res);
#line 957
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 957
  if (tmp___3 != 0L) {
#line 958
    drm_err("vmw_surface_do_validate", "Failed to allocate a surface id.\n");
#line 959
    goto out_no_id;
  } else {

  }
#line 961
  tmp___4 = ldv__builtin_expect(res->id > 32767, 0L);
#line 961
  if (tmp___4 != 0L) {
#line 962
    ret = -16;
#line 963
    goto out_no_fifo;
  } else {

  }
#line 971
  submit_size = vmw_surface_define_size((struct vmw_surface  const  *)srf);
#line 972
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 973
    tmp___5 = vmw_surface_dma_size((struct vmw_surface  const  *)srf);
#line 973
    submit_size = tmp___5 + submit_size;
  } else {

  }
#line 975
  tmp___6 = vmw_fifo_reserve(dev_priv, submit_size);
#line 975
  cmd = (uint8_t *)tmp___6;
#line 976
  tmp___7 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 976
  if (tmp___7 != 0L) {
#line 977
    drm_err("vmw_surface_do_validate", "Failed reserving FIFO space for surface validation.\n");
#line 979
    ret = -12;
#line 980
    goto out_no_fifo;
  } else {

  }
#line 983
  vmw_surface_define_encode((struct vmw_surface  const  *)srf, (void *)cmd);
#line 984
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 987
    tmp___8 = vmw_surface_define_size((struct vmw_surface  const  *)srf);
#line 987
    cmd = cmd + (unsigned long )tmp___8;
#line 988
    vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)srf->backup, & ptr);
#line 989
    vmw_surface_dma_encode(srf, (void *)cmd, (SVGAGuestPtr const   *)(& ptr), 1);
  } else {

  }
#line 992
  vmw_fifo_commit(dev_priv, submit_size);
#line 998
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1001
    vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
#line 1003
    ttm_eu_fence_buffer_objects(& val_list, (void *)fence);
#line 1004
    tmp___9 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                               1L);
#line 1004
    if (tmp___9 != 0L) {
#line 1005
      vmw_fence_obj_unreference(& fence);
    } else {

    }
#line 1006
    ttm_bo_unref(& val_buf.bo);
#line 1007
    ttm_bo_unref(& srf->backup);
  } else {

  }
#line 1014
  dev_priv->used_memory_size = dev_priv->used_memory_size + srf->backup_size;
#line 1016
  return (0);
  out_no_fifo: 
#line 1019
  vmw_resource_release_id(res);
  out_no_id: ;
  out_no_validate: ;
#line 1022
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1023
    ttm_eu_backoff_reservation(& val_list);
  } else {

  }
  out_no_reserve: ;
#line 1025
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1026
    ttm_bo_unref(& val_buf.bo);
  } else {

  }
#line 1027
  return (ret);
}
}
#line 1039 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_evict(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ 
  struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  struct vmw_fence_obj *fence ;
  SVGAGuestPtr ptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  uint32_t tmp___7 ;
  long tmp___8 ;

  {
#line 1042
  res = & srf->res;
#line 1051
  tmp = ldv__builtin_expect(res->id == -1, 0L);
#line 1051
  if (tmp != 0L) {
#line 1051
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (1051), "i" (12UL));
    ldv_39292: ;
#line 1051
    goto ldv_39292;
  } else {

  }
#line 1057
  if ((unsigned long )srf->backup == (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1058
    ret = ttm_bo_create(& dev_priv->bdev, (unsigned long )srf->backup_size, ttm_bo_type_device,
                        & vmw_srf_placement, 0U, 0UL, 1, 0, & srf->backup);
#line 1062
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1062
    if (tmp___0 != 0L) {
#line 1063
      return (ret);
    } else {

    }
  } else {

  }
#line 1070
  INIT_LIST_HEAD(& val_list);
#line 1071
  val_buf.bo = ttm_bo_reference(srf->backup);
#line 1072
  val_buf.new_sync_obj_arg = 1;
#line 1074
  list_add_tail(& val_buf.head, & val_list);
#line 1075
  ret = ttm_eu_reserve_buffers(& val_list);
#line 1076
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1076
  if (tmp___1 != 0L) {
#line 1077
    goto out_no_reserve;
  } else {

  }
#line 1079
  ret = ttm_bo_validate(srf->backup, & vmw_srf_placement, 1, 0, 0);
#line 1081
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1081
  if (tmp___2 != 0L) {
#line 1082
    goto out_no_validate;
  } else {

  }
#line 1089
  tmp___3 = vmw_surface_dma_size((struct vmw_surface  const  *)srf);
#line 1089
  tmp___4 = vmw_surface_destroy_size();
#line 1089
  submit_size = tmp___3 + tmp___4;
#line 1090
  tmp___5 = vmw_fifo_reserve(dev_priv, submit_size);
#line 1090
  cmd = (uint8_t *)tmp___5;
#line 1091
  tmp___6 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 1091
  if (tmp___6 != 0L) {
#line 1092
    drm_err("vmw_surface_evict", "Failed reserving FIFO space for surface eviction.\n");
#line 1094
    ret = -12;
#line 1095
    goto out_no_fifo;
  } else {

  }
#line 1098
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)srf->backup, & ptr);
#line 1099
  vmw_surface_dma_encode(srf, (void *)cmd, (SVGAGuestPtr const   *)(& ptr), 0);
#line 1100
  tmp___7 = vmw_surface_dma_size((struct vmw_surface  const  *)srf);
#line 1100
  cmd = cmd + (unsigned long )tmp___7;
#line 1101
  vmw_surface_destroy_encode((uint32_t )res->id, (void *)cmd);
#line 1102
  vmw_fifo_commit(dev_priv, submit_size);
#line 1108
  dev_priv->used_memory_size = dev_priv->used_memory_size - srf->backup_size;
#line 1114
  vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
#line 1116
  ttm_eu_fence_buffer_objects(& val_list, (void *)fence);
#line 1117
  tmp___8 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                             1L);
#line 1117
  if (tmp___8 != 0L) {
#line 1118
    vmw_fence_obj_unreference(& fence);
  } else {

  }
#line 1119
  ttm_bo_unref(& val_buf.bo);
#line 1125
  vmw_resource_release_id(res);
#line 1127
  return (0);
  out_no_fifo: ;
  out_no_validate: ;
#line 1131
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1132
    ttm_eu_backoff_reservation(& val_list);
  } else {

  }
  out_no_reserve: 
#line 1134
  ttm_bo_unref(& val_buf.bo);
#line 1135
  ttm_bo_unref(& srf->backup);
#line 1136
  return (ret);
}
}
#line 1153 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ 
  int ret ;
  struct vmw_surface *evict_srf ;
  long tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  long tmp___1 ;
  long tmp___2 ;

  {
  ldv_39307: 
#line 1160
  _raw_write_lock(& dev_priv->resource_lock);
#line 1161
  list_del_init(& srf->lru_head);
#line 1162
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1164
  ret = vmw_surface_do_validate(dev_priv, srf);
#line 1165
  tmp = ldv__builtin_expect(ret != -16, 1L);
#line 1165
  if (tmp != 0L) {
#line 1166
    goto ldv_39303;
  } else {

  }
#line 1168
  _raw_write_lock(& dev_priv->resource_lock);
#line 1169
  tmp___0 = list_empty((struct list_head  const  *)(& dev_priv->surface_lru));
#line 1169
  if (tmp___0 != 0) {
#line 1170
    drm_err("vmw_surface_validate", "Out of device memory for surfaces.\n");
#line 1171
    ret = -16;
#line 1172
    _raw_write_unlock(& dev_priv->resource_lock);
#line 1173
    goto ldv_39303;
  } else {

  }
#line 1177
  __mptr = (struct list_head  const  *)dev_priv->surface_lru.next;
#line 1177
  evict_srf = vmw_surface_reference((struct vmw_surface *)__mptr + 0xffffffffffffffa0UL);
#line 1180
  list_del_init(& evict_srf->lru_head);
#line 1182
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1183
  vmw_surface_evict(dev_priv, evict_srf);
#line 1185
  vmw_surface_unreference(& evict_srf);
#line 1187
  goto ldv_39307;
  ldv_39303: 
#line 1189
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1189
  if (tmp___1 != 0L) {
#line 1189
    tmp___2 = ldv__builtin_expect(srf->res.id != -1, 0L);
#line 1189
    if (tmp___2 != 0L) {
#line 1190
      _raw_write_lock(& dev_priv->resource_lock);
#line 1191
      list_add_tail(& srf->lru_head, & dev_priv->surface_lru);
#line 1192
      _raw_write_unlock(& dev_priv->resource_lock);
    } else {

    }
  } else {

  }
#line 1195
  return (ret);
}
}
#line 1207 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_surface_remove_from_lists(struct vmw_resource *res ) 
{ 
  struct vmw_surface *srf ;
  struct vmw_resource  const  *__mptr ;

  {
#line 1209
  __mptr = (struct vmw_resource  const  *)res;
#line 1209
  srf = (struct vmw_surface *)__mptr;
#line 1211
  list_del_init(& srf->lru_head);
#line 1212
  return;
}
}
#line 1214 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource * ) ) 
{ 
  int ret ;
  struct vmw_resource *res ;
  long tmp ;
  long tmp___0 ;

  {
#line 1219
  res = & srf->res;
#line 1221
  tmp = ldv__builtin_expect((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0),
                         0L);
#line 1221
  if (tmp != 0L) {
#line 1221
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (1221), "i" (12UL));
    ldv_39322: ;
#line 1221
    goto ldv_39322;
  } else {

  }
#line 1222
  INIT_LIST_HEAD(& srf->lru_head);
#line 1223
  ret = vmw_resource_init(dev_priv, res, & dev_priv->surface_idr, ttm_driver_type1,
                          1, res_free, & vmw_surface_remove_from_lists);
#line 1227
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1227
  if (tmp___0 != 0L) {
#line 1228
    (*res_free)(res);
  } else {

  }
#line 1235
  vmw_3d_resource_inc(dev_priv, 0);
#line 1236
  vmw_resource_activate(res, & vmw_hw_surface_destroy);
#line 1237
  return (ret);
}
}
#line 1240 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_surface_free(struct vmw_resource *res ) 
{ 
  struct vmw_surface *srf ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface  const  *__mptr___0 ;
  struct vmw_private *dev_priv ;
  uint32_t size ;
  struct ttm_mem_global *tmp ;

  {
#line 1242
  __mptr = (struct vmw_resource  const  *)res;
#line 1242
  srf = (struct vmw_surface *)__mptr;
#line 1244
  __mptr___0 = (struct vmw_surface  const  *)srf;
#line 1244
  user_srf = (struct vmw_user_surface *)__mptr___0 + 0xffffffffffffffc0UL;
#line 1245
  dev_priv = srf->res.dev_priv;
#line 1246
  size = user_srf->size;
#line 1248
  if ((unsigned long )srf->backup != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1249
    ttm_bo_unref(& srf->backup);
  } else {

  }
#line 1250
  kfree((void const   *)srf->offsets);
#line 1251
  kfree((void const   *)srf->sizes);
#line 1252
  kfree((void const   *)srf->snooper.image);
#line 1253
  kfree((void const   *)user_srf);
#line 1254
  tmp = vmw_mem_glob(dev_priv);
#line 1254
  ttm_mem_global_free(tmp, (uint64_t )size);
#line 1255
  return;
}
}
#line 1270 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreserve(struct list_head *list ) 
{ 
  struct vmw_resource *res ;
  struct vmw_surface *srf ;
  rwlock_t *lock ;
  struct list_head  const  *__mptr ;
  long tmp ;
  struct vmw_resource  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1274
  lock = 0;
#line 1276
  __mptr = (struct list_head  const  *)list->next;
#line 1276
  res = (struct vmw_resource *)__mptr + 0xffffffffffffffc0UL;
#line 1276
  goto ldv_39348;
  ldv_39347: ;
#line 1278
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_surface_res_free) && (unsigned long )res->res_free != (unsigned long )(& vmw_user_surface_free)) {
#line 1280
    goto ldv_39344;
  } else {

  }
#line 1282
  tmp = ldv__builtin_expect((unsigned long )lock == (unsigned long )((rwlock_t *)0),
                         0L);
#line 1282
  if (tmp != 0L) {
#line 1283
    lock = & (res->dev_priv)->resource_lock;
#line 1284
    _raw_write_lock(lock);
  } else {

  }
#line 1287
  __mptr___0 = (struct vmw_resource  const  *)res;
#line 1287
  srf = (struct vmw_surface *)__mptr___0;
#line 1288
  list_del_init(& srf->lru_head);
#line 1289
  list_add_tail(& srf->lru_head, & (res->dev_priv)->surface_lru);
  ldv_39344: 
#line 1276
  __mptr___1 = (struct list_head  const  *)res->validate_head.next;
#line 1276
  res = (struct vmw_resource *)__mptr___1 + 0xffffffffffffffc0UL;
  ldv_39348: ;
#line 1276
  if ((unsigned long )(& res->validate_head) != (unsigned long )list) {
#line 1277
    goto ldv_39347;
  } else {

  }

#line 1292
  if ((unsigned long )lock != (unsigned long )((rwlock_t *)0)) {
#line 1293
    _raw_write_unlock(lock);
  } else {

  }
#line 1294
  return;
}
}
#line 1301 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) 
{ 
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1309
  tmp = ldv__builtin_expect((unsigned long )*out_surf != (unsigned long )((struct vmw_surface *)0),
                         0L);
#line 1309
  if (tmp != 0L) {
#line 1309
    goto _L;
  } else {
#line 1309
    tmp___0 = ldv__builtin_expect((unsigned long )*out_buf != (unsigned long )((struct vmw_dma_buffer *)0),
                               0L);
#line 1309
    if (tmp___0 != 0L) {
      _L: /* CIL Label */ 
#line 1309
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (1309), "i" (12UL));
      ldv_39358: ;
#line 1309
      goto ldv_39358;
    } else {

    }
  }
#line 1311
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, handle, out_surf);
#line 1312
  if (ret == 0) {
#line 1313
    return (0);
  } else {

  }
#line 1315
  ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);
#line 1316
  return (ret);
}
}
#line 1320 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) 
{ 
  struct vmw_resource *res ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 1328
  ret = -22;
#line 1330
  base = ttm_base_object_lookup(tfile, handle);
#line 1331
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 1331
  if (tmp != 0L) {
#line 1332
    return (-22);
  } else {

  }
#line 1334
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != 257U, 0L);
#line 1334
  if (tmp___0 != 0L) {
#line 1335
    goto out_bad_resource;
  } else {

  }
#line 1337
  __mptr = (struct ttm_base_object  const  *)base;
#line 1337
  user_srf = (struct vmw_user_surface *)__mptr;
#line 1338
  srf = & user_srf->srf;
#line 1339
  res = & srf->res;
#line 1341
  _raw_read_lock(& dev_priv->resource_lock);
#line 1343
  if (! res->avail || (unsigned long )res->res_free != (unsigned long )(& vmw_user_surface_free)) {
#line 1344
    _raw_read_unlock(& dev_priv->resource_lock);
#line 1345
    goto out_bad_resource;
  } else {

  }
#line 1348
  kref_get(& res->kref);
#line 1349
  _raw_read_unlock(& dev_priv->resource_lock);
#line 1351
  *out = srf;
#line 1352
  ret = 0;
  out_bad_resource: 
#line 1355
  ttm_base_object_unref(& base);
#line 1357
  return (ret);
}
}
#line 1360 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_surface_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 1362
  base = *p_base;
#line 1364
  __mptr = (struct ttm_base_object  const  *)base;
#line 1364
  user_srf = (struct vmw_user_surface *)__mptr;
#line 1365
  res = & user_srf->srf.res;
#line 1367
  *p_base = 0;
#line 1368
  vmw_resource_unreference(& res);
#line 1369
  return;
}
}
#line 1371 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_surface_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 1374
  arg = (struct drm_vmw_surface_arg *)data;
#line 1375
  tmp = vmw_fpriv(file_priv);
#line 1375
  tfile = tmp->tfile;
#line 1377
  tmp___0 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->sid, TTM_REF_USAGE);
#line 1377
  return (tmp___0);
}
}
#line 1380 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *srf ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  union drm_vmw_surface_create_arg *arg ;
  struct drm_vmw_surface_create_req *req ;
  struct drm_vmw_surface_arg *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct drm_vmw_size *user_sizes ;
  int ret ;
  int i ;
  int j ;
  uint32_t cur_bo_offset ;
  struct drm_vmw_size *cur_size ;
  struct vmw_surface_offset *cur_offset ;
  uint32_t stride_bpp ;
  uint32_t bpp ;
  uint32_t num_sizes ;
  uint32_t size ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  struct ttm_mem_global *tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  size_t __len ;
  void *__ret ;
  void *tmp___12 ;
  long tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  unsigned long tmp___16 ;
  long tmp___17 ;
  uint32_t stride ;
  void *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  struct ttm_mem_global *tmp___21 ;

  {
#line 1383
  tmp = vmw_priv(dev);
#line 1383
  dev_priv = tmp;
#line 1388
  arg = (union drm_vmw_surface_create_arg *)data;
#line 1390
  req = & arg->req;
#line 1391
  rep = & arg->rep;
#line 1392
  tmp___1 = vmw_fpriv(file_priv);
#line 1392
  tfile = tmp___1->tfile;
#line 1403
  tmp___2 = vmw_master(file_priv->master);
#line 1403
  vmaster = tmp___2;
#line 1405
  tmp___4 = ldv__builtin_expect(vmw_user_surface_size == 0ULL, 0L);
#line 1405
  if (tmp___4 != 0L) {
#line 1406
    tmp___3 = ttm_round_pot(280UL);
#line 1406
    vmw_user_surface_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 1409
  num_sizes = 0U;
#line 1410
  i = 0;
#line 1410
  goto ldv_39415;
  ldv_39414: 
#line 1411
  num_sizes = req->mip_levels[i] + num_sizes;
#line 1410
  i = i + 1;
  ldv_39415: ;
#line 1410
  if (i <= 5) {
#line 1411
    goto ldv_39414;
  } else {

  }

#line 1413
  if (num_sizes > 144U) {
#line 1415
    return (-22);
  } else {

  }
#line 1417
  tmp___5 = ttm_round_pot((unsigned long )num_sizes * 16UL);
#line 1417
  tmp___6 = ttm_round_pot((unsigned long )num_sizes * 12UL);
#line 1417
  size = (((uint32_t )tmp___5 + (uint32_t )vmw_user_surface_size) + (uint32_t )tmp___6) + 128U;
#line 1422
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1423
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1423
  if (tmp___7 != 0L) {
#line 1424
    return (ret);
  } else {

  }
#line 1426
  tmp___8 = vmw_mem_glob(dev_priv);
#line 1426
  ret = ttm_mem_global_alloc(tmp___8, (uint64_t )size, 0, 1);
#line 1428
  tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 1428
  if (tmp___9 != 0L) {
#line 1429
    if (ret != -512) {
#line 1430
      drm_err("vmw_surface_define_ioctl", "Out of graphics memory for surface creation.\n");
    } else {

    }
#line 1432
    goto out_unlock;
  } else {

  }
#line 1435
  tmp___10 = kmalloc(280UL, 208U);
#line 1435
  user_srf = (struct vmw_user_surface *)tmp___10;
#line 1436
  tmp___11 = ldv__builtin_expect((unsigned long )user_srf == (unsigned long )((struct vmw_user_surface *)0),
                              0L);
#line 1436
  if (tmp___11 != 0L) {
#line 1437
    ret = -12;
#line 1438
    goto out_no_user_srf;
  } else {

  }
#line 1441
  srf = & user_srf->srf;
#line 1442
  res = & srf->res;
#line 1444
  srf->flags = req->flags;
#line 1445
  srf->format = req->format;
#line 1446
  srf->scanout = req->scanout != 0;
#line 1447
  srf->backup = 0;
#line 1449
  __len = 24UL;
#line 1449
  if (__len > 63UL) {
#line 1449
    __ret = __memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                     __len);
  } else {
#line 1449
    __ret = __builtin_memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                             __len);
  }
#line 1450
  srf->num_sizes = num_sizes;
#line 1451
  user_srf->size = size;
#line 1453
  tmp___12 = kmalloc((unsigned long )srf->num_sizes * 16UL, 208U);
#line 1453
  srf->sizes = (struct drm_vmw_size *)tmp___12;
#line 1454
  tmp___13 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 1454
  if (tmp___13 != 0L) {
#line 1455
    ret = -12;
#line 1456
    goto out_no_sizes;
  } else {

  }
#line 1458
  tmp___14 = kmalloc((unsigned long )srf->num_sizes * 12UL, 208U);
#line 1458
  srf->offsets = (struct vmw_surface_offset *)tmp___14;
#line 1460
  tmp___15 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 1460
  if (tmp___15 != 0L) {
#line 1461
    ret = -12;
#line 1462
    goto out_no_offsets;
  } else {

  }
#line 1465
  user_sizes = (struct drm_vmw_size *)req->size_addr;
#line 1468
  tmp___16 = copy_from_user((void *)srf->sizes, (void const   *)user_sizes, (unsigned long )srf->num_sizes * 16UL);
#line 1468
  ret = (int )tmp___16;
#line 1470
  tmp___17 = ldv__builtin_expect(ret != 0, 0L);
#line 1470
  if (tmp___17 != 0L) {
#line 1471
    ret = -14;
#line 1472
    goto out_no_copy;
  } else {

  }
#line 1475
  cur_bo_offset = 0U;
#line 1476
  cur_offset = srf->offsets;
#line 1477
  cur_size = srf->sizes;
#line 1479
  bpp = (uint32_t )vmw_sf_bpp[srf->format].bpp;
#line 1480
  stride_bpp = (uint32_t )vmw_sf_bpp[srf->format].s_bpp;
#line 1482
  i = 0;
#line 1482
  goto ldv_39431;
  ldv_39430: 
#line 1483
  j = 0;
#line 1483
  goto ldv_39428;
  ldv_39427: 
#line 1484
  stride = (cur_size->width * stride_bpp + 7U) >> 3;
#line 1487
  cur_offset->face = (uint32_t )i;
#line 1488
  cur_offset->mip = (uint32_t )j;
#line 1489
  cur_offset->bo_offset = cur_bo_offset;
#line 1490
  cur_bo_offset = (((cur_size->height * stride) * cur_size->depth) * bpp) / stride_bpp + cur_bo_offset;
#line 1492
  cur_offset = cur_offset + 1;
#line 1493
  cur_size = cur_size + 1;
#line 1483
  j = j + 1;
  ldv_39428: ;
#line 1483
  if ((uint32_t )j < srf->mip_levels[i]) {
#line 1484
    goto ldv_39427;
  } else {

  }
#line 1482
  i = i + 1;
  ldv_39431: ;
#line 1482
  if (i <= 5) {
#line 1483
    goto ldv_39430;
  } else {

  }
#line 1496
  srf->backup_size = cur_bo_offset;
#line 1498
  if (((((int )srf->scanout && srf->num_sizes == 1U) && (srf->sizes)->width == 64U) && (srf->sizes)->height == 64U) && srf->format == 2U) {
#line 1505
    tmp___18 = kzalloc(16384UL, 208U);
#line 1505
    srf->snooper.image = (uint32_t *)tmp___18;
#line 1506
    if ((unsigned long )srf->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 1507
      drm_err("vmw_surface_define_ioctl", "Failed to allocate cursor_image\n");
#line 1508
      ret = -12;
#line 1509
      goto out_no_copy;
    } else {

    }
  } else {
#line 1512
    srf->snooper.image = 0;
  }
#line 1514
  srf->snooper.crtc = 0;
#line 1516
  user_srf->base.shareable = 0;
#line 1517
  user_srf->base.tfile = 0;
#line 1524
  ret = vmw_surface_init(dev_priv, srf, & vmw_user_surface_free);
#line 1525
  tmp___19 = ldv__builtin_expect(ret != 0, 0L);
#line 1525
  if (tmp___19 != 0L) {
#line 1526
    goto out_unlock;
  } else {

  }
#line 1528
  tmp___0 = vmw_resource_reference(& srf->res);
#line 1529
  ret = ttm_base_object_init(tfile, & user_srf->base, req->shareable != 0, ttm_driver_type1,
                             & vmw_user_surface_base_release, 0);
#line 1533
  tmp___20 = ldv__builtin_expect(ret != 0, 0L);
#line 1533
  if (tmp___20 != 0L) {
#line 1534
    vmw_resource_unreference(& tmp___0);
#line 1535
    vmw_resource_unreference(& res);
#line 1536
    goto out_unlock;
  } else {

  }
#line 1539
  rep->sid = (int32_t )user_srf->base.hash.key;
#line 1540
  if (rep->sid == -1) {
#line 1541
    drm_err("vmw_surface_define_ioctl", "Created bad Surface ID.\n");
  } else {

  }
#line 1543
  vmw_resource_unreference(& res);
#line 1545
  ttm_read_unlock(& vmaster->lock);
#line 1546
  return (0);
  out_no_copy: 
#line 1548
  kfree((void const   *)srf->offsets);
  out_no_offsets: 
#line 1550
  kfree((void const   *)srf->sizes);
  out_no_sizes: 
#line 1552
  kfree((void const   *)user_srf);
  out_no_user_srf: 
#line 1554
  tmp___21 = vmw_mem_glob(dev_priv);
#line 1554
  ttm_mem_global_free(tmp___21, (uint64_t )size);
  out_unlock: 
#line 1556
  ttm_read_unlock(& vmaster->lock);
#line 1557
  return (ret);
}
}
#line 1560 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  union drm_vmw_surface_reference_arg *arg ;
  struct drm_vmw_surface_arg *req ;
  struct drm_vmw_surface_create_req *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct drm_vmw_size *user_sizes ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  long tmp___3 ;

  {
#line 1563
  arg = (union drm_vmw_surface_reference_arg *)data;
#line 1565
  req = & arg->req;
#line 1566
  rep = & arg->rep;
#line 1567
  tmp = vmw_fpriv(file_priv);
#line 1567
  tfile = tmp->tfile;
#line 1572
  ret = -22;
#line 1574
  base = ttm_base_object_lookup(tfile, (uint32_t )req->sid);
#line 1575
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 1575
  if (tmp___0 != 0L) {
#line 1576
    drm_err("vmw_surface_reference_ioctl", "Could not find surface to reference.\n");
#line 1577
    return (-22);
  } else {

  }
#line 1580
  tmp___1 = ldv__builtin_expect((unsigned int )base->object_type != 257U, 0L);
#line 1580
  if (tmp___1 != 0L) {
#line 1581
    goto out_bad_resource;
  } else {

  }
#line 1583
  __mptr = (struct ttm_base_object  const  *)base;
#line 1583
  user_srf = (struct vmw_user_surface *)__mptr;
#line 1584
  srf = & user_srf->srf;
#line 1586
  ret = ttm_ref_object_add(tfile, & user_srf->base, TTM_REF_USAGE, 0);
#line 1587
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1587
  if (tmp___2 != 0L) {
#line 1588
    drm_err("vmw_surface_reference_ioctl", "Could not add a reference to a surface.\n");
#line 1589
    goto out_no_reference;
  } else {

  }
#line 1592
  rep->flags = srf->flags;
#line 1593
  rep->format = srf->format;
#line 1594
  __len = 24UL;
#line 1594
  if (__len > 63UL) {
#line 1594
    __ret = __memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                     __len);
  } else {
#line 1594
    __ret = __builtin_memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                             __len);
  }
#line 1595
  user_sizes = (struct drm_vmw_size *)rep->size_addr;
#line 1598
  if ((unsigned long )user_sizes != (unsigned long )((struct drm_vmw_size *)0)) {
#line 1599
    ret = copy_to_user((void *)user_sizes, (void const   *)srf->sizes, srf->num_sizes * 16U);
  } else {

  }
#line 1601
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1601
  if (tmp___3 != 0L) {
#line 1602
    drm_err("vmw_surface_reference_ioctl", "copy_to_user failed %p %u\n", user_sizes,
            srf->num_sizes);
#line 1604
    ret = -14;
  } else {

  }
  out_bad_resource: ;
  out_no_reference: 
#line 1608
  ttm_base_object_unref(& base);
#line 1610
  return (ret);
}
}
#line 1613 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 1620
  ret = -1;
#line 1622
  base = ttm_base_object_lookup(tfile, handle);
#line 1623
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 1623
  if (tmp != 0L) {
#line 1624
    return (-22);
  } else {

  }
#line 1626
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != 257U, 0L);
#line 1626
  if (tmp___0 != 0L) {
#line 1627
    goto out_bad_surface;
  } else {

  }
#line 1629
  __mptr = (struct ttm_base_object  const  *)base;
#line 1629
  user_srf = (struct vmw_user_surface *)__mptr;
#line 1630
  *id = user_srf->srf.res.id;
#line 1631
  ret = 0;
  out_bad_surface: 
#line 1639
  ttm_base_object_unref(& base);
#line 1640
  return (ret);
}
}
#line 1646 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;

  {
#line 1648
  tmp = vmw_dma_buffer(bo);
#line 1648
  vmw_bo = tmp;
#line 1650
  kfree((void const   *)vmw_bo);
#line 1651
  return;
}
}
#line 1653 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) 
{ 
  struct ttm_bo_device *bdev ;
  size_t acc_size ;
  int ret ;
  long tmp ;

  {
#line 1659
  bdev = & dev_priv->bdev;
#line 1663
  tmp = ldv__builtin_expect((unsigned long )bo_free == (unsigned long )((void (*)(struct ttm_buffer_object * ))0),
                         0L);
#line 1663
  if (tmp != 0L) {
#line 1663
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (1663), "i" (12UL));
    ldv_39483: ;
#line 1663
    goto ldv_39483;
  } else {

  }
#line 1665
  acc_size = ttm_bo_acc_size(bdev, size, 472U);
#line 1666
  memset((void *)vmw_bo, 0, 472UL);
#line 1668
  INIT_LIST_HEAD(& vmw_bo->validate_list);
#line 1670
  ret = ttm_bo_init(bdev, & vmw_bo->base, size, ttm_bo_type_device, placement, 0U,
                    0UL, (int )interruptible, 0, acc_size, 0, bo_free);
#line 1674
  return (ret);
}
}
#line 1677 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct vmw_user_dma_buffer *tmp ;

  {
#line 1679
  tmp = vmw_user_dma_buffer(bo);
#line 1679
  vmw_user_bo = tmp;
#line 1681
  kfree((void const   *)vmw_user_bo);
#line 1682
  return;
}
}
#line 1684 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_release(struct ttm_base_object **p_base ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 1687
  base = *p_base;
#line 1690
  *p_base = 0;
#line 1692
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 1692
  if (tmp != 0L) {
#line 1693
    return;
  } else {

  }
#line 1695
  __mptr = (struct ttm_base_object  const  *)base;
#line 1695
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 1696
  bo = & vmw_user_bo->dma.base;
#line 1697
  ttm_bo_unref(& bo);
#line 1698
  return;
}
}
#line 1700 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  union drm_vmw_alloc_dmabuf_arg *arg ;
  struct drm_vmw_alloc_dmabuf_req *req ;
  struct drm_vmw_dmabuf_rep *rep ;
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_buffer_object *tmp___0 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct vmw_fpriv *tmp___6 ;
  long tmp___7 ;

  {
#line 1703
  tmp = vmw_priv(dev);
#line 1703
  dev_priv = tmp;
#line 1704
  arg = (union drm_vmw_alloc_dmabuf_arg *)data;
#line 1706
  req = & arg->req;
#line 1707
  rep = & arg->rep;
#line 1710
  tmp___1 = vmw_master(file_priv->master);
#line 1710
  vmaster = tmp___1;
#line 1713
  tmp___2 = kzalloc(536UL, 208U);
#line 1713
  vmw_user_bo = (struct vmw_user_dma_buffer *)tmp___2;
#line 1714
  tmp___3 = ldv__builtin_expect((unsigned long )vmw_user_bo == (unsigned long )((struct vmw_user_dma_buffer *)0),
                             0L);
#line 1714
  if (tmp___3 != 0L) {
#line 1715
    return (-12);
  } else {

  }
#line 1717
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1718
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1718
  if (tmp___4 != 0L) {
#line 1719
    kfree((void const   *)vmw_user_bo);
#line 1720
    return (ret);
  } else {

  }
#line 1723
  ret = vmw_dmabuf_init(dev_priv, & vmw_user_bo->dma, (size_t )req->size, & vmw_vram_sys_placement,
                        1, & vmw_user_dmabuf_destroy);
#line 1726
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1726
  if (tmp___5 != 0L) {
#line 1727
    goto out_no_dmabuf;
  } else {

  }
#line 1729
  tmp___0 = ttm_bo_reference(& vmw_user_bo->dma.base);
#line 1730
  tmp___6 = vmw_fpriv(file_priv);
#line 1730
  ret = ttm_base_object_init(tmp___6->tfile, & vmw_user_bo->base, 0, ttm_buffer_type,
                             & vmw_user_dmabuf_release, 0);
#line 1735
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1735
  if (tmp___7 != 0L) {

  } else {
#line 1738
    rep->handle = (uint32_t )vmw_user_bo->base.hash.key;
#line 1739
    rep->map_handle = vmw_user_bo->dma.base.addr_space_offset;
#line 1740
    rep->cur_gmr_id = (uint32_t )vmw_user_bo->base.hash.key;
#line 1741
    rep->cur_gmr_offset = 0U;
  }
#line 1745
  ttm_bo_unref(& tmp___0);
  out_no_dmabuf: 
#line 1747
  ttm_read_unlock(& vmaster->lock);
#line 1749
  return (ret);
}
}
#line 1752 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_unref_dmabuf_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 1755
  arg = (struct drm_vmw_unref_dmabuf_arg *)data;
#line 1758
  tmp = vmw_fpriv(file_priv);
#line 1758
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, TTM_REF_USAGE);
#line 1758
  return (tmp___0);
}
}
#line 1763 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;
  long tmp___0 ;

  {
#line 1766
  tmp = vmw_dma_buffer(bo);
#line 1766
  vmw_bo = tmp;
#line 1768
  tmp___0 = ldv__builtin_expect((long )vmw_bo->on_validate_list, 1L);
#line 1768
  if (tmp___0 != 0L) {
#line 1769
    return (vmw_bo->cur_validate_node);
  } else {

  }
#line 1771
  vmw_bo->cur_validate_node = cur_validate_node;
#line 1772
  vmw_bo->on_validate_list = 1;
#line 1774
  return (cur_validate_node);
}
}
#line 1777 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) 
{ 
  struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;

  {
#line 1779
  tmp = vmw_dma_buffer(bo);
#line 1779
  vmw_bo = tmp;
#line 1781
  vmw_bo->on_validate_list = 0;
#line 1782
  return;
}
}
#line 1784 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) 
{ 
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  long tmp ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 1790
  base = ttm_base_object_lookup(tfile, handle);
#line 1791
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 1791
  if (tmp != 0L) {
#line 1792
    printk("<3>Invalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 1794
    return (-3);
  } else {

  }
#line 1797
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != 1U, 0L);
#line 1797
  if (tmp___0 != 0L) {
#line 1798
    ttm_base_object_unref(& base);
#line 1799
    printk("<3>Invalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 1801
    return (-22);
  } else {

  }
#line 1804
  __mptr = (struct ttm_base_object  const  *)base;
#line 1804
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 1805
  ttm_bo_reference(& vmw_user_bo->dma.base);
#line 1806
  ttm_base_object_unref(& base);
#line 1807
  *out = & vmw_user_bo->dma;
#line 1809
  return (0);
}
}
#line 1816 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_stream_destroy(struct vmw_resource *res ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_stream *stream ;
  int ret ;
  struct vmw_resource  const  *__mptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 1818
  dev_priv = res->dev_priv;
#line 1822
  printk("<6>[drm] %s: unref\n", "vmw_stream_destroy");
#line 1823
  __mptr = (struct vmw_resource  const  *)res;
#line 1823
  stream = (struct vmw_stream *)__mptr;
#line 1825
  ret = vmw_overlay_unref(dev_priv, stream->stream_id);
#line 1826
  __ret_warn_on = ret != 0;
#line 1826
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1826
  if (tmp != 0L) {
#line 1826
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared",
                       1826);
  } else {

  }
#line 1826
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1828
  return;
}
}
#line 1829 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_stream_init(struct vmw_private *dev_priv , struct vmw_stream *stream ,
                           void (*res_free)(struct vmw_resource * ) ) 
{ 
  struct vmw_resource *res ;
  int ret ;
  long tmp ;

  {
#line 1833
  res = & stream->res;
#line 1836
  ret = vmw_resource_init(dev_priv, res, & dev_priv->stream_idr, ttm_driver_type2,
                          0, res_free, 0);
#line 1839
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1839
  if (tmp != 0L) {
#line 1840
    if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 1841
      kfree((void const   *)stream);
    } else {
#line 1843
      (*res_free)(& stream->res);
    }
#line 1844
    return (ret);
  } else {

  }
#line 1847
  ret = vmw_overlay_claim(dev_priv, & stream->stream_id);
#line 1848
  if (ret != 0) {
#line 1849
    vmw_resource_unreference(& res);
#line 1850
    return (ret);
  } else {

  }
#line 1853
  printk("<6>[drm] %s: claimed\n", "vmw_stream_init");
#line 1855
  vmw_resource_activate(& stream->res, & vmw_stream_destroy);
#line 1856
  return (0);
}
}
#line 1863 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_free(struct vmw_resource *res ) 
{ 
  struct vmw_user_stream *stream ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 1866
  __mptr = (struct vmw_resource  const  *)res;
#line 1866
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffc0UL;
#line 1867
  dev_priv = res->dev_priv;
#line 1869
  kfree((void const   *)stream);
#line 1870
  tmp = vmw_mem_glob(dev_priv);
#line 1870
  ttm_mem_global_free(tmp, vmw_user_stream_size);
#line 1871
  return;
}
}
#line 1879 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_stream *stream ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 1881
  base = *p_base;
#line 1883
  __mptr = (struct ttm_base_object  const  *)base;
#line 1883
  stream = (struct vmw_user_stream *)__mptr;
#line 1884
  res = & stream->stream.res;
#line 1886
  *p_base = 0;
#line 1887
  vmw_resource_unreference(& res);
#line 1888
  return;
}
}
#line 1890 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_resource *res ;
  struct vmw_user_stream *stream ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  int ret ;
  long tmp___1 ;
  struct vmw_resource  const  *__mptr ;

  {
#line 1893
  tmp = vmw_priv(dev);
#line 1893
  dev_priv = tmp;
#line 1896
  arg = (struct drm_vmw_stream_arg *)data;
#line 1897
  tmp___0 = vmw_fpriv(file_priv);
#line 1897
  tfile = tmp___0->tfile;
#line 1898
  ret = 0;
#line 1900
  res = vmw_resource_lookup(dev_priv, & dev_priv->stream_idr, (int )arg->stream_id);
#line 1901
  tmp___1 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 1901
  if (tmp___1 != 0L) {
#line 1902
    return (-22);
  } else {

  }
#line 1904
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 1905
    ret = -22;
#line 1906
    goto out;
  } else {

  }
#line 1909
  __mptr = (struct vmw_resource  const  *)res;
#line 1909
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffc0UL;
#line 1910
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 1911
    ret = -22;
#line 1912
    goto out;
  } else {

  }
#line 1915
  ttm_ref_object_base_unref(tfile, stream->base.hash.key, TTM_REF_USAGE);
  out: 
#line 1917
  vmw_resource_unreference(& res);
#line 1918
  return (ret);
}
}
#line 1921 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 1924
  tmp = vmw_priv(dev);
#line 1924
  dev_priv = tmp;
#line 1928
  arg = (struct drm_vmw_stream_arg *)data;
#line 1929
  tmp___1 = vmw_fpriv(file_priv);
#line 1929
  tfile = tmp___1->tfile;
#line 1930
  tmp___2 = vmw_master(file_priv->master);
#line 1930
  vmaster = tmp___2;
#line 1938
  tmp___4 = ldv__builtin_expect(vmw_user_stream_size == 0ULL, 0L);
#line 1938
  if (tmp___4 != 0L) {
#line 1939
    tmp___3 = ttm_round_pot(168UL);
#line 1939
    vmw_user_stream_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 1941
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1942
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1942
  if (tmp___5 != 0L) {
#line 1943
    return (ret);
  } else {

  }
#line 1945
  tmp___6 = vmw_mem_glob(dev_priv);
#line 1945
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_stream_size, 0, 1);
#line 1948
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1948
  if (tmp___7 != 0L) {
#line 1949
    if (ret != -512) {
#line 1950
      drm_err("vmw_stream_claim_ioctl", "Out of graphics memory for stream creation.\n");
    } else {

    }
#line 1952
    goto out_unlock;
  } else {

  }
#line 1956
  tmp___8 = kmalloc(168UL, 208U);
#line 1956
  stream = (struct vmw_user_stream *)tmp___8;
#line 1957
  tmp___10 = ldv__builtin_expect((unsigned long )stream == (unsigned long )((struct vmw_user_stream *)0),
                              0L);
#line 1957
  if (tmp___10 != 0L) {
#line 1958
    tmp___9 = vmw_mem_glob(dev_priv);
#line 1958
    ttm_mem_global_free(tmp___9, vmw_user_stream_size);
#line 1960
    ret = -12;
#line 1961
    goto out_unlock;
  } else {

  }
#line 1964
  res = & stream->stream.res;
#line 1965
  stream->base.shareable = 0;
#line 1966
  stream->base.tfile = 0;
#line 1972
  ret = vmw_stream_init(dev_priv, & stream->stream, & vmw_user_stream_free);
#line 1973
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 1973
  if (tmp___11 != 0L) {
#line 1974
    goto out_unlock;
  } else {

  }
#line 1976
  tmp___0 = vmw_resource_reference(res);
#line 1977
  ret = ttm_base_object_init(tfile, & stream->base, 0, ttm_driver_type2, & vmw_user_stream_base_release,
                             0);
#line 1980
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 1980
  if (tmp___12 != 0L) {
#line 1981
    vmw_resource_unreference(& tmp___0);
#line 1982
    goto out_err;
  } else {

  }
#line 1985
  arg->stream_id = (uint32_t )res->id;
  out_err: 
#line 1987
  vmw_resource_unreference(& res);
  out_unlock: 
#line 1989
  ttm_read_unlock(& vmaster->lock);
#line 1990
  return (ret);
}
}
#line 1993 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) 
{ 
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  struct vmw_resource  const  *__mptr ;

  {
#line 2001
  res = vmw_resource_lookup(dev_priv, & dev_priv->stream_idr, (int )*inout_id);
#line 2002
  tmp = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                         0L);
#line 2002
  if (tmp != 0L) {
#line 2003
    return (-22);
  } else {

  }
#line 2005
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 2006
    ret = -22;
#line 2007
    goto err_ref;
  } else {

  }
#line 2010
  __mptr = (struct vmw_resource  const  *)res;
#line 2010
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffc0UL;
#line 2011
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 2012
    ret = -1;
#line 2013
    goto err_ref;
  } else {

  }
#line 2016
  *inout_id = stream->stream.stream_id;
#line 2017
  *out = res;
#line 2018
  return (0);
  err_ref: 
#line 2020
  vmw_resource_unreference(& res);
#line 2021
  return (ret);
}
}
#line 2024 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2029
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2031
  mutex_lock(ldv_func_arg1);
#line 2032
  return;
}
}
#line 2034 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int ldv_mutex_trylock_234(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2039
  tmp = mutex_trylock(ldv_func_arg1);
#line 2039
  ldv_func_res = tmp;
#line 2041
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 2041
  return (tmp___0);
#line 2043
  return (ldv_func_res);
}
}
#line 2046 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_235(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2051
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2053
  mutex_unlock(ldv_func_arg1);
#line 2054
  return;
}
}
#line 2056 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_236(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2061
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2063
  mutex_lock(ldv_func_arg1);
#line 2064
  return;
}
}
#line 2066 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_237(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2071
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2073
  mutex_unlock(ldv_func_arg1);
#line 2074
  return;
}
}
#line 2076 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2081
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 2083
  mutex_lock(ldv_func_arg1);
#line 2084
  return;
}
}
#line 2086 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2091
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 2093
  mutex_unlock(ldv_func_arg1);
#line 2094
  return;
}
}
#line 2096 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2101
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2103
  mutex_unlock(ldv_func_arg1);
#line 2104
  return;
}
}
#line 2106 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_241(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2111
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 2113
  mutex_lock(ldv_func_arg1);
#line 2114
  return;
}
}
#line 2116 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2121
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 2123
  mutex_unlock(ldv_func_arg1);
#line 2124
  return;
}
}
#line 2126 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2131
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2133
  mutex_lock(ldv_func_arg1);
#line 2134
  return;
}
}
#line 2136 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2141
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2143
  mutex_unlock(ldv_func_arg1);
#line 2144
  return;
}
}
#line 2146 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2151
  ldv_mutex_lock_cmdbuf_mutex(ldv_func_arg1);
#line 2153
  mutex_lock(ldv_func_arg1);
#line 2154
  return;
}
}
#line 2156 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2161
  ldv_mutex_unlock_cmdbuf_mutex(ldv_func_arg1);
#line 2163
  mutex_unlock(ldv_func_arg1);
#line 2164
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) ;
#line 605 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_tt_init(struct ttm_tt * , struct ttm_bo_device * , unsigned long  ,
                       uint32_t  , struct page * ) ;
#line 619
extern void ttm_tt_fini(struct ttm_tt * ) ;
#line 1011
extern struct ttm_mem_type_manager_func  const  ttm_bo_manager_func ;
#line 73 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) ;
#line 77
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) ;
#line 84
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) ;
#line 519 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct ttm_placement vmw_vram_gmr_ne_placement ;
#line 520
struct ttm_placement vmw_sys_placement ;
#line 521
struct ttm_placement vmw_evictable_placement ;
#line 668
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func ;
#line 48 "include/drm/ttm/ttm_page_alloc.h"
extern int ttm_pool_populate(struct ttm_tt * ) ;
#line 57
extern void ttm_pool_unpopulate(struct ttm_tt * ) ;
#line 137 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_placement_flags  =    65540U;
#line 140 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_ne_placement_flags  =    2162692U;
#line 144 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t sys_placement_flags  =    65537U;
#line 147 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_placement_flags  =    65544U;
#line 150 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_ne_placement_flags  =    2162696U;
#line 154 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& vram_placement_flags)};
#line 163 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_placement_flags[2U]  = {      65540U,      65544U};
#line 168 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_vram_placement_flags[2U]  = {      65544U,      65540U};
#line 173 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_placement_flags), 1U, (uint32_t const   *)(& gmr_placement_flags)};
#line 182 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_ne_placement_flags[2U]  = {      2162692U,      2162696U};
#line 187 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_ne_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_ne_placement_flags), 1U, (uint32_t const   *)(& gmr_ne_placement_flags)};
#line 196 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 205 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_ne_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_ne_placement_flags), 1U, (uint32_t const   *)(& vram_ne_placement_flags)};
#line 214 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& sys_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 223 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t evictable_placement_flags[3U]  = {      65537U,      65540U,      65544U};
#line 229 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_evictable_placement  =    {0U, 0U, 3U, (uint32_t const   *)(& evictable_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 238 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_srf_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& gmr_placement_flags), 2U, (uint32_t const   *)(& gmr_vram_placement_flags)};
#line 253 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_bind(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;
  int tmp ;

  {
#line 255
  __mptr = (struct ttm_tt  const  *)ttm;
#line 255
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 257
  vmw_be->gmr_id = (int )bo_mem->start;
#line 259
  tmp = vmw_gmr_bind(vmw_be->dev_priv, ttm->pages, ttm->num_pages, vmw_be->gmr_id);
#line 259
  return (tmp);
}
}
#line 263 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_unbind(struct ttm_tt *ttm ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 265
  __mptr = (struct ttm_tt  const  *)ttm;
#line 265
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 267
  vmw_gmr_unbind(vmw_be->dev_priv, vmw_be->gmr_id);
#line 268
  return (0);
}
}
#line 271 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_destroy(struct ttm_tt *ttm ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 273
  __mptr = (struct ttm_tt  const  *)ttm;
#line 273
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 275
  ttm_tt_fini(ttm);
#line 276
  kfree((void const   *)vmw_be);
#line 277
  return;
}
}
#line 279 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static struct ttm_backend_func vmw_ttm_func  =    {& vmw_ttm_bind, & vmw_ttm_unbind, & vmw_ttm_destroy};
#line 285 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_tt *vmw_ttm_tt_create(struct ttm_bo_device *bdev , unsigned long size ,
                                 uint32_t page_flags , struct page *dummy_read_page ) 
{ 
  struct vmw_ttm_tt *vmw_be ;
  void *tmp ;
  struct ttm_bo_device  const  *__mptr ;
  int tmp___0 ;

  {
#line 291
  tmp = kmalloc(104UL, 208U);
#line 291
  vmw_be = (struct vmw_ttm_tt *)tmp;
#line 292
  if ((unsigned long )vmw_be == (unsigned long )((struct vmw_ttm_tt *)0)) {
#line 293
    return (0);
  } else {

  }
#line 295
  vmw_be->ttm.func = & vmw_ttm_func;
#line 296
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 296
  vmw_be->dev_priv = (struct vmw_private *)__mptr;
#line 298
  tmp___0 = ttm_tt_init(& vmw_be->ttm, bdev, size, page_flags, dummy_read_page);
#line 298
  if (tmp___0 != 0) {
#line 299
    kfree((void const   *)vmw_be);
#line 300
    return (0);
  } else {

  }
#line 303
  return (& vmw_be->ttm);
}
}
#line 306 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_invalidate_caches(struct ttm_bo_device *bdev , uint32_t flags ) 
{ 


  {
#line 308
  return (0);
}
}
#line 311 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_init_mem_type(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) 
{ 


  {
#line 314
  switch (type) {
  case (uint32_t )0: 
#line 318
  man->flags = 2U;
#line 319
  man->available_caching = 65536U;
#line 320
  man->default_caching = 65536U;
#line 321
  goto ldv_39092;
  case (uint32_t )2: 
#line 324
  man->func = & ttm_bo_manager_func;
#line 325
  man->gpu_offset = 0UL;
#line 326
  man->flags = 3U;
#line 327
  man->available_caching = 65536U;
#line 328
  man->default_caching = 65536U;
#line 329
  goto ldv_39092;
  case (uint32_t )3: 
#line 336
  man->func = & vmw_gmrid_manager_func;
#line 337
  man->gpu_offset = 0UL;
#line 338
  man->flags = 10U;
#line 339
  man->available_caching = 65536U;
#line 340
  man->default_caching = 65536U;
#line 341
  goto ldv_39092;
  default: 
#line 343
  drm_err("vmw_init_mem_type", "Unsupported memory type %u\n", type);
#line 344
  return (-22);
  }
  ldv_39092: ;
#line 346
  return (0);
}
}
#line 349 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void vmw_evict_flags(struct ttm_buffer_object *bo , struct ttm_placement *placement ) 
{ 


  {
#line 352
  *placement = vmw_sys_placement;
#line 353
  return;
}
}
#line 359 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_verify_access(struct ttm_buffer_object *bo , struct file *filp ) 
{ 


  {
#line 361
  return (0);
}
}
#line 364 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_io_mem_reserve(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 
  struct ttm_mem_type_manager *man ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;

  {
#line 366
  man = (struct ttm_mem_type_manager *)(& bdev->man) + (unsigned long )mem->mem_type;
#line 367
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 367
  dev_priv = (struct vmw_private *)__mptr;
#line 369
  mem->bus.addr = 0;
#line 370
  mem->bus.is_iomem = 0;
#line 371
  mem->bus.offset = 0UL;
#line 372
  mem->bus.size = mem->num_pages << 12;
#line 373
  mem->bus.base = 0UL;
#line 374
  if ((man->flags & 2U) == 0U) {
#line 375
    return (-22);
  } else {

  }
#line 376
  switch (mem->mem_type) {
  case (uint32_t )0: ;
  case (uint32_t )3: ;
#line 379
  return (0);
  case (uint32_t )2: 
#line 381
  mem->bus.offset = mem->start << 12;
#line 382
  mem->bus.base = (unsigned long )dev_priv->vram_start;
#line 383
  mem->bus.is_iomem = 1;
#line 384
  goto ldv_39116;
  default: ;
#line 386
  return (-22);
  }
  ldv_39116: ;
#line 388
  return (0);
}
}
#line 391 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_io_mem_free(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 


  {
#line 393
  return;
}
}
#line 395 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_fault_reserve_notify(struct ttm_buffer_object *bo ) 
{ 


  {
#line 397
  return (0);
}
}
#line 405 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void *vmw_sync_obj_ref(void *sync_obj ) 
{ 
  struct vmw_fence_obj *tmp ;

  {
#line 408
  tmp = vmw_fence_obj_reference((struct vmw_fence_obj *)sync_obj);
#line 408
  return ((void *)tmp);
}
}
#line 412 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_sync_obj_unref(void **sync_obj ) 
{ 


  {
#line 414
  vmw_fence_obj_unreference((struct vmw_fence_obj **)sync_obj);
#line 415
  return;
}
}
#line 417 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_flush(void *sync_obj , void *sync_arg ) 
{ 


  {
#line 419
  vmw_fence_obj_flush((struct vmw_fence_obj *)sync_obj);
#line 420
  return (0);
}
}
#line 423 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static bool vmw_sync_obj_signaled(void *sync_obj , void *sync_arg ) 
{ 
  unsigned long flags ;
  bool tmp ;

  {
#line 425
  flags = (unsigned long )sync_arg;
#line 426
  tmp = vmw_fence_obj_signaled((struct vmw_fence_obj *)sync_obj, (unsigned int )flags);
#line 426
  return (tmp);
}
}
#line 431 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_wait(void *sync_obj , void *sync_arg , bool lazy , bool interruptible ) 
{ 
  unsigned long flags ;
  int tmp ;

  {
#line 434
  flags = (unsigned long )sync_arg;
#line 436
  tmp = vmw_fence_obj_wait((struct vmw_fence_obj *)sync_obj, (unsigned int )flags,
                           (int )lazy, (int )interruptible, 1250UL);
#line 436
  return (tmp);
}
}
#line 442 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_bo_driver vmw_bo_driver  = 
#line 442
     {& vmw_ttm_tt_create, & ttm_pool_populate, & ttm_pool_unpopulate, & vmw_invalidate_caches,
    & vmw_init_mem_type, & vmw_evict_flags, 0, & vmw_verify_access, & vmw_sync_obj_signaled,
    & vmw_sync_obj_wait, & vmw_sync_obj_flush, & vmw_sync_obj_unref, & vmw_sync_obj_ref,
    0, & vmw_ttm_fault_reserve_notify, 0, & vmw_ttm_io_mem_reserve, & vmw_ttm_io_mem_free};
#line 500 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_main7_sequence_infinite_withcheck_stateful(void) 
{ 
  struct ttm_tt *var_group1 ;
  struct ttm_mem_reg *var_group2 ;
  struct ttm_bo_device *var_group3 ;
  uint32_t var_vmw_invalidate_caches_4_p1 ;
  uint32_t var_vmw_init_mem_type_5_p1 ;
  struct ttm_mem_type_manager *var_vmw_init_mem_type_5_p2 ;
  struct ttm_buffer_object *var_group4 ;
  struct ttm_placement *var_group5 ;
  struct file *var_group6 ;
  void *var_vmw_sync_obj_signaled_14_p0 ;
  void *var_vmw_sync_obj_signaled_14_p1 ;
  void *var_vmw_sync_obj_wait_15_p0 ;
  void *var_vmw_sync_obj_wait_15_p1 ;
  bool var_vmw_sync_obj_wait_15_p2 ;
  bool var_vmw_sync_obj_wait_15_p3 ;
  void *var_vmw_sync_obj_flush_13_p0 ;
  void *var_vmw_sync_obj_flush_13_p1 ;
  void **var_vmw_sync_obj_unref_12_p0 ;
  void *var_vmw_sync_obj_ref_11_p0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 578
  LDV_IN_INTERRUPT = 1;
#line 587
  ldv_initialize();
#line 593
  goto ldv_39198;
  ldv_39197: 
#line 596
  tmp = __VERIFIER_nondet_int();
#line 596
  switch (tmp) {
  case 0: 
#line 606
  ldv_handler_precall();
#line 607
  vmw_ttm_bind(var_group1, var_group2);
#line 614
  goto ldv_39184;
  case 1: 
#line 623
  ldv_handler_precall();
#line 624
  vmw_ttm_unbind(var_group1);
#line 631
  goto ldv_39184;
  case 2: 
#line 640
  ldv_handler_precall();
#line 641
  vmw_ttm_destroy(var_group1);
#line 648
  goto ldv_39184;
  case 3: 
#line 657
  ldv_handler_precall();
#line 658
  vmw_invalidate_caches(var_group3, var_vmw_invalidate_caches_4_p1);
#line 665
  goto ldv_39184;
  case 4: 
#line 674
  ldv_handler_precall();
#line 675
  vmw_init_mem_type(var_group3, var_vmw_init_mem_type_5_p1, var_vmw_init_mem_type_5_p2);
#line 682
  goto ldv_39184;
  case 5: 
#line 691
  ldv_handler_precall();
#line 692
  vmw_evict_flags(var_group4, var_group5);
#line 699
  goto ldv_39184;
  case 6: 
#line 708
  ldv_handler_precall();
#line 709
  vmw_verify_access(var_group4, var_group6);
#line 716
  goto ldv_39184;
  case 7: 
#line 725
  ldv_handler_precall();
#line 726
  vmw_sync_obj_signaled(var_vmw_sync_obj_signaled_14_p0, var_vmw_sync_obj_signaled_14_p1);
#line 733
  goto ldv_39184;
  case 8: 
#line 742
  ldv_handler_precall();
#line 743
  vmw_sync_obj_wait(var_vmw_sync_obj_wait_15_p0, var_vmw_sync_obj_wait_15_p1, (int )var_vmw_sync_obj_wait_15_p2,
                    (int )var_vmw_sync_obj_wait_15_p3);
#line 750
  goto ldv_39184;
  case 9: 
#line 759
  ldv_handler_precall();
#line 760
  vmw_sync_obj_flush(var_vmw_sync_obj_flush_13_p0, var_vmw_sync_obj_flush_13_p1);
#line 767
  goto ldv_39184;
  case 10: 
#line 776
  ldv_handler_precall();
#line 777
  vmw_sync_obj_unref(var_vmw_sync_obj_unref_12_p0);
#line 784
  goto ldv_39184;
  case 11: 
#line 793
  ldv_handler_precall();
#line 794
  vmw_sync_obj_ref(var_vmw_sync_obj_ref_11_p0);
#line 801
  goto ldv_39184;
  default: ;
#line 802
  goto ldv_39184;
  }
  ldv_39184: ;
  ldv_39198: 
#line 593
  tmp___0 = __VERIFIER_nondet_int();
#line 593
  if (tmp___0 != 0) {
#line 594
    goto ldv_39197;
  } else {

  }


#line 811
  ldv_check_final_state();
#line 814
  return;
}
}
#line 818 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 823
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 833
  tmp = mutex_trylock(ldv_func_arg1);
#line 833
  ldv_func_res = tmp;
#line 835
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 835
  return (tmp___0);
#line 837
  return (ldv_func_res);
}
}
#line 840 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 845
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 847
  mutex_unlock(ldv_func_arg1);
#line 848
  return;
}
}
#line 850 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 855
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 857
  mutex_lock(ldv_func_arg1);
#line 858
  return;
}
}
#line 860 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 865
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 867
  mutex_unlock(ldv_func_arg1);
#line 868
  return;
}
}
#line 870 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 875
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 877
  mutex_lock(ldv_func_arg1);
#line 878
  return;
}
}
#line 880 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 885
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 887
  mutex_unlock(ldv_func_arg1);
#line 888
  return;
}
}
#line 890 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 895
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 897
  mutex_unlock(ldv_func_arg1);
#line 898
  return;
}
}
#line 900 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 905
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 907
  mutex_lock(ldv_func_arg1);
#line 908
  return;
}
}
#line 910 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 915
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 917
  mutex_unlock(ldv_func_arg1);
#line 918
  return;
}
}
#line 920 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 925
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 927
  mutex_lock(ldv_func_arg1);
#line 928
  return;
}
}
#line 930 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 935
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 937
  mutex_unlock(ldv_func_arg1);
#line 938
  return;
}
}
#line 317 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 321
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 326
  return (oldbit);
}
}
#line 10 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2869;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2869;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2869;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2869;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2869: ;
#line 14
  return (pfo_ret__);
}
}
#line 15 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 119 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  unsigned char c ;

  {
#line 123
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 126
  return ((unsigned int )c != 0U);
}
}
#line 173 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 182
  __ret = i;
#line 182
  switch (4UL) {
  case 1UL: 
#line 182
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 182
  goto ldv_5501;
  case 2UL: 
#line 182
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 182
  goto ldv_5501;
  case 4UL: 
#line 182
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 182
  goto ldv_5501;
  case 8UL: 
#line 182
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 182
  goto ldv_5501;
  default: 
#line 182
  __xadd_wrong_size();
  }
  ldv_5501: ;
#line 182
  return (__ret + i);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_286(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_287(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_289(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_291(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_294(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_296(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_298(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_309(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_285(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_288(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_290(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_295(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_297(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_299(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) ;
#line 79
void ldv_mutex_lock_fifo_mutex(struct mutex *lock ) ;
#line 83
void ldv_mutex_unlock_fifo_mutex(struct mutex *lock ) ;
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 155 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 584
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 586
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 589
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 67 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 90
extern void down_write(struct rw_semaphore * ) ;
#line 105
extern void up_write(struct rw_semaphore * ) ;
#line 82 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 215 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 217
  __len = count;
#line 217
  __ret = __builtin_memcpy((void *)dst, src, __len);
#line 219
  return;
}
}
#line 360 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 2550 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2552
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2552
  return (tmp);
}
}
#line 2576 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2578
  tmp = test_tsk_thread_flag(p, 2);
#line 2578
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2578
  return ((int )tmp___0);
}
}
#line 589 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) ;
#line 590
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) ;
#line 591
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) ;
#line 135 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) 
{ 
  __le32 *fifo_mem ;
  uint32_t fifo_min ;
  uint32_t hwversion ;
  struct vmw_fifo_state  const  *fifo ;

  {
#line 137
  fifo_mem = dev_priv->mmio_virt;
#line 139
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 141
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 142
    return (0);
  } else {

  }
#line 144
  fifo_min = ioread32((void *)fifo_mem);
#line 145
  if (fifo_min <= 28U) {
#line 146
    return (0);
  } else {

  }
#line 148
  hwversion = ioread32((void *)(fifo_mem + (((unsigned int )fifo->capabilities & 256U) != 0U ? 17UL : 7UL)));
#line 154
  if (hwversion == 0U) {
#line 155
    return (0);
  } else {

  }
#line 157
  if (hwversion <= 131072U) {
#line 158
    return (0);
  } else {

  }
#line 161
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 162
    return (0);
  } else {

  }
#line 164
  return (1);
}
}
#line 167 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) 
{ 
  __le32 *fifo_mem ;
  uint32_t caps ;

  {
#line 169
  fifo_mem = dev_priv->mmio_virt;
#line 172
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 173
    return (0);
  } else {

  }
#line 175
  caps = ioread32((void *)fifo_mem + 4U);
#line 176
  if ((caps & 4U) != 0U) {
#line 177
    return (1);
  } else {

  }
#line 179
  return (0);
}
}
#line 182 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ 
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t dummy ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 184
  fifo_mem = dev_priv->mmio_virt;
#line 189
  fifo->static_buffer_size = 1048576UL;
#line 190
  tmp = vmalloc(fifo->static_buffer_size);
#line 190
  fifo->static_buffer = (__le32 *)tmp;
#line 191
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer == (unsigned long )((__le32 *)0),
                             0L);
#line 191
  if (tmp___0 != 0L) {
#line 192
    return (-12);
  } else {

  }
#line 194
  fifo->dynamic_buffer = 0;
#line 195
  fifo->reserved_size = 0UL;
#line 196
  fifo->using_bounce_buffer = 0;
#line 198
  __mutex_init(& fifo->fifo_mutex, "&fifo->fifo_mutex", & __key);
#line 199
  __init_rwsem(& fifo->rwsem, "&fifo->rwsem", & __key___0);
#line 205
  tmp___1 = vmw_read(dev_priv, 2U);
#line 205
  printk("<6>[drm] width %d\n", tmp___1);
#line 206
  tmp___2 = vmw_read(dev_priv, 3U);
#line 206
  printk("<6>[drm] height %d\n", tmp___2);
#line 207
  tmp___3 = vmw_read(dev_priv, 7U);
#line 207
  printk("<6>[drm] bpp %d\n", tmp___3);
#line 209
  ldv_mutex_lock_297(& dev_priv->hw_mutex);
#line 210
  dev_priv->enable_state = vmw_read(dev_priv, 1U);
#line 211
  dev_priv->config_done_state = vmw_read(dev_priv, 20U);
#line 212
  dev_priv->traces_state = vmw_read(dev_priv, 45U);
#line 213
  vmw_write(dev_priv, 1U, 1U);
#line 215
  min = 4U;
#line 216
  if ((dev_priv->capabilities & 32768U) != 0U) {
#line 217
    min = vmw_read(dev_priv, 30U);
  } else {

  }
#line 218
  min = min << 2;
#line 220
  if (min <= 4095U) {
#line 221
    min = 4096U;
  } else {

  }
#line 223
  iowrite32(min, (void *)fifo_mem);
#line 224
  iowrite32(dev_priv->mmio_size, (void *)fifo_mem + 1U);
#line 225
  __asm__  volatile   ("sfence": : : "memory");
#line 226
  iowrite32(min, (void *)fifo_mem + 2U);
#line 227
  iowrite32(min, (void *)fifo_mem + 3U);
#line 228
  iowrite32(0U, (void *)fifo_mem + 290U);
#line 229
  __asm__  volatile   ("mfence": : : "memory");
#line 231
  vmw_write(dev_priv, 20U, 1U);
#line 232
  ldv_mutex_unlock_298(& dev_priv->hw_mutex);
#line 234
  max = ioread32((void *)fifo_mem + 1U);
#line 235
  min = ioread32((void *)fifo_mem);
#line 236
  fifo->capabilities = ioread32((void *)fifo_mem + 4U);
#line 238
  printk("<6>[drm] Fifo max 0x%08x min 0x%08x cap 0x%08x\n", max, min, fifo->capabilities);
#line 243
  atomic_set(& dev_priv->marker_seq, (int )dev_priv->last_read_seqno);
#line 244
  iowrite32(dev_priv->last_read_seqno, (void *)fifo_mem + 6U);
#line 245
  vmw_marker_queue_init(& fifo->marker_queue);
#line 246
  tmp___4 = vmw_fifo_send_fence(dev_priv, & dummy);
#line 246
  return (tmp___4);
}
}
#line 249 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) 
{ 
  __le32 *fifo_mem ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 251
  fifo_mem = dev_priv->mmio_virt;
#line 253
  ldv_mutex_lock_299(& dev_priv->hw_mutex);
#line 255
  tmp = ioread32((void *)fifo_mem + 290U);
#line 255
  tmp___0 = ldv__builtin_expect(tmp == 0U, 0L);
#line 255
  if (tmp___0 != 0L) {
#line 256
    iowrite32(1U, (void *)fifo_mem + 290U);
#line 257
    vmw_write(dev_priv, 21U, reason);
  } else {

  }
#line 260
  ldv_mutex_unlock_300(& dev_priv->hw_mutex);
#line 261
  return;
}
}
#line 263 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ 
  __le32 *fifo_mem ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 265
  fifo_mem = dev_priv->mmio_virt;
#line 267
  ldv_mutex_lock_301(& dev_priv->hw_mutex);
#line 269
  goto ldv_39091;
  ldv_39090: 
#line 270
  vmw_write(dev_priv, 21U, 1U);
  ldv_39091: 
#line 269
  tmp = vmw_read(dev_priv, 22U);
#line 269
  if (tmp != 0U) {
#line 270
    goto ldv_39090;
  } else {

  }
#line 272
  dev_priv->last_read_seqno = ioread32((void *)fifo_mem + 6U);
#line 274
  vmw_write(dev_priv, 20U, dev_priv->config_done_state);
#line 276
  vmw_write(dev_priv, 1U, dev_priv->enable_state);
#line 278
  vmw_write(dev_priv, 45U, dev_priv->traces_state);
#line 281
  ldv_mutex_unlock_302(& dev_priv->hw_mutex);
#line 282
  vmw_marker_queue_takedown(& fifo->marker_queue);
#line 284
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 284
  if (tmp___0 != 0L) {
#line 285
    vfree((void const   *)fifo->static_buffer);
#line 286
    fifo->static_buffer = 0;
  } else {

  }
#line 289
  tmp___1 = ldv__builtin_expect((unsigned long )fifo->dynamic_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 289
  if (tmp___1 != 0L) {
#line 290
    vfree((void const   *)fifo->dynamic_buffer);
#line 291
    fifo->dynamic_buffer = 0;
  } else {

  }
#line 293
  return;
}
}
#line 295 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static bool vmw_fifo_is_full(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  __le32 *fifo_mem ;
  uint32_t max ;
  unsigned int tmp ;
  uint32_t next_cmd ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;

  {
#line 297
  fifo_mem = dev_priv->mmio_virt;
#line 298
  tmp = ioread32((void *)fifo_mem + 1U);
#line 298
  max = tmp;
#line 299
  tmp___0 = ioread32((void *)fifo_mem + 2U);
#line 299
  next_cmd = tmp___0;
#line 300
  tmp___1 = ioread32((void *)fifo_mem);
#line 300
  min = tmp___1;
#line 301
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 301
  stop = tmp___2;
#line 303
  return ((max - next_cmd) + (stop - min) <= bytes);
}
}
#line 306 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                               unsigned long timeout ) 
{ 
  int ret ;
  unsigned long end_jiffies ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;

  {
#line 310
  ret = 0;
#line 311
  end_jiffies = (unsigned long )jiffies + timeout;
#line 312
  tmp = get_current();
#line 312
  __wait.flags = 0U;
#line 312
  __wait.private = (void *)tmp;
#line 312
  __wait.func = & autoremove_wake_function;
#line 312
  __wait.task_list.next = & __wait.task_list;
#line 312
  __wait.task_list.prev = & __wait.task_list;
#line 314
  printk("<6>[drm] Fifo wait noirq.\n");
  ldv_39119: 
#line 317
  prepare_to_wait(& dev_priv->fifo_queue, & __wait, (int )interruptible ? 1 : 2);
#line 320
  tmp___0 = vmw_fifo_is_full(dev_priv, bytes);
#line 320
  if (tmp___0) {
#line 320
    tmp___1 = 0;
  } else {
#line 320
    tmp___1 = 1;
  }
#line 320
  if (tmp___1) {
#line 321
    goto ldv_39111;
  } else {

  }
#line 322
  if ((1 != 0 && 1 != 0) && (long )jiffies - (long )end_jiffies >= 0L) {
#line 323
    ret = -16;
#line 324
    drm_err("vmw_fifo_wait_noirq", "SVGA device lockup.\n");
#line 325
    goto ldv_39111;
  } else {

  }
#line 327
  schedule_timeout(1L);
#line 328
  if ((int )interruptible) {
#line 328
    tmp___2 = get_current();
#line 328
    tmp___3 = signal_pending(tmp___2);
#line 328
    if (tmp___3 != 0) {
#line 329
      ret = -512;
#line 330
      goto ldv_39111;
    } else {

    }
  } else {

  }
#line 332
  goto ldv_39119;
  ldv_39111: 
#line 333
  finish_wait(& dev_priv->fifo_queue, & __wait);
#line 334
  __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
#line 335
  printk("<6>[drm] Fifo noirq exit.\n");
#line 336
  return (ret);
}
}
#line 339 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                         unsigned long timeout ) 
{ 
  long ret ;
  unsigned long irq_flags ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  int tmp___4 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct task_struct *tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  raw_spinlock_t *tmp___17 ;
  int tmp___18 ;

  {
#line 343
  ret = 1L;
#line 346
  tmp = vmw_fifo_is_full(dev_priv, bytes);
#line 346
  if (tmp) {
#line 346
    tmp___0 = 0;
  } else {
#line 346
    tmp___0 = 1;
  }
#line 346
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 346
  if (tmp___1 != 0L) {
#line 347
    return (0);
  } else {

  }
#line 349
  vmw_fifo_ping_host(dev_priv, 2U);
#line 350
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 351
    tmp___2 = vmw_fifo_wait_noirq(dev_priv, bytes, (int )interruptible, timeout);
#line 351
    return (tmp___2);
  } else {

  }
#line 354
  ldv_mutex_lock_303(& dev_priv->hw_mutex);
#line 355
  tmp___4 = atomic_add_return(1, & dev_priv->fifo_queue_waiters);
#line 355
  if (tmp___4 > 0) {
#line 356
    tmp___3 = spinlock_check(& dev_priv->irq_lock);
#line 356
    irq_flags = _raw_spin_lock_irqsave(tmp___3);
#line 357
    outl(2U, (int )(dev_priv->io_start + 8U));
#line 359
    dev_priv->irq_mask = dev_priv->irq_mask | 2U;
#line 360
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 361
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 363
  ldv_mutex_unlock_304(& dev_priv->hw_mutex);
#line 365
  if ((int )interruptible) {
#line 366
    __ret = (long )timeout;
#line 366
    tmp___10 = vmw_fifo_is_full(dev_priv, bytes);
#line 366
    if ((int )tmp___10) {
#line 366
      tmp___5 = get_current();
#line 366
      __wait.flags = 0U;
#line 366
      __wait.private = (void *)tmp___5;
#line 366
      __wait.func = & autoremove_wake_function;
#line 366
      __wait.task_list.next = & __wait.task_list;
#line 366
      __wait.task_list.prev = & __wait.task_list;
      ldv_39135: 
#line 366
      prepare_to_wait(& dev_priv->fifo_queue, & __wait, 1);
#line 366
      tmp___6 = vmw_fifo_is_full(dev_priv, bytes);
#line 366
      if (tmp___6) {
#line 366
        tmp___7 = 0;
      } else {
#line 366
        tmp___7 = 1;
      }
#line 366
      if (tmp___7) {
#line 366
        goto ldv_39133;
      } else {

      }
#line 366
      tmp___8 = get_current();
#line 366
      tmp___9 = signal_pending(tmp___8);
#line 366
      if (tmp___9 == 0) {
#line 366
        __ret = schedule_timeout(__ret);
#line 366
        if (__ret == 0L) {
#line 366
          goto ldv_39133;
        } else {

        }
#line 366
        goto ldv_39134;
      } else {

      }
#line 366
      __ret = -512L;
#line 366
      goto ldv_39133;
      ldv_39134: ;
#line 366
      goto ldv_39135;
      ldv_39133: 
#line 366
      finish_wait(& dev_priv->fifo_queue, & __wait);
    } else {

    }
#line 366
    ret = __ret;
  } else {
#line 370
    __ret___0 = (long )timeout;
#line 370
    tmp___14 = vmw_fifo_is_full(dev_priv, bytes);
#line 370
    if ((int )tmp___14) {
#line 370
      tmp___11 = get_current();
#line 370
      __wait___0.flags = 0U;
#line 370
      __wait___0.private = (void *)tmp___11;
#line 370
      __wait___0.func = & autoremove_wake_function;
#line 370
      __wait___0.task_list.next = & __wait___0.task_list;
#line 370
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_39140: 
#line 370
      prepare_to_wait(& dev_priv->fifo_queue, & __wait___0, 2);
#line 370
      tmp___12 = vmw_fifo_is_full(dev_priv, bytes);
#line 370
      if (tmp___12) {
#line 370
        tmp___13 = 0;
      } else {
#line 370
        tmp___13 = 1;
      }
#line 370
      if (tmp___13) {
#line 370
        goto ldv_39139;
      } else {

      }
#line 370
      __ret___0 = schedule_timeout(__ret___0);
#line 370
      if (__ret___0 == 0L) {
#line 370
        goto ldv_39139;
      } else {

      }
#line 370
      goto ldv_39140;
      ldv_39139: 
#line 370
      finish_wait(& dev_priv->fifo_queue, & __wait___0);
    } else {

    }
#line 370
    ret = __ret___0;
  }
#line 374
  tmp___16 = ldv__builtin_expect(ret == 0L, 0L);
#line 374
  if (tmp___16 != 0L) {
#line 375
    ret = -16L;
  } else {
#line 376
    tmp___15 = ldv__builtin_expect(ret > 0L, 1L);
#line 376
    if (tmp___15 != 0L) {
#line 377
      ret = 0L;
    } else {

    }
  }
#line 379
  ldv_mutex_lock_305(& dev_priv->hw_mutex);
#line 380
  tmp___18 = atomic_dec_and_test(& dev_priv->fifo_queue_waiters);
#line 380
  if (tmp___18 != 0) {
#line 381
    tmp___17 = spinlock_check(& dev_priv->irq_lock);
#line 381
    irq_flags = _raw_spin_lock_irqsave(tmp___17);
#line 382
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967293U;
#line 383
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 384
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 386
  ldv_mutex_unlock_306(& dev_priv->hw_mutex);
#line 388
  return ((int )ret);
}
}
#line 401 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t next_cmd ;
  uint32_t reserveable ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;
  bool need_bounce ;
  bool reserve_in_place ;
  long tmp___3 ;
  bool tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;

  {
#line 403
  fifo_state = & dev_priv->fifo;
#line 404
  fifo_mem = dev_priv->mmio_virt;
#line 408
  reserveable = fifo_state->capabilities & 64U;
#line 411
  ldv_mutex_lock_307(& fifo_state->fifo_mutex);
#line 412
  max = ioread32((void *)fifo_mem + 1U);
#line 413
  min = ioread32((void *)fifo_mem);
#line 414
  next_cmd = ioread32((void *)fifo_mem + 2U);
#line 416
  tmp = ldv__builtin_expect(max - min <= bytes, 0L);
#line 416
  if (tmp != 0L) {
#line 417
    goto out_err;
  } else {

  }
#line 419
  tmp___0 = ldv__builtin_expect(fifo_state->reserved_size != 0UL, 0L);
#line 419
  if (tmp___0 != 0L) {
#line 419
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (419), "i" (12UL));
    ldv_39157: ;
#line 419
    goto ldv_39157;
  } else {

  }
#line 420
  tmp___1 = ldv__builtin_expect((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0),
                             0L);
#line 420
  if (tmp___1 != 0L) {
#line 420
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (420), "i" (12UL));
    ldv_39158: ;
#line 420
    goto ldv_39158;
  } else {

  }
#line 422
  fifo_state->reserved_size = (unsigned long )bytes;
  ldv_39162: 
#line 425
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 425
  stop = tmp___2;
#line 426
  need_bounce = 0;
#line 427
  reserve_in_place = 0;
#line 429
  if (next_cmd >= stop) {
#line 430
    tmp___5 = ldv__builtin_expect(next_cmd + bytes < max, 1L);
#line 430
    if (tmp___5 != 0L) {
#line 432
      reserve_in_place = 1;
    } else {
#line 430
      tmp___6 = ldv__builtin_expect(next_cmd + bytes == max, 1L);
#line 430
      if (tmp___6 != 0L) {
#line 430
        tmp___7 = ldv__builtin_expect(stop > min, 1L);
#line 430
        if (tmp___7 != 0L) {
#line 430
          tmp___8 = 1;
        } else {
#line 430
          tmp___8 = 0;
        }
      } else {
#line 430
        tmp___8 = 0;
      }
#line 430
      if (tmp___8 != 0) {
#line 432
        reserve_in_place = 1;
      } else {
#line 434
        tmp___4 = vmw_fifo_is_full(dev_priv, bytes);
#line 434
        if ((int )tmp___4) {
#line 435
          ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 437
          tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 437
          if (tmp___3 != 0L) {
#line 438
            goto out_err;
          } else {

          }
        } else {
#line 440
          need_bounce = 1;
        }
      }
    }
  } else {
#line 444
    tmp___10 = ldv__builtin_expect(next_cmd + bytes < stop, 1L);
#line 444
    if (tmp___10 != 0L) {
#line 445
      reserve_in_place = 1;
    } else {
#line 447
      ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 449
      tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 449
      if (tmp___9 != 0L) {
#line 450
        goto out_err;
      } else {

      }
    }
  }
#line 454
  if ((int )reserve_in_place) {
#line 455
    if (reserveable != 0U || bytes <= 4U) {
#line 456
      fifo_state->using_bounce_buffer = 0;
#line 458
      if (reserveable != 0U) {
#line 459
        iowrite32(bytes, (void *)fifo_mem + 14U);
      } else {

      }
#line 461
      return ((void *)fifo_mem + (unsigned long )(next_cmd >> 2));
    } else {
#line 463
      need_bounce = 1;
    }
  } else {

  }
#line 467
  if ((int )need_bounce) {
#line 468
    fifo_state->using_bounce_buffer = 1;
#line 469
    if ((unsigned long )bytes < fifo_state->static_buffer_size) {
#line 470
      return ((void *)fifo_state->static_buffer);
    } else {
#line 472
      tmp___11 = vmalloc((unsigned long )bytes);
#line 472
      fifo_state->dynamic_buffer = (__le32 *)tmp___11;
#line 473
      return ((void *)fifo_state->dynamic_buffer);
    }
  } else {

  }
#line 476
  goto ldv_39162;
  out_err: 
#line 478
  fifo_state->reserved_size = 0UL;
#line 479
  ldv_mutex_unlock_308(& fifo_state->fifo_mutex);
#line 480
  return (0);
}
}
#line 483 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                              uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ 
  uint32_t chunk_size ;
  uint32_t rest ;
  uint32_t *buffer ;

  {
#line 488
  chunk_size = max - next_cmd;
#line 490
  buffer = (unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0) ? fifo_state->dynamic_buffer : fifo_state->static_buffer;
#line 493
  if (bytes < chunk_size) {
#line 494
    chunk_size = bytes;
  } else {

  }
#line 496
  iowrite32(bytes, (void *)fifo_mem + 14U);
#line 497
  __asm__  volatile   ("mfence": : : "memory");
#line 498
  memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(next_cmd >> 2), (void const   *)buffer,
              (size_t )chunk_size);
#line 499
  rest = bytes - chunk_size;
#line 500
  if (rest != 0U) {
#line 501
    memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(min >> 2), (void const   *)buffer + (unsigned long )(chunk_size >> 2),
                (size_t )rest);
  } else {

  }
#line 502
  return;
}
}
#line 505 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                               uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ 
  uint32_t *buffer ;
  uint32_t *tmp ;
  long tmp___0 ;

  {
#line 510
  buffer = (unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0) ? fifo_state->dynamic_buffer : fifo_state->static_buffer;
#line 513
  goto ldv_39184;
  ldv_39183: 
#line 514
  tmp = buffer;
#line 514
  buffer = buffer + 1;
#line 514
  iowrite32(*tmp, (void *)fifo_mem + (unsigned long )(next_cmd >> 2));
#line 515
  next_cmd = next_cmd + 4U;
#line 516
  tmp___0 = ldv__builtin_expect(next_cmd == max, 0L);
#line 516
  if (tmp___0 != 0L) {
#line 517
    next_cmd = min;
  } else {

  }
#line 518
  __asm__  volatile   ("mfence": : : "memory");
#line 519
  iowrite32(next_cmd, (void *)fifo_mem + 2U);
#line 520
  __asm__  volatile   ("mfence": : : "memory");
#line 521
  bytes = bytes - 4U;
  ldv_39184: ;
#line 513
  if (bytes != 0U) {
#line 514
    goto ldv_39183;
  } else {

  }

#line 518
  return;
}
}
#line 525 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t next_cmd ;
  unsigned int tmp ;
  uint32_t max ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  bool reserveable ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 527
  fifo_state = & dev_priv->fifo;
#line 528
  fifo_mem = dev_priv->mmio_virt;
#line 529
  tmp = ioread32((void *)fifo_mem + 2U);
#line 529
  next_cmd = tmp;
#line 530
  tmp___0 = ioread32((void *)fifo_mem + 1U);
#line 530
  max = tmp___0;
#line 531
  tmp___1 = ioread32((void *)fifo_mem);
#line 531
  min = tmp___1;
#line 532
  reserveable = (fifo_state->capabilities & 64U) != 0U;
#line 534
  tmp___2 = ldv__builtin_expect((bytes & 3U) != 0U, 0L);
#line 534
  if (tmp___2 != 0L) {
#line 534
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (534), "i" (12UL));
    ldv_39196: ;
#line 534
    goto ldv_39196;
  } else {

  }
#line 535
  tmp___3 = ldv__builtin_expect((unsigned long )bytes > fifo_state->reserved_size, 0L);
#line 535
  if (tmp___3 != 0L) {
#line 535
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (535), "i" (12UL));
    ldv_39197: ;
#line 535
    goto ldv_39197;
  } else {

  }
#line 537
  fifo_state->reserved_size = 0UL;
#line 539
  if ((int )fifo_state->using_bounce_buffer) {
#line 540
    if ((int )reserveable) {
#line 541
      vmw_fifo_res_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    } else {
#line 544
      vmw_fifo_slow_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    }
#line 547
    if ((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0)) {
#line 548
      vfree((void const   *)fifo_state->dynamic_buffer);
#line 549
      fifo_state->dynamic_buffer = 0;
    } else {

    }
  } else {

  }
#line 554
  down_write(& fifo_state->rwsem);
#line 555
  if ((int )fifo_state->using_bounce_buffer || (int )reserveable) {
#line 556
    next_cmd = next_cmd + bytes;
#line 557
    if (next_cmd >= max) {
#line 558
      next_cmd = (min - max) + next_cmd;
    } else {

    }
#line 559
    __asm__  volatile   ("mfence": : : "memory");
#line 560
    iowrite32(next_cmd, (void *)fifo_mem + 2U);
  } else {

  }
#line 563
  if ((int )reserveable) {
#line 564
    iowrite32(0U, (void *)fifo_mem + 14U);
  } else {

  }
#line 565
  __asm__  volatile   ("mfence": : : "memory");
#line 566
  up_write(& fifo_state->rwsem);
#line 567
  vmw_fifo_ping_host(dev_priv, 1U);
#line 568
  ldv_mutex_unlock_309(& fifo_state->fifo_mutex);
#line 569
  return;
}
}
#line 571 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  struct svga_fifo_cmd_fence *cmd_fence ;
  void *fm ;
  int ret ;
  uint32_t bytes ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 573
  fifo_state = & dev_priv->fifo;
#line 576
  ret = 0;
#line 577
  bytes = 8U;
#line 579
  fm = vmw_fifo_reserve(dev_priv, bytes);
#line 580
  tmp___0 = ldv__builtin_expect((unsigned long )fm == (unsigned long )((void *)0), 0L);
#line 580
  if (tmp___0 != 0L) {
#line 581
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 581
    *seqno = (uint32_t )tmp;
#line 582
    ret = -12;
#line 583
    vmw_fallback_wait(dev_priv, 0, 1, *seqno, 0, 750UL);
#line 585
    goto out_err;
  } else {

  }
  ldv_39208: 
#line 589
  tmp___1 = atomic_add_return(1, & dev_priv->marker_seq);
#line 589
  *seqno = (uint32_t )tmp___1;
#line 590
  if (*seqno == 0U) {
#line 591
    goto ldv_39208;
  } else {

  }

#line 592
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 599
    vmw_fifo_commit(dev_priv, 0U);
#line 600
    return (0);
  } else {

  }
#line 603
  *((__le32 *)fm) = 30U;
#line 604
  cmd_fence = (struct svga_fifo_cmd_fence *)((unsigned long )fm + 4UL);
#line 607
  iowrite32(*seqno, (void *)(& cmd_fence->fence));
#line 608
  vmw_fifo_commit(dev_priv, bytes);
#line 609
  vmw_marker_push(& fifo_state->marker_queue, *seqno);
#line 610
  vmw_update_seqno(dev_priv, fifo_state);
  out_err: ;
#line 613
  return (ret);
}
}
#line 633 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) 
{ 
  struct ttm_buffer_object *bo ;
  struct __anonstruct_cmd_279___2 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 642
  bo = dev_priv->dummy_query_bo;
#line 648
  tmp = vmw_fifo_reserve(dev_priv, 24U);
#line 648
  cmd = (struct __anonstruct_281___1 *)tmp;
#line 650
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_279___2 *)0),
                             0L);
#line 650
  if (tmp___0 != 0L) {
#line 651
    drm_err("vmw_fifo_emit_dummy_query", "Out of fifo space for dummy query.\n");
#line 652
    return (-12);
  } else {

  }
#line 655
  cmd->header.id = 1067U;
#line 656
  cmd->header.size = 16U;
#line 657
  cmd->body.cid = cid;
#line 658
  cmd->body.type = SVGA3D_QUERYTYPE_OCCLUSION;
#line 660
  if (bo->mem.mem_type == 2U) {
#line 661
    cmd->body.guestResult.gmrId = 4294967294U;
#line 662
    cmd->body.guestResult.offset = (uint32 )bo->offset;
  } else {
#line 664
    cmd->body.guestResult.gmrId = (uint32 )bo->mem.start;
#line 665
    cmd->body.guestResult.offset = 0U;
  }
#line 668
  vmw_fifo_commit(dev_priv, 24U);
#line 670
  return (0);
}
}
#line 673 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_285(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 678
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 680
  mutex_lock(ldv_func_arg1);
#line 681
  return;
}
}
#line 683 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int ldv_mutex_trylock_286(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 688
  tmp = mutex_trylock(ldv_func_arg1);
#line 688
  ldv_func_res = tmp;
#line 690
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 690
  return (tmp___0);
#line 692
  return (ldv_func_res);
}
}
#line 695 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_287(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 700
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 702
  mutex_unlock(ldv_func_arg1);
#line 703
  return;
}
}
#line 705 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_288(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 710
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 712
  mutex_lock(ldv_func_arg1);
#line 713
  return;
}
}
#line 715 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_289(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 720
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 722
  mutex_unlock(ldv_func_arg1);
#line 723
  return;
}
}
#line 725 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_290(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 730
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 732
  mutex_lock(ldv_func_arg1);
#line 733
  return;
}
}
#line 735 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_291(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 740
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 742
  mutex_unlock(ldv_func_arg1);
#line 743
  return;
}
}
#line 745 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 750
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 752
  mutex_unlock(ldv_func_arg1);
#line 753
  return;
}
}
#line 755 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 760
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 762
  mutex_lock(ldv_func_arg1);
#line 763
  return;
}
}
#line 765 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_294(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 770
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 772
  mutex_unlock(ldv_func_arg1);
#line 773
  return;
}
}
#line 775 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_295(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 780
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 782
  mutex_lock(ldv_func_arg1);
#line 783
  return;
}
}
#line 785 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_296(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 790
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 792
  mutex_unlock(ldv_func_arg1);
#line 793
  return;
}
}
#line 795 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_297(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 800
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 802
  mutex_lock(ldv_func_arg1);
#line 803
  return;
}
}
#line 805 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_298(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 810
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 812
  mutex_unlock(ldv_func_arg1);
#line 813
  return;
}
}
#line 815 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_299(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 820
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 822
  mutex_lock(ldv_func_arg1);
#line 823
  return;
}
}
#line 825 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 830
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 832
  mutex_unlock(ldv_func_arg1);
#line 833
  return;
}
}
#line 835 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 842
  mutex_lock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 850
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 852
  mutex_unlock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 860
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 862
  mutex_lock(ldv_func_arg1);
#line 863
  return;
}
}
#line 865 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 870
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 872
  mutex_unlock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 880
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 882
  mutex_lock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 890
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 892
  mutex_unlock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 900
  ldv_mutex_lock_fifo_mutex(ldv_func_arg1);
#line 902
  mutex_lock(ldv_func_arg1);
#line 903
  return;
}
}
#line 905 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 910
  ldv_mutex_unlock_fifo_mutex(ldv_func_arg1);
#line 912
  mutex_unlock(ldv_func_arg1);
#line 913
  return;
}
}
#line 915 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_309(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 920
  ldv_mutex_unlock_fifo_mutex(ldv_func_arg1);
#line 922
  mutex_unlock(ldv_func_arg1);
#line 923
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_336(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_339(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_346(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_348(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_350(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_352(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_354(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_358(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_340(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_345(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_347(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_349(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_351(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_353(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) ;
#line 80 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 100
extern void up_read(struct rw_semaphore * ) ;
#line 364 "include/linux/sched.h"
extern void schedule(void) ;
#line 75 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fences_update(struct vmw_fence_manager *fman ) ;
#line 563 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) ;
#line 569
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) ;
#line 579
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) ;
#line 580
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) ;
#line 581
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) ;
#line 582
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) ;
#line 593
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) ;
#line 136 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
irqreturn_t vmw_irq_handler(int irq , void *arg ) 
{ 
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  uint32_t masked_status ;
  long tmp___0 ;

  {
#line 138
  dev = (struct drm_device *)arg;
#line 139
  tmp = vmw_priv(dev);
#line 139
  dev_priv = tmp;
#line 142
  spin_lock(& dev_priv->irq_lock);
#line 143
  status = inl((int )(dev_priv->io_start + 8U));
#line 144
  masked_status = dev_priv->irq_mask & status;
#line 145
  spin_unlock(& dev_priv->irq_lock);
#line 147
  tmp___0 = ldv__builtin_expect(status != 0U, 1L);
#line 147
  if (tmp___0 != 0L) {
#line 148
    outl(status, (int )(dev_priv->io_start + 8U));
  } else {

  }
#line 150
  if (masked_status == 0U) {
#line 151
    return (IRQ_NONE);
  } else {

  }
#line 153
  if ((masked_status & 5U) != 0U) {
#line 155
    vmw_fences_update(dev_priv->fman);
#line 156
    __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
  } else {

  }
#line 159
  if ((masked_status & 2U) != 0U) {
#line 160
    __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
  } else {

  }
#line 163
  return (IRQ_HANDLED);
}
}
#line 166 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
static bool vmw_fifo_idle(struct vmw_private *dev_priv , uint32_t seqno ) 
{ 
  uint32_t busy ;

  {
#line 170
  ldv_mutex_lock_347(& dev_priv->hw_mutex);
#line 171
  busy = vmw_read(dev_priv, 22U);
#line 172
  ldv_mutex_unlock_348(& dev_priv->hw_mutex);
#line 174
  return (busy == 0U);
}
}
#line 177 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) 
{ 
  __le32 *fifo_mem ;
  uint32_t seqno ;
  unsigned int tmp ;

  {
#line 180
  fifo_mem = dev_priv->mmio_virt;
#line 181
  tmp = ioread32((void *)fifo_mem + 6U);
#line 181
  seqno = tmp;
#line 183
  if (dev_priv->last_read_seqno != seqno) {
#line 184
    dev_priv->last_read_seqno = seqno;
#line 185
    vmw_marker_pull(& fifo_state->marker_queue, seqno);
#line 186
    vmw_fences_update(dev_priv->fman);
  } else {

  }
#line 188
  return;
}
}
#line 190 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  bool ret ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 196
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 196
  if (tmp != 0L) {
#line 197
    return (1);
  } else {

  }
#line 199
  fifo_state = & dev_priv->fifo;
#line 200
  vmw_update_seqno(dev_priv, fifo_state);
#line 201
  tmp___0 = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 201
  if (tmp___0 != 0L) {
#line 202
    return (1);
  } else {

  }
#line 204
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 204
    tmp___1 = vmw_fifo_idle(dev_priv, seqno);
#line 204
    if ((int )tmp___1) {
#line 206
      return (1);
    } else {

    }
  } else {

  }
#line 213
  tmp___2 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 213
  ret = (uint32_t )tmp___2 - seqno > 16777216U;
#line 216
  return (ret);
}
}
#line 219 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) 
{ 
  struct vmw_fifo_state *fifo_state ;
  uint32_t count ;
  uint32_t signal_seq ;
  int ret ;
  unsigned long end_jiffies ;
  bool (*wait_condition)(struct vmw_private * , uint32_t  ) ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  __le32 *fifo_mem ;

  {
#line 226
  fifo_state = & dev_priv->fifo;
#line 228
  count = 0U;
#line 231
  end_jiffies = (unsigned long )jiffies + timeout;
#line 233
  tmp = get_current();
#line 233
  __wait.flags = 0U;
#line 233
  __wait.private = (void *)tmp;
#line 233
  __wait.func = & autoremove_wake_function;
#line 233
  __wait.task_list.next = & __wait.task_list;
#line 233
  __wait.task_list.prev = & __wait.task_list;
#line 235
  wait_condition = (int )fifo_idle ? & vmw_fifo_idle : & vmw_seqno_passed;
#line 242
  if ((int )fifo_idle) {
#line 243
    down_read(& fifo_state->rwsem);
  } else {

  }
#line 244
  tmp___0 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 244
  signal_seq = (uint32_t )tmp___0;
#line 245
  ret = 0;
  ldv_39104: 
#line 248
  prepare_to_wait(& dev_priv->fence_queue, & __wait, (int )interruptible ? 1 : 2);
#line 251
  tmp___1 = (*wait_condition)(dev_priv, seqno);
#line 251
  if ((int )tmp___1) {
#line 252
    goto ldv_39096;
  } else {

  }
#line 253
  if ((1 != 0 && 1 != 0) && (long )jiffies - (long )end_jiffies >= 0L) {
#line 254
    drm_err("vmw_fallback_wait", "SVGA device lockup.\n");
#line 255
    goto ldv_39096;
  } else {

  }
#line 257
  if ((int )lazy) {
#line 258
    schedule_timeout(1L);
  } else {
#line 259
    count = count + (uint32_t )1;
#line 259
    if ((count & 15U) == 0U) {
#line 265
      tmp___2 = get_current();
#line 265
      tmp___2->state = 0L;
#line 266
      schedule();
#line 267
      tmp___3 = get_current();
#line 267
      tmp___3->state = (int )interruptible ? 1L : 2L;
    } else {

    }
  }
#line 271
  if ((int )interruptible) {
#line 271
    tmp___4 = get_current();
#line 271
    tmp___5 = signal_pending(tmp___4);
#line 271
    if (tmp___5 != 0) {
#line 272
      ret = -512;
#line 273
      goto ldv_39096;
    } else {

    }
  } else {

  }
#line 275
  goto ldv_39104;
  ldv_39096: 
#line 276
  finish_wait(& dev_priv->fence_queue, & __wait);
#line 277
  if (ret == 0 && (int )fifo_idle) {
#line 278
    fifo_mem = dev_priv->mmio_virt;
#line 279
    iowrite32(signal_seq, (void *)fifo_mem + 6U);
  } else {

  }
#line 281
  __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
#line 282
  if ((int )fifo_idle) {
#line 283
    up_read(& fifo_state->rwsem);
  } else {

  }
#line 285
  return (ret);
}
}
#line 288 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 290
  ldv_mutex_lock_349(& dev_priv->hw_mutex);
#line 291
  tmp___0 = dev_priv->fence_queue_waiters;
#line 291
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters + 1;
#line 291
  if (tmp___0 == 0) {
#line 294
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 294
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 295
    outl(1U, (int )(dev_priv->io_start + 8U));
#line 297
    dev_priv->irq_mask = dev_priv->irq_mask | 1U;
#line 298
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 299
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 301
  ldv_mutex_unlock_350(& dev_priv->hw_mutex);
#line 302
  return;
}
}
#line 304 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 306
  ldv_mutex_lock_351(& dev_priv->hw_mutex);
#line 307
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters - 1;
#line 307
  if (dev_priv->fence_queue_waiters == 0) {
#line 310
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 310
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 311
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967294U;
#line 312
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 313
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 315
  ldv_mutex_unlock_352(& dev_priv->hw_mutex);
#line 316
  return;
}
}
#line 319 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 321
  ldv_mutex_lock_353(& dev_priv->hw_mutex);
#line 322
  tmp___0 = dev_priv->goal_queue_waiters;
#line 322
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters + 1;
#line 322
  if (tmp___0 == 0) {
#line 325
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 325
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 326
    outl(4U, (int )(dev_priv->io_start + 8U));
#line 328
    dev_priv->irq_mask = dev_priv->irq_mask | 4U;
#line 329
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 330
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 332
  ldv_mutex_unlock_354(& dev_priv->hw_mutex);
#line 333
  return;
}
}
#line 335 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 337
  ldv_mutex_lock_355(& dev_priv->hw_mutex);
#line 338
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters - 1;
#line 338
  if (dev_priv->goal_queue_waiters == 0) {
#line 341
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 341
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 342
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967291U;
#line 343
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 344
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 346
  ldv_mutex_unlock_356(& dev_priv->hw_mutex);
#line 347
  return;
}
}
#line 349 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) 
{ 
  long ret ;
  struct vmw_fifo_state *fifo ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 354
  fifo = & dev_priv->fifo;
#line 356
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 356
  if (tmp != 0L) {
#line 357
    return (0);
  } else {

  }
#line 359
  tmp___0 = vmw_seqno_passed(dev_priv, seqno);
#line 359
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 359
  if (tmp___1 != 0L) {
#line 360
    return (0);
  } else {

  }
#line 362
  vmw_fifo_ping_host(dev_priv, 1U);
#line 364
  if ((fifo->capabilities & 1U) == 0U) {
#line 365
    tmp___2 = vmw_fallback_wait(dev_priv, (int )lazy, 1, seqno, (int )interruptible,
                                timeout);
#line 365
    return (tmp___2);
  } else {

  }
#line 368
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 369
    tmp___3 = vmw_fallback_wait(dev_priv, (int )lazy, 0, seqno, (int )interruptible,
                                timeout);
#line 369
    return (tmp___3);
  } else {

  }
#line 372
  vmw_seqno_waiter_add(dev_priv);
#line 374
  if ((int )interruptible) {
#line 375
    __ret = (long )timeout;
#line 375
    tmp___8 = vmw_seqno_passed(dev_priv, seqno);
#line 375
    if (tmp___8) {
#line 375
      tmp___9 = 0;
    } else {
#line 375
      tmp___9 = 1;
    }
#line 375
    if (tmp___9) {
#line 375
      tmp___4 = get_current();
#line 375
      __wait.flags = 0U;
#line 375
      __wait.private = (void *)tmp___4;
#line 375
      __wait.func = & autoremove_wake_function;
#line 375
      __wait.task_list.next = & __wait.task_list;
#line 375
      __wait.task_list.prev = & __wait.task_list;
      ldv_39147: 
#line 375
      prepare_to_wait(& dev_priv->fence_queue, & __wait, 1);
#line 375
      tmp___5 = vmw_seqno_passed(dev_priv, seqno);
#line 375
      if ((int )tmp___5) {
#line 375
        goto ldv_39145;
      } else {

      }
#line 375
      tmp___6 = get_current();
#line 375
      tmp___7 = signal_pending(tmp___6);
#line 375
      if (tmp___7 == 0) {
#line 375
        __ret = schedule_timeout(__ret);
#line 375
        if (__ret == 0L) {
#line 375
          goto ldv_39145;
        } else {

        }
#line 375
        goto ldv_39146;
      } else {

      }
#line 375
      __ret = -512L;
#line 375
      goto ldv_39145;
      ldv_39146: ;
#line 375
      goto ldv_39147;
      ldv_39145: 
#line 375
      finish_wait(& dev_priv->fence_queue, & __wait);
    } else {

    }
#line 375
    ret = __ret;
  } else {
#line 380
    __ret___0 = (long )timeout;
#line 380
    tmp___12 = vmw_seqno_passed(dev_priv, seqno);
#line 380
    if (tmp___12) {
#line 380
      tmp___13 = 0;
    } else {
#line 380
      tmp___13 = 1;
    }
#line 380
    if (tmp___13) {
#line 380
      tmp___10 = get_current();
#line 380
      __wait___0.flags = 0U;
#line 380
      __wait___0.private = (void *)tmp___10;
#line 380
      __wait___0.func = & autoremove_wake_function;
#line 380
      __wait___0.task_list.next = & __wait___0.task_list;
#line 380
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_39152: 
#line 380
      prepare_to_wait(& dev_priv->fence_queue, & __wait___0, 2);
#line 380
      tmp___11 = vmw_seqno_passed(dev_priv, seqno);
#line 380
      if ((int )tmp___11) {
#line 380
        goto ldv_39151;
      } else {

      }
#line 380
      __ret___0 = schedule_timeout(__ret___0);
#line 380
      if (__ret___0 == 0L) {
#line 380
        goto ldv_39151;
      } else {

      }
#line 380
      goto ldv_39152;
      ldv_39151: 
#line 380
      finish_wait(& dev_priv->fence_queue, & __wait___0);
    } else {

    }
#line 380
    ret = __ret___0;
  }
#line 385
  vmw_seqno_waiter_remove(dev_priv);
#line 387
  tmp___15 = ldv__builtin_expect(ret == 0L, 0L);
#line 387
  if (tmp___15 != 0L) {
#line 388
    ret = -16L;
  } else {
#line 389
    tmp___14 = ldv__builtin_expect(ret > 0L, 1L);
#line 389
    if (tmp___14 != 0L) {
#line 390
      ret = 0L;
    } else {

    }
  }
#line 392
  return ((int )ret);
}
}
#line 395 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_preinstall(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  struct lock_class_key __key ;

  {
#line 397
  tmp = vmw_priv(dev);
#line 397
  dev_priv = tmp;
#line 400
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 401
    return;
  } else {

  }
#line 403
  spinlock_check(& dev_priv->irq_lock);
#line 403
  __raw_spin_lock_init(& dev_priv->irq_lock.ldv_5988.rlock, "&(&dev_priv->irq_lock)->rlock",
                       & __key);
#line 404
  status = inl((int )(dev_priv->io_start + 8U));
#line 405
  outl(status, (int )(dev_priv->io_start + 8U));
#line 406
  return;
}
}
#line 408 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_irq_postinstall(struct drm_device *dev ) 
{ 


  {
#line 410
  return (0);
}
}
#line 413 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_uninstall(struct drm_device *dev ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;

  {
#line 415
  tmp = vmw_priv(dev);
#line 415
  dev_priv = tmp;
#line 418
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 419
    return;
  } else {

  }
#line 421
  ldv_mutex_lock_357(& dev_priv->hw_mutex);
#line 422
  vmw_write(dev_priv, 33U, 0U);
#line 423
  ldv_mutex_unlock_358(& dev_priv->hw_mutex);
#line 425
  status = inl((int )(dev_priv->io_start + 8U));
#line 426
  outl(status, (int )(dev_priv->io_start + 8U));
#line 427
  return;
}
}
#line 429 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 434
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 436
  mutex_lock(ldv_func_arg1);
#line 437
  return;
}
}
#line 439 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int ldv_mutex_trylock_336(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 444
  tmp = mutex_trylock(ldv_func_arg1);
#line 444
  ldv_func_res = tmp;
#line 446
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 446
  return (tmp___0);
#line 448
  return (ldv_func_res);
}
}
#line 451 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 458
  mutex_unlock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 466
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 468
  mutex_lock(ldv_func_arg1);
#line 469
  return;
}
}
#line 471 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_339(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 476
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 478
  mutex_unlock(ldv_func_arg1);
#line 479
  return;
}
}
#line 481 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_340(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 486
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 488
  mutex_lock(ldv_func_arg1);
#line 489
  return;
}
}
#line 491 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 498
  mutex_unlock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 506
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 508
  mutex_unlock(ldv_func_arg1);
#line 509
  return;
}
}
#line 511 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 516
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 518
  mutex_lock(ldv_func_arg1);
#line 519
  return;
}
}
#line 521 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 526
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_345(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 536
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 538
  mutex_lock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_346(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 546
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 548
  mutex_unlock(ldv_func_arg1);
#line 549
  return;
}
}
#line 551 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_347(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 556
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 558
  mutex_lock(ldv_func_arg1);
#line 559
  return;
}
}
#line 561 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_348(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 566
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 568
  mutex_unlock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_349(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 578
  mutex_lock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_350(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 586
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 588
  mutex_unlock(ldv_func_arg1);
#line 589
  return;
}
}
#line 591 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_351(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 596
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 598
  mutex_lock(ldv_func_arg1);
#line 599
  return;
}
}
#line 601 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_352(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 606
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 608
  mutex_unlock(ldv_func_arg1);
#line 609
  return;
}
}
#line 611 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_353(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 616
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 618
  mutex_lock(ldv_func_arg1);
#line 619
  return;
}
}
#line 621 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_354(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 626
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 628
  mutex_unlock(ldv_func_arg1);
#line 629
  return;
}
}
#line 631 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 638
  mutex_lock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 646
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 648
  mutex_unlock(ldv_func_arg1);
#line 649
  return;
}
}
#line 651 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 656
  ldv_mutex_lock_hw_mutex(ldv_func_arg1);
#line 658
  mutex_lock(ldv_func_arg1);
#line 659
  return;
}
}
#line 661 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_358(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 666
  ldv_mutex_unlock_hw_mutex(ldv_func_arg1);
#line 668
  mutex_unlock(ldv_func_arg1);
#line 669
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_384(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_385(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_387(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_389(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_386(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_388(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) ;
#line 831 "include/drm/drm_crtc.h"
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
#line 836
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
#line 845
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
#line 932
extern void drm_connector_attach_property(struct drm_connector * , struct drm_property * ,
                                          uint64_t  ) ;
#line 958
extern int drm_mode_create_dirty_info_property(struct drm_device * ) ;
#line 961
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
#line 965
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
#line 1436 "include/drm/drmP.h"
extern int drm_vblank_init(struct drm_device * , int  ) ;
#line 1447
extern void drm_vblank_cleanup(struct drm_device * ) ;
#line 160 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu ) 
{ 


  {
#line 162
  list_del_init(& ldu->active);
#line 163
  vmw_display_unit_cleanup(& ldu->base);
#line 164
  kfree((void const   *)ldu);
#line 165
  return;
}
}
#line 172 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc  const  *__mptr ;

  {
#line 174
  __mptr = (struct drm_crtc  const  *)crtc;
#line 174
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr);
#line 176
  return;
}
}
#line 177 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_commit_list(struct vmw_private *dev_priv ) 
{ 
  struct vmw_legacy_display *lds ;
  struct vmw_legacy_display_unit *entry ;
  struct vmw_display_unit *du ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int i ;
  int ret ;
  int w ;
  int h ;
  struct list_head  const  *__mptr ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  long tmp___1 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;

  {
#line 179
  lds = dev_priv->ldu_priv;
#line 181
  du = 0;
#line 182
  fb = 0;
#line 183
  crtc = 0;
#line 184
  i = 0;
#line 189
  if ((dev_priv->capabilities & 524288U) == 0U) {
#line 190
    w = 0;
#line 190
    h = 0;
#line 191
    __mptr = (struct list_head  const  *)lds->active.next;
#line 191
    entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c0UL;
#line 191
    goto ldv_39273;
    ldv_39272: 
#line 192
    crtc = & entry->base.crtc;
#line 193
    _max1 = w;
#line 193
    _max2 = crtc->x + crtc->mode.hdisplay;
#line 193
    w = _max1 > _max2 ? _max1 : _max2;
#line 194
    _max1___0 = h;
#line 194
    _max2___0 = crtc->y + crtc->mode.vdisplay;
#line 194
    h = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 195
    i = i + 1;
#line 191
    __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 191
    entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c0UL;
    ldv_39273: ;
#line 191
    if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 192
      goto ldv_39272;
    } else {

    }

#line 198
    if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 199
      return (0);
    } else {

    }
#line 200
    fb = entry->base.crtc.fb;
#line 202
    tmp = vmw_kms_write_svga(dev_priv, (unsigned int )w, (unsigned int )h, fb->pitches[0],
                             (unsigned int )fb->bits_per_pixel, fb->depth);
#line 202
    return (tmp);
  } else {

  }
#line 206
  tmp___0 = list_empty((struct list_head  const  *)(& lds->active));
#line 206
  if (tmp___0 == 0) {
#line 207
    __mptr___1 = (struct list_head  const  *)lds->active.next;
#line 207
    entry = (struct vmw_legacy_display_unit *)__mptr___1 + 0xfffffffffffff4c0UL;
#line 208
    fb = entry->base.crtc.fb;
#line 210
    vmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitches[0], (unsigned int )fb->bits_per_pixel,
                       fb->depth);
  } else {

  }
#line 215
  vmw_write(dev_priv, 34U, lds->num_active != 0U ? lds->num_active : 1U);
#line 218
  i = 0;
#line 219
  __mptr___2 = (struct list_head  const  *)lds->active.next;
#line 219
  entry = (struct vmw_legacy_display_unit *)__mptr___2 + 0xfffffffffffff4c0UL;
#line 219
  goto ldv_39282;
  ldv_39281: 
#line 220
  crtc = & entry->base.crtc;
#line 222
  vmw_write(dev_priv, 35U, (uint32_t )i);
#line 223
  vmw_write(dev_priv, 36U, i == 0);
#line 224
  vmw_write(dev_priv, 37U, (uint32_t )crtc->x);
#line 225
  vmw_write(dev_priv, 38U, (uint32_t )crtc->y);
#line 226
  vmw_write(dev_priv, 39U, (uint32_t )crtc->mode.hdisplay);
#line 227
  vmw_write(dev_priv, 40U, (uint32_t )crtc->mode.vdisplay);
#line 228
  vmw_write(dev_priv, 35U, 4294967295U);
#line 230
  i = i + 1;
#line 219
  __mptr___3 = (struct list_head  const  *)entry->active.next;
#line 219
  entry = (struct vmw_legacy_display_unit *)__mptr___3 + 0xfffffffffffff4c0UL;
  ldv_39282: ;
#line 219
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 220
    goto ldv_39281;
  } else {

  }
#line 233
  tmp___1 = ldv__builtin_expect((unsigned int )i != lds->num_active, 0L);
#line 233
  if (tmp___1 != 0L) {
#line 233
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (233), "i" (12UL));
    ldv_39284: ;
#line 233
    goto ldv_39284;
  } else {

  }
#line 235
  lds->last_num_active = lds->num_active;
#line 239
  __mptr___4 = (struct list_head  const  *)lds->active.next;
#line 239
  entry = (struct vmw_legacy_display_unit *)__mptr___4 + 0xfffffffffffff4c0UL;
#line 239
  goto ldv_39293;
  ldv_39292: 
#line 240
  du = & entry->base;
#line 242
  if ((unsigned long )du->cursor_dmabuf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 243
    goto ldv_39289;
  } else {

  }
#line 245
  ret = vmw_cursor_update_dmabuf(dev_priv, du->cursor_dmabuf, 64U, 64U, (u32 )du->hotspot_x,
                                 (u32 )du->hotspot_y);
#line 250
  if (ret == 0) {
#line 251
    goto ldv_39290;
  } else {

  }
#line 253
  drm_err("vmw_ldu_commit_list", "Could not update cursor image\n");
  ldv_39289: 
#line 239
  __mptr___5 = (struct list_head  const  *)entry->active.next;
#line 239
  entry = (struct vmw_legacy_display_unit *)__mptr___5 + 0xfffffffffffff4c0UL;
  ldv_39293: ;
#line 239
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 240
    goto ldv_39292;
  } else {

  }
  ldv_39290: ;
#line 256
  return (0);
}
}
#line 259 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_del_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ) 
{ 
  struct vmw_legacy_display *ld ;
  int tmp ;
  long tmp___0 ;

  {
#line 262
  ld = vmw_priv___0->ldu_priv;
#line 263
  tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 263
  if (tmp != 0) {
#line 264
    return (0);
  } else {

  }
#line 267
  list_del_init(& ldu->active);
#line 268
  ld->num_active = ld->num_active - 1U;
#line 268
  if (ld->num_active == 0U) {
#line 269
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb == (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 269
    if (tmp___0 != 0L) {
#line 269
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (269), "i" (12UL));
      ldv_39299: ;
#line 269
      goto ldv_39299;
    } else {

    }
#line 270
    if ((unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 271
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 272
    ld->fb = 0;
  } else {

  }
#line 275
  return (0);
}
}
#line 278 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_add_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ,
                              struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_legacy_display *ld ;
  struct vmw_legacy_display_unit *entry ;
  struct list_head *at ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 282
  ld = vmw_priv___0->ldu_priv;
#line 286
  tmp = ldv__builtin_expect(ld->num_active == 0U, 0L);
#line 286
  if (tmp != 0L) {
#line 286
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 286
    if (tmp___0 != 0L) {
#line 286
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (286), "i" (12UL));
      ldv_39308: ;
#line 286
      goto ldv_39308;
    } else {

    }
  } else {

  }
#line 287
  if ((unsigned long )ld->fb != (unsigned long )vfb) {
#line 288
    if ((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 289
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 290
    if ((unsigned long )vfb->pin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 291
      (*(vfb->pin))(vfb);
    } else {

    }
#line 292
    ld->fb = vfb;
  } else {

  }
#line 295
  tmp___1 = list_empty((struct list_head  const  *)(& ldu->active));
#line 295
  if (tmp___1 == 0) {
#line 296
    return (0);
  } else {

  }
#line 298
  at = & ld->active;
#line 299
  __mptr = (struct list_head  const  *)ld->active.next;
#line 299
  entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c0UL;
#line 299
  goto ldv_39315;
  ldv_39314: ;
#line 300
  if (entry->base.unit > ldu->base.unit) {
#line 301
    goto ldv_39313;
  } else {

  }
#line 303
  at = & entry->active;
#line 299
  __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 299
  entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c0UL;
  ldv_39315: ;
#line 299
  if ((unsigned long )(& entry->active) != (unsigned long )(& ld->active)) {
#line 300
    goto ldv_39314;
  } else {

  }
  ldv_39313: 
#line 306
  list_add(& ldu->active, at);
#line 308
  ld->num_active = ld->num_active + 1U;
#line 310
  return (0);
}
}
#line 313 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_legacy_display_unit *ldu ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 324
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 325
    return (-22);
  } else {

  }
#line 327
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 328
    return (-22);
  } else {

  }
#line 331
  crtc = set->crtc;
#line 332
  __mptr = (struct drm_crtc  const  *)crtc;
#line 332
  ldu = (struct vmw_legacy_display_unit *)__mptr;
#line 333
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 333
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 333
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 333
    vfb = 0;
  }
#line 334
  dev_priv = vmw_priv(crtc->dev);
#line 336
  if (set->num_connectors > 1UL) {
#line 337
    drm_err("vmw_ldu_crtc_set_config", "to many connectors\n");
#line 338
    return (-22);
  } else {

  }
#line 341
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& ldu->base.connector)) {
#line 343
    drm_err("vmw_ldu_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & ldu->base.connector);
#line 345
    return (-22);
  } else {

  }
#line 349
  if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) {
#line 349
    if ((dev_priv->ldu_priv)->num_active != 1U) {
#line 349
      goto _L;
    } else {
#line 349
      tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 349
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 349
        if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )vfb) {
#line 353
          drm_err("vmw_ldu_crtc_set_config", "Multiple framebuffers not supported\n");
#line 354
          return (-22);
        } else {

        }
      } else {

      }
    }
  } else {

  }
#line 358
  connector = & ldu->base.connector;
#line 359
  encoder = & ldu->base.encoder;
#line 362
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 364
    connector->encoder = 0;
#line 365
    encoder->crtc = 0;
#line 366
    crtc->fb = 0;
#line 368
    vmw_ldu_del_active(dev_priv, ldu);
#line 370
    tmp___0 = vmw_ldu_commit_list(dev_priv);
#line 370
    return (tmp___0);
  } else {

  }
#line 375
  mode = set->mode;
#line 376
  fb = set->fb;
#line 378
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 380
    drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
#line 381
    return (-22);
  } else {

  }
#line 384
  vmw_fb_off(dev_priv);
#line 386
  crtc->fb = fb;
#line 387
  encoder->crtc = crtc;
#line 388
  connector->encoder = encoder;
#line 389
  crtc->x = (int )set->x;
#line 390
  crtc->y = (int )set->y;
#line 391
  crtc->mode = *mode;
#line 393
  vmw_ldu_add_active(dev_priv, ldu, vfb);
#line 395
  tmp___1 = vmw_ldu_commit_list(dev_priv);
#line 395
  return (tmp___1);
}
}
#line 398 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_crtc_funcs vmw_legacy_crtc_funcs  = 
#line 398
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_ldu_crtc_destroy, & vmw_ldu_crtc_set_config, 0,
    0};
#line 413 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 415
  __mptr = (struct drm_encoder  const  *)encoder;
#line 415
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffca0UL);
#line 417
  return;
}
}
#line 418 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_encoder_funcs vmw_legacy_encoder_funcs  =    {0, & vmw_ldu_encoder_destroy};
#line 426 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_connector_destroy(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 428
  __mptr = (struct drm_connector  const  *)connector;
#line 428
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffc50UL);
#line 430
  return;
}
}
#line 431 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs  = 
#line 431
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_ldu_connector_destroy, 0};
#line 441 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ 
  struct vmw_legacy_display_unit *ldu ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 444
  dev = dev_priv->dev;
#line 449
  tmp = kzalloc(2896UL, 208U);
#line 449
  ldu = (struct vmw_legacy_display_unit *)tmp;
#line 450
  if ((unsigned long )ldu == (unsigned long )((struct vmw_legacy_display_unit *)0)) {
#line 451
    return (-12);
  } else {

  }
#line 453
  ldu->base.unit = unit;
#line 454
  crtc = & ldu->base.crtc;
#line 455
  encoder = & ldu->base.encoder;
#line 456
  connector = & ldu->base.connector;
#line 458
  INIT_LIST_HEAD(& ldu->active);
#line 460
  ldu->base.pref_active = unit == 0U;
#line 461
  ldu->base.pref_width = dev_priv->initial_width;
#line 462
  ldu->base.pref_height = dev_priv->initial_height;
#line 463
  ldu->base.pref_mode = 0;
#line 464
  ldu->base.is_implicit = 1;
#line 466
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs),
                     15);
#line 468
  connector->status = vmw_du_connector_detect(connector, 1);
#line 470
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_legacy_encoder_funcs),
                   5);
#line 472
  drm_mode_connector_attach_encoder(connector, encoder);
#line 473
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 474
  encoder->possible_clones = 0U;
#line 476
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_legacy_crtc_funcs));
#line 478
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 480
  drm_connector_attach_property(connector, dev->mode_config.dirty_info_property, 1ULL);
#line 484
  return (0);
}
}
#line 487 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;

  {
#line 489
  dev = dev_priv->dev;
#line 492
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 493
    printk("<6>[drm] ldu system already on\n");
#line 494
    return (-22);
  } else {

  }
#line 497
  tmp = kmalloc(32UL, 208U);
#line 497
  dev_priv->ldu_priv = (struct vmw_legacy_display *)tmp;
#line 498
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 499
    return (-12);
  } else {

  }
#line 501
  INIT_LIST_HEAD(& (dev_priv->ldu_priv)->active);
#line 502
  (dev_priv->ldu_priv)->num_active = 0U;
#line 503
  (dev_priv->ldu_priv)->last_num_active = 0U;
#line 504
  (dev_priv->ldu_priv)->fb = 0;
#line 507
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 508
    ret = drm_vblank_init(dev, 8);
  } else {
#line 510
    ret = drm_vblank_init(dev, 1);
  }
#line 511
  if (ret != 0) {
#line 512
    goto err_free;
  } else {

  }
#line 514
  ret = drm_mode_create_dirty_info_property(dev);
#line 515
  if (ret != 0) {
#line 516
    goto err_vblank_cleanup;
  } else {

  }
#line 518
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 519
    i = 0;
#line 519
    goto ldv_39363;
    ldv_39362: 
#line 520
    vmw_ldu_init(dev_priv, (unsigned int )i);
#line 519
    i = i + 1;
    ldv_39363: ;
#line 519
    if (i <= 7) {
#line 520
      goto ldv_39362;
    } else {

    }

  } else {
#line 522
    vmw_ldu_init(dev_priv, 0U);
  }
#line 524
  return (0);
  err_vblank_cleanup: 
#line 527
  drm_vblank_cleanup(dev);
  err_free: 
#line 529
  kfree((void const   *)dev_priv->ldu_priv);
#line 530
  dev_priv->ldu_priv = 0;
#line 531
  return (ret);
}
}
#line 534 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int tmp ;
  long tmp___0 ;

  {
#line 536
  dev = dev_priv->dev;
#line 538
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 539
    return (-38);
  } else {

  }
#line 541
  drm_vblank_cleanup(dev);
#line 543
  tmp = list_empty((struct list_head  const  *)(& (dev_priv->ldu_priv)->active));
#line 543
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 543
  if (tmp___0 != 0L) {
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (543), "i" (12UL));
    ldv_39369: ;
#line 543
    goto ldv_39369;
  } else {

  }
#line 545
  kfree((void const   *)dev_priv->ldu_priv);
#line 547
  return (0);
}
}
#line 587 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_main10_sequence_infinite_withcheck_stateful(void) 
{ 
  struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp ;
  int tmp___0 ;

  {
#line 649
  LDV_IN_INTERRUPT = 1;
#line 658
  ldv_initialize();
#line 666
  goto ldv_39397;
  ldv_39396: 
#line 669
  tmp = __VERIFIER_nondet_int();
#line 669
  switch (tmp) {
  case 0: 
#line 686
  ldv_handler_precall();
#line 687
  vmw_ldu_crtc_destroy(var_group1);
#line 694
  goto ldv_39391;
  case 1: 
#line 710
  ldv_handler_precall();
#line 711
  vmw_ldu_crtc_set_config(var_group2);
#line 718
  goto ldv_39391;
  case 2: 
#line 734
  ldv_handler_precall();
#line 735
  vmw_ldu_encoder_destroy(var_group3);
#line 742
  goto ldv_39391;
  case 3: 
#line 758
  ldv_handler_precall();
#line 759
  vmw_ldu_connector_destroy(var_group4);
#line 766
  goto ldv_39391;
  default: ;
#line 767
  goto ldv_39391;
  }
  ldv_39391: ;
  ldv_39397: 
#line 666
  tmp___0 = __VERIFIER_nondet_int();
#line 666
  if (tmp___0 != 0) {
#line 667
    goto ldv_39396;
  } else {

  }


#line 776
  ldv_check_final_state();
#line 779
  return;
}
}
#line 783 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 788
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 790
  mutex_lock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldv_mutex_trylock_384(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 798
  tmp = mutex_trylock(ldv_func_arg1);
#line 798
  ldv_func_res = tmp;
#line 800
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 800
  return (tmp___0);
#line 802
  return (ldv_func_res);
}
}
#line 805 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_385(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 810
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 812
  mutex_unlock(ldv_func_arg1);
#line 813
  return;
}
}
#line 815 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_386(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 820
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 822
  mutex_lock(ldv_func_arg1);
#line 823
  return;
}
}
#line 825 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_387(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 830
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 832
  mutex_unlock(ldv_func_arg1);
#line 833
  return;
}
}
#line 835 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_388(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 840
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 842
  mutex_lock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_389(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 850
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 852
  mutex_unlock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 860
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 862
  mutex_unlock(ldv_func_arg1);
#line 863
  return;
}
}
#line 865 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 870
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 872
  mutex_lock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 880
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 882
  mutex_unlock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 890
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 892
  mutex_lock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 900
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 902
  mutex_unlock(ldv_func_arg1);
#line 903
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_408(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_411(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_413(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_414(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_416(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_418(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_410(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_412(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_415(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_417(struct mutex *ldv_func_arg1 ) ;
#line 50 "include/drm/drm_global.h"
extern int drm_global_item_ref(struct drm_global_reference * ) ;
#line 51
extern void drm_global_item_unref(struct drm_global_reference * ) ;
#line 709 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_mmap(struct file * , struct vm_area_struct * , struct ttm_bo_device * ) ;
#line 148 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_init(struct ttm_mem_global * ) ;
#line 149
extern void ttm_mem_global_release(struct ttm_mem_global * ) ;
#line 749 "include/drm/ttm/ttm_bo_driver.h"
extern void ttm_bo_global_release(struct drm_global_reference * ) ;
#line 750
extern int ttm_bo_global_init(struct drm_global_reference * ) ;
#line 134 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) 
{ 
  struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  long tmp ;
  int tmp___0 ;

  {
#line 139
  tmp = ldv__builtin_expect(vma->vm_pgoff <= 1048575UL, 0L);
#line 139
  if (tmp != 0L) {
#line 140
    drm_err("vmw_mmap", "Illegal attempt to mmap old fifo space.\n");
#line 141
    return (-22);
  } else {

  }
#line 144
  file_priv = (struct drm_file *)filp->private_data;
#line 145
  dev_priv = vmw_priv((file_priv->minor)->dev);
#line 146
  tmp___0 = ttm_bo_mmap(filp, vma, & dev_priv->bdev);
#line 146
  return (tmp___0);
}
}
#line 149 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static int vmw_ttm_mem_global_init(struct drm_global_reference *ref ) 
{ 
  int tmp ;

  {
#line 151
  printk("<6>[drm] global init.\n");
#line 152
  tmp = ttm_mem_global_init((struct ttm_mem_global *)ref->object);
#line 152
  return (tmp);
}
}
#line 155 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static void vmw_ttm_mem_global_release(struct drm_global_reference *ref ) 
{ 


  {
#line 157
  ttm_mem_global_release((struct ttm_mem_global *)ref->object);
#line 158
  return;
}
}
#line 160 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_ttm_global_init(struct vmw_private *dev_priv ) 
{ 
  struct drm_global_reference *global_ref ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 165
  global_ref = & dev_priv->mem_global_ref;
#line 166
  global_ref->global_type = DRM_GLOBAL_TTM_MEM;
#line 167
  global_ref->size = 360UL;
#line 168
  global_ref->init = & vmw_ttm_mem_global_init;
#line 169
  global_ref->release = & vmw_ttm_mem_global_release;
#line 171
  ret = drm_global_item_ref(global_ref);
#line 172
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 172
  if (tmp != 0L) {
#line 173
    drm_err("vmw_ttm_global_init", "Failed setting up TTM memory accounting.\n");
#line 174
    return (ret);
  } else {

  }
#line 177
  dev_priv->bo_global_ref.mem_glob = (struct ttm_mem_global *)dev_priv->mem_global_ref.object;
#line 179
  global_ref = & dev_priv->bo_global_ref.ref;
#line 180
  global_ref->global_type = DRM_GLOBAL_TTM_BO;
#line 181
  global_ref->size = 368UL;
#line 182
  global_ref->init = & ttm_bo_global_init;
#line 183
  global_ref->release = & ttm_bo_global_release;
#line 184
  ret = drm_global_item_ref(global_ref);
#line 186
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 186
  if (tmp___0 != 0L) {
#line 187
    drm_err("vmw_ttm_global_init", "Failed setting up TTM buffer objects.\n");
#line 188
    goto out_no_bo;
  } else {

  }
#line 191
  return (0);
  out_no_bo: 
#line 193
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 194
  return (ret);
}
}
#line 197 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void vmw_ttm_global_release(struct vmw_private *dev_priv ) 
{ 


  {
#line 199
  drm_global_item_unref(& dev_priv->bo_global_ref.ref);
#line 200
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 201
  return;
}
}
#line 203 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_407(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 208
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 210
  mutex_lock(ldv_func_arg1);
#line 211
  return;
}
}
#line 213 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int ldv_mutex_trylock_408(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 218
  tmp = mutex_trylock(ldv_func_arg1);
#line 218
  ldv_func_res = tmp;
#line 220
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 220
  return (tmp___0);
#line 222
  return (ldv_func_res);
}
}
#line 225 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 230
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 232
  mutex_unlock(ldv_func_arg1);
#line 233
  return;
}
}
#line 235 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_410(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 240
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 242
  mutex_lock(ldv_func_arg1);
#line 243
  return;
}
}
#line 245 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_411(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 250
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 252
  mutex_unlock(ldv_func_arg1);
#line 253
  return;
}
}
#line 255 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_412(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 260
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 262
  mutex_lock(ldv_func_arg1);
#line 263
  return;
}
}
#line 265 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_413(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 270
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 272
  mutex_unlock(ldv_func_arg1);
#line 273
  return;
}
}
#line 275 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_414(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 280
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 282
  mutex_unlock(ldv_func_arg1);
#line 283
  return;
}
}
#line 285 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_415(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 290
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 292
  mutex_lock(ldv_func_arg1);
#line 293
  return;
}
}
#line 295 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_416(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 300
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 302
  mutex_unlock(ldv_func_arg1);
#line 303
  return;
}
}
#line 305 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_417(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 310
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 312
  mutex_lock(ldv_func_arg1);
#line 313
  return;
}
}
#line 315 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_418(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 320
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 322
  mutex_unlock(ldv_func_arg1);
#line 323
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_432(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_435(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_440(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_442(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_444(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_448(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_452(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_431(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_434(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_439(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_441(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_443(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_447(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_449(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) ;
#line 452 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) ;
#line 455
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) ;
#line 176 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_escape(struct vmw_escape_header *header , uint32_t size ) 
{ 


  {
#line 179
  header->cmd = 33U;
#line 180
  header->body.nsid = 0U;
#line 181
  header->body.size = size;
#line 182
  return;
}
}
#line 184 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id ) 
{ 


  {
#line 187
  fill_escape(& cmd->escape, 8U);
#line 188
  cmd->flush.cmdType = 131074U;
#line 189
  cmd->flush.streamId = stream_id;
#line 190
  return;
}
}
#line 198 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_put(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ 
  struct vmw_escape_video_flush *flush ;
  size_t fifo_size ;
  bool have_so ;
  int i ;
  int num_items ;
  SVGAGuestPtr ptr ;
  struct __anonstruct_cmds_291 *cmds ;
  struct __anonstruct_items_294 *items ;
  void *tmp ;

  {
#line 205
  have_so = (unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0);
#line 222
  if ((int )have_so) {
#line 223
    num_items = 21;
  } else {
#line 225
    num_items = 19;
  }
#line 227
  fifo_size = ((unsigned long )num_items + 5UL) * 8UL;
#line 229
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 229
  cmds = (struct __anonstruct_297___0 *)tmp;
#line 231
  if ((unsigned long )cmds == (unsigned long )((struct __anonstruct_cmds_291 *)0)) {
#line 232
    return (-12);
  } else {

  }
#line 234
  items = (struct __anonstruct_300 *)cmds + 1U;
#line 235
  flush = (struct vmw_escape_video_flush *)items + (unsigned long )num_items;
#line 238
  fill_escape(& cmds->escape, (uint32_t )((unsigned long )(num_items + 1)) * 8U);
#line 240
  cmds->header.cmdType = 131073U;
#line 241
  cmds->header.streamId = arg->stream_id;
#line 244
  i = 0;
#line 244
  goto ldv_39178;
  ldv_39177: 
#line 245
  (items + (unsigned long )i)->registerId = (uint32_t )i;
#line 244
  i = i + 1;
  ldv_39178: ;
#line 244
  if (i < num_items) {
#line 245
    goto ldv_39177;
  } else {

  }
#line 247
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& buf->base), & ptr);
#line 248
  ptr.offset = ptr.offset + arg->offset;
#line 250
  items->value = 1U;
#line 251
  (items + 1UL)->value = arg->flags;
#line 252
  (items + 2UL)->value = ptr.offset;
#line 253
  (items + 3UL)->value = (uint32_t )arg->format;
#line 254
  (items + 4UL)->value = arg->color_key;
#line 255
  (items + 5UL)->value = arg->size;
#line 256
  (items + 6UL)->value = arg->width;
#line 257
  (items + 7UL)->value = arg->height;
#line 258
  (items + 8UL)->value = (uint32_t )arg->src.x;
#line 259
  (items + 9UL)->value = (uint32_t )arg->src.y;
#line 260
  (items + 10UL)->value = arg->src.w;
#line 261
  (items + 11UL)->value = arg->src.h;
#line 262
  (items + 12UL)->value = (uint32_t )arg->dst.x;
#line 263
  (items + 13UL)->value = (uint32_t )arg->dst.y;
#line 264
  (items + 14UL)->value = arg->dst.w;
#line 265
  (items + 15UL)->value = arg->dst.h;
#line 266
  (items + 16UL)->value = arg->pitch[0];
#line 267
  (items + 17UL)->value = arg->pitch[1];
#line 268
  (items + 18UL)->value = arg->pitch[2];
#line 269
  if ((int )have_so) {
#line 270
    (items + 19UL)->value = ptr.gmrId;
#line 271
    (items + 20UL)->value = 4294967295U;
  } else {

  }
#line 274
  fill_flush(flush, arg->stream_id);
#line 276
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 278
  return (0);
}
}
#line 287 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_stop(struct vmw_private *dev_priv , uint32_t stream_id ,
                                 bool interruptible ) 
{ 
  struct __anonstruct_cmds_302 *cmds ;
  int ret ;
  void *tmp ;
  long tmp___0 ;

  {
  ldv_39193: 
#line 299
  tmp = vmw_fifo_reserve(dev_priv, 48U);
#line 299
  cmds = (struct __anonstruct_304 *)tmp;
#line 300
  if ((unsigned long )cmds != (unsigned long )((struct __anonstruct_cmds_302 *)0)) {
#line 301
    goto ldv_39191;
  } else {

  }
#line 303
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, (int )interruptible, 750UL);
#line 305
  if ((int )interruptible && ret == -512) {
#line 306
    return (ret);
  } else {
#line 308
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 308
    if (tmp___0 != 0L) {
#line 308
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (308), "i" (12UL));
      ldv_39192: ;
#line 308
      goto ldv_39192;
    } else {

    }
  }
#line 309
  goto ldv_39193;
  ldv_39191: 
#line 311
  fill_escape(& cmds->escape, 16U);
#line 312
  cmds->body.header.cmdType = 131073U;
#line 313
  cmds->body.header.streamId = stream_id;
#line 314
  cmds->body.items[0].registerId = 0U;
#line 315
  cmds->body.items[0].value = 0U;
#line 316
  fill_flush(& cmds->flush, stream_id);
#line 318
  vmw_fifo_commit(dev_priv, 48U);
#line 320
  return (0);
}
}
#line 329 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_move_buffer(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                   bool pin , bool inter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 333
  if (! pin) {
#line 334
    tmp = vmw_dmabuf_unpin(dev_priv, buf, (int )inter);
#line 334
    return (tmp);
  } else {

  }
#line 336
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 337
    tmp___0 = vmw_dmabuf_to_vram(dev_priv, buf, 1, (int )inter);
#line 337
    return (tmp___0);
  } else {

  }
#line 339
  tmp___1 = vmw_dmabuf_to_vram_or_gmr(dev_priv, buf, 1, (int )inter);
#line 339
  return (tmp___1);
}
}
#line 354 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_stop(struct vmw_private *dev_priv , uint32_t stream_id , bool pause ,
                            bool interruptible ) 
{ 
  struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp ;

  {
#line 358
  overlay = dev_priv->overlay_priv;
#line 359
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )stream_id;
#line 363
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 364
    return (0);
  } else {

  }
#line 367
  if (! stream->paused) {
#line 368
    ret = vmw_overlay_send_stop(dev_priv, stream_id, (int )interruptible);
#line 370
    if (ret != 0) {
#line 371
      return (ret);
    } else {

    }
#line 374
    ret = vmw_overlay_move_buffer(dev_priv, stream->buf, 0, (int )interruptible);
#line 376
    if ((int )interruptible && ret == -512) {
#line 377
      return (ret);
    } else {
#line 379
      tmp = ldv__builtin_expect(ret != 0, 0L);
#line 379
      if (tmp != 0L) {
#line 379
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (379), "i" (12UL));
        ldv_39209: ;
#line 379
        goto ldv_39209;
      } else {

      }
    }
  } else {

  }
#line 382
  if (! pause) {
#line 383
    vmw_dmabuf_unreference(& stream->buf);
#line 384
    stream->paused = 0;
  } else {
#line 386
    stream->paused = 1;
  }
#line 389
  return (0);
}
}
#line 401 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_update_stream(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                     struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ 
  struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 406
  overlay = dev_priv->overlay_priv;
#line 407
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )arg->stream_id;
#line 408
  ret = 0;
#line 410
  if ((unsigned long )buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 411
    return (-22);
  } else {

  }
#line 413
  drm_ut_debug_printk(1U, "drm", "vmw_overlay_update_stream", "   %s: old %p, new %p, %spaused\n",
                      "vmw_overlay_update_stream", stream->buf, buf, (int )stream->paused ? (char *)"" : (char *)"not ");
#line 416
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 417
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, (int )interruptible);
#line 419
    if (ret != 0) {
#line 420
      return (ret);
    } else {

    }
  } else
#line 421
  if (! stream->paused) {
#line 425
    ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 426
    if (ret == 0) {
#line 427
      stream->saved = *arg;
    } else {
#line 429
      tmp = ldv__builtin_expect((long )(! interruptible), 0L);
#line 429
      if (tmp != 0L) {
#line 429
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (429), "i" (12UL));
        ldv_39220: ;
#line 429
        goto ldv_39220;
      } else {

      }
    }
#line 431
    return (ret);
  } else {

  }
#line 437
  ret = vmw_overlay_move_buffer(dev_priv, buf, 1, (int )interruptible);
#line 438
  if (ret != 0) {
#line 439
    return (ret);
  } else {

  }
#line 441
  ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 442
  if (ret != 0) {
#line 446
    tmp___0 = vmw_overlay_move_buffer(dev_priv, buf, 0, 0);
#line 446
    tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 446
    if (tmp___1 != 0L) {
#line 446
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (447), "i" (12UL));
      ldv_39221: ;
#line 446
      goto ldv_39221;
    } else {

    }
#line 448
    return (ret);
  } else {

  }
#line 451
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 452
    stream->buf = vmw_dmabuf_reference(buf);
  } else {

  }
#line 453
  stream->saved = *arg;
#line 455
  stream->paused = 0;
#line 457
  return (0);
}
}
#line 467 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 469
  overlay = dev_priv->overlay_priv;
#line 472
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 473
    return (0);
  } else {

  }
#line 475
  ldv_mutex_lock_443(& overlay->mutex);
#line 477
  i = 0;
#line 477
  goto ldv_39233;
  ldv_39232: 
#line 478
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 479
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 480
    goto ldv_39229;
  } else {

  }
#line 482
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
#line 483
  __ret_warn_on = ret != 0;
#line 483
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 483
  if (tmp != 0L) {
#line 483
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       483);
  } else {

  }
#line 483
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ldv_39229: 
#line 477
  i = i + 1;
  ldv_39233: ;
#line 477
  if (i <= 0) {
#line 478
    goto ldv_39232;
  } else {

  }
#line 486
  ldv_mutex_unlock_444(& overlay->mutex);
#line 488
  return (0);
}
}
#line 498 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;

  {
#line 500
  overlay = dev_priv->overlay_priv;
#line 503
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 504
    return (0);
  } else {

  }
#line 506
  ldv_mutex_lock_445(& overlay->mutex);
#line 508
  i = 0;
#line 508
  goto ldv_39245;
  ldv_39244: 
#line 509
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 510
  if (! stream->paused) {
#line 511
    goto ldv_39242;
  } else {

  }
#line 513
  ret = vmw_overlay_update_stream(dev_priv, stream->buf, & stream->saved, 0);
#line 515
  if (ret != 0) {
#line 516
    printk("<6>[drm] %s: *warning* failed to resume stream %i\n", "vmw_overlay_resume_all",
           i);
  } else {

  }
  ldv_39242: 
#line 508
  i = i + 1;
  ldv_39245: ;
#line 508
  if (i <= 0) {
#line 509
    goto ldv_39244;
  } else {

  }
#line 520
  ldv_mutex_unlock_446(& overlay->mutex);
#line 522
  return (0);
}
}
#line 532 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 534
  overlay = dev_priv->overlay_priv;
#line 537
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 538
    return (0);
  } else {

  }
#line 540
  ldv_mutex_lock_447(& overlay->mutex);
#line 542
  i = 0;
#line 542
  goto ldv_39257;
  ldv_39256: ;
#line 543
  if ((int )overlay->stream[i].paused) {
#line 544
    printk("<6>[drm] %s: *warning* stream %i already paused\n", "vmw_overlay_pause_all",
           i);
  } else {

  }
#line 546
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 1, 0);
#line 547
  __ret_warn_on = ret != 0;
#line 547
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 547
  if (tmp != 0L) {
#line 547
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       547);
  } else {

  }
#line 547
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 542
  i = i + 1;
  ldv_39257: ;
#line 542
  if (i <= 0) {
#line 543
    goto ldv_39256;
  } else {

  }
#line 550
  ldv_mutex_unlock_448(& overlay->mutex);
#line 552
  return (0);
}
}
#line 555 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct vmw_overlay *overlay ;
  struct drm_vmw_control_stream_arg *arg ;
  struct vmw_dma_buffer *buf ;
  struct vmw_resource *res ;
  int ret ;

  {
#line 558
  tmp = vmw_fpriv(file_priv);
#line 558
  tfile = tmp->tfile;
#line 559
  tmp___0 = vmw_priv(dev);
#line 559
  dev_priv = tmp___0;
#line 560
  overlay = dev_priv->overlay_priv;
#line 561
  arg = (struct drm_vmw_control_stream_arg *)data;
#line 567
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 568
    return (-38);
  } else {

  }
#line 570
  ret = vmw_user_stream_lookup(dev_priv, tfile, & arg->stream_id, & res);
#line 571
  if (ret != 0) {
#line 572
    return (ret);
  } else {

  }
#line 574
  ldv_mutex_lock_449(& overlay->mutex);
#line 576
  if (arg->enabled == 0U) {
#line 577
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, 1);
#line 578
    goto out_unlock;
  } else {

  }
#line 581
  ret = vmw_user_dmabuf_lookup(tfile, arg->handle, & buf);
#line 582
  if (ret != 0) {
#line 583
    goto out_unlock;
  } else {

  }
#line 585
  ret = vmw_overlay_update_stream(dev_priv, buf, arg, 1);
#line 587
  vmw_dmabuf_unreference(& buf);
  out_unlock: 
#line 590
  ldv_mutex_unlock_450(& overlay->mutex);
#line 591
  vmw_resource_unreference(& res);
#line 593
  return (ret);
}
}
#line 596 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) 
{ 


  {
#line 598
  if ((unsigned long )dev_priv->overlay_priv == (unsigned long )((struct vmw_overlay *)0)) {
#line 599
    return (0);
  } else {

  }
#line 601
  return (1);
}
}
#line 604 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  int k ;

  {
#line 606
  overlay = dev_priv->overlay_priv;
#line 609
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 610
    return (0);
  } else {

  }
#line 612
  ldv_mutex_lock_451(& overlay->mutex);
#line 614
  i = 0;
#line 614
  k = 0;
#line 614
  goto ldv_39282;
  ldv_39281: ;
#line 615
  if (! overlay->stream[i].claimed) {
#line 616
    k = k + 1;
  } else {

  }
#line 614
  i = i + 1;
  ldv_39282: ;
#line 614
  if (i <= 0) {
#line 615
    goto ldv_39281;
  } else {

  }
#line 618
  ldv_mutex_unlock_452(& overlay->mutex);
#line 620
  return (k);
}
}
#line 623 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;

  {
#line 625
  overlay = dev_priv->overlay_priv;
#line 628
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 629
    return (-38);
  } else {

  }
#line 631
  ldv_mutex_lock_453(& overlay->mutex);
#line 633
  i = 0;
#line 633
  goto ldv_39292;
  ldv_39291: ;
#line 635
  if ((int )overlay->stream[i].claimed) {
#line 636
    goto ldv_39290;
  } else {

  }
#line 638
  overlay->stream[i].claimed = 1;
#line 639
  *out = (uint32_t )i;
#line 640
  ldv_mutex_unlock_454(& overlay->mutex);
#line 641
  return (0);
  ldv_39290: 
#line 633
  i = i + 1;
  ldv_39292: ;
#line 633
  if (i <= 0) {
#line 634
    goto ldv_39291;
  } else {

  }
#line 644
  ldv_mutex_unlock_455(& overlay->mutex);
#line 645
  return (-3);
}
}
#line 648 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) 
{ 
  struct vmw_overlay *overlay ;
  long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 650
  overlay = dev_priv->overlay_priv;
#line 652
  tmp = ldv__builtin_expect(stream_id != 0U, 0L);
#line 652
  if (tmp != 0L) {
#line 652
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                         "i" (652), "i" (12UL));
    ldv_39299: ;
#line 652
    goto ldv_39299;
  } else {

  }
#line 654
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 655
    return (-38);
  } else {

  }
#line 657
  ldv_mutex_lock_456(& overlay->mutex);
#line 659
  __ret_warn_on = ! overlay->stream[stream_id].claimed;
#line 659
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 659
  if (tmp___0 != 0L) {
#line 659
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       659);
  } else {

  }
#line 659
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 660
  vmw_overlay_stop(dev_priv, stream_id, 0, 0);
#line 661
  overlay->stream[stream_id].claimed = 0;
#line 663
  ldv_mutex_unlock_457(& overlay->mutex);
#line 664
  return (0);
}
}
#line 667 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_init(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  int i ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 672
  if ((unsigned long )dev_priv->overlay_priv != (unsigned long )((struct vmw_overlay *)0)) {
#line 673
    return (-22);
  } else {

  }
#line 675
  if ((dev_priv->fifo.capabilities & 8U) == 0U && (dev_priv->fifo.capabilities & 32U) != 0U) {
#line 677
    printk("<6>[drm] hardware doesn\'t support overlays\n");
#line 678
    return (-38);
  } else {

  }
#line 681
  tmp = kzalloc(272UL, 208U);
#line 681
  overlay = (struct vmw_overlay *)tmp;
#line 682
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 683
    return (-12);
  } else {

  }
#line 685
  __mutex_init(& overlay->mutex, "&overlay->mutex", & __key);
#line 686
  i = 0;
#line 686
  goto ldv_39309;
  ldv_39308: 
#line 687
  overlay->stream[i].buf = 0;
#line 688
  overlay->stream[i].paused = 0;
#line 689
  overlay->stream[i].claimed = 0;
#line 686
  i = i + 1;
  ldv_39309: ;
#line 686
  if (i <= 0) {
#line 687
    goto ldv_39308;
  } else {

  }
#line 692
  dev_priv->overlay_priv = overlay;
#line 694
  return (0);
}
}
#line 697 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_close(struct vmw_private *dev_priv ) 
{ 
  struct vmw_overlay *overlay ;
  bool forgotten_buffer ;
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 699
  overlay = dev_priv->overlay_priv;
#line 700
  forgotten_buffer = 0;
#line 703
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 704
    return (-38);
  } else {

  }
#line 706
  i = 0;
#line 706
  goto ldv_39318;
  ldv_39317: ;
#line 707
  if ((unsigned long )overlay->stream[i].buf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 708
    forgotten_buffer = 1;
#line 709
    vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
  } else {

  }
#line 706
  i = i + 1;
  ldv_39318: ;
#line 706
  if (i <= 0) {
#line 707
    goto ldv_39317;
  } else {

  }
#line 713
  __ret_warn_on = (int )forgotten_buffer;
#line 713
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 713
  if (tmp != 0L) {
#line 713
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       713);
  } else {

  }
#line 713
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 715
  dev_priv->overlay_priv = 0;
#line 716
  kfree((void const   *)overlay);
#line 718
  return (0);
}
}
#line 721 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_431(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 726
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 728
  mutex_lock(ldv_func_arg1);
#line 729
  return;
}
}
#line 731 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int ldv_mutex_trylock_432(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp = mutex_trylock(ldv_func_arg1);
#line 736
  ldv_func_res = tmp;
#line 738
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 738
  return (tmp___0);
#line 740
  return (ldv_func_res);
}
}
#line 743 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 748
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 750
  mutex_unlock(ldv_func_arg1);
#line 751
  return;
}
}
#line 753 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_434(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 758
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 760
  mutex_lock(ldv_func_arg1);
#line 761
  return;
}
}
#line 763 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_435(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 768
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 770
  mutex_unlock(ldv_func_arg1);
#line 771
  return;
}
}
#line 773 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 778
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 780
  mutex_lock(ldv_func_arg1);
#line 781
  return;
}
}
#line 783 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 788
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 790
  mutex_unlock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 798
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 800
  mutex_unlock(ldv_func_arg1);
#line 801
  return;
}
}
#line 803 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_439(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 808
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 810
  mutex_lock(ldv_func_arg1);
#line 811
  return;
}
}
#line 813 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_440(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 818
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 820
  mutex_unlock(ldv_func_arg1);
#line 821
  return;
}
}
#line 823 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_441(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 828
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 830
  mutex_lock(ldv_func_arg1);
#line 831
  return;
}
}
#line 833 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_442(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 838
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 840
  mutex_unlock(ldv_func_arg1);
#line 841
  return;
}
}
#line 843 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_443(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 848
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 850
  mutex_lock(ldv_func_arg1);
#line 851
  return;
}
}
#line 853 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_444(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 858
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 860
  mutex_unlock(ldv_func_arg1);
#line 861
  return;
}
}
#line 863 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_445(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 868
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 870
  mutex_lock(ldv_func_arg1);
#line 871
  return;
}
}
#line 873 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_446(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 878
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 880
  mutex_unlock(ldv_func_arg1);
#line 881
  return;
}
}
#line 883 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_447(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 888
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 890
  mutex_lock(ldv_func_arg1);
#line 891
  return;
}
}
#line 893 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_448(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 898
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 900
  mutex_unlock(ldv_func_arg1);
#line 901
  return;
}
}
#line 903 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_449(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 908
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 910
  mutex_lock(ldv_func_arg1);
#line 911
  return;
}
}
#line 913 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 918
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 920
  mutex_unlock(ldv_func_arg1);
#line 921
  return;
}
}
#line 923 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 928
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 930
  mutex_lock(ldv_func_arg1);
#line 931
  return;
}
}
#line 933 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_452(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 938
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 940
  mutex_unlock(ldv_func_arg1);
#line 941
  return;
}
}
#line 943 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 948
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 950
  mutex_lock(ldv_func_arg1);
#line 951
  return;
}
}
#line 953 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 958
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 960
  mutex_unlock(ldv_func_arg1);
#line 961
  return;
}
}
#line 963 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 968
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 970
  mutex_unlock(ldv_func_arg1);
#line 971
  return;
}
}
#line 973 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 978
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 980
  mutex_lock(ldv_func_arg1);
#line 981
  return;
}
}
#line 983 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 988
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 990
  mutex_unlock(ldv_func_arg1);
#line 991
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_486(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_491(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_485(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) ;
#line 56 "include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 


  {
#line 58
  if ((long )lhs->tv_sec < (long )rhs->tv_sec) {
#line 59
    return (-1);
  } else {

  }
#line 60
  if ((long )lhs->tv_sec > (long )rhs->tv_sec) {
#line 61
    return (1);
  } else {

  }
#line 62
  return ((int )((unsigned int )lhs->tv_nsec - (unsigned int )rhs->tv_nsec));
}
}
#line 78
extern void set_normalized_timespec(struct timespec * , time_t  , s64  ) ;
#line 101 "include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ 
  struct timespec ts_delta ;

  {
#line 105
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, (s64 )(lhs.tv_nsec - rhs.tv_nsec));
#line 107
  return (ts_delta);
}
}
#line 160
extern void getrawmonotonic(struct timespec * ) ;
#line 234
extern struct timespec ns_to_timespec(s64 const    ) ;
#line 140 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) 
{ 
  struct lock_class_key __key ;

  {
#line 142
  INIT_LIST_HEAD(& queue->head);
#line 143
  queue->lag = ns_to_timespec(0LL);
#line 144
  getrawmonotonic(& queue->lag_time);
#line 145
  spinlock_check(& queue->lock);
#line 145
  __raw_spin_lock_init(& queue->lock.ldv_5988.rlock, "&(&queue->lock)->rlock", & __key);
#line 147
  return;
}
}
#line 148 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) 
{ 
  struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 152
  spin_lock(& queue->lock);
#line 153
  __mptr = (struct list_head  const  *)queue->head.next;
#line 153
  marker = (struct vmw_marker *)__mptr;
#line 153
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 153
  next = (struct vmw_marker *)__mptr___0;
#line 153
  goto ldv_39026;
  ldv_39025: 
#line 154
  kfree((void const   *)marker);
#line 153
  marker = next;
#line 153
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 153
  next = (struct vmw_marker *)__mptr___1;
  ldv_39026: ;
#line 153
  if ((unsigned long )marker != (unsigned long )queue) {
#line 154
    goto ldv_39025;
  } else {

  }
#line 156
  spin_unlock(& queue->lock);
#line 157
  return;
}
}
#line 159 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) 
{ 
  struct vmw_marker *marker ;
  void *tmp ;
  long tmp___0 ;

  {
#line 162
  tmp = kmalloc(40UL, 208U);
#line 162
  marker = (struct vmw_marker *)tmp;
#line 164
  tmp___0 = ldv__builtin_expect((unsigned long )marker == (unsigned long )((struct vmw_marker *)0),
                             0L);
#line 164
  if (tmp___0 != 0L) {
#line 165
    return (-12);
  } else {

  }
#line 167
  marker->seqno = seqno;
#line 168
  getrawmonotonic(& marker->submitted);
#line 169
  spin_lock(& queue->lock);
#line 170
  list_add_tail(& marker->head, & queue->head);
#line 171
  spin_unlock(& queue->lock);
#line 173
  return (0);
}
}
#line 176 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) 
{ 
  struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct timespec now ;
  bool updated ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 181
  updated = 0;
#line 183
  spin_lock(& queue->lock);
#line 184
  getrawmonotonic(& now);
#line 186
  tmp = list_empty((struct list_head  const  *)(& queue->head));
#line 186
  if (tmp != 0) {
#line 187
    queue->lag = ns_to_timespec(0LL);
#line 188
    queue->lag_time = now;
#line 189
    updated = 1;
#line 190
    goto out_unlock;
  } else {

  }
#line 193
  __mptr = (struct list_head  const  *)queue->head.next;
#line 193
  marker = (struct vmw_marker *)__mptr;
#line 193
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 193
  next = (struct vmw_marker *)__mptr___0;
#line 193
  goto ldv_39050;
  ldv_39049: ;
#line 194
  if (signaled_seqno - marker->seqno > 1073741824U) {
#line 195
    goto ldv_39048;
  } else {

  }
#line 197
  queue->lag = timespec_sub(now, marker->submitted);
#line 198
  queue->lag_time = now;
#line 199
  updated = 1;
#line 200
  list_del(& marker->head);
#line 201
  kfree((void const   *)marker);
  ldv_39048: 
#line 193
  marker = next;
#line 193
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 193
  next = (struct vmw_marker *)__mptr___1;
  ldv_39050: ;
#line 193
  if ((unsigned long )marker != (unsigned long )queue) {
#line 194
    goto ldv_39049;
  } else {

  }

  out_unlock: 
#line 205
  spin_unlock(& queue->lock);
#line 207
  return ((int )updated ? 0 : -16);
}
}
#line 210 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_timespec_add(struct timespec t1 , struct timespec t2 ) 
{ 


  {
#line 213
  t1.tv_sec = t1.tv_sec + t2.tv_sec;
#line 214
  t1.tv_nsec = t1.tv_nsec + t2.tv_nsec;
#line 215
  if (t1.tv_nsec > 999999999L) {
#line 216
    t1.tv_sec = t1.tv_sec + 1L;
#line 217
    t1.tv_nsec = t1.tv_nsec + -1000000000L;
  } else {

  }
#line 220
  return (t1);
}
}
#line 223 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue ) 
{ 
  struct timespec now ;
  struct timespec tmp ;

  {
#line 227
  spin_lock(& queue->lock);
#line 228
  getrawmonotonic(& now);
#line 229
  tmp = timespec_sub(now, queue->lag_time);
#line 229
  queue->lag = vmw_timespec_add(queue->lag, tmp);
#line 231
  queue->lag_time = now;
#line 232
  spin_unlock(& queue->lock);
#line 233
  return (queue->lag);
}
}
#line 237 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static bool vmw_lag_lt(struct vmw_marker_queue *queue , uint32_t us ) 
{ 
  struct timespec lag ;
  struct timespec cond ;
  int tmp ;

  {
#line 242
  cond = ns_to_timespec((long long )us * 1000LL);
#line 243
  lag = vmw_fifo_lag(queue);
#line 244
  tmp = timespec_compare((struct timespec  const  *)(& lag), (struct timespec  const  *)(& cond));
#line 244
  return (tmp <= 0);
}
}
#line 247 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) 
{ 
  struct vmw_marker *marker ;
  uint32_t seqno ;
  int ret ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 254
  goto ldv_39077;
  ldv_39076: 
#line 255
  spin_lock(& queue->lock);
#line 256
  tmp___0 = list_empty((struct list_head  const  *)(& queue->head));
#line 256
  if (tmp___0 != 0) {
#line 257
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 257
    seqno = (uint32_t )tmp;
  } else {
#line 259
    __mptr = (struct list_head  const  *)queue->head.next;
#line 259
    marker = (struct vmw_marker *)__mptr;
#line 261
    seqno = marker->seqno;
  }
#line 263
  spin_unlock(& queue->lock);
#line 265
  ret = vmw_wait_seqno(dev_priv, 0, seqno, 1, 750UL);
#line 268
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 268
  if (tmp___1 != 0L) {
#line 269
    return (ret);
  } else {

  }
#line 271
  vmw_marker_pull(queue, seqno);
  ldv_39077: 
#line 254
  tmp___2 = vmw_lag_lt(queue, us);
#line 254
  if (tmp___2) {
#line 254
    tmp___3 = 0;
  } else {
#line 254
    tmp___3 = 1;
  }
#line 254
  if (tmp___3) {
#line 255
    goto ldv_39076;
  } else {

  }

#line 273
  return (0);
}
}
#line 276 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_485(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 281
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 283
  mutex_lock(ldv_func_arg1);
#line 284
  return;
}
}
#line 286 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int ldv_mutex_trylock_486(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 291
  tmp = mutex_trylock(ldv_func_arg1);
#line 291
  ldv_func_res = tmp;
#line 293
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 293
  return (tmp___0);
#line 295
  return (ldv_func_res);
}
}
#line 298 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 303
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 305
  mutex_unlock(ldv_func_arg1);
#line 306
  return;
}
}
#line 308 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 313
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 315
  mutex_lock(ldv_func_arg1);
#line 316
  return;
}
}
#line 318 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 323
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 325
  mutex_unlock(ldv_func_arg1);
#line 326
  return;
}
}
#line 328 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 333
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 335
  mutex_lock(ldv_func_arg1);
#line 336
  return;
}
}
#line 338 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_491(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 343
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 345
  mutex_unlock(ldv_func_arg1);
#line 346
  return;
}
}
#line 348 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 353
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 355
  mutex_unlock(ldv_func_arg1);
#line 356
  return;
}
}
#line 358 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 363
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 365
  mutex_lock(ldv_func_arg1);
#line 366
  return;
}
}
#line 368 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 373
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 375
  mutex_unlock(ldv_func_arg1);
#line 376
  return;
}
}
#line 378 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 383
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 385
  mutex_lock(ldv_func_arg1);
#line 386
  return;
}
}
#line 388 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 393
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 395
  mutex_unlock(ldv_func_arg1);
#line 396
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_510(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_515(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_518(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_520(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_509(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_514(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_517(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_519(struct mutex *ldv_func_arg1 ) ;
#line 142 "include/linux/idr.h"
extern int ida_pre_get(struct ida * , gfp_t  ) ;
#line 144
extern int ida_get_new(struct ida * , int * ) ;
#line 145
extern void ida_remove(struct ida * , int  ) ;
#line 146
extern void ida_destroy(struct ida * ) ;
#line 147
extern void ida_init(struct ida * ) ;
#line 150 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                                  struct ttm_placement *placement , struct ttm_mem_reg *mem ) 
{ 
  struct vmwgfx_gmrid_man *gman ;
  int ret ;
  int id ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 155
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 157
  ret = 0;
#line 160
  mem->mm_node = 0;
#line 162
  spin_lock(& gman->lock);
#line 164
  if (gman->max_gmr_pages != 0U) {
#line 165
    gman->used_gmr_pages = gman->used_gmr_pages + (uint32_t )bo->num_pages;
#line 166
    tmp = ldv__builtin_expect(gman->used_gmr_pages > gman->max_gmr_pages, 0L);
#line 166
    if (tmp != 0L) {
#line 167
      goto out_err_locked;
    } else {

    }
  } else {

  }
  ldv_39023: 
#line 171
  spin_unlock(& gman->lock);
#line 172
  tmp___0 = ida_pre_get(& gman->gmr_ida, 208U);
#line 172
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 172
  if (tmp___1 != 0L) {
#line 173
    ret = -12;
#line 174
    goto out_err;
  } else {

  }
#line 176
  spin_lock(& gman->lock);
#line 178
  ret = ida_get_new(& gman->gmr_ida, & id);
#line 179
  tmp___2 = ldv__builtin_expect(ret == 0, 0L);
#line 179
  if (tmp___2 != 0L) {
#line 179
    tmp___3 = ldv__builtin_expect((uint32_t )id >= gman->max_gmr_ids, 0L);
#line 179
    if (tmp___3 != 0L) {
#line 180
      ida_remove(& gman->gmr_ida, id);
#line 181
      ret = 0;
#line 182
      goto out_err_locked;
    } else {

    }
  } else {

  }
#line 184
  if (ret == -11) {
#line 185
    goto ldv_39023;
  } else {

  }
#line 186
  tmp___4 = ldv__builtin_expect(ret == 0, 1L);
#line 186
  if (tmp___4 != 0L) {
#line 187
    mem->mm_node = (void *)gman;
#line 188
    mem->start = (unsigned long )id;
#line 189
    mem->num_pages = bo->num_pages;
  } else {
#line 191
    goto out_err_locked;
  }
#line 193
  spin_unlock(& gman->lock);
#line 194
  return (0);
  out_err: 
#line 197
  spin_lock(& gman->lock);
  out_err_locked: 
#line 199
  gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )bo->num_pages;
#line 200
  spin_unlock(& gman->lock);
#line 201
  return (ret);
}
}
#line 204 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) 
{ 
  struct vmwgfx_gmrid_man *gman ;

  {
#line 207
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 210
  if ((unsigned long )mem->mm_node != (unsigned long )((void *)0)) {
#line 211
    spin_lock(& gman->lock);
#line 212
    ida_remove(& gman->gmr_ida, (int )mem->start);
#line 213
    gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )mem->num_pages;
#line 214
    spin_unlock(& gman->lock);
#line 215
    mem->mm_node = 0;
  } else {

  }
#line 217
  return;
}
}
#line 219 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_init(struct ttm_mem_type_manager *man , unsigned long p_size ) 
{ 
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;
  struct vmwgfx_gmrid_man *gman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;

  {
#line 223
  __mptr = (struct ttm_bo_device  const  *)man->bdev;
#line 223
  dev_priv = (struct vmw_private *)__mptr;
#line 224
  tmp = kzalloc(192UL, 208U);
#line 224
  gman = (struct vmwgfx_gmrid_man *)tmp;
#line 227
  tmp___0 = ldv__builtin_expect((unsigned long )gman == (unsigned long )((struct vmwgfx_gmrid_man *)0),
                             0L);
#line 227
  if (tmp___0 != 0L) {
#line 228
    return (-12);
  } else {

  }
#line 230
  spinlock_check(& gman->lock);
#line 230
  __raw_spin_lock_init(& gman->lock.ldv_5988.rlock, "&(&gman->lock)->rlock", & __key);
#line 231
  gman->max_gmr_pages = dev_priv->max_gmr_pages;
#line 232
  gman->used_gmr_pages = 0U;
#line 233
  ida_init(& gman->gmr_ida);
#line 234
  gman->max_gmr_ids = (uint32_t )p_size;
#line 235
  man->priv = (void *)gman;
#line 236
  return (0);
}
}
#line 239 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man ) 
{ 
  struct vmwgfx_gmrid_man *gman ;

  {
#line 241
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 244
  if ((unsigned long )gman != (unsigned long )((struct vmwgfx_gmrid_man *)0)) {
#line 245
    ida_destroy(& gman->gmr_ida);
#line 246
    kfree((void const   *)gman);
  } else {

  }
#line 248
  return (0);
}
}
#line 251 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man , char const   *prefix ) 
{ 


  {
#line 254
  printk("<6>%s: No debug info available for the GMR id manager.\n", prefix);
#line 255
  return;
}
}
#line 258 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func  =    {& vmw_gmrid_man_init, & vmw_gmrid_man_takedown, & vmw_gmrid_man_get_node, & vmw_gmrid_man_put_node,
    & vmw_gmrid_man_debug};
#line 266 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_509(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 271
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 273
  mutex_lock(ldv_func_arg1);
#line 274
  return;
}
}
#line 276 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
int ldv_mutex_trylock_510(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 281
  tmp = mutex_trylock(ldv_func_arg1);
#line 281
  ldv_func_res = tmp;
#line 283
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 283
  return (tmp___0);
#line 285
  return (ldv_func_res);
}
}
#line 288 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 293
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 295
  mutex_unlock(ldv_func_arg1);
#line 296
  return;
}
}
#line 298 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 303
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 305
  mutex_lock(ldv_func_arg1);
#line 306
  return;
}
}
#line 308 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 313
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 315
  mutex_unlock(ldv_func_arg1);
#line 316
  return;
}
}
#line 318 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_514(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 323
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 325
  mutex_lock(ldv_func_arg1);
#line 326
  return;
}
}
#line 328 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_515(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 333
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 335
  mutex_unlock(ldv_func_arg1);
#line 336
  return;
}
}
#line 338 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 343
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 345
  mutex_unlock(ldv_func_arg1);
#line 346
  return;
}
}
#line 348 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_517(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 353
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 355
  mutex_lock(ldv_func_arg1);
#line 356
  return;
}
}
#line 358 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_518(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 363
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 365
  mutex_unlock(ldv_func_arg1);
#line 366
  return;
}
}
#line 368 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_519(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 373
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 375
  mutex_lock(ldv_func_arg1);
#line 376
  return;
}
}
#line 378 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_520(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 383
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 385
  mutex_unlock(ldv_func_arg1);
#line 386
  return;
}
}
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 277
  first = list->next;
#line 278
  last = list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
#line 285
  return;
}
}
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
#line 321
  if (tmp == 0) {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
  } else {

  }
#line 325
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_534(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_535(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_539(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_542(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_544(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_533(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_538(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_543(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_545(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_547(struct mutex *ldv_func_arg1 ) ;
#line 71
void ldv_mutex_lock_goal_irq_mutex(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_goal_irq_mutex(struct mutex *lock ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5988.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5988.rlock);
#line 336
  return;
}
}
#line 148 "include/linux/time.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 156 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 380
extern int schedule_work(struct work_struct * ) ;
#line 392
extern bool cancel_work_sync(struct work_struct * ) ;
#line 208 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_obj_destroy_locked(struct kref *kref ) 
{ 
  struct vmw_fence_obj *fence ;
  struct kref  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned int num_fences ;

  {
#line 211
  __mptr = (struct kref  const  *)kref;
#line 211
  fence = (struct vmw_fence_obj *)__mptr;
#line 213
  fman = fence->fman;
#line 216
  list_del_init(& fence->head);
#line 217
  fman->num_fence_objects = fman->num_fence_objects - 1;
#line 217
  num_fences = (unsigned int )fman->num_fence_objects;
#line 218
  spin_unlock_irq(& fman->lock);
#line 219
  if ((unsigned long )fence->destroy != (unsigned long )((void (*)(struct vmw_fence_obj * ))0)) {
#line 220
    (*(fence->destroy))(fence);
  } else {
#line 222
    kfree((void const   *)fence);
  }
#line 224
  spin_lock_irq(& fman->lock);
#line 225
  return;
}
}
#line 234 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_work_func(struct work_struct *work ) 
{ 
  struct vmw_fence_manager *fman ;
  struct work_struct  const  *__mptr ;
  struct list_head list ;
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  bool seqno_valid ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 237
  __mptr = (struct work_struct  const  *)work;
#line 237
  fman = (struct vmw_fence_manager *)__mptr + 0xffffffffffffff98UL;
  ldv_39074: 
#line 243
  INIT_LIST_HEAD(& list);
#line 244
  ldv_mutex_lock_545(& fman->goal_irq_mutex);
#line 246
  spin_lock_irq(& fman->lock);
#line 247
  list_splice_init(& fman->cleanup_list, & list);
#line 248
  seqno_valid = fman->seqno_valid;
#line 249
  spin_unlock_irq(& fman->lock);
#line 251
  if (! seqno_valid && (int )fman->goal_irq_on) {
#line 252
    fman->goal_irq_on = 0;
#line 253
    vmw_goal_waiter_remove(fman->dev_priv);
  } else {

  }
#line 255
  ldv_mutex_unlock_546(& fman->goal_irq_mutex);
#line 257
  tmp = list_empty((struct list_head  const  *)(& list));
#line 257
  if (tmp != 0) {
#line 258
    return;
  } else {

  }
#line 266
  __mptr___0 = (struct list_head  const  *)list.next;
#line 266
  action = (struct vmw_fence_action *)__mptr___0;
#line 266
  __mptr___1 = (struct list_head  const  *)action->head.next;
#line 266
  next_action = (struct vmw_fence_action *)__mptr___1;
#line 266
  goto ldv_39072;
  ldv_39071: 
#line 267
  list_del_init(& action->head);
#line 268
  if ((unsigned long )action->cleanup != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 269
    (*(action->cleanup))(action);
  } else {

  }
#line 266
  action = next_action;
#line 266
  __mptr___2 = (struct list_head  const  *)next_action->head.next;
#line 266
  next_action = (struct vmw_fence_action *)__mptr___2;
  ldv_39072: ;
#line 266
  if ((unsigned long )(& action->head) != (unsigned long )(& list)) {
#line 267
    goto ldv_39071;
  } else {

  }

#line 271
  goto ldv_39074;
}
}
#line 274 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) 
{ 
  struct vmw_fence_manager *fman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct lock_class_key __key___1 ;

  {
#line 276
  tmp = kzalloc(400UL, 208U);
#line 276
  fman = (struct vmw_fence_manager *)tmp;
#line 278
  tmp___0 = ldv__builtin_expect((unsigned long )fman == (unsigned long )((struct vmw_fence_manager *)0),
                             0L);
#line 278
  if (tmp___0 != 0L) {
#line 279
    return (0);
  } else {

  }
#line 281
  fman->dev_priv = dev_priv;
#line 282
  spinlock_check(& fman->lock);
#line 282
  __raw_spin_lock_init(& fman->lock.ldv_5988.rlock, "&(&fman->lock)->rlock", & __key);
#line 283
  INIT_LIST_HEAD(& fman->fence_list);
#line 284
  INIT_LIST_HEAD(& fman->cleanup_list);
#line 285
  __init_work(& fman->work, 0);
#line 285
  __constr_expr_0.counter = 2097664L;
#line 285
  fman->work.data = __constr_expr_0;
#line 285
  lockdep_init_map(& fman->work.lockdep_map, "(&fman->work)", & __key___0, 0);
#line 285
  INIT_LIST_HEAD(& fman->work.entry);
#line 285
  fman->work.func = & vmw_fence_work_func;
#line 286
  fman->fifo_down = 1;
#line 287
  tmp___1 = ttm_round_pot(216UL);
#line 287
  fman->user_fence_size = (u32 )tmp___1;
#line 288
  tmp___2 = ttm_round_pot(152UL);
#line 288
  fman->fence_size = (u32 )tmp___2;
#line 289
  tmp___3 = ttm_round_pot(96UL);
#line 289
  fman->event_fence_action_size = (u32 )tmp___3;
#line 291
  __mutex_init(& fman->goal_irq_mutex, "&fman->goal_irq_mutex", & __key___1);
#line 293
  return (fman);
}
}
#line 296 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  bool lists_empty ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 301
  cancel_work_sync(& fman->work);
#line 303
  tmp = spinlock_check(& fman->lock);
#line 303
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 304
  tmp___0 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 304
  if (tmp___0 != 0) {
#line 304
    tmp___1 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 304
    if (tmp___1 != 0) {
#line 304
      tmp___2 = 1;
    } else {
#line 304
      tmp___2 = 0;
    }
  } else {
#line 304
    tmp___2 = 0;
  }
#line 304
  lists_empty = (bool )tmp___2;
#line 306
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 308
  tmp___3 = ldv__builtin_expect((long )(! lists_empty), 0L);
#line 308
  if (tmp___3 != 0L) {
#line 308
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (308), "i" (12UL));
    ldv_39091: ;
#line 308
    goto ldv_39091;
  } else {

  }
#line 309
  kfree((void const   *)fman);
#line 310
  return;
}
}
#line 312 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static int vmw_fence_obj_init(struct vmw_fence_manager *fman , struct vmw_fence_obj *fence ,
                              u32 seqno , uint32_t mask , void (*destroy)(struct vmw_fence_obj * ) ) 
{ 
  unsigned long irq_flags ;
  unsigned int num_fences ;
  int ret ;
  struct lock_class_key __key ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;

  {
#line 320
  ret = 0;
#line 322
  fence->seqno = seqno;
#line 323
  INIT_LIST_HEAD(& fence->seq_passed_actions);
#line 324
  fence->fman = fman;
#line 325
  fence->signaled = 0U;
#line 326
  fence->signal_mask = mask;
#line 327
  kref_init(& fence->kref);
#line 328
  fence->destroy = destroy;
#line 329
  __init_waitqueue_head(& fence->queue, "&fence->queue", & __key);
#line 331
  tmp = spinlock_check(& fman->lock);
#line 331
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 332
  tmp___0 = ldv__builtin_expect((long )fman->fifo_down, 0L);
#line 332
  if (tmp___0 != 0L) {
#line 333
    ret = -16;
#line 334
    goto out_unlock;
  } else {

  }
#line 336
  list_add_tail(& fence->head, & fman->fence_list);
#line 337
  fman->num_fence_objects = fman->num_fence_objects + 1;
#line 337
  num_fences = (unsigned int )fman->num_fence_objects;
  out_unlock: 
#line 340
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 341
  return (ret);
}
}
#line 345 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) 
{ 
  long tmp ;

  {
#line 347
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 347
  if (tmp != 0L) {
#line 348
    return (0);
  } else {

  }
#line 350
  kref_get(& fence->kref);
#line 351
  return (fence);
}
}
#line 361 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) 
{ 
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 363
  fence = *fence_p;
#line 366
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 366
  if (tmp != 0L) {
#line 367
    return;
  } else {

  }
#line 369
  fman = fence->fman;
#line 370
  *fence_p = 0;
#line 371
  spin_lock_irq(& fman->lock);
#line 372
  tmp___0 = atomic_read((atomic_t const   *)(& fence->kref.refcount));
#line 372
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 372
  if (tmp___1 != 0L) {
#line 372
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (372), "i" (12UL));
    ldv_39116: ;
#line 372
    goto ldv_39116;
  } else {

  }
#line 373
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
#line 374
  spin_unlock_irq(& fman->lock);
#line 375
  return;
}
}
#line 377 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_perform_actions(struct vmw_fence_manager *fman , struct list_head *list ) 
{ 
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 382
  __mptr = (struct list_head  const  *)list->next;
#line 382
  action = (struct vmw_fence_action *)__mptr;
#line 382
  __mptr___0 = (struct list_head  const  *)action->head.next;
#line 382
  next_action = (struct vmw_fence_action *)__mptr___0;
#line 382
  goto ldv_39130;
  ldv_39129: 
#line 383
  list_del_init(& action->head);
#line 384
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] - (uint32_t )1;
#line 385
  if ((unsigned long )action->seq_passed != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 386
    (*(action->seq_passed))(action);
  } else {

  }
#line 393
  list_add_tail(& action->head, & fman->cleanup_list);
#line 382
  action = next_action;
#line 382
  __mptr___1 = (struct list_head  const  *)next_action->head.next;
#line 382
  next_action = (struct vmw_fence_action *)__mptr___1;
  ldv_39130: ;
#line 382
  if ((unsigned long )(& action->head) != (unsigned long )list) {
#line 383
    goto ldv_39129;
  } else {

  }

#line 387
  return;
}
}
#line 413 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_new_locked(struct vmw_fence_manager *fman , u32 passed_seqno ) 
{ 
  u32 goal_seqno ;
  __le32 *fifo_mem ;
  struct vmw_fence_obj *fence ;
  long tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 420
  tmp = ldv__builtin_expect((long )(! fman->seqno_valid), 1L);
#line 420
  if (tmp != 0L) {
#line 421
    return (0);
  } else {

  }
#line 423
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 424
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 425
  tmp___0 = ldv__builtin_expect((int )(passed_seqno - goal_seqno) < 0, 1L);
#line 425
  if (tmp___0 != 0L) {
#line 426
    return (0);
  } else {

  }
#line 428
  fman->seqno_valid = 0;
#line 429
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 429
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 429
  goto ldv_39145;
  ldv_39144: 
#line 430
  tmp___1 = list_empty((struct list_head  const  *)(& fence->seq_passed_actions));
#line 430
  if (tmp___1 == 0) {
#line 431
    fman->seqno_valid = 1;
#line 432
    iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 434
    goto ldv_39143;
  } else {

  }
#line 429
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 429
  fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_39145: ;
#line 429
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 430
    goto ldv_39144;
  } else {

  }
  ldv_39143: ;
#line 438
  return (1);
}
}
#line 457 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_check_locked(struct vmw_fence_obj *fence ) 
{ 
  u32 goal_seqno ;
  __le32 *fifo_mem ;
  long tmp ;
  long tmp___0 ;

  {
#line 462
  if ((int )fence->signaled & 1) {
#line 463
    return (0);
  } else {

  }
#line 465
  fifo_mem = ((fence->fman)->dev_priv)->mmio_virt;
#line 466
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 467
  tmp = ldv__builtin_expect((long )(fence->fman)->seqno_valid, 1L);
#line 467
  if (tmp != 0L) {
#line 467
    tmp___0 = ldv__builtin_expect((int )(goal_seqno - fence->seqno) >= 0, 1L);
#line 467
    if (tmp___0 != 0L) {
#line 469
      return (0);
    } else {

    }
  } else {

  }
#line 471
  iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 472
  (fence->fman)->seqno_valid = 1;
#line 474
  return (1);
}
}
#line 477 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_update(struct vmw_fence_manager *fman ) 
{ 
  unsigned long flags ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_obj *next_fence ;
  struct list_head action_list ;
  bool needs_rerun ;
  uint32_t seqno ;
  uint32_t new_seqno ;
  __le32 *fifo_mem ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 484
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 486
  seqno = ioread32((void *)fifo_mem + 6U);
  rerun: 
#line 488
  tmp = spinlock_check(& fman->lock);
#line 488
  flags = _raw_spin_lock_irqsave(tmp);
#line 489
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 489
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 489
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 489
  next_fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
#line 489
  goto ldv_39174;
  ldv_39173: ;
#line 490
  if ((int )(seqno - fence->seqno) >= 0) {
#line 491
    list_del_init(& fence->head);
#line 492
    fence->signaled = fence->signaled | 1U;
#line 493
    INIT_LIST_HEAD(& action_list);
#line 494
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 496
    vmw_fences_perform_actions(fman, & action_list);
#line 497
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {
#line 499
    goto ldv_39172;
  }
#line 489
  fence = next_fence;
#line 489
  __mptr___1 = (struct list_head  const  *)next_fence->head.next;
#line 489
  next_fence = (struct vmw_fence_obj *)__mptr___1 + 0xfffffffffffffff0UL;
  ldv_39174: ;
#line 489
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 490
    goto ldv_39173;
  } else {

  }
  ldv_39172: 
#line 502
  needs_rerun = vmw_fence_goal_new_locked(fman, seqno);
#line 504
  tmp___0 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 504
  if (tmp___0 == 0) {
#line 505
    schedule_work(& fman->work);
  } else {

  }
#line 506
  spin_unlock_irqrestore(& fman->lock, flags);
#line 514
  tmp___1 = ldv__builtin_expect((long )needs_rerun, 0L);
#line 514
  if (tmp___1 != 0L) {
#line 515
    new_seqno = ioread32((void *)fifo_mem + 6U);
#line 516
    if (new_seqno != seqno) {
#line 517
      seqno = new_seqno;
#line 518
      goto rerun;
    } else {

    }
  } else {

  }
#line 521
  return;
}
}
#line 523 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) 
{ 
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  uint32_t signaled ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 526
  fman = fence->fman;
#line 530
  tmp = spinlock_check(& fman->lock);
#line 530
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 531
  signaled = fence->signaled;
#line 532
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 534
  flags = fence->signal_mask & flags;
#line 535
  if ((signaled & flags) == flags) {
#line 536
    return (1);
  } else {

  }
#line 538
  if ((signaled & 1U) == 0U) {
#line 539
    vmw_fences_update(fman);
  } else {

  }
#line 541
  tmp___0 = spinlock_check(& fman->lock);
#line 541
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 542
  signaled = fence->signaled;
#line 543
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 545
  return ((signaled & flags) == flags);
}
}
#line 548 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) 
{ 
  struct vmw_private *dev_priv ;
  long ret ;
  bool tmp ;
  long tmp___0 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 552
  dev_priv = (fence->fman)->dev_priv;
#line 555
  tmp = vmw_fence_obj_signaled(fence, flags);
#line 555
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 555
  if (tmp___0 != 0L) {
#line 556
    return (0);
  } else {

  }
#line 558
  vmw_fifo_ping_host(dev_priv, 1U);
#line 559
  vmw_seqno_waiter_add(dev_priv);
#line 561
  if ((int )interruptible) {
#line 562
    __ret = (long )timeout;
#line 562
    tmp___5 = vmw_fence_obj_signaled(fence, flags);
#line 562
    if (tmp___5) {
#line 562
      tmp___6 = 0;
    } else {
#line 562
      tmp___6 = 1;
    }
#line 562
    if (tmp___6) {
#line 562
      tmp___1 = get_current();
#line 562
      __wait.flags = 0U;
#line 562
      __wait.private = (void *)tmp___1;
#line 562
      __wait.func = & autoremove_wake_function;
#line 562
      __wait.task_list.next = & __wait.task_list;
#line 562
      __wait.task_list.prev = & __wait.task_list;
      ldv_39201: 
#line 562
      prepare_to_wait(& fence->queue, & __wait, 1);
#line 562
      tmp___2 = vmw_fence_obj_signaled(fence, flags);
#line 562
      if ((int )tmp___2) {
#line 562
        goto ldv_39199;
      } else {

      }
#line 562
      tmp___3 = get_current();
#line 562
      tmp___4 = signal_pending(tmp___3);
#line 562
      if (tmp___4 == 0) {
#line 562
        __ret = schedule_timeout(__ret);
#line 562
        if (__ret == 0L) {
#line 562
          goto ldv_39199;
        } else {

        }
#line 562
        goto ldv_39200;
      } else {

      }
#line 562
      __ret = -512L;
#line 562
      goto ldv_39199;
      ldv_39200: ;
#line 562
      goto ldv_39201;
      ldv_39199: 
#line 562
      finish_wait(& fence->queue, & __wait);
    } else {

    }
#line 562
    ret = __ret;
  } else {
#line 567
    __ret___0 = (long )timeout;
#line 567
    tmp___9 = vmw_fence_obj_signaled(fence, flags);
#line 567
    if (tmp___9) {
#line 567
      tmp___10 = 0;
    } else {
#line 567
      tmp___10 = 1;
    }
#line 567
    if (tmp___10) {
#line 567
      tmp___7 = get_current();
#line 567
      __wait___0.flags = 0U;
#line 567
      __wait___0.private = (void *)tmp___7;
#line 567
      __wait___0.func = & autoremove_wake_function;
#line 567
      __wait___0.task_list.next = & __wait___0.task_list;
#line 567
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_39206: 
#line 567
      prepare_to_wait(& fence->queue, & __wait___0, 2);
#line 567
      tmp___8 = vmw_fence_obj_signaled(fence, flags);
#line 567
      if ((int )tmp___8) {
#line 567
        goto ldv_39205;
      } else {

      }
#line 567
      __ret___0 = schedule_timeout(__ret___0);
#line 567
      if (__ret___0 == 0L) {
#line 567
        goto ldv_39205;
      } else {

      }
#line 567
      goto ldv_39206;
      ldv_39205: 
#line 567
      finish_wait(& fence->queue, & __wait___0);
    } else {

    }
#line 567
    ret = __ret___0;
  }
#line 572
  vmw_seqno_waiter_remove(dev_priv);
#line 574
  tmp___12 = ldv__builtin_expect(ret == 0L, 0L);
#line 574
  if (tmp___12 != 0L) {
#line 575
    ret = -16L;
  } else {
#line 576
    tmp___11 = ldv__builtin_expect(ret > 0L, 1L);
#line 576
    if (tmp___11 != 0L) {
#line 577
      ret = 0L;
    } else {

    }
  }
#line 579
  return ((int )ret);
}
}
#line 582 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_private *dev_priv ;

  {
#line 584
  dev_priv = (fence->fman)->dev_priv;
#line 586
  vmw_fifo_ping_host(dev_priv, 1U);
#line 587
  return;
}
}
#line 589 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_destroy(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 591
  fman = fence->fman;
#line 593
  kfree((void const   *)fence);
#line 597
  tmp = vmw_mem_glob(fman->dev_priv);
#line 597
  ttm_mem_global_free(tmp, (uint64_t )fman->fence_size);
#line 599
  return;
}
}
#line 601 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) 
{ 
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp ;
  struct vmw_fence_obj *fence ;
  int ret ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 606
  tmp = vmw_mem_glob(fman->dev_priv);
#line 606
  mem_glob = tmp;
#line 610
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->fence_size, 0, 0);
#line 612
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 612
  if (tmp___0 != 0L) {
#line 613
    return (ret);
  } else {

  }
#line 615
  tmp___1 = kzalloc(152UL, 208U);
#line 615
  fence = (struct vmw_fence_obj *)tmp___1;
#line 616
  tmp___2 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 616
  if (tmp___2 != 0L) {
#line 617
    ret = -12;
#line 618
    goto out_no_object;
  } else {

  }
#line 621
  ret = vmw_fence_obj_init(fman, fence, seqno, mask, & vmw_fence_destroy);
#line 623
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 623
  if (tmp___3 != 0L) {
#line 624
    goto out_err_init;
  } else {

  }
#line 626
  *p_fence = fence;
#line 627
  return (0);
  out_err_init: 
#line 630
  kfree((void const   *)fence);
  out_no_object: 
#line 632
  ttm_mem_global_free(mem_glob, (uint64_t )fman->fence_size);
#line 633
  return (ret);
}
}
#line 637 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_destroy(struct vmw_fence_obj *fence ) 
{ 
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 640
  __mptr = (struct vmw_fence_obj  const  *)fence;
#line 640
  ufence = (struct vmw_user_fence *)__mptr + 0xffffffffffffffc0UL;
#line 641
  fman = fence->fman;
#line 643
  kfree((void const   *)ufence);
#line 647
  tmp = vmw_mem_glob(fman->dev_priv);
#line 647
  ttm_mem_global_free(tmp, (uint64_t )fman->user_fence_size);
#line 649
  return;
}
}
#line 651 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_base_release(struct ttm_base_object **p_base ) 
{ 
  struct ttm_base_object *base ;
  struct vmw_user_fence *ufence ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_fence_obj *fence ;

  {
#line 653
  base = *p_base;
#line 655
  __mptr = (struct ttm_base_object  const  *)base;
#line 655
  ufence = (struct vmw_user_fence *)__mptr;
#line 656
  fence = & ufence->fence;
#line 658
  *p_base = 0;
#line 659
  vmw_fence_obj_unreference(& fence);
#line 660
  return;
}
}
#line 662 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) 
{ 
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *tmp___0 ;
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___1 ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 669
  tmp = vmw_fpriv(file_priv);
#line 669
  tfile = tmp->tfile;
#line 672
  tmp___1 = vmw_mem_glob(fman->dev_priv);
#line 672
  mem_glob = tmp___1;
#line 680
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->user_fence_size, 0, 0);
#line 682
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 682
  if (tmp___2 != 0L) {
#line 683
    return (ret);
  } else {

  }
#line 685
  tmp___3 = kzalloc(216UL, 208U);
#line 685
  ufence = (struct vmw_user_fence *)tmp___3;
#line 686
  tmp___4 = ldv__builtin_expect((unsigned long )ufence == (unsigned long )((struct vmw_user_fence *)0),
                             0L);
#line 686
  if (tmp___4 != 0L) {
#line 687
    ret = -12;
#line 688
    goto out_no_object;
  } else {

  }
#line 691
  ret = vmw_fence_obj_init(fman, & ufence->fence, seqno, mask, & vmw_user_fence_destroy);
#line 693
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 693
  if (tmp___5 != 0L) {
#line 694
    kfree((void const   *)ufence);
#line 695
    goto out_no_object;
  } else {

  }
#line 702
  tmp___0 = vmw_fence_obj_reference(& ufence->fence);
#line 703
  ret = ttm_base_object_init(tfile, & ufence->base, 0, ttm_driver_type3, & vmw_user_fence_base_release,
                             0);
#line 708
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 708
  if (tmp___6 != 0L) {
#line 712
    vmw_fence_obj_unreference(& tmp___0);
#line 713
    goto out_err;
  } else {

  }
#line 716
  *p_fence = & ufence->fence;
#line 717
  *p_handle = (uint32_t )ufence->base.hash.key;
#line 719
  return (0);
  out_err: 
#line 721
  tmp___0 = & ufence->fence;
#line 722
  vmw_fence_obj_unreference(& tmp___0);
  out_no_object: 
#line 724
  ttm_mem_global_free(mem_glob, (uint64_t )fman->user_fence_size);
#line 725
  return (ret);
}
}
#line 733 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  struct list_head action_list ;
  int ret ;
  raw_spinlock_t *tmp ;
  struct vmw_fence_obj *fence ;
  struct list_head  const  *__mptr ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 744
  tmp = spinlock_check(& fman->lock);
#line 744
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 745
  fman->fifo_down = 1;
#line 746
  goto ldv_39271;
  ldv_39270: 
#line 748
  __mptr = (struct list_head  const  *)fman->fence_list.prev;
#line 748
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 750
  kref_get(& fence->kref);
#line 751
  spin_unlock_irq(& fman->lock);
#line 753
  ret = vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
#line 757
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 757
  if (tmp___0 != 0L) {
#line 758
    list_del_init(& fence->head);
#line 759
    fence->signaled = fence->signaled | 1U;
#line 760
    INIT_LIST_HEAD(& action_list);
#line 761
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 763
    vmw_fences_perform_actions(fman, & action_list);
#line 764
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {

  }
#line 767
  spin_lock_irq(& fman->lock);
#line 769
  tmp___1 = list_empty((struct list_head  const  *)(& fence->head));
#line 769
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 769
  if (tmp___2 != 0L) {
#line 769
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (769), "i" (12UL));
    ldv_39269: ;
#line 769
    goto ldv_39269;
  } else {

  }
#line 770
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
  ldv_39271: 
#line 746
  tmp___3 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 746
  if (tmp___3 == 0) {
#line 747
    goto ldv_39270;
  } else {

  }
#line 772
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 773
  return;
}
}
#line 775 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 779
  tmp = spinlock_check(& fman->lock);
#line 779
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 780
  fman->fifo_down = 0;
#line 781
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 782
  return;
}
}
#line 785 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_wait_arg *arg ;
  unsigned long timeout ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int ret ;
  uint64_t wait_timeout ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 788
  arg = (struct drm_vmw_fence_wait_arg *)data;
#line 793
  tmp = vmw_fpriv(file_priv);
#line 793
  tfile = tmp->tfile;
#line 795
  wait_timeout = arg->timeout_us * 250ULL;
#line 802
  wait_timeout = ((wait_timeout >> 20) + (wait_timeout >> 24)) - (wait_timeout >> 26);
#line 805
  if (arg->cookie_valid == 0) {
#line 806
    arg->cookie_valid = 1;
#line 807
    arg->kernel_cookie = (unsigned long long )jiffies + wait_timeout;
  } else {

  }
#line 810
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 811
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 811
  if (tmp___0 != 0L) {
#line 812
    printk("<3>Wait invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 815
    return (-22);
  } else {

  }
#line 818
  __mptr = (struct ttm_base_object  const  *)base;
#line 818
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 820
  timeout = jiffies;
#line 821
  if ((1 != 0 && 1 != 0) && (long )timeout - (long )arg->kernel_cookie >= 0L) {
#line 822
    tmp___1 = vmw_fence_obj_signaled(fence, (uint32_t )arg->flags);
#line 822
    ret = (int )tmp___1 ? 0 : -16;
#line 824
    goto out;
  } else {

  }
#line 827
  timeout = (unsigned long )arg->kernel_cookie - timeout;
#line 829
  ret = vmw_fence_obj_wait(fence, (uint32_t )arg->flags, arg->lazy != 0, 1, timeout);
  out: 
#line 832
  ttm_base_object_unref(& base);
#line 838
  if (ret == 0 && arg->wait_options & 1) {
#line 839
    tmp___2 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->handle, TTM_REF_USAGE);
#line 839
    return (tmp___2);
  } else {

  }
#line 841
  return (ret);
}
}
#line 844 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_signaled_arg *arg ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___2 ;

  {
#line 847
  arg = (struct drm_vmw_fence_signaled_arg *)data;
#line 852
  tmp = vmw_fpriv(file_priv);
#line 852
  tfile = tmp->tfile;
#line 853
  tmp___0 = vmw_priv(dev);
#line 853
  dev_priv = tmp___0;
#line 855
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 856
  tmp___1 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 856
  if (tmp___1 != 0L) {
#line 857
    printk("<3>Fence signaled invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 860
    return (-22);
  } else {

  }
#line 863
  __mptr = (struct ttm_base_object  const  *)base;
#line 863
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 864
  fman = fence->fman;
#line 866
  tmp___2 = vmw_fence_obj_signaled(fence, arg->flags);
#line 866
  arg->signaled = (int32_t )tmp___2;
#line 867
  spin_lock_irq(& fman->lock);
#line 869
  arg->signaled_flags = fence->signaled;
#line 870
  arg->passed_seqno = dev_priv->last_read_seqno;
#line 871
  spin_unlock_irq(& fman->lock);
#line 873
  ttm_base_object_unref(& base);
#line 875
  return (0);
}
}
#line 879 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct drm_vmw_fence_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 882
  arg = (struct drm_vmw_fence_arg *)data;
#line 885
  tmp = vmw_fpriv(file_priv);
#line 885
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, TTM_REF_USAGE);
#line 885
  return (tmp___0);
}
}
#line 903 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct drm_pending_event *event ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;

  {
  ldv_39333: 
#line 911
  tmp = spinlock_check(& fman->lock);
#line 911
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 912
  tmp___0 = list_empty((struct list_head  const  *)event_list);
#line 912
  if (tmp___0 != 0) {
#line 913
    goto out_unlock;
  } else {

  }
#line 914
  __mptr = (struct list_head  const  *)event_list->next;
#line 914
  eaction = (struct vmw_event_fence_action *)__mptr + 0xffffffffffffffd8UL;
#line 917
  list_del_init(& eaction->fpriv_head);
#line 918
  event = eaction->event;
#line 919
  eaction->event = 0;
#line 920
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 921
  (*(event->destroy))(event);
#line 922
  goto ldv_39333;
  out_unlock: 
#line 924
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 925
  return;
}
}
#line 939 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_seq_passed(struct vmw_fence_action *action ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct drm_device *dev ;
  struct drm_pending_event *event ;
  struct drm_file *file_priv ;
  unsigned long irq_flags ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  struct timeval tv ;
  long tmp___1 ;

  {
#line 942
  __mptr = (struct vmw_fence_action  const  *)action;
#line 942
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 943
  dev = eaction->dev;
#line 944
  event = eaction->event;
#line 948
  tmp = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct drm_pending_event *)0),
                         0L);
#line 948
  if (tmp != 0L) {
#line 949
    return;
  } else {

  }
#line 951
  file_priv = event->file_priv;
#line 952
  tmp___0 = spinlock_check(& dev->event_lock);
#line 952
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 954
  tmp___1 = ldv__builtin_expect((unsigned long )eaction->tv_sec != (unsigned long )((uint32_t *)0),
                             1L);
#line 954
  if (tmp___1 != 0L) {
#line 957
    do_gettimeofday(& tv);
#line 958
    *(eaction->tv_sec) = (uint32_t )tv.tv_sec;
#line 959
    *(eaction->tv_usec) = (uint32_t )tv.tv_usec;
  } else {

  }
#line 962
  list_del_init(& eaction->fpriv_head);
#line 963
  list_add_tail(& (eaction->event)->link, & file_priv->event_list);
#line 964
  eaction->event = 0;
#line 965
  __wake_up(& file_priv->event_wait, 3U, 0, 0);
#line 966
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 967
  return;
}
}
#line 978 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_cleanup(struct vmw_fence_action *action ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 981
  __mptr = (struct vmw_fence_action  const  *)action;
#line 981
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 982
  fman = (eaction->fence)->fman;
#line 985
  tmp = spinlock_check(& fman->lock);
#line 985
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 986
  list_del(& eaction->fpriv_head);
#line 987
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 989
  vmw_fence_obj_unreference(& eaction->fence);
#line 990
  kfree((void const   *)eaction);
#line 991
  return;
}
}
#line 1003 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_add_action(struct vmw_fence_obj *fence , struct vmw_fence_action *action ) 
{ 
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  bool run_update ;
  raw_spinlock_t *tmp ;
  struct list_head action_list ;

  {
#line 1006
  fman = fence->fman;
#line 1008
  run_update = 0;
#line 1010
  ldv_mutex_lock_547(& fman->goal_irq_mutex);
#line 1011
  tmp = spinlock_check(& fman->lock);
#line 1011
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1013
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] + (uint32_t )1;
#line 1014
  if ((int )fence->signaled & 1) {
#line 1017
    INIT_LIST_HEAD(& action_list);
#line 1018
    list_add_tail(& action->head, & action_list);
#line 1019
    vmw_fences_perform_actions(fman, & action_list);
  } else {
#line 1021
    list_add_tail(& action->head, & fence->seq_passed_actions);
#line 1027
    run_update = vmw_fence_goal_check_locked(fence);
  }
#line 1030
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1032
  if ((int )run_update) {
#line 1033
    if (! fman->goal_irq_on) {
#line 1034
      fman->goal_irq_on = 1;
#line 1035
      vmw_goal_waiter_add(fman->dev_priv);
    } else {

    }
#line 1037
    vmw_fences_update(fman);
  } else {

  }
#line 1039
  ldv_mutex_unlock_548(& fman->goal_irq_mutex);
#line 1040
  return;
}
}
#line 1058 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) 
{ 
  struct vmw_event_fence_action *eaction ;
  struct vmw_fence_manager *fman ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  unsigned long irq_flags ;
  void *tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 1066
  fman = fence->fman;
#line 1067
  tmp = vmw_fpriv(file_priv);
#line 1067
  vmw_fp = tmp;
#line 1070
  tmp___0 = kzalloc(96UL, 208U);
#line 1070
  eaction = (struct vmw_event_fence_action *)tmp___0;
#line 1071
  tmp___1 = ldv__builtin_expect((unsigned long )eaction == (unsigned long )((struct vmw_event_fence_action *)0),
                             0L);
#line 1071
  if (tmp___1 != 0L) {
#line 1072
    return (-12);
  } else {

  }
#line 1074
  eaction->event = event;
#line 1076
  eaction->action.seq_passed = & vmw_event_fence_action_seq_passed;
#line 1077
  eaction->action.cleanup = & vmw_event_fence_action_cleanup;
#line 1078
  eaction->action.type = VMW_ACTION_EVENT;
#line 1080
  eaction->fence = vmw_fence_obj_reference(fence);
#line 1081
  eaction->dev = (fman->dev_priv)->dev;
#line 1082
  eaction->tv_sec = tv_sec;
#line 1083
  eaction->tv_usec = tv_usec;
#line 1085
  tmp___2 = spinlock_check(& fman->lock);
#line 1085
  irq_flags = _raw_spin_lock_irqsave(tmp___2);
#line 1086
  list_add_tail(& eaction->fpriv_head, & vmw_fp->fence_events);
#line 1087
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1089
  vmw_fence_obj_add_action(fence, & eaction->action);
#line 1091
  return (0);
}
}
#line 1099 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_create(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                  uint32_t flags , uint64_t user_data , bool interruptible ) 
{ 
  struct vmw_event_fence_pending *event ;
  struct drm_device *dev ;
  unsigned long irq_flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  raw_spinlock_t *tmp___4 ;

  {
#line 1106
  dev = ((fence->fman)->dev_priv)->dev;
#line 1110
  tmp = spinlock_check(& dev->event_lock);
#line 1110
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1112
  ret = (unsigned int )file_priv->event_space <= 23U ? -16 : 0;
#line 1113
  tmp___0 = ldv__builtin_expect(ret == 0, 1L);
#line 1113
  if (tmp___0 != 0L) {
#line 1114
    file_priv->event_space = (int )((unsigned int )file_priv->event_space - 24U);
  } else {

  }
#line 1116
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 1118
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1118
  if (tmp___1 != 0L) {
#line 1119
    drm_err("vmw_event_fence_action_create", "Failed to allocate event space for this file.\n");
#line 1120
    goto out_no_space;
  } else {

  }
#line 1124
  tmp___2 = kzalloc(24UL, 208U);
#line 1124
  event = (struct vmw_event_fence_pending *)tmp___2;
#line 1125
  tmp___3 = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct vmw_event_fence_pending *)0),
                             0L);
#line 1125
  if (tmp___3 != 0L) {
#line 1126
    drm_err("vmw_event_fence_action_create", "Failed to allocate an event.\n");
#line 1127
    ret = -12;
#line 1128
    goto out_no_event;
  } else {

  }
#line 1131
  event->event.base.type = 2147483648U;
#line 1132
  event->event.base.length = 72U;
#line 1133
  event->event.user_data = user_data;
#line 1135
  event->base.event = & event->event.base;
#line 1136
  event->base.file_priv = file_priv;
#line 1137
  event->base.destroy = (void (*)(struct drm_pending_event * ))(& kfree);
#line 1140
  if ((int )flags & 1) {
#line 1141
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                       & event->event.tv_usec, (int )interruptible);
  } else {
#line 1147
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, 0, 0, (int )interruptible);
  }
#line 1152
  if (ret != 0) {

  } else {

  }
#line 1156
  (*(event->base.destroy))(& event->base);
  out_no_event: 
#line 1158
  tmp___4 = spinlock_check(& dev->event_lock);
#line 1158
  irq_flags = _raw_spin_lock_irqsave(tmp___4);
#line 1159
  file_priv->event_space = (int )((unsigned int )file_priv->event_space + 72U);
#line 1160
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
  out_no_space: ;
#line 1162
  return (ret);
}
}
#line 1165 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_fence_event_arg *arg ;
  struct vmw_fence_obj *fence ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  uint32_t handle ;
  int ret ;
  struct ttm_base_object *base ;
  struct ttm_base_object *tmp___1 ;
  long tmp___2 ;
  struct ttm_base_object  const  *__mptr ;
  bool existed ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  struct vmw_fpriv *tmp___7 ;

  {
#line 1168
  tmp = vmw_priv(dev);
#line 1168
  dev_priv = tmp;
#line 1169
  arg = (struct drm_vmw_fence_event_arg *)data;
#line 1171
  fence = 0;
#line 1172
  tmp___0 = vmw_fpriv(file_priv);
#line 1172
  vmw_fp = tmp___0;
#line 1173
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 1184
  if (arg->handle != 0U) {
#line 1185
    tmp___1 = ttm_base_object_lookup(vmw_fp->tfile, arg->handle);
#line 1185
    base = tmp___1;
#line 1188
    tmp___2 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                               0L);
#line 1188
    if (tmp___2 != 0L) {
#line 1189
      drm_err("vmw_fence_event_ioctl", "Fence event invalid fence object handle 0x%08lx.\n",
              (unsigned long )arg->handle);
#line 1192
      return (-22);
    } else {

    }
#line 1194
    __mptr = (struct ttm_base_object  const  *)base;
#line 1194
    fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 1196
    vmw_fence_obj_reference(fence);
#line 1198
    if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1201
      ret = ttm_ref_object_add(vmw_fp->tfile, base, TTM_REF_USAGE, & existed);
#line 1203
      tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1203
      if (tmp___3 != 0L) {
#line 1204
        drm_err("vmw_fence_event_ioctl", "Failed to reference a fence object.\n");
#line 1206
        goto out_no_ref_obj;
      } else {

      }
#line 1208
      handle = (uint32_t )base->hash.key;
    } else {

    }
#line 1210
    ttm_base_object_unref(& base);
  } else {

  }
#line 1216
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1217
    ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, (unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0) ? & handle : 0);
#line 1221
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1221
    if (tmp___4 != 0L) {
#line 1222
      drm_err("vmw_fence_event_ioctl", "Fence event failed to create fence.\n");
#line 1223
      return (ret);
    } else {

    }
  } else {

  }
#line 1227
  tmp___5 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 1227
  if (tmp___5 != 0L) {
#line 1227
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (1227), "i" (12UL));
    ldv_39428: ;
#line 1227
    goto ldv_39428;
  } else {

  }
#line 1229
  if ((int )arg->flags & 1) {
#line 1230
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  } else {
#line 1235
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  }
#line 1240
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 1240
  if (tmp___6 != 0L) {
#line 1241
    if (ret != -512) {
#line 1242
      drm_err("vmw_fence_event_ioctl", "Failed to attach event to fence.\n");
    } else {

    }
#line 1243
    goto out_no_create;
  } else {

  }
#line 1246
  vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, fence, handle);
#line 1248
  vmw_fence_obj_unreference(& fence);
#line 1249
  return (0);
  out_no_create: ;
#line 1251
  if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1252
    tmp___7 = vmw_fpriv(file_priv);
#line 1252
    ttm_ref_object_base_unref(tmp___7->tfile, (unsigned long )handle, TTM_REF_USAGE);
  } else {

  }
  out_no_ref_obj: 
#line 1255
  vmw_fence_obj_unreference(& fence);
#line 1256
  return (ret);
}
}
#line 1259 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_533(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1264
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1266
  mutex_lock(ldv_func_arg1);
#line 1267
  return;
}
}
#line 1269 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int ldv_mutex_trylock_534(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1274
  tmp = mutex_trylock(ldv_func_arg1);
#line 1274
  ldv_func_res = tmp;
#line 1276
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1276
  return (tmp___0);
#line 1278
  return (ldv_func_res);
}
}
#line 1281 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_535(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1286
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1288
  mutex_unlock(ldv_func_arg1);
#line 1289
  return;
}
}
#line 1291 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1296
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1298
  mutex_lock(ldv_func_arg1);
#line 1299
  return;
}
}
#line 1301 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1306
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1308
  mutex_unlock(ldv_func_arg1);
#line 1309
  return;
}
}
#line 1311 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_538(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1316
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 1318
  mutex_lock(ldv_func_arg1);
#line 1319
  return;
}
}
#line 1321 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_539(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1326
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 1328
  mutex_unlock(ldv_func_arg1);
#line 1329
  return;
}
}
#line 1331 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1336
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1338
  mutex_unlock(ldv_func_arg1);
#line 1339
  return;
}
}
#line 1341 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1346
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 1348
  mutex_lock(ldv_func_arg1);
#line 1349
  return;
}
}
#line 1351 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_542(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1356
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1358
  mutex_unlock(ldv_func_arg1);
#line 1359
  return;
}
}
#line 1361 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_543(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1366
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1368
  mutex_lock(ldv_func_arg1);
#line 1369
  return;
}
}
#line 1371 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_544(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1376
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1378
  mutex_unlock(ldv_func_arg1);
#line 1379
  return;
}
}
#line 1381 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_545(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1386
  ldv_mutex_lock_goal_irq_mutex(ldv_func_arg1);
#line 1388
  mutex_lock(ldv_func_arg1);
#line 1389
  return;
}
}
#line 1391 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1396
  ldv_mutex_unlock_goal_irq_mutex(ldv_func_arg1);
#line 1398
  mutex_unlock(ldv_func_arg1);
#line 1399
  return;
}
}
#line 1401 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_547(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1406
  ldv_mutex_lock_goal_irq_mutex(ldv_func_arg1);
#line 1408
  mutex_lock(ldv_func_arg1);
#line 1409
  return;
}
}
#line 1411 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1416
  ldv_mutex_unlock_goal_irq_mutex(ldv_func_arg1);
#line 1418
  mutex_unlock(ldv_func_arg1);
#line 1419
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_566(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_567(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_569(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_572(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_574(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_565(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_568(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_570(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_573(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_575(struct mutex *ldv_func_arg1 ) ;
#line 448 "/work/vladimir/UFO/Work/test/inst/current/envs/linux-3.5/linux-3.5/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) ;
#line 153 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 158
  vmaster = dev_priv->active_master;
#line 159
  bo = & buf->base;
#line 162
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 163
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 163
  if (tmp != 0L) {
#line 164
    return (ret);
  } else {

  }
#line 166
  vmw_execbuf_release_pinned_bo(dev_priv, 0, 0U);
#line 168
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 169
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 169
  if (tmp___0 != 0L) {
#line 170
    goto err;
  } else {

  }
#line 172
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0, 0);
#line 174
  ttm_bo_unreserve(bo);
  err: 
#line 177
  ttm_write_unlock(& vmaster->lock);
#line 178
  return (ret);
}
}
#line 197 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement *placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 201
  vmaster = dev_priv->active_master;
#line 202
  bo = & buf->base;
#line 206
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 207
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 207
  if (tmp != 0L) {
#line 208
    return (ret);
  } else {

  }
#line 210
  if ((int )pin) {
#line 211
    vmw_execbuf_release_pinned_bo(dev_priv, 0, 0U);
  } else {

  }
#line 213
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 214
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 214
  if (tmp___0 != 0L) {
#line 215
    goto err;
  } else {

  }
#line 224
  if ((int )pin) {
#line 225
    placement = & vmw_vram_gmr_ne_placement;
  } else {
#line 227
    placement = & vmw_vram_gmr_placement;
  }
#line 229
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0, 0);
#line 230
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 230
  if (tmp___1 != 0L || ret == -512) {
#line 231
    goto err_unreserve;
  } else {

  }
#line 239
  if ((int )pin) {
#line 240
    placement = & vmw_vram_ne_placement;
  } else {
#line 242
    placement = & vmw_vram_placement;
  }
#line 244
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0, 0);
  err_unreserve: 
#line 247
  ttm_bo_unreserve(bo);
  err: 
#line 249
  ttm_write_unlock(& vmaster->lock);
#line 250
  return (ret);
}
}
#line 268 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) 
{ 
  struct ttm_placement *placement ;
  int tmp ;

  {
#line 274
  if ((int )pin) {
#line 275
    placement = & vmw_vram_ne_placement;
  } else {
#line 277
    placement = & vmw_vram_placement;
  }
#line 279
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, placement, (int )interruptible);
#line 279
  return (tmp);
}
}
#line 300 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) 
{ 
  struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 304
  vmaster = dev_priv->active_master;
#line 305
  bo = & buf->base;
#line 307
  ret = 0;
#line 309
  if ((int )pin) {
#line 310
    placement = vmw_vram_ne_placement;
  } else {
#line 312
    placement = vmw_vram_placement;
  }
#line 313
  placement.lpfn = (unsigned int )bo->num_pages;
#line 315
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 316
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 316
  if (tmp != 0L) {
#line 317
    return (ret);
  } else {

  }
#line 319
  if ((int )pin) {
#line 320
    vmw_execbuf_release_pinned_bo(dev_priv, 0, 0U);
  } else {

  }
#line 322
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 323
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 323
  if (tmp___0 != 0L) {
#line 324
    goto err_unlock;
  } else {

  }
#line 327
  if ((bo->mem.mem_type == 2U && bo->mem.start < bo->num_pages) && bo->mem.start != 0UL) {
#line 330
    ttm_bo_validate(bo, & vmw_sys_placement, 0, 0, 0);
  } else {

  }
#line 333
  ret = ttm_bo_validate(bo, & placement, (int )interruptible, 0, 0);
#line 336
  __ret_warn_on = ret == 0 && bo->offset != 0UL;
#line 336
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 336
  if (tmp___1 != 0L) {
#line 336
    warn_slowpath_null("/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared",
                       336);
  } else {

  }
#line 336
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 338
  ttm_bo_unreserve(bo);
  err_unlock: 
#line 340
  ttm_write_unlock(& vmaster->lock);
#line 342
  return (ret);
}
}
#line 360 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) 
{ 
  int tmp ;

  {
#line 369
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, & vmw_evictable_placement, (int )interruptible);
#line 369
  return (tmp);
}
}
#line 382 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) 
{ 


  {
#line 385
  if ((unsigned int )bo->mem.mem_type == 2U) {
#line 386
    ptr->gmrId = 4294967294U;
#line 387
    ptr->offset = (uint32 )bo->offset;
  } else {
#line 389
    ptr->gmrId = (uint32 )bo->mem.start;
#line 390
    ptr->offset = 0U;
  }
#line 392
  return;
}
}
#line 403 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) 
{ 
  uint32_t pl_flags ;
  struct ttm_placement placement ;
  uint32_t old_mem_type ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 407
  old_mem_type = bo->mem.mem_type;
#line 410
  tmp = atomic_read((atomic_t const   *)(& bo->reserved));
#line 410
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 410
  if (tmp___0 != 0L) {
#line 410
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                         "i" (410), "i" (12UL));
    ldv_39065: ;
#line 410
    goto ldv_39065;
  } else {

  }
#line 411
  tmp___1 = ldv__builtin_expect(old_mem_type != 2U, 0L);
#line 411
  if (tmp___1 != 0L) {
#line 411
    tmp___2 = ldv__builtin_expect(old_mem_type != 8U, 0L);
#line 411
    if (tmp___2 != 0L) {
#line 411
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (412), "i" (12UL));
      ldv_39066: ;
#line 411
      goto ldv_39066;
    } else {

    }
  } else {

  }
#line 414
  pl_flags = 65548U;
#line 415
  if ((int )pin) {
#line 416
    pl_flags = pl_flags | 2097152U;
  } else {

  }
#line 418
  memset((void *)(& placement), 0, 40UL);
#line 419
  placement.num_placement = 1U;
#line 420
  placement.placement = (uint32_t const   *)(& pl_flags);
#line 422
  ret = ttm_bo_validate(bo, & placement, 0, 1, 1);
#line 424
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 424
  if (tmp___3 != 0L) {
#line 424
    goto _L;
  } else {
#line 424
    tmp___4 = ldv__builtin_expect(bo->mem.mem_type != old_mem_type, 0L);
#line 424
    if (tmp___4 != 0L) {
      _L: /* CIL Label */ 
#line 424
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (424), "i" (12UL));
      ldv_39067: ;
#line 424
      goto ldv_39067;
    } else {

    }
  }
#line 426
  return;
}
}
#line 427 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_565(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 432
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 434
  mutex_lock(ldv_func_arg1);
#line 435
  return;
}
}
#line 437 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int ldv_mutex_trylock_566(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 442
  tmp = mutex_trylock(ldv_func_arg1);
#line 442
  ldv_func_res = tmp;
#line 444
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 444
  return (tmp___0);
#line 446
  return (ldv_func_res);
}
}
#line 449 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_567(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 454
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 456
  mutex_unlock(ldv_func_arg1);
#line 457
  return;
}
}
#line 459 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_568(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_569(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 474
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 476
  mutex_unlock(ldv_func_arg1);
#line 477
  return;
}
}
#line 479 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_570(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 484
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 486
  mutex_lock(ldv_func_arg1);
#line 487
  return;
}
}
#line 489 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 494
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 496
  mutex_unlock(ldv_func_arg1);
#line 497
  return;
}
}
#line 499 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_572(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 504
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 506
  mutex_unlock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_573(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 514
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 516
  mutex_lock(ldv_func_arg1);
#line 517
  return;
}
}
#line 519 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_574(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 524
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 526
  mutex_unlock(ldv_func_arg1);
#line 527
  return;
}
}
#line 529 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_575(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 536
  mutex_lock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 544
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 546
  mutex_unlock(ldv_func_arg1);
#line 547
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_590(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_593(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_600(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_589(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_594(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_599(struct mutex *ldv_func_arg1 ) ;
#line 161 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_destroy(struct vmw_screen_object_unit *sou ) 
{ 


  {
#line 163
  vmw_display_unit_cleanup(& sou->base);
#line 164
  kfree((void const   *)sou);
#line 165
  return;
}
}
#line 172 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_crtc_destroy(struct drm_crtc *crtc ) 
{ 
  struct drm_crtc  const  *__mptr ;

  {
#line 174
  __mptr = (struct drm_crtc  const  *)crtc;
#line 174
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr);
#line 176
  return;
}
}
#line 177 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_del_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ) 
{ 
  struct vmw_screen_object_display *ld ;

  {
#line 180
  ld = vmw_priv___0->sou_priv;
#line 182
  if ((int )sou->active_implicit) {
#line 183
    ld->num_implicit = ld->num_implicit - 1U;
#line 183
    if (ld->num_implicit == 0U) {
#line 184
      ld->implicit_fb = 0;
    } else {

    }
#line 185
    sou->active_implicit = 0;
  } else {

  }
#line 187
  return;
}
}
#line 189 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_add_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ,
                               struct vmw_framebuffer *vfb ) 
{ 
  struct vmw_screen_object_display *ld ;
  long tmp ;
  long tmp___0 ;

  {
#line 193
  ld = vmw_priv___0->sou_priv;
#line 195
  tmp = ldv__builtin_expect(ld->num_implicit == 0U, 0L);
#line 195
  if (tmp != 0L) {
#line 195
    tmp___0 = ldv__builtin_expect((unsigned long )ld->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 195
    if (tmp___0 != 0L) {
#line 195
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                           "i" (195), "i" (12UL));
      ldv_39262: ;
#line 195
      goto ldv_39262;
    } else {

    }
  } else {

  }
#line 197
  if (! sou->active_implicit && (int )sou->base.is_implicit) {
#line 198
    ld->implicit_fb = vfb;
#line 199
    sou->active_implicit = 1;
#line 200
    ld->num_implicit = ld->num_implicit + 1U;
  } else {

  }
#line 202
  return;
}
}
#line 207 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_create(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                               uint32_t x , uint32_t y , struct drm_display_mode *mode ) 
{ 
  size_t fifo_size ;
  struct __anonstruct_cmd_281 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 221
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 221
  if (tmp != 0L) {
#line 221
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (221), "i" (12UL));
    ldv_39277: ;
#line 221
    goto ldv_39277;
  } else {

  }
#line 223
  fifo_size = 48UL;
#line 224
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 224
  cmd = (struct __anonstruct_285___1 *)tmp___0;
#line 226
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_281 *)0),
                             0L);
#line 226
  if (tmp___1 != 0L) {
#line 227
    drm_err("vmw_sou_fifo_create", "Fifo reserve failed.\n");
#line 228
    return (-12);
  } else {

  }
#line 231
  memset((void *)cmd, 0, fifo_size);
#line 232
  cmd->header.cmdType = 34U;
#line 233
  cmd->obj.structSize = 44U;
#line 234
  cmd->obj.id = sou->base.unit;
#line 235
  cmd->obj.flags = sou->base.unit == 0U ? 3U : 1U;
#line 237
  cmd->obj.size.width = (uint32 )mode->hdisplay;
#line 238
  cmd->obj.size.height = (uint32 )mode->vdisplay;
#line 239
  if ((int )sou->base.is_implicit) {
#line 240
    cmd->obj.root.x = (int32 )x;
#line 241
    cmd->obj.root.y = (int32 )y;
  } else {
#line 243
    cmd->obj.root.x = sou->base.gui_x;
#line 244
    cmd->obj.root.y = sou->base.gui_y;
  }
#line 248
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& (sou->buffer)->base),
                       & cmd->obj.backingStore.ptr);
#line 249
  cmd->obj.backingStore.pitch = (uint32 )(mode->hdisplay * 4);
#line 251
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 253
  sou->defined = 1;
#line 255
  return (0);
}
}
#line 261 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_destroy(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ 
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_290 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 275
  tmp = ldv__builtin_expect((long )(! sou->defined), 0L);
#line 275
  if (tmp != 0L) {
#line 276
    return (0);
  } else {

  }
#line 278
  fifo_size = 8UL;
#line 279
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 279
  cmd = (struct __anonstruct_294 *)tmp___0;
#line 281
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_290 *)0),
                             0L);
#line 281
  if (tmp___1 != 0L) {
#line 282
    drm_err("vmw_sou_fifo_destroy", "Fifo reserve failed.\n");
#line 283
    return (-12);
  } else {

  }
#line 286
  memset((void *)cmd, 0, fifo_size);
#line 287
  cmd->header.cmdType = 35U;
#line 288
  cmd->body.screenId = sou->base.unit;
#line 290
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 293
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 750UL);
#line 294
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 294
  if (tmp___2 != 0L) {
#line 295
    drm_err("vmw_sou_fifo_destroy", "Failed to sync with HW");
  } else {
#line 297
    sou->defined = 0;
  }
#line 299
  return (ret);
}
}
#line 305 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_backing_free(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ 
  struct ttm_buffer_object *bo ;
  long tmp ;

  {
#line 310
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 310
  if (tmp != 0L) {
#line 311
    return;
  } else {

  }
#line 313
  bo = & (sou->buffer)->base;
#line 314
  ttm_bo_unref(& bo);
#line 315
  sou->buffer = 0;
#line 316
  sou->buffer_size = 0UL;
#line 317
  return;
}
}
#line 322 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_backing_alloc(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                                 unsigned long size ) 
{ 
  int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 328
  if (sou->buffer_size == size) {
#line 329
    return (0);
  } else {

  }
#line 331
  if ((unsigned long )sou->buffer != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 332
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 334
  tmp = kzalloc(472UL, 208U);
#line 334
  sou->buffer = (struct vmw_dma_buffer *)tmp;
#line 335
  tmp___0 = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 335
  if (tmp___0 != 0L) {
#line 336
    return (-12);
  } else {

  }
#line 341
  vmw_overlay_pause_all(dev_priv);
#line 342
  ret = vmw_dmabuf_init(dev_priv, sou->buffer, size, & vmw_vram_ne_placement, 0, & vmw_dmabuf_bo_free);
#line 345
  vmw_overlay_resume_all(dev_priv);
#line 347
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 347
  if (tmp___1 != 0L) {
#line 348
    sou->buffer = 0;
  } else {
#line 350
    sou->buffer_size = size;
  }
#line 352
  return (ret);
}
}
#line 355 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_crtc_set_config(struct drm_mode_set *set ) 
{ 
  struct vmw_private *dev_priv ;
  struct vmw_screen_object_unit *sou ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int ret ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  long tmp ;
  long tmp___0 ;
  size_t size ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 365
  ret = 0;
#line 367
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 368
    return (-22);
  } else {

  }
#line 370
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 371
    return (-22);
  } else {

  }
#line 374
  crtc = set->crtc;
#line 375
  __mptr = (struct drm_crtc  const  *)crtc;
#line 375
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 376
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 376
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 376
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 376
    vfb = 0;
  }
#line 377
  dev_priv = vmw_priv(crtc->dev);
#line 379
  if (set->num_connectors > 1UL) {
#line 380
    drm_err("vmw_sou_crtc_set_config", "to many connectors\n");
#line 381
    return (-22);
  } else {

  }
#line 384
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& sou->base.connector)) {
#line 386
    drm_err("vmw_sou_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & sou->base.connector);
#line 388
    return (-22);
  } else {

  }
#line 392
  if (((((int )sou->base.is_implicit && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0)) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) && ((dev_priv->sou_priv)->num_implicit != 1U || ! sou->active_implicit)) && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )vfb) {
#line 397
    drm_err("vmw_sou_crtc_set_config", "Multiple framebuffers not supported\n");
#line 398
    return (-22);
  } else {

  }
#line 402
  connector = & sou->base.connector;
#line 403
  encoder = & sou->base.encoder;
#line 406
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 407
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 409
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 409
    if (tmp != 0L) {
#line 410
      return (ret);
    } else {

    }
#line 412
    connector->encoder = 0;
#line 413
    encoder->crtc = 0;
#line 414
    crtc->fb = 0;
#line 415
    crtc->x = 0;
#line 416
    crtc->y = 0;
#line 418
    vmw_sou_del_active(dev_priv, sou);
#line 420
    vmw_sou_backing_free(dev_priv, sou);
#line 422
    return (0);
  } else {

  }
#line 427
  mode = set->mode;
#line 428
  fb = set->fb;
#line 430
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 432
    drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
#line 433
    return (-22);
  } else {

  }
#line 436
  vmw_fb_off(dev_priv);
#line 438
  if (mode->hdisplay != crtc->mode.hdisplay || mode->vdisplay != crtc->mode.vdisplay) {
#line 444
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 446
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 446
    if (tmp___0 != 0L) {
#line 447
      return (ret);
    } else {

    }
#line 449
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 452
  if ((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 454
    size = (size_t )((mode->hdisplay * mode->vdisplay) * 4);
#line 455
    ret = vmw_sou_backing_alloc(dev_priv, sou, size);
#line 456
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 456
    if (tmp___1 != 0L) {
#line 457
      return (ret);
    } else {

    }
  } else {

  }
#line 460
  ret = vmw_sou_fifo_create(dev_priv, sou, set->x, set->y, mode);
#line 461
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 461
  if (tmp___2 != 0L) {
#line 469
    if ((int )sou->defined) {
#line 470
      return (ret);
    } else {

    }
#line 472
    connector->encoder = 0;
#line 473
    encoder->crtc = 0;
#line 474
    crtc->fb = 0;
#line 475
    crtc->x = 0;
#line 476
    crtc->y = 0;
#line 478
    return (ret);
  } else {

  }
#line 481
  vmw_sou_add_active(dev_priv, sou, vfb);
#line 483
  connector->encoder = encoder;
#line 484
  encoder->crtc = crtc;
#line 485
  crtc->mode = *mode;
#line 486
  crtc->fb = fb;
#line 487
  crtc->x = (int )set->x;
#line 488
  crtc->y = (int )set->y;
#line 490
  return (0);
}
}
#line 493 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_crtc_funcs vmw_screen_object_crtc_funcs  = 
#line 493
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_sou_crtc_destroy, & vmw_sou_crtc_set_config, & vmw_du_page_flip,
    0};
#line 508 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_encoder_destroy(struct drm_encoder *encoder ) 
{ 
  struct drm_encoder  const  *__mptr ;

  {
#line 510
  __mptr = (struct drm_encoder  const  *)encoder;
#line 510
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffca0UL);
#line 512
  return;
}
}
#line 513 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_encoder_funcs vmw_screen_object_encoder_funcs  =    {0, & vmw_sou_encoder_destroy};
#line 521 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_connector_destroy(struct drm_connector *connector ) 
{ 
  struct drm_connector  const  *__mptr ;

  {
#line 523
  __mptr = (struct drm_connector  const  *)connector;
#line 523
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffc50UL);
#line 525
  return;
}
}
#line 526 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs___0  = 
#line 526
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_sou_connector_destroy, 0};
#line 536 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 539
  dev = dev_priv->dev;
#line 544
  tmp = kzalloc(2904UL, 208U);
#line 544
  sou = (struct vmw_screen_object_unit *)tmp;
#line 545
  if ((unsigned long )sou == (unsigned long )((struct vmw_screen_object_unit *)0)) {
#line 546
    return (-12);
  } else {

  }
#line 548
  sou->base.unit = unit;
#line 549
  crtc = & sou->base.crtc;
#line 550
  encoder = & sou->base.encoder;
#line 551
  connector = & sou->base.connector;
#line 553
  sou->active_implicit = 0;
#line 555
  sou->base.pref_active = unit == 0U;
#line 556
  sou->base.pref_width = dev_priv->initial_width;
#line 557
  sou->base.pref_height = dev_priv->initial_height;
#line 558
  sou->base.pref_mode = 0;
#line 559
  sou->base.is_implicit = 1;
#line 561
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs___0),
                     15);
#line 563
  connector->status = vmw_du_connector_detect(connector, 1);
#line 565
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_screen_object_encoder_funcs),
                   5);
#line 567
  drm_mode_connector_attach_encoder(connector, encoder);
#line 568
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 569
  encoder->possible_clones = 0U;
#line 571
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_screen_object_crtc_funcs));
#line 573
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 575
  drm_connector_attach_property(connector, dev->mode_config.dirty_info_property, 1ULL);
#line 579
  return (0);
}
}
#line 582 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 584
  dev = dev_priv->dev;
#line 587
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 588
    printk("<6>[drm] sou system already on\n");
#line 589
    return (-22);
  } else {

  }
#line 592
  if ((dev_priv->fifo.capabilities & 512U) == 0U) {
#line 593
    printk("<6>[drm] Not using screen objects, missing cap SCREEN_OBJECT_2\n");
#line 595
    return (-38);
  } else {

  }
#line 598
  ret = -12;
#line 599
  tmp = kmalloc(16UL, 208U);
#line 599
  dev_priv->sou_priv = (struct vmw_screen_object_display *)tmp;
#line 600
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 600
  if (tmp___0 != 0L) {
#line 601
    goto err_no_mem;
  } else {

  }
#line 603
  (dev_priv->sou_priv)->num_implicit = 0U;
#line 604
  (dev_priv->sou_priv)->implicit_fb = 0;
#line 606
  ret = drm_vblank_init(dev, 8);
#line 607
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 607
  if (tmp___1 != 0L) {
#line 608
    goto err_free;
  } else {

  }
#line 610
  ret = drm_mode_create_dirty_info_property(dev);
#line 611
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 611
  if (tmp___2 != 0L) {
#line 612
    goto err_vblank_cleanup;
  } else {

  }
#line 614
  i = 0;
#line 614
  goto ldv_39353;
  ldv_39352: 
#line 615
  vmw_sou_init(dev_priv, (unsigned int )i);
#line 614
  i = i + 1;
  ldv_39353: ;
#line 614
  if (i <= 7) {
#line 615
    goto ldv_39352;
  } else {

  }
#line 617
  printk("<6>[drm] Screen objects system initialized\n");
#line 619
  return (0);
  err_vblank_cleanup: 
#line 622
  drm_vblank_cleanup(dev);
  err_free: 
#line 624
  kfree((void const   *)dev_priv->sou_priv);
#line 625
  dev_priv->sou_priv = 0;
  err_no_mem: ;
#line 627
  return (ret);
}
}
#line 630 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) 
{ 
  struct drm_device *dev ;

  {
#line 632
  dev = dev_priv->dev;
#line 634
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 635
    return (-38);
  } else {

  }
#line 637
  drm_vblank_cleanup(dev);
#line 639
  kfree((void const   *)dev_priv->sou_priv);
#line 641
  return (0);
}
}
#line 648 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;

  {
#line 651
  __mptr = (struct drm_crtc  const  *)crtc;
#line 651
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 653
  if (! sou->base.is_implicit) {
#line 654
    return (1);
  } else {

  }
#line 656
  if ((dev_priv->sou_priv)->num_implicit != 1U) {
#line 657
    return (0);
  } else {

  }
#line 659
  return (1);
}
}
#line 666 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ 
  struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;
  long tmp ;
  struct drm_framebuffer  const  *__mptr___0 ;

  {
#line 669
  __mptr = (struct drm_crtc  const  *)crtc;
#line 669
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 671
  tmp = ldv__builtin_expect((long )(! sou->base.is_implicit), 0L);
#line 671
  if (tmp != 0L) {
#line 671
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (671), "i" (12UL));
    ldv_39373: ;
#line 671
    goto ldv_39373;
  } else {

  }
#line 674
  __mptr___0 = (struct drm_framebuffer  const  *)sou->base.crtc.fb;
#line 674
  (dev_priv->sou_priv)->implicit_fb = (struct vmw_framebuffer *)__mptr___0;
#line 676
  return;
}
}
#line 714 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_main17_sequence_infinite_withcheck_stateful(void) 
{ 
  struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp ;
  int tmp___0 ;

  {
#line 776
  LDV_IN_INTERRUPT = 1;
#line 785
  ldv_initialize();
#line 793
  goto ldv_39403;
  ldv_39402: 
#line 796
  tmp = __VERIFIER_nondet_int();
#line 796
  switch (tmp) {
  case 0: 
#line 813
  ldv_handler_precall();
#line 814
  vmw_sou_crtc_destroy(var_group1);
#line 821
  goto ldv_39397;
  case 1: 
#line 837
  ldv_handler_precall();
#line 838
  vmw_sou_crtc_set_config(var_group2);
#line 845
  goto ldv_39397;
  case 2: 
#line 861
  ldv_handler_precall();
#line 862
  vmw_sou_encoder_destroy(var_group3);
#line 869
  goto ldv_39397;
  case 3: 
#line 885
  ldv_handler_precall();
#line 886
  vmw_sou_connector_destroy(var_group4);
#line 893
  goto ldv_39397;
  default: ;
#line 894
  goto ldv_39397;
  }
  ldv_39397: ;
  ldv_39403: 
#line 793
  tmp___0 = __VERIFIER_nondet_int();
#line 793
  if (tmp___0 != 0) {
#line 794
    goto ldv_39402;
  } else {

  }


#line 903
  ldv_check_final_state();
#line 906
  return;
}
}
#line 910 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_589(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 915
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 917
  mutex_lock(ldv_func_arg1);
#line 918
  return;
}
}
#line 920 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldv_mutex_trylock_590(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 925
  tmp = mutex_trylock(ldv_func_arg1);
#line 925
  ldv_func_res = tmp;
#line 927
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 927
  return (tmp___0);
#line 929
  return (ldv_func_res);
}
}
#line 932 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 937
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 939
  mutex_unlock(ldv_func_arg1);
#line 940
  return;
}
}
#line 942 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 947
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 949
  mutex_lock(ldv_func_arg1);
#line 950
  return;
}
}
#line 952 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_593(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 957
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 959
  mutex_unlock(ldv_func_arg1);
#line 960
  return;
}
}
#line 962 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_594(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 967
  ldv_mutex_lock_update_lock(ldv_func_arg1);
#line 969
  mutex_lock(ldv_func_arg1);
#line 970
  return;
}
}
#line 972 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 977
  ldv_mutex_unlock_update_lock(ldv_func_arg1);
#line 979
  mutex_unlock(ldv_func_arg1);
#line 980
  return;
}
}
#line 982 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 987
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 989
  mutex_unlock(ldv_func_arg1);
#line 990
  return;
}
}
#line 992 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 997
  ldv_mutex_lock_struct_mutex(ldv_func_arg1);
#line 999
  mutex_lock(ldv_func_arg1);
#line 1000
  return;
}
}
#line 1002 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_598(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1007
  ldv_mutex_unlock_struct_mutex(ldv_func_arg1);
#line 1009
  mutex_unlock(ldv_func_arg1);
#line 1010
  return;
}
}
#line 1012 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_599(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1017
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1019
  mutex_lock(ldv_func_arg1);
#line 1020
  return;
}
}
#line 1022 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_600(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1027
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1029
  mutex_unlock(ldv_func_arg1);
#line 1030
  return;
}
}
#line 10 "/work/vladimir/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/work/vladimir/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/work/vladimir/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cmdbuf_mutex  ;
#line 11 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_cmdbuf_mutex = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_cmdbuf_mutex = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cmdbuf_mutex(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_cmdbuf_mutex = 2;
#line 69
  return;
}
}
#line 72 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_cmdbuf_mutex = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cmdbuf_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_cmdbuf_mutex = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cmdbuf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_cmdbuf_mutex == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cmdbuf_mutex(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_cmdbuf_mutex == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_cmdbuf_mutex = 1;
#line 158
  return;
}
}
#line 160 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex  ;
#line 163 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cred_guard_mutex = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cred_guard_mutex = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cred_guard_mutex = 2;
#line 221
  return;
}
}
#line 224 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cred_guard_mutex = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cred_guard_mutex = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_cred_guard_mutex == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_cred_guard_mutex == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cred_guard_mutex = 1;
#line 310
  return;
}
}
#line 312 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fb_surf_mutex  ;
#line 315 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 320
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_fb_surf_mutex = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 346
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_fb_surf_mutex = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fb_surf_mutex(struct mutex *lock ) 
{ 


  {
#line 370
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_fb_surf_mutex = 2;
#line 373
  return;
}
}
#line 376 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fb_surf_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_fb_surf_mutex = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fb_surf_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_fb_surf_mutex = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fb_surf_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 431
  if (ldv_mutex_fb_surf_mutex == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fb_surf_mutex(struct mutex *lock ) 
{ 


  {
#line 459
  if (ldv_mutex_fb_surf_mutex == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_fb_surf_mutex = 1;
#line 462
  return;
}
}
#line 464 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fifo_mutex  ;
#line 467 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 472
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_fifo_mutex = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 498
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_fifo_mutex = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fifo_mutex(struct mutex *lock ) 
{ 


  {
#line 522
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_fifo_mutex = 2;
#line 525
  return;
}
}
#line 528 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fifo_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_fifo_mutex = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fifo_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_fifo_mutex = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fifo_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 583
  if (ldv_mutex_fifo_mutex == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fifo_mutex(struct mutex *lock ) 
{ 


  {
#line 611
  if (ldv_mutex_fifo_mutex == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_fifo_mutex = 1;
#line 614
  return;
}
}
#line 616 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_goal_irq_mutex  ;
#line 619 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 624
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_goal_irq_mutex = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 650
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_goal_irq_mutex = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_goal_irq_mutex(struct mutex *lock ) 
{ 


  {
#line 674
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_goal_irq_mutex = 2;
#line 677
  return;
}
}
#line 680 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_goal_irq_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_goal_irq_mutex = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_goal_irq_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_goal_irq_mutex = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_goal_irq_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 735
  if (ldv_mutex_goal_irq_mutex == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_goal_irq_mutex(struct mutex *lock ) 
{ 


  {
#line 763
  if (ldv_mutex_goal_irq_mutex == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_goal_irq_mutex = 1;
#line 766
  return;
}
}
#line 768 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_hw_mutex  ;
#line 771 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 776
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_hw_mutex = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 802
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_hw_mutex = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_hw_mutex(struct mutex *lock ) 
{ 


  {
#line 826
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_hw_mutex = 2;
#line 829
  return;
}
}
#line 832 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_hw_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_hw_mutex = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_hw_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_hw_mutex = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_hw_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 887
  if (ldv_mutex_hw_mutex == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_hw_mutex(struct mutex *lock ) 
{ 


  {
#line 915
  if (ldv_mutex_hw_mutex == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_hw_mutex = 1;
#line 918
  return;
}
}
#line 920 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 923 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 928
  if (ldv_mutex_lock == 1) {

  } else {
#line 928
    ldv_error();
  }
#line 931
  nondetermined = __VERIFIER_nondet_int();
#line 934
  if (nondetermined) {
#line 937
    ldv_mutex_lock = 2;
#line 939
    return (0);
  } else {
#line 944
    return (-4);
  }
}
}
#line 949 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 954
  if (ldv_mutex_lock == 1) {

  } else {
#line 954
    ldv_error();
  }
#line 957
  nondetermined = __VERIFIER_nondet_int();
#line 960
  if (nondetermined) {
#line 963
    ldv_mutex_lock = 2;
#line 965
    return (0);
  } else {
#line 970
    return (-4);
  }
}
}
#line 975 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 978
  if (ldv_mutex_lock == 1) {

  } else {
#line 978
    ldv_error();
  }
#line 980
  ldv_mutex_lock = 2;
#line 981
  return;
}
}
#line 984 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 989
  if (ldv_mutex_lock == 1) {

  } else {
#line 989
    ldv_error();
  }
#line 992
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 995
  if (is_mutex_held_by_another_thread) {
#line 998
    return (0);
  } else {
#line 1003
    ldv_mutex_lock = 2;
#line 1005
    return (1);
  }
}
}
#line 1010 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1015
  if (ldv_mutex_lock == 1) {

  } else {
#line 1015
    ldv_error();
  }
#line 1018
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1021
  if (atomic_value_after_dec == 0) {
#line 1024
    ldv_mutex_lock = 2;
#line 1026
    return (1);
  } else {

  }
#line 1030
  return (0);
}
}
#line 1035 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1039
  if (ldv_mutex_lock == 1) {
#line 1042
    nondetermined = __VERIFIER_nondet_int();
#line 1045
    if (nondetermined) {
#line 1048
      return (0);
    } else {
#line 1053
      return (1);
    }
  } else {
#line 1059
    return (1);
  }
}
}
#line 1064 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 1067
  if (ldv_mutex_lock == 2) {

  } else {
#line 1067
    ldv_error();
  }
#line 1069
  ldv_mutex_lock = 1;
#line 1070
  return;
}
}
#line 1072 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex  ;
#line 1075 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1080
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1080
    ldv_error();
  }
#line 1083
  nondetermined = __VERIFIER_nondet_int();
#line 1086
  if (nondetermined) {
#line 1089
    ldv_mutex_mutex = 2;
#line 1091
    return (0);
  } else {
#line 1096
    return (-4);
  }
}
}
#line 1101 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1106
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1106
    ldv_error();
  }
#line 1109
  nondetermined = __VERIFIER_nondet_int();
#line 1112
  if (nondetermined) {
#line 1115
    ldv_mutex_mutex = 2;
#line 1117
    return (0);
  } else {
#line 1122
    return (-4);
  }
}
}
#line 1127 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex(struct mutex *lock ) 
{ 


  {
#line 1130
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1130
    ldv_error();
  }
#line 1132
  ldv_mutex_mutex = 2;
#line 1133
  return;
}
}
#line 1136 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1141
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1141
    ldv_error();
  }
#line 1144
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1147
  if (is_mutex_held_by_another_thread) {
#line 1150
    return (0);
  } else {
#line 1155
    ldv_mutex_mutex = 2;
#line 1157
    return (1);
  }
}
}
#line 1162 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1167
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1167
    ldv_error();
  }
#line 1170
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1173
  if (atomic_value_after_dec == 0) {
#line 1176
    ldv_mutex_mutex = 2;
#line 1178
    return (1);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1187 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1191
  if (ldv_mutex_mutex == 1) {
#line 1194
    nondetermined = __VERIFIER_nondet_int();
#line 1197
    if (nondetermined) {
#line 1200
      return (0);
    } else {
#line 1205
      return (1);
    }
  } else {
#line 1211
    return (1);
  }
}
}
#line 1216 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex(struct mutex *lock ) 
{ 


  {
#line 1219
  if (ldv_mutex_mutex == 2) {

  } else {
#line 1219
    ldv_error();
  }
#line 1221
  ldv_mutex_mutex = 1;
#line 1222
  return;
}
}
#line 1224 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_pm_mutex  ;
#line 1227 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1232
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1232
    ldv_error();
  }
#line 1235
  nondetermined = __VERIFIER_nondet_int();
#line 1238
  if (nondetermined) {
#line 1241
    ldv_mutex_pm_mutex = 2;
#line 1243
    return (0);
  } else {
#line 1248
    return (-4);
  }
}
}
#line 1253 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1258
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1258
    ldv_error();
  }
#line 1261
  nondetermined = __VERIFIER_nondet_int();
#line 1264
  if (nondetermined) {
#line 1267
    ldv_mutex_pm_mutex = 2;
#line 1269
    return (0);
  } else {
#line 1274
    return (-4);
  }
}
}
#line 1279 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) 
{ 


  {
#line 1282
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1282
    ldv_error();
  }
#line 1284
  ldv_mutex_pm_mutex = 2;
#line 1285
  return;
}
}
#line 1288 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_pm_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1293
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1293
    ldv_error();
  }
#line 1296
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1299
  if (is_mutex_held_by_another_thread) {
#line 1302
    return (0);
  } else {
#line 1307
    ldv_mutex_pm_mutex = 2;
#line 1309
    return (1);
  }
}
}
#line 1314 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_pm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1319
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1319
    ldv_error();
  }
#line 1322
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1325
  if (atomic_value_after_dec == 0) {
#line 1328
    ldv_mutex_pm_mutex = 2;
#line 1330
    return (1);
  } else {

  }
#line 1334
  return (0);
}
}
#line 1339 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_pm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1343
  if (ldv_mutex_pm_mutex == 1) {
#line 1346
    nondetermined = __VERIFIER_nondet_int();
#line 1349
    if (nondetermined) {
#line 1352
      return (0);
    } else {
#line 1357
      return (1);
    }
  } else {
#line 1363
    return (1);
  }
}
}
#line 1368 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) 
{ 


  {
#line 1371
  if (ldv_mutex_pm_mutex == 2) {

  } else {
#line 1371
    ldv_error();
  }
#line 1373
  ldv_mutex_pm_mutex = 1;
#line 1374
  return;
}
}
#line 1376 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_release_mutex  ;
#line 1379 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1384
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1384
    ldv_error();
  }
#line 1387
  nondetermined = __VERIFIER_nondet_int();
#line 1390
  if (nondetermined) {
#line 1393
    ldv_mutex_release_mutex = 2;
#line 1395
    return (0);
  } else {
#line 1400
    return (-4);
  }
}
}
#line 1405 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1410
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1410
    ldv_error();
  }
#line 1413
  nondetermined = __VERIFIER_nondet_int();
#line 1416
  if (nondetermined) {
#line 1419
    ldv_mutex_release_mutex = 2;
#line 1421
    return (0);
  } else {
#line 1426
    return (-4);
  }
}
}
#line 1431 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_release_mutex(struct mutex *lock ) 
{ 


  {
#line 1434
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1434
    ldv_error();
  }
#line 1436
  ldv_mutex_release_mutex = 2;
#line 1437
  return;
}
}
#line 1440 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_release_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1445
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1445
    ldv_error();
  }
#line 1448
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1451
  if (is_mutex_held_by_another_thread) {
#line 1454
    return (0);
  } else {
#line 1459
    ldv_mutex_release_mutex = 2;
#line 1461
    return (1);
  }
}
}
#line 1466 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_release_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1471
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1471
    ldv_error();
  }
#line 1474
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1477
  if (atomic_value_after_dec == 0) {
#line 1480
    ldv_mutex_release_mutex = 2;
#line 1482
    return (1);
  } else {

  }
#line 1486
  return (0);
}
}
#line 1491 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_release_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1495
  if (ldv_mutex_release_mutex == 1) {
#line 1498
    nondetermined = __VERIFIER_nondet_int();
#line 1501
    if (nondetermined) {
#line 1504
      return (0);
    } else {
#line 1509
      return (1);
    }
  } else {
#line 1515
    return (1);
  }
}
}
#line 1520 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_release_mutex(struct mutex *lock ) 
{ 


  {
#line 1523
  if (ldv_mutex_release_mutex == 2) {

  } else {
#line 1523
    ldv_error();
  }
#line 1525
  ldv_mutex_release_mutex = 1;
#line 1526
  return;
}
}
#line 1528 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_struct_mutex  ;
#line 1531 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1536
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1536
    ldv_error();
  }
#line 1539
  nondetermined = __VERIFIER_nondet_int();
#line 1542
  if (nondetermined) {
#line 1545
    ldv_mutex_struct_mutex = 2;
#line 1547
    return (0);
  } else {
#line 1552
    return (-4);
  }
}
}
#line 1557 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1562
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1562
    ldv_error();
  }
#line 1565
  nondetermined = __VERIFIER_nondet_int();
#line 1568
  if (nondetermined) {
#line 1571
    ldv_mutex_struct_mutex = 2;
#line 1573
    return (0);
  } else {
#line 1578
    return (-4);
  }
}
}
#line 1583 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_struct_mutex(struct mutex *lock ) 
{ 


  {
#line 1586
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1586
    ldv_error();
  }
#line 1588
  ldv_mutex_struct_mutex = 2;
#line 1589
  return;
}
}
#line 1592 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_struct_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1597
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1597
    ldv_error();
  }
#line 1600
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1603
  if (is_mutex_held_by_another_thread) {
#line 1606
    return (0);
  } else {
#line 1611
    ldv_mutex_struct_mutex = 2;
#line 1613
    return (1);
  }
}
}
#line 1618 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_struct_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1623
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1623
    ldv_error();
  }
#line 1626
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1629
  if (atomic_value_after_dec == 0) {
#line 1632
    ldv_mutex_struct_mutex = 2;
#line 1634
    return (1);
  } else {

  }
#line 1638
  return (0);
}
}
#line 1643 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_struct_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1647
  if (ldv_mutex_struct_mutex == 1) {
#line 1650
    nondetermined = __VERIFIER_nondet_int();
#line 1653
    if (nondetermined) {
#line 1656
      return (0);
    } else {
#line 1661
      return (1);
    }
  } else {
#line 1667
    return (1);
  }
}
}
#line 1672 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_struct_mutex(struct mutex *lock ) 
{ 


  {
#line 1675
  if (ldv_mutex_struct_mutex == 2) {

  } else {
#line 1675
    ldv_error();
  }
#line 1677
  ldv_mutex_struct_mutex = 1;
#line 1678
  return;
}
}
#line 1680 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_update_lock  ;
#line 1683 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1688
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1688
    ldv_error();
  }
#line 1691
  nondetermined = __VERIFIER_nondet_int();
#line 1694
  if (nondetermined) {
#line 1697
    ldv_mutex_update_lock = 2;
#line 1699
    return (0);
  } else {
#line 1704
    return (-4);
  }
}
}
#line 1709 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1714
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1714
    ldv_error();
  }
#line 1717
  nondetermined = __VERIFIER_nondet_int();
#line 1720
  if (nondetermined) {
#line 1723
    ldv_mutex_update_lock = 2;
#line 1725
    return (0);
  } else {
#line 1730
    return (-4);
  }
}
}
#line 1735 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_update_lock(struct mutex *lock ) 
{ 


  {
#line 1738
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1738
    ldv_error();
  }
#line 1740
  ldv_mutex_update_lock = 2;
#line 1741
  return;
}
}
#line 1744 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_update_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1749
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1749
    ldv_error();
  }
#line 1752
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1755
  if (is_mutex_held_by_another_thread) {
#line 1758
    return (0);
  } else {
#line 1763
    ldv_mutex_update_lock = 2;
#line 1765
    return (1);
  }
}
}
#line 1770 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_update_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1775
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1775
    ldv_error();
  }
#line 1778
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1781
  if (atomic_value_after_dec == 0) {
#line 1784
    ldv_mutex_update_lock = 2;
#line 1786
    return (1);
  } else {

  }
#line 1790
  return (0);
}
}
#line 1795 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_update_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1799
  if (ldv_mutex_update_lock == 1) {
#line 1802
    nondetermined = __VERIFIER_nondet_int();
#line 1805
    if (nondetermined) {
#line 1808
      return (0);
    } else {
#line 1813
      return (1);
    }
  } else {
#line 1819
    return (1);
  }
}
}
#line 1824 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_update_lock(struct mutex *lock ) 
{ 


  {
#line 1827
  if (ldv_mutex_update_lock == 2) {

  } else {
#line 1827
    ldv_error();
  }
#line 1829
  ldv_mutex_update_lock = 1;
#line 1830
  return;
}
}
#line 1834 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 1837
  ldv_mutex_cmdbuf_mutex = 1;
#line 1839
  ldv_mutex_cred_guard_mutex = 1;
#line 1841
  ldv_mutex_fb_surf_mutex = 1;
#line 1843
  ldv_mutex_fifo_mutex = 1;
#line 1845
  ldv_mutex_goal_irq_mutex = 1;
#line 1847
  ldv_mutex_hw_mutex = 1;
#line 1849
  ldv_mutex_lock = 1;
#line 1851
  ldv_mutex_mutex = 1;
#line 1853
  ldv_mutex_pm_mutex = 1;
#line 1855
  ldv_mutex_release_mutex = 1;
#line 1857
  ldv_mutex_struct_mutex = 1;
#line 1859
  ldv_mutex_update_lock = 1;
#line 1860
  return;
}
}
#line 1863 "/work/vladimir/UFO/Work/test/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--defaultlinux-3.5--X--32_7a--X--ufo/linux-3.5/csd_deg_dscv/29/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 1866
  if (ldv_mutex_cmdbuf_mutex == 1) {

  } else {
#line 1866
    ldv_error();
  }
#line 1868
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 1868
    ldv_error();
  }
#line 1870
  if (ldv_mutex_fb_surf_mutex == 1) {

  } else {
#line 1870
    ldv_error();
  }
#line 1872
  if (ldv_mutex_fifo_mutex == 1) {

  } else {
#line 1872
    ldv_error();
  }
#line 1874
  if (ldv_mutex_goal_irq_mutex == 1) {

  } else {
#line 1874
    ldv_error();
  }
#line 1876
  if (ldv_mutex_hw_mutex == 1) {

  } else {
#line 1876
    ldv_error();
  }
#line 1878
  if (ldv_mutex_lock == 1) {

  } else {
#line 1878
    ldv_error();
  }
#line 1880
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1880
    ldv_error();
  }
#line 1882
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1882
    ldv_error();
  }
#line 1884
  if (ldv_mutex_release_mutex == 1) {

  } else {
#line 1884
    ldv_error();
  }
#line 1886
  if (ldv_mutex_struct_mutex == 1) {

  } else {
#line 1886
    ldv_error();
  }
#line 1888
  if (ldv_mutex_update_lock == 1) {

  } else {
#line 1888
    ldv_error();
  }
#line 1889
  return;
}
}
