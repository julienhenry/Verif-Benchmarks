/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_nlink_t;
#line 31 "include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 44 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 52 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 53 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 75 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 76 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 90 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 91 "include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 92 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 93 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 94 "include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 95 "include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 27 "include/linux/types.h"
typedef unsigned short umode_t;
#line 28 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 29 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 30 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 35 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 38 "include/linux/types.h"
typedef _Bool bool;
#line 40 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 41 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 54 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 63 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 68 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 78 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 111 "include/linux/types.h"
typedef __s32 int32_t;
#line 115 "include/linux/types.h"
typedef __u8 uint8_t;
#line 116 "include/linux/types.h"
typedef __u16 uint16_t;
#line 117 "include/linux/types.h"
typedef __u32 uint32_t;
#line 120 "include/linux/types.h"
typedef __u64 uint64_t;
#line 142 "include/linux/types.h"
typedef unsigned long sector_t;
#line 143 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 180 "include/linux/types.h"
typedef __u32 __le32;
#line 202 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 203 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 206 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 211 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 219 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int counter ;
};
#line 219 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 224 "include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long counter ;
};
#line 224 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
#line 229 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 233
struct hlist_node;
#line 233 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 237 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 253 "include/linux/types.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 40 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint32_t uint32;
#line 42 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef int32_t int32;
#line 287 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestPtr {
   uint32 gmrId ;
   uint32 offset ;
};
#line 287 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestPtr SVGAGuestPtr;
#line 314 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct____missing_field_name_11 {
   uint32 bitsPerPixel : 8 ;
   uint32 colorDepth : 8 ;
   uint32 reserved : 16 ;
};
#line 314 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
union __anonunion____missing_field_name_10 {
   struct __anonstruct____missing_field_name_11 __annonCompField4 ;
   uint32 value ;
};
#line 314 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGMRImageFormat {
   union __anonunion____missing_field_name_10 __annonCompField5 ;
};
#line 314 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGMRImageFormat SVGAGMRImageFormat;
#line 385 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedRect {
   int32 left ;
   int32 top ;
   int32 right ;
   int32 bottom ;
};
#line 385 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedRect SVGASignedRect;
#line 393 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedPoint {
   int32 x ;
   int32 y ;
};
#line 393 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedPoint SVGASignedPoint;
#line 1060 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdUpdate {
   uint32 x ;
   uint32 y ;
   uint32 width ;
   uint32 height ;
};
#line 1060 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdUpdate SVGAFifoCmdUpdate;
#line 1326 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMRFB_22 {
   SVGAGuestPtr ptr ;
   uint32 bytesPerLine ;
   SVGAGMRImageFormat format ;
};
#line 1326 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMRFB_22 SVGAFifoCmdDefineGMRFB;
#line 1363 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_23 {
   SVGASignedPoint srcOrigin ;
   SVGASignedRect destRect ;
   uint32 destScreenId ;
};
#line 1363 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_23 SVGAFifoCmdBlitGMRFBToScreen;
#line 613 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum __anonenum_SVGA3dRenderTargetType_54 {
    SVGA3D_RT_DEPTH = 0,
    SVGA3D_RT_STENCIL = 1,
    SVGA3D_RT_COLOR0 = 2,
    SVGA3D_RT_COLOR1 = 3,
    SVGA3D_RT_COLOR2 = 4,
    SVGA3D_RT_COLOR3 = 5,
    SVGA3D_RT_COLOR4 = 6,
    SVGA3D_RT_COLOR5 = 7,
    SVGA3D_RT_COLOR6 = 8,
    SVGA3D_RT_COLOR7 = 9,
    SVGA3D_RT_MAX = 10,
    SVGA3D_RT_INVALID = 4294967295U
} ;
#line 613 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dRenderTargetType_54 SVGA3dRenderTargetType;
#line 661
enum __anonenum_SVGA3dTextureStateName_59 {
    SVGA3D_TS_INVALID = 0,
    SVGA3D_TS_BIND_TEXTURE = 1,
    SVGA3D_TS_COLOROP = 2,
    SVGA3D_TS_COLORARG1 = 3,
    SVGA3D_TS_COLORARG2 = 4,
    SVGA3D_TS_ALPHAOP = 5,
    SVGA3D_TS_ALPHAARG1 = 6,
    SVGA3D_TS_ALPHAARG2 = 7,
    SVGA3D_TS_ADDRESSU = 8,
    SVGA3D_TS_ADDRESSV = 9,
    SVGA3D_TS_MIPFILTER = 10,
    SVGA3D_TS_MAGFILTER = 11,
    SVGA3D_TS_MINFILTER = 12,
    SVGA3D_TS_BORDERCOLOR = 13,
    SVGA3D_TS_TEXCOORDINDEX = 14,
    SVGA3D_TS_TEXTURETRANSFORMFLAGS = 15,
    SVGA3D_TS_TEXCOORDGEN = 16,
    SVGA3D_TS_BUMPENVMAT00 = 17,
    SVGA3D_TS_BUMPENVMAT01 = 18,
    SVGA3D_TS_BUMPENVMAT10 = 19,
    SVGA3D_TS_BUMPENVMAT11 = 20,
    SVGA3D_TS_TEXTURE_MIPMAP_LEVEL = 21,
    SVGA3D_TS_TEXTURE_LOD_BIAS = 22,
    SVGA3D_TS_TEXTURE_ANISOTROPIC_LEVEL = 23,
    SVGA3D_TS_ADDRESSW = 24,
    SVGA3D_TS_GAMMA = 25,
    SVGA3D_TS_BUMPENVLSCALE = 26,
    SVGA3D_TS_BUMPENVLOFFSET = 27,
    SVGA3D_TS_COLORARG0 = 28,
    SVGA3D_TS_ALPHAARG0 = 29,
    SVGA3D_TS_MAX = 30
} ;
#line 661 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dTextureStateName_59 SVGA3dTextureStateName;
#line 827
enum __anonenum_SVGA3dDeclUsage_67 {
    SVGA3D_DECLUSAGE_POSITION = 0,
    SVGA3D_DECLUSAGE_BLENDWEIGHT = 1,
    SVGA3D_DECLUSAGE_BLENDINDICES = 2,
    SVGA3D_DECLUSAGE_NORMAL = 3,
    SVGA3D_DECLUSAGE_PSIZE = 4,
    SVGA3D_DECLUSAGE_TEXCOORD = 5,
    SVGA3D_DECLUSAGE_TANGENT = 6,
    SVGA3D_DECLUSAGE_BINORMAL = 7,
    SVGA3D_DECLUSAGE_TESSFACTOR = 8,
    SVGA3D_DECLUSAGE_POSITIONT = 9,
    SVGA3D_DECLUSAGE_COLOR = 10,
    SVGA3D_DECLUSAGE_FOG = 11,
    SVGA3D_DECLUSAGE_DEPTH = 12,
    SVGA3D_DECLUSAGE_SAMPLE = 13,
    SVGA3D_DECLUSAGE_MAX = 14
} ;
#line 827 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dDeclUsage_67 SVGA3dDeclUsage;
#line 845
enum __anonenum_SVGA3dDeclMethod_68 {
    SVGA3D_DECLMETHOD_DEFAULT = 0,
    SVGA3D_DECLMETHOD_PARTIALU = 1,
    SVGA3D_DECLMETHOD_PARTIALV = 2,
    SVGA3D_DECLMETHOD_CROSSUV = 3,
    SVGA3D_DECLMETHOD_UV = 4,
    SVGA3D_DECLMETHOD_LOOKUP = 5,
    SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED = 6
} ;
#line 845 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dDeclMethod_68 SVGA3dDeclMethod;
#line 855
enum __anonenum_SVGA3dDeclType_69 {
    SVGA3D_DECLTYPE_FLOAT1 = 0,
    SVGA3D_DECLTYPE_FLOAT2 = 1,
    SVGA3D_DECLTYPE_FLOAT3 = 2,
    SVGA3D_DECLTYPE_FLOAT4 = 3,
    SVGA3D_DECLTYPE_D3DCOLOR = 4,
    SVGA3D_DECLTYPE_UBYTE4 = 5,
    SVGA3D_DECLTYPE_SHORT2 = 6,
    SVGA3D_DECLTYPE_SHORT4 = 7,
    SVGA3D_DECLTYPE_UBYTE4N = 8,
    SVGA3D_DECLTYPE_SHORT2N = 9,
    SVGA3D_DECLTYPE_SHORT4N = 10,
    SVGA3D_DECLTYPE_USHORT2N = 11,
    SVGA3D_DECLTYPE_USHORT4N = 12,
    SVGA3D_DECLTYPE_UDEC3 = 13,
    SVGA3D_DECLTYPE_DEC3N = 14,
    SVGA3D_DECLTYPE_FLOAT16_2 = 15,
    SVGA3D_DECLTYPE_FLOAT16_4 = 16,
    SVGA3D_DECLTYPE_MAX = 17
} ;
#line 855 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dDeclType_69 SVGA3dDeclType;
#line 904
enum __anonenum_SVGA3dPrimitiveType_72 {
    SVGA3D_PRIMITIVE_INVALID = 0,
    SVGA3D_PRIMITIVE_TRIANGLELIST = 1,
    SVGA3D_PRIMITIVE_POINTLIST = 2,
    SVGA3D_PRIMITIVE_LINELIST = 3,
    SVGA3D_PRIMITIVE_LINESTRIP = 4,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP = 5,
    SVGA3D_PRIMITIVE_TRIANGLEFAN = 6,
    SVGA3D_PRIMITIVE_MAX = 7
} ;
#line 904 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dPrimitiveType_72 SVGA3dPrimitiveType;
#line 973
enum __anonenum_SVGA3dStretchBltMode_79 {
    SVGA3D_STRETCH_BLT_POINT = 0,
    SVGA3D_STRETCH_BLT_LINEAR = 1,
    SVGA3D_STRETCH_BLT_MAX = 2
} ;
#line 973 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dStretchBltMode_79 SVGA3dStretchBltMode;
#line 979
enum __anonenum_SVGA3dQueryType_80 {
    SVGA3D_QUERYTYPE_OCCLUSION = 0,
    SVGA3D_QUERYTYPE_MAX = 1
} ;
#line 979 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dQueryType_80 SVGA3dQueryType;
#line 991
enum __anonenum_SVGA3dTransferType_82 {
    SVGA3D_WRITE_HOST_VRAM = 1,
    SVGA3D_READ_HOST_VRAM = 2
} ;
#line 991 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dTransferType_82 SVGA3dTransferType;
#line 1083 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dSurfaceImageId {
   uint32 sid ;
   uint32 face ;
   uint32 mipmap ;
};
#line 1083 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dSurfaceImageId SVGA3dSurfaceImageId;
#line 1090 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 1090 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dGuestImage SVGA3dGuestImage;
#line 1120 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdHeader_86 {
   uint32 id ;
   uint32 size ;
};
#line 1120 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdHeader_86 SVGA3dCmdHeader;
#line 1261 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dBox_97 {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
};
#line 1261 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dBox_97 SVGA3dBox;
#line 1296 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdPresent_100 {
   uint32 sid ;
};
#line 1296 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdPresent_100 SVGA3dCmdPresent;
#line 1317 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetRenderTarget_104 {
   uint32 cid ;
   SVGA3dRenderTargetType type ;
   SVGA3dSurfaceImageId target ;
};
#line 1317 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetRenderTarget_104 SVGA3dCmdSetRenderTarget;
#line 1324 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceCopy_105 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
};
#line 1324 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceCopy_105 SVGA3dCmdSurfaceCopy;
#line 1331 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_106 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
   SVGA3dBox boxSrc ;
   SVGA3dBox boxDest ;
   SVGA3dStretchBltMode mode ;
};
#line 1331 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_106 SVGA3dCmdSurfaceStretchBlt;
#line 1362 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMA_108 {
   SVGA3dGuestImage guest ;
   SVGA3dSurfaceImageId host ;
   SVGA3dTransferType transfer ;
};
#line 1362 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMA_108 SVGA3dCmdSurfaceDMA;
#line 1431 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArrayRangeHint_110 {
   uint32 first ;
   uint32 last ;
};
#line 1431 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArrayRangeHint_110 SVGA3dArrayRangeHint;
#line 1446 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArray_111 {
   uint32 surfaceId ;
   uint32 offset ;
   uint32 stride ;
};
#line 1446 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArray_111 SVGA3dArray;
#line 1464 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexArrayIdentity_112 {
   SVGA3dDeclType type ;
   SVGA3dDeclMethod method ;
   SVGA3dDeclUsage usage ;
   uint32 usageIndex ;
};
#line 1464 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexArrayIdentity_112 SVGA3dVertexArrayIdentity;
#line 1478 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexDecl_113 {
   SVGA3dVertexArrayIdentity identity ;
   SVGA3dArray array ;
   SVGA3dArrayRangeHint rangeHint ;
};
#line 1478 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexDecl_113 SVGA3dVertexDecl;
#line 1485 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dPrimitiveRange_114 {
   SVGA3dPrimitiveType primType ;
   uint32 primitiveCount ;
   SVGA3dArray indexArray ;
   uint32 indexWidth ;
   int32 indexBias ;
};
#line 1485 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dPrimitiveRange_114 SVGA3dPrimitiveRange;
#line 1535 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDrawPrimitives_115 {
   uint32 cid ;
   uint32 numVertexDecls ;
   uint32 numRanges ;
};
#line 1535 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDrawPrimitives_115 SVGA3dCmdDrawPrimitives;
#line 1555 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion____missing_field_name_117 {
   uint32 value ;
   float floatValue ;
};
#line 1555 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dTextureState_116 {
   uint32 stage ;
   SVGA3dTextureStateName name ;
   union __anonunion____missing_field_name_117 __annonCompField16 ;
};
#line 1555 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dTextureState_116 SVGA3dTextureState;
#line 1565 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetTextureState_118 {
   uint32 cid ;
};
#line 1565 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetTextureState_118 SVGA3dCmdSetTextureState;
#line 1676 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdEndQuery_134 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1676 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdEndQuery_134 SVGA3dCmdEndQuery;
#line 1683 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdWaitForQuery_135 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1683 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdWaitForQuery_135 SVGA3dCmdWaitForQuery;
#line 1736 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_138 {
   SVGA3dSurfaceImageId srcImage ;
   SVGASignedRect srcRect ;
   uint32 destScreenId ;
   SVGASignedRect destRect ;
};
#line 1736 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_138 SVGA3dCmdBlitSurfaceToScreen;
#line 56 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/alternative.h"
struct module;
#line 47 "include/linux/dynamic_debug.h"
struct device;
#line 135 "include/linux/kernel.h"
struct completion;
#line 136
struct pt_regs;
#line 349
struct pid;
#line 50 "include/linux/miscdevice.h"
struct file_operations;
#line 15 "include/linux/blk_types.h"
struct page;
#line 16
struct block_device;
#line 12 "include/linux/thread_info.h"
struct timespec;
#line 20 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 8 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct mm_struct;
#line 99 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_148 {
   unsigned int a ;
   unsigned int b ;
};
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_149 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField19 ;
   struct __anonstruct____missing_field_name_149 __annonCompField20 ;
};
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_147 __annonCompField21 ;
} __attribute__((__packed__)) ;
#line 13 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 192 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 192 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 194 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_153 {
   pgdval_t pgd ;
};
#line 194 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_153 pgd_t;
#line 282 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 295
struct file;
#line 313
struct seq_file;
#line 47 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt_types.h"
struct thread_struct;
#line 53
struct cpumask;
#line 329
struct arch_spinlock;
#line 141 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 11 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_157 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 11 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_157 __annonCompField22 ;
};
#line 10 "include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 14 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((4096UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 637 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 153 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 290 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
#line 306 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_164 {
   u64 rip ;
   u64 rdp ;
};
#line 306 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_165 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 306 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_163 {
   struct __anonstruct____missing_field_name_164 __annonCompField26 ;
   struct __anonstruct____missing_field_name_165 __annonCompField27 ;
};
#line 306 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_166 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
#line 306 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_163 __annonCompField28 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_166 __annonCompField29 ;
} __attribute__((__aligned__(16))) ;
#line 341 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 361 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
#line 366 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
#line 372 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
#line 379 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 386 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 433
struct kmem_cache;
#line 435
struct perf_event;
#line 437 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 20 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_169 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 20 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_169 __annonCompField31 ;
};
#line 20 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 27 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
struct __anonstruct____missing_field_name_171 {
   u32 read ;
   s32 write ;
};
#line 27 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_170 {
   s64 lock ;
   struct __anonstruct____missing_field_name_171 __annonCompField32 ;
};
#line 27 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_170 arch_rwlock_t;
#line 391 "include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 64 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_172 {
   struct raw_spinlock rlock ;
};
#line 64 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_172 __annonCompField33 ;
};
#line 64 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 11 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_173 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 11 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_173 rwlock_t;
#line 49 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 53 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 119 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 119 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 188 "include/linux/rcupdate.h"
struct notifier_block;
#line 33 "include/linux/list_bl.h"
struct hlist_bl_node;
#line 33 "include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 37 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 13 "include/linux/dcache.h"
struct nameidata;
#line 14
struct path;
#line 15
struct vfsmount;
#line 35 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char    *name ;
};
#line 88
struct inode;
#line 88
struct dentry_operations;
#line 88
struct super_block;
#line 88 "include/linux/dcache.h"
union __anonunion_d_u_175 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 88 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations    *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_175 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 131 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry    * , struct inode    * , struct qstr * ) ;
   int (*d_compare)(struct dentry    * , struct inode    * , struct dentry  const  * ,
                    struct inode    * , unsigned int  , char    * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry    * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 14 "include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 20 "include/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 64 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 64 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 14 "include/linux/prio_tree.h"
struct prio_tree_node;
#line 14 "include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 6 "include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50 "include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 69 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char    *name ;
   void *magic ;
};
#line 69 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 94 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
#line 94 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 378
struct user_namespace;
#line 16 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 8 "include/linux/shrinker.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 31 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control *sc ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 10 "include/linux/migrate_mode.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 408 "include/linux/fs.h"
struct export_operations;
#line 410
struct iovec;
#line 412
struct kiocb;
#line 413
struct kobject;
#line 414
struct pipe_inode_info;
#line 415
struct poll_table_struct;
#line 416
struct kstatfs;
#line 417
struct vm_area_struct;
#line 419
struct cred;
#line 469 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 129 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 19 "include/linux/rwsem.h"
struct rw_semaphore;
#line 25 "include/linux/rwsem.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
};
#line 18 "include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char    *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 15 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 10 "include/linux/timer.h"
struct tvec_base;
#line 12 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 289
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 15 "include/linux/workqueue.h"
struct workqueue_struct;
#line 17
struct work_struct;
#line 79 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 92 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 50 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 50 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 264 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_late)(struct device *dev ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*freeze_late)(struct device *dev ) ;
   int (*thaw_early)(struct device *dev ) ;
   int (*poweroff_late)(struct device *dev ) ;
   int (*restore_early)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
#line 458
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 480
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 488
struct wakeup_source;
#line 495 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 506
struct dev_pm_qos_request;
#line 506
struct pm_qos_raints;
#line 506 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool ignore_children : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   ktime_t suspend_time ;
   s64 max_time_suspended_ns ;
   struct dev_pm_qos_request *pq_req ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_raints *raints ;
};
#line 564 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_247 {
   unsigned long bits[(((unsigned long )(1 << 10) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_247 nodemask_t;
#line 174 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 11 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_248 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_248 mm_context_t;
#line 50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 146 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 146 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 17 "include/linux/dqblk_qtree.h"
struct dquot;
#line 185 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "include/linux/quota.h"
typedef long long qsize_t;
#line 200 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 215
struct quota_format_type;
#line 217 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 288 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 305 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 316 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 332 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 345 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops    *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 399 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops    *ops[2] ;
};
#line 533 "include/linux/fs.h"
struct address_space;
#line 534
struct writeback_control;
#line 577 "include/linux/fs.h"
union __anonunion_arg_278 {
   char *buf ;
   void *data ;
};
#line 577 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_277 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_278 arg ;
   int error ;
};
#line 577 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_277 read_descriptor_t;
#line 590 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec    *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 645
struct backing_dev_info;
#line 646 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations    *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 669
struct request_queue;
#line 671
struct hd_struct;
#line 671
struct gendisk;
#line 671 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 749
struct posix_acl;
#line 761
struct inode_operations;
#line 761 "include/linux/fs.h"
union __anonunion____missing_field_name_279 {
   unsigned int    i_nlink ;
   unsigned int __i_nlink ;
};
#line 761 "include/linux/fs.h"
union __anonunion____missing_field_name_280 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 761
struct file_lock;
#line 761
struct cdev;
#line 761 "include/linux/fs.h"
union __anonunion____missing_field_name_281 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 761 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   uid_t i_uid ;
   gid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations    *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_279 __annonCompField44 ;
   dev_t i_rdev ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   blkcnt_t i_blocks ;
   loff_t i_size ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_280 __annonCompField45 ;
   atomic_t i_count ;
   unsigned int i_blkbits ;
   u64 i_version ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations    *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_281 __annonCompField46 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 942 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 953 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 976 "include/linux/fs.h"
union __anonunion_f_u_282 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 976 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_282 f_u ;
   struct path f_path ;
   struct file_operations    *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred    *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1111
struct files_struct;
#line 1111 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1113 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1118 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 4 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 9 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 15
struct nfs4_lock_state;
#line 16 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1138 "include/linux/fs.h"
struct fasync_struct;
#line 1138 "include/linux/fs.h"
struct __anonstruct_afs_284 {
   struct list_head link ;
   int state ;
};
#line 1138 "include/linux/fs.h"
union __anonunion_fl_u_283 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_284 afs ;
};
#line 1138 "include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations    *fl_ops ;
   struct lock_manager_operations    *fl_lmops ;
   union __anonunion_fl_u_283 fl_u ;
};
#line 1378 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1418
struct file_system_type;
#line 1418
struct super_operations;
#line 1418
struct xattr_handler;
#line 1418
struct mtd_info;
#line 1418 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations    *s_op ;
   struct dquot_operations    *dq_op ;
   struct quotactl_ops    *s_qcop ;
   struct export_operations    *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler    **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock  __attribute__((__aligned__((1) <<  (6) ))) ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   u8 s_uuid[16] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations    *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1567 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1609 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char    * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec    * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec    * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char    * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file *file , int mode , loff_t offset , loff_t len ) ;
};
#line 1639 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char    * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char    * , void    * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char    * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char    * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 1684 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int flags ) ;
   int (*write_inode)(struct inode * , struct writeback_control *wbc ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char    * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1835 "include/linux/fs.h"
struct file_system_type {
   char    *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char    * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 50 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 20 "include/linux/kobject_ns.h"
struct sock;
#line 27
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 40 "include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void    *(*netlink_ns)(struct sock *sk ) ;
   void    *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 26 "include/linux/sysfs.h"
struct attribute {
   char    *name ;
   umode_t mode ;
};
#line 56 "include/linux/sysfs.h"
struct attribute_group {
   char    *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 88 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
#line 112 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char    * , size_t  ) ;
   void    *(*namespace)(struct kobject * , struct attribute    * ) ;
};
#line 118
struct sysfs_dirent;
#line 22 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 60 "include/linux/kobject.h"
struct kset;
#line 60
struct kobj_type;
#line 60 "include/linux/kobject.h"
struct kobject {
   char    *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 108 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops    *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations    *(*child_ns_type)(struct kobject *kobj ) ;
   void    *(*namespace)(struct kobject *kobj ) ;
};
#line 116 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 123 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*   filter)(struct kset *kset , struct kobject *kobj ) ;
   char    *(*   name)(struct kset *kset , struct kobject *kobj ) ;
   int (*   uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 159 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops    *uevent_ops ;
};
#line 46 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[26] ;
};
#line 57 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 73 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 80 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char    *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 46 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
#line 48 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char    *buffer , unsigned long count ,
                         void *data );
#line 51 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations    *proc_iops ;
   struct file_operations    *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 125
struct tty_driver;
#line 243
struct nsproxy;
#line 19 "include/linux/klist.h"
struct klist_node;
#line 39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 4 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct dma_map_ops;
#line 4 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 16 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 29 "include/linux/device.h"
struct device_private;
#line 30
struct device_driver;
#line 31
struct driver_private;
#line 33
struct class;
#line 34
struct subsys_private;
#line 35
struct bus_type;
#line 36
struct device_node;
#line 37
struct iommu_ops;
#line 39 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char    *buf , size_t count ) ;
};
#line 89
struct device_attribute;
#line 89
struct driver_attribute;
#line 89 "include/linux/device.h"
struct bus_type {
   char    *name ;
   char    *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops    *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 214
struct of_device_id;
#line 214 "include/linux/device.h"
struct device_driver {
   char    *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char    *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id    *of_match_table ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group    **groups ;
   struct dev_pm_ops    *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char    *buf , size_t count ) ;
};
#line 330
struct class_attribute;
#line 330 "include/linux/device.h"
struct class {
   char    *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct kobj_ns_type_operations    *ns_type ;
   void    *(*namespace)(struct device *dev ) ;
   struct dev_pm_ops    *pm ;
   struct subsys_private *p ;
};
#line 397 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , struct class_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct class *class , struct class_attribute *attr , char    *buf ,
                    size_t count ) ;
   void    *(*namespace)(struct class *class , struct class_attribute    *attr ) ;
};
#line 465 "include/linux/device.h"
struct device_type {
   char    *name ;
   struct attribute_group    **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops    *pm ;
};
#line 476 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char    *buf ,
                    size_t count ) ;
};
#line 559 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 627
struct dma_coherent_mem;
#line 627 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char    *init_name ;
   struct device_type    *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group    **groups ;
   void (*release)(struct device *dev ) ;
};
#line 43 "include/linux/pm_wakeup.h"
struct wakeup_source {
   char    *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned int active : 1 ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 17 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
#line 506 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 17 "include/linux/platform_device.h"
struct mfd_cell;
#line 19 "include/linux/platform_device.h"
struct platform_device {
   char    *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id    *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 10 "include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 61 "include/linux/pci.h"
struct hotplug_slot;
#line 61 "include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 117 "include/linux/pci.h"
typedef int pci_power_t;
#line 143 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 145
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 169 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 186 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 230
struct pcie_link_state;
#line 231
struct pci_vpd;
#line 232
struct pci_sriov;
#line 233
struct pci_ats;
#line 238
struct pci_driver;
#line 238 "include/linux/pci.h"
union __anonunion____missing_field_name_292 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 238 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 pcie_type : 4 ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17] ;
   struct bin_attribute *res_attr_wc[17] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_292 __annonCompField47 ;
   struct pci_ats *ats ;
};
#line 406
struct pci_ops;
#line 406 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 472 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
#line 491 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 503 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 523 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
#line 544 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char    *name ;
   struct pci_device_id    *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id    *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 6 "include/asm-generic/scatterlist.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_294 {
   unsigned long index ;
   void *freelist ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_298 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_297 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_298 __annonCompField49 ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_296 {
   union __anonunion____missing_field_name_297 __annonCompField50 ;
   atomic_t _count ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_295 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_296 __annonCompField51 ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_293 {
   union __anonunion____missing_field_name_294 __annonCompField48 ;
   union __anonunion____missing_field_name_295 __annonCompField52 ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_300 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_299 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_300 __annonCompField54 ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_301 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 40 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct____missing_field_name_293 __annonCompField53 ;
   union __anonunion____missing_field_name_299 __annonCompField55 ;
   union __anonunion____missing_field_name_301 __annonCompField56 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 200 "include/linux/mm_types.h"
struct __anonstruct_vm_set_303 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 200 "include/linux/mm_types.h"
union __anonunion_shared_302 {
   struct __anonstruct_vm_set_303 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 200
struct anon_vma;
#line 200
struct vm_operations_struct;
#line 200
struct mempolicy;
#line 200 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_302 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct    *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 257 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 262 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 284 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3] ;
};
#line 288
struct linux_binfmt;
#line 288
struct mmu_notifier_mm;
#line 288 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
#line 25 "include/linux/mm.h"
struct user_struct;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 205 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t    *from , nodemask_t    *to ,
                  unsigned long flags ) ;
};
#line 27 "include/linux/dma-attrs.h"
struct dma_attrs {
   unsigned long flags[((4UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 7 "include/linux/dma-direction.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 11 "include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc)(struct device *dev , size_t size , dma_addr_t *dma_handle , gfp_t gfp ,
                  struct dma_attrs *attrs ) ;
   void (*free)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ,
                struct dma_attrs *attrs ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs *attrs ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int (*set_dma_mask)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
#line 12 "include/linux/cdev.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations    *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 101 "include/linux/sem.h"
struct sem_undo_list;
#line 101 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 16 "include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 58 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 10 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct siginfo;
#line 30 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_319 {
   unsigned long sig[1] ;
};
#line 30 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_319 sigset_t;
#line 17 "include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 167 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 174 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 7 "include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 7 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_321 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_322 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_323 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_324 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_325 {
   void *_addr ;
   short _addr_lsb ;
};
#line 48 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_326 {
   long _band ;
   int _fd ;
};
#line 48 "include/asm-generic/siginfo.h"
union __anonunion__sifields_320 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_321 _kill ;
   struct __anonstruct__timer_322 _timer ;
   struct __anonstruct__rt_323 _rt ;
   struct __anonstruct__sigchld_324 _sigchld ;
   struct __anonstruct__sigfault_325 _sigfault ;
   struct __anonstruct__sigpoll_326 _sigpoll ;
};
#line 48 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_320 _sifields ;
};
#line 48 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 28 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 10 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_329 {
   int mode ;
};
#line 10 "include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_329 seccomp_t;
#line 81 "include/linux/plist.h"
struct plist_head {
   struct list_head node_list ;
};
#line 85 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 42 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 8 "include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 13 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 27 "include/linux/hrtimer.h"
struct hrtimer_clock_base;
#line 28
struct hrtimer_cpu_base;
#line 44
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 108 "include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 145 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 178 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3] ;
};
#line 11 "include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 20 "include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 29 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 76
struct signal_struct;
#line 79
struct key_type;
#line 81
struct keyring_list;
#line 124
struct key_user;
#line 124 "include/linux/key.h"
union __anonunion____missing_field_name_386 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 124 "include/linux/key.h"
union __anonunion_type_data_387 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
   int reject_error ;
};
#line 124 "include/linux/key.h"
union __anonunion_payload_388 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 124 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_386 __annonCompField59 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_387 type_data ;
   union __anonunion_payload_388 payload ;
};
#line 18 "include/linux/selinux.h"
struct audit_context;
#line 31 "include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
#line 83 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 116 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 61 "include/linux/llist.h"
struct llist_node;
#line 65 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 97 "include/linux/sched.h"
struct futex_pi_state;
#line 98
struct robust_list_head;
#line 99
struct bio_list;
#line 100
struct fs_struct;
#line 101
struct perf_event_context;
#line 102
struct blk_plug;
#line 151
struct cfs_rq;
#line 15 "include/linux/aio.h"
struct kioctx;
#line 87 "include/linux/aio.h"
union __anonunion_ki_obj_389 {
   void *user ;
   struct task_struct *tsk ;
};
#line 87
struct eventfd_ctx;
#line 87 "include/linux/aio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_389 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 166 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
#line 179 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 443 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 450 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 458 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 476 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 519
struct autogroup;
#line 528
struct tty_struct;
#line 528
struct taskstats;
#line 528
struct tty_audit_buf;
#line 528 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 703 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
#line 748
struct reclaim_state;
#line 751 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 763 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1088
struct io_context;
#line 1102
struct rq;
#line 1122 "include/linux/sched.h"
struct sched_class {
   struct sched_class    *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*yield_task)(struct rq *rq ) ;
   bool (*yield_to_task)(struct rq *rq , struct task_struct *p , bool preempt ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int flags ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sd_flag , int flags ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_waking)(struct task_struct *task ) ;
   void (*task_woken)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask    *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_fork)(struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ) ;
   unsigned int (*get_rr_interval)(struct rq *rq , struct task_struct *task ) ;
   void (*task_move_group)(struct task_struct *p , int on_rq ) ;
};
#line 1167 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1172 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1207 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1233
struct rt_rq;
#line 1233 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1264
struct css_set;
#line 1264
struct compat_robust_list_head;
#line 1264
struct mem_cgroup;
#line 1264 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1264 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class    *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned int irq_thread : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred    *real_cred ;
   struct cred    *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
#line 39 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 212 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 226 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 230 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 35 "include/linux/agp_backend.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 40 "include/linux/agp_backend.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 45 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct    *vm_ops ;
};
#line 67
struct agp_bridge_data;
#line 39 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "include/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 85 "include/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 118 "include/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60] ;
};
#line 145 "include/drm/drm.h"
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
#line 177
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
#line 190
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
#line 235
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
#line 400
enum drm_ctx_flags {
    _DRM_CONTEXT_PRESERVED = 1,
    _DRM_CONTEXT_2DONLY = 2
} ;
#line 456 "include/drm/drm.h"
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
#line 579 "include/drm/drm.h"
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
#line 275 "include/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4] ;
   __u32 pitches[4] ;
   __u32 offsets[4] ;
};
#line 418 "include/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 757 "include/drm/drm.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 765 "include/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 51 "include/linux/idr.h"
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[1 << 6] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
#line 59 "include/linux/idr.h"
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
#line 129 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[128UL / sizeof(long ) - 1UL] ;
};
#line 134 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 84 "include/drm/drmP.h"
struct drm_file;
#line 85
struct drm_device;
#line 42 "include/drm/drm_hashtab.h"
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
#line 47 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 17 "include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations    *op ;
   int poll_event ;
   void *private ;
};
#line 31 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
#line 44 "include/drm/drm_mm.h"
struct drm_mm;
#line 44 "include/drm/drm_mm.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned int hole_follows : 1 ;
   unsigned int scanned_block : 1 ;
   unsigned int scanned_prev_free : 1 ;
   unsigned int scanned_next_free : 1 ;
   unsigned int scanned_preceeds_hole : 1 ;
   unsigned int allocated : 1 ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
#line 58 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned int scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
};
#line 295 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device *dev , void *data , struct drm_file *file_priv );
#line 310 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
#line 340
enum __anonenum_list_409 {
    DRM_LIST_NONE = 0,
    DRM_LIST_FREE = 1,
    DRM_LIST_WAIT = 2,
    DRM_LIST_PEND = 3,
    DRM_LIST_PRIO = 4,
    DRM_LIST_RECLAIM = 5
} ;
#line 340 "include/drm/drmP.h"
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   wait_queue_head_t dma_wait ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   enum __anonenum_list_409 list ;
   int dev_priv_size ;
   void *dev_private ;
};
#line 369 "include/drm/drmP.h"
struct drm_waitlist {
   int count ;
   struct drm_buf **bufs ;
   struct drm_buf **rp ;
   struct drm_buf **wp ;
   struct drm_buf **end ;
   spinlock_t read_lock ;
   spinlock_t write_lock ;
};
#line 379 "include/drm/drmP.h"
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
#line 391 "include/drm/drmP.h"
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
#line 400 "include/drm/drmP.h"
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
#line 412 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event *event ) ;
};
#line 422 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 428
struct drm_minor;
#line 428
struct drm_master;
#line 428 "include/drm/drmP.h"
struct drm_file {
   int authenticated ;
   pid_t pid ;
   uid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 459 "include/drm/drmP.h"
struct drm_queue {
   atomic_t use_count ;
   atomic_t finalization ;
   atomic_t block_count ;
   atomic_t block_read ;
   wait_queue_head_t read_queue ;
   atomic_t block_write ;
   wait_queue_head_t write_queue ;
   atomic_t total_queued ;
   atomic_t total_flushed ;
   atomic_t total_locks ;
   enum drm_ctx_flags flags ;
   struct drm_waitlist waitlist ;
   wait_queue_head_t flush_queue ;
};
#line 478 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 493
enum __anonenum_flags_410 {
    _DRM_DMA_USE_AGP = 1,
    _DRM_DMA_USE_SG = 2,
    _DRM_DMA_USE_FB = 4,
    _DRM_DMA_USE_PCI_RO = 8
} ;
#line 493 "include/drm/drmP.h"
struct drm_device_dma {
   struct drm_buf_entry bufs[23] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   enum __anonenum_flags_410 flags ;
};
#line 527 "include/drm/drmP.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 543 "include/drm/drmP.h"
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
#line 551 "include/drm/drmP.h"
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 560 "include/drm/drmP.h"
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
#line 575 "include/drm/drmP.h"
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
#line 624
struct dma_buf;
#line 624
struct dma_buf_attachment;
#line 624 "include/drm/drmP.h"
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 28 "include/linux/of.h"
typedef u32 phandle;
#line 31 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char    *name ;
   char    *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 193 "include/linux/serial.h"
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
#line 6 "include/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "include/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "include/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 31 "include/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 14 "include/asm-generic/termios.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 9 "include/linux/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5] ;
   __u16 x_sflag ;
};
#line 249 "include/linux/tty_driver.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver *driver , struct inode *inode ,
                                int idx ) ;
   int (*install)(struct tty_driver *driver , struct tty_struct *tty ) ;
   void (*remove)(struct tty_driver *driver , struct tty_struct *tty ) ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   void (*shutdown)(struct tty_struct *tty ) ;
   void (*cleanup)(struct tty_struct *tty ) ;
   int (*write)(struct tty_struct *tty , unsigned char    *buf , int count ) ;
   int (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   int (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*tiocmget)(struct tty_struct *tty ) ;
   int (*tiocmset)(struct tty_struct *tty , unsigned int set , unsigned int clear ) ;
   int (*resize)(struct tty_struct *tty , struct winsize *ws ) ;
   int (*set_termiox)(struct tty_struct *tty , struct termiox *tnew ) ;
   int (*get_icount)(struct tty_struct *tty , struct serial_icounter_struct *icount ) ;
   int (*poll_init)(struct tty_driver *driver , int line , char *options ) ;
   int (*poll_get_char)(struct tty_driver *driver , int line ) ;
   void (*poll_put_char)(struct tty_driver *driver , int line , char ch ) ;
   struct file_operations    *proc_fops ;
};
#line 294 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev cdev ;
   struct module *owner ;
   char    *driver_name ;
   char    *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations    *ops ;
   struct list_head tty_drivers ;
};
#line 49 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 114 "include/linux/tty_ldisc.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct *tty ) ;
   ssize_t (*read)(struct tty_struct *tty , struct file *file , unsigned char *buf ,
                   size_t nr ) ;
   ssize_t (*write)(struct tty_struct *tty , struct file *file , unsigned char    *buf ,
                    size_t nr ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                        unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct *tty ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char    *cp , char *fp ,
                       int count ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
#line 154 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
};
#line 64 "include/linux/tty.h"
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0] ;
};
#line 87 "include/linux/tty.h"
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
#line 202
struct tty_port;
#line 204 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port *port ) ;
   void (*dtr_rts)(struct tty_port *port , int raise ) ;
   void (*shutdown)(struct tty_port *port ) ;
   void (*drop)(struct tty_port *port ) ;
   int (*activate)(struct tty_port *port , struct tty_struct *tty ) ;
   void (*destruct)(struct tty_port *port ) ;
};
#line 223 "include/linux/tty.h"
struct tty_port {
   struct tty_struct *tty ;
   struct tty_port_operations    *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 259 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations    *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   struct termiox *termiox ;
   char name[64] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned char echo_overrun : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[256UL / (8UL * sizeof(unsigned long ))] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[4096UL / (8UL * sizeof(unsigned long ))] ;
   unsigned char *echo_buf ;
   unsigned int echo_pos ;
   unsigned int echo_cnt ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   struct mutex output_lock ;
   struct mutex echo_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 37 "include/drm/drm_crtc.h"
struct drm_mode_set;
#line 38
struct drm_framebuffer;
#line 50 "include/drm/drm_crtc.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
};
#line 63
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 116 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int crtc_hadjusted ;
   int crtc_vadjusted ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
#line 172
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 178
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 193 "include/drm/drm_crtc.h"
struct drm_display_info {
   char name[32] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
   char *raw_edid ;
};
#line 214 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer *framebuffer ) ;
   int (*create_handle)(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                        unsigned int *handle ) ;
   int (*dirty)(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                unsigned int num_clips ) ;
};
#line 237 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs    *funcs ;
   unsigned int pitches[4] ;
   unsigned int offsets[4] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 256 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
#line 269 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
#line 280
struct drm_crtc;
#line 281
struct drm_connector;
#line 282
struct drm_encoder;
#line 283
struct drm_pending_vblank_event;
#line 311 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc *crtc ) ;
   void (*restore)(struct drm_crtc *crtc ) ;
   void (*reset)(struct drm_crtc *crtc ) ;
   int (*cursor_set)(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                     uint32_t width , uint32_t height ) ;
   int (*cursor_move)(struct drm_crtc *crtc , int x , int y ) ;
   void (*gamma_set)(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                     uint32_t size ) ;
   void (*destroy)(struct drm_crtc *crtc ) ;
   int (*set_config)(struct drm_mode_set *set ) ;
   int (*page_flip)(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
};
#line 367 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   int x ;
   int y ;
   struct drm_crtc_funcs    *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
};
#line 420 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector *connector , int mode ) ;
   void (*save)(struct drm_connector *connector ) ;
   void (*restore)(struct drm_connector *connector ) ;
   void (*reset)(struct drm_connector *connector ) ;
   enum drm_connector_status (*detect)(struct drm_connector *connector , bool force ) ;
   int (*fill_modes)(struct drm_connector *connector , uint32_t max_width , uint32_t max_height ) ;
   int (*set_property)(struct drm_connector *connector , struct drm_property *property ,
                       uint64_t val ) ;
   void (*destroy)(struct drm_connector *connector ) ;
   void (*force)(struct drm_connector *connector ) ;
};
#line 448 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder *encoder ) ;
   void (*destroy)(struct drm_encoder *encoder ) ;
};
#line 473 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs    *funcs ;
   void *helper_private ;
};
#line 487
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 544 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs    *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   u32 property_ids[16] ;
   uint64_t property_values[16] ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2] ;
   int video_latency[2] ;
   int audio_latency[2] ;
   int null_edid_counter ;
};
#line 665 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct list_head head ;
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 687 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device *dev , struct drm_file *file_priv ,
                                        struct drm_mode_fb_cmd2 *mode_cmd ) ;
   void (*output_poll_changed)(struct drm_device *dev ) ;
};
#line 707 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
#line 743 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
#line 682 "include/drm/drmP.h"
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 721 "include/drm/drmP.h"
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device *dev ) ;
   char    *(*get_name)(struct drm_device *dev ) ;
   int (*set_busid)(struct drm_device *dev , struct drm_master *master ) ;
   int (*set_unique)(struct drm_device *dev , struct drm_master *master , struct drm_unique *unique ) ;
   int (*irq_by_busid)(struct drm_device *dev , struct drm_irq_busid *p ) ;
   int (*agp_init)(struct drm_device *dev ) ;
};
#line 739
struct usb_driver;
#line 739 "include/drm/drmP.h"
union __anonunion_kdriver_413 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
#line 739 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long flags ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file *file_priv ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t state ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device *dev , int context ) ;
   u32 (*get_vblank_counter)(struct drm_device *dev , int crtc ) ;
   int (*enable_vblank)(struct drm_device *dev , int crtc ) ;
   void (*disable_vblank)(struct drm_device *dev , int crtc ) ;
   int (*device_is_agp)(struct drm_device *dev ) ;
   int (*get_scanout_position)(struct drm_device *dev , int crtc , int *vpos , int *hpos ) ;
   int (*get_vblank_timestamp)(struct drm_device *dev , int crtc , int *max_error ,
                               struct timeval *vblank_time , unsigned int flags ) ;
   irqreturn_t (*irq_handler)(int irq , void *arg ) ;
   void (*irq_preinstall)(struct drm_device *dev ) ;
   int (*irq_postinstall)(struct drm_device *dev ) ;
   void (*irq_uninstall)(struct drm_device *dev ) ;
   void (*reclaim_buffers)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*reclaim_buffers_locked)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*reclaim_buffers_idlelocked)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*set_version)(struct drm_device *dev , struct drm_set_version *sv ) ;
   int (*master_create)(struct drm_device *dev , struct drm_master *master ) ;
   void (*master_destroy)(struct drm_device *dev , struct drm_master *master ) ;
   int (*master_set)(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) ;
   void (*master_drop)(struct drm_device *dev , struct drm_file *file_priv , bool from_release ) ;
   int (*debugfs_init)(struct drm_minor *minor ) ;
   void (*debugfs_cleanup)(struct drm_minor *minor ) ;
   int (*gem_init_object)(struct drm_gem_object *obj ) ;
   void (*gem_free_object)(struct drm_gem_object *obj ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device *dev , struct drm_file *file_priv ,
                             uint32_t handle , uint32_t flags , int *prime_fd ) ;
   int (*prime_fd_to_handle)(struct drm_device *dev , struct drm_file *file_priv ,
                             int prime_fd , uint32_t *handle ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device *dev , struct drm_gem_object *obj ,
                                       int flags ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device *dev , struct dma_buf *dma_buf ) ;
   void (*vgaarb_irq)(struct drm_device *dev , bool state ) ;
   int (*dumb_create)(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
   int (*dumb_map_offset)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                          uint64_t *offset ) ;
   int (*dumb_destroy)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) ;
   struct vm_operations_struct *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations    *fops ;
   union __anonunion_kdriver_413 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
#line 999 "include/drm/drmP.h"
struct drm_info_list {
   char    *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
#line 1009 "include/drm/drmP.h"
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
#line 1019 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
#line 1054 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 1064
struct usb_device;
#line 1064 "include/drm/drmP.h"
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15] ;
   atomic_t counts[15] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   int queue_count ;
   int queue_reserved ;
   int queue_slots ;
   struct drm_queue **queuelist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
#line 33 "include/drm/drm_global.h"
enum drm_global_types {
    DRM_GLOBAL_TTM_MEM = 0,
    DRM_GLOBAL_TTM_BO = 1,
    DRM_GLOBAL_TTM_OBJECT = 2,
    DRM_GLOBAL_NUM = 3
} ;
#line 40 "include/drm/drm_global.h"
struct drm_global_reference {
   enum drm_global_types global_type ;
   size_t size ;
   void *object ;
   int (*init)(struct drm_global_reference * ) ;
   void (*release)(struct drm_global_reference * ) ;
};
#line 189 "include/drm/vmwgfx_drm.h"
struct drm_vmw_size {
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
   uint32_t pad64 ;
};
#line 278 "include/drm/vmwgfx_drm.h"
struct drm_vmw_execbuf_arg {
   uint64_t commands ;
   uint32_t command_size ;
   uint32_t throttle_us ;
   uint64_t fence_rep ;
   uint32_t version ;
   uint32_t flags ;
};
#line 312 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_rep {
   uint32_t handle ;
   uint32_t mask ;
   uint32_t seqno ;
   uint32_t passed_seqno ;
   uint32_t pad64 ;
   int32_t error ;
};
#line 40 "include/linux/taskstats.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count  __attribute__((__aligned__(8))) ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32] ;
   __u8 ac_sched  __attribute__((__aligned__(8))) ;
   __u8 ac_pad[3] ;
   __u32 ac_uid  __attribute__((__aligned__(8))) ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime  __attribute__((__aligned__(8))) ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 22 "include/linux/cgroup.h"
struct cgroupfs_root;
#line 25
struct cgroup;
#line 26
struct css_id;
#line 60 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
};
#line 163 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   struct list_head sibling ;
   struct list_head children ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[8UL * sizeof(unsigned long )] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct rcu_head rcu_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
};
#line 224 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[8UL * sizeof(unsigned long )] ;
   struct rcu_head rcu_head ;
};
#line 113 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 43 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bo_device;
#line 60 "include/drm/ttm/ttm_bo_api.h"
struct ttm_placement {
   unsigned int fpfn ;
   unsigned int lpfn ;
   unsigned int num_placement ;
   uint32_t    *placement ;
   unsigned int num_busy_placement ;
   uint32_t    *busy_placement ;
};
#line 82 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bus_placement {
   void *addr ;
   unsigned long base ;
   unsigned long size ;
   unsigned long offset ;
   bool is_iomem ;
   bool io_reserved_vm ;
   uint64_t io_reserved_count ;
};
#line 107 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_reg {
   void *mm_node ;
   unsigned long start ;
   unsigned long size ;
   unsigned long num_pages ;
   uint32_t page_alignment ;
   uint32_t mem_type ;
   uint32_t placement ;
   struct ttm_bus_placement bus ;
};
#line 129
enum ttm_bo_type {
    ttm_bo_type_device = 0,
    ttm_bo_type_kernel = 1
} ;
#line 134
struct ttm_tt;
#line 192
struct ttm_bo_global;
#line 192 "include/drm/ttm/ttm_bo_api.h"
struct ttm_buffer_object {
   struct ttm_bo_global *glob ;
   struct ttm_bo_device *bdev ;
   unsigned long buffer_start ;
   enum ttm_bo_type type ;
   void (*destroy)(struct ttm_buffer_object * ) ;
   unsigned long num_pages ;
   uint64_t addr_space_offset ;
   size_t acc_size ;
   struct kref kref ;
   struct kref list_kref ;
   wait_queue_head_t event_queue ;
   struct ttm_mem_reg mem ;
   struct file *persistent_swap_storage ;
   struct ttm_tt *ttm ;
   bool evicted ;
   atomic_t cpu_writers ;
   struct list_head lru ;
   struct list_head ddestroy ;
   struct list_head swap ;
   struct list_head io_reserve_lru ;
   uint32_t val_seq ;
   bool seq_valid ;
   atomic_t reserved ;
   void *sync_obj_arg ;
   void *sync_obj ;
   unsigned long priv_flags ;
   struct rb_node vm_rb ;
   struct drm_mm_node *vm_node ;
   unsigned long offset ;
   uint32_t cur_placement ;
};
#line 49 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_shrink {
   int (*do_shrink)(struct ttm_mem_shrink * ) ;
};
#line 77
struct ttm_mem_zone;
#line 78 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_global {
   struct kobject kobj ;
   struct ttm_mem_shrink *shrink ;
   struct workqueue_struct *swap_queue ;
   struct work_struct work ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   struct ttm_mem_zone *zones[2] ;
   unsigned int num_zones ;
   struct ttm_mem_zone *zone_kernel ;
   struct ttm_mem_zone *zone_dma32 ;
};
#line 42 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_backend;
#line 44 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_backend_func {
   int (*bind)(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) ;
   int (*unbind)(struct ttm_tt *ttm ) ;
   void (*destroy)(struct ttm_tt *ttm ) ;
};
#line 85
enum ttm_caching_state {
    tt_uncached = 0,
    tt_wc = 1,
    tt_cached = 2
} ;
#line 112
enum __anonenum_state_428 {
    tt_bound = 0,
    tt_unbound = 1,
    tt_unpopulated = 2
} ;
#line 112 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_tt {
   struct ttm_bo_device *bdev ;
   struct ttm_backend_func *func ;
   struct page *dummy_read_page ;
   struct page **pages ;
   uint32_t page_flags ;
   unsigned long num_pages ;
   struct ttm_bo_global *glob ;
   struct ttm_backend *be ;
   struct file *swap_storage ;
   enum ttm_caching_state caching_state ;
   enum __anonenum_state_428 state ;
};
#line 151
struct ttm_mem_type_manager;
#line 153 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager_func {
   int (*init)(struct ttm_mem_type_manager *man , unsigned long p_size ) ;
   int (*takedown)(struct ttm_mem_type_manager *man ) ;
   int (*get_node)(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                   struct ttm_placement *placement , struct ttm_mem_reg *mem ) ;
   void (*put_node)(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) ;
   void (*debug)(struct ttm_mem_type_manager *man , char    *prefix ) ;
};
#line 265 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager {
   struct ttm_bo_device *bdev ;
   bool has_type ;
   bool use_type ;
   uint32_t flags ;
   unsigned long gpu_offset ;
   uint64_t size ;
   uint32_t available_caching ;
   uint32_t default_caching ;
   struct ttm_mem_type_manager_func    *func ;
   void *priv ;
   struct mutex io_reserve_mutex ;
   bool use_io_reserve_lru ;
   bool io_reserve_fastpath ;
   struct list_head io_reserve_lru ;
   struct list_head lru ;
};
#line 317 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_driver {
   struct ttm_tt *(*ttm_tt_create)(struct ttm_bo_device *bdev , unsigned long size ,
                                   uint32_t page_flags , struct page *dummy_read_page ) ;
   int (*ttm_tt_populate)(struct ttm_tt *ttm ) ;
   void (*ttm_tt_unpopulate)(struct ttm_tt *ttm ) ;
   int (*invalidate_caches)(struct ttm_bo_device *bdev , uint32_t flags ) ;
   int (*init_mem_type)(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) ;
   void (*evict_flags)(struct ttm_buffer_object *bo , struct ttm_placement *placement ) ;
   int (*move)(struct ttm_buffer_object *bo , bool evict , bool interruptible , bool no_wait_reserve ,
               bool no_wait_gpu , struct ttm_mem_reg *new_mem ) ;
   int (*verify_access)(struct ttm_buffer_object *bo , struct file *filp ) ;
   bool (*sync_obj_signaled)(void *sync_obj , void *sync_arg ) ;
   int (*sync_obj_wait)(void *sync_obj , void *sync_arg , bool lazy , bool interruptible ) ;
   int (*sync_obj_flush)(void *sync_obj , void *sync_arg ) ;
   void (*sync_obj_unref)(void **sync_obj ) ;
   void *(*sync_obj_ref)(void *sync_obj ) ;
   void (*move_notify)(struct ttm_buffer_object *bo , struct ttm_mem_reg *new_mem ) ;
   int (*fault_reserve_notify)(struct ttm_buffer_object *bo ) ;
   void (*swap_notify)(struct ttm_buffer_object *bo ) ;
   int (*io_mem_reserve)(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) ;
   void (*io_mem_free)(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) ;
};
#line 460 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global_ref {
   struct drm_global_reference ref ;
   struct ttm_mem_global *mem_glob ;
};
#line 479 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global {
   struct kobject kobj ;
   struct ttm_mem_global *mem_glob ;
   struct page *dummy_read_page ;
   struct ttm_mem_shrink shrink ;
   struct mutex device_list_mutex ;
   spinlock_t lru_lock ;
   struct list_head device_list ;
   struct list_head swap_lru ;
   atomic_t bo_count ;
};
#line 533 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_device {
   struct list_head device_list ;
   struct ttm_bo_global *glob ;
   struct ttm_bo_driver *driver ;
   rwlock_t vm_lock ;
   struct ttm_mem_type_manager man[8] ;
   spinlock_t fence_lock ;
   struct rb_root addr_space_rb ;
   struct drm_mm addr_space_mm ;
   struct list_head ddestroy ;
   uint32_t val_seq ;
   bool nice_mode ;
   struct address_space *dev_mapping ;
   struct delayed_work wq ;
   bool need_dma32 ;
};
#line 60 "include/drm/ttm/ttm_object.h"
enum ttm_ref_type {
    TTM_REF_USAGE = 0,
    TTM_REF_SYNCCPU_READ = 1,
    TTM_REF_SYNCCPU_WRITE = 2,
    TTM_REF_NUM = 3
} ;
#line 75
enum ttm_object_type {
    ttm_fence_type = 0,
    ttm_buffer_type = 1,
    ttm_lock_type = 2,
    ttm_driver_type0 = 256,
    ttm_driver_type1 = 257,
    ttm_driver_type2 = 258,
    ttm_driver_type3 = 259,
    ttm_driver_type4 = 260,
    ttm_driver_type5 = 261
} ;
#line 87
struct ttm_object_file;
#line 88
struct ttm_object_device;
#line 122 "include/drm/ttm/ttm_object.h"
struct ttm_base_object {
   struct drm_hash_item hash ;
   enum ttm_object_type object_type ;
   bool shareable ;
   struct ttm_object_file *tfile ;
   struct kref refcount ;
   void (*refcount_release)(struct ttm_base_object **base ) ;
   void (*ref_obj_release)(struct ttm_base_object *base , enum ttm_ref_type ref_type ) ;
};
#line 69 "include/drm/ttm/ttm_lock.h"
struct ttm_lock {
   struct ttm_base_object base ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   int32_t rw ;
   uint32_t flags ;
   bool kill_takers ;
   int signal ;
   struct ttm_object_file *vt_holder ;
};
#line 50 "include/drm/ttm/ttm_execbuf_util.h"
struct ttm_validate_buffer {
   struct list_head head ;
   struct ttm_buffer_object *bo ;
   void *new_sync_obj_arg ;
   bool reserved ;
   bool removed ;
   int put_count ;
   void *old_sync_obj ;
};
#line 32 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_private;
#line 34
struct vmw_fence_manager;
#line 52 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj {
   struct kref kref ;
   u32 seqno ;
   struct vmw_fence_manager *fman ;
   struct list_head head ;
   uint32_t signaled ;
   uint32_t signal_mask ;
   struct list_head seq_passed_actions ;
   void (*destroy)(struct vmw_fence_obj *fence ) ;
   wait_queue_head_t queue ;
};
#line 62 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fpriv {
   struct drm_master *locked_master ;
   struct ttm_object_file *tfile ;
   struct list_head fence_events ;
};
#line 68 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_dma_buffer {
   struct ttm_buffer_object base ;
   struct list_head validate_list ;
   bool gmr_bound ;
   uint32_t cur_validate_node ;
   bool on_validate_list ;
};
#line 76 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource {
   struct kref kref ;
   struct vmw_private *dev_priv ;
   struct idr *idr ;
   int id ;
   enum ttm_object_type res_type ;
   bool avail ;
   void (*remove_from_lists)(struct vmw_resource *res ) ;
   void (*hw_destroy)(struct vmw_resource *res ) ;
   void (*res_free)(struct vmw_resource *res ) ;
   struct list_head validate_head ;
   struct list_head query_head ;
};
#line 97 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_cursor_snooper {
   struct drm_crtc *crtc ;
   size_t age ;
   uint32_t *image ;
};
#line 104
struct vmw_surface_offset;
#line 106 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_surface {
   struct vmw_resource res ;
   struct list_head lru_head ;
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6] ;
   struct drm_vmw_size *sizes ;
   uint32_t num_sizes ;
   bool scanout ;
   struct vmw_cursor_snooper snooper ;
   struct ttm_buffer_object *backup ;
   struct vmw_surface_offset *offsets ;
   uint32_t backup_size ;
};
#line 124 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker_queue {
   struct list_head head ;
   struct timespec lag ;
   struct timespec lag_time ;
   spinlock_t lock ;
};
#line 131 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fifo_state {
   unsigned long reserved_size ;
   __le32 *dynamic_buffer ;
   __le32 *static_buffer ;
   unsigned long static_buffer_size ;
   bool using_bounce_buffer ;
   uint32_t capabilities ;
   struct mutex fifo_mutex ;
   struct rw_semaphore rwsem ;
   struct vmw_marker_queue marker_queue ;
};
#line 143 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_relocation {
   SVGAGuestPtr *location ;
   uint32_t index ;
};
#line 148 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_sw_context {
   struct ida bo_list ;
   uint32_t last_cid ;
   bool cid_valid ;
   bool kernel ;
   struct vmw_resource *cur_ctx ;
   uint32_t last_sid ;
   uint32_t sid_translation ;
   bool sid_valid ;
   struct ttm_object_file *tfile ;
   struct list_head validate_nodes ;
   struct vmw_relocation relocs[2048] ;
   uint32_t cur_reloc ;
   struct ttm_validate_buffer val_bufs[2048] ;
   uint32_t cur_val_buf ;
   uint32_t *cmd_bounce ;
   uint32_t cmd_bounce_size ;
   struct list_head resource_list ;
   uint32_t fence_flags ;
   struct list_head query_list ;
   struct ttm_buffer_object *cur_query_bo ;
   uint32_t cur_query_cid ;
   bool query_cid_valid ;
};
#line 173
struct vmw_legacy_display;
#line 174
struct vmw_overlay;
#line 176 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_master {
   struct ttm_lock lock ;
   struct mutex fb_surf_mutex ;
   struct list_head fb_surf ;
};
#line 182 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_vga_topology_state {
   uint32_t width ;
   uint32_t height ;
   uint32_t primary ;
   uint32_t pos_x ;
   uint32_t pos_y ;
};
#line 190
struct vmw_screen_object_display;
#line 190 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_private {
   struct ttm_bo_device bdev ;
   struct ttm_bo_global_ref bo_global_ref ;
   struct drm_global_reference mem_global_ref ;
   struct vmw_fifo_state fifo ;
   struct drm_device *dev ;
   unsigned long vmw_chipset ;
   unsigned int io_start ;
   uint32_t vram_start ;
   uint32_t vram_size ;
   uint32_t mmio_start ;
   uint32_t mmio_size ;
   uint32_t fb_max_width ;
   uint32_t fb_max_height ;
   uint32_t initial_width ;
   uint32_t initial_height ;
   __le32 *mmio_virt ;
   int mmio_mtrr ;
   uint32_t capabilities ;
   uint32_t max_gmr_descriptors ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t memory_size ;
   bool has_gmr ;
   struct mutex hw_mutex ;
   struct vmw_vga_topology_state vga_save[16] ;
   uint32_t vga_width ;
   uint32_t vga_height ;
   uint32_t vga_bpp ;
   uint32_t vga_bpl ;
   uint32_t vga_pitchlock ;
   uint32_t num_displays ;
   void *fb_info ;
   struct vmw_legacy_display *ldu_priv ;
   struct vmw_screen_object_display *sou_priv ;
   struct vmw_overlay *overlay_priv ;
   rwlock_t resource_lock ;
   struct idr context_idr ;
   struct idr surface_idr ;
   struct idr stream_idr ;
   struct mutex init_mutex ;
   struct ttm_object_device *tdev ;
   atomic_t marker_seq ;
   wait_queue_head_t fence_queue ;
   wait_queue_head_t fifo_queue ;
   int fence_queue_waiters ;
   int goal_queue_waiters ;
   atomic_t fifo_queue_waiters ;
   uint32_t last_read_seqno ;
   spinlock_t irq_lock ;
   struct vmw_fence_manager *fman ;
   uint32_t irq_mask ;
   uint32_t traces_state ;
   uint32_t enable_state ;
   uint32_t config_done_state ;
   struct vmw_sw_context ctx ;
   struct mutex cmdbuf_mutex ;
   bool stealth ;
   bool is_opened ;
   bool enable_fb ;
   struct vmw_master *active_master ;
   struct vmw_master fbdev_master ;
   struct notifier_block pm_nb ;
   bool suspended ;
   struct mutex release_mutex ;
   uint32_t num_3d_resources ;
   struct ttm_buffer_object *dummy_query_bo ;
   struct ttm_buffer_object *pinned_bo ;
   uint32_t query_cid ;
   bool dummy_query_bo_pinned ;
   struct list_head surface_lru ;
   uint32_t used_memory_size ;
};
#line 112 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_cid_cmd {
   SVGA3dCmdHeader header ;
   __le32 cid ;
};
#line 190 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_sid_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetRenderTarget body ;
};
#line 209 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_sid_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceCopy body ;
};
#line 226 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_sid_cmd___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceStretchBlt body ;
};
#line 243 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_sid_cmd___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 262 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_sid_cmd___3 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdPresent body ;
};
#line 487 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdEndQuery q ;
};
#line 516 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_query_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery q ;
};
#line 555 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_dma_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA dma ;
};
#line 608 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_draw_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDrawPrimitives body ;
};
#line 660 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct vmw_tex_state_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetTextureState state ;
};
#line 695 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
struct __anonstruct_cmd_429 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 754 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
typedef int (*vmw_cmd_func)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * );
#line 41 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_reg.h"
struct svga_guest_mem_descriptor {
   __le32 ppn ;
   __le32 num_pages ;
};
#line 1494 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMR2_27 {
   uint32 gmrId ;
   uint32 numPages ;
};
#line 1494 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMR2_27 SVGAFifoCmdDefineGMR2;
#line 1529
enum __anonenum_SVGARemapGMR2Flags_28 {
    SVGA_REMAP_GMR2_PPN32 = 0,
    SVGA_REMAP_GMR2_VIA_GMR = 1,
    SVGA_REMAP_GMR2_PPN64 = 2,
    SVGA_REMAP_GMR2_SINGLE_PPN = 4
} ;
#line 1529 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef enum __anonenum_SVGARemapGMR2Flags_28 SVGARemapGMR2Flags;
#line 1536 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdRemapGMR2_29 {
   uint32 gmrId ;
   SVGARemapGMR2Flags flags ;
   uint32 offsetPages ;
   uint32 numPages ;
};
#line 1536 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdRemapGMR2_29 SVGAFifoCmdRemapGMR2;
#line 13 "include/linux/thread_info.h"
struct compat_timespec;
#line 18 "include/linux/thread_info.h"
struct __anonstruct_futex_144 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_nanosleep_145 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 18
struct pollfd;
#line 18 "include/linux/thread_info.h"
struct __anonstruct_poll_146 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 18 "include/linux/thread_info.h"
union __anonunion____missing_field_name_143 {
   struct __anonstruct_futex_144 futex ;
   struct __anonstruct_nanosleep_145 nanosleep ;
   struct __anonstruct_poll_146 poll ;
};
#line 18 "include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_143 __annonCompField18 ;
};
#line 21 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/thread_info.h"
struct exec_domain;
#line 92 "include/linux/personality.h"
struct map_segment;
#line 92 "include/linux/personality.h"
struct exec_domain {
   char    *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 569 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_168 {
   unsigned long seg ;
};
#line 569 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_168 mm_segment_t;
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned int sig_on_uaccess_error : 1 ;
   unsigned int uaccess_err : 1 ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 18 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 45 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 33 "include/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 263 "include/drm/drm_mode.h"
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
#line 1132 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdDefineAlphaCursor {
   uint32 id ;
   uint32 hotspotX ;
   uint32 hotspotY ;
   uint32 width ;
   uint32 height ;
};
#line 1132 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdDefineAlphaCursor SVGAFifoCmdDefineAlphaCursor;
#line 1411 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_296 {
   SVGASignedPoint destOrigin ;
   SVGASignedRect srcRect ;
   uint32 srcScreenId ;
};
#line 1411 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_296 SVGAFifoCmdBlitScreenToGMRFB;
#line 83 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum SVGA3dSurfaceFormat {
    SVGA3D_FORMAT_INVALID = 0,
    SVGA3D_X8R8G8B8 = 1,
    SVGA3D_A8R8G8B8 = 2,
    SVGA3D_R5G6B5 = 3,
    SVGA3D_X1R5G5B5 = 4,
    SVGA3D_A1R5G5B5 = 5,
    SVGA3D_A4R4G4B4 = 6,
    SVGA3D_Z_D32 = 7,
    SVGA3D_Z_D16 = 8,
    SVGA3D_Z_D24S8 = 9,
    SVGA3D_Z_D15S1 = 10,
    SVGA3D_LUMINANCE8 = 11,
    SVGA3D_LUMINANCE4_ALPHA4 = 12,
    SVGA3D_LUMINANCE16 = 13,
    SVGA3D_LUMINANCE8_ALPHA8 = 14,
    SVGA3D_DXT1 = 15,
    SVGA3D_DXT2 = 16,
    SVGA3D_DXT3 = 17,
    SVGA3D_DXT4 = 18,
    SVGA3D_DXT5 = 19,
    SVGA3D_BUMPU8V8 = 20,
    SVGA3D_BUMPL6V5U5 = 21,
    SVGA3D_BUMPX8L8V8U8 = 22,
    SVGA3D_BUMPL8V8U8 = 23,
    SVGA3D_ARGB_S10E5 = 24,
    SVGA3D_ARGB_S23E8 = 25,
    SVGA3D_A2R10G10B10 = 26,
    SVGA3D_V8U8 = 27,
    SVGA3D_Q8W8V8U8 = 28,
    SVGA3D_CxV8U8 = 29,
    SVGA3D_X8L8V8U8 = 30,
    SVGA3D_A2W10V10U10 = 31,
    SVGA3D_ALPHA8 = 32,
    SVGA3D_R_S10E5 = 33,
    SVGA3D_R_S23E8 = 34,
    SVGA3D_RG_S10E5 = 35,
    SVGA3D_RG_S23E8 = 36,
    SVGA3D_BUFFER = 37,
    SVGA3D_Z_D24X8 = 38,
    SVGA3D_V16U16 = 39,
    SVGA3D_G16R16 = 40,
    SVGA3D_A16B16G16R16 = 41,
    SVGA3D_UYVY = 42,
    SVGA3D_YUY2 = 43,
    SVGA3D_NV12 = 44,
    SVGA3D_AYUV = 45,
    SVGA3D_BC4_UNORM = 108,
    SVGA3D_BC5_UNORM = 111,
    SVGA3D_Z_DF16 = 118,
    SVGA3D_Z_DF24 = 119,
    SVGA3D_Z_D24S8_INT = 120,
    SVGA3D_FORMAT_MAX = 121
} ;
#line 1240 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dCopyBox {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
   uint32 srcx ;
   uint32 srcy ;
   uint32 srcz ;
};
#line 1240 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dCopyBox SVGA3dCopyBox;
#line 426 "include/drm/vmwgfx_drm.h"
struct drm_vmw_rect {
   int32_t x ;
   int32_t y ;
   uint32_t w ;
   uint32_t h ;
};
#line 493 "include/drm/vmwgfx_drm.h"
struct drm_vmw_cursor_bypass_arg {
   uint32_t flags ;
   uint32_t crtc_id ;
   int32_t xpos ;
   int32_t ypos ;
   int32_t xhot ;
   int32_t yhot ;
};
#line 784 "include/drm/vmwgfx_drm.h"
struct drm_vmw_update_layout_arg {
   uint32_t num_outputs ;
   uint32_t pad64 ;
   uint64_t rects ;
};
#line 290 "include/drm/ttm/ttm_bo_api.h"
enum __anonenum_bo_kmap_type_427 {
    ttm_bo_map_iomap = 129,
    ttm_bo_map_vmap = 2,
    ttm_bo_map_kmap = 3,
    ttm_bo_map_premapped = 132
} ;
#line 290 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bo_kmap_obj {
   void *virtual ;
   struct page *page ;
   enum __anonenum_bo_kmap_type_427 bo_kmap_type ;
   struct ttm_buffer_object *bo ;
};
#line 103 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer;
#line 47 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_framebuffer {
   struct drm_framebuffer base ;
   int (*pin)(struct vmw_framebuffer *fb ) ;
   int (*unpin)(struct vmw_framebuffer *fb ) ;
   bool dmabuf ;
   struct ttm_base_object *user_obj ;
   uint32_t user_handle ;
};
#line 81 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_display_unit {
   struct drm_crtc crtc ;
   struct drm_encoder encoder ;
   struct drm_connector connector ;
   struct vmw_surface *cursor_surface ;
   struct vmw_dma_buffer *cursor_dmabuf ;
   size_t cursor_age ;
   int cursor_x ;
   int cursor_y ;
   int hotspot_x ;
   int hotspot_y ;
   unsigned int unit ;
   unsigned int pref_width ;
   unsigned int pref_height ;
   bool pref_active ;
   struct drm_display_mode *pref_mode ;
   int gui_x ;
   int gui_y ;
   bool is_implicit ;
};
#line 36 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct vmw_clip_rect {
   int x1 ;
   int x2 ;
   int y1 ;
   int y2 ;
};
#line 92 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_429___0 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 394 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct vmw_framebuffer_surface {
   struct vmw_framebuffer base ;
   struct vmw_surface *surface ;
   struct vmw_dma_buffer *buffer ;
   struct list_head head ;
   struct drm_master *master ;
};
#line 438 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_430 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 729 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct vmw_framebuffer_dmabuf {
   struct vmw_framebuffer base ;
   struct vmw_dma_buffer *buffer ;
};
#line 755 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_431 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 788 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_432 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 838 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_blits_433 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 1203 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_434 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1337 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_cmd_435 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1341 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
struct __anonstruct_blits_436 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 146 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 234 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 18 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 19 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 23 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 24 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 194 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 194 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 39 "include/linux/moduleparam.h"
struct kernel_param;
#line 41 "include/linux/moduleparam.h"
struct kernel_param_ops {
   int (*set)(char    *val , struct kernel_param    *kp ) ;
   int (*get)(char *buffer , struct kernel_param    *kp ) ;
   void (*free)(void *arg ) ;
};
#line 50
struct kparam_string;
#line 50
struct kparam_array;
#line 50 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_199 {
   void *arg ;
   struct kparam_string    *str ;
   struct kparam_array    *arr ;
};
#line 50 "include/linux/moduleparam.h"
struct kernel_param {
   char    *name ;
   struct kernel_param_ops    *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion____missing_field_name_199 __annonCompField32 ;
};
#line 63 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 69 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops    *ops ;
   void *elem ;
};
#line 143 "include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
};
#line 23 "include/linux/tracepoint.h"
struct tracepoint;
#line 25 "include/linux/tracepoint.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 30 "include/linux/tracepoint.h"
struct tracepoint {
   char    *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 19 "include/linux/export.h"
struct kernel_symbol {
   unsigned long value ;
   char    *name ;
};
#line 8 "include/asm-generic/module.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 44 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char    * ,
                    size_t count ) ;
   void (*setup)(struct module * , char    * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 71
struct exception_table_entry;
#line 199
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 215 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct ftrace_event_call;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char    *version ;
   char    *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol    *syms ;
   unsigned long    *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol    *gpl_syms ;
   unsigned long    *gpl_crcs ;
   struct kernel_symbol    *unused_syms ;
   unsigned long    *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol    *unused_gpl_syms ;
   unsigned long    *unused_gpl_crcs ;
   struct kernel_symbol    *gpl_future_syms ;
   unsigned long    *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint *   *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char    **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
};
#line 94 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 984 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum __anonenum_SVGA3dQueryState_359 {
    SVGA3D_QUERYSTATE_PENDING = 0,
    SVGA3D_QUERYSTATE_SUCCEEDED = 1,
    SVGA3D_QUERYSTATE_FAILED = 2,
    SVGA3D_QUERYSTATE_NEW = 3
} ;
#line 984 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dQueryState_359 SVGA3dQueryState;
#line 1690 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion____missing_field_name_415 {
   uint32 result32 ;
};
#line 1690 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dQueryResult_414 {
   uint32 totalSize ;
   SVGA3dQueryState state ;
   union __anonunion____missing_field_name_415 __annonCompField61 ;
};
#line 1690 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dQueryResult_414 SVGA3dQueryResult;
#line 88 "include/drm/vmwgfx_drm.h"
struct drm_vmw_getparam_arg {
   uint64_t value ;
   uint32_t param ;
   uint32_t pad64 ;
};
#line 111 "include/drm/vmwgfx_drm.h"
struct drm_vmw_context_arg {
   int32_t cid ;
   uint32_t pad64 ;
};
#line 154 "include/drm/vmwgfx_drm.h"
struct drm_vmw_surface_create_req {
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6] ;
   uint64_t size_addr ;
   int32_t shareable ;
   int32_t scanout ;
};
#line 173 "include/drm/vmwgfx_drm.h"
struct drm_vmw_surface_arg {
   int32_t sid ;
   uint32_t pad64 ;
};
#line 205 "include/drm/vmwgfx_drm.h"
union drm_vmw_surface_create_arg {
   struct drm_vmw_surface_arg rep ;
   struct drm_vmw_surface_create_req req ;
};
#line 233 "include/drm/vmwgfx_drm.h"
union drm_vmw_surface_reference_arg {
   struct drm_vmw_surface_create_req rep ;
   struct drm_vmw_surface_arg req ;
};
#line 347 "include/drm/vmwgfx_drm.h"
struct drm_vmw_alloc_dmabuf_req {
   uint32_t size ;
   uint32_t pad64 ;
};
#line 365 "include/drm/vmwgfx_drm.h"
struct drm_vmw_dmabuf_rep {
   uint64_t map_handle ;
   uint32_t handle ;
   uint32_t cur_gmr_id ;
   uint32_t cur_gmr_offset ;
   uint32_t pad64 ;
};
#line 382 "include/drm/vmwgfx_drm.h"
union drm_vmw_alloc_dmabuf_arg {
   struct drm_vmw_alloc_dmabuf_req req ;
   struct drm_vmw_dmabuf_rep rep ;
};
#line 402 "include/drm/vmwgfx_drm.h"
struct drm_vmw_unref_dmabuf_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 451 "include/drm/vmwgfx_drm.h"
struct drm_vmw_control_stream_arg {
   uint32_t stream_id ;
   uint32_t enabled ;
   uint32_t flags ;
   uint32_t color_key ;
   uint32_t handle ;
   uint32_t offset ;
   int32_t format ;
   uint32_t size ;
   uint32_t width ;
   uint32_t height ;
   uint32_t pitch[3] ;
   uint32_t pad64 ;
   struct drm_vmw_rect src ;
   struct drm_vmw_rect dst ;
};
#line 516 "include/drm/vmwgfx_drm.h"
struct drm_vmw_stream_arg {
   uint32_t stream_id ;
   uint32_t pad64 ;
};
#line 547 "include/drm/vmwgfx_drm.h"
struct drm_vmw_get_3d_cap_arg {
   uint64_t buffer ;
   uint32_t max_size ;
   uint32_t pad64 ;
};
#line 598 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_wait_arg {
   uint32_t handle ;
   int32_t cookie_valid ;
   uint64_t kernel_cookie ;
   uint64_t timeout_us ;
   int32_t lazy ;
   int32_t flags ;
   int32_t wait_options ;
   int32_t pad64 ;
};
#line 629 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_signaled_arg {
   uint32_t handle ;
   uint32_t flags ;
   int32_t signaled ;
   uint32_t passed_seqno ;
   uint32_t signaled_flags ;
   uint32_t pad64 ;
};
#line 655 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 698 "include/drm/vmwgfx_drm.h"
struct drm_vmw_fence_event_arg {
   uint64_t fence_rep ;
   uint64_t user_data ;
   uint32_t handle ;
   uint32_t flags ;
};
#line 730 "include/drm/vmwgfx_drm.h"
struct drm_vmw_present_arg {
   uint32_t fb_id ;
   uint32_t sid ;
   int32_t dest_x ;
   int32_t dest_y ;
   uint64_t clips_ptr ;
   uint32_t num_clips ;
   uint32_t pad64 ;
};
#line 760 "include/drm/vmwgfx_drm.h"
struct drm_vmw_present_readback_arg {
   uint32_t fb_id ;
   uint32_t num_clips ;
   uint64_t clips_ptr ;
   uint64_t fence_rep ;
};
#line 1137 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
struct __anonstruct_437 {
   int  : 0 ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 161 "include/linux/fb.h"
struct fb_fix_screeninfo {
   char id[16] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2] ;
};
#line 192 "include/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 245 "include/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4] ;
};
#line 285 "include/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 345 "include/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 354 "include/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 363 "include/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char    *data ;
   struct fb_cmap cmap ;
};
#line 387 "include/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 391 "include/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char    *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 35 "include/linux/backlight.h"
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 42
struct backlight_device;
#line 43
struct fb_info;
#line 45 "include/linux/backlight.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 61 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 87 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops    *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
#line 447 "include/linux/fb.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 458
struct fb_videomode;
#line 458 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4] ;
   __u8 monitor[14] ;
   __u8 serial_no[14] ;
   __u8 ascii[14] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   __u16 gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 563 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 586 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info *info , void *dst , void *src , unsigned int size ) ;
   void (*readio)(struct fb_info *info , void *dst , void *src , unsigned int size ) ;
};
#line 604 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*deferred_io)(struct fb_info *info , struct list_head *pagelist ) ;
};
#line 628 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info *info , int user ) ;
   int (*fb_release)(struct fb_info *info , int user ) ;
   ssize_t (*fb_read)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ) ;
   ssize_t (*fb_write)(struct fb_info *info , char    *buf , size_t count , loff_t *ppos ) ;
   int (*fb_check_var)(struct fb_var_screeninfo *var , struct fb_info *info ) ;
   int (*fb_set_par)(struct fb_info *info ) ;
   int (*fb_setcolreg)(unsigned int regno , unsigned int red , unsigned int green ,
                       unsigned int blue , unsigned int transp , struct fb_info *info ) ;
   int (*fb_setcmap)(struct fb_cmap *cmap , struct fb_info *info ) ;
   int (*fb_blank)(int blank , struct fb_info *info ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo *var , struct fb_info *info ) ;
   void (*fb_fillrect)(struct fb_info *info , struct fb_fillrect    *rect ) ;
   void (*fb_copyarea)(struct fb_info *info , struct fb_copyarea    *region ) ;
   void (*fb_imageblit)(struct fb_info *info , struct fb_image    *image ) ;
   int (*fb_cursor)(struct fb_info *info , struct fb_cursor *cursor ) ;
   void (*fb_rotate)(struct fb_info *info , int angle ) ;
   int (*fb_sync)(struct fb_info *info ) ;
   int (*fb_ioctl)(struct fb_info *info , unsigned int cmd , unsigned long arg ) ;
   int (*fb_compat_ioctl)(struct fb_info *info , unsigned int cmd , unsigned long arg ) ;
   int (*fb_mmap)(struct fb_info *info , struct vm_area_struct *vma ) ;
   void (*fb_get_caps)(struct fb_info *info , struct fb_blit_caps *caps , struct fb_var_screeninfo *var ) ;
   void (*fb_destroy)(struct fb_info *info ) ;
   int (*fb_debug_enter)(struct fb_info *info ) ;
   int (*fb_debug_leave)(struct fb_info *info ) ;
};
#line 709 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8    *data ;
};
#line 718 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 729 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 738 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 749 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 758 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info *info , struct fb_tilemap *map ) ;
   void (*fb_tilecopy)(struct fb_info *info , struct fb_tilearea *area ) ;
   void (*fb_tilefill)(struct fb_info *info , struct fb_tilerect *rect ) ;
   void (*fb_tileblit)(struct fb_info *info , struct fb_tileblit *blit ) ;
   void (*fb_tilecursor)(struct fb_info *info , struct fb_tilecursor *cursor ) ;
   int (*fb_get_tilemax)(struct fb_info *info ) ;
};
#line 839 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 839 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0] ;
};
#line 839 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
#line 1146 "include/linux/fb.h"
struct fb_videomode {
   char    *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
struct __anonstruct_dirty_429 {
   spinlock_t lock ;
   bool active ;
   unsigned int x1 ;
   unsigned int y1 ;
   unsigned int x2 ;
   unsigned int y2 ;
};
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
struct vmw_fb_par {
   struct vmw_private *vmw_priv ;
   void *vmalloc ;
   struct vmw_dma_buffer *vmw_bo ;
   struct ttm_bo_kmap_obj map ;
   u32 pseudo_palette[17] ;
   unsigned int depth ;
   unsigned int bpp ;
   unsigned int max_width ;
   unsigned int max_height ;
   void *bo_ptr ;
   unsigned int bo_size ;
   bool bo_iowrite ;
   struct __anonstruct_dirty_429 dirty ;
};
#line 217 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
struct __anonstruct_cmd_430___0 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 83 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum SVGA3dSurfaceFormat SVGA3dSurfaceFormat;
#line 1131 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSize_87 {
   uint32 width ;
   uint32 height ;
   uint32 depth ;
};
#line 1131 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSize_87 SVGA3dSize;
#line 1138
enum __anonenum_SVGA3dSurfaceFlags_88 {
    SVGA3D_SURFACE_CUBEMAP = 1,
    SVGA3D_SURFACE_HINT_STATIC = 2,
    SVGA3D_SURFACE_HINT_DYNAMIC = 4,
    SVGA3D_SURFACE_HINT_INDEXBUFFER = 8,
    SVGA3D_SURFACE_HINT_VERTEXBUFFER = 16,
    SVGA3D_SURFACE_HINT_TEXTURE = 32,
    SVGA3D_SURFACE_HINT_RENDERTARGET = 64,
    SVGA3D_SURFACE_HINT_DEPTHSTENCIL = 128,
    SVGA3D_SURFACE_HINT_WRITEONLY = 256,
    SVGA3D_SURFACE_MASKABLE_ANTIALIAS = 512,
    SVGA3D_SURFACE_AUTOGENMIPMAPS = 1024
} ;
#line 1138 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum __anonenum_SVGA3dSurfaceFlags_88 SVGA3dSurfaceFlags;
#line 1152 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceFace_89 {
   uint32 numMipLevels ;
};
#line 1152 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceFace_89 SVGA3dSurfaceFace;
#line 1157 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineSurface_90 {
   uint32 sid ;
   SVGA3dSurfaceFlags surfaceFlags ;
   SVGA3dSurfaceFormat format ;
   SVGA3dSurfaceFace face[6] ;
};
#line 1157 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineSurface_90 SVGA3dCmdDefineSurface;
#line 1205 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroySurface_92 {
   uint32 sid ;
};
#line 1205 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroySurface_92 SVGA3dCmdDestroySurface;
#line 1210 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineContext_93 {
   uint32 cid ;
};
#line 1210 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineContext_93 SVGA3dCmdDefineContext;
#line 1215 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroyContext_94 {
   uint32 cid ;
};
#line 1215 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroyContext_94 SVGA3dCmdDestroyContext;
#line 1340 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceDMAFlags_107 {
   uint32 discard : 1 ;
   uint32 unsynchronized : 1 ;
   uint32 reserved : 30 ;
};
#line 1340 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceDMAFlags_107 SVGA3dSurfaceDMAFlags;
#line 1390 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_109 {
   uint32 suffixSize ;
   uint32 maximumOffset ;
   SVGA3dSurfaceDMAFlags flags ;
};
#line 1390 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_109 SVGA3dCmdSurfaceDMASuffix;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 34 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_user_context {
   struct ttm_base_object base ;
   struct vmw_resource res ;
};
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_user_surface {
   struct ttm_base_object base ;
   struct vmw_surface srf ;
   uint32_t size ;
};
#line 45 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_user_dma_buffer {
   struct ttm_base_object base ;
   struct vmw_dma_buffer dma ;
};
#line 55 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_stream {
   struct vmw_resource res ;
   uint32_t stream_id ;
};
#line 60 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_user_stream {
   struct ttm_base_object base ;
   struct vmw_stream stream ;
};
#line 65 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_surface_offset {
   uint32_t face ;
   uint32_t mip ;
   uint32_t bo_offset ;
};
#line 260 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct __anonstruct_cmd_429___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 289 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct __anonstruct_cmd_430___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 503 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_bpp {
   uint8_t bpp ;
   uint8_t s_bpp ;
};
#line 579 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_surface_dma {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA body ;
   SVGA3dCopyBox cb ;
   SVGA3dCmdSurfaceDMASuffix suffix ;
};
#line 586 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_surface_define {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineSurface body ;
};
#line 591 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_surface_destroy {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroySurface body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 144 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct vmw_ttm_tt {
   struct ttm_tt ttm ;
   struct vmw_private *dev_priv ;
   int gmr_id ;
};
#line 46 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_reg.h"
struct svga_fifo_cmd_fence {
   __le32 fence ;
};
#line 27 "include/linux/wait.h"
struct __wait_queue;
#line 27 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 31 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int flags , void *key ) ;
   struct list_head task_list ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 540 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
struct __anonstruct_cmd_429___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
struct vmw_legacy_display {
   struct list_head active ;
   unsigned int num_active ;
   unsigned int last_num_active ;
   struct vmw_framebuffer *fb ;
};
#line 51 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
struct vmw_legacy_display_unit {
   struct vmw_display_unit base ;
   struct list_head active ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 1223 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdEscape {
   uint32 nsid ;
   uint32 size ;
};
#line 1223 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdEscape SVGAFifoCmdEscape;
#line 64 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_header_430 {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 64 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_items_431 {
   uint32 registerId ;
   uint32 value ;
};
#line 64 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoSetRegs {
   struct __anonstruct_header_430 header ;
   struct __anonstruct_items_431 items[1] ;
};
#line 64 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoSetRegs SVGAEscapeVideoSetRegs;
#line 78 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoFlush {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 78 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoFlush SVGAEscapeVideoFlush;
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct vmw_stream___0 {
   struct vmw_dma_buffer *buf ;
   bool claimed ;
   bool paused ;
   struct drm_vmw_control_stream_arg saved ;
};
#line 49 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct vmw_overlay {
   struct mutex mutex ;
   struct vmw_stream___0 stream[1] ;
};
#line 63 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct vmw_escape_header {
   uint32_t cmd ;
   SVGAFifoCmdEscape body ;
};
#line 68 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct vmw_escape_video_flush {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoFlush flush ;
};
#line 106 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct __anonstruct_header_441 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 106 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct __anonstruct_cmds_440 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_441 header ;
};
#line 113 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct __anonstruct_items_442 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 188 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
struct __anonstruct_cmds_443 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 31 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
struct vmw_marker {
   struct list_head head ;
   uint32_t seqno ;
   struct timespec submitted ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
struct vmwgfx_gmrid_man {
   spinlock_t lock ;
   struct ida gmr_ida ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t used_gmr_pages ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 676 "include/drm/vmwgfx_drm.h"
struct drm_vmw_event_fence {
   struct drm_event base ;
   uint64_t user_data ;
   uint32_t tv_sec ;
   uint32_t tv_usec ;
};
#line 40 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
enum vmw_action_type {
    VMW_ACTION_EVENT = 0,
    VMW_ACTION_MAX = 1
} ;
#line 45 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_action {
   struct list_head head ;
   enum vmw_action_type type ;
   void (*seq_passed)(struct vmw_fence_action *action ) ;
   void (*cleanup)(struct vmw_fence_action *action ) ;
};
#line 33 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_fence_manager {
   int num_fence_objects ;
   struct vmw_private *dev_priv ;
   spinlock_t lock ;
   struct list_head fence_list ;
   struct work_struct work ;
   u32 user_fence_size ;
   u32 fence_size ;
   u32 event_fence_action_size ;
   bool fifo_down ;
   struct list_head cleanup_list ;
   uint32_t pending_actions[1] ;
   struct mutex goal_irq_mutex ;
   bool goal_irq_on ;
   bool seqno_valid ;
};
#line 51 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_user_fence {
   struct ttm_base_object base ;
   struct vmw_fence_obj fence ;
};
#line 71 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_event_fence_action {
   struct vmw_fence_action action ;
   struct list_head fpriv_head ;
   struct drm_pending_event *event ;
   struct vmw_fence_obj *fence ;
   struct drm_device *dev ;
   uint32_t *tv_sec ;
   uint32_t *tv_usec ;
};
#line 991 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_event_fence_pending {
   struct drm_pending_event base ;
   struct drm_vmw_event_fence event ;
};
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 290 "include/linux/timer.h"
enum hrtimer_restart;
#line 24 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 327 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 327 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestImage SVGAGuestImage;
#line 967 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_size_288 {
   uint32 width ;
   uint32 height ;
};
#line 967 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_root_289 {
   int32 x ;
   int32 y ;
};
#line 967 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAScreenObject {
   uint32 structSize ;
   uint32 id ;
   uint32 flags ;
   struct __anonstruct_size_288 size ;
   struct __anonstruct_root_289 root ;
   SVGAGuestImage backingStore ;
   uint32 cloneCount ;
};
#line 967 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAScreenObject SVGAScreenObject;
#line 1273 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDestroyScreen_293 {
   uint32 screenId ;
};
#line 1273 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDestroyScreen_293 SVGAFifoCmdDestroyScreen;
#line 39 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct vmw_screen_object_display {
   unsigned int num_implicit ;
   struct vmw_framebuffer *implicit_fb ;
};
#line 48 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct vmw_screen_object_unit {
   struct vmw_display_unit base ;
   unsigned long buffer_size ;
   struct vmw_dma_buffer *buffer ;
   bool defined ;
   bool active_implicit ;
};
#line 111 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct __anonstruct_header_430___0 {
   uint32_t cmdType ;
};
#line 111 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct __anonstruct_cmd_429___3 {
   struct __anonstruct_header_430___0 header ;
   SVGAScreenObject obj ;
};
#line 164 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct __anonstruct_header_432 {
   uint32_t cmdType ;
};
#line 164 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
struct __anonstruct_cmd_431___0 {
   struct __anonstruct_header_432 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 1 "<compiler builtins>"

#line 1

#line 1
long ldv__builtin_expect(long val , long res ) ;
#line 100 "include/linux/printk.h"
extern int ( /* format attribute */  printk)(char    *fmt  , ...) ;
#line 147 "include/linux/kernel.h"
extern void __might_sleep(char    *file , int line , int preempt_offset ) ;
#line 194
__inline static void might_fault(void)  __attribute__((__no_instrument_function__)) ;
#line 194 "include/linux/kernel.h"
__inline static void might_fault(void) 
{ 

  {
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    __might_sleep("include/linux/kernel.h", 196, 0);
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 196
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 196
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list )  __attribute__((__no_instrument_function__)) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
#line 26
  *((struct list_head **)list) = list;
#line 27
  __cil_tmp2 = (unsigned long )list;
#line 27
  __cil_tmp3 = __cil_tmp2 + 8;
#line 27
  *((struct list_head **)__cil_tmp3) = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) ;
#line 74
__inline static void list_add_tail(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct list_head *__cil_tmp5 ;

  {
  {
#line 76
  __cil_tmp3 = (unsigned long )head;
#line 76
  __cil_tmp4 = __cil_tmp3 + 8;
#line 76
  __cil_tmp5 = *((struct list_head **)__cil_tmp4);
#line 76
  __list_add(new, __cil_tmp5, head);
  }
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head *entry ) ;
#line 112
extern void list_del(struct list_head *entry ) ;
#line 142
__inline static void list_del_init(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
  }
#line 146
  return;
}
}
#line 186
__inline static int list_empty(struct list_head    *head )  __attribute__((__no_instrument_function__)) ;
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head    *head ) 
{ unsigned long __cil_tmp2 ;
  struct list_head *   __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 188
  __cil_tmp2 = (unsigned long )head;
#line 188
  __cil_tmp3 = *((struct list_head *   *)head);
#line 188
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 188
  return (__cil_tmp4 == __cil_tmp2);
  }
}
}
#line 55 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/string_64.h"
extern void *memset(void *s , int c , size_t n ) ;
#line 64 "include/asm-generic/bug.h"
extern void ( /* format attribute */  warn_slowpath_fmt)(char    *file , int    line ,
                                                         char    *fmt  , ...) ;
#line 70
extern void warn_slowpath_null(char    *file , int    line ) ;
#line 23 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t    *v )  __attribute__((__no_instrument_function__)) ;
#line 23 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t    *v ) 
{ int    *__cil_tmp2 ;
  int volatile   *__cil_tmp3 ;
  int volatile   __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp2 = (int    *)v;
#line 25
  __cil_tmp3 = (int volatile   *)__cil_tmp2;
#line 25
  __cil_tmp4 = *__cil_tmp3;
#line 25
  return ((int )__cil_tmp4);
  }
}
}
#line 93
__inline static void atomic_inc(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 93 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
#line 95
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "incl %0": "+m" (*((int *)v)));
#line 97
  return;
}
}
#line 152 "include/linux/mutex.h"
void mutex_lock(struct mutex *lock ) ;
#line 153
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) ;
#line 154
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) ;
#line 168
int mutex_trylock(struct mutex *lock ) ;
#line 169
void mutex_unlock(struct mutex *lock ) ;
#line 170
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) ;
#line 548 "include/linux/capability.h"
extern bool capable(int cap ) ;
#line 54 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long size ) ;
#line 66
extern void vfree(void    *addr ) ;
#line 39 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
#line 39 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  atomic_t *__cil_tmp6 ;
  atomic_t    *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  long __cil_tmp10 ;
  int    __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  atomic_t *__cil_tmp15 ;

  {
  {
#line 41
  __cil_tmp6 = (atomic_t *)kref;
#line 41
  __cil_tmp7 = (atomic_t    *)__cil_tmp6;
#line 41
  tmp = atomic_read(__cil_tmp7);
  }
#line 41
  if (tmp) {
#line 41
    tmp___0 = 0;
  } else {
#line 41
    tmp___0 = 1;
  }
  {
#line 41
  __ret_warn_on = tmp___0;
#line 41
  __cil_tmp8 = ! __ret_warn_on;
#line 41
  __cil_tmp9 = ! __cil_tmp8;
#line 41
  __cil_tmp10 = (long )__cil_tmp9;
#line 41
  tmp___1 = ldv__builtin_expect(__cil_tmp10, 0L);
  }
#line 41
  if (tmp___1) {
    {
#line 41
    __cil_tmp11 = (int    )41;
#line 41
    warn_slowpath_null("include/linux/kref.h", __cil_tmp11);
    }
  } else {

  }
  {
#line 41
  __cil_tmp12 = ! __ret_warn_on;
#line 41
  __cil_tmp13 = ! __cil_tmp12;
#line 41
  __cil_tmp14 = (long )__cil_tmp13;
#line 41
  ldv__builtin_expect(__cil_tmp14, 0L);
#line 42
  __cil_tmp15 = (atomic_t *)kref;
#line 42
  atomic_inc(__cil_tmp15);
  }
#line 43
  return;
}
}
#line 39 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
extern unsigned long __attribute__((__warn_unused_result__))  _copy_to_user(void *to ,
                                                                            void    *from ,
                                                                            unsigned int len ) ;
#line 41
extern unsigned long __attribute__((__warn_unused_result__))  _copy_from_user(void *to ,
                                                                              void    *from ,
                                                                              unsigned int len ) ;
#line 46
__inline static unsigned long __attribute__((__warn_unused_result__))  copy_from_user(void *to ,
                                                                                      void    *from ,
                                                                                      unsigned long n )  __attribute__((__no_instrument_function__)) ;
#line 46 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long __attribute__((__warn_unused_result__))  copy_from_user(void *to ,
                                                                                      void    *from ,
                                                                                      unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  unsigned long __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  int    __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;

  {
  {
#line 50
  tmp = __builtin_object_size(to, 0);
#line 50
  sz = (int )tmp;
#line 52
  might_fault();
  }
#line 53
  if (sz == -1) {
#line 53
    tmp___1 = 1;
  } else {
    {
#line 53
    __cil_tmp10 = (unsigned long )sz;
#line 53
    if (__cil_tmp10 >= n) {
#line 53
      tmp___1 = 1;
    } else {
#line 53
      tmp___1 = 0;
    }
    }
  }
  {
#line 53
  __cil_tmp11 = (long )tmp___1;
#line 53
  tmp___2 = ldv__builtin_expect(__cil_tmp11, 1L);
  }
#line 53
  if (tmp___2) {
    {
#line 54
    __cil_tmp12 = (unsigned int )n;
#line 54
    n = (unsigned long )_copy_from_user(to, from, __cil_tmp12);
    }
  } else {
    {
#line 57
    __ret_warn_on = 1;
#line 57
    __cil_tmp13 = ! __ret_warn_on;
#line 57
    __cil_tmp14 = ! __cil_tmp13;
#line 57
    __cil_tmp15 = (long )__cil_tmp14;
#line 57
    tmp___0 = ldv__builtin_expect(__cil_tmp15, 0L);
    }
#line 57
    if (tmp___0) {
      {
#line 57
      __cil_tmp16 = (int    )57;
#line 57
      warn_slowpath_fmt("/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h",
                        __cil_tmp16, "Buffer overflow detected!\n");
      }
    } else {

    }
    {
#line 57
    __cil_tmp17 = ! __ret_warn_on;
#line 57
    __cil_tmp18 = ! __cil_tmp17;
#line 57
    __cil_tmp19 = (long )__cil_tmp18;
#line 57
    ldv__builtin_expect(__cil_tmp19, 0L);
    }
  }
#line 59
  return (n);
}
}
#line 62
__inline static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) copy_to_user)(void *dst ,
                                                                                                                void    *src ,
                                                                                                                unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 62 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
__inline static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) copy_to_user)(void *dst ,
                                                                                                                void    *src ,
                                                                                                                unsigned int size ) 
{ unsigned long tmp ;

  {
  {
#line 65
  might_fault();
#line 67
  tmp = (unsigned long )_copy_to_user(dst, src, size);
  }
#line 67
  return ((int )tmp);
}
}
#line 132 "include/drm/drmP.h"
extern int ( /* format attribute */  drm_err)(char    *func , char    *format 
                                              , ...) ;
#line 310 "include/drm/ttm/ttm_bo_api.h"
__inline static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
#line 310 "include/drm/ttm/ttm_bo_api.h"
__inline static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct kref *__cil_tmp4 ;

  {
  {
#line 313
  __cil_tmp2 = (unsigned long )bo;
#line 313
  __cil_tmp3 = __cil_tmp2 + 64;
#line 313
  __cil_tmp4 = (struct kref *)__cil_tmp3;
#line 313
  kref_get(__cil_tmp4);
  }
#line 314
  return (bo);
}
}
#line 350
extern int ttm_bo_validate(struct ttm_buffer_object *bo , struct ttm_placement *placement ,
                           bool interruptible , bool no_wait_reserve , bool no_wait_gpu ) ;
#line 362
extern void ttm_bo_unref(struct ttm_buffer_object **bo ) ;
#line 216 "include/drm/ttm/ttm_object.h"
extern int ttm_ref_object_base_unref(struct ttm_object_file *tfile , unsigned long key ,
                                     enum ttm_ref_type ref_type ) ;
#line 96 "include/drm/ttm/ttm_lock.h"
extern void ttm_read_unlock(struct ttm_lock *lock ) ;
#line 108
extern int ttm_read_lock(struct ttm_lock *lock , bool interruptible ) ;
#line 69 "include/drm/ttm/ttm_execbuf_util.h"
extern void ttm_eu_backoff_reservation(struct list_head *list ) ;
#line 96
extern int ttm_eu_reserve_buffers(struct list_head *list ) ;
#line 110
extern void ttm_eu_fence_buffer_objects(struct list_head *list , void *sync_obj ) ;
#line 70 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) ;
#line 80
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) ;
#line 86
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) ;
#line 91
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) ;
#line 336 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_private *vmw_priv(struct drm_device *dev )  __attribute__((__no_instrument_function__)) ;
#line 336 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_private *vmw_priv(struct drm_device *dev ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 338
  __cil_tmp2 = (unsigned long )dev;
#line 338
  __cil_tmp3 = __cil_tmp2 + 1064;
#line 338
  __cil_tmp4 = *((void **)__cil_tmp3);
#line 338
  return ((struct vmw_private *)__cil_tmp4);
  }
}
}
#line 341
__inline static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv )  __attribute__((__no_instrument_function__)) ;
#line 341 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 343
  __cil_tmp2 = (unsigned long )file_priv;
#line 343
  __cil_tmp3 = __cil_tmp2 + 136;
#line 343
  __cil_tmp4 = *((void **)__cil_tmp3);
#line 343
  return ((struct vmw_fpriv *)__cil_tmp4);
  }
}
}
#line 346
__inline static struct vmw_master *vmw_master(struct drm_master *master )  __attribute__((__no_instrument_function__)) ;
#line 346 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_master *vmw_master(struct drm_master *master ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 348
  __cil_tmp2 = (unsigned long )master;
#line 348
  __cil_tmp3 = __cil_tmp2 + 192;
#line 348
  __cil_tmp4 = *((void **)__cil_tmp3);
#line 348
  return ((struct vmw_master *)__cil_tmp4);
  }
}
}
#line 386
void vmw_resource_unreference(struct vmw_resource **p_res ) ;
#line 392
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) ;
#line 405
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) ;
#line 418
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) ;
#line 430
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) ;
#line 432
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) ;
#line 433
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) ;
#line 443
void vmw_resource_unreserve(struct list_head *list ) ;
#line 466
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) ;
#line 493
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 494
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 495
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) ;
#line 500
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) ;
#line 515
struct ttm_placement vmw_vram_placement ;
#line 518
struct ttm_placement vmw_vram_gmr_placement ;
#line 530
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 532
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) ;
#line 542
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) ;
#line 546
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) ;
#line 550
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) ;
#line 571
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) ;
#line 577
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) ;
#line 595
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) ;
#line 617
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) ;
#line 618
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) ;
#line 674
__inline static void vmw_surface_unreference(struct vmw_surface **srf )  __attribute__((__no_instrument_function__)) ;
#line 674 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_surface_unreference(struct vmw_surface **srf ) 
{ struct vmw_surface *tmp_srf ;
  struct vmw_resource *res ;
  struct vmw_resource **__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 676
  tmp_srf = *srf;
#line 677
  __cil_tmp4 = & res;
#line 677
  *__cil_tmp4 = (struct vmw_resource *)tmp_srf;
#line 678
  __cil_tmp5 = (void *)0;
#line 678
  *srf = (struct vmw_surface *)__cil_tmp5;
#line 680
  vmw_resource_unreference(& res);
  }
#line 681
  return;
}
}
#line 689
__inline static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf )  __attribute__((__no_instrument_function__)) ;
#line 689 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf ) 
{ struct vmw_dma_buffer *tmp_buf ;
  struct ttm_buffer_object *bo ;
  struct ttm_buffer_object **__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 691
  tmp_buf = *buf;
#line 692
  __cil_tmp4 = & bo;
#line 692
  *__cil_tmp4 = (struct ttm_buffer_object *)tmp_buf;
#line 693
  __cil_tmp5 = (void *)0;
#line 693
  *buf = (struct vmw_dma_buffer *)__cil_tmp5;
#line 695
  ttm_bo_unref(& bo);
  }
#line 696
  return;
}
}
#line 33 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_invalid(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                           SVGA3dCmdHeader *header ) 
{ int tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 37
  tmp___9 = capable(21);
#line 37
  tmp___8 = (int )tmp___9;
  }
#line 37
  if (tmp___8) {

  } else {
#line 37
    tmp___8 = -22;
  }
#line 37
  return (tmp___8);
}
}
#line 40 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_ok(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                      SVGA3dCmdHeader *header ) 
{ 

  {
#line 44
  return (0);
}
}
#line 47 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_resource_to_validate_list(struct vmw_sw_context *sw_context , struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  int tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct list_head *__cil_tmp7 ;
  struct list_head    *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 50
  res = *p_res;
#line 52
  __cil_tmp5 = (unsigned long )res;
#line 52
  __cil_tmp6 = __cil_tmp5 + 64;
#line 52
  __cil_tmp7 = (struct list_head *)__cil_tmp6;
#line 52
  __cil_tmp8 = (struct list_head    *)__cil_tmp7;
#line 52
  tmp___7 = list_empty(__cil_tmp8);
  }
#line 52
  if (tmp___7) {
    {
#line 53
    __cil_tmp9 = (unsigned long )res;
#line 53
    __cil_tmp10 = __cil_tmp9 + 64;
#line 53
    __cil_tmp11 = (struct list_head *)__cil_tmp10;
#line 53
    __cil_tmp12 = (unsigned long )sw_context;
#line 53
    __cil_tmp13 = __cil_tmp12 + 131216;
#line 53
    __cil_tmp14 = (struct list_head *)__cil_tmp13;
#line 53
    list_add_tail(__cil_tmp11, __cil_tmp14);
#line 54
    __cil_tmp15 = (void *)0;
#line 54
    *p_res = (struct vmw_resource *)__cil_tmp15;
    }
  } else {
    {
#line 56
    vmw_resource_unreference(p_res);
    }
  }
#line 57
  return;
}
}
#line 72 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_bo_to_validate_list(struct vmw_sw_context *sw_context , struct ttm_buffer_object *bo ,
                                   uint32_t fence_flags , uint32_t *p_val_node ) 
{ uint32_t val_node ;
  struct ttm_validate_buffer *val_buf ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t __cil_tmp52 ;

  {
  {
#line 80
  __cil_tmp9 = (unsigned long )sw_context;
#line 80
  __cil_tmp10 = __cil_tmp9 + 131192;
#line 80
  __cil_tmp11 = *((uint32_t *)__cil_tmp10);
#line 80
  val_node = vmw_dmabuf_validate_node(bo, __cil_tmp11);
#line 82
  __cil_tmp12 = val_node >= 2048U;
#line 82
  __cil_tmp13 = ! __cil_tmp12;
#line 82
  __cil_tmp14 = ! __cil_tmp13;
#line 82
  __cil_tmp15 = (long )__cil_tmp14;
#line 82
  tmp___7 = ldv__builtin_expect(__cil_tmp15, 0L);
  }
#line 82
  if (tmp___7) {
    {
#line 83
    drm_err("vmw_bo_to_validate_list", "Max number of DMA buffers per submission exceeded.\n");
    }
#line 85
    return (-22);
  } else {

  }
  {
#line 88
  __cil_tmp16 = val_node * 48UL;
#line 88
  __cil_tmp17 = 32888 + __cil_tmp16;
#line 88
  __cil_tmp18 = (unsigned long )sw_context;
#line 88
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 88
  val_buf = (struct ttm_validate_buffer *)__cil_tmp19;
#line 89
  __cil_tmp20 = (unsigned long )sw_context;
#line 89
  __cil_tmp21 = __cil_tmp20 + 131192;
#line 89
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 89
  __cil_tmp23 = val_node == __cil_tmp22;
#line 89
  __cil_tmp24 = ! __cil_tmp23;
#line 89
  __cil_tmp25 = ! __cil_tmp24;
#line 89
  __cil_tmp26 = (long )__cil_tmp25;
#line 89
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 89
  if (tmp___8) {
    {
#line 90
    __cil_tmp27 = (unsigned long )val_buf;
#line 90
    __cil_tmp28 = __cil_tmp27 + 24;
#line 90
    *((void **)__cil_tmp28) = (void *)0;
#line 91
    __cil_tmp29 = (unsigned long )val_buf;
#line 91
    __cil_tmp30 = __cil_tmp29 + 16;
#line 91
    *((struct ttm_buffer_object **)__cil_tmp30) = ttm_bo_reference(bo);
#line 92
    __cil_tmp31 = (struct list_head *)val_buf;
#line 92
    __cil_tmp32 = (unsigned long )sw_context;
#line 92
    __cil_tmp33 = __cil_tmp32 + 96;
#line 92
    __cil_tmp34 = (struct list_head *)__cil_tmp33;
#line 92
    list_add_tail(__cil_tmp31, __cil_tmp34);
#line 93
    __cil_tmp35 = (unsigned long )sw_context;
#line 93
    __cil_tmp36 = __cil_tmp35 + 131192;
#line 93
    __cil_tmp37 = (unsigned long )sw_context;
#line 93
    __cil_tmp38 = __cil_tmp37 + 131192;
#line 93
    __cil_tmp39 = *((uint32_t *)__cil_tmp38);
#line 93
    *((uint32_t *)__cil_tmp36) = __cil_tmp39 + 1U;
    }
  } else {

  }
#line 96
  __cil_tmp40 = (unsigned long )val_buf;
#line 96
  __cil_tmp41 = __cil_tmp40 + 24;
#line 96
  __cil_tmp42 = (unsigned long )fence_flags;
#line 96
  __cil_tmp43 = (unsigned long )val_buf;
#line 96
  __cil_tmp44 = __cil_tmp43 + 24;
#line 96
  __cil_tmp45 = *((void **)__cil_tmp44);
#line 96
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 96
  __cil_tmp47 = __cil_tmp46 | __cil_tmp42;
#line 96
  *((void **)__cil_tmp41) = (void *)__cil_tmp47;
#line 98
  __cil_tmp48 = (unsigned long )sw_context;
#line 98
  __cil_tmp49 = __cil_tmp48 + 131232;
#line 98
  __cil_tmp50 = (unsigned long )sw_context;
#line 98
  __cil_tmp51 = __cil_tmp50 + 131232;
#line 98
  __cil_tmp52 = *((uint32_t *)__cil_tmp51);
#line 98
  *((uint32_t *)__cil_tmp49) = __cil_tmp52 | fence_flags;
#line 100
  if (p_val_node) {
#line 101
    *p_val_node = val_node;
  } else {

  }
#line 103
  return (0);
}
}
#line 106 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_cid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_resource *ctx ;
  struct vmw_cid_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader    *__mptr ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  struct vmw_cid_cmd *__cil_tmp11 ;
  SVGA3dCmdHeader *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct ttm_object_file *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  __le32 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  __le32 __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct vmw_resource **__cil_tmp47 ;

  {
#line 118
  __mptr = (SVGA3dCmdHeader    *)header;
#line 118
  __cil_tmp11 = (struct vmw_cid_cmd *)0;
#line 118
  __cil_tmp12 = (SVGA3dCmdHeader *)__cil_tmp11;
#line 118
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 118
  __cil_tmp14 = (char *)__mptr;
#line 118
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
#line 118
  cmd = (struct vmw_cid_cmd *)__cil_tmp15;
  {
#line 119
  __cil_tmp16 = (unsigned long )sw_context;
#line 119
  __cil_tmp17 = __cil_tmp16 + 60;
#line 119
  if (*((bool *)__cil_tmp17)) {
    {
#line 119
    __cil_tmp18 = (unsigned long )sw_context;
#line 119
    __cil_tmp19 = __cil_tmp18 + 56;
#line 119
    __cil_tmp20 = *((uint32_t *)__cil_tmp19);
#line 119
    __cil_tmp21 = (unsigned long )cmd;
#line 119
    __cil_tmp22 = __cil_tmp21 + 8;
#line 119
    __cil_tmp23 = *((__le32 *)__cil_tmp22);
#line 119
    if (__cil_tmp23 == __cil_tmp20) {
#line 119
      tmp___7 = 1;
    } else {
#line 119
      tmp___7 = 0;
    }
    }
  } else {
#line 119
    tmp___7 = 0;
  }
  }
  {
#line 119
  __cil_tmp24 = (long )tmp___7;
#line 119
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 1L);
  }
#line 119
  if (tmp___8) {
#line 120
    return (0);
  } else {

  }
  {
#line 122
  __cil_tmp25 = (unsigned long )sw_context;
#line 122
  __cil_tmp26 = __cil_tmp25 + 88;
#line 122
  __cil_tmp27 = *((struct ttm_object_file **)__cil_tmp26);
#line 122
  __cil_tmp28 = (unsigned long )cmd;
#line 122
  __cil_tmp29 = __cil_tmp28 + 8;
#line 122
  __cil_tmp30 = *((__le32 *)__cil_tmp29);
#line 122
  __cil_tmp31 = (int )__cil_tmp30;
#line 122
  ret = vmw_context_check(dev_priv, __cil_tmp27, __cil_tmp31, & ctx);
#line 124
  __cil_tmp32 = ret != 0;
#line 124
  __cil_tmp33 = ! __cil_tmp32;
#line 124
  __cil_tmp34 = ! __cil_tmp33;
#line 124
  __cil_tmp35 = (long )__cil_tmp34;
#line 124
  tmp___9 = ldv__builtin_expect(__cil_tmp35, 0L);
  }
#line 124
  if (tmp___9) {
    {
#line 125
    __cil_tmp36 = (unsigned long )cmd;
#line 125
    __cil_tmp37 = __cil_tmp36 + 8;
#line 125
    __cil_tmp38 = *((__le32 *)__cil_tmp37);
#line 125
    drm_err("vmw_cmd_cid_check", "Could not find or use context %u\n", __cil_tmp38);
    }
#line 127
    return (ret);
  } else {

  }
  {
#line 130
  __cil_tmp39 = (unsigned long )sw_context;
#line 130
  __cil_tmp40 = __cil_tmp39 + 56;
#line 130
  __cil_tmp41 = (unsigned long )cmd;
#line 130
  __cil_tmp42 = __cil_tmp41 + 8;
#line 130
  *((uint32_t *)__cil_tmp40) = *((__le32 *)__cil_tmp42);
#line 131
  __cil_tmp43 = (unsigned long )sw_context;
#line 131
  __cil_tmp44 = __cil_tmp43 + 60;
#line 131
  *((bool *)__cil_tmp44) = (bool )1;
#line 132
  __cil_tmp45 = (unsigned long )sw_context;
#line 132
  __cil_tmp46 = __cil_tmp45 + 64;
#line 132
  __cil_tmp47 = & ctx;
#line 132
  *((struct vmw_resource **)__cil_tmp46) = *__cil_tmp47;
#line 133
  vmw_resource_to_validate_list(sw_context, & ctx);
  }
#line 135
  return (0);
}
}
#line 138 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_sid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             uint32_t *sid ) 
{ struct vmw_surface *srf ;
  int ret ;
  struct vmw_resource *res ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint32_t __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_object_file *__cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_surface **__cil_tmp31 ;
  struct vmw_surface *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface **__cil_tmp44 ;
  struct vmw_surface *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct vmw_resource **__cil_tmp51 ;
  struct vmw_surface **__cil_tmp52 ;
  struct vmw_surface *__cil_tmp53 ;

  {
  {
#line 146
  __cil_tmp11 = *sid;
#line 146
  if (__cil_tmp11 == 4294967295U) {
#line 147
    return (0);
  } else {

  }
  }
  {
#line 149
  __cil_tmp12 = (unsigned long )sw_context;
#line 149
  __cil_tmp13 = __cil_tmp12 + 80;
#line 149
  if (*((bool *)__cil_tmp13)) {
    {
#line 149
    __cil_tmp14 = (unsigned long )sw_context;
#line 149
    __cil_tmp15 = __cil_tmp14 + 72;
#line 149
    __cil_tmp16 = *((uint32_t *)__cil_tmp15);
#line 149
    __cil_tmp17 = *sid;
#line 149
    if (__cil_tmp17 == __cil_tmp16) {
#line 149
      tmp___7 = 1;
    } else {
#line 149
      tmp___7 = 0;
    }
    }
  } else {
#line 149
    tmp___7 = 0;
  }
  }
  {
#line 149
  __cil_tmp18 = (long )tmp___7;
#line 149
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 1L);
  }
#line 149
  if (tmp___8) {
#line 151
    __cil_tmp19 = (unsigned long )sw_context;
#line 151
    __cil_tmp20 = __cil_tmp19 + 76;
#line 151
    *sid = *((uint32_t *)__cil_tmp20);
#line 152
    return (0);
  } else {

  }
  {
#line 155
  __cil_tmp21 = (unsigned long )sw_context;
#line 155
  __cil_tmp22 = __cil_tmp21 + 88;
#line 155
  __cil_tmp23 = *((struct ttm_object_file **)__cil_tmp22);
#line 155
  __cil_tmp24 = *sid;
#line 155
  ret = vmw_user_surface_lookup_handle(dev_priv, __cil_tmp23, __cil_tmp24, & srf);
#line 158
  __cil_tmp25 = ret != 0;
#line 158
  __cil_tmp26 = ! __cil_tmp25;
#line 158
  __cil_tmp27 = ! __cil_tmp26;
#line 158
  __cil_tmp28 = (long )__cil_tmp27;
#line 158
  tmp___9 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 158
  if (tmp___9) {
    {
#line 159
    __cil_tmp29 = *sid;
#line 159
    __cil_tmp30 = (unsigned long )sid;
#line 159
    drm_err("vmw_cmd_sid_check", "Could ot find or use surface 0x%08x address 0x%08lx\n",
            __cil_tmp29, __cil_tmp30);
    }
#line 163
    return (ret);
  } else {

  }
  {
#line 166
  __cil_tmp31 = & srf;
#line 166
  __cil_tmp32 = *__cil_tmp31;
#line 166
  ret = vmw_surface_validate(dev_priv, __cil_tmp32);
#line 167
  __cil_tmp33 = ret != 0;
#line 167
  __cil_tmp34 = ! __cil_tmp33;
#line 167
  __cil_tmp35 = ! __cil_tmp34;
#line 167
  __cil_tmp36 = (long )__cil_tmp35;
#line 167
  tmp___10 = ldv__builtin_expect(__cil_tmp36, 0L);
  }
#line 167
  if (tmp___10) {
#line 168
    if (ret != -512) {
      {
#line 169
      drm_err("vmw_cmd_sid_check", "Could not validate surface.\n");
      }
    } else {

    }
    {
#line 170
    vmw_surface_unreference(& srf);
    }
#line 171
    return (ret);
  } else {

  }
  {
#line 174
  __cil_tmp37 = (unsigned long )sw_context;
#line 174
  __cil_tmp38 = __cil_tmp37 + 72;
#line 174
  *((uint32_t *)__cil_tmp38) = *sid;
#line 175
  __cil_tmp39 = (unsigned long )sw_context;
#line 175
  __cil_tmp40 = __cil_tmp39 + 80;
#line 175
  *((bool *)__cil_tmp40) = (bool )1;
#line 176
  __cil_tmp41 = (unsigned long )sw_context;
#line 176
  __cil_tmp42 = __cil_tmp41 + 76;
#line 176
  __cil_tmp43 = 0 + 24;
#line 176
  __cil_tmp44 = & srf;
#line 176
  __cil_tmp45 = *__cil_tmp44;
#line 176
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 176
  __cil_tmp47 = __cil_tmp46 + __cil_tmp43;
#line 176
  __cil_tmp48 = *((int *)__cil_tmp47);
#line 176
  *((uint32_t *)__cil_tmp42) = (uint32_t )__cil_tmp48;
#line 177
  __cil_tmp49 = (unsigned long )sw_context;
#line 177
  __cil_tmp50 = __cil_tmp49 + 76;
#line 177
  *sid = *((uint32_t *)__cil_tmp50);
#line 179
  __cil_tmp51 = & res;
#line 179
  __cil_tmp52 = & srf;
#line 179
  __cil_tmp53 = *__cil_tmp52;
#line 179
  *__cil_tmp51 = (struct vmw_resource *)__cil_tmp53;
#line 180
  vmw_resource_to_validate_list(sw_context, & res);
  }
#line 182
  return (0);
}
}
#line 186 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                           SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd *cmd ;
  int ret ;
  long tmp___7 ;
  SVGA3dCmdHeader    *__mptr ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  struct vmw_sid_cmd *__cil_tmp12 ;
  SVGA3dCmdHeader *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32 *__cil_tmp20 ;

  {
  {
#line 196
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 197
  __cil_tmp8 = ret != 0;
#line 197
  __cil_tmp9 = ! __cil_tmp8;
#line 197
  __cil_tmp10 = ! __cil_tmp9;
#line 197
  __cil_tmp11 = (long )__cil_tmp10;
#line 197
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 0L);
  }
#line 197
  if (tmp___7) {
#line 198
    return (ret);
  } else {

  }
  {
#line 200
  __mptr = (SVGA3dCmdHeader    *)header;
#line 200
  __cil_tmp12 = (struct vmw_sid_cmd *)0;
#line 200
  __cil_tmp13 = (SVGA3dCmdHeader *)__cil_tmp12;
#line 200
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 200
  __cil_tmp15 = (char *)__mptr;
#line 200
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
#line 200
  cmd = (struct vmw_sid_cmd *)__cil_tmp16;
#line 201
  __cil_tmp17 = 8 + 8;
#line 201
  __cil_tmp18 = (unsigned long )cmd;
#line 201
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 201
  __cil_tmp20 = (uint32 *)__cil_tmp19;
#line 201
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp20);
  }
#line 202
  return (ret);
}
}
#line 205 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___0 *__cil_tmp9 ;
  SVGA3dCmdHeader *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32 *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32 *__cil_tmp24 ;

  {
  {
#line 215
  __mptr = (SVGA3dCmdHeader    *)header;
#line 215
  __cil_tmp9 = (struct vmw_sid_cmd___0 *)0;
#line 215
  __cil_tmp10 = (SVGA3dCmdHeader *)__cil_tmp9;
#line 215
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 215
  __cil_tmp12 = (char *)__mptr;
#line 215
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 215
  cmd = (struct vmw_sid_cmd___0 *)__cil_tmp13;
#line 216
  __cil_tmp14 = (unsigned long )cmd;
#line 216
  __cil_tmp15 = __cil_tmp14 + 8;
#line 216
  __cil_tmp16 = (uint32 *)__cil_tmp15;
#line 216
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp16);
#line 217
  __cil_tmp17 = ret != 0;
#line 217
  __cil_tmp18 = ! __cil_tmp17;
#line 217
  __cil_tmp19 = ! __cil_tmp18;
#line 217
  __cil_tmp20 = (long )__cil_tmp19;
#line 217
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 217
  if (tmp___7) {
#line 218
    return (ret);
  } else {

  }
  {
#line 219
  __cil_tmp21 = 8 + 12;
#line 219
  __cil_tmp22 = (unsigned long )cmd;
#line 219
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 219
  __cil_tmp24 = (uint32 *)__cil_tmp23;
#line 219
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp24);
  }
#line 219
  return (tmp___8);
}
}
#line 222 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                     SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___1 *cmd ;
  int ret ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___1 *__cil_tmp9 ;
  SVGA3dCmdHeader *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32 *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32 *__cil_tmp24 ;

  {
  {
#line 232
  __mptr = (SVGA3dCmdHeader    *)header;
#line 232
  __cil_tmp9 = (struct vmw_sid_cmd___1 *)0;
#line 232
  __cil_tmp10 = (SVGA3dCmdHeader *)__cil_tmp9;
#line 232
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 232
  __cil_tmp12 = (char *)__mptr;
#line 232
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 232
  cmd = (struct vmw_sid_cmd___1 *)__cil_tmp13;
#line 233
  __cil_tmp14 = (unsigned long )cmd;
#line 233
  __cil_tmp15 = __cil_tmp14 + 8;
#line 233
  __cil_tmp16 = (uint32 *)__cil_tmp15;
#line 233
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp16);
#line 234
  __cil_tmp17 = ret != 0;
#line 234
  __cil_tmp18 = ! __cil_tmp17;
#line 234
  __cil_tmp19 = ! __cil_tmp18;
#line 234
  __cil_tmp20 = (long )__cil_tmp19;
#line 234
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 234
  if (tmp___7) {
#line 235
    return (ret);
  } else {

  }
  {
#line 236
  __cil_tmp21 = 8 + 12;
#line 236
  __cil_tmp22 = (unsigned long )cmd;
#line 236
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 236
  __cil_tmp24 = (uint32 *)__cil_tmp23;
#line 236
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp24);
  }
#line 236
  return (tmp___8);
}
}
#line 239 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                         SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___2 *cmd ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___2 *__cil_tmp8 ;
  SVGA3dCmdHeader *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  uint32 __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32 *__cil_tmp23 ;

  {
  {
#line 248
  __mptr = (SVGA3dCmdHeader    *)header;
#line 248
  __cil_tmp8 = (struct vmw_sid_cmd___2 *)0;
#line 248
  __cil_tmp9 = (SVGA3dCmdHeader *)__cil_tmp8;
#line 248
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 248
  __cil_tmp11 = (char *)__mptr;
#line 248
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 248
  cmd = (struct vmw_sid_cmd___2 *)__cil_tmp12;
#line 250
  __cil_tmp13 = (unsigned long )sw_context;
#line 250
  __cil_tmp14 = __cil_tmp13 + 61;
#line 250
  __cil_tmp15 = *((bool *)__cil_tmp14);
#line 250
  __cil_tmp16 = ! __cil_tmp15;
#line 250
  __cil_tmp17 = ! __cil_tmp16;
#line 250
  __cil_tmp18 = ! __cil_tmp17;
#line 250
  __cil_tmp19 = (long )__cil_tmp18;
#line 250
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 250
  if (tmp___7) {
    {
#line 251
    __cil_tmp20 = *((uint32 *)cmd);
#line 251
    drm_err("vmw_cmd_blt_surf_screen_check", "Kernel only SVGA3d command: %u.\n",
            __cil_tmp20);
    }
#line 252
    return (-1);
  } else {

  }
  {
#line 255
  __cil_tmp21 = (unsigned long )cmd;
#line 255
  __cil_tmp22 = __cil_tmp21 + 8;
#line 255
  __cil_tmp23 = (uint32 *)__cil_tmp22;
#line 255
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp23);
  }
#line 255
  return (tmp___8);
}
}
#line 258 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_present_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                 SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___3 *cmd ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___3 *__cil_tmp8 ;
  SVGA3dCmdHeader *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  uint32 __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32 *__cil_tmp23 ;

  {
  {
#line 268
  __mptr = (SVGA3dCmdHeader    *)header;
#line 268
  __cil_tmp8 = (struct vmw_sid_cmd___3 *)0;
#line 268
  __cil_tmp9 = (SVGA3dCmdHeader *)__cil_tmp8;
#line 268
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 268
  __cil_tmp11 = (char *)__mptr;
#line 268
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 268
  cmd = (struct vmw_sid_cmd___3 *)__cil_tmp12;
#line 270
  __cil_tmp13 = (unsigned long )sw_context;
#line 270
  __cil_tmp14 = __cil_tmp13 + 61;
#line 270
  __cil_tmp15 = *((bool *)__cil_tmp14);
#line 270
  __cil_tmp16 = ! __cil_tmp15;
#line 270
  __cil_tmp17 = ! __cil_tmp16;
#line 270
  __cil_tmp18 = ! __cil_tmp17;
#line 270
  __cil_tmp19 = (long )__cil_tmp18;
#line 270
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 270
  if (tmp___7) {
    {
#line 271
    __cil_tmp20 = *((uint32 *)cmd);
#line 271
    drm_err("vmw_cmd_present_check", "Kernel only SVGA3d command: %u.\n", __cil_tmp20);
    }
#line 272
    return (-1);
  } else {

  }
  {
#line 275
  __cil_tmp21 = (unsigned long )cmd;
#line 275
  __cil_tmp22 = __cil_tmp21 + 8;
#line 275
  __cil_tmp23 = (uint32 *)__cil_tmp22;
#line 275
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp23);
  }
#line 275
  return (tmp___8);
}
}
#line 294 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv , uint32_t cid ,
                                       struct ttm_buffer_object *new_query_bo , struct vmw_sw_context *sw_context ) 
{ int ret ;
  bool add_cid ;
  uint32_t cid_to_add ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  struct vmw_resource *ctx ;
  int tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_buffer_object *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_buffer_object *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct ttm_buffer_object *__cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  void *__cil_tmp58 ;
  uint32_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct ttm_buffer_object *__cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  void *__cil_tmp70 ;
  uint32_t *__cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  uint32_t __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  struct list_head    *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct list_head *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct list_head *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct ttm_buffer_object *__cil_tmp102 ;
  uint32_t __cil_tmp103 ;
  void *__cil_tmp104 ;
  uint32_t *__cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  long __cil_tmp109 ;

  {
  {
#line 300
  add_cid = (bool )0;
#line 303
  __cil_tmp19 = (unsigned long )sw_context;
#line 303
  __cil_tmp20 = __cil_tmp19 + 131256;
#line 303
  __cil_tmp21 = *((struct ttm_buffer_object **)__cil_tmp20);
#line 303
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 303
  __cil_tmp23 = (unsigned long )new_query_bo;
#line 303
  __cil_tmp24 = __cil_tmp23 != __cil_tmp22;
#line 303
  __cil_tmp25 = ! __cil_tmp24;
#line 303
  __cil_tmp26 = ! __cil_tmp25;
#line 303
  __cil_tmp27 = (long )__cil_tmp26;
#line 303
  tmp___12 = ldv__builtin_expect(__cil_tmp27, 0L);
  }
#line 303
  if (tmp___12) {
    {
#line 305
    __cil_tmp28 = (unsigned long )new_query_bo;
#line 305
    __cil_tmp29 = __cil_tmp28 + 40;
#line 305
    __cil_tmp30 = *((unsigned long *)__cil_tmp29);
#line 305
    __cil_tmp31 = __cil_tmp30 > 4UL;
#line 305
    __cil_tmp32 = ! __cil_tmp31;
#line 305
    __cil_tmp33 = ! __cil_tmp32;
#line 305
    __cil_tmp34 = (long )__cil_tmp33;
#line 305
    tmp___7 = ldv__builtin_expect(__cil_tmp34, 0L);
    }
#line 305
    if (tmp___7) {
      {
#line 306
      drm_err("vmw_query_bo_switch_prepare", "Query buffer too large.\n");
      }
#line 307
      return (-22);
    } else {

    }
    {
#line 310
    __cil_tmp35 = (void *)0;
#line 310
    __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 310
    __cil_tmp37 = (unsigned long )sw_context;
#line 310
    __cil_tmp38 = __cil_tmp37 + 131256;
#line 310
    __cil_tmp39 = *((struct ttm_buffer_object **)__cil_tmp38);
#line 310
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 310
    __cil_tmp41 = __cil_tmp40 != __cil_tmp36;
#line 310
    __cil_tmp42 = ! __cil_tmp41;
#line 310
    __cil_tmp43 = ! __cil_tmp42;
#line 310
    __cil_tmp44 = (long )__cil_tmp43;
#line 310
    tmp___10 = ldv__builtin_expect(__cil_tmp44, 0L);
    }
#line 310
    if (tmp___10) {
      {
#line 311
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 311
        __cil_tmp45 = (unsigned long )sw_context;
#line 311
        __cil_tmp46 = __cil_tmp45 + 131268;
#line 311
        __cil_tmp47 = *((bool *)__cil_tmp46);
#line 311
        __cil_tmp48 = ! __cil_tmp47;
#line 311
        __cil_tmp49 = ! __cil_tmp48;
#line 311
        __cil_tmp50 = ! __cil_tmp49;
#line 311
        __cil_tmp51 = (long )__cil_tmp50;
#line 311
        tmp___8 = ldv__builtin_expect(__cil_tmp51, 0L);
        }
#line 311
        if (tmp___8) {
          {
#line 311
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 311
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                                 "i" (311), "i" (12UL));
            {
#line 311
            while (1) {
              while_continue___1: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 311
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {

        }
#line 311
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 312
      add_cid = (bool )1;
#line 313
      __cil_tmp52 = (unsigned long )sw_context;
#line 313
      __cil_tmp53 = __cil_tmp52 + 131264;
#line 313
      cid_to_add = *((uint32_t *)__cil_tmp53);
#line 314
      __cil_tmp54 = (unsigned long )sw_context;
#line 314
      __cil_tmp55 = __cil_tmp54 + 131256;
#line 314
      __cil_tmp56 = *((struct ttm_buffer_object **)__cil_tmp55);
#line 314
      __cil_tmp57 = (uint32_t )1;
#line 314
      __cil_tmp58 = (void *)0;
#line 314
      __cil_tmp59 = (uint32_t *)__cil_tmp58;
#line 314
      ret = vmw_bo_to_validate_list(sw_context, __cil_tmp56, __cil_tmp57, __cil_tmp59);
#line 318
      __cil_tmp60 = ret != 0;
#line 318
      __cil_tmp61 = ! __cil_tmp60;
#line 318
      __cil_tmp62 = ! __cil_tmp61;
#line 318
      __cil_tmp63 = (long )__cil_tmp62;
#line 318
      tmp___9 = ldv__builtin_expect(__cil_tmp63, 0L);
      }
#line 318
      if (tmp___9) {
#line 319
        return (ret);
      } else {

      }
    } else {

    }
    {
#line 321
    __cil_tmp64 = (unsigned long )sw_context;
#line 321
    __cil_tmp65 = __cil_tmp64 + 131256;
#line 321
    *((struct ttm_buffer_object **)__cil_tmp65) = new_query_bo;
#line 323
    __cil_tmp66 = (unsigned long )dev_priv;
#line 323
    __cil_tmp67 = __cil_tmp66 + 134744;
#line 323
    __cil_tmp68 = *((struct ttm_buffer_object **)__cil_tmp67);
#line 323
    __cil_tmp69 = (uint32_t )1;
#line 323
    __cil_tmp70 = (void *)0;
#line 323
    __cil_tmp71 = (uint32_t *)__cil_tmp70;
#line 323
    ret = vmw_bo_to_validate_list(sw_context, __cil_tmp68, __cil_tmp69, __cil_tmp71);
#line 327
    __cil_tmp72 = ret != 0;
#line 327
    __cil_tmp73 = ! __cil_tmp72;
#line 327
    __cil_tmp74 = ! __cil_tmp73;
#line 327
    __cil_tmp75 = (long )__cil_tmp74;
#line 327
    tmp___11 = ldv__builtin_expect(__cil_tmp75, 0L);
    }
#line 327
    if (tmp___11) {
#line 328
      return (ret);
    } else {

    }
  } else {

  }
  {
#line 332
  __cil_tmp76 = (unsigned long )sw_context;
#line 332
  __cil_tmp77 = __cil_tmp76 + 131264;
#line 332
  __cil_tmp78 = *((uint32_t *)__cil_tmp77);
#line 332
  if (cid != __cil_tmp78) {
    {
#line 332
    __cil_tmp79 = (unsigned long )sw_context;
#line 332
    __cil_tmp80 = __cil_tmp79 + 131268;
#line 332
    if (*((bool *)__cil_tmp80)) {
#line 332
      tmp___13 = 1;
    } else {
#line 332
      tmp___13 = 0;
    }
    }
  } else {
#line 332
    tmp___13 = 0;
  }
  }
  {
#line 332
  __cil_tmp81 = (long )tmp___13;
#line 332
  tmp___14 = ldv__builtin_expect(__cil_tmp81, 0L);
  }
#line 332
  if (tmp___14) {
#line 334
    add_cid = (bool )1;
#line 335
    __cil_tmp82 = (unsigned long )sw_context;
#line 335
    __cil_tmp83 = __cil_tmp82 + 131264;
#line 335
    cid_to_add = *((uint32_t *)__cil_tmp83);
  } else {

  }
#line 338
  __cil_tmp84 = (unsigned long )sw_context;
#line 338
  __cil_tmp85 = __cil_tmp84 + 131264;
#line 338
  *((uint32_t *)__cil_tmp85) = cid;
#line 339
  __cil_tmp86 = (unsigned long )sw_context;
#line 339
  __cil_tmp87 = __cil_tmp86 + 131268;
#line 339
  *((bool *)__cil_tmp87) = (bool )1;
#line 341
  if (add_cid) {
    {
#line 342
    __cil_tmp88 = (unsigned long )sw_context;
#line 342
    __cil_tmp89 = __cil_tmp88 + 64;
#line 342
    ctx = *((struct vmw_resource **)__cil_tmp89);
#line 344
    __cil_tmp90 = (unsigned long )ctx;
#line 344
    __cil_tmp91 = __cil_tmp90 + 80;
#line 344
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
#line 344
    __cil_tmp93 = (struct list_head    *)__cil_tmp92;
#line 344
    tmp___15 = list_empty(__cil_tmp93);
    }
#line 344
    if (tmp___15) {
      {
#line 345
      __cil_tmp94 = (unsigned long )ctx;
#line 345
      __cil_tmp95 = __cil_tmp94 + 80;
#line 345
      __cil_tmp96 = (struct list_head *)__cil_tmp95;
#line 345
      __cil_tmp97 = (unsigned long )sw_context;
#line 345
      __cil_tmp98 = __cil_tmp97 + 131240;
#line 345
      __cil_tmp99 = (struct list_head *)__cil_tmp98;
#line 345
      list_add_tail(__cil_tmp96, __cil_tmp99);
      }
    } else {

    }
    {
#line 347
    __cil_tmp100 = (unsigned long )dev_priv;
#line 347
    __cil_tmp101 = __cil_tmp100 + 134744;
#line 347
    __cil_tmp102 = *((struct ttm_buffer_object **)__cil_tmp101);
#line 347
    __cil_tmp103 = (uint32_t )1;
#line 347
    __cil_tmp104 = (void *)0;
#line 347
    __cil_tmp105 = (uint32_t *)__cil_tmp104;
#line 347
    ret = vmw_bo_to_validate_list(sw_context, __cil_tmp102, __cil_tmp103, __cil_tmp105);
#line 351
    __cil_tmp106 = ret != 0;
#line 351
    __cil_tmp107 = ! __cil_tmp106;
#line 351
    __cil_tmp108 = ! __cil_tmp107;
#line 351
    __cil_tmp109 = (long )__cil_tmp108;
#line 351
    tmp___16 = ldv__builtin_expect(__cil_tmp109, 0L);
    }
#line 351
    if (tmp___16) {
#line 352
      return (ret);
    } else {

    }
  } else {

  }
#line 354
  return (0);
}
}
#line 376 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_query_bo_switch_commit(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct vmw_resource *ctx ;
  struct vmw_resource *next_ctx ;
  int ret ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct vmw_resource *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  struct vmw_resource *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct list_head *__cil_tmp46 ;
  struct list_head    *__cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct list_head *__cil_tmp59 ;
  struct vmw_resource *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct ttm_buffer_object *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct ttm_buffer_object *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object *__cil_tmp79 ;
  bool __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct ttm_buffer_object **__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct ttm_buffer_object *__cil_tmp86 ;
  bool __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct ttm_buffer_object *__cil_tmp90 ;
  bool __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct ttm_buffer_object *__cil_tmp102 ;

  {
#line 388
  __cil_tmp13 = (unsigned long )sw_context;
#line 388
  __cil_tmp14 = __cil_tmp13 + 131240;
#line 388
  __cil_tmp15 = *((struct list_head **)__cil_tmp14);
#line 388
  __mptr = (struct list_head    *)__cil_tmp15;
#line 388
  __cil_tmp16 = (struct vmw_resource *)0;
#line 388
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 388
  __cil_tmp18 = __cil_tmp17 + 80;
#line 388
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
#line 388
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 388
  __cil_tmp21 = (char *)__mptr;
#line 388
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
#line 388
  ctx = (struct vmw_resource *)__cil_tmp22;
#line 388
  __cil_tmp23 = (unsigned long )ctx;
#line 388
  __cil_tmp24 = __cil_tmp23 + 80;
#line 388
  __cil_tmp25 = *((struct list_head **)__cil_tmp24);
#line 388
  __mptr___0 = (struct list_head    *)__cil_tmp25;
#line 388
  __cil_tmp26 = (struct vmw_resource *)0;
#line 388
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 388
  __cil_tmp28 = __cil_tmp27 + 80;
#line 388
  __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 388
  __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 388
  __cil_tmp31 = (char *)__mptr___0;
#line 388
  __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 388
  next_ctx = (struct vmw_resource *)__cil_tmp32;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 388
    __cil_tmp33 = (unsigned long )sw_context;
#line 388
    __cil_tmp34 = __cil_tmp33 + 131240;
#line 388
    __cil_tmp35 = (struct list_head *)__cil_tmp34;
#line 388
    __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 388
    __cil_tmp37 = (unsigned long )ctx;
#line 388
    __cil_tmp38 = __cil_tmp37 + 80;
#line 388
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
#line 388
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 388
    if (__cil_tmp40 != __cil_tmp36) {

    } else {
#line 388
      goto while_break;
    }
    }
    {
#line 390
    __cil_tmp41 = (unsigned long )ctx;
#line 390
    __cil_tmp42 = __cil_tmp41 + 80;
#line 390
    __cil_tmp43 = (struct list_head *)__cil_tmp42;
#line 390
    list_del_init(__cil_tmp43);
    }
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 392
      __cil_tmp44 = (unsigned long )ctx;
#line 392
      __cil_tmp45 = __cil_tmp44 + 64;
#line 392
      __cil_tmp46 = (struct list_head *)__cil_tmp45;
#line 392
      __cil_tmp47 = (struct list_head    *)__cil_tmp46;
#line 392
      tmp___7 = list_empty(__cil_tmp47);
      }
#line 392
      if (tmp___7) {
#line 392
        tmp___8 = 1;
      } else {
#line 392
        tmp___8 = 0;
      }
      {
#line 392
      __cil_tmp48 = (long )tmp___8;
#line 392
      tmp___9 = ldv__builtin_expect(__cil_tmp48, 0L);
      }
#line 392
      if (tmp___9) {
        {
#line 392
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 392
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                               "i" (392), "i" (12UL));
          {
#line 392
          while (1) {
            while_continue___2: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 392
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {

      }
#line 392
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 394
    __cil_tmp49 = (unsigned long )ctx;
#line 394
    __cil_tmp50 = __cil_tmp49 + 24;
#line 394
    __cil_tmp51 = *((int *)__cil_tmp50);
#line 394
    __cil_tmp52 = (uint32_t )__cil_tmp51;
#line 394
    ret = vmw_fifo_emit_dummy_query(dev_priv, __cil_tmp52);
#line 396
    __cil_tmp53 = ret != 0;
#line 396
    __cil_tmp54 = ! __cil_tmp53;
#line 396
    __cil_tmp55 = ! __cil_tmp54;
#line 396
    __cil_tmp56 = (long )__cil_tmp55;
#line 396
    tmp___10 = ldv__builtin_expect(__cil_tmp56, 0L);
    }
#line 396
    if (tmp___10) {
      {
#line 397
      drm_err("vmw_query_bo_switch_commit", "Out of fifo space for dummy query.\n");
      }
    } else {

    }
#line 388
    ctx = next_ctx;
#line 388
    __cil_tmp57 = (unsigned long )next_ctx;
#line 388
    __cil_tmp58 = __cil_tmp57 + 80;
#line 388
    __cil_tmp59 = *((struct list_head **)__cil_tmp58);
#line 388
    __mptr___1 = (struct list_head    *)__cil_tmp59;
#line 388
    __cil_tmp60 = (struct vmw_resource *)0;
#line 388
    __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 388
    __cil_tmp62 = __cil_tmp61 + 80;
#line 388
    __cil_tmp63 = (struct list_head *)__cil_tmp62;
#line 388
    __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 388
    __cil_tmp65 = (char *)__mptr___1;
#line 388
    __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
#line 388
    next_ctx = (struct vmw_resource *)__cil_tmp66;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  __cil_tmp67 = (unsigned long )sw_context;
#line 400
  __cil_tmp68 = __cil_tmp67 + 131256;
#line 400
  __cil_tmp69 = *((struct ttm_buffer_object **)__cil_tmp68);
#line 400
  __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 400
  __cil_tmp71 = (unsigned long )dev_priv;
#line 400
  __cil_tmp72 = __cil_tmp71 + 134752;
#line 400
  __cil_tmp73 = *((struct ttm_buffer_object **)__cil_tmp72);
#line 400
  __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 400
  if (__cil_tmp74 != __cil_tmp70) {
    {
#line 401
    __cil_tmp75 = (unsigned long )dev_priv;
#line 401
    __cil_tmp76 = __cil_tmp75 + 134752;
#line 401
    if (*((struct ttm_buffer_object **)__cil_tmp76)) {
      {
#line 402
      __cil_tmp77 = (unsigned long )dev_priv;
#line 402
      __cil_tmp78 = __cil_tmp77 + 134752;
#line 402
      __cil_tmp79 = *((struct ttm_buffer_object **)__cil_tmp78);
#line 402
      __cil_tmp80 = (bool )0;
#line 402
      vmw_bo_pin(__cil_tmp79, __cil_tmp80);
#line 403
      __cil_tmp81 = (unsigned long )dev_priv;
#line 403
      __cil_tmp82 = __cil_tmp81 + 134752;
#line 403
      __cil_tmp83 = (struct ttm_buffer_object **)__cil_tmp82;
#line 403
      ttm_bo_unref(__cil_tmp83);
      }
    } else {

    }
    }
    {
#line 406
    __cil_tmp84 = (unsigned long )sw_context;
#line 406
    __cil_tmp85 = __cil_tmp84 + 131256;
#line 406
    __cil_tmp86 = *((struct ttm_buffer_object **)__cil_tmp85);
#line 406
    __cil_tmp87 = (bool )1;
#line 406
    vmw_bo_pin(__cil_tmp86, __cil_tmp87);
#line 414
    __cil_tmp88 = (unsigned long )dev_priv;
#line 414
    __cil_tmp89 = __cil_tmp88 + 134744;
#line 414
    __cil_tmp90 = *((struct ttm_buffer_object **)__cil_tmp89);
#line 414
    __cil_tmp91 = (bool )1;
#line 414
    vmw_bo_pin(__cil_tmp90, __cil_tmp91);
#line 415
    __cil_tmp92 = (unsigned long )dev_priv;
#line 415
    __cil_tmp93 = __cil_tmp92 + 134764;
#line 415
    *((bool *)__cil_tmp93) = (bool )1;
#line 417
    __cil_tmp94 = (unsigned long )dev_priv;
#line 417
    __cil_tmp95 = __cil_tmp94 + 134760;
#line 417
    __cil_tmp96 = (unsigned long )sw_context;
#line 417
    __cil_tmp97 = __cil_tmp96 + 131264;
#line 417
    *((uint32_t *)__cil_tmp95) = *((uint32_t *)__cil_tmp97);
#line 418
    __cil_tmp98 = (unsigned long )dev_priv;
#line 418
    __cil_tmp99 = __cil_tmp98 + 134752;
#line 418
    __cil_tmp100 = (unsigned long )sw_context;
#line 418
    __cil_tmp101 = __cil_tmp100 + 131256;
#line 418
    __cil_tmp102 = *((struct ttm_buffer_object **)__cil_tmp101);
#line 418
    *((struct ttm_buffer_object **)__cil_tmp99) = ttm_bo_reference(__cil_tmp102);
    }
  } else {

  }
  }
#line 421
  return;
}
}
#line 431 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_query_switch_backoff(struct vmw_sw_context *sw_context ) 
{ struct list_head *list ;
  struct list_head *next ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct list_head *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
#line 435
  __cil_tmp4 = (unsigned long )sw_context;
#line 435
  __cil_tmp5 = __cil_tmp4 + 131240;
#line 435
  list = *((struct list_head **)__cil_tmp5);
#line 435
  next = *((struct list_head **)list);
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    __cil_tmp6 = (unsigned long )sw_context;
#line 435
    __cil_tmp7 = __cil_tmp6 + 131240;
#line 435
    __cil_tmp8 = (struct list_head *)__cil_tmp7;
#line 435
    __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 435
    __cil_tmp10 = (unsigned long )list;
#line 435
    if (__cil_tmp10 != __cil_tmp9) {

    } else {
#line 435
      goto while_break;
    }
    }
    {
#line 436
    list_del_init(list);
#line 435
    list = next;
#line 435
    next = *((struct list_head **)list);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  return;
}
}
#line 440 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_translate_guest_ptr(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                   SVGAGuestPtr *ptr , struct vmw_dma_buffer **vmw_bo_p ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  uint32_t handle ;
  struct vmw_relocation *reloc ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  long tmp___10 ;
  struct vmw_dma_buffer **__cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct ttm_object_file *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct vmw_dma_buffer **__cil_tmp23 ;
  struct vmw_dma_buffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  uint32_t *__cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  long __cil_tmp50 ;
  struct vmw_dma_buffer **__cil_tmp51 ;
  void *__cil_tmp52 ;

  {
  {
#line 445
  __cil_tmp14 = & vmw_bo;
#line 445
  __cil_tmp15 = (void *)0;
#line 445
  *__cil_tmp14 = (struct vmw_dma_buffer *)__cil_tmp15;
#line 447
  handle = *((uint32 *)ptr);
#line 451
  __cil_tmp16 = (unsigned long )sw_context;
#line 451
  __cil_tmp17 = __cil_tmp16 + 88;
#line 451
  __cil_tmp18 = *((struct ttm_object_file **)__cil_tmp17);
#line 451
  ret = vmw_user_dmabuf_lookup(__cil_tmp18, handle, & vmw_bo);
#line 452
  __cil_tmp19 = ret != 0;
#line 452
  __cil_tmp20 = ! __cil_tmp19;
#line 452
  __cil_tmp21 = ! __cil_tmp20;
#line 452
  __cil_tmp22 = (long )__cil_tmp21;
#line 452
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 452
  if (tmp___7) {
    {
#line 453
    drm_err("vmw_translate_guest_ptr", "Could not find or use GMR region.\n");
    }
#line 454
    return (-22);
  } else {

  }
  {
#line 456
  __cil_tmp23 = & vmw_bo;
#line 456
  __cil_tmp24 = *__cil_tmp23;
#line 456
  bo = (struct ttm_buffer_object *)__cil_tmp24;
#line 458
  __cil_tmp25 = (unsigned long )sw_context;
#line 458
  __cil_tmp26 = __cil_tmp25 + 32880;
#line 458
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 458
  __cil_tmp28 = __cil_tmp27 >= 2048U;
#line 458
  __cil_tmp29 = ! __cil_tmp28;
#line 458
  __cil_tmp30 = ! __cil_tmp29;
#line 458
  __cil_tmp31 = (long )__cil_tmp30;
#line 458
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 458
  if (tmp___8) {
    {
#line 459
    drm_err("vmw_translate_guest_ptr", "Max number relocations per submission exceeded\n");
#line 461
    ret = -22;
    }
#line 462
    goto out_no_reloc;
  } else {

  }
  {
#line 465
  __cil_tmp32 = (unsigned long )sw_context;
#line 465
  __cil_tmp33 = __cil_tmp32 + 32880;
#line 465
  tmp___9 = *((uint32_t *)__cil_tmp33);
#line 465
  __cil_tmp34 = (unsigned long )sw_context;
#line 465
  __cil_tmp35 = __cil_tmp34 + 32880;
#line 465
  __cil_tmp36 = (unsigned long )sw_context;
#line 465
  __cil_tmp37 = __cil_tmp36 + 32880;
#line 465
  __cil_tmp38 = *((uint32_t *)__cil_tmp37);
#line 465
  *((uint32_t *)__cil_tmp35) = __cil_tmp38 + 1U;
#line 465
  __cil_tmp39 = tmp___9 * 16UL;
#line 465
  __cil_tmp40 = 112 + __cil_tmp39;
#line 465
  __cil_tmp41 = (unsigned long )sw_context;
#line 465
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 465
  reloc = (struct vmw_relocation *)__cil_tmp42;
#line 466
  *((SVGAGuestPtr **)reloc) = ptr;
#line 468
  __cil_tmp43 = (uint32_t )1;
#line 468
  __cil_tmp44 = (unsigned long )reloc;
#line 468
  __cil_tmp45 = __cil_tmp44 + 8;
#line 468
  __cil_tmp46 = (uint32_t *)__cil_tmp45;
#line 468
  ret = vmw_bo_to_validate_list(sw_context, bo, __cil_tmp43, __cil_tmp46);
#line 470
  __cil_tmp47 = ret != 0;
#line 470
  __cil_tmp48 = ! __cil_tmp47;
#line 470
  __cil_tmp49 = ! __cil_tmp48;
#line 470
  __cil_tmp50 = (long )__cil_tmp49;
#line 470
  tmp___10 = ldv__builtin_expect(__cil_tmp50, 0L);
  }
#line 470
  if (tmp___10) {
#line 471
    goto out_no_reloc;
  } else {

  }
#line 473
  __cil_tmp51 = & vmw_bo;
#line 473
  *vmw_bo_p = *__cil_tmp51;
#line 474
  return (0);
  out_no_reloc: 
  {
#line 477
  vmw_dmabuf_unreference(& vmw_bo);
#line 478
  __cil_tmp52 = (void *)0;
#line 478
  vmw_bo_p = (struct vmw_dma_buffer **)__cil_tmp52;
  }
#line 479
  return (ret);
}
}
#line 482 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_end_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  struct vmw_query_cmd *__cil_tmp10 ;
  SVGA3dCmdHeader *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  SVGAGuestPtr *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32 __cil_tmp29 ;
  struct vmw_dma_buffer **__cil_tmp30 ;
  struct vmw_dma_buffer *__cil_tmp31 ;
  struct ttm_buffer_object *__cil_tmp32 ;

  {
  {
#line 493
  __mptr = (SVGA3dCmdHeader    *)header;
#line 493
  __cil_tmp10 = (struct vmw_query_cmd *)0;
#line 493
  __cil_tmp11 = (SVGA3dCmdHeader *)__cil_tmp10;
#line 493
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 493
  __cil_tmp13 = (char *)__mptr;
#line 493
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 493
  cmd = (struct vmw_query_cmd *)__cil_tmp14;
#line 494
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 495
  __cil_tmp15 = ret != 0;
#line 495
  __cil_tmp16 = ! __cil_tmp15;
#line 495
  __cil_tmp17 = ! __cil_tmp16;
#line 495
  __cil_tmp18 = (long )__cil_tmp17;
#line 495
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  }
#line 495
  if (tmp___7) {
#line 496
    return (ret);
  } else {

  }
  {
#line 498
  __cil_tmp19 = 8 + 8;
#line 498
  __cil_tmp20 = (unsigned long )cmd;
#line 498
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 498
  __cil_tmp22 = (SVGAGuestPtr *)__cil_tmp21;
#line 498
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp22, & vmw_bo);
#line 501
  __cil_tmp23 = ret != 0;
#line 501
  __cil_tmp24 = ! __cil_tmp23;
#line 501
  __cil_tmp25 = ! __cil_tmp24;
#line 501
  __cil_tmp26 = (long )__cil_tmp25;
#line 501
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 501
  if (tmp___8) {
#line 502
    return (ret);
  } else {

  }
  {
#line 504
  __cil_tmp27 = (unsigned long )cmd;
#line 504
  __cil_tmp28 = __cil_tmp27 + 8;
#line 504
  __cil_tmp29 = *((uint32 *)__cil_tmp28);
#line 504
  __cil_tmp30 = & vmw_bo;
#line 504
  __cil_tmp31 = *__cil_tmp30;
#line 504
  __cil_tmp32 = (struct ttm_buffer_object *)__cil_tmp31;
#line 504
  ret = vmw_query_bo_switch_prepare(dev_priv, __cil_tmp29, __cil_tmp32, sw_context);
#line 507
  vmw_dmabuf_unreference(& vmw_bo);
  }
#line 508
  return (ret);
}
}
#line 511 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_wait_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd___0 *cmd ;
  int ret ;
  struct vmw_resource *ctx ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct vmw_query_cmd___0 *__cil_tmp12 ;
  SVGA3dCmdHeader *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  SVGAGuestPtr *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  struct list_head    *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;

  {
  {
#line 523
  __mptr = (SVGA3dCmdHeader    *)header;
#line 523
  __cil_tmp12 = (struct vmw_query_cmd___0 *)0;
#line 523
  __cil_tmp13 = (SVGA3dCmdHeader *)__cil_tmp12;
#line 523
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 523
  __cil_tmp15 = (char *)__mptr;
#line 523
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
#line 523
  cmd = (struct vmw_query_cmd___0 *)__cil_tmp16;
#line 524
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 525
  __cil_tmp17 = ret != 0;
#line 525
  __cil_tmp18 = ! __cil_tmp17;
#line 525
  __cil_tmp19 = ! __cil_tmp18;
#line 525
  __cil_tmp20 = (long )__cil_tmp19;
#line 525
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 525
  if (tmp___7) {
#line 526
    return (ret);
  } else {

  }
  {
#line 528
  __cil_tmp21 = 8 + 8;
#line 528
  __cil_tmp22 = (unsigned long )cmd;
#line 528
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 528
  __cil_tmp24 = (SVGAGuestPtr *)__cil_tmp23;
#line 528
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp24, & vmw_bo);
#line 531
  __cil_tmp25 = ret != 0;
#line 531
  __cil_tmp26 = ! __cil_tmp25;
#line 531
  __cil_tmp27 = ! __cil_tmp26;
#line 531
  __cil_tmp28 = (long )__cil_tmp27;
#line 531
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 531
  if (tmp___8) {
#line 532
    return (ret);
  } else {

  }
  {
#line 534
  vmw_dmabuf_unreference(& vmw_bo);
#line 541
  __cil_tmp29 = (unsigned long )sw_context;
#line 541
  __cil_tmp30 = __cil_tmp29 + 64;
#line 541
  ctx = *((struct vmw_resource **)__cil_tmp30);
#line 542
  __cil_tmp31 = (unsigned long )ctx;
#line 542
  __cil_tmp32 = __cil_tmp31 + 80;
#line 542
  __cil_tmp33 = (struct list_head *)__cil_tmp32;
#line 542
  __cil_tmp34 = (struct list_head    *)__cil_tmp33;
#line 542
  tmp___9 = list_empty(__cil_tmp34);
  }
#line 542
  if (tmp___9) {

  } else {
    {
#line 543
    __cil_tmp35 = (unsigned long )ctx;
#line 543
    __cil_tmp36 = __cil_tmp35 + 80;
#line 543
    __cil_tmp37 = (struct list_head *)__cil_tmp36;
#line 543
    list_del_init(__cil_tmp37);
    }
  }
#line 545
  return (0);
}
}
#line 548 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_dma(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                       SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  struct vmw_surface *srf ;
  struct vmw_dma_cmd *cmd ;
  int ret ;
  struct vmw_resource *res ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  struct vmw_dma_buffer **__cil_tmp13 ;
  void *__cil_tmp14 ;
  struct vmw_surface **__cil_tmp15 ;
  void *__cil_tmp16 ;
  struct vmw_dma_cmd *__cil_tmp17 ;
  SVGA3dCmdHeader *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  SVGAGuestPtr *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  struct vmw_dma_buffer **__cil_tmp29 ;
  struct vmw_dma_buffer *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct ttm_object_file *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32 __cil_tmp37 ;
  struct vmw_surface **__cil_tmp38 ;
  struct vmw_surface *__cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct vmw_surface **__cil_tmp48 ;
  struct vmw_surface *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  int __cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  struct vmw_surface *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct ttm_object_file *__cil_tmp57 ;
  struct vmw_resource **__cil_tmp58 ;
  struct vmw_surface **__cil_tmp59 ;
  struct vmw_surface *__cil_tmp60 ;

  {
  {
#line 552
  __cil_tmp13 = & vmw_bo;
#line 552
  __cil_tmp14 = (void *)0;
#line 552
  *__cil_tmp13 = (struct vmw_dma_buffer *)__cil_tmp14;
#line 554
  __cil_tmp15 = & srf;
#line 554
  __cil_tmp16 = (void *)0;
#line 554
  *__cil_tmp15 = (struct vmw_surface *)__cil_tmp16;
#line 562
  __mptr = (SVGA3dCmdHeader    *)header;
#line 562
  __cil_tmp17 = (struct vmw_dma_cmd *)0;
#line 562
  __cil_tmp18 = (SVGA3dCmdHeader *)__cil_tmp17;
#line 562
  __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 562
  __cil_tmp20 = (char *)__mptr;
#line 562
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
#line 562
  cmd = (struct vmw_dma_cmd *)__cil_tmp21;
#line 563
  __cil_tmp22 = (unsigned long )cmd;
#line 563
  __cil_tmp23 = __cil_tmp22 + 8;
#line 563
  __cil_tmp24 = (SVGAGuestPtr *)__cil_tmp23;
#line 563
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp24, & vmw_bo);
#line 566
  __cil_tmp25 = ret != 0;
#line 566
  __cil_tmp26 = ! __cil_tmp25;
#line 566
  __cil_tmp27 = ! __cil_tmp26;
#line 566
  __cil_tmp28 = (long )__cil_tmp27;
#line 566
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 566
  if (tmp___7) {
#line 567
    return (ret);
  } else {

  }
  {
#line 569
  __cil_tmp29 = & vmw_bo;
#line 569
  __cil_tmp30 = *__cil_tmp29;
#line 569
  bo = (struct ttm_buffer_object *)__cil_tmp30;
#line 570
  __cil_tmp31 = (unsigned long )sw_context;
#line 570
  __cil_tmp32 = __cil_tmp31 + 88;
#line 570
  __cil_tmp33 = *((struct ttm_object_file **)__cil_tmp32);
#line 570
  __cil_tmp34 = 8 + 12;
#line 570
  __cil_tmp35 = (unsigned long )cmd;
#line 570
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
#line 570
  __cil_tmp37 = *((uint32 *)__cil_tmp36);
#line 570
  ret = vmw_user_surface_lookup_handle(dev_priv, __cil_tmp33, __cil_tmp37, & srf);
  }
#line 572
  if (ret) {
    {
#line 573
    drm_err("vmw_cmd_dma", "could not find surface\n");
    }
#line 574
    goto out_no_reloc;
  } else {

  }
  {
#line 577
  __cil_tmp38 = & srf;
#line 577
  __cil_tmp39 = *__cil_tmp38;
#line 577
  ret = vmw_surface_validate(dev_priv, __cil_tmp39);
#line 578
  __cil_tmp40 = ret != 0;
#line 578
  __cil_tmp41 = ! __cil_tmp40;
#line 578
  __cil_tmp42 = ! __cil_tmp41;
#line 578
  __cil_tmp43 = (long )__cil_tmp42;
#line 578
  tmp___8 = ldv__builtin_expect(__cil_tmp43, 0L);
  }
#line 578
  if (tmp___8) {
#line 579
    if (ret != -512) {
      {
#line 580
      drm_err("vmw_cmd_dma", "Culd not validate surface.\n");
      }
    } else {

    }
#line 581
    goto out_no_validate;
  } else {

  }
  {
#line 587
  __cil_tmp44 = 8 + 12;
#line 587
  __cil_tmp45 = (unsigned long )cmd;
#line 587
  __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
#line 587
  __cil_tmp47 = 0 + 24;
#line 587
  __cil_tmp48 = & srf;
#line 587
  __cil_tmp49 = *__cil_tmp48;
#line 587
  __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 587
  __cil_tmp51 = __cil_tmp50 + __cil_tmp47;
#line 587
  __cil_tmp52 = *((int *)__cil_tmp51);
#line 587
  *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp52;
#line 588
  __cil_tmp53 = & srf;
#line 588
  __cil_tmp54 = *__cil_tmp53;
#line 588
  __cil_tmp55 = (unsigned long )sw_context;
#line 588
  __cil_tmp56 = __cil_tmp55 + 88;
#line 588
  __cil_tmp57 = *((struct ttm_object_file **)__cil_tmp56);
#line 588
  vmw_kms_cursor_snoop(__cil_tmp54, __cil_tmp57, bo, header);
#line 590
  vmw_dmabuf_unreference(& vmw_bo);
#line 592
  __cil_tmp58 = & res;
#line 592
  __cil_tmp59 = & srf;
#line 592
  __cil_tmp60 = *__cil_tmp59;
#line 592
  *__cil_tmp58 = (struct vmw_resource *)__cil_tmp60;
#line 593
  vmw_resource_to_validate_list(sw_context, & res);
  }
#line 595
  return (0);
  out_no_validate: 
  {
#line 598
  vmw_surface_unreference(& srf);
  }
  out_no_reloc: 
  {
#line 600
  vmw_dmabuf_unreference(& vmw_bo);
  }
#line 601
  return (ret);
}
}
#line 604 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_draw(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                        SVGA3dCmdHeader *header ) 
{ struct vmw_draw_cmd *cmd ;
  SVGA3dVertexDecl *decl ;
  SVGA3dPrimitiveRange *range ;
  uint32_t i ;
  uint32_t maxnum ;
  int ret ;
  long tmp___7 ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  struct vmw_draw_cmd *__cil_tmp22 ;
  SVGA3dCmdHeader *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32 __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  uint32 __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32 __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32 *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32 __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32 __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  uint32 __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  uint32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  uint32 *__cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  long __cil_tmp83 ;

  {
  {
#line 612
  __cil_tmp16 = (unsigned long )header;
#line 612
  __cil_tmp17 = __cil_tmp16 + 20UL;
#line 612
  decl = (SVGA3dVertexDecl *)__cil_tmp17;
#line 619
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 620
  __cil_tmp18 = ret != 0;
#line 620
  __cil_tmp19 = ! __cil_tmp18;
#line 620
  __cil_tmp20 = ! __cil_tmp19;
#line 620
  __cil_tmp21 = (long )__cil_tmp20;
#line 620
  tmp___7 = ldv__builtin_expect(__cil_tmp21, 0L);
  }
#line 620
  if (tmp___7) {
#line 621
    return (ret);
  } else {

  }
  {
#line 623
  __mptr = (SVGA3dCmdHeader    *)header;
#line 623
  __cil_tmp22 = (struct vmw_draw_cmd *)0;
#line 623
  __cil_tmp23 = (SVGA3dCmdHeader *)__cil_tmp22;
#line 623
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 623
  __cil_tmp25 = (char *)__mptr;
#line 623
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 623
  cmd = (struct vmw_draw_cmd *)__cil_tmp26;
#line 624
  __cil_tmp27 = (unsigned long )header;
#line 624
  __cil_tmp28 = __cil_tmp27 + 4;
#line 624
  __cil_tmp29 = *((uint32 *)__cil_tmp28);
#line 624
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 624
  __cil_tmp31 = __cil_tmp30 - 12UL;
#line 624
  __cil_tmp32 = __cil_tmp31 / 36UL;
#line 624
  maxnum = (uint32_t )__cil_tmp32;
#line 626
  __cil_tmp33 = 8 + 4;
#line 626
  __cil_tmp34 = (unsigned long )cmd;
#line 626
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 626
  __cil_tmp36 = *((uint32 *)__cil_tmp35);
#line 626
  __cil_tmp37 = __cil_tmp36 > maxnum;
#line 626
  __cil_tmp38 = ! __cil_tmp37;
#line 626
  __cil_tmp39 = ! __cil_tmp38;
#line 626
  __cil_tmp40 = (long )__cil_tmp39;
#line 626
  tmp___8 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 626
  if (tmp___8) {
    {
#line 627
    drm_err("vmw_cmd_draw", "Illegal number of vertex declarations.\n");
    }
#line 628
    return (-22);
  } else {

  }
#line 631
  i = (uint32_t )0;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 631
    __cil_tmp41 = 8 + 4;
#line 631
    __cil_tmp42 = (unsigned long )cmd;
#line 631
    __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 631
    __cil_tmp44 = *((uint32 *)__cil_tmp43);
#line 631
    if (i < __cil_tmp44) {

    } else {
#line 631
      goto while_break;
    }
    }
    {
#line 632
    __cil_tmp45 = (unsigned long )decl;
#line 632
    __cil_tmp46 = __cil_tmp45 + 16;
#line 632
    __cil_tmp47 = (uint32 *)__cil_tmp46;
#line 632
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp47);
#line 634
    __cil_tmp48 = ret != 0;
#line 634
    __cil_tmp49 = ! __cil_tmp48;
#line 634
    __cil_tmp50 = ! __cil_tmp49;
#line 634
    __cil_tmp51 = (long )__cil_tmp50;
#line 634
    tmp___9 = ldv__builtin_expect(__cil_tmp51, 0L);
    }
#line 634
    if (tmp___9) {
#line 635
      return (ret);
    } else {

    }
#line 631
    i = i + 1U;
#line 631
    decl = decl + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 638
  __cil_tmp52 = 8 + 4;
#line 638
  __cil_tmp53 = (unsigned long )cmd;
#line 638
  __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
#line 638
  __cil_tmp55 = *((uint32 *)__cil_tmp54);
#line 638
  __cil_tmp56 = (unsigned long )__cil_tmp55;
#line 638
  __cil_tmp57 = __cil_tmp56 * 36UL;
#line 638
  __cil_tmp58 = (unsigned long )header;
#line 638
  __cil_tmp59 = __cil_tmp58 + 4;
#line 638
  __cil_tmp60 = *((uint32 *)__cil_tmp59);
#line 638
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 638
  __cil_tmp62 = __cil_tmp61 - 12UL;
#line 638
  __cil_tmp63 = __cil_tmp62 - __cil_tmp57;
#line 638
  __cil_tmp64 = __cil_tmp63 / 28UL;
#line 638
  maxnum = (uint32_t )__cil_tmp64;
#line 640
  __cil_tmp65 = 8 + 8;
#line 640
  __cil_tmp66 = (unsigned long )cmd;
#line 640
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
#line 640
  __cil_tmp68 = *((uint32 *)__cil_tmp67);
#line 640
  __cil_tmp69 = __cil_tmp68 > maxnum;
#line 640
  __cil_tmp70 = ! __cil_tmp69;
#line 640
  __cil_tmp71 = ! __cil_tmp70;
#line 640
  __cil_tmp72 = (long )__cil_tmp71;
#line 640
  tmp___10 = ldv__builtin_expect(__cil_tmp72, 0L);
  }
#line 640
  if (tmp___10) {
    {
#line 641
    drm_err("vmw_cmd_draw", "Illegal number of index ranges.\n");
    }
#line 642
    return (-22);
  } else {

  }
#line 645
  range = (SVGA3dPrimitiveRange *)decl;
#line 646
  i = (uint32_t )0;
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 646
    __cil_tmp73 = 8 + 8;
#line 646
    __cil_tmp74 = (unsigned long )cmd;
#line 646
    __cil_tmp75 = __cil_tmp74 + __cil_tmp73;
#line 646
    __cil_tmp76 = *((uint32 *)__cil_tmp75);
#line 646
    if (i < __cil_tmp76) {

    } else {
#line 646
      goto while_break___0;
    }
    }
    {
#line 647
    __cil_tmp77 = (unsigned long )range;
#line 647
    __cil_tmp78 = __cil_tmp77 + 8;
#line 647
    __cil_tmp79 = (uint32 *)__cil_tmp78;
#line 647
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp79);
#line 649
    __cil_tmp80 = ret != 0;
#line 649
    __cil_tmp81 = ! __cil_tmp80;
#line 649
    __cil_tmp82 = ! __cil_tmp81;
#line 649
    __cil_tmp83 = (long )__cil_tmp82;
#line 649
    tmp___11 = ldv__builtin_expect(__cil_tmp83, 0L);
    }
#line 649
    if (tmp___11) {
#line 650
      return (ret);
    } else {

    }
#line 646
    i = i + 1U;
#line 646
    range = range + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 652
  return (0);
}
}
#line 656 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_tex_state(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ SVGA3dTextureState *last_state ;
  SVGA3dTextureState *cur_state ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32 __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  SVGA3dTextureStateName __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 *__cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;

  {
  {
#line 665
  __cil_tmp10 = (unsigned long )header;
#line 665
  __cil_tmp11 = __cil_tmp10 + 4;
#line 665
  __cil_tmp12 = *((uint32 *)__cil_tmp11);
#line 665
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 665
  __cil_tmp14 = (unsigned long )header;
#line 665
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
#line 665
  __cil_tmp16 = __cil_tmp15 + 8UL;
#line 665
  last_state = (SVGA3dTextureState *)__cil_tmp16;
#line 667
  __cil_tmp17 = (unsigned long )header;
#line 667
  __cil_tmp18 = __cil_tmp17 + 12UL;
#line 667
  cur_state = (SVGA3dTextureState *)__cil_tmp18;
#line 671
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 672
  __cil_tmp19 = ret != 0;
#line 672
  __cil_tmp20 = ! __cil_tmp19;
#line 672
  __cil_tmp21 = ! __cil_tmp20;
#line 672
  __cil_tmp22 = (long )__cil_tmp21;
#line 672
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 672
  if (tmp___7) {
#line 673
    return (ret);
  } else {

  }
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 675
    __cil_tmp23 = (unsigned long )last_state;
#line 675
    __cil_tmp24 = (unsigned long )cur_state;
#line 675
    if (__cil_tmp24 < __cil_tmp23) {

    } else {
#line 675
      goto while_break;
    }
    }
    {
#line 676
    __cil_tmp25 = (unsigned long )cur_state;
#line 676
    __cil_tmp26 = __cil_tmp25 + 4;
#line 676
    __cil_tmp27 = *((SVGA3dTextureStateName *)__cil_tmp26);
#line 676
    __cil_tmp28 = (unsigned int )__cil_tmp27;
#line 676
    __cil_tmp29 = __cil_tmp28 != 1U;
#line 676
    __cil_tmp30 = ! __cil_tmp29;
#line 676
    __cil_tmp31 = ! __cil_tmp30;
#line 676
    __cil_tmp32 = (long )__cil_tmp31;
#line 676
    tmp___8 = ldv__builtin_expect(__cil_tmp32, 1L);
    }
#line 676
    if (tmp___8) {
#line 677
      goto __Cont;
    } else {

    }
    {
#line 679
    __cil_tmp33 = (unsigned long )cur_state;
#line 679
    __cil_tmp34 = __cil_tmp33 + 8;
#line 679
    __cil_tmp35 = (uint32 *)__cil_tmp34;
#line 679
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp35);
#line 681
    __cil_tmp36 = ret != 0;
#line 681
    __cil_tmp37 = ! __cil_tmp36;
#line 681
    __cil_tmp38 = ! __cil_tmp37;
#line 681
    __cil_tmp39 = (long )__cil_tmp38;
#line 681
    tmp___9 = ldv__builtin_expect(__cil_tmp39, 0L);
    }
#line 681
    if (tmp___9) {
#line 682
      return (ret);
    } else {

    }
    __Cont: /* CIL Label */ 
#line 675
    cur_state = cur_state + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  return (0);
}
}
#line 688 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      void *buf ) 
{ struct vmw_dma_buffer *vmw_bo ;
  int ret ;
  struct __anonstruct_cmd_429 *cmd ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  SVGAGuestPtr *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;

  {
  {
#line 695
  cmd = (struct __anonstruct_cmd_429 *)buf;
#line 700
  __cil_tmp8 = (unsigned long )cmd;
#line 700
  __cil_tmp9 = __cil_tmp8 + 4;
#line 700
  __cil_tmp10 = (SVGAGuestPtr *)__cil_tmp9;
#line 700
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp10, & vmw_bo);
#line 703
  __cil_tmp11 = ret != 0;
#line 703
  __cil_tmp12 = ! __cil_tmp11;
#line 703
  __cil_tmp13 = ! __cil_tmp12;
#line 703
  __cil_tmp14 = (long )__cil_tmp13;
#line 703
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 703
  if (tmp___7) {
#line 704
    return (ret);
  } else {

  }
  {
#line 706
  vmw_dmabuf_unreference(& vmw_bo);
  }
#line 708
  return (ret);
}
}
#line 711 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_check_not_3d(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                void *buf , uint32_t *size ) 
{ uint32_t size_remaining ;
  uint32_t cmd_id ;
  long tmp___7 ;
  int tmp___8 ;
  uint32_t *__cil_tmp9 ;
  uint32_t *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;

  {
#line 715
  size_remaining = *size;
#line 718
  __cil_tmp9 = (uint32_t *)buf;
#line 718
  __cil_tmp10 = __cil_tmp9 + 0;
#line 718
  cmd_id = *__cil_tmp10;
#line 720
  if ((int )cmd_id == 1) {
#line 720
    goto case_1;
  } else
#line 723
  if ((int )cmd_id == 36) {
#line 723
    goto case_36;
  } else
#line 726
  if ((int )cmd_id == 37) {
#line 726
    goto case_37;
  } else
#line 729
  if ((int )cmd_id == 38) {
#line 729
    goto case_38;
  } else {
    {
#line 732
    goto switch_default;
#line 719
    if (0) {
      case_1: /* CIL Label */ 
#line 721
      __cil_tmp11 = 4UL + 16UL;
#line 721
      *size = (uint32_t )__cil_tmp11;
#line 722
      goto switch_break;
      case_36: /* CIL Label */ 
#line 724
      __cil_tmp12 = 4UL + 16UL;
#line 724
      *size = (uint32_t )__cil_tmp12;
#line 725
      goto switch_break;
      case_37: /* CIL Label */ 
#line 727
      __cil_tmp13 = 4UL + 28UL;
#line 727
      *size = (uint32_t )__cil_tmp13;
#line 728
      goto switch_break;
      case_38: /* CIL Label */ 
#line 730
      __cil_tmp14 = 4UL + 28UL;
#line 730
      *size = (uint32_t )__cil_tmp14;
#line 731
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 733
      drm_err("vmw_cmd_check_not_3d", "Unsupported SVGA command: %u.\n", cmd_id);
      }
#line 734
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  {
#line 737
  __cil_tmp15 = *size;
#line 737
  if (__cil_tmp15 > size_remaining) {
    {
#line 738
    drm_err("vmw_cmd_check_not_3d", "Invalid SVGA command (size mismatch): %u.\n",
            cmd_id);
    }
#line 740
    return (-22);
  } else {

  }
  }
  {
#line 743
  __cil_tmp16 = (unsigned long )sw_context;
#line 743
  __cil_tmp17 = __cil_tmp16 + 61;
#line 743
  __cil_tmp18 = *((bool *)__cil_tmp17);
#line 743
  __cil_tmp19 = ! __cil_tmp18;
#line 743
  __cil_tmp20 = ! __cil_tmp19;
#line 743
  __cil_tmp21 = ! __cil_tmp20;
#line 743
  __cil_tmp22 = (long )__cil_tmp21;
#line 743
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 743
  if (tmp___7) {
    {
#line 744
    drm_err("vmw_cmd_check_not_3d", "Kernel only SVGA command: %u.\n", cmd_id);
    }
#line 745
    return (-1);
  } else {

  }
#line 748
  if (cmd_id == 36U) {
    {
#line 749
    tmp___8 = vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);
    }
#line 749
    return (tmp___8);
  } else {

  }
#line 751
  return (0);
}
}
#line 761 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static vmw_cmd_func vmw_cmd_funcs[1082]  = 
#line 761
  {      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_surface_copy_check,      & vmw_cmd_stretch_blt_check, 
        & vmw_cmd_dma,      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_set_render_target_check,      & vmw_cmd_tex_state, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_present_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_draw, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_end_query,      & vmw_cmd_wait_query, 
        & vmw_cmd_ok,      & vmw_cmd_blt_surf_screen_check};
#line 796 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                         void *buf , uint32_t *size ) 
{ uint32_t cmd_id ;
  uint32_t size_remaining ;
  SVGA3dCmdHeader *header ;
  int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  uint32_t *__cil_tmp14 ;
  uint32_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  vmw_cmd_func __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;

  {
  {
#line 801
  size_remaining = *size;
#line 802
  header = (SVGA3dCmdHeader *)buf;
#line 805
  __cil_tmp14 = (uint32_t *)buf;
#line 805
  __cil_tmp15 = __cil_tmp14 + 0;
#line 805
  cmd_id = *__cil_tmp15;
#line 807
  __cil_tmp16 = cmd_id < 43U;
#line 807
  __cil_tmp17 = ! __cil_tmp16;
#line 807
  __cil_tmp18 = ! __cil_tmp17;
#line 807
  __cil_tmp19 = (long )__cil_tmp18;
#line 807
  tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 807
  if (tmp___8) {
    {
#line 808
    tmp___7 = vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);
    }
#line 808
    return (tmp___7);
  } else {

  }
  {
#line 811
  cmd_id = *((uint32 *)header);
#line 812
  __cil_tmp20 = (unsigned long )header;
#line 812
  __cil_tmp21 = __cil_tmp20 + 4;
#line 812
  __cil_tmp22 = *((uint32 *)__cil_tmp21);
#line 812
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 812
  __cil_tmp24 = __cil_tmp23 + 8UL;
#line 812
  *size = (uint32_t )__cil_tmp24;
#line 814
  cmd_id = cmd_id - 1040U;
#line 815
  __cil_tmp25 = *size;
#line 815
  __cil_tmp26 = __cil_tmp25 > size_remaining;
#line 815
  __cil_tmp27 = ! __cil_tmp26;
#line 815
  __cil_tmp28 = ! __cil_tmp27;
#line 815
  __cil_tmp29 = (long )__cil_tmp28;
#line 815
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 815
  if (tmp___9) {
#line 816
    goto out_err;
  } else {

  }
  {
#line 818
  __cil_tmp30 = cmd_id >= 42U;
#line 818
  __cil_tmp31 = ! __cil_tmp30;
#line 818
  __cil_tmp32 = ! __cil_tmp31;
#line 818
  __cil_tmp33 = (long )__cil_tmp32;
#line 818
  tmp___10 = ldv__builtin_expect(__cil_tmp33, 0L);
  }
#line 818
  if (tmp___10) {
#line 819
    goto out_err;
  } else {

  }
  {
#line 821
  __cil_tmp34 = cmd_id * 8UL;
#line 821
  __cil_tmp35 = (unsigned long )(vmw_cmd_funcs) + __cil_tmp34;
#line 821
  __cil_tmp36 = *((vmw_cmd_func *)__cil_tmp35);
#line 821
  ret = (*__cil_tmp36)(dev_priv, sw_context, header);
#line 822
  __cil_tmp37 = ret != 0;
#line 822
  __cil_tmp38 = ! __cil_tmp37;
#line 822
  __cil_tmp39 = ! __cil_tmp38;
#line 822
  __cil_tmp40 = (long )__cil_tmp39;
#line 822
  tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 822
  if (tmp___11) {
#line 823
    goto out_err;
  } else {

  }
#line 825
  return (0);
  out_err: 
  {
#line 827
  __cil_tmp41 = cmd_id + 1040U;
#line 827
  drm_err("vmw_cmd_check", "Illegal / Invalid SVGA3D command: %d\n", __cil_tmp41);
  }
#line 829
  return (-22);
}
}
#line 832 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_cmd_check_all(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             void *buf , uint32_t size ) 
{ int32_t cur_size ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  uint32_t *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  uint32_t *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;

  {
#line 837
  __cil_tmp9 = & size;
#line 837
  __cil_tmp10 = *__cil_tmp9;
#line 837
  cur_size = (int32_t )__cil_tmp10;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (cur_size > 0) {

    } else {
#line 840
      goto while_break;
    }
    {
#line 841
    __cil_tmp11 = & size;
#line 841
    *__cil_tmp11 = (uint32_t )cur_size;
#line 842
    ret = vmw_cmd_check(dev_priv, sw_context, buf, & size);
#line 843
    __cil_tmp12 = ret != 0;
#line 843
    __cil_tmp13 = ! __cil_tmp12;
#line 843
    __cil_tmp14 = ! __cil_tmp13;
#line 843
    __cil_tmp15 = (long )__cil_tmp14;
#line 843
    tmp___7 = ldv__builtin_expect(__cil_tmp15, 0L);
    }
#line 843
    if (tmp___7) {
#line 844
      return (ret);
    } else {

    }
#line 845
    __cil_tmp16 = & size;
#line 845
    __cil_tmp17 = *__cil_tmp16;
#line 845
    __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 845
    __cil_tmp19 = (unsigned long )buf;
#line 845
    __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
#line 845
    buf = (void *)__cil_tmp20;
#line 846
    __cil_tmp21 = & size;
#line 846
    __cil_tmp22 = *__cil_tmp21;
#line 846
    __cil_tmp23 = (uint32_t )cur_size;
#line 846
    __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 846
    cur_size = (int32_t )__cil_tmp24;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  __cil_tmp25 = cur_size != 0;
#line 849
  __cil_tmp26 = ! __cil_tmp25;
#line 849
  __cil_tmp27 = ! __cil_tmp26;
#line 849
  __cil_tmp28 = (long )__cil_tmp27;
#line 849
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 849
  if (tmp___8) {
    {
#line 850
    drm_err("vmw_cmd_check_all", "Command verifier out of sync.\n");
    }
#line 851
    return (-22);
  } else {

  }
#line 854
  return (0);
}
}
#line 857 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_free_relocations(struct vmw_sw_context *sw_context ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
#line 859
  __cil_tmp2 = (unsigned long )sw_context;
#line 859
  __cil_tmp3 = __cil_tmp2 + 32880;
#line 859
  *((uint32_t *)__cil_tmp3) = (uint32_t )0;
#line 860
  return;
}
}
#line 862 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_apply_relocations(struct vmw_sw_context *sw_context ) 
{ uint32_t i ;
  struct vmw_relocation *reloc ;
  struct ttm_validate_buffer *validate ;
  struct ttm_buffer_object *bo ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  SVGAGuestPtr *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  SVGAGuestPtr *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  SVGAGuestPtr *__cil_tmp38 ;
  SVGAGuestPtr *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;

  {
#line 869
  i = (uint32_t )0;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 869
    __cil_tmp6 = (unsigned long )sw_context;
#line 869
    __cil_tmp7 = __cil_tmp6 + 32880;
#line 869
    __cil_tmp8 = *((uint32_t *)__cil_tmp7);
#line 869
    if (i < __cil_tmp8) {

    } else {
#line 869
      goto while_break;
    }
    }
#line 870
    __cil_tmp9 = i * 16UL;
#line 870
    __cil_tmp10 = 112 + __cil_tmp9;
#line 870
    __cil_tmp11 = (unsigned long )sw_context;
#line 870
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 870
    reloc = (struct vmw_relocation *)__cil_tmp12;
#line 871
    __cil_tmp13 = (unsigned long )reloc;
#line 871
    __cil_tmp14 = __cil_tmp13 + 8;
#line 871
    __cil_tmp15 = *((uint32_t *)__cil_tmp14);
#line 871
    __cil_tmp16 = __cil_tmp15 * 48UL;
#line 871
    __cil_tmp17 = 32888 + __cil_tmp16;
#line 871
    __cil_tmp18 = (unsigned long )sw_context;
#line 871
    __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 871
    validate = (struct ttm_validate_buffer *)__cil_tmp19;
#line 872
    __cil_tmp20 = (unsigned long )validate;
#line 872
    __cil_tmp21 = __cil_tmp20 + 16;
#line 872
    bo = *((struct ttm_buffer_object **)__cil_tmp21);
    {
#line 873
    __cil_tmp22 = 112 + 36;
#line 873
    __cil_tmp23 = (unsigned long )bo;
#line 873
    __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 873
    __cil_tmp25 = *((uint32_t *)__cil_tmp24);
#line 873
    if (__cil_tmp25 == 2U) {
#line 874
      __cil_tmp26 = *((SVGAGuestPtr **)reloc);
#line 874
      __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 874
      __cil_tmp28 = __cil_tmp27 + 4;
#line 874
      __cil_tmp29 = (unsigned long )bo;
#line 874
      __cil_tmp30 = __cil_tmp29 + 368;
#line 874
      __cil_tmp31 = *((unsigned long *)__cil_tmp30);
#line 874
      __cil_tmp32 = *((SVGAGuestPtr **)reloc);
#line 874
      __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 874
      __cil_tmp34 = __cil_tmp33 + 4;
#line 874
      __cil_tmp35 = *((uint32 *)__cil_tmp34);
#line 874
      __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 874
      __cil_tmp37 = __cil_tmp36 + __cil_tmp31;
#line 874
      *((uint32 *)__cil_tmp28) = (uint32 )__cil_tmp37;
#line 875
      __cil_tmp38 = *((SVGAGuestPtr **)reloc);
#line 875
      *((uint32 *)__cil_tmp38) = (uint32 )-2;
    } else {
#line 877
      __cil_tmp39 = *((SVGAGuestPtr **)reloc);
#line 877
      __cil_tmp40 = 112 + 8;
#line 877
      __cil_tmp41 = (unsigned long )bo;
#line 877
      __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 877
      __cil_tmp43 = *((unsigned long *)__cil_tmp42);
#line 877
      *((uint32 *)__cil_tmp39) = (uint32 )__cil_tmp43;
    }
    }
#line 869
    i = i + 1U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 879
  vmw_free_relocations(sw_context);
  }
#line 880
  return;
}
}
#line 882 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_clear_validations(struct vmw_sw_context *sw_context ) 
{ struct ttm_validate_buffer *entry ;
  struct ttm_validate_buffer *next ;
  struct vmw_resource *res ;
  struct vmw_resource *res_next ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  long tmp___7 ;
  struct list_head    *__mptr___2 ;
  struct list_head    *__mptr___3 ;
  struct list_head    *__mptr___4 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct ttm_validate_buffer *__cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct ttm_validate_buffer *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct ttm_buffer_object *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_buffer_object **__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  struct ttm_validate_buffer *__cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  struct vmw_resource **__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  struct vmw_resource **__cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  struct vmw_resource *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct list_head *__cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct list_head *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct vmw_resource **__cil_tmp88 ;
  struct vmw_resource *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  struct vmw_resource **__cil_tmp94 ;
  struct vmw_resource *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct list_head *__cil_tmp98 ;
  struct vmw_resource **__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct list_head *__cil_tmp102 ;
  struct vmw_resource *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct list_head *__cil_tmp106 ;
  unsigned int __cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;

  {
#line 890
  __cil_tmp13 = (unsigned long )sw_context;
#line 890
  __cil_tmp14 = __cil_tmp13 + 96;
#line 890
  __cil_tmp15 = *((struct list_head **)__cil_tmp14);
#line 890
  __mptr = (struct list_head    *)__cil_tmp15;
#line 890
  __cil_tmp16 = (struct ttm_validate_buffer *)0;
#line 890
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
#line 890
  __cil_tmp18 = (unsigned int )__cil_tmp17;
#line 890
  __cil_tmp19 = (char *)__mptr;
#line 890
  __cil_tmp20 = __cil_tmp19 - __cil_tmp18;
#line 890
  entry = (struct ttm_validate_buffer *)__cil_tmp20;
#line 890
  __cil_tmp21 = *((struct list_head **)entry);
#line 890
  __mptr___0 = (struct list_head    *)__cil_tmp21;
#line 890
  __cil_tmp22 = (struct ttm_validate_buffer *)0;
#line 890
  __cil_tmp23 = (struct list_head *)__cil_tmp22;
#line 890
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 890
  __cil_tmp25 = (char *)__mptr___0;
#line 890
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 890
  next = (struct ttm_validate_buffer *)__cil_tmp26;
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 890
    __cil_tmp27 = (unsigned long )sw_context;
#line 890
    __cil_tmp28 = __cil_tmp27 + 96;
#line 890
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 890
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 890
    __cil_tmp31 = (struct list_head *)entry;
#line 890
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 890
    if (__cil_tmp32 != __cil_tmp30) {

    } else {
#line 890
      goto while_break;
    }
    }
    {
#line 892
    __cil_tmp33 = (struct list_head *)entry;
#line 892
    list_del(__cil_tmp33);
#line 893
    __cil_tmp34 = (unsigned long )entry;
#line 893
    __cil_tmp35 = __cil_tmp34 + 16;
#line 893
    __cil_tmp36 = *((struct ttm_buffer_object **)__cil_tmp35);
#line 893
    vmw_dmabuf_validate_clear(__cil_tmp36);
#line 894
    __cil_tmp37 = (unsigned long )entry;
#line 894
    __cil_tmp38 = __cil_tmp37 + 16;
#line 894
    __cil_tmp39 = (struct ttm_buffer_object **)__cil_tmp38;
#line 894
    ttm_bo_unref(__cil_tmp39);
#line 895
    __cil_tmp40 = (unsigned long )sw_context;
#line 895
    __cil_tmp41 = __cil_tmp40 + 131192;
#line 895
    __cil_tmp42 = (unsigned long )sw_context;
#line 895
    __cil_tmp43 = __cil_tmp42 + 131192;
#line 895
    __cil_tmp44 = *((uint32_t *)__cil_tmp43);
#line 895
    *((uint32_t *)__cil_tmp41) = __cil_tmp44 - 1U;
#line 890
    entry = next;
#line 890
    __cil_tmp45 = *((struct list_head **)next);
#line 890
    __mptr___1 = (struct list_head    *)__cil_tmp45;
#line 890
    __cil_tmp46 = (struct ttm_validate_buffer *)0;
#line 890
    __cil_tmp47 = (struct list_head *)__cil_tmp46;
#line 890
    __cil_tmp48 = (unsigned int )__cil_tmp47;
#line 890
    __cil_tmp49 = (char *)__mptr___1;
#line 890
    __cil_tmp50 = __cil_tmp49 - __cil_tmp48;
#line 890
    next = (struct ttm_validate_buffer *)__cil_tmp50;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 897
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 897
    __cil_tmp51 = (unsigned long )sw_context;
#line 897
    __cil_tmp52 = __cil_tmp51 + 131192;
#line 897
    __cil_tmp53 = *((uint32_t *)__cil_tmp52);
#line 897
    __cil_tmp54 = __cil_tmp53 != 0U;
#line 897
    __cil_tmp55 = ! __cil_tmp54;
#line 897
    __cil_tmp56 = ! __cil_tmp55;
#line 897
    __cil_tmp57 = (long )__cil_tmp56;
#line 897
    tmp___7 = ldv__builtin_expect(__cil_tmp57, 0L);
    }
#line 897
    if (tmp___7) {
      {
#line 897
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 897
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                             "i" (897), "i" (12UL));
        {
#line 897
        while (1) {
          while_continue___2: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 897
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 897
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 902
  __cil_tmp58 = (unsigned long )sw_context;
#line 902
  __cil_tmp59 = __cil_tmp58 + 131216;
#line 902
  __cil_tmp60 = (struct list_head *)__cil_tmp59;
#line 902
  vmw_resource_unreserve(__cil_tmp60);
#line 903
  __cil_tmp61 = (unsigned long )sw_context;
#line 903
  __cil_tmp62 = __cil_tmp61 + 131216;
#line 903
  __cil_tmp63 = *((struct list_head **)__cil_tmp62);
#line 903
  __mptr___2 = (struct list_head    *)__cil_tmp63;
#line 903
  __cil_tmp64 = & res;
#line 903
  __cil_tmp65 = (struct vmw_resource *)0;
#line 903
  __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 903
  __cil_tmp67 = __cil_tmp66 + 64;
#line 903
  __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 903
  __cil_tmp69 = (unsigned int )__cil_tmp68;
#line 903
  __cil_tmp70 = (char *)__mptr___2;
#line 903
  __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
#line 903
  *__cil_tmp64 = (struct vmw_resource *)__cil_tmp71;
#line 903
  __cil_tmp72 = & res;
#line 903
  __cil_tmp73 = *__cil_tmp72;
#line 903
  __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 903
  __cil_tmp75 = __cil_tmp74 + 64;
#line 903
  __cil_tmp76 = *((struct list_head **)__cil_tmp75);
#line 903
  __mptr___3 = (struct list_head    *)__cil_tmp76;
#line 903
  __cil_tmp77 = (struct vmw_resource *)0;
#line 903
  __cil_tmp78 = (unsigned long )__cil_tmp77;
#line 903
  __cil_tmp79 = __cil_tmp78 + 64;
#line 903
  __cil_tmp80 = (struct list_head *)__cil_tmp79;
#line 903
  __cil_tmp81 = (unsigned int )__cil_tmp80;
#line 903
  __cil_tmp82 = (char *)__mptr___3;
#line 903
  __cil_tmp83 = __cil_tmp82 - __cil_tmp81;
#line 903
  res_next = (struct vmw_resource *)__cil_tmp83;
  }
  {
#line 903
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 903
    __cil_tmp84 = (unsigned long )sw_context;
#line 903
    __cil_tmp85 = __cil_tmp84 + 131216;
#line 903
    __cil_tmp86 = (struct list_head *)__cil_tmp85;
#line 903
    __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 903
    __cil_tmp88 = & res;
#line 903
    __cil_tmp89 = *__cil_tmp88;
#line 903
    __cil_tmp90 = (unsigned long )__cil_tmp89;
#line 903
    __cil_tmp91 = __cil_tmp90 + 64;
#line 903
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
#line 903
    __cil_tmp93 = (unsigned long )__cil_tmp92;
#line 903
    if (__cil_tmp93 != __cil_tmp87) {

    } else {
#line 903
      goto while_break___3;
    }
    }
    {
#line 905
    __cil_tmp94 = & res;
#line 905
    __cil_tmp95 = *__cil_tmp94;
#line 905
    __cil_tmp96 = (unsigned long )__cil_tmp95;
#line 905
    __cil_tmp97 = __cil_tmp96 + 64;
#line 905
    __cil_tmp98 = (struct list_head *)__cil_tmp97;
#line 905
    list_del_init(__cil_tmp98);
#line 906
    vmw_resource_unreference(& res);
#line 903
    __cil_tmp99 = & res;
#line 903
    *__cil_tmp99 = res_next;
#line 903
    __cil_tmp100 = (unsigned long )res_next;
#line 903
    __cil_tmp101 = __cil_tmp100 + 64;
#line 903
    __cil_tmp102 = *((struct list_head **)__cil_tmp101);
#line 903
    __mptr___4 = (struct list_head    *)__cil_tmp102;
#line 903
    __cil_tmp103 = (struct vmw_resource *)0;
#line 903
    __cil_tmp104 = (unsigned long )__cil_tmp103;
#line 903
    __cil_tmp105 = __cil_tmp104 + 64;
#line 903
    __cil_tmp106 = (struct list_head *)__cil_tmp105;
#line 903
    __cil_tmp107 = (unsigned int )__cil_tmp106;
#line 903
    __cil_tmp108 = (char *)__mptr___4;
#line 903
    __cil_tmp109 = __cil_tmp108 - __cil_tmp107;
#line 903
    res_next = (struct vmw_resource *)__cil_tmp109;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 908
  return;
}
}
#line 910 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_validate_single_buffer(struct vmw_private *dev_priv , struct ttm_buffer_object *bo ) 
{ int ret ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ttm_buffer_object *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct ttm_buffer_object *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  bool __cil_tmp19 ;
  bool __cil_tmp20 ;
  long __cil_tmp21 ;
  bool __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;

  {
  {
#line 920
  __cil_tmp6 = (unsigned long )dev_priv;
#line 920
  __cil_tmp7 = __cil_tmp6 + 134752;
#line 920
  __cil_tmp8 = *((struct ttm_buffer_object **)__cil_tmp7);
#line 920
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 920
  __cil_tmp10 = (unsigned long )bo;
#line 920
  if (__cil_tmp10 == __cil_tmp9) {
#line 923
    return (0);
  } else {
    {
#line 920
    __cil_tmp11 = (unsigned long )dev_priv;
#line 920
    __cil_tmp12 = __cil_tmp11 + 134744;
#line 920
    __cil_tmp13 = *((struct ttm_buffer_object **)__cil_tmp12);
#line 920
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 920
    __cil_tmp15 = (unsigned long )bo;
#line 920
    if (__cil_tmp15 == __cil_tmp14) {
      {
#line 920
      __cil_tmp16 = (unsigned long )dev_priv;
#line 920
      __cil_tmp17 = __cil_tmp16 + 134764;
#line 920
      if (*((bool *)__cil_tmp17)) {
#line 923
        return (0);
      } else {

      }
      }
    } else {

    }
    }
  }
  }
  {
#line 932
  __cil_tmp18 = (bool )1;
#line 932
  __cil_tmp19 = (bool )0;
#line 932
  __cil_tmp20 = (bool )0;
#line 932
  ret = ttm_bo_validate(bo, & vmw_vram_gmr_placement, __cil_tmp18, __cil_tmp19, __cil_tmp20);
  }
#line 933
  if (ret == 0) {
#line 933
    tmp___7 = 1;
  } else
#line 933
  if (ret == -512) {
#line 933
    tmp___7 = 1;
  } else {
#line 933
    tmp___7 = 0;
  }
  {
#line 933
  __cil_tmp21 = (long )tmp___7;
#line 933
  tmp___8 = ldv__builtin_expect(__cil_tmp21, 1L);
  }
#line 933
  if (tmp___8) {
#line 934
    return (ret);
  } else {

  }
  {
#line 941
  printk("<6>[drm] Falling through to VRAM.\n");
#line 942
  __cil_tmp22 = (bool )1;
#line 942
  __cil_tmp23 = (bool )0;
#line 942
  __cil_tmp24 = (bool )0;
#line 942
  ret = ttm_bo_validate(bo, & vmw_vram_placement, __cil_tmp22, __cil_tmp23, __cil_tmp24);
  }
#line 943
  return (ret);
}
}
#line 947 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_validate_buffers(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct ttm_validate_buffer *entry ;
  int ret ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct ttm_validate_buffer *__cil_tmp11 ;
  struct list_head *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct ttm_buffer_object *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  struct ttm_validate_buffer *__cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 953
  __cil_tmp8 = (unsigned long )sw_context;
#line 953
  __cil_tmp9 = __cil_tmp8 + 96;
#line 953
  __cil_tmp10 = *((struct list_head **)__cil_tmp9);
#line 953
  __mptr = (struct list_head    *)__cil_tmp10;
#line 953
  __cil_tmp11 = (struct ttm_validate_buffer *)0;
#line 953
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
#line 953
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 953
  __cil_tmp14 = (char *)__mptr;
#line 953
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
#line 953
  entry = (struct ttm_validate_buffer *)__cil_tmp15;
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 953
    __cil_tmp16 = (unsigned long )sw_context;
#line 953
    __cil_tmp17 = __cil_tmp16 + 96;
#line 953
    __cil_tmp18 = (struct list_head *)__cil_tmp17;
#line 953
    __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 953
    __cil_tmp20 = (struct list_head *)entry;
#line 953
    __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 953
    if (__cil_tmp21 != __cil_tmp19) {

    } else {
#line 953
      goto while_break;
    }
    }
    {
#line 954
    __cil_tmp22 = (unsigned long )entry;
#line 954
    __cil_tmp23 = __cil_tmp22 + 16;
#line 954
    __cil_tmp24 = *((struct ttm_buffer_object **)__cil_tmp23);
#line 954
    ret = vmw_validate_single_buffer(dev_priv, __cil_tmp24);
#line 955
    __cil_tmp25 = ret != 0;
#line 955
    __cil_tmp26 = ! __cil_tmp25;
#line 955
    __cil_tmp27 = ! __cil_tmp26;
#line 955
    __cil_tmp28 = (long )__cil_tmp27;
#line 955
    tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
    }
#line 955
    if (tmp___7) {
#line 956
      return (ret);
    } else {

    }
#line 953
    __cil_tmp29 = *((struct list_head **)entry);
#line 953
    __mptr___0 = (struct list_head    *)__cil_tmp29;
#line 953
    __cil_tmp30 = (struct ttm_validate_buffer *)0;
#line 953
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
#line 953
    __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 953
    __cil_tmp33 = (char *)__mptr___0;
#line 953
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
#line 953
    entry = (struct ttm_validate_buffer *)__cil_tmp34;
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  return (0);
}
}
#line 961 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context , uint32_t size ) 
{ long tmp___7 ;
  void *tmp___8 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  uint32_t __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  uint32_t *__cil_tmp46 ;
  void    *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  uint32_t *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;

  {
  {
#line 964
  __cil_tmp5 = (unsigned long )sw_context;
#line 964
  __cil_tmp6 = __cil_tmp5 + 131208;
#line 964
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
#line 964
  __cil_tmp8 = __cil_tmp7 >= size;
#line 964
  __cil_tmp9 = ! __cil_tmp8;
#line 964
  __cil_tmp10 = ! __cil_tmp9;
#line 964
  __cil_tmp11 = (long )__cil_tmp10;
#line 964
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 1L);
  }
#line 964
  if (tmp___7) {
#line 965
    return (0);
  } else {

  }
  {
#line 967
  __cil_tmp12 = (unsigned long )sw_context;
#line 967
  __cil_tmp13 = __cil_tmp12 + 131208;
#line 967
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
#line 967
  if (__cil_tmp14 == 0U) {
#line 968
    __cil_tmp15 = (unsigned long )sw_context;
#line 968
    __cil_tmp16 = __cil_tmp15 + 131208;
#line 968
    *((uint32_t *)__cil_tmp16) = (uint32_t )32768;
  } else {

  }
  }
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 970
    __cil_tmp17 = (unsigned long )sw_context;
#line 970
    __cil_tmp18 = __cil_tmp17 + 131208;
#line 970
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 970
    if (__cil_tmp19 < size) {

    } else {
#line 970
      goto while_break;
    }
    }
#line 971
    __cil_tmp20 = (unsigned long )sw_context;
#line 971
    __cil_tmp21 = __cil_tmp20 + 131208;
#line 971
    __cil_tmp22 = 1UL << 12;
#line 971
    __cil_tmp23 = (uint32_t )__cil_tmp22;
#line 971
    __cil_tmp24 = __cil_tmp23 - 1U;
#line 971
    __cil_tmp25 = ~ __cil_tmp24;
#line 971
    __cil_tmp26 = 1UL << 12;
#line 971
    __cil_tmp27 = (uint32_t )__cil_tmp26;
#line 971
    __cil_tmp28 = __cil_tmp27 - 1U;
#line 971
    __cil_tmp29 = (unsigned long )sw_context;
#line 971
    __cil_tmp30 = __cil_tmp29 + 131208;
#line 971
    __cil_tmp31 = *((uint32_t *)__cil_tmp30);
#line 971
    __cil_tmp32 = __cil_tmp31 >> 1;
#line 971
    __cil_tmp33 = (unsigned long )sw_context;
#line 971
    __cil_tmp34 = __cil_tmp33 + 131208;
#line 971
    __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 971
    __cil_tmp36 = __cil_tmp35 + __cil_tmp32;
#line 971
    __cil_tmp37 = __cil_tmp36 + __cil_tmp28;
#line 971
    *((uint32_t *)__cil_tmp21) = __cil_tmp37 & __cil_tmp25;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 976
  __cil_tmp38 = (void *)0;
#line 976
  __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 976
  __cil_tmp40 = (unsigned long )sw_context;
#line 976
  __cil_tmp41 = __cil_tmp40 + 131200;
#line 976
  __cil_tmp42 = *((uint32_t **)__cil_tmp41);
#line 976
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 976
  if (__cil_tmp43 != __cil_tmp39) {
    {
#line 977
    __cil_tmp44 = (unsigned long )sw_context;
#line 977
    __cil_tmp45 = __cil_tmp44 + 131200;
#line 977
    __cil_tmp46 = *((uint32_t **)__cil_tmp45);
#line 977
    __cil_tmp47 = (void    *)__cil_tmp46;
#line 977
    vfree(__cil_tmp47);
    }
  } else {

  }
  }
  {
#line 979
  __cil_tmp48 = (unsigned long )sw_context;
#line 979
  __cil_tmp49 = __cil_tmp48 + 131208;
#line 979
  __cil_tmp50 = *((uint32_t *)__cil_tmp49);
#line 979
  __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 979
  tmp___8 = vmalloc(__cil_tmp51);
#line 979
  __cil_tmp52 = (unsigned long )sw_context;
#line 979
  __cil_tmp53 = __cil_tmp52 + 131200;
#line 979
  *((uint32_t **)__cil_tmp53) = (uint32_t *)tmp___8;
  }
  {
#line 981
  __cil_tmp54 = (void *)0;
#line 981
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 981
  __cil_tmp56 = (unsigned long )sw_context;
#line 981
  __cil_tmp57 = __cil_tmp56 + 131200;
#line 981
  __cil_tmp58 = *((uint32_t **)__cil_tmp57);
#line 981
  __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 981
  if (__cil_tmp59 == __cil_tmp55) {
    {
#line 982
    drm_err("vmw_resize_cmd_bounce", "Failed to allocate command bounce buffer.\n");
#line 983
    __cil_tmp60 = (unsigned long )sw_context;
#line 983
    __cil_tmp61 = __cil_tmp60 + 131208;
#line 983
    *((uint32_t *)__cil_tmp61) = (uint32_t )0;
    }
#line 984
    return (-12);
  } else {

  }
  }
#line 987
  return (0);
}
}
#line 1001 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) 
{ uint32_t sequence ;
  int ret ;
  bool synced ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_fence_manager *__cil_tmp29 ;
  uint32_t *__cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct vmw_fence_manager *__cil_tmp35 ;
  uint32_t *__cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  long __cil_tmp39 ;
  bool __cil_tmp40 ;
  bool __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  bool __cil_tmp44 ;
  void *__cil_tmp45 ;

  {
#line 1008
  synced = (bool )0;
  {
#line 1011
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1011
    __cil_tmp13 = (void *)0;
#line 1011
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1011
    __cil_tmp15 = (unsigned long )p_handle;
#line 1011
    if (__cil_tmp15 != __cil_tmp14) {
      {
#line 1011
      __cil_tmp16 = (void *)0;
#line 1011
      __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 1011
      __cil_tmp18 = (unsigned long )file_priv;
#line 1011
      if (__cil_tmp18 == __cil_tmp17) {
#line 1011
        tmp___7 = 1;
      } else {
#line 1011
        tmp___7 = 0;
      }
      }
    } else {
#line 1011
      tmp___7 = 0;
    }
    }
    {
#line 1011
    __cil_tmp19 = (long )tmp___7;
#line 1011
    tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
    }
#line 1011
    if (tmp___8) {
      {
#line 1011
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1011
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                             "i" (1011), "i" (12UL));
        {
#line 1011
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1011
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 1011
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1013
  ret = vmw_fifo_send_fence(dev_priv, & sequence);
#line 1014
  __cil_tmp20 = ret != 0;
#line 1014
  __cil_tmp21 = ! __cil_tmp20;
#line 1014
  __cil_tmp22 = ! __cil_tmp21;
#line 1014
  __cil_tmp23 = (long )__cil_tmp22;
#line 1014
  tmp___9 = ldv__builtin_expect(__cil_tmp23, 0L);
  }
#line 1014
  if (tmp___9) {
    {
#line 1015
    drm_err("vmw_execbuf_fence_commands", "Fence submission error. Syncing.\n");
#line 1016
    synced = (bool )1;
    }
  } else {

  }
  {
#line 1019
  __cil_tmp24 = (void *)0;
#line 1019
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 1019
  __cil_tmp26 = (unsigned long )p_handle;
#line 1019
  if (__cil_tmp26 != __cil_tmp25) {
    {
#line 1020
    __cil_tmp27 = (unsigned long )dev_priv;
#line 1020
    __cil_tmp28 = __cil_tmp27 + 3008;
#line 1020
    __cil_tmp29 = *((struct vmw_fence_manager **)__cil_tmp28);
#line 1020
    __cil_tmp30 = & sequence;
#line 1020
    __cil_tmp31 = *__cil_tmp30;
#line 1020
    __cil_tmp32 = (uint32_t )1;
#line 1020
    ret = vmw_user_fence_create(file_priv, __cil_tmp29, __cil_tmp31, __cil_tmp32,
                                p_fence, p_handle);
    }
  } else {
    {
#line 1025
    __cil_tmp33 = (unsigned long )dev_priv;
#line 1025
    __cil_tmp34 = __cil_tmp33 + 3008;
#line 1025
    __cil_tmp35 = *((struct vmw_fence_manager **)__cil_tmp34);
#line 1025
    __cil_tmp36 = & sequence;
#line 1025
    __cil_tmp37 = *__cil_tmp36;
#line 1025
    __cil_tmp38 = (uint32_t )1;
#line 1025
    ret = vmw_fence_create(__cil_tmp35, __cil_tmp37, __cil_tmp38, p_fence);
    }
  }
  }
#line 1029
  if (ret != 0) {
#line 1029
    if (! synced) {
#line 1029
      tmp___10 = 1;
    } else {
#line 1029
      tmp___10 = 0;
    }
  } else {
#line 1029
    tmp___10 = 0;
  }
  {
#line 1029
  __cil_tmp39 = (long )tmp___10;
#line 1029
  tmp___11 = ldv__builtin_expect(__cil_tmp39, 0L);
  }
#line 1029
  if (tmp___11) {
    {
#line 1030
    __cil_tmp40 = (bool )0;
#line 1030
    __cil_tmp41 = (bool )0;
#line 1030
    __cil_tmp42 = & sequence;
#line 1030
    __cil_tmp43 = *__cil_tmp42;
#line 1030
    __cil_tmp44 = (bool )0;
#line 1030
    vmw_fallback_wait(dev_priv, __cil_tmp40, __cil_tmp41, __cil_tmp43, __cil_tmp44,
                      1250UL);
#line 1033
    __cil_tmp45 = (void *)0;
#line 1033
    *p_fence = (struct vmw_fence_obj *)__cil_tmp45;
    }
  } else {

  }
#line 1036
  return (0);
}
}
#line 1059 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) 
{ struct drm_vmw_fence_rep fence_rep ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  struct drm_vmw_fence_rep *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct vmw_fifo_state *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  void *__cil_tmp32 ;
  void    *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct ttm_object_file *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  enum ttm_ref_type __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  bool __cil_tmp49 ;
  bool __cil_tmp50 ;

  {
  {
#line 1069
  __cil_tmp10 = (void *)0;
#line 1069
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1069
  __cil_tmp12 = (unsigned long )user_fence_rep;
#line 1069
  if (__cil_tmp12 == __cil_tmp11) {
#line 1070
    return;
  } else {

  }
  }
  {
#line 1072
  __cil_tmp13 = (void *)(& fence_rep);
#line 1072
  memset(__cil_tmp13, 0, 24UL);
#line 1074
  __cil_tmp14 = (unsigned long )(& fence_rep) + 20;
#line 1074
  *((int32_t *)__cil_tmp14) = ret;
  }
#line 1075
  if (ret == 0) {
    {
#line 1076
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1076
      __cil_tmp15 = (void *)0;
#line 1076
      __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 1076
      __cil_tmp17 = (unsigned long )fence;
#line 1076
      __cil_tmp18 = __cil_tmp17 == __cil_tmp16;
#line 1076
      __cil_tmp19 = ! __cil_tmp18;
#line 1076
      __cil_tmp20 = ! __cil_tmp19;
#line 1076
      __cil_tmp21 = (long )__cil_tmp20;
#line 1076
      tmp___7 = ldv__builtin_expect(__cil_tmp21, 0L);
      }
#line 1076
      if (tmp___7) {
        {
#line 1076
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1076
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                               "i" (1076), "i" (12UL));
          {
#line 1076
          while (1) {
            while_continue___1: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1076
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {

      }
#line 1076
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1078
    __cil_tmp22 = & fence_rep;
#line 1078
    *((uint32_t *)__cil_tmp22) = fence_handle;
#line 1079
    __cil_tmp23 = (unsigned long )(& fence_rep) + 8;
#line 1079
    __cil_tmp24 = (unsigned long )fence;
#line 1079
    __cil_tmp25 = __cil_tmp24 + 4;
#line 1079
    *((uint32_t *)__cil_tmp23) = *((u32 *)__cil_tmp25);
#line 1080
    __cil_tmp26 = (unsigned long )dev_priv;
#line 1080
    __cil_tmp27 = __cil_tmp26 + 1856;
#line 1080
    __cil_tmp28 = (struct vmw_fifo_state *)__cil_tmp27;
#line 1080
    vmw_update_seqno(dev_priv, __cil_tmp28);
#line 1081
    __cil_tmp29 = (unsigned long )(& fence_rep) + 12;
#line 1081
    __cil_tmp30 = (unsigned long )dev_priv;
#line 1081
    __cil_tmp31 = __cil_tmp30 + 2980;
#line 1081
    *((uint32_t *)__cil_tmp29) = *((uint32_t *)__cil_tmp31);
    }
  } else {

  }
  {
#line 1089
  __cil_tmp32 = (void *)user_fence_rep;
#line 1089
  __cil_tmp33 = (void    *)(& fence_rep);
#line 1089
  __cil_tmp34 = (unsigned int )24UL;
#line 1089
  ret = (int )copy_to_user(__cil_tmp32, __cil_tmp33, __cil_tmp34);
#line 1096
  __cil_tmp35 = ret != 0;
#line 1096
  __cil_tmp36 = ! __cil_tmp35;
#line 1096
  __cil_tmp37 = ! __cil_tmp36;
#line 1096
  __cil_tmp38 = (long )__cil_tmp37;
#line 1096
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 0L);
  }
#line 1096
  if (tmp___8) {
    {
#line 1096
    __cil_tmp39 = (unsigned long )(& fence_rep) + 20;
#line 1096
    __cil_tmp40 = *((int32_t *)__cil_tmp39);
#line 1096
    if (__cil_tmp40 == 0) {
      {
#line 1097
      __cil_tmp41 = (unsigned long )vmw_fp;
#line 1097
      __cil_tmp42 = __cil_tmp41 + 8;
#line 1097
      __cil_tmp43 = *((struct ttm_object_file **)__cil_tmp42);
#line 1097
      __cil_tmp44 = (unsigned long )fence_handle;
#line 1097
      __cil_tmp45 = (enum ttm_ref_type )0;
#line 1097
      ttm_ref_object_base_unref(__cil_tmp43, __cil_tmp44, __cil_tmp45);
#line 1099
      drm_err("vmw_execbuf_copy_fence_user", "Fence copy error. Syncing.\n");
#line 1100
      __cil_tmp46 = (unsigned long )fence;
#line 1100
      __cil_tmp47 = __cil_tmp46 + 36;
#line 1100
      __cil_tmp48 = *((uint32_t *)__cil_tmp47);
#line 1100
      __cil_tmp49 = (bool )0;
#line 1100
      __cil_tmp50 = (bool )0;
#line 1100
      vmw_fence_obj_wait(fence, __cil_tmp48, __cil_tmp49, __cil_tmp50, 1250UL);
      }
    } else {

    }
    }
  } else {

  }
#line 1104
  return;
}
}
#line 1106 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) 
{ struct vmw_sw_context *sw_context ;
  struct vmw_fence_obj *fence ;
  uint32_t handle ;
  void *cmd ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long tmp___9 ;
  long tmp___10 ;
  struct vmw_fpriv *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___17 ;
  struct vmw_fpriv *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_fence_obj **__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void    *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  uint32_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct list_head *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct list_head *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  void *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct ttm_buffer_object *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct list_head *__cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  long __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  struct vmw_marker_queue *__cil_tmp123 ;
  uint32_t __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  long __cil_tmp128 ;
  void *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  long __cil_tmp135 ;
  void    *__cil_tmp136 ;
  void *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct list_head *__cil_tmp140 ;
  struct vmw_fence_obj **__cil_tmp141 ;
  struct vmw_fence_obj *__cil_tmp142 ;
  void *__cil_tmp143 ;
  struct vmw_fence_obj **__cil_tmp144 ;
  struct vmw_fence_obj *__cil_tmp145 ;
  uint32_t *__cil_tmp146 ;
  uint32_t __cil_tmp147 ;
  void *__cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  long __cil_tmp154 ;
  struct vmw_fence_obj **__cil_tmp155 ;
  struct vmw_fence_obj **__cil_tmp156 ;
  void *__cil_tmp157 ;
  void *__cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct vmw_fence_obj **__cil_tmp160 ;
  struct vmw_fence_obj *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  int __cil_tmp165 ;
  long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  struct mutex *__cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  struct list_head *__cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  struct mutex *__cil_tmp175 ;

  {
  {
#line 1115
  __cil_tmp30 = (unsigned long )dev_priv;
#line 1115
  __cil_tmp31 = __cil_tmp30 + 3032;
#line 1115
  sw_context = (struct vmw_sw_context *)__cil_tmp31;
#line 1116
  __cil_tmp32 = & fence;
#line 1116
  __cil_tmp33 = (void *)0;
#line 1116
  *__cil_tmp32 = (struct vmw_fence_obj *)__cil_tmp33;
#line 1121
  __cil_tmp34 = (unsigned long )dev_priv;
#line 1121
  __cil_tmp35 = __cil_tmp34 + 134304;
#line 1121
  __cil_tmp36 = (struct mutex *)__cil_tmp35;
#line 1121
  ret = (int )mutex_lock_interruptible(__cil_tmp36);
#line 1122
  __cil_tmp37 = ret != 0;
#line 1122
  __cil_tmp38 = ! __cil_tmp37;
#line 1122
  __cil_tmp39 = ! __cil_tmp38;
#line 1122
  __cil_tmp40 = (long )__cil_tmp39;
#line 1122
  tmp___7 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 1122
  if (tmp___7) {
#line 1123
    return (-512);
  } else {

  }
  {
#line 1125
  __cil_tmp41 = (void *)0;
#line 1125
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 1125
  __cil_tmp43 = (unsigned long )kernel_commands;
#line 1125
  if (__cil_tmp43 == __cil_tmp42) {
    {
#line 1126
    __cil_tmp44 = (unsigned long )sw_context;
#line 1126
    __cil_tmp45 = __cil_tmp44 + 61;
#line 1126
    *((bool *)__cil_tmp45) = (bool )0;
#line 1128
    ret = vmw_resize_cmd_bounce(sw_context, command_size);
#line 1129
    __cil_tmp46 = ret != 0;
#line 1129
    __cil_tmp47 = ! __cil_tmp46;
#line 1129
    __cil_tmp48 = ! __cil_tmp47;
#line 1129
    __cil_tmp49 = (long )__cil_tmp48;
#line 1129
    tmp___8 = ldv__builtin_expect(__cil_tmp49, 0L);
    }
#line 1129
    if (tmp___8) {
#line 1130
      goto out_unlock;
    } else {

    }
    {
#line 1133
    __cil_tmp50 = (unsigned long )sw_context;
#line 1133
    __cil_tmp51 = __cil_tmp50 + 131200;
#line 1133
    __cil_tmp52 = *((uint32_t **)__cil_tmp51);
#line 1133
    __cil_tmp53 = (void *)__cil_tmp52;
#line 1133
    __cil_tmp54 = (void    *)user_commands;
#line 1133
    __cil_tmp55 = (unsigned long )command_size;
#line 1133
    tmp___9 = (unsigned long )copy_from_user(__cil_tmp53, __cil_tmp54, __cil_tmp55);
#line 1133
    ret = (int )tmp___9;
#line 1136
    __cil_tmp56 = ret != 0;
#line 1136
    __cil_tmp57 = ! __cil_tmp56;
#line 1136
    __cil_tmp58 = ! __cil_tmp57;
#line 1136
    __cil_tmp59 = (long )__cil_tmp58;
#line 1136
    tmp___10 = ldv__builtin_expect(__cil_tmp59, 0L);
    }
#line 1136
    if (tmp___10) {
      {
#line 1137
      ret = -14;
#line 1138
      drm_err("vmw_execbuf_process", "Failed copying commands.\n");
      }
#line 1139
      goto out_unlock;
    } else {

    }
#line 1141
    __cil_tmp60 = (unsigned long )sw_context;
#line 1141
    __cil_tmp61 = __cil_tmp60 + 131200;
#line 1141
    __cil_tmp62 = *((uint32_t **)__cil_tmp61);
#line 1141
    kernel_commands = (void *)__cil_tmp62;
  } else {
#line 1143
    __cil_tmp63 = (unsigned long )sw_context;
#line 1143
    __cil_tmp64 = __cil_tmp63 + 61;
#line 1143
    *((bool *)__cil_tmp64) = (bool )1;
  }
  }
  {
#line 1145
  tmp___11 = vmw_fpriv(file_priv);
#line 1145
  __cil_tmp65 = (unsigned long )sw_context;
#line 1145
  __cil_tmp66 = __cil_tmp65 + 88;
#line 1145
  __cil_tmp67 = (unsigned long )tmp___11;
#line 1145
  __cil_tmp68 = __cil_tmp67 + 8;
#line 1145
  *((struct ttm_object_file **)__cil_tmp66) = *((struct ttm_object_file **)__cil_tmp68);
#line 1146
  __cil_tmp69 = (unsigned long )sw_context;
#line 1146
  __cil_tmp70 = __cil_tmp69 + 60;
#line 1146
  *((bool *)__cil_tmp70) = (bool )0;
#line 1147
  __cil_tmp71 = (unsigned long )sw_context;
#line 1147
  __cil_tmp72 = __cil_tmp71 + 80;
#line 1147
  *((bool *)__cil_tmp72) = (bool )0;
#line 1148
  __cil_tmp73 = (unsigned long )sw_context;
#line 1148
  __cil_tmp74 = __cil_tmp73 + 32880;
#line 1148
  *((uint32_t *)__cil_tmp74) = (uint32_t )0;
#line 1149
  __cil_tmp75 = (unsigned long )sw_context;
#line 1149
  __cil_tmp76 = __cil_tmp75 + 131192;
#line 1149
  *((uint32_t *)__cil_tmp76) = (uint32_t )0;
#line 1150
  __cil_tmp77 = (unsigned long )sw_context;
#line 1150
  __cil_tmp78 = __cil_tmp77 + 131232;
#line 1150
  *((uint32_t *)__cil_tmp78) = (uint32_t )0;
#line 1151
  __cil_tmp79 = (unsigned long )sw_context;
#line 1151
  __cil_tmp80 = __cil_tmp79 + 131240;
#line 1151
  __cil_tmp81 = (struct list_head *)__cil_tmp80;
#line 1151
  INIT_LIST_HEAD(__cil_tmp81);
#line 1152
  __cil_tmp82 = (unsigned long )sw_context;
#line 1152
  __cil_tmp83 = __cil_tmp82 + 131216;
#line 1152
  __cil_tmp84 = (struct list_head *)__cil_tmp83;
#line 1152
  INIT_LIST_HEAD(__cil_tmp84);
#line 1153
  __cil_tmp85 = (unsigned long )sw_context;
#line 1153
  __cil_tmp86 = __cil_tmp85 + 131256;
#line 1153
  __cil_tmp87 = (unsigned long )dev_priv;
#line 1153
  __cil_tmp88 = __cil_tmp87 + 134752;
#line 1153
  *((struct ttm_buffer_object **)__cil_tmp86) = *((struct ttm_buffer_object **)__cil_tmp88);
#line 1154
  __cil_tmp89 = (unsigned long )sw_context;
#line 1154
  __cil_tmp90 = __cil_tmp89 + 131264;
#line 1154
  __cil_tmp91 = (unsigned long )dev_priv;
#line 1154
  __cil_tmp92 = __cil_tmp91 + 134760;
#line 1154
  *((uint32_t *)__cil_tmp90) = *((uint32_t *)__cil_tmp92);
#line 1155
  __cil_tmp93 = (unsigned long )sw_context;
#line 1155
  __cil_tmp94 = __cil_tmp93 + 131268;
#line 1155
  __cil_tmp95 = (void *)0;
#line 1155
  __cil_tmp96 = (unsigned long )__cil_tmp95;
#line 1155
  __cil_tmp97 = (unsigned long )dev_priv;
#line 1155
  __cil_tmp98 = __cil_tmp97 + 134752;
#line 1155
  __cil_tmp99 = *((struct ttm_buffer_object **)__cil_tmp98);
#line 1155
  __cil_tmp100 = (unsigned long )__cil_tmp99;
#line 1155
  __cil_tmp101 = __cil_tmp100 != __cil_tmp96;
#line 1155
  *((bool *)__cil_tmp94) = (bool )__cil_tmp101;
#line 1157
  __cil_tmp102 = (unsigned long )sw_context;
#line 1157
  __cil_tmp103 = __cil_tmp102 + 96;
#line 1157
  __cil_tmp104 = (struct list_head *)__cil_tmp103;
#line 1157
  INIT_LIST_HEAD(__cil_tmp104);
#line 1159
  ret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands, command_size);
#line 1161
  __cil_tmp105 = ret != 0;
#line 1161
  __cil_tmp106 = ! __cil_tmp105;
#line 1161
  __cil_tmp107 = ! __cil_tmp106;
#line 1161
  __cil_tmp108 = (long )__cil_tmp107;
#line 1161
  tmp___12 = ldv__builtin_expect(__cil_tmp108, 0L);
  }
#line 1161
  if (tmp___12) {
#line 1162
    goto out_err;
  } else {

  }
  {
#line 1164
  __cil_tmp109 = (unsigned long )sw_context;
#line 1164
  __cil_tmp110 = __cil_tmp109 + 96;
#line 1164
  __cil_tmp111 = (struct list_head *)__cil_tmp110;
#line 1164
  ret = ttm_eu_reserve_buffers(__cil_tmp111);
#line 1165
  __cil_tmp112 = ret != 0;
#line 1165
  __cil_tmp113 = ! __cil_tmp112;
#line 1165
  __cil_tmp114 = ! __cil_tmp113;
#line 1165
  __cil_tmp115 = (long )__cil_tmp114;
#line 1165
  tmp___13 = ldv__builtin_expect(__cil_tmp115, 0L);
  }
#line 1165
  if (tmp___13) {
#line 1166
    goto out_err;
  } else {

  }
  {
#line 1168
  ret = vmw_validate_buffers(dev_priv, sw_context);
#line 1169
  __cil_tmp116 = ret != 0;
#line 1169
  __cil_tmp117 = ! __cil_tmp116;
#line 1169
  __cil_tmp118 = ! __cil_tmp117;
#line 1169
  __cil_tmp119 = (long )__cil_tmp118;
#line 1169
  tmp___14 = ldv__builtin_expect(__cil_tmp119, 0L);
  }
#line 1169
  if (tmp___14) {
#line 1170
    goto out_err;
  } else {

  }
  {
#line 1172
  vmw_apply_relocations(sw_context);
  }
#line 1174
  if (throttle_us) {
    {
#line 1175
    __cil_tmp120 = 1856 + 160;
#line 1175
    __cil_tmp121 = (unsigned long )dev_priv;
#line 1175
    __cil_tmp122 = __cil_tmp121 + __cil_tmp120;
#line 1175
    __cil_tmp123 = (struct vmw_marker_queue *)__cil_tmp122;
#line 1175
    __cil_tmp124 = (uint32_t )throttle_us;
#line 1175
    ret = vmw_wait_lag(dev_priv, __cil_tmp123, __cil_tmp124);
#line 1178
    __cil_tmp125 = ret != 0;
#line 1178
    __cil_tmp126 = ! __cil_tmp125;
#line 1178
    __cil_tmp127 = ! __cil_tmp126;
#line 1178
    __cil_tmp128 = (long )__cil_tmp127;
#line 1178
    tmp___15 = ldv__builtin_expect(__cil_tmp128, 0L);
    }
#line 1178
    if (tmp___15) {
#line 1179
      goto out_throttle;
    } else {

    }
  } else {

  }
  {
#line 1182
  cmd = vmw_fifo_reserve(dev_priv, command_size);
#line 1183
  __cil_tmp129 = (void *)0;
#line 1183
  __cil_tmp130 = (unsigned long )__cil_tmp129;
#line 1183
  __cil_tmp131 = (unsigned long )cmd;
#line 1183
  __cil_tmp132 = __cil_tmp131 == __cil_tmp130;
#line 1183
  __cil_tmp133 = ! __cil_tmp132;
#line 1183
  __cil_tmp134 = ! __cil_tmp133;
#line 1183
  __cil_tmp135 = (long )__cil_tmp134;
#line 1183
  tmp___16 = ldv__builtin_expect(__cil_tmp135, 0L);
  }
#line 1183
  if (tmp___16) {
    {
#line 1184
    drm_err("vmw_execbuf_process", "Failed reserving fifo space for commands.\n");
#line 1185
    ret = -12;
    }
#line 1186
    goto out_throttle;
  } else {

  }
  {
#line 1189
  __len = (size_t )command_size;
#line 1189
  __cil_tmp136 = (void    *)kernel_commands;
#line 1189
  __ret = __builtin_memcpy(cmd, __cil_tmp136, __len);
#line 1190
  vmw_fifo_commit(dev_priv, command_size);
#line 1192
  vmw_query_bo_switch_commit(dev_priv, sw_context);
  }
#line 1193
  if (user_fence_rep) {
#line 1193
    tmp___17 = & handle;
  } else {
#line 1193
    __cil_tmp137 = (void *)0;
#line 1193
    tmp___17 = (uint32_t *)__cil_tmp137;
  }
  {
#line 1193
  ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___17);
  }
#line 1202
  if (ret != 0) {
    {
#line 1203
    drm_err("vmw_execbuf_process", "Fence submission error. Syncing.\n");
    }
  } else {

  }
  {
#line 1205
  __cil_tmp138 = (unsigned long )sw_context;
#line 1205
  __cil_tmp139 = __cil_tmp138 + 96;
#line 1205
  __cil_tmp140 = (struct list_head *)__cil_tmp139;
#line 1205
  __cil_tmp141 = & fence;
#line 1205
  __cil_tmp142 = *__cil_tmp141;
#line 1205
  __cil_tmp143 = (void *)__cil_tmp142;
#line 1205
  ttm_eu_fence_buffer_objects(__cil_tmp140, __cil_tmp143);
#line 1208
  vmw_clear_validations(sw_context);
#line 1209
  tmp___18 = vmw_fpriv(file_priv);
#line 1209
  __cil_tmp144 = & fence;
#line 1209
  __cil_tmp145 = *__cil_tmp144;
#line 1209
  __cil_tmp146 = & handle;
#line 1209
  __cil_tmp147 = *__cil_tmp146;
#line 1209
  vmw_execbuf_copy_fence_user(dev_priv, tmp___18, ret, user_fence_rep, __cil_tmp145,
                              __cil_tmp147);
#line 1213
  __cil_tmp148 = (void *)0;
#line 1213
  __cil_tmp149 = (unsigned long )__cil_tmp148;
#line 1213
  __cil_tmp150 = (unsigned long )out_fence;
#line 1213
  __cil_tmp151 = __cil_tmp150 != __cil_tmp149;
#line 1213
  __cil_tmp152 = ! __cil_tmp151;
#line 1213
  __cil_tmp153 = ! __cil_tmp152;
#line 1213
  __cil_tmp154 = (long )__cil_tmp153;
#line 1213
  tmp___20 = ldv__builtin_expect(__cil_tmp154, 0L);
  }
#line 1213
  if (tmp___20) {
#line 1214
    __cil_tmp155 = & fence;
#line 1214
    *out_fence = *__cil_tmp155;
#line 1215
    __cil_tmp156 = & fence;
#line 1215
    __cil_tmp157 = (void *)0;
#line 1215
    *__cil_tmp156 = (struct vmw_fence_obj *)__cil_tmp157;
  } else {
    {
#line 1216
    __cil_tmp158 = (void *)0;
#line 1216
    __cil_tmp159 = (unsigned long )__cil_tmp158;
#line 1216
    __cil_tmp160 = & fence;
#line 1216
    __cil_tmp161 = *__cil_tmp160;
#line 1216
    __cil_tmp162 = (unsigned long )__cil_tmp161;
#line 1216
    __cil_tmp163 = __cil_tmp162 != __cil_tmp159;
#line 1216
    __cil_tmp164 = ! __cil_tmp163;
#line 1216
    __cil_tmp165 = ! __cil_tmp164;
#line 1216
    __cil_tmp166 = (long )__cil_tmp165;
#line 1216
    tmp___19 = ldv__builtin_expect(__cil_tmp166, 1L);
    }
#line 1216
    if (tmp___19) {
      {
#line 1217
      vmw_fence_obj_unreference(& fence);
      }
    } else {

    }
  }
  {
#line 1220
  __cil_tmp167 = (unsigned long )dev_priv;
#line 1220
  __cil_tmp168 = __cil_tmp167 + 134304;
#line 1220
  __cil_tmp169 = (struct mutex *)__cil_tmp168;
#line 1220
  mutex_unlock(__cil_tmp169);
  }
#line 1221
  return (0);
  out_err: 
  {
#line 1224
  vmw_free_relocations(sw_context);
  }
  out_throttle: 
  {
#line 1226
  vmw_query_switch_backoff(sw_context);
#line 1227
  __cil_tmp170 = (unsigned long )sw_context;
#line 1227
  __cil_tmp171 = __cil_tmp170 + 96;
#line 1227
  __cil_tmp172 = (struct list_head *)__cil_tmp171;
#line 1227
  ttm_eu_backoff_reservation(__cil_tmp172);
#line 1228
  vmw_clear_validations(sw_context);
  }
  out_unlock: 
  {
#line 1230
  __cil_tmp173 = (unsigned long )dev_priv;
#line 1230
  __cil_tmp174 = __cil_tmp173 + 134304;
#line 1230
  __cil_tmp175 = (struct mutex *)__cil_tmp174;
#line 1230
  mutex_unlock(__cil_tmp175);
  }
#line 1231
  return (ret);
}
}
#line 1243 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
static void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv ) 
{ bool __cil_tmp2 ;
  bool __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  bool __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ttm_buffer_object *__cil_tmp8 ;
  bool __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_buffer_object *__cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 1245
  drm_err("vmw_execbuf_unpin_panic", "Can\'t unpin query buffer. Trying to recover.\n");
#line 1247
  __cil_tmp2 = (bool )0;
#line 1247
  __cil_tmp3 = (bool )1;
#line 1247
  __cil_tmp4 = (uint32_t )0;
#line 1247
  __cil_tmp5 = (bool )0;
#line 1247
  vmw_fallback_wait(dev_priv, __cil_tmp2, __cil_tmp3, __cil_tmp4, __cil_tmp5, 2500UL);
#line 1248
  __cil_tmp6 = (unsigned long )dev_priv;
#line 1248
  __cil_tmp7 = __cil_tmp6 + 134752;
#line 1248
  __cil_tmp8 = *((struct ttm_buffer_object **)__cil_tmp7);
#line 1248
  __cil_tmp9 = (bool )0;
#line 1248
  vmw_bo_pin(__cil_tmp8, __cil_tmp9);
#line 1249
  __cil_tmp10 = (unsigned long )dev_priv;
#line 1249
  __cil_tmp11 = __cil_tmp10 + 134744;
#line 1249
  __cil_tmp12 = *((struct ttm_buffer_object **)__cil_tmp11);
#line 1249
  __cil_tmp13 = (bool )0;
#line 1249
  vmw_bo_pin(__cil_tmp12, __cil_tmp13);
#line 1250
  __cil_tmp14 = (unsigned long )dev_priv;
#line 1250
  __cil_tmp15 = __cil_tmp14 + 134764;
#line 1250
  *((bool *)__cil_tmp15) = (bool )0;
  }
#line 1251
  return;
}
}
#line 1275 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) 
{ int ret ;
  struct list_head validate_list ;
  struct ttm_validate_buffer pinned_val ;
  struct ttm_validate_buffer query_val ;
  struct vmw_fence_obj *fence ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct ttm_buffer_object *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct ttm_buffer_object *__cil_tmp27 ;
  struct ttm_validate_buffer *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct ttm_buffer_object *__cil_tmp35 ;
  struct ttm_validate_buffer *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_buffer_object *__cil_tmp51 ;
  bool __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_buffer_object *__cil_tmp55 ;
  bool __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  void *__cil_tmp59 ;
  struct drm_file *__cil_tmp60 ;
  void *__cil_tmp61 ;
  uint32_t *__cil_tmp62 ;
  struct vmw_fence_obj **__cil_tmp63 ;
  struct vmw_fence_obj *__cil_tmp64 ;
  void *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  struct ttm_buffer_object **__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct ttm_buffer_object **__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct ttm_buffer_object **__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct mutex *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct ttm_buffer_object **__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object **__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct ttm_buffer_object **__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct mutex *__cil_tmp85 ;

  {
  {
#line 1278
  ret = 0;
#line 1283
  __cil_tmp11 = (unsigned long )dev_priv;
#line 1283
  __cil_tmp12 = __cil_tmp11 + 134304;
#line 1283
  __cil_tmp13 = (struct mutex *)__cil_tmp12;
#line 1283
  mutex_lock(__cil_tmp13);
  }
  {
#line 1285
  __cil_tmp14 = (void *)0;
#line 1285
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 1285
  __cil_tmp16 = (unsigned long )dev_priv;
#line 1285
  __cil_tmp17 = __cil_tmp16 + 134752;
#line 1285
  __cil_tmp18 = *((struct ttm_buffer_object **)__cil_tmp17);
#line 1285
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 1285
  if (__cil_tmp19 == __cil_tmp15) {
#line 1286
    goto out_unlock;
  } else {

  }
  }
#line 1288
  if (only_on_cid_match) {
    {
#line 1288
    __cil_tmp20 = (unsigned long )dev_priv;
#line 1288
    __cil_tmp21 = __cil_tmp20 + 134760;
#line 1288
    __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 1288
    if (cid != __cil_tmp22) {
#line 1289
      goto out_unlock;
    } else {

    }
    }
  } else {

  }
  {
#line 1291
  INIT_LIST_HEAD(& validate_list);
#line 1293
  __cil_tmp23 = (unsigned long )(& pinned_val) + 24;
#line 1293
  *((void **)__cil_tmp23) = (void *)1UL;
#line 1295
  __cil_tmp24 = (unsigned long )(& pinned_val) + 16;
#line 1295
  __cil_tmp25 = (unsigned long )dev_priv;
#line 1295
  __cil_tmp26 = __cil_tmp25 + 134752;
#line 1295
  __cil_tmp27 = *((struct ttm_buffer_object **)__cil_tmp26);
#line 1295
  *((struct ttm_buffer_object **)__cil_tmp24) = ttm_bo_reference(__cil_tmp27);
#line 1296
  __cil_tmp28 = & pinned_val;
#line 1296
  __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 1296
  list_add_tail(__cil_tmp29, & validate_list);
#line 1298
  __cil_tmp30 = (unsigned long )(& query_val) + 24;
#line 1298
  __cil_tmp31 = (unsigned long )(& pinned_val) + 24;
#line 1298
  *((void **)__cil_tmp30) = *((void **)__cil_tmp31);
#line 1299
  __cil_tmp32 = (unsigned long )(& query_val) + 16;
#line 1299
  __cil_tmp33 = (unsigned long )dev_priv;
#line 1299
  __cil_tmp34 = __cil_tmp33 + 134744;
#line 1299
  __cil_tmp35 = *((struct ttm_buffer_object **)__cil_tmp34);
#line 1299
  *((struct ttm_buffer_object **)__cil_tmp32) = ttm_bo_reference(__cil_tmp35);
#line 1300
  __cil_tmp36 = & query_val;
#line 1300
  __cil_tmp37 = (struct list_head *)__cil_tmp36;
#line 1300
  list_add_tail(__cil_tmp37, & validate_list);
  }
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1303
    ret = ttm_eu_reserve_buffers(& validate_list);
    }
#line 1302
    if (ret == -512) {

    } else {
#line 1302
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1306
  __cil_tmp38 = ret != 0;
#line 1306
  __cil_tmp39 = ! __cil_tmp38;
#line 1306
  __cil_tmp40 = ! __cil_tmp39;
#line 1306
  __cil_tmp41 = (long )__cil_tmp40;
#line 1306
  tmp___7 = ldv__builtin_expect(__cil_tmp41, 0L);
  }
#line 1306
  if (tmp___7) {
    {
#line 1307
    vmw_execbuf_unpin_panic(dev_priv);
    }
#line 1308
    goto out_no_reserve;
  } else {

  }
  {
#line 1311
  __cil_tmp42 = (unsigned long )dev_priv;
#line 1311
  __cil_tmp43 = __cil_tmp42 + 134760;
#line 1311
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
#line 1311
  ret = vmw_fifo_emit_dummy_query(dev_priv, __cil_tmp44);
#line 1312
  __cil_tmp45 = ret != 0;
#line 1312
  __cil_tmp46 = ! __cil_tmp45;
#line 1312
  __cil_tmp47 = ! __cil_tmp46;
#line 1312
  __cil_tmp48 = (long )__cil_tmp47;
#line 1312
  tmp___8 = ldv__builtin_expect(__cil_tmp48, 0L);
  }
#line 1312
  if (tmp___8) {
    {
#line 1313
    vmw_execbuf_unpin_panic(dev_priv);
    }
#line 1314
    goto out_no_emit;
  } else {

  }
  {
#line 1317
  __cil_tmp49 = (unsigned long )dev_priv;
#line 1317
  __cil_tmp50 = __cil_tmp49 + 134752;
#line 1317
  __cil_tmp51 = *((struct ttm_buffer_object **)__cil_tmp50);
#line 1317
  __cil_tmp52 = (bool )0;
#line 1317
  vmw_bo_pin(__cil_tmp51, __cil_tmp52);
#line 1318
  __cil_tmp53 = (unsigned long )dev_priv;
#line 1318
  __cil_tmp54 = __cil_tmp53 + 134744;
#line 1318
  __cil_tmp55 = *((struct ttm_buffer_object **)__cil_tmp54);
#line 1318
  __cil_tmp56 = (bool )0;
#line 1318
  vmw_bo_pin(__cil_tmp55, __cil_tmp56);
#line 1319
  __cil_tmp57 = (unsigned long )dev_priv;
#line 1319
  __cil_tmp58 = __cil_tmp57 + 134764;
#line 1319
  *((bool *)__cil_tmp58) = (bool )0;
#line 1321
  __cil_tmp59 = (void *)0;
#line 1321
  __cil_tmp60 = (struct drm_file *)__cil_tmp59;
#line 1321
  __cil_tmp61 = (void *)0;
#line 1321
  __cil_tmp62 = (uint32_t *)__cil_tmp61;
#line 1321
  vmw_execbuf_fence_commands(__cil_tmp60, dev_priv, & fence, __cil_tmp62);
#line 1322
  __cil_tmp63 = & fence;
#line 1322
  __cil_tmp64 = *__cil_tmp63;
#line 1322
  __cil_tmp65 = (void *)__cil_tmp64;
#line 1322
  ttm_eu_fence_buffer_objects(& validate_list, __cil_tmp65);
#line 1324
  __cil_tmp66 = (unsigned long )(& query_val) + 16;
#line 1324
  __cil_tmp67 = (struct ttm_buffer_object **)__cil_tmp66;
#line 1324
  ttm_bo_unref(__cil_tmp67);
#line 1325
  __cil_tmp68 = (unsigned long )(& pinned_val) + 16;
#line 1325
  __cil_tmp69 = (struct ttm_buffer_object **)__cil_tmp68;
#line 1325
  ttm_bo_unref(__cil_tmp69);
#line 1326
  __cil_tmp70 = (unsigned long )dev_priv;
#line 1326
  __cil_tmp71 = __cil_tmp70 + 134752;
#line 1326
  __cil_tmp72 = (struct ttm_buffer_object **)__cil_tmp71;
#line 1326
  ttm_bo_unref(__cil_tmp72);
  }
  out_unlock: 
  {
#line 1329
  __cil_tmp73 = (unsigned long )dev_priv;
#line 1329
  __cil_tmp74 = __cil_tmp73 + 134304;
#line 1329
  __cil_tmp75 = (struct mutex *)__cil_tmp74;
#line 1329
  mutex_unlock(__cil_tmp75);
  }
#line 1330
  return;
  out_no_emit: 
  {
#line 1333
  ttm_eu_backoff_reservation(& validate_list);
  }
  out_no_reserve: 
  {
#line 1335
  __cil_tmp76 = (unsigned long )(& query_val) + 16;
#line 1335
  __cil_tmp77 = (struct ttm_buffer_object **)__cil_tmp76;
#line 1335
  ttm_bo_unref(__cil_tmp77);
#line 1336
  __cil_tmp78 = (unsigned long )(& pinned_val) + 16;
#line 1336
  __cil_tmp79 = (struct ttm_buffer_object **)__cil_tmp78;
#line 1336
  ttm_bo_unref(__cil_tmp79);
#line 1337
  __cil_tmp80 = (unsigned long )dev_priv;
#line 1337
  __cil_tmp81 = __cil_tmp80 + 134752;
#line 1337
  __cil_tmp82 = (struct ttm_buffer_object **)__cil_tmp81;
#line 1337
  ttm_bo_unref(__cil_tmp82);
#line 1338
  __cil_tmp83 = (unsigned long )dev_priv;
#line 1338
  __cil_tmp84 = __cil_tmp83 + 134304;
#line 1338
  __cil_tmp85 = (struct mutex *)__cil_tmp84;
#line 1338
  mutex_unlock(__cil_tmp85);
  }
#line 1339
  return;
}
}
#line 1342 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_execbuf_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  int ret ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_master *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct ttm_lock *__cil_tmp23 ;
  bool __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  uint64_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  uint64_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint64_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  void *__cil_tmp44 ;
  struct drm_vmw_fence_rep *__cil_tmp45 ;
  void *__cil_tmp46 ;
  struct vmw_fence_obj **__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  struct ttm_lock *__cil_tmp52 ;

  {
  {
#line 1345
  tmp___7 = vmw_priv(dev);
#line 1345
  dev_priv = tmp___7;
#line 1346
  arg = (struct drm_vmw_execbuf_arg *)data;
#line 1347
  __cil_tmp13 = (unsigned long )file_priv;
#line 1347
  __cil_tmp14 = __cil_tmp13 + 152;
#line 1347
  __cil_tmp15 = *((struct drm_master **)__cil_tmp14);
#line 1347
  tmp___8 = vmw_master(__cil_tmp15);
#line 1347
  vmaster = tmp___8;
#line 1357
  __cil_tmp16 = (unsigned long )arg;
#line 1357
  __cil_tmp17 = __cil_tmp16 + 24;
#line 1357
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
#line 1357
  __cil_tmp19 = __cil_tmp18 != 1U;
#line 1357
  __cil_tmp20 = ! __cil_tmp19;
#line 1357
  __cil_tmp21 = ! __cil_tmp20;
#line 1357
  __cil_tmp22 = (long )__cil_tmp21;
#line 1357
  tmp___9 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 1357
  if (tmp___9) {
    {
#line 1358
    drm_err("vmw_execbuf_ioctl", "Incorrect execbuf version.\n");
#line 1359
    drm_err("vmw_execbuf_ioctl", "You\'re running outdated experimental vmwgfx user-space drivers.");
    }
#line 1361
    return (-22);
  } else {

  }
  {
#line 1364
  __cil_tmp23 = (struct ttm_lock *)vmaster;
#line 1364
  __cil_tmp24 = (bool )1;
#line 1364
  ret = ttm_read_lock(__cil_tmp23, __cil_tmp24);
#line 1365
  __cil_tmp25 = ret != 0;
#line 1365
  __cil_tmp26 = ! __cil_tmp25;
#line 1365
  __cil_tmp27 = ! __cil_tmp26;
#line 1365
  __cil_tmp28 = (long )__cil_tmp27;
#line 1365
  tmp___10 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 1365
  if (tmp___10) {
#line 1366
    return (ret);
  } else {

  }
  {
#line 1368
  __cil_tmp29 = *((uint64_t *)arg);
#line 1368
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 1368
  __cil_tmp31 = (void *)__cil_tmp30;
#line 1368
  __cil_tmp32 = (void *)0;
#line 1368
  __cil_tmp33 = (unsigned long )arg;
#line 1368
  __cil_tmp34 = __cil_tmp33 + 8;
#line 1368
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 1368
  __cil_tmp36 = (unsigned long )arg;
#line 1368
  __cil_tmp37 = __cil_tmp36 + 12;
#line 1368
  __cil_tmp38 = *((uint32_t *)__cil_tmp37);
#line 1368
  __cil_tmp39 = (uint64_t )__cil_tmp38;
#line 1368
  __cil_tmp40 = (unsigned long )arg;
#line 1368
  __cil_tmp41 = __cil_tmp40 + 16;
#line 1368
  __cil_tmp42 = *((uint64_t *)__cil_tmp41);
#line 1368
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 1368
  __cil_tmp44 = (void *)__cil_tmp43;
#line 1368
  __cil_tmp45 = (struct drm_vmw_fence_rep *)__cil_tmp44;
#line 1368
  __cil_tmp46 = (void *)0;
#line 1368
  __cil_tmp47 = (struct vmw_fence_obj **)__cil_tmp46;
#line 1368
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp31, __cil_tmp32, __cil_tmp35,
                            __cil_tmp39, __cil_tmp45, __cil_tmp47);
#line 1374
  __cil_tmp48 = ret != 0;
#line 1374
  __cil_tmp49 = ! __cil_tmp48;
#line 1374
  __cil_tmp50 = ! __cil_tmp49;
#line 1374
  __cil_tmp51 = (long )__cil_tmp50;
#line 1374
  tmp___11 = ldv__builtin_expect(__cil_tmp51, 0L);
  }
#line 1374
  if (tmp___11) {
#line 1375
    goto out_unlock;
  } else {

  }
  {
#line 1377
  vmw_kms_cursor_post_execbuf(dev_priv);
  }
  out_unlock: 
  {
#line 1380
  __cil_tmp52 = (struct ttm_lock *)vmaster;
#line 1380
  ttm_read_unlock(__cil_tmp52);
  }
#line 1381
  return (ret);
}
}
#line 5 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast-assert.h"
void ldv_blast_assert(void) 
{ 

  {
  ERROR: 
#line 6
  goto ERROR;
}
}
#line 6 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast.h"
extern int __VERIFIER_nondet_int(void) ;
#line 19 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int ldv_mutex  =    1;
#line 22 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 29
  if (ldv_mutex == 1) {

  } else {
    {
#line 29
    ldv_blast_assert();
    }
  }
  {
#line 32
  nondetermined = __VERIFIER_nondet_int();
  }
#line 35
  if (nondetermined) {
#line 38
    ldv_mutex = 2;
#line 40
    return (0);
  } else {
#line 45
    return (-4);
  }
}
}
#line 50 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 57
  if (ldv_mutex == 1) {

  } else {
    {
#line 57
    ldv_blast_assert();
    }
  }
  {
#line 60
  nondetermined = __VERIFIER_nondet_int();
  }
#line 63
  if (nondetermined) {
#line 66
    ldv_mutex = 2;
#line 68
    return (0);
  } else {
#line 73
    return (-4);
  }
}
}
#line 78 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 83
  if (ldv_mutex == 1) {

  } else {
    {
#line 83
    ldv_blast_assert();
    }
  }
  {
#line 86
  atomic_value_after_dec = __VERIFIER_nondet_int();
  }
#line 89
  if (atomic_value_after_dec == 0) {
#line 92
    ldv_mutex = 2;
#line 94
    return (1);
  } else {

  }
#line 98
  return (0);
}
}
#line 103 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_lock(struct mutex *lock ) 
{ 

  {
#line 108
  if (ldv_mutex == 1) {

  } else {
    {
#line 108
    ldv_blast_assert();
    }
  }
#line 110
  ldv_mutex = 2;
#line 111
  return;
}
}
#line 114 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_trylock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 121
  if (ldv_mutex == 1) {

  } else {
    {
#line 121
    ldv_blast_assert();
    }
  }
  {
#line 124
  nondetermined = __VERIFIER_nondet_int();
  }
#line 127
  if (nondetermined) {
#line 130
    ldv_mutex = 2;
#line 132
    return (1);
  } else {
#line 137
    return (0);
  }
}
}
#line 142 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_unlock(struct mutex *lock ) 
{ 

  {
#line 147
  if (ldv_mutex == 2) {

  } else {
    {
#line 147
    ldv_blast_assert();
    }
  }
#line 149
  ldv_mutex = 1;
#line 150
  return;
}
}
#line 153 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void ldv_check_final_state(void) 
{ 

  {
#line 156
  if (ldv_mutex == 1) {

  } else {
    {
#line 156
    ldv_blast_assert();
    }
  }
#line 157
  return;
}
}
#line 1386 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"
long ldv__builtin_expect(long val , long res ) 
{ 

  {
#line 1387
  return (val);
}
}
#line 88 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 34 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void *to , void    *from , size_t len ) ;
#line 220 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack  __attribute__((__section__(".data..percpu"))) ;
#line 222
__inline static struct thread_info *current_thread_info(void)  __attribute__((__no_instrument_function__)) ;
#line 222 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 225
  if ((int )8UL == 1) {
#line 225
    goto case_1;
  } else
#line 225
  if ((int )8UL == 2) {
#line 225
    goto case_2;
  } else
#line 225
  if ((int )8UL == 4) {
#line 225
    goto case_4;
  } else
#line 225
  if ((int )8UL == 8) {
#line 225
    goto case_8;
  } else {
    {
#line 225
    goto switch_default;
#line 225
    if (0) {
      case_1: /* CIL Label */ 
#line 225
      __asm__  ("mov"
                "b "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 225
      goto switch_break;
      case_2: /* CIL Label */ 
#line 225
      __asm__  ("mov"
                "w "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 225
      goto switch_break;
      case_4: /* CIL Label */ 
#line 225
      __asm__  ("mov"
                "l "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 225
      goto switch_break;
      case_8: /* CIL Label */ 
#line 225
      __asm__  ("mov"
                "q "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 225
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 225
      __bad_percpu_size();
      }
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
#line 225
  __cil_tmp3 = 1UL << 12;
#line 225
  __cil_tmp4 = __cil_tmp3 << 1;
#line 225
  __cil_tmp5 = pfo_ret__ + 40UL;
#line 225
  __cil_tmp6 = __cil_tmp5 - __cil_tmp4;
#line 225
  __cil_tmp7 = (void *)__cil_tmp6;
#line 225
  ti = (struct thread_info *)__cil_tmp7;
#line 227
  return (ti);
}
}
#line 310 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 

  {
#line 310
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
#line 310
  return;
}
}
#line 324 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t gfp_mask , unsigned int order ) ;
#line 326
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
#line 326 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ struct page *tmp ;

  {
  {
#line 329
  tmp = alloc_pages_current(gfp_mask, order);
  }
#line 329
  return (tmp);
}
}
#line 360
extern void __free_pages(struct page *page , unsigned int order ) ;
#line 737 "include/linux/mm.h"
__inline static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page    *page )  __attribute__((__no_instrument_function__)) ;
#line 737 "include/linux/mm.h"
__inline static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page    *page ) 
{ struct page *__cil_tmp2 ;
  struct page    *__cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  phys_addr_t __cil_tmp6 ;
  phys_addr_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
  {
#line 739
  __cil_tmp2 = (struct page *)0xffffea0000000000UL;
#line 739
  __cil_tmp3 = (struct page    *)__cil_tmp2;
#line 739
  __cil_tmp4 = page - __cil_tmp3;
#line 739
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 739
  __cil_tmp6 = (phys_addr_t )__cil_tmp5;
#line 739
  __cil_tmp7 = __cil_tmp6 << 12;
#line 739
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 739
  __cil_tmp9 = __cil_tmp8 + 0xffff880000000000UL;
#line 739
  return ((void *)__cil_tmp9);
  }
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ struct thread_info *tmp___7 ;
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 18
    tmp___7 = current_thread_info();
#line 18
    __cil_tmp2 = (unsigned long )tmp___7;
#line 18
    __cil_tmp3 = __cil_tmp2 + 28;
#line 18
    __cil_tmp4 = (unsigned long )tmp___7;
#line 18
    __cil_tmp5 = __cil_tmp4 + 28;
#line 18
    __cil_tmp6 = *((int *)__cil_tmp5);
#line 18
    *((int *)__cil_tmp3) = __cil_tmp6 + 1;
    }
#line 18
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26
__inline static void pagefault_enable(void)  __attribute__((__no_instrument_function__)) ;
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ struct thread_info *tmp___7 ;
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 33
    tmp___7 = current_thread_info();
#line 33
    __cil_tmp2 = (unsigned long )tmp___7;
#line 33
    __cil_tmp3 = __cil_tmp2 + 28;
#line 33
    __cil_tmp4 = (unsigned long )tmp___7;
#line 33
    __cil_tmp5 = __cil_tmp4 + 28;
#line 33
    __cil_tmp6 = *((int *)__cil_tmp5);
#line 33
    *((int *)__cil_tmp3) = __cil_tmp6 - 1;
    }
#line 33
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  __asm__  volatile   ("": : : "memory");
  {
#line 38
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 38
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 39
  return;
}
}
#line 59 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 59 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ void *tmp___7 ;
  struct page    *__cil_tmp3 ;

  {
  {
#line 61
  pagefault_disable();
#line 62
  __cil_tmp3 = (struct page    *)page;
#line 62
  tmp___7 = lowmem_page_address(__cil_tmp3);
  }
#line 62
  return (tmp___7);
}
}
#line 66
__inline static void __kunmap_atomic(void *addr )  __attribute__((__no_instrument_function__)) ;
#line 66 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 

  {
  {
#line 68
  pagefault_enable();
  }
#line 69
  return;
}
}
#line 351 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value )  __attribute__((__no_instrument_function__)) ;
#line 351 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 354
  __cil_tmp4 = (unsigned long )dev_priv;
#line 354
  __cil_tmp5 = __cil_tmp4 + 2104;
#line 354
  __cil_tmp6 = *((unsigned int *)__cil_tmp5);
#line 354
  __cil_tmp7 = (int )__cil_tmp6;
#line 354
  outl(offset, __cil_tmp7);
#line 355
  __cil_tmp8 = (unsigned long )dev_priv;
#line 355
  __cil_tmp9 = __cil_tmp8 + 2104;
#line 355
  __cil_tmp10 = *((unsigned int *)__cil_tmp9);
#line 355
  __cil_tmp11 = __cil_tmp10 + 1U;
#line 355
  __cil_tmp12 = (int )__cil_tmp11;
#line 355
  outl(value, __cil_tmp12);
  }
#line 356
  return;
}
}
#line 375
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) ;
#line 379
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) ;
#line 34 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
static int vmw_gmr2_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                         int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  SVGAFifoCmdRemapGMR2 remap_cmd ;
  uint32_t define_size ;
  uint32_t remap_size ;
  uint32_t *cmd ;
  uint32_t *cmd_orig ;
  uint32_t i ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t *tmp___9 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___10 ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct page **tmp___11 ;
  struct page **tmp___12 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  SVGAFifoCmdDefineGMR2 *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  SVGAFifoCmdRemapGMR2 *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  void    *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void    *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void *__cil_tmp46 ;
  void    *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void    *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct page *__cil_tmp52 ;
  struct page *__cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  uint64_t *__cil_tmp56 ;
  struct page *__cil_tmp57 ;
  struct page *__cil_tmp58 ;
  int __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  uint32_t __cil_tmp62 ;

  {
  {
#line 41
  __cil_tmp22 = 8UL + 4UL;
#line 41
  define_size = (uint32_t )__cil_tmp22;
#line 42
  __cil_tmp23 = 8UL * num_pages;
#line 42
  __cil_tmp24 = __cil_tmp23 + 16UL;
#line 42
  __cil_tmp25 = __cil_tmp24 + 4UL;
#line 42
  remap_size = (uint32_t )__cil_tmp25;
#line 47
  __cil_tmp26 = define_size + remap_size;
#line 47
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp26);
#line 47
  cmd = (uint32_t *)tmp___7;
#line 47
  cmd_orig = cmd;
#line 48
  __cil_tmp27 = (void *)0;
#line 48
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 48
  __cil_tmp29 = (unsigned long )cmd;
#line 48
  __cil_tmp30 = __cil_tmp29 == __cil_tmp28;
#line 48
  __cil_tmp31 = ! __cil_tmp30;
#line 48
  __cil_tmp32 = ! __cil_tmp31;
#line 48
  __cil_tmp33 = (long )__cil_tmp32;
#line 48
  tmp___8 = ldv__builtin_expect(__cil_tmp33, 0L);
  }
#line 48
  if (tmp___8) {
#line 49
    return (-12);
  } else {

  }
#line 51
  __cil_tmp34 = & define_cmd;
#line 51
  *((uint32 *)__cil_tmp34) = (uint32 )gmr_id;
#line 52
  __cil_tmp35 = (unsigned long )(& define_cmd) + 4;
#line 52
  *((uint32 *)__cil_tmp35) = (uint32 )num_pages;
#line 54
  __cil_tmp36 = & remap_cmd;
#line 54
  *((uint32 *)__cil_tmp36) = (uint32 )gmr_id;
#line 55
  if (8UL > 4UL) {
#line 55
    __cil_tmp37 = (unsigned long )(& remap_cmd) + 4;
#line 55
    *((SVGARemapGMR2Flags *)__cil_tmp37) = (SVGARemapGMR2Flags )2;
  } else {
#line 55
    __cil_tmp38 = (unsigned long )(& remap_cmd) + 4;
#line 55
    *((SVGARemapGMR2Flags *)__cil_tmp38) = (SVGARemapGMR2Flags )0;
  }
#line 57
  __cil_tmp39 = (unsigned long )(& remap_cmd) + 8;
#line 57
  *((uint32 *)__cil_tmp39) = (uint32 )0;
#line 58
  __cil_tmp40 = (unsigned long )(& remap_cmd) + 12;
#line 58
  *((uint32 *)__cil_tmp40) = (uint32 )num_pages;
#line 60
  tmp___9 = cmd;
#line 60
  cmd = cmd + 1;
#line 60
  *tmp___9 = (uint32_t )41;
#line 61
  __len = 8UL;
#line 61
  if (__len >= 64UL) {
    {
#line 61
    __cil_tmp41 = (void *)cmd;
#line 61
    __cil_tmp42 = (void    *)(& define_cmd);
#line 61
    __ret = __memcpy(__cil_tmp41, __cil_tmp42, __len);
    }
  } else {
    {
#line 61
    __cil_tmp43 = (void *)cmd;
#line 61
    __cil_tmp44 = (void    *)(& define_cmd);
#line 61
    __ret = __builtin_memcpy(__cil_tmp43, __cil_tmp44, __len);
    }
  }
#line 62
  __cil_tmp45 = 8UL / 4UL;
#line 62
  cmd = cmd + __cil_tmp45;
#line 64
  tmp___10 = cmd;
#line 64
  cmd = cmd + 1;
#line 64
  *tmp___10 = (uint32_t )42;
#line 65
  __len___0 = 16UL;
#line 65
  if (__len___0 >= 64UL) {
    {
#line 65
    __cil_tmp46 = (void *)cmd;
#line 65
    __cil_tmp47 = (void    *)(& remap_cmd);
#line 65
    __ret___0 = __memcpy(__cil_tmp46, __cil_tmp47, __len___0);
    }
  } else {
    {
#line 65
    __cil_tmp48 = (void *)cmd;
#line 65
    __cil_tmp49 = (void    *)(& remap_cmd);
#line 65
    __ret___0 = __builtin_memcpy(__cil_tmp48, __cil_tmp49, __len___0);
    }
  }
#line 66
  __cil_tmp50 = 16UL / 4UL;
#line 66
  cmd = cmd + __cil_tmp50;
#line 68
  i = (uint32_t )0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    __cil_tmp51 = (unsigned long )i;
#line 68
    if (__cil_tmp51 < num_pages) {

    } else {
#line 68
      goto while_break;
    }
    }
#line 69
    if (8UL > 4UL) {
#line 70
      tmp___11 = pages;
#line 70
      pages = pages + 1;
#line 70
      __cil_tmp52 = (struct page *)0xffffea0000000000UL;
#line 70
      __cil_tmp53 = *tmp___11;
#line 70
      __cil_tmp54 = __cil_tmp53 - __cil_tmp52;
#line 70
      __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 70
      *cmd = (uint32_t )__cil_tmp55;
    } else {
#line 72
      tmp___12 = pages;
#line 72
      pages = pages + 1;
#line 72
      __cil_tmp56 = (uint64_t *)cmd;
#line 72
      __cil_tmp57 = (struct page *)0xffffea0000000000UL;
#line 72
      __cil_tmp58 = *tmp___12;
#line 72
      __cil_tmp59 = __cil_tmp58 - __cil_tmp57;
#line 72
      __cil_tmp60 = (unsigned long )__cil_tmp59;
#line 72
      *__cil_tmp56 = (uint64_t )__cil_tmp60;
    }
#line 74
    __cil_tmp61 = 8UL / 4UL;
#line 74
    cmd = cmd + __cil_tmp61;
#line 68
    i = i + 1U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  __cil_tmp62 = define_size + remap_size;
#line 77
  vmw_fifo_commit(dev_priv, __cil_tmp62);
  }
#line 79
  return (0);
}
}
#line 82 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
static void vmw_gmr2_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  uint32_t define_size ;
  uint32_t *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t *tmp___9 ;
  size_t __len ;
  void *__ret ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  SVGAFifoCmdDefineGMR2 *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  void    *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void    *__cil_tmp24 ;

  {
  {
#line 86
  __cil_tmp11 = 8UL + 4UL;
#line 86
  define_size = (uint32_t )__cil_tmp11;
#line 89
  tmp___7 = vmw_fifo_reserve(dev_priv, define_size);
#line 89
  cmd = (uint32_t *)tmp___7;
#line 90
  __cil_tmp12 = (void *)0;
#line 90
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 90
  __cil_tmp14 = (unsigned long )cmd;
#line 90
  __cil_tmp15 = __cil_tmp14 == __cil_tmp13;
#line 90
  __cil_tmp16 = ! __cil_tmp15;
#line 90
  __cil_tmp17 = ! __cil_tmp16;
#line 90
  __cil_tmp18 = (long )__cil_tmp17;
#line 90
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 0L);
  }
#line 90
  if (tmp___8) {
    {
#line 91
    drm_err("vmw_gmr2_unbind", "GMR2 unbind failed.\n");
    }
#line 92
    return;
  } else {

  }
#line 94
  __cil_tmp19 = & define_cmd;
#line 94
  *((uint32 *)__cil_tmp19) = (uint32 )gmr_id;
#line 95
  __cil_tmp20 = (unsigned long )(& define_cmd) + 4;
#line 95
  *((uint32 *)__cil_tmp20) = (uint32 )0;
#line 97
  tmp___9 = cmd;
#line 97
  cmd = cmd + 1;
#line 97
  *tmp___9 = (uint32_t )41;
#line 98
  __len = 8UL;
#line 98
  if (__len >= 64UL) {
    {
#line 98
    __cil_tmp21 = (void *)cmd;
#line 98
    __cil_tmp22 = (void    *)(& define_cmd);
#line 98
    __ret = __memcpy(__cil_tmp21, __cil_tmp22, __len);
    }
  } else {
    {
#line 98
    __cil_tmp23 = (void *)cmd;
#line 98
    __cil_tmp24 = (void    *)(& define_cmd);
#line 98
    __ret = __builtin_memcpy(__cil_tmp23, __cil_tmp24, __len);
    }
  }
  {
#line 100
  vmw_fifo_commit(dev_priv, define_size);
  }
#line 101
  return;
}
}
#line 108 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
static int vmw_gmr_build_descriptors(struct list_head *desc_pages , struct page **pages ,
                                     unsigned long num_pages ) 
{ struct page *page ;
  struct page *next ;
  struct svga_guest_mem_descriptor *page_virtual ;
  struct svga_guest_mem_descriptor *desc_virtual ;
  unsigned int desc_per_page ;
  unsigned long prev_pfn ;
  unsigned long pfn ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  uint32_t tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  struct page *__cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  void *__cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  long __cil_tmp55 ;
  struct page *__cil_tmp56 ;
  struct page *__cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  void *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  long __cil_tmp77 ;
  void *__cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  struct page *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct list_head *__cil_tmp89 ;
  struct page *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct list_head *__cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct list_head *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct list_head *__cil_tmp107 ;
  struct page *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct list_head *__cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;

  {
#line 113
  __cil_tmp22 = (void *)0;
#line 113
  page_virtual = (struct svga_guest_mem_descriptor *)__cil_tmp22;
#line 114
  __cil_tmp23 = (void *)0;
#line 114
  desc_virtual = (struct svga_guest_mem_descriptor *)__cil_tmp23;
#line 120
  __cil_tmp24 = 1UL << 12;
#line 120
  __cil_tmp25 = __cil_tmp24 / 8UL;
#line 120
  __cil_tmp26 = __cil_tmp25 - 1UL;
#line 120
  desc_per_page = (unsigned int )__cil_tmp26;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    __cil_tmp27 = num_pages != 0UL;
#line 123
    __cil_tmp28 = ! __cil_tmp27;
#line 123
    __cil_tmp29 = ! __cil_tmp28;
#line 123
    __cil_tmp30 = (long )__cil_tmp29;
#line 123
    tmp___12 = ldv__builtin_expect(__cil_tmp30, 1L);
    }
#line 123
    if (tmp___12) {

    } else {
#line 123
      goto while_break;
    }
    {
#line 124
    page = alloc_pages(2U, 0U);
#line 125
    __cil_tmp31 = (void *)0;
#line 125
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 125
    __cil_tmp33 = (unsigned long )page;
#line 125
    __cil_tmp34 = __cil_tmp33 == __cil_tmp32;
#line 125
    __cil_tmp35 = ! __cil_tmp34;
#line 125
    __cil_tmp36 = ! __cil_tmp35;
#line 125
    __cil_tmp37 = (long )__cil_tmp36;
#line 125
    tmp___7 = ldv__builtin_expect(__cil_tmp37, 0L);
    }
#line 125
    if (tmp___7) {
#line 126
      ret = -12;
#line 127
      goto out_err;
    } else {

    }
    {
#line 130
    __cil_tmp38 = (unsigned long )page;
#line 130
    __cil_tmp39 = __cil_tmp38 + 32;
#line 130
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
#line 130
    list_add_tail(__cil_tmp40, desc_pages);
#line 137
    __cil_tmp41 = (void *)0;
#line 137
    __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 137
    __cil_tmp43 = (unsigned long )page_virtual;
#line 137
    __cil_tmp44 = __cil_tmp43 != __cil_tmp42;
#line 137
    __cil_tmp45 = ! __cil_tmp44;
#line 137
    __cil_tmp46 = ! __cil_tmp45;
#line 137
    __cil_tmp47 = (long )__cil_tmp46;
#line 137
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 1L);
    }
#line 137
    if (tmp___8) {
#line 138
      __cil_tmp48 = (struct page *)0xffffea0000000000UL;
#line 138
      __cil_tmp49 = page - __cil_tmp48;
#line 138
      __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 138
      *((__le32 *)desc_virtual) = (__le32 )__cil_tmp50;
      {
#line 139
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 139
        __cil_tmp51 = (void *)page_virtual;
#line 139
        __kunmap_atomic(__cil_tmp51);
        }
#line 139
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
    {
#line 142
    tmp___9 = kmap_atomic(page);
#line 142
    page_virtual = (struct svga_guest_mem_descriptor *)tmp___9;
#line 143
    desc_virtual = page_virtual - 1;
#line 144
    prev_pfn = ~ 0UL;
    }
    {
#line 146
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 146
      __cil_tmp52 = num_pages != 0UL;
#line 146
      __cil_tmp53 = ! __cil_tmp52;
#line 146
      __cil_tmp54 = ! __cil_tmp53;
#line 146
      __cil_tmp55 = (long )__cil_tmp54;
#line 146
      tmp___11 = ldv__builtin_expect(__cil_tmp55, 1L);
      }
#line 146
      if (tmp___11) {

      } else {
#line 146
        goto while_break___1;
      }
#line 147
      __cil_tmp56 = (struct page *)0xffffea0000000000UL;
#line 147
      __cil_tmp57 = *pages;
#line 147
      __cil_tmp58 = __cil_tmp57 - __cil_tmp56;
#line 147
      pfn = (unsigned long )__cil_tmp58;
      {
#line 149
      __cil_tmp59 = prev_pfn + 1UL;
#line 149
      if (pfn != __cil_tmp59) {
        {
#line 151
        __cil_tmp60 = desc_per_page - 1U;
#line 151
        __cil_tmp61 = desc_virtual - page_virtual;
#line 151
        __cil_tmp62 = (unsigned int )__cil_tmp61;
#line 151
        if (__cil_tmp62 == __cil_tmp60) {
#line 153
          goto while_break___1;
        } else {

        }
        }
#line 155
        desc_virtual = desc_virtual + 1;
#line 155
        *((__le32 *)desc_virtual) = (__u32 )pfn;
#line 156
        __cil_tmp63 = (unsigned long )desc_virtual;
#line 156
        __cil_tmp64 = __cil_tmp63 + 4;
#line 156
        *((__le32 *)__cil_tmp64) = (__u32 )1;
      } else {
#line 158
        __cil_tmp65 = (unsigned long )desc_virtual;
#line 158
        __cil_tmp66 = __cil_tmp65 + 4;
#line 158
        tmp___10 = *((__le32 *)__cil_tmp66);
#line 160
        __cil_tmp67 = (unsigned long )desc_virtual;
#line 160
        __cil_tmp68 = __cil_tmp67 + 4;
#line 160
        *((__le32 *)__cil_tmp68) = tmp___10 + 1U;
      }
      }
#line 162
      prev_pfn = pfn;
#line 163
      num_pages = num_pages - 1UL;
#line 164
      pages = pages + 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 167
    desc_virtual = desc_virtual + 1;
#line 167
    *((__le32 *)desc_virtual) = (__u32 )0;
#line 168
    __cil_tmp69 = (unsigned long )desc_virtual;
#line 168
    __cil_tmp70 = __cil_tmp69 + 4;
#line 168
    *((__le32 *)__cil_tmp70) = (__u32 )0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  __cil_tmp71 = (void *)0;
#line 171
  __cil_tmp72 = (unsigned long )__cil_tmp71;
#line 171
  __cil_tmp73 = (unsigned long )page_virtual;
#line 171
  __cil_tmp74 = __cil_tmp73 != __cil_tmp72;
#line 171
  __cil_tmp75 = ! __cil_tmp74;
#line 171
  __cil_tmp76 = ! __cil_tmp75;
#line 171
  __cil_tmp77 = (long )__cil_tmp76;
#line 171
  tmp___13 = ldv__builtin_expect(__cil_tmp77, 1L);
  }
#line 171
  if (tmp___13) {
    {
#line 172
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 172
      __cil_tmp78 = (void *)page_virtual;
#line 172
      __kunmap_atomic(__cil_tmp78);
      }
#line 172
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {

  }
#line 174
  return (0);
  out_err: 
#line 176
  __cil_tmp79 = *((struct list_head **)desc_pages);
#line 176
  __mptr = (struct list_head    *)__cil_tmp79;
#line 176
  __cil_tmp80 = (struct page *)0;
#line 176
  __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 176
  __cil_tmp82 = __cil_tmp81 + 32;
#line 176
  __cil_tmp83 = (struct list_head *)__cil_tmp82;
#line 176
  __cil_tmp84 = (unsigned int )__cil_tmp83;
#line 176
  __cil_tmp85 = (char *)__mptr;
#line 176
  __cil_tmp86 = __cil_tmp85 - __cil_tmp84;
#line 176
  page = (struct page *)__cil_tmp86;
#line 176
  __cil_tmp87 = (unsigned long )page;
#line 176
  __cil_tmp88 = __cil_tmp87 + 32;
#line 176
  __cil_tmp89 = *((struct list_head **)__cil_tmp88);
#line 176
  __mptr___0 = (struct list_head    *)__cil_tmp89;
#line 176
  __cil_tmp90 = (struct page *)0;
#line 176
  __cil_tmp91 = (unsigned long )__cil_tmp90;
#line 176
  __cil_tmp92 = __cil_tmp91 + 32;
#line 176
  __cil_tmp93 = (struct list_head *)__cil_tmp92;
#line 176
  __cil_tmp94 = (unsigned int )__cil_tmp93;
#line 176
  __cil_tmp95 = (char *)__mptr___0;
#line 176
  __cil_tmp96 = __cil_tmp95 - __cil_tmp94;
#line 176
  next = (struct page *)__cil_tmp96;
  {
#line 176
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 176
    __cil_tmp97 = (unsigned long )desc_pages;
#line 176
    __cil_tmp98 = (unsigned long )page;
#line 176
    __cil_tmp99 = __cil_tmp98 + 32;
#line 176
    __cil_tmp100 = (struct list_head *)__cil_tmp99;
#line 176
    __cil_tmp101 = (unsigned long )__cil_tmp100;
#line 176
    if (__cil_tmp101 != __cil_tmp97) {

    } else {
#line 176
      goto while_break___3;
    }
    }
    {
#line 177
    __cil_tmp102 = (unsigned long )page;
#line 177
    __cil_tmp103 = __cil_tmp102 + 32;
#line 177
    __cil_tmp104 = (struct list_head *)__cil_tmp103;
#line 177
    list_del_init(__cil_tmp104);
#line 178
    __free_pages(page, 0U);
#line 176
    page = next;
#line 176
    __cil_tmp105 = (unsigned long )next;
#line 176
    __cil_tmp106 = __cil_tmp105 + 32;
#line 176
    __cil_tmp107 = *((struct list_head **)__cil_tmp106);
#line 176
    __mptr___1 = (struct list_head    *)__cil_tmp107;
#line 176
    __cil_tmp108 = (struct page *)0;
#line 176
    __cil_tmp109 = (unsigned long )__cil_tmp108;
#line 176
    __cil_tmp110 = __cil_tmp109 + 32;
#line 176
    __cil_tmp111 = (struct list_head *)__cil_tmp110;
#line 176
    __cil_tmp112 = (unsigned int )__cil_tmp111;
#line 176
    __cil_tmp113 = (char *)__mptr___1;
#line 176
    __cil_tmp114 = __cil_tmp113 - __cil_tmp112;
#line 176
    next = (struct page *)__cil_tmp114;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 180
  return (ret);
}
}
#line 183
__inline static void vmw_gmr_free_descriptors(struct list_head *desc_pages )  __attribute__((__no_instrument_function__)) ;
#line 183 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
__inline static void vmw_gmr_free_descriptors(struct list_head *desc_pages ) 
{ struct page *page ;
  struct page *next ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  struct list_head *__cil_tmp7 ;
  struct page *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  struct page *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct page *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 187
  __cil_tmp7 = *((struct list_head **)desc_pages);
#line 187
  __mptr = (struct list_head    *)__cil_tmp7;
#line 187
  __cil_tmp8 = (struct page *)0;
#line 187
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 187
  __cil_tmp10 = __cil_tmp9 + 32;
#line 187
  __cil_tmp11 = (struct list_head *)__cil_tmp10;
#line 187
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 187
  __cil_tmp13 = (char *)__mptr;
#line 187
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 187
  page = (struct page *)__cil_tmp14;
#line 187
  __cil_tmp15 = (unsigned long )page;
#line 187
  __cil_tmp16 = __cil_tmp15 + 32;
#line 187
  __cil_tmp17 = *((struct list_head **)__cil_tmp16);
#line 187
  __mptr___0 = (struct list_head    *)__cil_tmp17;
#line 187
  __cil_tmp18 = (struct page *)0;
#line 187
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 187
  __cil_tmp20 = __cil_tmp19 + 32;
#line 187
  __cil_tmp21 = (struct list_head *)__cil_tmp20;
#line 187
  __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 187
  __cil_tmp23 = (char *)__mptr___0;
#line 187
  __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 187
  next = (struct page *)__cil_tmp24;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    __cil_tmp25 = (unsigned long )desc_pages;
#line 187
    __cil_tmp26 = (unsigned long )page;
#line 187
    __cil_tmp27 = __cil_tmp26 + 32;
#line 187
    __cil_tmp28 = (struct list_head *)__cil_tmp27;
#line 187
    __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 187
    if (__cil_tmp29 != __cil_tmp25) {

    } else {
#line 187
      goto while_break;
    }
    }
    {
#line 188
    __cil_tmp30 = (unsigned long )page;
#line 188
    __cil_tmp31 = __cil_tmp30 + 32;
#line 188
    __cil_tmp32 = (struct list_head *)__cil_tmp31;
#line 188
    list_del_init(__cil_tmp32);
#line 189
    __free_pages(page, 0U);
#line 187
    page = next;
#line 187
    __cil_tmp33 = (unsigned long )next;
#line 187
    __cil_tmp34 = __cil_tmp33 + 32;
#line 187
    __cil_tmp35 = *((struct list_head **)__cil_tmp34);
#line 187
    __mptr___1 = (struct list_head    *)__cil_tmp35;
#line 187
    __cil_tmp36 = (struct page *)0;
#line 187
    __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 187
    __cil_tmp38 = __cil_tmp37 + 32;
#line 187
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
#line 187
    __cil_tmp40 = (unsigned int )__cil_tmp39;
#line 187
    __cil_tmp41 = (char *)__mptr___1;
#line 187
    __cil_tmp42 = __cil_tmp41 - __cil_tmp40;
#line 187
    next = (struct page *)__cil_tmp42;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 193 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
static void vmw_gmr_fire_descriptors(struct vmw_private *dev_priv , int gmr_id , struct list_head *desc_pages ) 
{ struct page *page ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  struct list_head    *__mptr ;
  struct list_head    *__cil_tmp9 ;
  long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  struct page *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  struct page *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct mutex *__cil_tmp29 ;

  {
  {
#line 198
  __cil_tmp9 = (struct list_head    *)desc_pages;
#line 198
  tmp___7 = list_empty(__cil_tmp9);
  }
#line 198
  if (tmp___7) {
#line 198
    tmp___8 = 1;
  } else {
#line 198
    tmp___8 = 0;
  }
  {
#line 198
  __cil_tmp10 = (long )tmp___8;
#line 198
  tmp___9 = ldv__builtin_expect(__cil_tmp10, 0L);
  }
#line 198
  if (tmp___9) {
#line 199
    return;
  } else {

  }
  {
#line 201
  __cil_tmp11 = *((struct list_head **)desc_pages);
#line 201
  __mptr = (struct list_head    *)__cil_tmp11;
#line 201
  __cil_tmp12 = (struct page *)0;
#line 201
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 201
  __cil_tmp14 = __cil_tmp13 + 32;
#line 201
  __cil_tmp15 = (struct list_head *)__cil_tmp14;
#line 201
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 201
  __cil_tmp17 = (char *)__mptr;
#line 201
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 201
  page = (struct page *)__cil_tmp18;
#line 203
  __cil_tmp19 = (unsigned long )dev_priv;
#line 203
  __cil_tmp20 = __cil_tmp19 + 2184;
#line 203
  __cil_tmp21 = (struct mutex *)__cil_tmp20;
#line 203
  mutex_lock(__cil_tmp21);
#line 205
  __cil_tmp22 = (uint32_t )gmr_id;
#line 205
  vmw_write(dev_priv, 41U, __cil_tmp22);
#line 206
  __asm__  volatile   ("sfence": : : "memory");
#line 207
  __cil_tmp23 = (struct page *)0xffffea0000000000UL;
#line 207
  __cil_tmp24 = page - __cil_tmp23;
#line 207
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 207
  __cil_tmp26 = (uint32_t )__cil_tmp25;
#line 207
  vmw_write(dev_priv, 42U, __cil_tmp26);
#line 208
  __asm__  volatile   ("mfence": : : "memory");
#line 210
  __cil_tmp27 = (unsigned long )dev_priv;
#line 210
  __cil_tmp28 = __cil_tmp27 + 2184;
#line 210
  __cil_tmp29 = (struct mutex *)__cil_tmp28;
#line 210
  mutex_unlock(__cil_tmp29);
  }
#line 212
  return;
}
}
#line 219 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
static unsigned long vmw_gmr_count_descriptors(struct page **pages , unsigned long num_pages ) 
{ unsigned long prev_pfn ;
  unsigned long pfn ;
  unsigned long descriptors ;
  struct page **tmp___7 ;
  unsigned long tmp___8 ;
  struct page *__cil_tmp8 ;
  struct page *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
#line 222
  prev_pfn = ~ 0UL;
#line 224
  descriptors = 0UL;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    tmp___8 = num_pages;
#line 226
    num_pages = num_pages - 1UL;
#line 226
    if (tmp___8) {

    } else {
#line 226
      goto while_break;
    }
#line 227
    tmp___7 = pages;
#line 227
    pages = pages + 1;
#line 227
    __cil_tmp8 = (struct page *)0xffffea0000000000UL;
#line 227
    __cil_tmp9 = *tmp___7;
#line 227
    __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 227
    pfn = (unsigned long )__cil_tmp10;
    {
#line 228
    __cil_tmp11 = prev_pfn + 1UL;
#line 228
    if (__cil_tmp11 != pfn) {
#line 229
      descriptors = descriptors + 1UL;
    } else {

    }
    }
#line 230
    prev_pfn = pfn;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (descriptors);
}
}
#line 236 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) 
{ struct list_head desc_pages ;
  int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;

  {
  {
#line 244
  __cil_tmp12 = (unsigned long )dev_priv;
#line 244
  __cil_tmp13 = __cil_tmp12 + 2156;
#line 244
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
#line 244
  __cil_tmp15 = __cil_tmp14 & 4194304U;
#line 244
  __cil_tmp16 = ! __cil_tmp15;
#line 244
  __cil_tmp17 = ! __cil_tmp16;
#line 244
  __cil_tmp18 = (long )__cil_tmp17;
#line 244
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 1L);
  }
#line 244
  if (tmp___8) {
    {
#line 245
    tmp___7 = vmw_gmr2_bind(dev_priv, pages, num_pages, gmr_id);
    }
#line 245
    return (tmp___7);
  } else {

  }
  {
#line 247
  __cil_tmp19 = (unsigned long )dev_priv;
#line 247
  __cil_tmp20 = __cil_tmp19 + 2156;
#line 247
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
#line 247
  __cil_tmp22 = __cil_tmp21 & 1048576U;
#line 247
  __cil_tmp23 = ! __cil_tmp22;
#line 247
  __cil_tmp24 = ! __cil_tmp23;
#line 247
  __cil_tmp25 = ! __cil_tmp24;
#line 247
  __cil_tmp26 = (long )__cil_tmp25;
#line 247
  tmp___9 = ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 247
  if (tmp___9) {
#line 248
    return (-22);
  } else {

  }
  {
#line 250
  tmp___10 = vmw_gmr_count_descriptors(pages, num_pages);
  }
  {
#line 250
  __cil_tmp27 = (unsigned long )dev_priv;
#line 250
  __cil_tmp28 = __cil_tmp27 + 2160;
#line 250
  __cil_tmp29 = *((uint32_t *)__cil_tmp28);
#line 250
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 250
  if (tmp___10 > __cil_tmp30) {
#line 252
    return (-22);
  } else {

  }
  }
  {
#line 254
  INIT_LIST_HEAD(& desc_pages);
#line 256
  ret = vmw_gmr_build_descriptors(& desc_pages, pages, num_pages);
#line 257
  __cil_tmp31 = ret != 0;
#line 257
  __cil_tmp32 = ! __cil_tmp31;
#line 257
  __cil_tmp33 = ! __cil_tmp32;
#line 257
  __cil_tmp34 = (long )__cil_tmp33;
#line 257
  tmp___11 = ldv__builtin_expect(__cil_tmp34, 0L);
  }
#line 257
  if (tmp___11) {
#line 258
    return (ret);
  } else {

  }
  {
#line 260
  vmw_gmr_fire_descriptors(dev_priv, gmr_id, & desc_pages);
#line 261
  vmw_gmr_free_descriptors(& desc_pages);
  }
#line 263
  return (0);
}
}
#line 267 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c"
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ long tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct mutex *__cil_tmp18 ;

  {
  {
#line 269
  __cil_tmp4 = (unsigned long )dev_priv;
#line 269
  __cil_tmp5 = __cil_tmp4 + 2156;
#line 269
  __cil_tmp6 = *((uint32_t *)__cil_tmp5);
#line 269
  __cil_tmp7 = __cil_tmp6 & 4194304U;
#line 269
  __cil_tmp8 = ! __cil_tmp7;
#line 269
  __cil_tmp9 = ! __cil_tmp8;
#line 269
  __cil_tmp10 = (long )__cil_tmp9;
#line 269
  tmp___7 = ldv__builtin_expect(__cil_tmp10, 1L);
  }
#line 269
  if (tmp___7) {
    {
#line 270
    vmw_gmr2_unbind(dev_priv, gmr_id);
    }
#line 271
    return;
  } else {

  }
  {
#line 274
  __cil_tmp11 = (unsigned long )dev_priv;
#line 274
  __cil_tmp12 = __cil_tmp11 + 2184;
#line 274
  __cil_tmp13 = (struct mutex *)__cil_tmp12;
#line 274
  mutex_lock(__cil_tmp13);
#line 275
  __cil_tmp14 = (uint32_t )gmr_id;
#line 275
  vmw_write(dev_priv, 41U, __cil_tmp14);
#line 276
  __asm__  volatile   ("sfence": : : "memory");
#line 277
  __cil_tmp15 = (uint32_t )0;
#line 277
  vmw_write(dev_priv, 42U, __cil_tmp15);
#line 278
  __asm__  volatile   ("mfence": : : "memory");
#line 279
  __cil_tmp16 = (unsigned long )dev_priv;
#line 279
  __cil_tmp17 = __cil_tmp16 + 2184;
#line 279
  __cil_tmp18 = (struct mutex *)__cil_tmp17;
#line 279
  mutex_unlock(__cil_tmp18);
  }
#line 280
  return;
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ struct list_head *__cil_tmp3 ;

  {
  {
#line 62
  __cil_tmp3 = *((struct list_head **)head);
#line 62
  __list_add(new, head, __cil_tmp3);
  }
#line 63
  return;
}
}
#line 153
__inline static void list_move(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
  }
#line 157
  return;
}
}
#line 22 "include/linux/err.h"
__inline static void * __attribute__((__warn_unused_result__)) ERR_PTR(long error )  __attribute__((__no_instrument_function__)) ;
#line 22 "include/linux/err.h"
__inline static void * __attribute__((__warn_unused_result__)) ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 310 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ unsigned int value ;

  {
#line 310
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 161 "include/linux/slab.h"
extern void kfree(void    * ) ;
#line 221 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 268
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 268 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
#line 283
  tmp___2 = __kmalloc(size, flags);
  }
#line 283
  return (tmp___2);
}
}
#line 243 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 243 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned long __cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
#line 245
  if (size != 0UL) {
    {
#line 245
    __cil_tmp5 = 0xffffffffffffffffUL / size;
#line 245
    if (n > __cil_tmp5) {
#line 246
      return ((void *)0);
    } else {

    }
    }
  } else {

  }
  {
#line 247
  __cil_tmp6 = n * size;
#line 247
  tmp = __kmalloc(__cil_tmp6, flags);
  }
#line 247
  return (tmp);
}
}
#line 256
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 256 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 258
  __cil_tmp5 = flags | 32768U;
#line 258
  tmp = kmalloc_array(n, size, __cil_tmp5);
  }
#line 258
  return (tmp);
}
}
#line 349
__inline static void *kzalloc(size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 349 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = flags | 32768U;
#line 351
  tmp = kmalloc(size, __cil_tmp4);
  }
#line 351
  return (tmp);
}
}
#line 127 "include/drm/drmP.h"
extern void ( /* format attribute */  drm_ut_debug_printk)(unsigned int request_level ,
                                                           char    *prefix ,
                                                           char    *function_name ,
                                                           char    *format  , ...) ;
#line 821 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc *crtc ) ;
#line 828
extern void drm_connector_cleanup(struct drm_connector *connector ) ;
#line 845
extern void drm_encoder_cleanup(struct drm_encoder *encoder ) ;
#line 858
extern void drm_mode_probed_add(struct drm_connector *connector , struct drm_display_mode *mode ) ;
#line 861
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev , struct drm_display_mode    *mode ) ;
#line 864
extern void drm_mode_config_init(struct drm_device *dev ) ;
#line 866
extern void drm_mode_config_cleanup(struct drm_device *dev ) ;
#line 879
extern void drm_mode_destroy(struct drm_device *dev , struct drm_display_mode *mode ) ;
#line 889
extern int drm_mode_vrefresh(struct drm_display_mode    *mode ) ;
#line 892
extern void drm_mode_connector_list_update(struct drm_connector *connector ) ;
#line 904
extern int drm_framebuffer_init(struct drm_device *dev , struct drm_framebuffer *fb ,
                                struct drm_framebuffer_funcs    *funcs ) ;
#line 907
extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb ) ;
#line 941
extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev , uint32_t id ,
                                                    uint32_t type ) ;
#line 1027
extern void drm_fb_get_bpp_depth(uint32_t format , unsigned int *depth , int *bpp ) ;
#line 1504 "include/drm/drmP.h"
extern struct drm_master *drm_master_get(struct drm_master *master ) ;
#line 1505
extern void drm_master_put(struct drm_master **master ) ;
#line 640 "include/drm/ttm/ttm_bo_api.h"
__inline static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem )  __attribute__((__no_instrument_function__)) ;
#line 640 "include/drm/ttm/ttm_bo_api.h"
__inline static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  enum __anonenum_bo_kmap_type_427 __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 643
  __cil_tmp3 = (unsigned long )map;
#line 643
  __cil_tmp4 = __cil_tmp3 + 16;
#line 643
  __cil_tmp5 = *((enum __anonenum_bo_kmap_type_427 *)__cil_tmp4);
#line 643
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 643
  __cil_tmp7 = __cil_tmp6 & 128U;
#line 643
  __cil_tmp8 = ! __cil_tmp7;
#line 643
  __cil_tmp9 = ! __cil_tmp8;
#line 643
  *is_iomem = (bool )__cil_tmp9;
#line 644
  return (*((void **)map));
}
}
#line 664
extern int ttm_bo_kmap(struct ttm_buffer_object *bo , unsigned long start_page , unsigned long num_pages ,
                       struct ttm_bo_kmap_obj *map ) ;
#line 675
extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj *map ) ;
#line 848 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_reserve(struct ttm_buffer_object *bo , bool interruptible , bool no_wait ,
                          bool use_sequence , uint32_t sequence ) ;
#line 889
extern void ttm_bo_unreserve(struct ttm_buffer_object *bo ) ;
#line 169 "include/drm/ttm/ttm_object.h"
extern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file *tfile ,
                                                      uint32_t key ) ;
#line 181
extern void ttm_base_object_unref(struct ttm_base_object **p_base ) ;
#line 114 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) ;
#line 358 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset )  __attribute__((__no_instrument_function__)) ;
#line 358 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset ) 
{ uint32_t val ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 363
  __cil_tmp4 = (unsigned long )dev_priv;
#line 363
  __cil_tmp5 = __cil_tmp4 + 2104;
#line 363
  __cil_tmp6 = *((unsigned int *)__cil_tmp5);
#line 363
  __cil_tmp7 = (int )__cil_tmp6;
#line 363
  outl(offset, __cil_tmp7);
#line 364
  __cil_tmp8 = (unsigned long )dev_priv;
#line 364
  __cil_tmp9 = __cil_tmp8 + 2104;
#line 364
  __cil_tmp10 = *((unsigned int *)__cil_tmp9);
#line 364
  __cil_tmp11 = __cil_tmp10 + 1U;
#line 364
  __cil_tmp12 = (int )__cil_tmp11;
#line 364
  val = inl(__cil_tmp12);
  }
#line 365
  return (val);
}
}
#line 387
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) ;
#line 396
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) ;
#line 458
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) ;
#line 461
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) ;
#line 499
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) ;
#line 611
int vmw_kms_init(struct vmw_private *dev_priv ) ;
#line 612
int vmw_kms_close(struct vmw_private *dev_priv ) ;
#line 613
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) ;
#line 614
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) ;
#line 615
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 622
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) ;
#line 626
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) ;
#line 629
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) ;
#line 630
int vmw_enable_vblank(struct drm_device *dev , int crtc ) ;
#line 631
void vmw_disable_vblank(struct drm_device *dev , int crtc ) ;
#line 632
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) ;
#line 639
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) ;
#line 645
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 657
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) ;
#line 658
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) ;
#line 683
__inline static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
#line 683 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf ) 
{ struct vmw_resource *__cil_tmp2 ;

  {
  {
#line 685
  __cil_tmp2 = (struct vmw_resource *)srf;
#line 685
  vmw_resource_reference(__cil_tmp2);
  }
#line 686
  return (srf);
}
}
#line 698
__inline static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf )  __attribute__((__no_instrument_function__)) ;
#line 698 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf ) 
{ struct ttm_buffer_object *tmp___7 ;
  struct ttm_buffer_object *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 700
  __cil_tmp3 = (struct ttm_buffer_object *)buf;
#line 700
  tmp___7 = ttm_bo_reference(__cil_tmp3);
  }
#line 700
  if (tmp___7) {
#line 701
    return (buf);
  } else {

  }
  {
#line 702
  __cil_tmp4 = (void *)0;
#line 702
  return ((struct vmw_dma_buffer *)__cil_tmp4);
  }
}
}
#line 63 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 66
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 70
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) ;
#line 123
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) ;
#line 124
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
#line 127
void vmw_du_crtc_save(struct drm_crtc *crtc ) ;
#line 128
void vmw_du_crtc_restore(struct drm_crtc *crtc ) ;
#line 129
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) ;
#line 132
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) ;
#line 134
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 135
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) ;
#line 136
void vmw_du_connector_save(struct drm_connector *connector ) ;
#line 137
void vmw_du_connector_restore(struct drm_connector *connector ) ;
#line 138
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) ;
#line 140
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) ;
#line 142
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) ;
#line 150
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 151
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 156
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) ;
#line 157
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) ;
#line 160
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 162
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 44 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_clip_cliprects(struct drm_clip_rect *rects , int num_rects , int clip_x151 ,
                        int clip_x250 , int clip_y149 , int clip_y248 , SVGASignedRect *out_rects ,
                        int *out_num ) 
{ int i ;
  int k ;
  int x1 ;
  int __max1 ;
  int __max2 ;
  int tmp___7 ;
  int y1 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___8 ;
  int x2 ;
  int __min1 ;
  int __min2 ;
  int tmp___9 ;
  int y2 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___10 ;
  struct drm_clip_rect *__cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  struct drm_clip_rect *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned short __cil_tmp29 ;
  struct drm_clip_rect *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned short __cil_tmp33 ;
  struct drm_clip_rect *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned short __cil_tmp37 ;
  SVGASignedRect *__cil_tmp38 ;
  SVGASignedRect *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  SVGASignedRect *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  SVGASignedRect *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;

  {
#line 52
  i = 0;
#line 52
  k = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (i < num_rects) {

    } else {
#line 52
      goto while_break;
    }
#line 53
    __max1 = clip_x151;
#line 53
    __cil_tmp24 = rects + i;
#line 53
    __cil_tmp25 = *((unsigned short *)__cil_tmp24);
#line 53
    __max2 = (int )__cil_tmp25;
#line 53
    if (__max1 > __max2) {
#line 53
      tmp___7 = __max1;
    } else {
#line 53
      tmp___7 = __max2;
    }
#line 53
    x1 = tmp___7;
#line 54
    __max1___0 = clip_y149;
#line 54
    __cil_tmp26 = rects + i;
#line 54
    __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 54
    __cil_tmp28 = __cil_tmp27 + 2;
#line 54
    __cil_tmp29 = *((unsigned short *)__cil_tmp28);
#line 54
    __max2___0 = (int )__cil_tmp29;
#line 54
    if (__max1___0 > __max2___0) {
#line 54
      tmp___8 = __max1___0;
    } else {
#line 54
      tmp___8 = __max2___0;
    }
#line 54
    y1 = tmp___8;
#line 55
    __min1 = clip_x250;
#line 55
    __cil_tmp30 = rects + i;
#line 55
    __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 55
    __cil_tmp32 = __cil_tmp31 + 4;
#line 55
    __cil_tmp33 = *((unsigned short *)__cil_tmp32);
#line 55
    __min2 = (int )__cil_tmp33;
#line 55
    if (__min1 < __min2) {
#line 55
      tmp___9 = __min1;
    } else {
#line 55
      tmp___9 = __min2;
    }
#line 55
    x2 = tmp___9;
#line 56
    __min1___0 = clip_y248;
#line 56
    __cil_tmp34 = rects + i;
#line 56
    __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 56
    __cil_tmp36 = __cil_tmp35 + 6;
#line 56
    __cil_tmp37 = *((unsigned short *)__cil_tmp36);
#line 56
    __min2___0 = (int )__cil_tmp37;
#line 56
    if (__min1___0 < __min2___0) {
#line 56
      tmp___10 = __min1___0;
    } else {
#line 56
      tmp___10 = __min2___0;
    }
#line 56
    y2 = tmp___10;
#line 58
    if (x1 >= x2) {
#line 59
      goto __Cont;
    } else {

    }
#line 60
    if (y1 >= y2) {
#line 61
      goto __Cont;
    } else {

    }
#line 63
    __cil_tmp38 = out_rects + k;
#line 63
    *((int32 *)__cil_tmp38) = x1;
#line 64
    __cil_tmp39 = out_rects + k;
#line 64
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 64
    __cil_tmp41 = __cil_tmp40 + 4;
#line 64
    *((int32 *)__cil_tmp41) = y1;
#line 65
    __cil_tmp42 = out_rects + k;
#line 65
    __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 65
    __cil_tmp44 = __cil_tmp43 + 8;
#line 65
    *((int32 *)__cil_tmp44) = x2;
#line 66
    __cil_tmp45 = out_rects + k;
#line 66
    __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 66
    __cil_tmp47 = __cil_tmp46 + 12;
#line 66
    *((int32 *)__cil_tmp47) = y2;
#line 67
    k = k + 1;
    __Cont: /* CIL Label */ 
#line 52
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  *out_num = k;
#line 71
  return;
}
}
#line 73 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct vmw_surface **__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_dma_buffer **__cil_tmp11 ;
  struct drm_crtc *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_encoder *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_connector *__cil_tmp18 ;

  {
  {
#line 75
  __cil_tmp2 = (unsigned long )du;
#line 75
  __cil_tmp3 = __cil_tmp2 + 1992;
#line 75
  if (*((struct vmw_surface **)__cil_tmp3)) {
    {
#line 76
    __cil_tmp4 = (unsigned long )du;
#line 76
    __cil_tmp5 = __cil_tmp4 + 1992;
#line 76
    __cil_tmp6 = (struct vmw_surface **)__cil_tmp5;
#line 76
    vmw_surface_unreference(__cil_tmp6);
    }
  } else {

  }
  }
  {
#line 77
  __cil_tmp7 = (unsigned long )du;
#line 77
  __cil_tmp8 = __cil_tmp7 + 2000;
#line 77
  if (*((struct vmw_dma_buffer **)__cil_tmp8)) {
    {
#line 78
    __cil_tmp9 = (unsigned long )du;
#line 78
    __cil_tmp10 = __cil_tmp9 + 2000;
#line 78
    __cil_tmp11 = (struct vmw_dma_buffer **)__cil_tmp10;
#line 78
    vmw_dmabuf_unreference(__cil_tmp11);
    }
  } else {

  }
  }
  {
#line 79
  __cil_tmp12 = (struct drm_crtc *)du;
#line 79
  drm_crtc_cleanup(__cil_tmp12);
#line 80
  __cil_tmp13 = (unsigned long )du;
#line 80
  __cil_tmp14 = __cil_tmp13 + 544;
#line 80
  __cil_tmp15 = (struct drm_encoder *)__cil_tmp14;
#line 80
  drm_encoder_cleanup(__cil_tmp15);
#line 81
  __cil_tmp16 = (unsigned long )du;
#line 81
  __cil_tmp17 = __cil_tmp16 + 616;
#line 81
  __cil_tmp18 = (struct drm_connector *)__cil_tmp17;
#line 81
  drm_connector_cleanup(__cil_tmp18);
  }
#line 82
  return;
}
}
#line 88 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct __anonstruct_cmd_429___0 *cmd ;
  u32 image_size ;
  u32 cmd_size ;
  void *tmp___7 ;
  long tmp___8 ;
  size_t __len ;
  void *__ret ;
  u32 __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  void *__cil_tmp24 ;
  struct __anonstruct_cmd_429___0 *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void    *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
#line 96
  __cil_tmp14 = width * height;
#line 96
  image_size = __cil_tmp14 * 4U;
#line 97
  __cil_tmp15 = (unsigned long )image_size;
#line 97
  __cil_tmp16 = 24UL + __cil_tmp15;
#line 97
  cmd_size = (u32 )__cil_tmp16;
#line 99
  if (! image) {
#line 100
    return (-22);
  } else {

  }
  {
#line 102
  tmp___7 = vmw_fifo_reserve(dev_priv, cmd_size);
#line 102
  cmd = (struct __anonstruct_cmd_429___0 *)tmp___7;
#line 103
  __cil_tmp17 = (void *)0;
#line 103
  __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 103
  __cil_tmp19 = (unsigned long )cmd;
#line 103
  __cil_tmp20 = __cil_tmp19 == __cil_tmp18;
#line 103
  __cil_tmp21 = ! __cil_tmp20;
#line 103
  __cil_tmp22 = ! __cil_tmp21;
#line 103
  __cil_tmp23 = (long )__cil_tmp22;
#line 103
  tmp___8 = ldv__builtin_expect(__cil_tmp23, 0L);
  }
#line 103
  if (tmp___8) {
    {
#line 104
    drm_err("vmw_cursor_update_image", "Fifo reserve failed.\n");
    }
#line 105
    return (-12);
  } else {

  }
  {
#line 108
  __cil_tmp24 = (void *)cmd;
#line 108
  memset(__cil_tmp24, 0, 24UL);
#line 110
  __len = (size_t )image_size;
#line 110
  __cil_tmp25 = cmd + 1;
#line 110
  __cil_tmp26 = (void *)__cil_tmp25;
#line 110
  __cil_tmp27 = (void    *)image;
#line 110
  __ret = __builtin_memcpy(__cil_tmp26, __cil_tmp27, __len);
#line 112
  *((u32 *)cmd) = (__u32 )22;
#line 113
  __cil_tmp28 = (unsigned long )cmd;
#line 113
  __cil_tmp29 = __cil_tmp28 + 4;
#line 113
  *((uint32 *)__cil_tmp29) = (__u32 )0;
#line 114
  __cil_tmp30 = 4 + 12;
#line 114
  __cil_tmp31 = (unsigned long )cmd;
#line 114
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
#line 114
  *((uint32 *)__cil_tmp32) = width;
#line 115
  __cil_tmp33 = 4 + 16;
#line 115
  __cil_tmp34 = (unsigned long )cmd;
#line 115
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 115
  *((uint32 *)__cil_tmp35) = height;
#line 116
  __cil_tmp36 = 4 + 4;
#line 116
  __cil_tmp37 = (unsigned long )cmd;
#line 116
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 116
  *((uint32 *)__cil_tmp38) = hotspotX;
#line 117
  __cil_tmp39 = 4 + 8;
#line 117
  __cil_tmp40 = (unsigned long )cmd;
#line 117
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 117
  *((uint32 *)__cil_tmp41) = hotspotY;
#line 119
  vmw_fifo_commit(dev_priv, cmd_size);
  }
#line 121
  return (0);
}
}
#line 124 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  void *virtual ;
  bool dummy ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp15 ;
  u32 __cil_tmp16 ;
  u32 __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_buffer_object *__cil_tmp21 ;
  bool __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct ttm_buffer_object *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  u32 *__cil_tmp35 ;
  struct ttm_buffer_object *__cil_tmp36 ;

  {
  {
#line 136
  kmap_offset = 0UL;
#line 137
  __cil_tmp15 = 1UL << 12;
#line 137
  __cil_tmp16 = width * height;
#line 137
  __cil_tmp17 = __cil_tmp16 * 4U;
#line 137
  __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 137
  __cil_tmp19 = __cil_tmp18 + __cil_tmp15;
#line 137
  __cil_tmp20 = __cil_tmp19 - 1UL;
#line 137
  kmap_num = __cil_tmp20 >> 12;
#line 139
  __cil_tmp21 = (struct ttm_buffer_object *)dmabuf;
#line 139
  __cil_tmp22 = (bool )1;
#line 139
  __cil_tmp23 = (bool )0;
#line 139
  __cil_tmp24 = (bool )0;
#line 139
  __cil_tmp25 = (uint32_t )0;
#line 139
  ret = ttm_bo_reserve(__cil_tmp21, __cil_tmp22, __cil_tmp23, __cil_tmp24, __cil_tmp25);
#line 140
  __cil_tmp26 = ret != 0;
#line 140
  __cil_tmp27 = ! __cil_tmp26;
#line 140
  __cil_tmp28 = ! __cil_tmp27;
#line 140
  __cil_tmp29 = (long )__cil_tmp28;
#line 140
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 140
  if (tmp___7) {
    {
#line 141
    drm_err("vmw_cursor_update_dmabuf", "reserve failed\n");
    }
#line 142
    return (-22);
  } else {

  }
  {
#line 145
  __cil_tmp30 = (struct ttm_buffer_object *)dmabuf;
#line 145
  ret = ttm_bo_kmap(__cil_tmp30, kmap_offset, kmap_num, & map);
#line 146
  __cil_tmp31 = ret != 0;
#line 146
  __cil_tmp32 = ! __cil_tmp31;
#line 146
  __cil_tmp33 = ! __cil_tmp32;
#line 146
  __cil_tmp34 = (long )__cil_tmp33;
#line 146
  tmp___8 = ldv__builtin_expect(__cil_tmp34, 0L);
  }
#line 146
  if (tmp___8) {
#line 147
    goto err_unreserve;
  } else {

  }
  {
#line 149
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 150
  __cil_tmp35 = (u32 *)virtual;
#line 150
  ret = vmw_cursor_update_image(dev_priv, __cil_tmp35, width, height, hotspotX, hotspotY);
#line 153
  ttm_bo_kunmap(& map);
  }
  err_unreserve: 
  {
#line 155
  __cil_tmp36 = (struct ttm_buffer_object *)dmabuf;
#line 155
  ttm_bo_unreserve(__cil_tmp36);
  }
#line 157
  return (ret);
}
}
#line 161 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) 
{ __le32 *fifo_mem ;
  uint32_t count ;
  int tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  u32 __cil_tmp10 ;
  __le32 *__cil_tmp11 ;
  void *__cil_tmp12 ;
  u32 __cil_tmp13 ;
  __le32 *__cil_tmp14 ;
  void *__cil_tmp15 ;
  u32 __cil_tmp16 ;
  __le32 *__cil_tmp17 ;
  void *__cil_tmp18 ;
  __le32 *__cil_tmp19 ;
  void *__cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
#line 164
  __cil_tmp8 = (unsigned long )dev_priv;
#line 164
  __cil_tmp9 = __cil_tmp8 + 2144;
#line 164
  fifo_mem = *((__le32 **)__cil_tmp9);
#line 167
  if (show) {
#line 167
    tmp___7 = 1;
  } else {
#line 167
    tmp___7 = 0;
  }
  {
#line 167
  __cil_tmp10 = (u32 )tmp___7;
#line 167
  __cil_tmp11 = fifo_mem + 9;
#line 167
  __cil_tmp12 = (void *)__cil_tmp11;
#line 167
  iowrite32(__cil_tmp10, __cil_tmp12);
#line 168
  __cil_tmp13 = (u32 )x;
#line 168
  __cil_tmp14 = fifo_mem + 10;
#line 168
  __cil_tmp15 = (void *)__cil_tmp14;
#line 168
  iowrite32(__cil_tmp13, __cil_tmp15);
#line 169
  __cil_tmp16 = (u32 )y;
#line 169
  __cil_tmp17 = fifo_mem + 11;
#line 169
  __cil_tmp18 = (void *)__cil_tmp17;
#line 169
  iowrite32(__cil_tmp16, __cil_tmp18);
#line 170
  __cil_tmp19 = fifo_mem + 12;
#line 170
  __cil_tmp20 = (void *)__cil_tmp19;
#line 170
  count = ioread32(__cil_tmp20);
#line 171
  count = count + 1U;
#line 171
  __cil_tmp21 = fifo_mem + 12;
#line 171
  __cil_tmp22 = (void *)__cil_tmp21;
#line 171
  iowrite32(count, __cil_tmp22);
  }
#line 172
  return;
}
}
#line 174 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_display_unit *du ;
  struct drm_crtc    *__mptr ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *dmabuf ;
  int ret ;
  struct drm_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_display_unit *__cil_tmp18 ;
  struct drm_crtc *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  struct vmw_surface **__cil_tmp23 ;
  void *__cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  void *__cil_tmp26 ;
  struct vmw_surface **__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_surface **__cil_tmp29 ;
  struct vmw_surface *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  uint32_t *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_surface *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface **__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct vmw_dma_buffer **__cil_tmp49 ;
  struct vmw_surface **__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct vmw_surface *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct vmw_surface *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct vmw_surface **__cil_tmp68 ;
  struct vmw_surface *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t *__cil_tmp72 ;
  u32 __cil_tmp73 ;
  u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  int __cil_tmp77 ;
  u32 __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  int __cil_tmp81 ;
  u32 __cil_tmp82 ;
  struct vmw_dma_buffer **__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct vmw_dma_buffer **__cil_tmp86 ;
  struct vmw_dma_buffer **__cil_tmp87 ;
  struct vmw_dma_buffer *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  int __cil_tmp91 ;
  u32 __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  u32 __cil_tmp96 ;
  bool __cil_tmp97 ;
  bool __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;

  {
  {
#line 177
  __cil_tmp15 = *((struct drm_device **)crtc);
#line 177
  tmp___7 = vmw_priv(__cil_tmp15);
#line 177
  dev_priv = tmp___7;
#line 178
  tmp___8 = vmw_fpriv(file_priv);
#line 178
  __cil_tmp16 = (unsigned long )tmp___8;
#line 178
  __cil_tmp17 = __cil_tmp16 + 8;
#line 178
  tfile = *((struct ttm_object_file **)__cil_tmp17);
#line 179
  __mptr = (struct drm_crtc    *)crtc;
#line 179
  __cil_tmp18 = (struct vmw_display_unit *)0;
#line 179
  __cil_tmp19 = (struct drm_crtc *)__cil_tmp18;
#line 179
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 179
  __cil_tmp21 = (char *)__mptr;
#line 179
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
#line 179
  du = (struct vmw_display_unit *)__cil_tmp22;
#line 180
  __cil_tmp23 = & surface;
#line 180
  __cil_tmp24 = (void *)0;
#line 180
  *__cil_tmp23 = (struct vmw_surface *)__cil_tmp24;
#line 181
  __cil_tmp25 = & dmabuf;
#line 181
  __cil_tmp26 = (void *)0;
#line 181
  *__cil_tmp25 = (struct vmw_dma_buffer *)__cil_tmp26;
  }
#line 185
  if (handle) {
#line 185
    if (width != 64U) {
#line 186
      return (-22);
    } else
#line 185
    if (height != 64U) {
#line 186
      return (-22);
    } else {

    }
  } else {

  }
#line 188
  if (handle) {
    {
#line 189
    ret = vmw_user_lookup_handle(dev_priv, tfile, handle, & surface, & dmabuf);
    }
#line 191
    if (ret) {
      {
#line 192
      drm_err("vmw_du_crtc_cursor_set", "failed to find surface or dmabuf: %i\n",
              ret);
      }
#line 193
      return (-22);
    } else {

    }
  } else {

  }
  {
#line 198
  __cil_tmp27 = & surface;
#line 198
  if (*__cil_tmp27) {
    {
#line 198
    __cil_tmp28 = 160 + 16;
#line 198
    __cil_tmp29 = & surface;
#line 198
    __cil_tmp30 = *__cil_tmp29;
#line 198
    __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 198
    __cil_tmp32 = __cil_tmp31 + __cil_tmp28;
#line 198
    __cil_tmp33 = *((uint32_t **)__cil_tmp32);
#line 198
    if (! __cil_tmp33) {
      {
#line 199
      drm_err("vmw_du_crtc_cursor_set", "surface not suitable for cursor\n");
#line 200
      vmw_surface_unreference(& surface);
      }
#line 201
      return (-22);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 205
  __cil_tmp34 = (unsigned long )du;
#line 205
  __cil_tmp35 = __cil_tmp34 + 1992;
#line 205
  if (*((struct vmw_surface **)__cil_tmp35)) {
    {
#line 206
    __cil_tmp36 = (unsigned long )du;
#line 206
    __cil_tmp37 = __cil_tmp36 + 1992;
#line 206
    __cil_tmp38 = *((struct vmw_surface **)__cil_tmp37);
#line 206
    __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 206
    __cil_tmp40 = __cil_tmp39 + 160;
#line 206
    __cil_tmp41 = (void *)0;
#line 206
    *((struct drm_crtc **)__cil_tmp40) = (struct drm_crtc *)__cil_tmp41;
#line 207
    __cil_tmp42 = (unsigned long )du;
#line 207
    __cil_tmp43 = __cil_tmp42 + 1992;
#line 207
    __cil_tmp44 = (struct vmw_surface **)__cil_tmp43;
#line 207
    vmw_surface_unreference(__cil_tmp44);
    }
  } else {

  }
  }
  {
#line 209
  __cil_tmp45 = (unsigned long )du;
#line 209
  __cil_tmp46 = __cil_tmp45 + 2000;
#line 209
  if (*((struct vmw_dma_buffer **)__cil_tmp46)) {
    {
#line 210
    __cil_tmp47 = (unsigned long )du;
#line 210
    __cil_tmp48 = __cil_tmp47 + 2000;
#line 210
    __cil_tmp49 = (struct vmw_dma_buffer **)__cil_tmp48;
#line 210
    vmw_dmabuf_unreference(__cil_tmp49);
    }
  } else {

  }
  }
  {
#line 213
  __cil_tmp50 = & surface;
#line 213
  if (*__cil_tmp50) {
    {
#line 215
    __cil_tmp51 = (unsigned long )du;
#line 215
    __cil_tmp52 = __cil_tmp51 + 1992;
#line 215
    __cil_tmp53 = & surface;
#line 215
    *((struct vmw_surface **)__cil_tmp52) = *__cil_tmp53;
#line 217
    __cil_tmp54 = (unsigned long )du;
#line 217
    __cil_tmp55 = __cil_tmp54 + 1992;
#line 217
    __cil_tmp56 = *((struct vmw_surface **)__cil_tmp55);
#line 217
    __cil_tmp57 = (unsigned long )__cil_tmp56;
#line 217
    __cil_tmp58 = __cil_tmp57 + 160;
#line 217
    *((struct drm_crtc **)__cil_tmp58) = crtc;
#line 218
    __cil_tmp59 = (unsigned long )du;
#line 218
    __cil_tmp60 = __cil_tmp59 + 2008;
#line 218
    __cil_tmp61 = 160 + 8;
#line 218
    __cil_tmp62 = (unsigned long )du;
#line 218
    __cil_tmp63 = __cil_tmp62 + 1992;
#line 218
    __cil_tmp64 = *((struct vmw_surface **)__cil_tmp63);
#line 218
    __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 218
    __cil_tmp66 = __cil_tmp65 + __cil_tmp61;
#line 218
    *((size_t *)__cil_tmp60) = *((size_t *)__cil_tmp66);
#line 219
    __cil_tmp67 = 160 + 16;
#line 219
    __cil_tmp68 = & surface;
#line 219
    __cil_tmp69 = *__cil_tmp68;
#line 219
    __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 219
    __cil_tmp71 = __cil_tmp70 + __cil_tmp67;
#line 219
    __cil_tmp72 = *((uint32_t **)__cil_tmp71);
#line 219
    __cil_tmp73 = (u32 )64;
#line 219
    __cil_tmp74 = (u32 )64;
#line 219
    __cil_tmp75 = (unsigned long )du;
#line 219
    __cil_tmp76 = __cil_tmp75 + 2024;
#line 219
    __cil_tmp77 = *((int *)__cil_tmp76);
#line 219
    __cil_tmp78 = (u32 )__cil_tmp77;
#line 219
    __cil_tmp79 = (unsigned long )du;
#line 219
    __cil_tmp80 = __cil_tmp79 + 2028;
#line 219
    __cil_tmp81 = *((int *)__cil_tmp80);
#line 219
    __cil_tmp82 = (u32 )__cil_tmp81;
#line 219
    vmw_cursor_update_image(dev_priv, __cil_tmp72, __cil_tmp73, __cil_tmp74, __cil_tmp78,
                            __cil_tmp82);
    }
  } else {
    {
#line 221
    __cil_tmp83 = & dmabuf;
#line 221
    if (*__cil_tmp83) {
      {
#line 223
      __cil_tmp84 = (unsigned long )du;
#line 223
      __cil_tmp85 = __cil_tmp84 + 2000;
#line 223
      __cil_tmp86 = & dmabuf;
#line 223
      *((struct vmw_dma_buffer **)__cil_tmp85) = *__cil_tmp86;
#line 225
      __cil_tmp87 = & dmabuf;
#line 225
      __cil_tmp88 = *__cil_tmp87;
#line 225
      __cil_tmp89 = (unsigned long )du;
#line 225
      __cil_tmp90 = __cil_tmp89 + 2024;
#line 225
      __cil_tmp91 = *((int *)__cil_tmp90);
#line 225
      __cil_tmp92 = (u32 )__cil_tmp91;
#line 225
      __cil_tmp93 = (unsigned long )du;
#line 225
      __cil_tmp94 = __cil_tmp93 + 2028;
#line 225
      __cil_tmp95 = *((int *)__cil_tmp94);
#line 225
      __cil_tmp96 = (u32 )__cil_tmp95;
#line 225
      ret = vmw_cursor_update_dmabuf(dev_priv, __cil_tmp88, width, height, __cil_tmp92,
                                     __cil_tmp96);
      }
    } else {
      {
#line 228
      __cil_tmp97 = (bool )0;
#line 228
      vmw_cursor_update_position(dev_priv, __cil_tmp97, 0, 0);
      }
#line 229
      return (0);
    }
    }
  }
  }
  {
#line 232
  __cil_tmp98 = (bool )1;
#line 232
  __cil_tmp99 = (unsigned long )du;
#line 232
  __cil_tmp100 = __cil_tmp99 + 2024;
#line 232
  __cil_tmp101 = *((int *)__cil_tmp100);
#line 232
  __cil_tmp102 = (unsigned long )du;
#line 232
  __cil_tmp103 = __cil_tmp102 + 2016;
#line 232
  __cil_tmp104 = *((int *)__cil_tmp103);
#line 232
  __cil_tmp105 = __cil_tmp104 + __cil_tmp101;
#line 232
  __cil_tmp106 = (unsigned long )du;
#line 232
  __cil_tmp107 = __cil_tmp106 + 2028;
#line 232
  __cil_tmp108 = *((int *)__cil_tmp107);
#line 232
  __cil_tmp109 = (unsigned long )du;
#line 232
  __cil_tmp110 = __cil_tmp109 + 2020;
#line 232
  __cil_tmp111 = *((int *)__cil_tmp110);
#line 232
  __cil_tmp112 = __cil_tmp111 + __cil_tmp108;
#line 232
  vmw_cursor_update_position(dev_priv, __cil_tmp98, __cil_tmp105, __cil_tmp112);
  }
#line 236
  return (0);
}
}
#line 239 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_display_unit *du ;
  struct drm_crtc    *__mptr ;
  bool shown ;
  int tmp___8 ;
  struct drm_device *__cil_tmp10 ;
  struct vmw_display_unit *__cil_tmp11 ;
  struct drm_crtc *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;

  {
  {
#line 241
  __cil_tmp10 = *((struct drm_device **)crtc);
#line 241
  tmp___7 = vmw_priv(__cil_tmp10);
#line 241
  dev_priv = tmp___7;
#line 242
  __mptr = (struct drm_crtc    *)crtc;
#line 242
  __cil_tmp11 = (struct vmw_display_unit *)0;
#line 242
  __cil_tmp12 = (struct drm_crtc *)__cil_tmp11;
#line 242
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 242
  __cil_tmp14 = (char *)__mptr;
#line 242
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
#line 242
  du = (struct vmw_display_unit *)__cil_tmp15;
  }
  {
#line 243
  __cil_tmp16 = (unsigned long )du;
#line 243
  __cil_tmp17 = __cil_tmp16 + 1992;
#line 243
  if (*((struct vmw_surface **)__cil_tmp17)) {
#line 243
    tmp___8 = 1;
  } else {
    {
#line 243
    __cil_tmp18 = (unsigned long )du;
#line 243
    __cil_tmp19 = __cil_tmp18 + 2000;
#line 243
    if (*((struct vmw_dma_buffer **)__cil_tmp19)) {
#line 243
      tmp___8 = 1;
    } else {
#line 243
      tmp___8 = 0;
    }
    }
  }
  }
  {
#line 243
  shown = (bool )tmp___8;
#line 245
  __cil_tmp20 = (unsigned long )du;
#line 245
  __cil_tmp21 = __cil_tmp20 + 2016;
#line 245
  __cil_tmp22 = (unsigned long )crtc;
#line 245
  __cil_tmp23 = __cil_tmp22 + 480;
#line 245
  __cil_tmp24 = *((int *)__cil_tmp23);
#line 245
  *((int *)__cil_tmp21) = x + __cil_tmp24;
#line 246
  __cil_tmp25 = (unsigned long )du;
#line 246
  __cil_tmp26 = __cil_tmp25 + 2020;
#line 246
  __cil_tmp27 = (unsigned long )crtc;
#line 246
  __cil_tmp28 = __cil_tmp27 + 484;
#line 246
  __cil_tmp29 = *((int *)__cil_tmp28);
#line 246
  *((int *)__cil_tmp26) = y + __cil_tmp29;
#line 248
  __cil_tmp30 = (unsigned long )du;
#line 248
  __cil_tmp31 = __cil_tmp30 + 2024;
#line 248
  __cil_tmp32 = *((int *)__cil_tmp31);
#line 248
  __cil_tmp33 = (unsigned long )du;
#line 248
  __cil_tmp34 = __cil_tmp33 + 2016;
#line 248
  __cil_tmp35 = *((int *)__cil_tmp34);
#line 248
  __cil_tmp36 = __cil_tmp35 + __cil_tmp32;
#line 248
  __cil_tmp37 = (unsigned long )du;
#line 248
  __cil_tmp38 = __cil_tmp37 + 2028;
#line 248
  __cil_tmp39 = *((int *)__cil_tmp38);
#line 248
  __cil_tmp40 = (unsigned long )du;
#line 248
  __cil_tmp41 = __cil_tmp40 + 2020;
#line 248
  __cil_tmp42 = *((int *)__cil_tmp41);
#line 248
  __cil_tmp43 = __cil_tmp42 + __cil_tmp39;
#line 248
  vmw_cursor_update_position(dev_priv, shown, __cil_tmp36, __cil_tmp43);
  }
#line 252
  return (0);
}
}
#line 255 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  SVGA3dCopyBox *box ;
  unsigned int box_count ;
  void *virtual ;
  bool dummy ;
  struct vmw_dma_cmd *cmd ;
  int i ;
  int ret ;
  SVGA3dCmdHeader    *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct vmw_dma_cmd *__cil_tmp22 ;
  SVGA3dCmdHeader *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32 __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32 __cil_tmp44 ;
  struct vmw_dma_cmd *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  uint32 __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  uint32 __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint32 __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32 __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32 __cil_tmp69 ;
  uint32 __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  uint32 __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  uint32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  uint32 __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  uint32 __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  uint32 __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  uint32 __cil_tmp91 ;
  uint32 __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  uint32 __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  uint32 __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  uint32 __cil_tmp101 ;
  uint32 __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  uint32 __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  uint32 __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  uint32 __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  uint32 __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  uint32 __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  uint32 __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  uint32 __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  uint32 __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  uint32 __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  uint32 __cil_tmp135 ;
  uint32 __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  uint32 __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  uint32 __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  uint32 __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  uint32 __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  uint32 __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  uint32 __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  uint32 __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  uint32 __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  uint32 __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  uint32 __cil_tmp169 ;
  uint32 __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  uint32 __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  uint32 __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  uint32 __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  uint32 __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  uint32 __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  uint32 __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  uint32 __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  uint32 __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint32 __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  uint32 __cil_tmp203 ;
  uint32 __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  uint32 __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  uint32 __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  uint32 __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  uint32 __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  uint32 __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  uint32 __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  uint32 __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  uint32 __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  uint32 __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  uint32 __cil_tmp237 ;
  uint32 __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  uint32 __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  uint32 __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  uint32 __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  uint32 __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  uint32 __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  uint32 __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  uint32 __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  uint32 __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  uint32 __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  uint32 __cil_tmp271 ;
  uint32 __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  uint32 __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  uint32 __cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  uint32 __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  uint32 __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  uint32 __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  uint32 __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  uint32 __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  uint32 __cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  uint32 __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  uint32 __cil_tmp305 ;
  uint32 __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  uint32 __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  uint32 __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  unsigned long __cil_tmp314 ;
  uint32 __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  uint32 __cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  uint32 __cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;
  unsigned long __cil_tmp325 ;
  unsigned long __cil_tmp326 ;
  uint32 __cil_tmp327 ;
  unsigned long __cil_tmp328 ;
  unsigned long __cil_tmp329 ;
  uint32 __cil_tmp330 ;
  unsigned long __cil_tmp331 ;
  unsigned long __cil_tmp332 ;
  uint32 __cil_tmp333 ;
  unsigned long __cil_tmp334 ;
  unsigned long __cil_tmp335 ;
  uint32 __cil_tmp336 ;
  uint32 __cil_tmp337 ;
  unsigned long __cil_tmp338 ;
  unsigned long __cil_tmp339 ;
  uint32 __cil_tmp340 ;
  unsigned long __cil_tmp341 ;
  unsigned long __cil_tmp342 ;
  uint32 __cil_tmp343 ;
  unsigned long __cil_tmp344 ;
  unsigned long __cil_tmp345 ;
  uint32 __cil_tmp346 ;
  unsigned long __cil_tmp347 ;
  unsigned long __cil_tmp348 ;
  uint32 __cil_tmp349 ;
  unsigned long __cil_tmp350 ;
  unsigned long __cil_tmp351 ;
  uint32 __cil_tmp352 ;
  unsigned long __cil_tmp353 ;
  unsigned long __cil_tmp354 ;
  unsigned long __cil_tmp355 ;
  unsigned long __cil_tmp356 ;
  unsigned long __cil_tmp357 ;
  uint32 __cil_tmp358 ;
  unsigned long __cil_tmp359 ;
  unsigned long __cil_tmp360 ;
  unsigned long __cil_tmp361 ;
  unsigned long __cil_tmp362 ;
  unsigned long __cil_tmp363 ;
  uint32 __cil_tmp364 ;
  uint32 __cil_tmp365 ;
  int __cil_tmp366 ;
  bool __cil_tmp367 ;
  bool __cil_tmp368 ;
  bool __cil_tmp369 ;
  uint32_t __cil_tmp370 ;
  int __cil_tmp371 ;
  int __cil_tmp372 ;
  int __cil_tmp373 ;
  long __cil_tmp374 ;
  int __cil_tmp375 ;
  int __cil_tmp376 ;
  int __cil_tmp377 ;
  long __cil_tmp378 ;
  unsigned long __cil_tmp379 ;
  unsigned long __cil_tmp380 ;
  uint32 __cil_tmp381 ;
  unsigned long __cil_tmp382 ;
  unsigned long __cil_tmp383 ;
  unsigned long __cil_tmp384 ;
  unsigned long __cil_tmp385 ;
  uint32 __cil_tmp386 ;
  unsigned long __cil_tmp387 ;
  unsigned long __cil_tmp388 ;
  unsigned long __cil_tmp389 ;
  uint32_t *__cil_tmp390 ;
  void *__cil_tmp391 ;
  void    *__cil_tmp392 ;
  unsigned long __cil_tmp393 ;
  unsigned long __cil_tmp394 ;
  unsigned long __cil_tmp395 ;
  uint32_t *__cil_tmp396 ;
  void *__cil_tmp397 ;
  void    *__cil_tmp398 ;
  unsigned long __cil_tmp399 ;
  unsigned long __cil_tmp400 ;
  uint32 __cil_tmp401 ;
  uint32 __cil_tmp402 ;
  unsigned long __cil_tmp403 ;
  unsigned long __cil_tmp404 ;
  uint32 __cil_tmp405 ;
  uint32 __cil_tmp406 ;
  int __cil_tmp407 ;
  unsigned long __cil_tmp408 ;
  unsigned long __cil_tmp409 ;
  unsigned long __cil_tmp410 ;
  uint32_t *__cil_tmp411 ;
  uint32_t *__cil_tmp412 ;
  void *__cil_tmp413 ;
  unsigned long __cil_tmp414 ;
  unsigned long __cil_tmp415 ;
  unsigned long __cil_tmp416 ;
  unsigned long __cil_tmp417 ;
  uint32 __cil_tmp418 ;
  uint32 __cil_tmp419 ;
  uint32 __cil_tmp420 ;
  void *__cil_tmp421 ;
  void    *__cil_tmp422 ;
  unsigned long __cil_tmp423 ;
  unsigned long __cil_tmp424 ;
  unsigned long __cil_tmp425 ;
  unsigned long __cil_tmp426 ;
  unsigned long __cil_tmp427 ;
  unsigned long __cil_tmp428 ;
  size_t __cil_tmp429 ;

  {
#line 273
  __mptr = (SVGA3dCmdHeader    *)header;
#line 273
  __cil_tmp22 = (struct vmw_dma_cmd *)0;
#line 273
  __cil_tmp23 = (SVGA3dCmdHeader *)__cil_tmp22;
#line 273
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 273
  __cil_tmp25 = (char *)__mptr;
#line 273
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 273
  cmd = (struct vmw_dma_cmd *)__cil_tmp26;
  {
#line 276
  __cil_tmp27 = 160 + 16;
#line 276
  __cil_tmp28 = (unsigned long )srf;
#line 276
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
#line 276
  __cil_tmp30 = *((uint32_t **)__cil_tmp29);
#line 276
  if (! __cil_tmp30) {
#line 277
    return;
  } else {

  }
  }
  {
#line 279
  __cil_tmp31 = 12 + 4;
#line 279
  __cil_tmp32 = 8 + __cil_tmp31;
#line 279
  __cil_tmp33 = (unsigned long )cmd;
#line 279
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 279
  __cil_tmp35 = *((uint32 *)__cil_tmp34);
#line 279
  if (__cil_tmp35 != 0U) {
    {
#line 280
    drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
    }
#line 281
    return;
  } else {
    {
#line 279
    __cil_tmp36 = 12 + 8;
#line 279
    __cil_tmp37 = 8 + __cil_tmp36;
#line 279
    __cil_tmp38 = (unsigned long )cmd;
#line 279
    __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
#line 279
    __cil_tmp40 = *((uint32 *)__cil_tmp39);
#line 279
    if (__cil_tmp40 != 0U) {
      {
#line 280
      drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
      }
#line 281
      return;
    } else {

    }
    }
  }
  }
  {
#line 284
  __cil_tmp41 = 0 + 4;
#line 284
  __cil_tmp42 = (unsigned long )cmd;
#line 284
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 284
  __cil_tmp44 = *((uint32 *)__cil_tmp43);
#line 284
  if (__cil_tmp44 < 64U) {
    {
#line 285
    drm_err("vmw_kms_cursor_snoop", "at least one full copy box must be given\n");
    }
#line 286
    return;
  } else {

  }
  }
#line 289
  __cil_tmp45 = cmd + 1;
#line 289
  box = (SVGA3dCopyBox *)__cil_tmp45;
#line 290
  __cil_tmp46 = 0 + 4;
#line 290
  __cil_tmp47 = (unsigned long )cmd;
#line 290
  __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 290
  __cil_tmp49 = *((uint32 *)__cil_tmp48);
#line 290
  __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 290
  __cil_tmp51 = __cil_tmp50 - 28UL;
#line 290
  __cil_tmp52 = __cil_tmp51 / 36UL;
#line 290
  box_count = (unsigned int )__cil_tmp52;
  {
#line 293
  __cil_tmp53 = 1UL << 12;
#line 293
  __cil_tmp54 = 0 + 4;
#line 293
  __cil_tmp55 = 0 + __cil_tmp54;
#line 293
  __cil_tmp56 = 8 + __cil_tmp55;
#line 293
  __cil_tmp57 = (unsigned long )cmd;
#line 293
  __cil_tmp58 = __cil_tmp57 + __cil_tmp56;
#line 293
  __cil_tmp59 = *((uint32 *)__cil_tmp58);
#line 293
  __cil_tmp60 = (unsigned long )__cil_tmp59;
#line 293
  if (__cil_tmp60 % __cil_tmp53) {
    {
#line 300
    drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
    __cil_tmp61 = (unsigned long )box;
#line 301
    __cil_tmp62 = __cil_tmp61 + 24;
#line 301
    __cil_tmp63 = *((uint32 *)__cil_tmp62);
#line 301
    __cil_tmp64 = (unsigned long )box;
#line 301
    __cil_tmp65 = __cil_tmp64 + 28;
#line 301
    __cil_tmp66 = *((uint32 *)__cil_tmp65);
#line 301
    __cil_tmp67 = (unsigned long )box;
#line 301
    __cil_tmp68 = __cil_tmp67 + 32;
#line 301
    __cil_tmp69 = *((uint32 *)__cil_tmp68);
#line 301
    __cil_tmp70 = *((uint32 *)box);
#line 301
    __cil_tmp71 = (unsigned long )box;
#line 301
    __cil_tmp72 = __cil_tmp71 + 4;
#line 301
    __cil_tmp73 = *((uint32 *)__cil_tmp72);
#line 301
    __cil_tmp74 = (unsigned long )box;
#line 301
    __cil_tmp75 = __cil_tmp74 + 8;
#line 301
    __cil_tmp76 = *((uint32 *)__cil_tmp75);
#line 301
    __cil_tmp77 = (unsigned long )box;
#line 301
    __cil_tmp78 = __cil_tmp77 + 12;
#line 301
    __cil_tmp79 = *((uint32 *)__cil_tmp78);
#line 301
    __cil_tmp80 = (unsigned long )box;
#line 301
    __cil_tmp81 = __cil_tmp80 + 16;
#line 301
    __cil_tmp82 = *((uint32 *)__cil_tmp81);
#line 301
    __cil_tmp83 = (unsigned long )box;
#line 301
    __cil_tmp84 = __cil_tmp83 + 20;
#line 301
    __cil_tmp85 = *((uint32 *)__cil_tmp84);
#line 301
    __cil_tmp86 = 0 + 4;
#line 301
    __cil_tmp87 = 0 + __cil_tmp86;
#line 301
    __cil_tmp88 = 8 + __cil_tmp87;
#line 301
    __cil_tmp89 = (unsigned long )cmd;
#line 301
    __cil_tmp90 = __cil_tmp89 + __cil_tmp88;
#line 301
    __cil_tmp91 = *((uint32 *)__cil_tmp90);
#line 301
    drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
            __cil_tmp63, __cil_tmp66, __cil_tmp69, __cil_tmp70, __cil_tmp73, __cil_tmp76,
            __cil_tmp79, __cil_tmp82, __cil_tmp85, box_count, __cil_tmp91);
    }
#line 306
    return;
  } else {
    {
#line 293
    __cil_tmp92 = *((uint32 *)box);
#line 293
    if (__cil_tmp92 != 0U) {
      {
#line 300
      drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
      __cil_tmp93 = (unsigned long )box;
#line 301
      __cil_tmp94 = __cil_tmp93 + 24;
#line 301
      __cil_tmp95 = *((uint32 *)__cil_tmp94);
#line 301
      __cil_tmp96 = (unsigned long )box;
#line 301
      __cil_tmp97 = __cil_tmp96 + 28;
#line 301
      __cil_tmp98 = *((uint32 *)__cil_tmp97);
#line 301
      __cil_tmp99 = (unsigned long )box;
#line 301
      __cil_tmp100 = __cil_tmp99 + 32;
#line 301
      __cil_tmp101 = *((uint32 *)__cil_tmp100);
#line 301
      __cil_tmp102 = *((uint32 *)box);
#line 301
      __cil_tmp103 = (unsigned long )box;
#line 301
      __cil_tmp104 = __cil_tmp103 + 4;
#line 301
      __cil_tmp105 = *((uint32 *)__cil_tmp104);
#line 301
      __cil_tmp106 = (unsigned long )box;
#line 301
      __cil_tmp107 = __cil_tmp106 + 8;
#line 301
      __cil_tmp108 = *((uint32 *)__cil_tmp107);
#line 301
      __cil_tmp109 = (unsigned long )box;
#line 301
      __cil_tmp110 = __cil_tmp109 + 12;
#line 301
      __cil_tmp111 = *((uint32 *)__cil_tmp110);
#line 301
      __cil_tmp112 = (unsigned long )box;
#line 301
      __cil_tmp113 = __cil_tmp112 + 16;
#line 301
      __cil_tmp114 = *((uint32 *)__cil_tmp113);
#line 301
      __cil_tmp115 = (unsigned long )box;
#line 301
      __cil_tmp116 = __cil_tmp115 + 20;
#line 301
      __cil_tmp117 = *((uint32 *)__cil_tmp116);
#line 301
      __cil_tmp118 = 0 + 4;
#line 301
      __cil_tmp119 = 0 + __cil_tmp118;
#line 301
      __cil_tmp120 = 8 + __cil_tmp119;
#line 301
      __cil_tmp121 = (unsigned long )cmd;
#line 301
      __cil_tmp122 = __cil_tmp121 + __cil_tmp120;
#line 301
      __cil_tmp123 = *((uint32 *)__cil_tmp122);
#line 301
      drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
              __cil_tmp95, __cil_tmp98, __cil_tmp101, __cil_tmp102, __cil_tmp105,
              __cil_tmp108, __cil_tmp111, __cil_tmp114, __cil_tmp117, box_count, __cil_tmp123);
      }
#line 306
      return;
    } else {
      {
#line 293
      __cil_tmp124 = (unsigned long )box;
#line 293
      __cil_tmp125 = __cil_tmp124 + 4;
#line 293
      __cil_tmp126 = *((uint32 *)__cil_tmp125);
#line 293
      if (__cil_tmp126 != 0U) {
        {
#line 300
        drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
        __cil_tmp127 = (unsigned long )box;
#line 301
        __cil_tmp128 = __cil_tmp127 + 24;
#line 301
        __cil_tmp129 = *((uint32 *)__cil_tmp128);
#line 301
        __cil_tmp130 = (unsigned long )box;
#line 301
        __cil_tmp131 = __cil_tmp130 + 28;
#line 301
        __cil_tmp132 = *((uint32 *)__cil_tmp131);
#line 301
        __cil_tmp133 = (unsigned long )box;
#line 301
        __cil_tmp134 = __cil_tmp133 + 32;
#line 301
        __cil_tmp135 = *((uint32 *)__cil_tmp134);
#line 301
        __cil_tmp136 = *((uint32 *)box);
#line 301
        __cil_tmp137 = (unsigned long )box;
#line 301
        __cil_tmp138 = __cil_tmp137 + 4;
#line 301
        __cil_tmp139 = *((uint32 *)__cil_tmp138);
#line 301
        __cil_tmp140 = (unsigned long )box;
#line 301
        __cil_tmp141 = __cil_tmp140 + 8;
#line 301
        __cil_tmp142 = *((uint32 *)__cil_tmp141);
#line 301
        __cil_tmp143 = (unsigned long )box;
#line 301
        __cil_tmp144 = __cil_tmp143 + 12;
#line 301
        __cil_tmp145 = *((uint32 *)__cil_tmp144);
#line 301
        __cil_tmp146 = (unsigned long )box;
#line 301
        __cil_tmp147 = __cil_tmp146 + 16;
#line 301
        __cil_tmp148 = *((uint32 *)__cil_tmp147);
#line 301
        __cil_tmp149 = (unsigned long )box;
#line 301
        __cil_tmp150 = __cil_tmp149 + 20;
#line 301
        __cil_tmp151 = *((uint32 *)__cil_tmp150);
#line 301
        __cil_tmp152 = 0 + 4;
#line 301
        __cil_tmp153 = 0 + __cil_tmp152;
#line 301
        __cil_tmp154 = 8 + __cil_tmp153;
#line 301
        __cil_tmp155 = (unsigned long )cmd;
#line 301
        __cil_tmp156 = __cil_tmp155 + __cil_tmp154;
#line 301
        __cil_tmp157 = *((uint32 *)__cil_tmp156);
#line 301
        drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                __cil_tmp129, __cil_tmp132, __cil_tmp135, __cil_tmp136, __cil_tmp139,
                __cil_tmp142, __cil_tmp145, __cil_tmp148, __cil_tmp151, box_count,
                __cil_tmp157);
        }
#line 306
        return;
      } else {
        {
#line 293
        __cil_tmp158 = (unsigned long )box;
#line 293
        __cil_tmp159 = __cil_tmp158 + 8;
#line 293
        __cil_tmp160 = *((uint32 *)__cil_tmp159);
#line 293
        if (__cil_tmp160 != 0U) {
          {
#line 300
          drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
          __cil_tmp161 = (unsigned long )box;
#line 301
          __cil_tmp162 = __cil_tmp161 + 24;
#line 301
          __cil_tmp163 = *((uint32 *)__cil_tmp162);
#line 301
          __cil_tmp164 = (unsigned long )box;
#line 301
          __cil_tmp165 = __cil_tmp164 + 28;
#line 301
          __cil_tmp166 = *((uint32 *)__cil_tmp165);
#line 301
          __cil_tmp167 = (unsigned long )box;
#line 301
          __cil_tmp168 = __cil_tmp167 + 32;
#line 301
          __cil_tmp169 = *((uint32 *)__cil_tmp168);
#line 301
          __cil_tmp170 = *((uint32 *)box);
#line 301
          __cil_tmp171 = (unsigned long )box;
#line 301
          __cil_tmp172 = __cil_tmp171 + 4;
#line 301
          __cil_tmp173 = *((uint32 *)__cil_tmp172);
#line 301
          __cil_tmp174 = (unsigned long )box;
#line 301
          __cil_tmp175 = __cil_tmp174 + 8;
#line 301
          __cil_tmp176 = *((uint32 *)__cil_tmp175);
#line 301
          __cil_tmp177 = (unsigned long )box;
#line 301
          __cil_tmp178 = __cil_tmp177 + 12;
#line 301
          __cil_tmp179 = *((uint32 *)__cil_tmp178);
#line 301
          __cil_tmp180 = (unsigned long )box;
#line 301
          __cil_tmp181 = __cil_tmp180 + 16;
#line 301
          __cil_tmp182 = *((uint32 *)__cil_tmp181);
#line 301
          __cil_tmp183 = (unsigned long )box;
#line 301
          __cil_tmp184 = __cil_tmp183 + 20;
#line 301
          __cil_tmp185 = *((uint32 *)__cil_tmp184);
#line 301
          __cil_tmp186 = 0 + 4;
#line 301
          __cil_tmp187 = 0 + __cil_tmp186;
#line 301
          __cil_tmp188 = 8 + __cil_tmp187;
#line 301
          __cil_tmp189 = (unsigned long )cmd;
#line 301
          __cil_tmp190 = __cil_tmp189 + __cil_tmp188;
#line 301
          __cil_tmp191 = *((uint32 *)__cil_tmp190);
#line 301
          drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                  __cil_tmp163, __cil_tmp166, __cil_tmp169, __cil_tmp170, __cil_tmp173,
                  __cil_tmp176, __cil_tmp179, __cil_tmp182, __cil_tmp185, box_count,
                  __cil_tmp191);
          }
#line 306
          return;
        } else {
          {
#line 293
          __cil_tmp192 = (unsigned long )box;
#line 293
          __cil_tmp193 = __cil_tmp192 + 24;
#line 293
          __cil_tmp194 = *((uint32 *)__cil_tmp193);
#line 293
          if (__cil_tmp194 != 0U) {
            {
#line 300
            drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
            __cil_tmp195 = (unsigned long )box;
#line 301
            __cil_tmp196 = __cil_tmp195 + 24;
#line 301
            __cil_tmp197 = *((uint32 *)__cil_tmp196);
#line 301
            __cil_tmp198 = (unsigned long )box;
#line 301
            __cil_tmp199 = __cil_tmp198 + 28;
#line 301
            __cil_tmp200 = *((uint32 *)__cil_tmp199);
#line 301
            __cil_tmp201 = (unsigned long )box;
#line 301
            __cil_tmp202 = __cil_tmp201 + 32;
#line 301
            __cil_tmp203 = *((uint32 *)__cil_tmp202);
#line 301
            __cil_tmp204 = *((uint32 *)box);
#line 301
            __cil_tmp205 = (unsigned long )box;
#line 301
            __cil_tmp206 = __cil_tmp205 + 4;
#line 301
            __cil_tmp207 = *((uint32 *)__cil_tmp206);
#line 301
            __cil_tmp208 = (unsigned long )box;
#line 301
            __cil_tmp209 = __cil_tmp208 + 8;
#line 301
            __cil_tmp210 = *((uint32 *)__cil_tmp209);
#line 301
            __cil_tmp211 = (unsigned long )box;
#line 301
            __cil_tmp212 = __cil_tmp211 + 12;
#line 301
            __cil_tmp213 = *((uint32 *)__cil_tmp212);
#line 301
            __cil_tmp214 = (unsigned long )box;
#line 301
            __cil_tmp215 = __cil_tmp214 + 16;
#line 301
            __cil_tmp216 = *((uint32 *)__cil_tmp215);
#line 301
            __cil_tmp217 = (unsigned long )box;
#line 301
            __cil_tmp218 = __cil_tmp217 + 20;
#line 301
            __cil_tmp219 = *((uint32 *)__cil_tmp218);
#line 301
            __cil_tmp220 = 0 + 4;
#line 301
            __cil_tmp221 = 0 + __cil_tmp220;
#line 301
            __cil_tmp222 = 8 + __cil_tmp221;
#line 301
            __cil_tmp223 = (unsigned long )cmd;
#line 301
            __cil_tmp224 = __cil_tmp223 + __cil_tmp222;
#line 301
            __cil_tmp225 = *((uint32 *)__cil_tmp224);
#line 301
            drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                    __cil_tmp197, __cil_tmp200, __cil_tmp203, __cil_tmp204, __cil_tmp207,
                    __cil_tmp210, __cil_tmp213, __cil_tmp216, __cil_tmp219, box_count,
                    __cil_tmp225);
            }
#line 306
            return;
          } else {
            {
#line 293
            __cil_tmp226 = (unsigned long )box;
#line 293
            __cil_tmp227 = __cil_tmp226 + 28;
#line 293
            __cil_tmp228 = *((uint32 *)__cil_tmp227);
#line 293
            if (__cil_tmp228 != 0U) {
              {
#line 300
              drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
              __cil_tmp229 = (unsigned long )box;
#line 301
              __cil_tmp230 = __cil_tmp229 + 24;
#line 301
              __cil_tmp231 = *((uint32 *)__cil_tmp230);
#line 301
              __cil_tmp232 = (unsigned long )box;
#line 301
              __cil_tmp233 = __cil_tmp232 + 28;
#line 301
              __cil_tmp234 = *((uint32 *)__cil_tmp233);
#line 301
              __cil_tmp235 = (unsigned long )box;
#line 301
              __cil_tmp236 = __cil_tmp235 + 32;
#line 301
              __cil_tmp237 = *((uint32 *)__cil_tmp236);
#line 301
              __cil_tmp238 = *((uint32 *)box);
#line 301
              __cil_tmp239 = (unsigned long )box;
#line 301
              __cil_tmp240 = __cil_tmp239 + 4;
#line 301
              __cil_tmp241 = *((uint32 *)__cil_tmp240);
#line 301
              __cil_tmp242 = (unsigned long )box;
#line 301
              __cil_tmp243 = __cil_tmp242 + 8;
#line 301
              __cil_tmp244 = *((uint32 *)__cil_tmp243);
#line 301
              __cil_tmp245 = (unsigned long )box;
#line 301
              __cil_tmp246 = __cil_tmp245 + 12;
#line 301
              __cil_tmp247 = *((uint32 *)__cil_tmp246);
#line 301
              __cil_tmp248 = (unsigned long )box;
#line 301
              __cil_tmp249 = __cil_tmp248 + 16;
#line 301
              __cil_tmp250 = *((uint32 *)__cil_tmp249);
#line 301
              __cil_tmp251 = (unsigned long )box;
#line 301
              __cil_tmp252 = __cil_tmp251 + 20;
#line 301
              __cil_tmp253 = *((uint32 *)__cil_tmp252);
#line 301
              __cil_tmp254 = 0 + 4;
#line 301
              __cil_tmp255 = 0 + __cil_tmp254;
#line 301
              __cil_tmp256 = 8 + __cil_tmp255;
#line 301
              __cil_tmp257 = (unsigned long )cmd;
#line 301
              __cil_tmp258 = __cil_tmp257 + __cil_tmp256;
#line 301
              __cil_tmp259 = *((uint32 *)__cil_tmp258);
#line 301
              drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                      __cil_tmp231, __cil_tmp234, __cil_tmp237, __cil_tmp238, __cil_tmp241,
                      __cil_tmp244, __cil_tmp247, __cil_tmp250, __cil_tmp253, box_count,
                      __cil_tmp259);
              }
#line 306
              return;
            } else {
              {
#line 293
              __cil_tmp260 = (unsigned long )box;
#line 293
              __cil_tmp261 = __cil_tmp260 + 32;
#line 293
              __cil_tmp262 = *((uint32 *)__cil_tmp261);
#line 293
              if (__cil_tmp262 != 0U) {
                {
#line 300
                drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
                __cil_tmp263 = (unsigned long )box;
#line 301
                __cil_tmp264 = __cil_tmp263 + 24;
#line 301
                __cil_tmp265 = *((uint32 *)__cil_tmp264);
#line 301
                __cil_tmp266 = (unsigned long )box;
#line 301
                __cil_tmp267 = __cil_tmp266 + 28;
#line 301
                __cil_tmp268 = *((uint32 *)__cil_tmp267);
#line 301
                __cil_tmp269 = (unsigned long )box;
#line 301
                __cil_tmp270 = __cil_tmp269 + 32;
#line 301
                __cil_tmp271 = *((uint32 *)__cil_tmp270);
#line 301
                __cil_tmp272 = *((uint32 *)box);
#line 301
                __cil_tmp273 = (unsigned long )box;
#line 301
                __cil_tmp274 = __cil_tmp273 + 4;
#line 301
                __cil_tmp275 = *((uint32 *)__cil_tmp274);
#line 301
                __cil_tmp276 = (unsigned long )box;
#line 301
                __cil_tmp277 = __cil_tmp276 + 8;
#line 301
                __cil_tmp278 = *((uint32 *)__cil_tmp277);
#line 301
                __cil_tmp279 = (unsigned long )box;
#line 301
                __cil_tmp280 = __cil_tmp279 + 12;
#line 301
                __cil_tmp281 = *((uint32 *)__cil_tmp280);
#line 301
                __cil_tmp282 = (unsigned long )box;
#line 301
                __cil_tmp283 = __cil_tmp282 + 16;
#line 301
                __cil_tmp284 = *((uint32 *)__cil_tmp283);
#line 301
                __cil_tmp285 = (unsigned long )box;
#line 301
                __cil_tmp286 = __cil_tmp285 + 20;
#line 301
                __cil_tmp287 = *((uint32 *)__cil_tmp286);
#line 301
                __cil_tmp288 = 0 + 4;
#line 301
                __cil_tmp289 = 0 + __cil_tmp288;
#line 301
                __cil_tmp290 = 8 + __cil_tmp289;
#line 301
                __cil_tmp291 = (unsigned long )cmd;
#line 301
                __cil_tmp292 = __cil_tmp291 + __cil_tmp290;
#line 301
                __cil_tmp293 = *((uint32 *)__cil_tmp292);
#line 301
                drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                        __cil_tmp265, __cil_tmp268, __cil_tmp271, __cil_tmp272, __cil_tmp275,
                        __cil_tmp278, __cil_tmp281, __cil_tmp284, __cil_tmp287, box_count,
                        __cil_tmp293);
                }
#line 306
                return;
              } else {
                {
#line 293
                __cil_tmp294 = (unsigned long )box;
#line 293
                __cil_tmp295 = __cil_tmp294 + 20;
#line 293
                __cil_tmp296 = *((uint32 *)__cil_tmp295);
#line 293
                if (__cil_tmp296 != 1U) {
                  {
#line 300
                  drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
                  __cil_tmp297 = (unsigned long )box;
#line 301
                  __cil_tmp298 = __cil_tmp297 + 24;
#line 301
                  __cil_tmp299 = *((uint32 *)__cil_tmp298);
#line 301
                  __cil_tmp300 = (unsigned long )box;
#line 301
                  __cil_tmp301 = __cil_tmp300 + 28;
#line 301
                  __cil_tmp302 = *((uint32 *)__cil_tmp301);
#line 301
                  __cil_tmp303 = (unsigned long )box;
#line 301
                  __cil_tmp304 = __cil_tmp303 + 32;
#line 301
                  __cil_tmp305 = *((uint32 *)__cil_tmp304);
#line 301
                  __cil_tmp306 = *((uint32 *)box);
#line 301
                  __cil_tmp307 = (unsigned long )box;
#line 301
                  __cil_tmp308 = __cil_tmp307 + 4;
#line 301
                  __cil_tmp309 = *((uint32 *)__cil_tmp308);
#line 301
                  __cil_tmp310 = (unsigned long )box;
#line 301
                  __cil_tmp311 = __cil_tmp310 + 8;
#line 301
                  __cil_tmp312 = *((uint32 *)__cil_tmp311);
#line 301
                  __cil_tmp313 = (unsigned long )box;
#line 301
                  __cil_tmp314 = __cil_tmp313 + 12;
#line 301
                  __cil_tmp315 = *((uint32 *)__cil_tmp314);
#line 301
                  __cil_tmp316 = (unsigned long )box;
#line 301
                  __cil_tmp317 = __cil_tmp316 + 16;
#line 301
                  __cil_tmp318 = *((uint32 *)__cil_tmp317);
#line 301
                  __cil_tmp319 = (unsigned long )box;
#line 301
                  __cil_tmp320 = __cil_tmp319 + 20;
#line 301
                  __cil_tmp321 = *((uint32 *)__cil_tmp320);
#line 301
                  __cil_tmp322 = 0 + 4;
#line 301
                  __cil_tmp323 = 0 + __cil_tmp322;
#line 301
                  __cil_tmp324 = 8 + __cil_tmp323;
#line 301
                  __cil_tmp325 = (unsigned long )cmd;
#line 301
                  __cil_tmp326 = __cil_tmp325 + __cil_tmp324;
#line 301
                  __cil_tmp327 = *((uint32 *)__cil_tmp326);
#line 301
                  drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                          __cil_tmp299, __cil_tmp302, __cil_tmp305, __cil_tmp306,
                          __cil_tmp309, __cil_tmp312, __cil_tmp315, __cil_tmp318,
                          __cil_tmp321, box_count, __cil_tmp327);
                  }
#line 306
                  return;
                } else
#line 293
                if (box_count != 1U) {
                  {
#line 300
                  drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 301
                  __cil_tmp328 = (unsigned long )box;
#line 301
                  __cil_tmp329 = __cil_tmp328 + 24;
#line 301
                  __cil_tmp330 = *((uint32 *)__cil_tmp329);
#line 301
                  __cil_tmp331 = (unsigned long )box;
#line 301
                  __cil_tmp332 = __cil_tmp331 + 28;
#line 301
                  __cil_tmp333 = *((uint32 *)__cil_tmp332);
#line 301
                  __cil_tmp334 = (unsigned long )box;
#line 301
                  __cil_tmp335 = __cil_tmp334 + 32;
#line 301
                  __cil_tmp336 = *((uint32 *)__cil_tmp335);
#line 301
                  __cil_tmp337 = *((uint32 *)box);
#line 301
                  __cil_tmp338 = (unsigned long )box;
#line 301
                  __cil_tmp339 = __cil_tmp338 + 4;
#line 301
                  __cil_tmp340 = *((uint32 *)__cil_tmp339);
#line 301
                  __cil_tmp341 = (unsigned long )box;
#line 301
                  __cil_tmp342 = __cil_tmp341 + 8;
#line 301
                  __cil_tmp343 = *((uint32 *)__cil_tmp342);
#line 301
                  __cil_tmp344 = (unsigned long )box;
#line 301
                  __cil_tmp345 = __cil_tmp344 + 12;
#line 301
                  __cil_tmp346 = *((uint32 *)__cil_tmp345);
#line 301
                  __cil_tmp347 = (unsigned long )box;
#line 301
                  __cil_tmp348 = __cil_tmp347 + 16;
#line 301
                  __cil_tmp349 = *((uint32 *)__cil_tmp348);
#line 301
                  __cil_tmp350 = (unsigned long )box;
#line 301
                  __cil_tmp351 = __cil_tmp350 + 20;
#line 301
                  __cil_tmp352 = *((uint32 *)__cil_tmp351);
#line 301
                  __cil_tmp353 = 0 + 4;
#line 301
                  __cil_tmp354 = 0 + __cil_tmp353;
#line 301
                  __cil_tmp355 = 8 + __cil_tmp354;
#line 301
                  __cil_tmp356 = (unsigned long )cmd;
#line 301
                  __cil_tmp357 = __cil_tmp356 + __cil_tmp355;
#line 301
                  __cil_tmp358 = *((uint32 *)__cil_tmp357);
#line 301
                  drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                          __cil_tmp330, __cil_tmp333, __cil_tmp336, __cil_tmp337,
                          __cil_tmp340, __cil_tmp343, __cil_tmp346, __cil_tmp349,
                          __cil_tmp352, box_count, __cil_tmp358);
                  }
#line 306
                  return;
                } else {

                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
  {
#line 309
  __cil_tmp359 = 0 + 4;
#line 309
  __cil_tmp360 = 0 + __cil_tmp359;
#line 309
  __cil_tmp361 = 8 + __cil_tmp360;
#line 309
  __cil_tmp362 = (unsigned long )cmd;
#line 309
  __cil_tmp363 = __cil_tmp362 + __cil_tmp361;
#line 309
  __cil_tmp364 = *((uint32 *)__cil_tmp363);
#line 309
  __cil_tmp365 = __cil_tmp364 >> 12;
#line 309
  kmap_offset = (unsigned long )__cil_tmp365;
#line 310
  __cil_tmp366 = 16384 >> 12;
#line 310
  kmap_num = (unsigned long )__cil_tmp366;
#line 312
  __cil_tmp367 = (bool )1;
#line 312
  __cil_tmp368 = (bool )0;
#line 312
  __cil_tmp369 = (bool )0;
#line 312
  __cil_tmp370 = (uint32_t )0;
#line 312
  ret = ttm_bo_reserve(bo, __cil_tmp367, __cil_tmp368, __cil_tmp369, __cil_tmp370);
#line 313
  __cil_tmp371 = ret != 0;
#line 313
  __cil_tmp372 = ! __cil_tmp371;
#line 313
  __cil_tmp373 = ! __cil_tmp372;
#line 313
  __cil_tmp374 = (long )__cil_tmp373;
#line 313
  tmp___7 = ldv__builtin_expect(__cil_tmp374, 0L);
  }
#line 313
  if (tmp___7) {
    {
#line 314
    drm_err("vmw_kms_cursor_snoop", "reserve failed\n");
    }
#line 315
    return;
  } else {

  }
  {
#line 318
  ret = ttm_bo_kmap(bo, kmap_offset, kmap_num, & map);
#line 319
  __cil_tmp375 = ret != 0;
#line 319
  __cil_tmp376 = ! __cil_tmp375;
#line 319
  __cil_tmp377 = ! __cil_tmp376;
#line 319
  __cil_tmp378 = (long )__cil_tmp377;
#line 319
  tmp___8 = ldv__builtin_expect(__cil_tmp378, 0L);
  }
#line 319
  if (tmp___8) {
#line 320
    goto err_unreserve;
  } else {

  }
  {
#line 322
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
  }
  {
#line 324
  __cil_tmp379 = (unsigned long )box;
#line 324
  __cil_tmp380 = __cil_tmp379 + 12;
#line 324
  __cil_tmp381 = *((uint32 *)__cil_tmp380);
#line 324
  if (__cil_tmp381 == 64U) {
    {
#line 324
    __cil_tmp382 = 0 + 8;
#line 324
    __cil_tmp383 = 8 + __cil_tmp382;
#line 324
    __cil_tmp384 = (unsigned long )cmd;
#line 324
    __cil_tmp385 = __cil_tmp384 + __cil_tmp383;
#line 324
    __cil_tmp386 = *((uint32 *)__cil_tmp385);
#line 324
    if (__cil_tmp386 == 256U) {
#line 325
      __len = (size_t )16384;
#line 325
      if (__len >= 64UL) {
        {
#line 325
        __cil_tmp387 = 160 + 16;
#line 325
        __cil_tmp388 = (unsigned long )srf;
#line 325
        __cil_tmp389 = __cil_tmp388 + __cil_tmp387;
#line 325
        __cil_tmp390 = *((uint32_t **)__cil_tmp389);
#line 325
        __cil_tmp391 = (void *)__cil_tmp390;
#line 325
        __cil_tmp392 = (void    *)virtual;
#line 325
        __ret = __memcpy(__cil_tmp391, __cil_tmp392, __len);
        }
      } else {
        {
#line 325
        __cil_tmp393 = 160 + 16;
#line 325
        __cil_tmp394 = (unsigned long )srf;
#line 325
        __cil_tmp395 = __cil_tmp394 + __cil_tmp393;
#line 325
        __cil_tmp396 = *((uint32_t **)__cil_tmp395);
#line 325
        __cil_tmp397 = (void *)__cil_tmp396;
#line 325
        __cil_tmp398 = (void    *)virtual;
#line 325
        __ret = __builtin_memcpy(__cil_tmp397, __cil_tmp398, __len);
        }
      }
    } else {
#line 324
      goto _L;
    }
    }
  } else {
    _L: /* CIL Label */ 
#line 328
    i = 0;
    {
#line 328
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 328
      __cil_tmp399 = (unsigned long )box;
#line 328
      __cil_tmp400 = __cil_tmp399 + 16;
#line 328
      __cil_tmp401 = *((uint32 *)__cil_tmp400);
#line 328
      __cil_tmp402 = (uint32 )i;
#line 328
      if (__cil_tmp402 < __cil_tmp401) {

      } else {
#line 328
        goto while_break;
      }
      }
      {
#line 329
      __cil_tmp403 = (unsigned long )box;
#line 329
      __cil_tmp404 = __cil_tmp403 + 12;
#line 329
      __cil_tmp405 = *((uint32 *)__cil_tmp404);
#line 329
      __cil_tmp406 = __cil_tmp405 * 4U;
#line 329
      __len___0 = (size_t )__cil_tmp406;
#line 329
      __cil_tmp407 = i * 64;
#line 329
      __cil_tmp408 = 160 + 16;
#line 329
      __cil_tmp409 = (unsigned long )srf;
#line 329
      __cil_tmp410 = __cil_tmp409 + __cil_tmp408;
#line 329
      __cil_tmp411 = *((uint32_t **)__cil_tmp410);
#line 329
      __cil_tmp412 = __cil_tmp411 + __cil_tmp407;
#line 329
      __cil_tmp413 = (void *)__cil_tmp412;
#line 329
      __cil_tmp414 = 0 + 8;
#line 329
      __cil_tmp415 = 8 + __cil_tmp414;
#line 329
      __cil_tmp416 = (unsigned long )cmd;
#line 329
      __cil_tmp417 = __cil_tmp416 + __cil_tmp415;
#line 329
      __cil_tmp418 = *((uint32 *)__cil_tmp417);
#line 329
      __cil_tmp419 = (uint32 )i;
#line 329
      __cil_tmp420 = __cil_tmp419 * __cil_tmp418;
#line 329
      __cil_tmp421 = virtual + __cil_tmp420;
#line 329
      __cil_tmp422 = (void    *)__cil_tmp421;
#line 329
      __ret___0 = __builtin_memcpy(__cil_tmp413, __cil_tmp422, __len___0);
#line 328
      i = i + 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  }
  {
#line 334
  __cil_tmp423 = 160 + 8;
#line 334
  __cil_tmp424 = (unsigned long )srf;
#line 334
  __cil_tmp425 = __cil_tmp424 + __cil_tmp423;
#line 334
  __cil_tmp426 = 160 + 8;
#line 334
  __cil_tmp427 = (unsigned long )srf;
#line 334
  __cil_tmp428 = __cil_tmp427 + __cil_tmp426;
#line 334
  __cil_tmp429 = *((size_t *)__cil_tmp428);
#line 334
  *((size_t *)__cil_tmp425) = __cil_tmp429 + 1UL;
#line 345
  ttm_bo_kunmap(& map);
  }
  err_unreserve: 
  {
#line 347
  ttm_bo_unreserve(bo);
  }
#line 348
  return;
}
}
#line 350 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_crtc *crtc ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct drm_crtc    *__mptr___1 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct mutex *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  struct drm_crtc *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_display_unit *__cil_tmp33 ;
  struct drm_crtc *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct vmw_surface *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  size_t __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  size_t __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct vmw_surface *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct vmw_surface *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  uint32_t *__cil_tmp65 ;
  u32 __cil_tmp66 ;
  u32 __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int __cil_tmp70 ;
  u32 __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  u32 __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  struct drm_crtc *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct list_head *__cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct mutex *__cil_tmp88 ;

  {
  {
#line 352
  __cil_tmp8 = (unsigned long )dev_priv;
#line 352
  __cil_tmp9 = __cil_tmp8 + 2088;
#line 352
  dev = *((struct drm_device **)__cil_tmp9);
#line 356
  __cil_tmp10 = (unsigned long )dev;
#line 356
  __cil_tmp11 = __cil_tmp10 + 1152;
#line 356
  __cil_tmp12 = (struct mutex *)__cil_tmp11;
#line 356
  mutex_lock(__cil_tmp12);
#line 358
  __cil_tmp13 = 1152 + 296;
#line 358
  __cil_tmp14 = (unsigned long )dev;
#line 358
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
#line 358
  __cil_tmp16 = *((struct list_head **)__cil_tmp15);
#line 358
  __mptr = (struct list_head    *)__cil_tmp16;
#line 358
  __cil_tmp17 = (struct drm_crtc *)0;
#line 358
  __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 358
  __cil_tmp19 = __cil_tmp18 + 8;
#line 358
  __cil_tmp20 = (struct list_head *)__cil_tmp19;
#line 358
  __cil_tmp21 = (unsigned int )__cil_tmp20;
#line 358
  __cil_tmp22 = (char *)__mptr;
#line 358
  __cil_tmp23 = __cil_tmp22 - __cil_tmp21;
#line 358
  crtc = (struct drm_crtc *)__cil_tmp23;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    __cil_tmp24 = 1152 + 296;
#line 358
    __cil_tmp25 = (unsigned long )dev;
#line 358
    __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
#line 358
    __cil_tmp27 = (struct list_head *)__cil_tmp26;
#line 358
    __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 358
    __cil_tmp29 = (unsigned long )crtc;
#line 358
    __cil_tmp30 = __cil_tmp29 + 8;
#line 358
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
#line 358
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 358
    if (__cil_tmp32 != __cil_tmp28) {

    } else {
#line 358
      goto while_break;
    }
    }
#line 359
    __mptr___1 = (struct drm_crtc    *)crtc;
#line 359
    __cil_tmp33 = (struct vmw_display_unit *)0;
#line 359
    __cil_tmp34 = (struct drm_crtc *)__cil_tmp33;
#line 359
    __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 359
    __cil_tmp36 = (char *)__mptr___1;
#line 359
    __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
#line 359
    du = (struct vmw_display_unit *)__cil_tmp37;
    {
#line 360
    __cil_tmp38 = (unsigned long )du;
#line 360
    __cil_tmp39 = __cil_tmp38 + 1992;
#line 360
    __cil_tmp40 = *((struct vmw_surface **)__cil_tmp39);
#line 360
    if (! __cil_tmp40) {
#line 362
      goto __Cont;
    } else {
      {
#line 360
      __cil_tmp41 = 160 + 8;
#line 360
      __cil_tmp42 = (unsigned long )du;
#line 360
      __cil_tmp43 = __cil_tmp42 + 1992;
#line 360
      __cil_tmp44 = *((struct vmw_surface **)__cil_tmp43);
#line 360
      __cil_tmp45 = (unsigned long )__cil_tmp44;
#line 360
      __cil_tmp46 = __cil_tmp45 + __cil_tmp41;
#line 360
      __cil_tmp47 = *((size_t *)__cil_tmp46);
#line 360
      __cil_tmp48 = (unsigned long )du;
#line 360
      __cil_tmp49 = __cil_tmp48 + 2008;
#line 360
      __cil_tmp50 = *((size_t *)__cil_tmp49);
#line 360
      if (__cil_tmp50 == __cil_tmp47) {
#line 362
        goto __Cont;
      } else {

      }
      }
    }
    }
    {
#line 364
    __cil_tmp51 = (unsigned long )du;
#line 364
    __cil_tmp52 = __cil_tmp51 + 2008;
#line 364
    __cil_tmp53 = 160 + 8;
#line 364
    __cil_tmp54 = (unsigned long )du;
#line 364
    __cil_tmp55 = __cil_tmp54 + 1992;
#line 364
    __cil_tmp56 = *((struct vmw_surface **)__cil_tmp55);
#line 364
    __cil_tmp57 = (unsigned long )__cil_tmp56;
#line 364
    __cil_tmp58 = __cil_tmp57 + __cil_tmp53;
#line 364
    *((size_t *)__cil_tmp52) = *((size_t *)__cil_tmp58);
#line 365
    __cil_tmp59 = 160 + 16;
#line 365
    __cil_tmp60 = (unsigned long )du;
#line 365
    __cil_tmp61 = __cil_tmp60 + 1992;
#line 365
    __cil_tmp62 = *((struct vmw_surface **)__cil_tmp61);
#line 365
    __cil_tmp63 = (unsigned long )__cil_tmp62;
#line 365
    __cil_tmp64 = __cil_tmp63 + __cil_tmp59;
#line 365
    __cil_tmp65 = *((uint32_t **)__cil_tmp64);
#line 365
    __cil_tmp66 = (u32 )64;
#line 365
    __cil_tmp67 = (u32 )64;
#line 365
    __cil_tmp68 = (unsigned long )du;
#line 365
    __cil_tmp69 = __cil_tmp68 + 2024;
#line 365
    __cil_tmp70 = *((int *)__cil_tmp69);
#line 365
    __cil_tmp71 = (u32 )__cil_tmp70;
#line 365
    __cil_tmp72 = (unsigned long )du;
#line 365
    __cil_tmp73 = __cil_tmp72 + 2028;
#line 365
    __cil_tmp74 = *((int *)__cil_tmp73);
#line 365
    __cil_tmp75 = (u32 )__cil_tmp74;
#line 365
    vmw_cursor_update_image(dev_priv, __cil_tmp65, __cil_tmp66, __cil_tmp67, __cil_tmp71,
                            __cil_tmp75);
    }
    __Cont: /* CIL Label */ 
#line 358
    __cil_tmp76 = (unsigned long )crtc;
#line 358
    __cil_tmp77 = __cil_tmp76 + 8;
#line 358
    __cil_tmp78 = *((struct list_head **)__cil_tmp77);
#line 358
    __mptr___0 = (struct list_head    *)__cil_tmp78;
#line 358
    __cil_tmp79 = (struct drm_crtc *)0;
#line 358
    __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 358
    __cil_tmp81 = __cil_tmp80 + 8;
#line 358
    __cil_tmp82 = (struct list_head *)__cil_tmp81;
#line 358
    __cil_tmp83 = (unsigned int )__cil_tmp82;
#line 358
    __cil_tmp84 = (char *)__mptr___0;
#line 358
    __cil_tmp85 = __cil_tmp84 - __cil_tmp83;
#line 358
    crtc = (struct drm_crtc *)__cil_tmp85;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  __cil_tmp86 = (unsigned long )dev;
#line 370
  __cil_tmp87 = __cil_tmp86 + 1152;
#line 370
  __cil_tmp88 = (struct mutex *)__cil_tmp87;
#line 370
  mutex_unlock(__cil_tmp88);
  }
#line 371
  return;
}
}
#line 377 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                  unsigned int *handle ) 
{ 

  {
#line 381
  if (handle) {
#line 382
    *handle = 0U;
  } else {

  }
#line 384
  return (0);
}
}
#line 402 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer    *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  struct vmw_framebuffer_surface *__cil_tmp6 ;
  struct drm_framebuffer *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct drm_master *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct mutex *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct mutex *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct drm_master **__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct vmw_surface **__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_base_object **__cil_tmp32 ;
  void    *__cil_tmp33 ;

  {
  {
#line 405
  __mptr = (struct drm_framebuffer    *)framebuffer;
#line 405
  __cil_tmp6 = (struct vmw_framebuffer_surface *)0;
#line 405
  __cil_tmp7 = (struct drm_framebuffer *)__cil_tmp6;
#line 405
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 405
  __cil_tmp9 = (char *)__mptr;
#line 405
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 405
  vfbs = (struct vmw_framebuffer_surface *)__cil_tmp10;
#line 406
  __cil_tmp11 = (unsigned long )vfbs;
#line 406
  __cil_tmp12 = __cil_tmp11 + 192;
#line 406
  __cil_tmp13 = *((struct drm_master **)__cil_tmp12);
#line 406
  tmp___7 = vmw_master(__cil_tmp13);
#line 406
  vmaster = tmp___7;
#line 409
  __cil_tmp14 = (unsigned long )vmaster;
#line 409
  __cil_tmp15 = __cil_tmp14 + 152;
#line 409
  __cil_tmp16 = (struct mutex *)__cil_tmp15;
#line 409
  mutex_lock(__cil_tmp16);
#line 410
  __cil_tmp17 = (unsigned long )vfbs;
#line 410
  __cil_tmp18 = __cil_tmp17 + 176;
#line 410
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
#line 410
  list_del(__cil_tmp19);
#line 411
  __cil_tmp20 = (unsigned long )vmaster;
#line 411
  __cil_tmp21 = __cil_tmp20 + 152;
#line 411
  __cil_tmp22 = (struct mutex *)__cil_tmp21;
#line 411
  mutex_unlock(__cil_tmp22);
#line 413
  __cil_tmp23 = (unsigned long )vfbs;
#line 413
  __cil_tmp24 = __cil_tmp23 + 192;
#line 413
  __cil_tmp25 = (struct drm_master **)__cil_tmp24;
#line 413
  drm_master_put(__cil_tmp25);
#line 414
  drm_framebuffer_cleanup(framebuffer);
#line 415
  __cil_tmp26 = (unsigned long )vfbs;
#line 415
  __cil_tmp27 = __cil_tmp26 + 160;
#line 415
  __cil_tmp28 = (struct vmw_surface **)__cil_tmp27;
#line 415
  vmw_surface_unreference(__cil_tmp28);
#line 416
  __cil_tmp29 = 0 + 144;
#line 416
  __cil_tmp30 = (unsigned long )vfbs;
#line 416
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 416
  __cil_tmp32 = (struct ttm_base_object **)__cil_tmp31;
#line 416
  ttm_base_object_unref(__cil_tmp32);
#line 418
  __cil_tmp33 = (void    *)vfbs;
#line 418
  kfree(__cil_tmp33);
  }
#line 419
  return;
}
}
#line 421 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int do_surface_dirty_sou(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                struct vmw_framebuffer *framebuffer , unsigned int flags ,
                                unsigned int color , struct drm_clip_rect *clips ,
                                unsigned int num_clips , int inc , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *clips_ptr ;
  struct drm_clip_rect *tmp___7 ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_430 *cmd ;
  SVGASignedRect *blits ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int tmp___8 ;
  struct drm_crtc    *__mptr___1 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  int __min1 ;
  int __min2 ;
  int tmp___15 ;
  int __max1 ;
  int __max2 ;
  int tmp___16 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___17 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___18 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___19 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_device *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct list_head *__cil_tmp56 ;
  struct drm_crtc *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  struct drm_device *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct list_head *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  struct list_head *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct drm_framebuffer *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct drm_framebuffer *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct vmw_display_unit *__cil_tmp84 ;
  struct drm_crtc *__cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  struct list_head *__cil_tmp91 ;
  struct drm_crtc *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  struct list_head *__cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  void *__cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  void *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  struct __anonstruct_cmd_430 *__cil_tmp118 ;
  unsigned short __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned short __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned short __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned short __cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned short __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned short __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned short __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned short __cil_tmp139 ;
  void *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  size_t __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned int __cil_tmp160 ;
  struct drm_clip_rect *__cil_tmp161 ;
  unsigned short __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  struct drm_clip_rect *__cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned short __cil_tmp170 ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  struct drm_clip_rect *__cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned short __cil_tmp178 ;
  int __cil_tmp179 ;
  int __cil_tmp180 ;
  struct drm_clip_rect *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned short __cil_tmp186 ;
  int __cil_tmp187 ;
  int __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  int __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  int __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  int __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  int __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  int __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  int __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  int __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  int __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  int __cil_tmp251 ;
  int *__cil_tmp252 ;
  int __cil_tmp253 ;
  int *__cil_tmp254 ;
  int __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  size_t __cil_tmp261 ;
  void *__cil_tmp262 ;
  void *__cil_tmp263 ;
  uint32_t __cil_tmp264 ;
  uint64_t __cil_tmp265 ;
  void *__cil_tmp266 ;
  struct drm_vmw_fence_rep *__cil_tmp267 ;
  int __cil_tmp268 ;
  int __cil_tmp269 ;
  int __cil_tmp270 ;
  long __cil_tmp271 ;
  void    *__cil_tmp272 ;
  void    *__cil_tmp273 ;
  int clip_y2274 ;
  int clip_y1275 ;
  int clip_x2276 ;
  int clip_x1277 ;

  {
#line 435
  ret = 0;
#line 444
  num_units = 0;
#line 445
  __cil_tmp50 = 1152 + 296;
#line 445
  __cil_tmp51 = (unsigned long )dev_priv;
#line 445
  __cil_tmp52 = __cil_tmp51 + 2088;
#line 445
  __cil_tmp53 = *((struct drm_device **)__cil_tmp52);
#line 445
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 445
  __cil_tmp55 = __cil_tmp54 + __cil_tmp50;
#line 445
  __cil_tmp56 = *((struct list_head **)__cil_tmp55);
#line 445
  __mptr = (struct list_head    *)__cil_tmp56;
#line 445
  __cil_tmp57 = (struct drm_crtc *)0;
#line 445
  __cil_tmp58 = (unsigned long )__cil_tmp57;
#line 445
  __cil_tmp59 = __cil_tmp58 + 8;
#line 445
  __cil_tmp60 = (struct list_head *)__cil_tmp59;
#line 445
  __cil_tmp61 = (unsigned int )__cil_tmp60;
#line 445
  __cil_tmp62 = (char *)__mptr;
#line 445
  __cil_tmp63 = __cil_tmp62 - __cil_tmp61;
#line 445
  crtc = (struct drm_crtc *)__cil_tmp63;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 445
    __cil_tmp64 = 1152 + 296;
#line 445
    __cil_tmp65 = (unsigned long )dev_priv;
#line 445
    __cil_tmp66 = __cil_tmp65 + 2088;
#line 445
    __cil_tmp67 = *((struct drm_device **)__cil_tmp66);
#line 445
    __cil_tmp68 = (unsigned long )__cil_tmp67;
#line 445
    __cil_tmp69 = __cil_tmp68 + __cil_tmp64;
#line 445
    __cil_tmp70 = (struct list_head *)__cil_tmp69;
#line 445
    __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 445
    __cil_tmp72 = (unsigned long )crtc;
#line 445
    __cil_tmp73 = __cil_tmp72 + 8;
#line 445
    __cil_tmp74 = (struct list_head *)__cil_tmp73;
#line 445
    __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 445
    if (__cil_tmp75 != __cil_tmp71) {

    } else {
#line 445
      goto while_break;
    }
    }
    {
#line 447
    __cil_tmp76 = (struct drm_framebuffer *)framebuffer;
#line 447
    __cil_tmp77 = (unsigned long )__cil_tmp76;
#line 447
    __cil_tmp78 = (unsigned long )crtc;
#line 447
    __cil_tmp79 = __cil_tmp78 + 32;
#line 447
    __cil_tmp80 = *((struct drm_framebuffer **)__cil_tmp79);
#line 447
    __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 447
    if (__cil_tmp81 != __cil_tmp77) {
#line 448
      goto __Cont;
    } else {

    }
    }
#line 449
    tmp___8 = num_units;
#line 449
    num_units = num_units + 1;
#line 449
    __mptr___1 = (struct drm_crtc    *)crtc;
#line 449
    __cil_tmp82 = tmp___8 * 8UL;
#line 449
    __cil_tmp83 = (unsigned long )(units) + __cil_tmp82;
#line 449
    __cil_tmp84 = (struct vmw_display_unit *)0;
#line 449
    __cil_tmp85 = (struct drm_crtc *)__cil_tmp84;
#line 449
    __cil_tmp86 = (unsigned int )__cil_tmp85;
#line 449
    __cil_tmp87 = (char *)__mptr___1;
#line 449
    __cil_tmp88 = __cil_tmp87 - __cil_tmp86;
#line 449
    *((struct vmw_display_unit **)__cil_tmp83) = (struct vmw_display_unit *)__cil_tmp88;
    __Cont: /* CIL Label */ 
#line 445
    __cil_tmp89 = (unsigned long )crtc;
#line 445
    __cil_tmp90 = __cil_tmp89 + 8;
#line 445
    __cil_tmp91 = *((struct list_head **)__cil_tmp90);
#line 445
    __mptr___0 = (struct list_head    *)__cil_tmp91;
#line 445
    __cil_tmp92 = (struct drm_crtc *)0;
#line 445
    __cil_tmp93 = (unsigned long )__cil_tmp92;
#line 445
    __cil_tmp94 = __cil_tmp93 + 8;
#line 445
    __cil_tmp95 = (struct list_head *)__cil_tmp94;
#line 445
    __cil_tmp96 = (unsigned int )__cil_tmp95;
#line 445
    __cil_tmp97 = (char *)__mptr___0;
#line 445
    __cil_tmp98 = __cil_tmp97 - __cil_tmp96;
#line 445
    crtc = (struct drm_crtc *)__cil_tmp98;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 452
    if (! clips) {
#line 452
      tmp___9 = 1;
    } else
#line 452
    if (! num_clips) {
#line 452
      tmp___9 = 1;
    } else {
#line 452
      tmp___9 = 0;
    }
    {
#line 452
    __cil_tmp99 = (long )tmp___9;
#line 452
    tmp___10 = ldv__builtin_expect(__cil_tmp99, 0L);
    }
#line 452
    if (tmp___10) {
      {
#line 452
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 452
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (452), "i" (12UL));
        {
#line 452
        while (1) {
          while_continue___2: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 452
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 452
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 454
  __cil_tmp100 = (unsigned long )num_clips;
#line 454
  __cil_tmp101 = 8UL * __cil_tmp100;
#line 454
  tmp___11 = kzalloc(__cil_tmp101, 208U);
#line 454
  tmp___7 = (struct drm_clip_rect *)tmp___11;
#line 455
  __cil_tmp102 = (void *)0;
#line 455
  __cil_tmp103 = (unsigned long )__cil_tmp102;
#line 455
  __cil_tmp104 = (unsigned long )tmp___7;
#line 455
  __cil_tmp105 = __cil_tmp104 == __cil_tmp103;
#line 455
  __cil_tmp106 = ! __cil_tmp105;
#line 455
  __cil_tmp107 = ! __cil_tmp106;
#line 455
  __cil_tmp108 = (long )__cil_tmp107;
#line 455
  tmp___12 = ldv__builtin_expect(__cil_tmp108, 0L);
  }
#line 455
  if (tmp___12) {
    {
#line 456
    drm_err("do_surface_dirty_sou", "Temporary cliprect memory alloc failed.\n");
    }
#line 457
    return (-12);
  } else {

  }
  {
#line 460
  __cil_tmp109 = (unsigned long )num_clips;
#line 460
  __cil_tmp110 = 16UL * __cil_tmp109;
#line 460
  fifo_size = 56UL + __cil_tmp110;
#line 461
  tmp___13 = kzalloc(fifo_size, 208U);
#line 461
  cmd = (struct __anonstruct_cmd_430 *)tmp___13;
#line 462
  __cil_tmp111 = (void *)0;
#line 462
  __cil_tmp112 = (unsigned long )__cil_tmp111;
#line 462
  __cil_tmp113 = (unsigned long )cmd;
#line 462
  __cil_tmp114 = __cil_tmp113 == __cil_tmp112;
#line 462
  __cil_tmp115 = ! __cil_tmp114;
#line 462
  __cil_tmp116 = ! __cil_tmp115;
#line 462
  __cil_tmp117 = (long )__cil_tmp116;
#line 462
  tmp___14 = ldv__builtin_expect(__cil_tmp117, 0L);
  }
#line 462
  if (tmp___14) {
    {
#line 463
    drm_err("do_surface_dirty_sou", "Temporary fifo memory alloc failed.\n");
#line 464
    ret = -12;
    }
#line 465
    goto out_free_tmp;
  } else {

  }
#line 469
  __cil_tmp118 = cmd + 1;
#line 469
  blits = (SVGASignedRect *)__cil_tmp118;
#line 472
  __cil_tmp119 = *((unsigned short *)clips);
#line 472
  left = (int )__cil_tmp119;
#line 473
  __cil_tmp120 = (unsigned long )clips;
#line 473
  __cil_tmp121 = __cil_tmp120 + 4;
#line 473
  __cil_tmp122 = *((unsigned short *)__cil_tmp121);
#line 473
  right = (int )__cil_tmp122;
#line 474
  __cil_tmp123 = (unsigned long )clips;
#line 474
  __cil_tmp124 = __cil_tmp123 + 2;
#line 474
  __cil_tmp125 = *((unsigned short *)__cil_tmp124);
#line 474
  top = (int )__cil_tmp125;
#line 475
  __cil_tmp126 = (unsigned long )clips;
#line 475
  __cil_tmp127 = __cil_tmp126 + 6;
#line 475
  __cil_tmp128 = *((unsigned short *)__cil_tmp127);
#line 475
  bottom = (int )__cil_tmp128;
#line 478
  i = 1;
#line 478
  clips_ptr = clips + inc;
  {
#line 478
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 478
    __cil_tmp129 = (unsigned int )i;
#line 478
    if (__cil_tmp129 < num_clips) {

    } else {
#line 478
      goto while_break___3;
    }
    }
#line 480
    __min1 = left;
#line 480
    __cil_tmp130 = *((unsigned short *)clips_ptr);
#line 480
    __min2 = (int )__cil_tmp130;
#line 480
    if (__min1 < __min2) {
#line 480
      tmp___15 = __min1;
    } else {
#line 480
      tmp___15 = __min2;
    }
#line 480
    left = tmp___15;
#line 481
    __max1 = right;
#line 481
    __cil_tmp131 = (unsigned long )clips_ptr;
#line 481
    __cil_tmp132 = __cil_tmp131 + 4;
#line 481
    __cil_tmp133 = *((unsigned short *)__cil_tmp132);
#line 481
    __max2 = (int )__cil_tmp133;
#line 481
    if (__max1 > __max2) {
#line 481
      tmp___16 = __max1;
    } else {
#line 481
      tmp___16 = __max2;
    }
#line 481
    right = tmp___16;
#line 482
    __min1___0 = top;
#line 482
    __cil_tmp134 = (unsigned long )clips_ptr;
#line 482
    __cil_tmp135 = __cil_tmp134 + 2;
#line 482
    __cil_tmp136 = *((unsigned short *)__cil_tmp135);
#line 482
    __min2___0 = (int )__cil_tmp136;
#line 482
    if (__min1___0 < __min2___0) {
#line 482
      tmp___17 = __min1___0;
    } else {
#line 482
      tmp___17 = __min2___0;
    }
#line 482
    top = tmp___17;
#line 483
    __max1___0 = bottom;
#line 483
    __cil_tmp137 = (unsigned long )clips_ptr;
#line 483
    __cil_tmp138 = __cil_tmp137 + 6;
#line 483
    __cil_tmp139 = *((unsigned short *)__cil_tmp138);
#line 483
    __max2___0 = (int )__cil_tmp139;
#line 483
    if (__max1___0 > __max2___0) {
#line 483
      tmp___18 = __max1___0;
    } else {
#line 483
      tmp___18 = __max2___0;
    }
#line 483
    bottom = tmp___18;
#line 478
    i = i + 1;
#line 478
    clips_ptr = clips_ptr + inc;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 487
  __cil_tmp140 = (void *)cmd;
#line 487
  memset(__cil_tmp140, 0, fifo_size);
#line 488
  *((uint32 *)cmd) = (__u32 )1069;
#line 489
  __cil_tmp141 = 0 + 4;
#line 489
  __cil_tmp142 = (unsigned long )cmd;
#line 489
  __cil_tmp143 = __cil_tmp142 + __cil_tmp141;
#line 489
  __cil_tmp144 = fifo_size - 8UL;
#line 489
  *((uint32 *)__cil_tmp143) = (__u32 )__cil_tmp144;
#line 491
  __cil_tmp145 = 8 + 12;
#line 491
  __cil_tmp146 = (unsigned long )cmd;
#line 491
  __cil_tmp147 = __cil_tmp146 + __cil_tmp145;
#line 491
  *((int32 *)__cil_tmp147) = left;
#line 492
  __cil_tmp148 = 12 + 8;
#line 492
  __cil_tmp149 = 8 + __cil_tmp148;
#line 492
  __cil_tmp150 = (unsigned long )cmd;
#line 492
  __cil_tmp151 = __cil_tmp150 + __cil_tmp149;
#line 492
  *((int32 *)__cil_tmp151) = right;
#line 493
  __cil_tmp152 = 12 + 4;
#line 493
  __cil_tmp153 = 8 + __cil_tmp152;
#line 493
  __cil_tmp154 = (unsigned long )cmd;
#line 493
  __cil_tmp155 = __cil_tmp154 + __cil_tmp153;
#line 493
  *((int32 *)__cil_tmp155) = top;
#line 494
  __cil_tmp156 = 12 + 12;
#line 494
  __cil_tmp157 = 8 + __cil_tmp156;
#line 494
  __cil_tmp158 = (unsigned long )cmd;
#line 494
  __cil_tmp159 = __cil_tmp158 + __cil_tmp157;
#line 494
  *((int32 *)__cil_tmp159) = bottom;
#line 496
  clips_ptr = clips;
#line 497
  i = 0;
  }
  {
#line 497
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 497
    __cil_tmp160 = (unsigned int )i;
#line 497
    if (__cil_tmp160 < num_clips) {

    } else {
#line 497
      goto while_break___4;
    }
    }
#line 498
    __cil_tmp161 = tmp___7 + i;
#line 498
    __cil_tmp162 = *((unsigned short *)clips_ptr);
#line 498
    __cil_tmp163 = (int )__cil_tmp162;
#line 498
    __cil_tmp164 = __cil_tmp163 - left;
#line 498
    *((unsigned short *)__cil_tmp161) = (unsigned short )__cil_tmp164;
#line 499
    __cil_tmp165 = tmp___7 + i;
#line 499
    __cil_tmp166 = (unsigned long )__cil_tmp165;
#line 499
    __cil_tmp167 = __cil_tmp166 + 4;
#line 499
    __cil_tmp168 = (unsigned long )clips_ptr;
#line 499
    __cil_tmp169 = __cil_tmp168 + 4;
#line 499
    __cil_tmp170 = *((unsigned short *)__cil_tmp169);
#line 499
    __cil_tmp171 = (int )__cil_tmp170;
#line 499
    __cil_tmp172 = __cil_tmp171 - left;
#line 499
    *((unsigned short *)__cil_tmp167) = (unsigned short )__cil_tmp172;
#line 500
    __cil_tmp173 = tmp___7 + i;
#line 500
    __cil_tmp174 = (unsigned long )__cil_tmp173;
#line 500
    __cil_tmp175 = __cil_tmp174 + 2;
#line 500
    __cil_tmp176 = (unsigned long )clips_ptr;
#line 500
    __cil_tmp177 = __cil_tmp176 + 2;
#line 500
    __cil_tmp178 = *((unsigned short *)__cil_tmp177);
#line 500
    __cil_tmp179 = (int )__cil_tmp178;
#line 500
    __cil_tmp180 = __cil_tmp179 - top;
#line 500
    *((unsigned short *)__cil_tmp175) = (unsigned short )__cil_tmp180;
#line 501
    __cil_tmp181 = tmp___7 + i;
#line 501
    __cil_tmp182 = (unsigned long )__cil_tmp181;
#line 501
    __cil_tmp183 = __cil_tmp182 + 6;
#line 501
    __cil_tmp184 = (unsigned long )clips_ptr;
#line 501
    __cil_tmp185 = __cil_tmp184 + 6;
#line 501
    __cil_tmp186 = *((unsigned short *)__cil_tmp185);
#line 501
    __cil_tmp187 = (int )__cil_tmp186;
#line 501
    __cil_tmp188 = __cil_tmp187 - top;
#line 501
    *((unsigned short *)__cil_tmp183) = (unsigned short )__cil_tmp188;
#line 497
    i = i + 1;
#line 497
    clips_ptr = clips_ptr + inc;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 505
  i = 0;
  {
#line 505
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 505
    if (i < num_units) {

    } else {
#line 505
      goto while_break___5;
    }
#line 506
    __cil_tmp189 = i * 8UL;
#line 506
    __cil_tmp190 = (unsigned long )(units) + __cil_tmp189;
#line 506
    unit = *((struct vmw_display_unit **)__cil_tmp190);
#line 510
    __cil_tmp191 = 0 + 480;
#line 510
    __cil_tmp192 = (unsigned long )unit;
#line 510
    __cil_tmp193 = __cil_tmp192 + __cil_tmp191;
#line 510
    __cil_tmp194 = *((int *)__cil_tmp193);
#line 510
    clip_x1277 = left - __cil_tmp194;
#line 511
    __cil_tmp195 = 0 + 484;
#line 511
    __cil_tmp196 = (unsigned long )unit;
#line 511
    __cil_tmp197 = __cil_tmp196 + __cil_tmp195;
#line 511
    __cil_tmp198 = *((int *)__cil_tmp197);
#line 511
    clip_y1275 = top - __cil_tmp198;
#line 512
    __cil_tmp199 = 0 + 480;
#line 512
    __cil_tmp200 = (unsigned long )unit;
#line 512
    __cil_tmp201 = __cil_tmp200 + __cil_tmp199;
#line 512
    __cil_tmp202 = *((int *)__cil_tmp201);
#line 512
    clip_x2276 = right - __cil_tmp202;
#line 513
    __cil_tmp203 = 0 + 484;
#line 513
    __cil_tmp204 = (unsigned long )unit;
#line 513
    __cil_tmp205 = __cil_tmp204 + __cil_tmp203;
#line 513
    __cil_tmp206 = *((int *)__cil_tmp205);
#line 513
    clip_y2274 = bottom - __cil_tmp206;
    {
#line 516
    __cil_tmp207 = 48 + 68;
#line 516
    __cil_tmp208 = 0 + __cil_tmp207;
#line 516
    __cil_tmp209 = (unsigned long )unit;
#line 516
    __cil_tmp210 = __cil_tmp209 + __cil_tmp208;
#line 516
    __cil_tmp211 = *((int *)__cil_tmp210);
#line 516
    if (clip_x1277 >= __cil_tmp211) {
#line 519
      goto __Cont___0;
    } else {
      {
#line 516
      __cil_tmp212 = 48 + 88;
#line 516
      __cil_tmp213 = 0 + __cil_tmp212;
#line 516
      __cil_tmp214 = (unsigned long )unit;
#line 516
      __cil_tmp215 = __cil_tmp214 + __cil_tmp213;
#line 516
      __cil_tmp216 = *((int *)__cil_tmp215);
#line 516
      if (clip_y1275 >= __cil_tmp216) {
#line 519
        goto __Cont___0;
      } else
#line 516
      if (clip_x2276 <= 0) {
#line 519
        goto __Cont___0;
      } else
#line 516
      if (clip_y2274 <= 0) {
#line 519
        goto __Cont___0;
      } else {

      }
      }
    }
    }
    {
#line 525
    __cil_tmp217 = 8 + 32;
#line 525
    __cil_tmp218 = (unsigned long )cmd;
#line 525
    __cil_tmp219 = __cil_tmp218 + __cil_tmp217;
#line 525
    *((int32 *)__cil_tmp219) = clip_x1277;
#line 526
    __cil_tmp220 = 32 + 8;
#line 526
    __cil_tmp221 = 8 + __cil_tmp220;
#line 526
    __cil_tmp222 = (unsigned long )cmd;
#line 526
    __cil_tmp223 = __cil_tmp222 + __cil_tmp221;
#line 526
    *((int32 *)__cil_tmp223) = clip_x2276;
#line 527
    __cil_tmp224 = 32 + 4;
#line 527
    __cil_tmp225 = 8 + __cil_tmp224;
#line 527
    __cil_tmp226 = (unsigned long )cmd;
#line 527
    __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
#line 527
    *((int32 *)__cil_tmp227) = clip_y1275;
#line 528
    __cil_tmp228 = 32 + 12;
#line 528
    __cil_tmp229 = 8 + __cil_tmp228;
#line 528
    __cil_tmp230 = (unsigned long )cmd;
#line 528
    __cil_tmp231 = __cil_tmp230 + __cil_tmp229;
#line 528
    *((int32 *)__cil_tmp231) = clip_y2274;
#line 531
    __cil_tmp232 = 48 + 68;
#line 531
    __cil_tmp233 = 0 + __cil_tmp232;
#line 531
    __cil_tmp234 = (unsigned long )unit;
#line 531
    __cil_tmp235 = __cil_tmp234 + __cil_tmp233;
#line 531
    __cil_tmp236 = *((int *)__cil_tmp235);
#line 531
    clip_x2276 = __cil_tmp236 - clip_x1277;
#line 532
    __cil_tmp237 = 48 + 88;
#line 532
    __cil_tmp238 = 0 + __cil_tmp237;
#line 532
    __cil_tmp239 = (unsigned long )unit;
#line 532
    __cil_tmp240 = __cil_tmp239 + __cil_tmp238;
#line 532
    __cil_tmp241 = *((int *)__cil_tmp240);
#line 532
    clip_y2274 = __cil_tmp241 - clip_y1275;
#line 533
    clip_x1277 = 0 - clip_x1277;
#line 534
    clip_y1275 = 0 - clip_y1275;
#line 537
    __cil_tmp242 = (unsigned long )cmd;
#line 537
    __cil_tmp243 = __cil_tmp242 + 8;
#line 537
    __cil_tmp244 = (unsigned long )framebuffer;
#line 537
    __cil_tmp245 = __cil_tmp244 + 152;
#line 537
    *((uint32 *)__cil_tmp243) = *((uint32_t *)__cil_tmp245);
#line 538
    __cil_tmp246 = 8 + 28;
#line 538
    __cil_tmp247 = (unsigned long )cmd;
#line 538
    __cil_tmp248 = __cil_tmp247 + __cil_tmp246;
#line 538
    __cil_tmp249 = (unsigned long )unit;
#line 538
    __cil_tmp250 = __cil_tmp249 + 2032;
#line 538
    *((uint32 *)__cil_tmp248) = *((unsigned int *)__cil_tmp250);
#line 541
    __cil_tmp251 = (int )num_clips;
#line 541
    vmw_clip_cliprects(tmp___7, __cil_tmp251, clip_x1277, clip_x2276, clip_y1275,
                       clip_y2274, blits, & num);
    }
    {
#line 544
    __cil_tmp252 = & num;
#line 544
    __cil_tmp253 = *__cil_tmp252;
#line 544
    if (__cil_tmp253 == 0) {
#line 545
      goto __Cont___0;
    } else {

    }
    }
#line 548
    if (out_fence) {
#line 548
      if (*out_fence) {
        {
#line 549
        vmw_fence_obj_unreference(out_fence);
        }
      } else {

      }
    } else {

    }
    {
#line 552
    __cil_tmp254 = & num;
#line 552
    __cil_tmp255 = *__cil_tmp254;
#line 552
    __cil_tmp256 = (unsigned long )__cil_tmp255;
#line 552
    __cil_tmp257 = 16UL * __cil_tmp256;
#line 552
    fifo_size = 56UL + __cil_tmp257;
#line 553
    __cil_tmp258 = 0 + 4;
#line 553
    __cil_tmp259 = (unsigned long )cmd;
#line 553
    __cil_tmp260 = __cil_tmp259 + __cil_tmp258;
#line 553
    __cil_tmp261 = fifo_size - 8UL;
#line 553
    *((uint32 *)__cil_tmp260) = (__u32 )__cil_tmp261;
#line 554
    __cil_tmp262 = (void *)0;
#line 554
    __cil_tmp263 = (void *)cmd;
#line 554
    __cil_tmp264 = (uint32_t )fifo_size;
#line 554
    __cil_tmp265 = (uint64_t )0;
#line 554
    __cil_tmp266 = (void *)0;
#line 554
    __cil_tmp267 = (struct drm_vmw_fence_rep *)__cil_tmp266;
#line 554
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp262, __cil_tmp263, __cil_tmp264,
                              __cil_tmp265, __cil_tmp267, out_fence);
#line 557
    __cil_tmp268 = ret != 0;
#line 557
    __cil_tmp269 = ! __cil_tmp268;
#line 557
    __cil_tmp270 = ! __cil_tmp269;
#line 557
    __cil_tmp271 = (long )__cil_tmp270;
#line 557
    tmp___19 = ldv__builtin_expect(__cil_tmp271, 0L);
    }
#line 557
    if (tmp___19) {
#line 558
      goto while_break___5;
    } else {

    }
    __Cont___0: /* CIL Label */ 
#line 505
    i = i + 1;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 562
  __cil_tmp272 = (void    *)cmd;
#line 562
  kfree(__cil_tmp272);
  }
  out_free_tmp: 
  {
#line 564
  __cil_tmp273 = (void    *)tmp___7;
#line 564
  kfree(__cil_tmp273);
  }
#line 566
  return (ret);
}
}
#line 569 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                  unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                  unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer    *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int inc ;
  long tmp___9 ;
  long tmp___10 ;
  struct drm_device *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct drm_master *__cil_tmp21 ;
  struct vmw_framebuffer_surface *__cil_tmp22 ;
  struct drm_framebuffer *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct drm_master *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct vmw_screen_object_display *__cil_tmp41 ;
  struct ttm_lock *__cil_tmp42 ;
  bool __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct drm_clip_rect *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  struct vmw_framebuffer *__cil_tmp59 ;
  void *__cil_tmp60 ;
  struct vmw_fence_obj **__cil_tmp61 ;
  struct ttm_lock *__cil_tmp62 ;

  {
  {
#line 575
  __cil_tmp18 = *((struct drm_device **)framebuffer);
#line 575
  tmp___7 = vmw_priv(__cil_tmp18);
#line 575
  dev_priv = tmp___7;
#line 576
  __cil_tmp19 = (unsigned long )file_priv;
#line 576
  __cil_tmp20 = __cil_tmp19 + 152;
#line 576
  __cil_tmp21 = *((struct drm_master **)__cil_tmp20);
#line 576
  tmp___8 = vmw_master(__cil_tmp21);
#line 576
  vmaster = tmp___8;
#line 578
  __mptr = (struct drm_framebuffer    *)framebuffer;
#line 578
  __cil_tmp22 = (struct vmw_framebuffer_surface *)0;
#line 578
  __cil_tmp23 = (struct drm_framebuffer *)__cil_tmp22;
#line 578
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 578
  __cil_tmp25 = (char *)__mptr;
#line 578
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 578
  vfbs = (struct vmw_framebuffer_surface *)__cil_tmp26;
#line 580
  inc = 1;
#line 582
  __cil_tmp27 = (unsigned long )file_priv;
#line 582
  __cil_tmp28 = __cil_tmp27 + 152;
#line 582
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
#line 582
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 582
  __cil_tmp31 = (unsigned long )vfbs;
#line 582
  __cil_tmp32 = __cil_tmp31 + 192;
#line 582
  __cil_tmp33 = *((struct drm_master **)__cil_tmp32);
#line 582
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 582
  __cil_tmp35 = __cil_tmp34 != __cil_tmp30;
#line 582
  __cil_tmp36 = ! __cil_tmp35;
#line 582
  __cil_tmp37 = ! __cil_tmp36;
#line 582
  __cil_tmp38 = (long )__cil_tmp37;
#line 582
  tmp___9 = ldv__builtin_expect(__cil_tmp38, 0L);
  }
#line 582
  if (tmp___9) {
#line 583
    return (-22);
  } else {

  }
  {
#line 586
  __cil_tmp39 = (unsigned long )dev_priv;
#line 586
  __cil_tmp40 = __cil_tmp39 + 2616;
#line 586
  __cil_tmp41 = *((struct vmw_screen_object_display **)__cil_tmp40);
#line 586
  if (! __cil_tmp41) {
#line 587
    return (-22);
  } else {

  }
  }
  {
#line 589
  __cil_tmp42 = (struct ttm_lock *)vmaster;
#line 589
  __cil_tmp43 = (bool )1;
#line 589
  ret = ttm_read_lock(__cil_tmp42, __cil_tmp43);
#line 590
  __cil_tmp44 = ret != 0;
#line 590
  __cil_tmp45 = ! __cil_tmp44;
#line 590
  __cil_tmp46 = ! __cil_tmp45;
#line 590
  __cil_tmp47 = (long )__cil_tmp46;
#line 590
  tmp___10 = ldv__builtin_expect(__cil_tmp47, 0L);
  }
#line 590
  if (tmp___10) {
#line 591
    return (ret);
  } else {

  }
#line 593
  if (! num_clips) {
#line 594
    num_clips = 1U;
#line 595
    clips = & norect;
#line 596
    __cil_tmp48 = (unsigned long )(& norect) + 2;
#line 596
    *((unsigned short *)__cil_tmp48) = (unsigned short)0;
#line 596
    __cil_tmp49 = & norect;
#line 596
    __cil_tmp50 = (unsigned long )(& norect) + 2;
#line 596
    *((unsigned short *)__cil_tmp49) = *((unsigned short *)__cil_tmp50);
#line 597
    __cil_tmp51 = (unsigned long )(& norect) + 4;
#line 597
    __cil_tmp52 = (unsigned long )framebuffer;
#line 597
    __cil_tmp53 = __cil_tmp52 + 72;
#line 597
    __cil_tmp54 = *((unsigned int *)__cil_tmp53);
#line 597
    *((unsigned short *)__cil_tmp51) = (unsigned short )__cil_tmp54;
#line 598
    __cil_tmp55 = (unsigned long )(& norect) + 6;
#line 598
    __cil_tmp56 = (unsigned long )framebuffer;
#line 598
    __cil_tmp57 = __cil_tmp56 + 76;
#line 598
    __cil_tmp58 = *((unsigned int *)__cil_tmp57);
#line 598
    *((unsigned short *)__cil_tmp55) = (unsigned short )__cil_tmp58;
  } else
#line 599
  if (flags & 1U) {
#line 600
    num_clips = num_clips / 2U;
#line 601
    inc = 2;
  } else {

  }
  {
#line 604
  __cil_tmp59 = (struct vmw_framebuffer *)vfbs;
#line 604
  __cil_tmp60 = (void *)0;
#line 604
  __cil_tmp61 = (struct vmw_fence_obj **)__cil_tmp60;
#line 604
  ret = do_surface_dirty_sou(dev_priv, file_priv, __cil_tmp59, flags, color, clips,
                             num_clips, inc, __cil_tmp61);
#line 608
  __cil_tmp62 = (struct ttm_lock *)vmaster;
#line 608
  ttm_read_unlock(__cil_tmp62);
  }
#line 609
  return (0);
}
}
#line 612 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs  =    {& vmw_framebuffer_surface_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_surface_dirty};
#line 618 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                           struct vmw_surface *surface , struct vmw_framebuffer **out ,
                                           struct drm_mode_fb_cmd    *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_surface *vfbs ;
  enum SVGA3dSurfaceFormat format ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  int ret ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  struct vmw_surface *tmp___13 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_master *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_screen_object_display *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  bool __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  __u32    __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_vmw_size *__cil_tmp47 ;
  struct drm_vmw_size *__cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  __u32    __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct drm_vmw_size *__cil_tmp56 ;
  struct drm_vmw_size *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32_t __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_vmw_size *__cil_tmp63 ;
  struct drm_vmw_size *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  uint32_t __cil_tmp67 ;
  long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  __u32    __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  __u32    __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  uint32_t __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct drm_framebuffer *__cil_tmp83 ;
  struct drm_framebuffer_funcs    *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  __u32    __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  __u32    __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  __u32    __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  __u32    __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  __u32    __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  __u32    __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  struct drm_master *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  struct mutex *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct list_head *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  struct list_head *__cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  struct mutex *__cil_tmp146 ;
  struct drm_framebuffer *__cil_tmp147 ;
  void    *__cil_tmp148 ;

  {
  {
#line 626
  __cil_tmp18 = (unsigned long )dev_priv;
#line 626
  __cil_tmp19 = __cil_tmp18 + 2088;
#line 626
  dev = *((struct drm_device **)__cil_tmp19);
#line 629
  __cil_tmp20 = (unsigned long )file_priv;
#line 629
  __cil_tmp21 = __cil_tmp20 + 152;
#line 629
  __cil_tmp22 = *((struct drm_master **)__cil_tmp21);
#line 629
  tmp___7 = vmw_master(__cil_tmp22);
#line 629
  vmaster = tmp___7;
  }
  {
#line 633
  __cil_tmp23 = (unsigned long )dev_priv;
#line 633
  __cil_tmp24 = __cil_tmp23 + 2616;
#line 633
  __cil_tmp25 = *((struct vmw_screen_object_display **)__cil_tmp24);
#line 633
  if (! __cil_tmp25) {
#line 634
    return (-38);
  } else {

  }
  }
  {
#line 641
  __cil_tmp26 = (unsigned long )surface;
#line 641
  __cil_tmp27 = __cil_tmp26 + 156;
#line 641
  __cil_tmp28 = *((bool *)__cil_tmp27);
#line 641
  __cil_tmp29 = ! __cil_tmp28;
#line 641
  __cil_tmp30 = ! __cil_tmp29;
#line 641
  __cil_tmp31 = ! __cil_tmp30;
#line 641
  __cil_tmp32 = (long )__cil_tmp31;
#line 641
  tmp___8 = ldv__builtin_expect(__cil_tmp32, 0L);
  }
#line 641
  if (tmp___8) {
#line 642
    return (-22);
  } else {

  }
  {
#line 644
  __cil_tmp33 = 0 * 4UL;
#line 644
  __cil_tmp34 = 120 + __cil_tmp33;
#line 644
  __cil_tmp35 = (unsigned long )surface;
#line 644
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
#line 644
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 644
  if (__cil_tmp37 != 1U) {
#line 644
    tmp___9 = 1;
  } else {
    {
#line 644
    __cil_tmp38 = (unsigned long )surface;
#line 644
    __cil_tmp39 = __cil_tmp38 + 152;
#line 644
    __cil_tmp40 = *((uint32_t *)__cil_tmp39);
#line 644
    if (__cil_tmp40 != 1U) {
#line 644
      tmp___9 = 1;
    } else {
      {
#line 644
      __cil_tmp41 = (unsigned long )mode_cmd;
#line 644
      __cil_tmp42 = __cil_tmp41 + 4;
#line 644
      __cil_tmp43 = *((__u32    *)__cil_tmp42);
#line 644
      __cil_tmp44 = (uint32_t )__cil_tmp43;
#line 644
      __cil_tmp45 = (unsigned long )surface;
#line 644
      __cil_tmp46 = __cil_tmp45 + 144;
#line 644
      __cil_tmp47 = *((struct drm_vmw_size **)__cil_tmp46);
#line 644
      __cil_tmp48 = __cil_tmp47 + 0;
#line 644
      __cil_tmp49 = *((uint32_t *)__cil_tmp48);
#line 644
      if (__cil_tmp49 < __cil_tmp44) {
#line 644
        tmp___9 = 1;
      } else {
        {
#line 644
        __cil_tmp50 = (unsigned long )mode_cmd;
#line 644
        __cil_tmp51 = __cil_tmp50 + 8;
#line 644
        __cil_tmp52 = *((__u32    *)__cil_tmp51);
#line 644
        __cil_tmp53 = (uint32_t )__cil_tmp52;
#line 644
        __cil_tmp54 = (unsigned long )surface;
#line 644
        __cil_tmp55 = __cil_tmp54 + 144;
#line 644
        __cil_tmp56 = *((struct drm_vmw_size **)__cil_tmp55);
#line 644
        __cil_tmp57 = __cil_tmp56 + 0;
#line 644
        __cil_tmp58 = (unsigned long )__cil_tmp57;
#line 644
        __cil_tmp59 = __cil_tmp58 + 4;
#line 644
        __cil_tmp60 = *((uint32_t *)__cil_tmp59);
#line 644
        if (__cil_tmp60 < __cil_tmp53) {
#line 644
          tmp___9 = 1;
        } else {
          {
#line 644
          __cil_tmp61 = (unsigned long )surface;
#line 644
          __cil_tmp62 = __cil_tmp61 + 144;
#line 644
          __cil_tmp63 = *((struct drm_vmw_size **)__cil_tmp62);
#line 644
          __cil_tmp64 = __cil_tmp63 + 0;
#line 644
          __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 644
          __cil_tmp66 = __cil_tmp65 + 8;
#line 644
          __cil_tmp67 = *((uint32_t *)__cil_tmp66);
#line 644
          if (__cil_tmp67 != 1U) {
#line 644
            tmp___9 = 1;
          } else {
#line 644
            tmp___9 = 0;
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
  {
#line 644
  __cil_tmp68 = (long )tmp___9;
#line 644
  tmp___10 = ldv__builtin_expect(__cil_tmp68, 0L);
  }
#line 644
  if (tmp___10) {
    {
#line 649
    drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
    }
#line 651
    return (-22);
  } else {

  }
  {
#line 654
  __cil_tmp69 = (unsigned long )mode_cmd;
#line 654
  __cil_tmp70 = __cil_tmp69 + 20;
#line 654
  __cil_tmp71 = *((__u32    *)__cil_tmp70);
#line 655
  if ((int )__cil_tmp71 == 32) {
#line 655
    goto case_32;
  } else
#line 658
  if ((int )__cil_tmp71 == 24) {
#line 658
    goto case_24;
  } else
#line 661
  if ((int )__cil_tmp71 == 16) {
#line 661
    goto case_16;
  } else
#line 664
  if ((int )__cil_tmp71 == 15) {
#line 664
    goto case_15;
  } else
#line 667
  if ((int )__cil_tmp71 == 8) {
#line 667
    goto case_8;
  } else {
    {
#line 670
    goto switch_default;
#line 654
    if (0) {
      case_32: /* CIL Label */ 
#line 656
      format = (enum SVGA3dSurfaceFormat )2;
#line 657
      goto switch_break;
      case_24: /* CIL Label */ 
#line 659
      format = (enum SVGA3dSurfaceFormat )1;
#line 660
      goto switch_break;
      case_16: /* CIL Label */ 
#line 662
      format = (enum SVGA3dSurfaceFormat )3;
#line 663
      goto switch_break;
      case_15: /* CIL Label */ 
#line 665
      format = (enum SVGA3dSurfaceFormat )5;
#line 666
      goto switch_break;
      case_8: /* CIL Label */ 
#line 668
      format = (enum SVGA3dSurfaceFormat )11;
#line 669
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 671
      __cil_tmp72 = (unsigned long )mode_cmd;
#line 671
      __cil_tmp73 = __cil_tmp72 + 20;
#line 671
      __cil_tmp74 = *((__u32    *)__cil_tmp73);
#line 671
      drm_err("vmw_kms_new_framebuffer_surface", "Invalid color depth: %d\n", __cil_tmp74);
      }
#line 672
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  }
  {
#line 675
  __cil_tmp75 = (unsigned long )surface;
#line 675
  __cil_tmp76 = __cil_tmp75 + 116;
#line 675
  __cil_tmp77 = *((uint32_t *)__cil_tmp76);
#line 675
  __cil_tmp78 = (unsigned int )format;
#line 675
  __cil_tmp79 = __cil_tmp78 != __cil_tmp77;
#line 675
  __cil_tmp80 = ! __cil_tmp79;
#line 675
  __cil_tmp81 = ! __cil_tmp80;
#line 675
  __cil_tmp82 = (long )__cil_tmp81;
#line 675
  tmp___11 = ldv__builtin_expect(__cil_tmp82, 0L);
  }
#line 675
  if (tmp___11) {
    {
#line 676
    drm_err("vmw_kms_new_framebuffer_surface", "Invalid surface format for requested mode.\n");
    }
#line 677
    return (-22);
  } else {

  }
  {
#line 680
  tmp___12 = kzalloc(200UL, 208U);
#line 680
  vfbs = (struct vmw_framebuffer_surface *)tmp___12;
  }
#line 681
  if (! vfbs) {
#line 682
    ret = -12;
#line 683
    goto out_err1;
  } else {

  }
  {
#line 686
  __cil_tmp83 = (struct drm_framebuffer *)vfbs;
#line 686
  __cil_tmp84 = (struct drm_framebuffer_funcs    *)(& vmw_framebuffer_surface_funcs);
#line 686
  ret = drm_framebuffer_init(dev, __cil_tmp83, __cil_tmp84);
  }
#line 688
  if (ret) {
#line 689
    goto out_err2;
  } else {

  }
  {
#line 691
  tmp___13 = vmw_surface_reference(surface);
  }
#line 691
  if (tmp___13) {

  } else {
    {
#line 692
    drm_err("vmw_kms_new_framebuffer_surface", "failed to reference surface %p\n",
            surface);
    }
#line 693
    goto out_err3;
  }
  {
#line 697
  __cil_tmp85 = 0 + 84;
#line 697
  __cil_tmp86 = 0 + __cil_tmp85;
#line 697
  __cil_tmp87 = (unsigned long )vfbs;
#line 697
  __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
#line 697
  __cil_tmp89 = (unsigned long )mode_cmd;
#line 697
  __cil_tmp90 = __cil_tmp89 + 16;
#line 697
  __cil_tmp91 = *((__u32    *)__cil_tmp90);
#line 697
  *((int *)__cil_tmp88) = (int )__cil_tmp91;
#line 698
  __cil_tmp92 = 0 * 4UL;
#line 698
  __cil_tmp93 = 40 + __cil_tmp92;
#line 698
  __cil_tmp94 = 0 + __cil_tmp93;
#line 698
  __cil_tmp95 = 0 + __cil_tmp94;
#line 698
  __cil_tmp96 = (unsigned long )vfbs;
#line 698
  __cil_tmp97 = __cil_tmp96 + __cil_tmp95;
#line 698
  __cil_tmp98 = (unsigned long )mode_cmd;
#line 698
  __cil_tmp99 = __cil_tmp98 + 12;
#line 698
  __cil_tmp100 = *((__u32    *)__cil_tmp99);
#line 698
  *((unsigned int *)__cil_tmp97) = (unsigned int )__cil_tmp100;
#line 699
  __cil_tmp101 = 0 + 80;
#line 699
  __cil_tmp102 = 0 + __cil_tmp101;
#line 699
  __cil_tmp103 = (unsigned long )vfbs;
#line 699
  __cil_tmp104 = __cil_tmp103 + __cil_tmp102;
#line 699
  __cil_tmp105 = (unsigned long )mode_cmd;
#line 699
  __cil_tmp106 = __cil_tmp105 + 20;
#line 699
  __cil_tmp107 = *((__u32    *)__cil_tmp106);
#line 699
  *((unsigned int *)__cil_tmp104) = (unsigned int )__cil_tmp107;
#line 700
  __cil_tmp108 = 0 + 72;
#line 700
  __cil_tmp109 = 0 + __cil_tmp108;
#line 700
  __cil_tmp110 = (unsigned long )vfbs;
#line 700
  __cil_tmp111 = __cil_tmp110 + __cil_tmp109;
#line 700
  __cil_tmp112 = (unsigned long )mode_cmd;
#line 700
  __cil_tmp113 = __cil_tmp112 + 4;
#line 700
  __cil_tmp114 = *((__u32    *)__cil_tmp113);
#line 700
  *((unsigned int *)__cil_tmp111) = (unsigned int )__cil_tmp114;
#line 701
  __cil_tmp115 = 0 + 76;
#line 701
  __cil_tmp116 = 0 + __cil_tmp115;
#line 701
  __cil_tmp117 = (unsigned long )vfbs;
#line 701
  __cil_tmp118 = __cil_tmp117 + __cil_tmp116;
#line 701
  __cil_tmp119 = (unsigned long )mode_cmd;
#line 701
  __cil_tmp120 = __cil_tmp119 + 8;
#line 701
  __cil_tmp121 = *((__u32    *)__cil_tmp120);
#line 701
  *((unsigned int *)__cil_tmp118) = (unsigned int )__cil_tmp121;
#line 702
  __cil_tmp122 = (unsigned long )vfbs;
#line 702
  __cil_tmp123 = __cil_tmp122 + 160;
#line 702
  *((struct vmw_surface **)__cil_tmp123) = surface;
#line 703
  __cil_tmp124 = 0 + 152;
#line 703
  __cil_tmp125 = (unsigned long )vfbs;
#line 703
  __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 703
  __cil_tmp127 = (unsigned long )mode_cmd;
#line 703
  __cil_tmp128 = __cil_tmp127 + 24;
#line 703
  __cil_tmp129 = *((__u32    *)__cil_tmp128);
#line 703
  *((uint32_t *)__cil_tmp126) = (uint32_t )__cil_tmp129;
#line 704
  __cil_tmp130 = (unsigned long )vfbs;
#line 704
  __cil_tmp131 = __cil_tmp130 + 192;
#line 704
  __cil_tmp132 = (unsigned long )file_priv;
#line 704
  __cil_tmp133 = __cil_tmp132 + 152;
#line 704
  __cil_tmp134 = *((struct drm_master **)__cil_tmp133);
#line 704
  *((struct drm_master **)__cil_tmp131) = drm_master_get(__cil_tmp134);
#line 706
  __cil_tmp135 = (unsigned long )vmaster;
#line 706
  __cil_tmp136 = __cil_tmp135 + 152;
#line 706
  __cil_tmp137 = (struct mutex *)__cil_tmp136;
#line 706
  mutex_lock(__cil_tmp137);
#line 707
  __cil_tmp138 = (unsigned long )vfbs;
#line 707
  __cil_tmp139 = __cil_tmp138 + 176;
#line 707
  __cil_tmp140 = (struct list_head *)__cil_tmp139;
#line 707
  __cil_tmp141 = (unsigned long )vmaster;
#line 707
  __cil_tmp142 = __cil_tmp141 + 224;
#line 707
  __cil_tmp143 = (struct list_head *)__cil_tmp142;
#line 707
  list_add_tail(__cil_tmp140, __cil_tmp143);
#line 708
  __cil_tmp144 = (unsigned long )vmaster;
#line 708
  __cil_tmp145 = __cil_tmp144 + 152;
#line 708
  __cil_tmp146 = (struct mutex *)__cil_tmp145;
#line 708
  mutex_unlock(__cil_tmp146);
#line 710
  *out = (struct vmw_framebuffer *)vfbs;
  }
#line 712
  return (0);
  out_err3: 
  {
#line 715
  __cil_tmp147 = (struct drm_framebuffer *)vfbs;
#line 715
  drm_framebuffer_cleanup(__cil_tmp147);
  }
  out_err2: 
  {
#line 717
  __cil_tmp148 = (void    *)vfbs;
#line 717
  kfree(__cil_tmp148);
  }
  out_err1: 
#line 719
  return (ret);
}
}
#line 734 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer    *__mptr ;
  struct vmw_framebuffer_dmabuf *__cil_tmp4 ;
  struct drm_framebuffer *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_dma_buffer **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct ttm_base_object **__cil_tmp15 ;
  void    *__cil_tmp16 ;

  {
  {
#line 737
  __mptr = (struct drm_framebuffer    *)framebuffer;
#line 737
  __cil_tmp4 = (struct vmw_framebuffer_dmabuf *)0;
#line 737
  __cil_tmp5 = (struct drm_framebuffer *)__cil_tmp4;
#line 737
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 737
  __cil_tmp7 = (char *)__mptr;
#line 737
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 737
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp8;
#line 739
  drm_framebuffer_cleanup(framebuffer);
#line 740
  __cil_tmp9 = (unsigned long )vfbd;
#line 740
  __cil_tmp10 = __cil_tmp9 + 160;
#line 740
  __cil_tmp11 = (struct vmw_dma_buffer **)__cil_tmp10;
#line 740
  vmw_dmabuf_unreference(__cil_tmp11);
#line 741
  __cil_tmp12 = 0 + 144;
#line 741
  __cil_tmp13 = (unsigned long )vfbd;
#line 741
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 741
  __cil_tmp15 = (struct ttm_base_object **)__cil_tmp14;
#line 741
  ttm_base_object_unref(__cil_tmp15);
#line 743
  __cil_tmp16 = (void    *)vfbd;
#line 743
  kfree(__cil_tmp16);
  }
#line 744
  return;
}
}
#line 746 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv , struct vmw_framebuffer *framebuffer ,
                               unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment ) 
{ size_t fifo_size ;
  int i ;
  struct __anonstruct_cmd_431 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  struct __anonstruct_cmd_431 *__cil_tmp24 ;
  struct __anonstruct_cmd_431 *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned short __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct __anonstruct_cmd_431 *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct __anonstruct_cmd_431 *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned short __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned short __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct __anonstruct_cmd_431 *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned short __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned short __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  uint32_t __cil_tmp60 ;

  {
  {
#line 760
  __cil_tmp13 = (unsigned long )num_clips;
#line 760
  fifo_size = 20UL * __cil_tmp13;
#line 761
  __cil_tmp14 = (uint32_t )fifo_size;
#line 761
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp14);
#line 761
  cmd = (struct __anonstruct_cmd_431 *)tmp___7;
#line 762
  __cil_tmp15 = (void *)0;
#line 762
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 762
  __cil_tmp17 = (unsigned long )cmd;
#line 762
  __cil_tmp18 = __cil_tmp17 == __cil_tmp16;
#line 762
  __cil_tmp19 = ! __cil_tmp18;
#line 762
  __cil_tmp20 = ! __cil_tmp19;
#line 762
  __cil_tmp21 = (long )__cil_tmp20;
#line 762
  tmp___8 = ldv__builtin_expect(__cil_tmp21, 0L);
  }
#line 762
  if (tmp___8) {
    {
#line 763
    drm_err("do_dmabuf_dirty_ldu", "Fifo reserve failed.\n");
    }
#line 764
    return (-12);
  } else {

  }
  {
#line 767
  __cil_tmp22 = (void *)cmd;
#line 767
  memset(__cil_tmp22, 0, fifo_size);
#line 768
  i = 0;
  }
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 768
    __cil_tmp23 = (unsigned int )i;
#line 768
    if (__cil_tmp23 < num_clips) {

    } else {
#line 768
      goto while_break;
    }
    }
#line 769
    __cil_tmp24 = cmd + i;
#line 769
    *((uint32_t *)__cil_tmp24) = (__u32 )1;
#line 770
    __cil_tmp25 = cmd + i;
#line 770
    __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 770
    __cil_tmp27 = __cil_tmp26 + 4;
#line 770
    __cil_tmp28 = *((unsigned short *)clips);
#line 770
    *((uint32 *)__cil_tmp27) = (__u32 )__cil_tmp28;
#line 771
    __cil_tmp29 = 4 + 4;
#line 771
    __cil_tmp30 = cmd + i;
#line 771
    __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 771
    __cil_tmp32 = __cil_tmp31 + __cil_tmp29;
#line 771
    __cil_tmp33 = (unsigned long )clips;
#line 771
    __cil_tmp34 = __cil_tmp33 + 2;
#line 771
    __cil_tmp35 = *((unsigned short *)__cil_tmp34);
#line 771
    *((uint32 *)__cil_tmp32) = (__u32 )__cil_tmp35;
#line 772
    __cil_tmp36 = 4 + 8;
#line 772
    __cil_tmp37 = cmd + i;
#line 772
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 772
    __cil_tmp39 = __cil_tmp38 + __cil_tmp36;
#line 772
    __cil_tmp40 = *((unsigned short *)clips);
#line 772
    __cil_tmp41 = (int )__cil_tmp40;
#line 772
    __cil_tmp42 = (unsigned long )clips;
#line 772
    __cil_tmp43 = __cil_tmp42 + 4;
#line 772
    __cil_tmp44 = *((unsigned short *)__cil_tmp43);
#line 772
    __cil_tmp45 = (int )__cil_tmp44;
#line 772
    __cil_tmp46 = __cil_tmp45 - __cil_tmp41;
#line 772
    *((uint32 *)__cil_tmp39) = (__u32 )__cil_tmp46;
#line 773
    __cil_tmp47 = 4 + 12;
#line 773
    __cil_tmp48 = cmd + i;
#line 773
    __cil_tmp49 = (unsigned long )__cil_tmp48;
#line 773
    __cil_tmp50 = __cil_tmp49 + __cil_tmp47;
#line 773
    __cil_tmp51 = (unsigned long )clips;
#line 773
    __cil_tmp52 = __cil_tmp51 + 2;
#line 773
    __cil_tmp53 = *((unsigned short *)__cil_tmp52);
#line 773
    __cil_tmp54 = (int )__cil_tmp53;
#line 773
    __cil_tmp55 = (unsigned long )clips;
#line 773
    __cil_tmp56 = __cil_tmp55 + 6;
#line 773
    __cil_tmp57 = *((unsigned short *)__cil_tmp56);
#line 773
    __cil_tmp58 = (int )__cil_tmp57;
#line 773
    __cil_tmp59 = __cil_tmp58 - __cil_tmp54;
#line 773
    *((uint32 *)__cil_tmp50) = (__u32 )__cil_tmp59;
#line 768
    i = i + 1;
#line 768
    clips = clips + increment;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 776
  __cil_tmp60 = (uint32_t )fifo_size;
#line 776
  vmw_fifo_commit(dev_priv, __cil_tmp60);
  }
#line 777
  return (0);
}
}
#line 780 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int do_dmabuf_define_gmrfb(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                                  struct vmw_framebuffer *framebuffer ) 
{ int depth ;
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_432 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  uint64_t __cil_tmp60 ;
  void *__cil_tmp61 ;
  struct drm_vmw_fence_rep *__cil_tmp62 ;
  void *__cil_tmp63 ;
  struct vmw_fence_obj **__cil_tmp64 ;
  void    *__cil_tmp65 ;

  {
#line 784
  __cil_tmp10 = 0 + 80;
#line 784
  __cil_tmp11 = (unsigned long )framebuffer;
#line 784
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 784
  __cil_tmp13 = *((unsigned int *)__cil_tmp12);
#line 784
  depth = (int )__cil_tmp13;
#line 797
  if (depth == 32) {
#line 798
    depth = 24;
  } else {

  }
  {
#line 800
  fifo_size = 20UL;
#line 801
  tmp___7 = kmalloc(fifo_size, 208U);
#line 801
  cmd = (struct __anonstruct_cmd_432 *)tmp___7;
#line 802
  __cil_tmp14 = (void *)0;
#line 802
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 802
  __cil_tmp16 = (unsigned long )cmd;
#line 802
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
#line 802
  __cil_tmp18 = ! __cil_tmp17;
#line 802
  __cil_tmp19 = ! __cil_tmp18;
#line 802
  __cil_tmp20 = (long )__cil_tmp19;
#line 802
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 802
  if (tmp___8) {
    {
#line 803
    drm_err("do_dmabuf_define_gmrfb", "Failed to allocate temporary cmd buffer.\n");
    }
#line 804
    return (-12);
  } else {

  }
  {
#line 807
  __cil_tmp21 = (void *)cmd;
#line 807
  memset(__cil_tmp21, 0, fifo_size);
#line 808
  *((uint32_t *)cmd) = (uint32_t )36;
#line 809
  __cil_tmp22 = 4 + 12;
#line 809
  __cil_tmp23 = (unsigned long )cmd;
#line 809
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 809
  __cil_tmp25 = 0 + 84;
#line 809
  __cil_tmp26 = (unsigned long )framebuffer;
#line 809
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
#line 809
  __cil_tmp28 = *((int *)__cil_tmp27);
#line 809
  *((uint32 *)__cil_tmp24) = (uint32 )__cil_tmp28;
#line 810
  __cil_tmp29 = 0 + 1;
#line 810
  __cil_tmp30 = 0 + __cil_tmp29;
#line 810
  __cil_tmp31 = 12 + __cil_tmp30;
#line 810
  __cil_tmp32 = 4 + __cil_tmp31;
#line 810
  __cil_tmp33 = (unsigned long )cmd;
#line 810
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 810
  *((uint32 *)__cil_tmp34) = (uint32 )depth;
#line 811
  __cil_tmp35 = 0 + 2;
#line 811
  __cil_tmp36 = 0 + __cil_tmp35;
#line 811
  __cil_tmp37 = 12 + __cil_tmp36;
#line 811
  __cil_tmp38 = 4 + __cil_tmp37;
#line 811
  __cil_tmp39 = (unsigned long )cmd;
#line 811
  __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 811
  *((uint32 *)__cil_tmp40) = (uint32 )0;
#line 812
  __cil_tmp41 = 4 + 8;
#line 812
  __cil_tmp42 = (unsigned long )cmd;
#line 812
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 812
  __cil_tmp44 = 0 * 4UL;
#line 812
  __cil_tmp45 = 40 + __cil_tmp44;
#line 812
  __cil_tmp46 = 0 + __cil_tmp45;
#line 812
  __cil_tmp47 = (unsigned long )framebuffer;
#line 812
  __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 812
  *((uint32 *)__cil_tmp43) = *((unsigned int *)__cil_tmp48);
#line 813
  __cil_tmp49 = (unsigned long )cmd;
#line 813
  __cil_tmp50 = __cil_tmp49 + 4;
#line 813
  __cil_tmp51 = (unsigned long )framebuffer;
#line 813
  __cil_tmp52 = __cil_tmp51 + 152;
#line 813
  *((uint32 *)__cil_tmp50) = *((uint32_t *)__cil_tmp52);
#line 814
  __cil_tmp53 = 0 + 4;
#line 814
  __cil_tmp54 = 4 + __cil_tmp53;
#line 814
  __cil_tmp55 = (unsigned long )cmd;
#line 814
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 814
  *((uint32 *)__cil_tmp56) = (uint32 )0;
#line 816
  __cil_tmp57 = (void *)0;
#line 816
  __cil_tmp58 = (void *)cmd;
#line 816
  __cil_tmp59 = (uint32_t )fifo_size;
#line 816
  __cil_tmp60 = (uint64_t )0;
#line 816
  __cil_tmp61 = (void *)0;
#line 816
  __cil_tmp62 = (struct drm_vmw_fence_rep *)__cil_tmp61;
#line 816
  __cil_tmp63 = (void *)0;
#line 816
  __cil_tmp64 = (struct vmw_fence_obj **)__cil_tmp63;
#line 816
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp57, __cil_tmp58, __cil_tmp59,
                            __cil_tmp60, __cil_tmp62, __cil_tmp64);
#line 819
  __cil_tmp65 = (void    *)cmd;
#line 819
  kfree(__cil_tmp65);
  }
#line 821
  return (ret);
}
}
#line 824 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int do_dmabuf_dirty_sou(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_framebuffer *framebuffer , unsigned int flags ,
                               unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *clips_ptr ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  struct __anonstruct_blits_433 *blits ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int tmp___10 ;
  struct drm_crtc    *__mptr___1 ;
  struct vmw_display_unit *unit ;
  int hit_num ;
  int clip_x1 ;
  int clip_y1 ;
  int clip_x2 ;
  int clip_y2 ;
  int move_x ;
  int move_y ;
  int __min1 ;
  int __min2 ;
  int tmp___11 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___12 ;
  int __min1___1 ;
  int __min2___1 ;
  int tmp___13 ;
  int __min1___2 ;
  int __min2___2 ;
  int tmp___14 ;
  long tmp___15 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  void *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct drm_device *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  struct drm_crtc *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct list_head *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct drm_device *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct drm_framebuffer *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct drm_framebuffer *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct vmw_display_unit *__cil_tmp93 ;
  struct drm_crtc *__cil_tmp94 ;
  unsigned int __cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct list_head *__cil_tmp100 ;
  struct drm_crtc *__cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  unsigned int __cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned short __cil_tmp115 ;
  int __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  int __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned short __cil_tmp123 ;
  int __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  int __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned short __cil_tmp131 ;
  int __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned short __cil_tmp139 ;
  int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  int __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  struct __anonstruct_blits_433 *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  struct __anonstruct_blits_433 *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct __anonstruct_blits_433 *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned short __cil_tmp169 ;
  int __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  struct __anonstruct_blits_433 *__cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned short __cil_tmp178 ;
  int __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  struct __anonstruct_blits_433 *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  struct __anonstruct_blits_433 *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  struct __anonstruct_blits_433 *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  struct __anonstruct_blits_433 *__cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  void *__cil_tmp200 ;
  void *__cil_tmp201 ;
  uint32_t __cil_tmp202 ;
  uint64_t __cil_tmp203 ;
  void *__cil_tmp204 ;
  struct drm_vmw_fence_rep *__cil_tmp205 ;
  int __cil_tmp206 ;
  int __cil_tmp207 ;
  int __cil_tmp208 ;
  long __cil_tmp209 ;
  void    *__cil_tmp210 ;

  {
  {
#line 843
  ret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);
#line 844
  __cil_tmp47 = ret != 0;
#line 844
  __cil_tmp48 = ! __cil_tmp47;
#line 844
  __cil_tmp49 = ! __cil_tmp48;
#line 844
  __cil_tmp50 = (long )__cil_tmp49;
#line 844
  tmp___7 = ldv__builtin_expect(__cil_tmp50, 0L);
  }
#line 844
  if (tmp___7) {
#line 845
    return (ret);
  } else {

  }
  {
#line 847
  __cil_tmp51 = (unsigned long )num_clips;
#line 847
  fifo_size = 32UL * __cil_tmp51;
#line 848
  tmp___8 = kmalloc(fifo_size, 208U);
#line 848
  blits = (struct __anonstruct_blits_433 *)tmp___8;
#line 849
  __cil_tmp52 = (void *)0;
#line 849
  __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 849
  __cil_tmp54 = (unsigned long )blits;
#line 849
  __cil_tmp55 = __cil_tmp54 == __cil_tmp53;
#line 849
  __cil_tmp56 = ! __cil_tmp55;
#line 849
  __cil_tmp57 = ! __cil_tmp56;
#line 849
  __cil_tmp58 = (long )__cil_tmp57;
#line 849
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 0L);
  }
#line 849
  if (tmp___9) {
    {
#line 850
    drm_err("do_dmabuf_dirty_sou", "Failed to allocate temporary cmd buffer.\n");
    }
#line 851
    return (-12);
  } else {

  }
#line 854
  num_units = 0;
#line 855
  __cil_tmp59 = 1152 + 296;
#line 855
  __cil_tmp60 = (unsigned long )dev_priv;
#line 855
  __cil_tmp61 = __cil_tmp60 + 2088;
#line 855
  __cil_tmp62 = *((struct drm_device **)__cil_tmp61);
#line 855
  __cil_tmp63 = (unsigned long )__cil_tmp62;
#line 855
  __cil_tmp64 = __cil_tmp63 + __cil_tmp59;
#line 855
  __cil_tmp65 = *((struct list_head **)__cil_tmp64);
#line 855
  __mptr = (struct list_head    *)__cil_tmp65;
#line 855
  __cil_tmp66 = (struct drm_crtc *)0;
#line 855
  __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 855
  __cil_tmp68 = __cil_tmp67 + 8;
#line 855
  __cil_tmp69 = (struct list_head *)__cil_tmp68;
#line 855
  __cil_tmp70 = (unsigned int )__cil_tmp69;
#line 855
  __cil_tmp71 = (char *)__mptr;
#line 855
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
#line 855
  crtc = (struct drm_crtc *)__cil_tmp72;
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 855
    __cil_tmp73 = 1152 + 296;
#line 855
    __cil_tmp74 = (unsigned long )dev_priv;
#line 855
    __cil_tmp75 = __cil_tmp74 + 2088;
#line 855
    __cil_tmp76 = *((struct drm_device **)__cil_tmp75);
#line 855
    __cil_tmp77 = (unsigned long )__cil_tmp76;
#line 855
    __cil_tmp78 = __cil_tmp77 + __cil_tmp73;
#line 855
    __cil_tmp79 = (struct list_head *)__cil_tmp78;
#line 855
    __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 855
    __cil_tmp81 = (unsigned long )crtc;
#line 855
    __cil_tmp82 = __cil_tmp81 + 8;
#line 855
    __cil_tmp83 = (struct list_head *)__cil_tmp82;
#line 855
    __cil_tmp84 = (unsigned long )__cil_tmp83;
#line 855
    if (__cil_tmp84 != __cil_tmp80) {

    } else {
#line 855
      goto while_break;
    }
    }
    {
#line 856
    __cil_tmp85 = (struct drm_framebuffer *)framebuffer;
#line 856
    __cil_tmp86 = (unsigned long )__cil_tmp85;
#line 856
    __cil_tmp87 = (unsigned long )crtc;
#line 856
    __cil_tmp88 = __cil_tmp87 + 32;
#line 856
    __cil_tmp89 = *((struct drm_framebuffer **)__cil_tmp88);
#line 856
    __cil_tmp90 = (unsigned long )__cil_tmp89;
#line 856
    if (__cil_tmp90 != __cil_tmp86) {
#line 857
      goto __Cont;
    } else {

    }
    }
#line 858
    tmp___10 = num_units;
#line 858
    num_units = num_units + 1;
#line 858
    __mptr___1 = (struct drm_crtc    *)crtc;
#line 858
    __cil_tmp91 = tmp___10 * 8UL;
#line 858
    __cil_tmp92 = (unsigned long )(units) + __cil_tmp91;
#line 858
    __cil_tmp93 = (struct vmw_display_unit *)0;
#line 858
    __cil_tmp94 = (struct drm_crtc *)__cil_tmp93;
#line 858
    __cil_tmp95 = (unsigned int )__cil_tmp94;
#line 858
    __cil_tmp96 = (char *)__mptr___1;
#line 858
    __cil_tmp97 = __cil_tmp96 - __cil_tmp95;
#line 858
    *((struct vmw_display_unit **)__cil_tmp92) = (struct vmw_display_unit *)__cil_tmp97;
    __Cont: /* CIL Label */ 
#line 855
    __cil_tmp98 = (unsigned long )crtc;
#line 855
    __cil_tmp99 = __cil_tmp98 + 8;
#line 855
    __cil_tmp100 = *((struct list_head **)__cil_tmp99);
#line 855
    __mptr___0 = (struct list_head    *)__cil_tmp100;
#line 855
    __cil_tmp101 = (struct drm_crtc *)0;
#line 855
    __cil_tmp102 = (unsigned long )__cil_tmp101;
#line 855
    __cil_tmp103 = __cil_tmp102 + 8;
#line 855
    __cil_tmp104 = (struct list_head *)__cil_tmp103;
#line 855
    __cil_tmp105 = (unsigned int )__cil_tmp104;
#line 855
    __cil_tmp106 = (char *)__mptr___0;
#line 855
    __cil_tmp107 = __cil_tmp106 - __cil_tmp105;
#line 855
    crtc = (struct drm_crtc *)__cil_tmp107;
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  k = 0;
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (k < num_units) {

    } else {
#line 861
      goto while_break___0;
    }
#line 862
    __cil_tmp108 = k * 8UL;
#line 862
    __cil_tmp109 = (unsigned long )(units) + __cil_tmp108;
#line 862
    unit = *((struct vmw_display_unit **)__cil_tmp109);
#line 863
    hit_num = 0;
#line 865
    clips_ptr = clips;
#line 866
    i = 0;
    {
#line 866
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 866
      __cil_tmp110 = (unsigned int )i;
#line 866
      if (__cil_tmp110 < num_clips) {

      } else {
#line 866
        goto while_break___1;
      }
      }
#line 867
      __cil_tmp111 = 0 + 480;
#line 867
      __cil_tmp112 = (unsigned long )unit;
#line 867
      __cil_tmp113 = __cil_tmp112 + __cil_tmp111;
#line 867
      __cil_tmp114 = *((int *)__cil_tmp113);
#line 867
      __cil_tmp115 = *((unsigned short *)clips_ptr);
#line 867
      __cil_tmp116 = (int )__cil_tmp115;
#line 867
      clip_x1 = __cil_tmp116 - __cil_tmp114;
#line 868
      __cil_tmp117 = 0 + 484;
#line 868
      __cil_tmp118 = (unsigned long )unit;
#line 868
      __cil_tmp119 = __cil_tmp118 + __cil_tmp117;
#line 868
      __cil_tmp120 = *((int *)__cil_tmp119);
#line 868
      __cil_tmp121 = (unsigned long )clips_ptr;
#line 868
      __cil_tmp122 = __cil_tmp121 + 2;
#line 868
      __cil_tmp123 = *((unsigned short *)__cil_tmp122);
#line 868
      __cil_tmp124 = (int )__cil_tmp123;
#line 868
      clip_y1 = __cil_tmp124 - __cil_tmp120;
#line 869
      __cil_tmp125 = 0 + 480;
#line 869
      __cil_tmp126 = (unsigned long )unit;
#line 869
      __cil_tmp127 = __cil_tmp126 + __cil_tmp125;
#line 869
      __cil_tmp128 = *((int *)__cil_tmp127);
#line 869
      __cil_tmp129 = (unsigned long )clips_ptr;
#line 869
      __cil_tmp130 = __cil_tmp129 + 4;
#line 869
      __cil_tmp131 = *((unsigned short *)__cil_tmp130);
#line 869
      __cil_tmp132 = (int )__cil_tmp131;
#line 869
      clip_x2 = __cil_tmp132 - __cil_tmp128;
#line 870
      __cil_tmp133 = 0 + 484;
#line 870
      __cil_tmp134 = (unsigned long )unit;
#line 870
      __cil_tmp135 = __cil_tmp134 + __cil_tmp133;
#line 870
      __cil_tmp136 = *((int *)__cil_tmp135);
#line 870
      __cil_tmp137 = (unsigned long )clips_ptr;
#line 870
      __cil_tmp138 = __cil_tmp137 + 6;
#line 870
      __cil_tmp139 = *((unsigned short *)__cil_tmp138);
#line 870
      __cil_tmp140 = (int )__cil_tmp139;
#line 870
      clip_y2 = __cil_tmp140 - __cil_tmp136;
      {
#line 874
      __cil_tmp141 = 48 + 68;
#line 874
      __cil_tmp142 = 0 + __cil_tmp141;
#line 874
      __cil_tmp143 = (unsigned long )unit;
#line 874
      __cil_tmp144 = __cil_tmp143 + __cil_tmp142;
#line 874
      __cil_tmp145 = *((int *)__cil_tmp144);
#line 874
      if (clip_x1 >= __cil_tmp145) {
#line 877
        goto __Cont___0;
      } else {
        {
#line 874
        __cil_tmp146 = 48 + 88;
#line 874
        __cil_tmp147 = 0 + __cil_tmp146;
#line 874
        __cil_tmp148 = (unsigned long )unit;
#line 874
        __cil_tmp149 = __cil_tmp148 + __cil_tmp147;
#line 874
        __cil_tmp150 = *((int *)__cil_tmp149);
#line 874
        if (clip_y1 >= __cil_tmp150) {
#line 877
          goto __Cont___0;
        } else
#line 874
        if (clip_x2 <= 0) {
#line 877
          goto __Cont___0;
        } else
#line 874
        if (clip_y2 <= 0) {
#line 877
          goto __Cont___0;
        } else {

        }
        }
      }
      }
#line 880
      __min1 = clip_x2;
#line 880
      __cil_tmp151 = 48 + 68;
#line 880
      __cil_tmp152 = 0 + __cil_tmp151;
#line 880
      __cil_tmp153 = (unsigned long )unit;
#line 880
      __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
#line 880
      __min2 = *((int *)__cil_tmp154);
#line 880
      if (__min1 < __min2) {
#line 880
        tmp___11 = __min1;
      } else {
#line 880
        tmp___11 = __min2;
      }
#line 880
      clip_x2 = tmp___11;
#line 881
      __min1___0 = clip_y2;
#line 881
      __cil_tmp155 = 48 + 88;
#line 881
      __cil_tmp156 = 0 + __cil_tmp155;
#line 881
      __cil_tmp157 = (unsigned long )unit;
#line 881
      __cil_tmp158 = __cil_tmp157 + __cil_tmp156;
#line 881
      __min2___0 = *((int *)__cil_tmp158);
#line 881
      if (__min1___0 < __min2___0) {
#line 881
        tmp___12 = __min1___0;
      } else {
#line 881
        tmp___12 = __min2___0;
      }
#line 881
      clip_y2 = tmp___12;
#line 884
      __min1___1 = clip_x1;
#line 884
      __min2___1 = 0;
#line 884
      if (__min1___1 < __min2___1) {
#line 884
        tmp___13 = __min1___1;
      } else {
#line 884
        tmp___13 = __min2___1;
      }
#line 884
      move_x = tmp___13;
#line 885
      __min1___2 = clip_y1;
#line 885
      __min2___2 = 0;
#line 885
      if (__min1___2 < __min2___2) {
#line 885
        tmp___14 = __min1___2;
      } else {
#line 885
        tmp___14 = __min2___2;
      }
#line 885
      move_y = tmp___14;
#line 888
      __cil_tmp159 = blits + hit_num;
#line 888
      *((uint32_t *)__cil_tmp159) = (uint32_t )37;
#line 889
      __cil_tmp160 = 4 + 24;
#line 889
      __cil_tmp161 = blits + hit_num;
#line 889
      __cil_tmp162 = (unsigned long )__cil_tmp161;
#line 889
      __cil_tmp163 = __cil_tmp162 + __cil_tmp160;
#line 889
      __cil_tmp164 = (unsigned long )unit;
#line 889
      __cil_tmp165 = __cil_tmp164 + 2032;
#line 889
      *((uint32 *)__cil_tmp163) = *((unsigned int *)__cil_tmp165);
#line 890
      __cil_tmp166 = blits + hit_num;
#line 890
      __cil_tmp167 = (unsigned long )__cil_tmp166;
#line 890
      __cil_tmp168 = __cil_tmp167 + 4;
#line 890
      __cil_tmp169 = *((unsigned short *)clips_ptr);
#line 890
      __cil_tmp170 = (int )__cil_tmp169;
#line 890
      *((int32 *)__cil_tmp168) = __cil_tmp170 - move_x;
#line 891
      __cil_tmp171 = 0 + 4;
#line 891
      __cil_tmp172 = 4 + __cil_tmp171;
#line 891
      __cil_tmp173 = blits + hit_num;
#line 891
      __cil_tmp174 = (unsigned long )__cil_tmp173;
#line 891
      __cil_tmp175 = __cil_tmp174 + __cil_tmp172;
#line 891
      __cil_tmp176 = (unsigned long )clips_ptr;
#line 891
      __cil_tmp177 = __cil_tmp176 + 2;
#line 891
      __cil_tmp178 = *((unsigned short *)__cil_tmp177);
#line 891
      __cil_tmp179 = (int )__cil_tmp178;
#line 891
      *((int32 *)__cil_tmp175) = __cil_tmp179 - move_y;
#line 892
      __cil_tmp180 = 4 + 8;
#line 892
      __cil_tmp181 = blits + hit_num;
#line 892
      __cil_tmp182 = (unsigned long )__cil_tmp181;
#line 892
      __cil_tmp183 = __cil_tmp182 + __cil_tmp180;
#line 892
      *((int32 *)__cil_tmp183) = clip_x1 - move_x;
#line 893
      __cil_tmp184 = 8 + 4;
#line 893
      __cil_tmp185 = 4 + __cil_tmp184;
#line 893
      __cil_tmp186 = blits + hit_num;
#line 893
      __cil_tmp187 = (unsigned long )__cil_tmp186;
#line 893
      __cil_tmp188 = __cil_tmp187 + __cil_tmp185;
#line 893
      *((int32 *)__cil_tmp188) = clip_y1 - move_y;
#line 894
      __cil_tmp189 = 8 + 8;
#line 894
      __cil_tmp190 = 4 + __cil_tmp189;
#line 894
      __cil_tmp191 = blits + hit_num;
#line 894
      __cil_tmp192 = (unsigned long )__cil_tmp191;
#line 894
      __cil_tmp193 = __cil_tmp192 + __cil_tmp190;
#line 894
      *((int32 *)__cil_tmp193) = clip_x2;
#line 895
      __cil_tmp194 = 8 + 12;
#line 895
      __cil_tmp195 = 4 + __cil_tmp194;
#line 895
      __cil_tmp196 = blits + hit_num;
#line 895
      __cil_tmp197 = (unsigned long )__cil_tmp196;
#line 895
      __cil_tmp198 = __cil_tmp197 + __cil_tmp195;
#line 895
      *((int32 *)__cil_tmp198) = clip_y2;
#line 896
      hit_num = hit_num + 1;
      __Cont___0: /* CIL Label */ 
#line 866
      i = i + 1;
#line 866
      clips_ptr = clips_ptr + increment;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 900
    if (hit_num == 0) {
#line 901
      goto __Cont___1;
    } else {

    }
#line 904
    if (out_fence) {
#line 904
      if (*out_fence) {
        {
#line 905
        vmw_fence_obj_unreference(out_fence);
        }
      } else {

      }
    } else {

    }
    {
#line 907
    __cil_tmp199 = (unsigned long )hit_num;
#line 907
    fifo_size = 32UL * __cil_tmp199;
#line 908
    __cil_tmp200 = (void *)0;
#line 908
    __cil_tmp201 = (void *)blits;
#line 908
    __cil_tmp202 = (uint32_t )fifo_size;
#line 908
    __cil_tmp203 = (uint64_t )0;
#line 908
    __cil_tmp204 = (void *)0;
#line 908
    __cil_tmp205 = (struct drm_vmw_fence_rep *)__cil_tmp204;
#line 908
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp200, __cil_tmp201, __cil_tmp202,
                              __cil_tmp203, __cil_tmp205, out_fence);
#line 911
    __cil_tmp206 = ret != 0;
#line 911
    __cil_tmp207 = ! __cil_tmp206;
#line 911
    __cil_tmp208 = ! __cil_tmp207;
#line 911
    __cil_tmp209 = (long )__cil_tmp208;
#line 911
    tmp___15 = ldv__builtin_expect(__cil_tmp209, 0L);
    }
#line 911
    if (tmp___15) {
#line 912
      goto while_break___0;
    } else {

    }
    __Cont___1: /* CIL Label */ 
#line 861
    k = k + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 915
  __cil_tmp210 = (void    *)blits;
#line 915
  kfree(__cil_tmp210);
  }
#line 917
  return (ret);
}
}
#line 920 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                 unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                 unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer    *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int increment ;
  long tmp___9 ;
  struct drm_device *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_master *__cil_tmp20 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp21 ;
  struct drm_framebuffer *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  struct ttm_lock *__cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct drm_clip_rect *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_framebuffer *__cil_tmp45 ;
  struct vmw_framebuffer *__cil_tmp46 ;
  void *__cil_tmp47 ;
  struct vmw_fence_obj **__cil_tmp48 ;
  struct ttm_lock *__cil_tmp49 ;

  {
  {
#line 926
  __cil_tmp17 = *((struct drm_device **)framebuffer);
#line 926
  tmp___7 = vmw_priv(__cil_tmp17);
#line 926
  dev_priv = tmp___7;
#line 927
  __cil_tmp18 = (unsigned long )file_priv;
#line 927
  __cil_tmp19 = __cil_tmp18 + 152;
#line 927
  __cil_tmp20 = *((struct drm_master **)__cil_tmp19);
#line 927
  tmp___8 = vmw_master(__cil_tmp20);
#line 927
  vmaster = tmp___8;
#line 929
  __mptr = (struct drm_framebuffer    *)framebuffer;
#line 929
  __cil_tmp21 = (struct vmw_framebuffer_dmabuf *)0;
#line 929
  __cil_tmp22 = (struct drm_framebuffer *)__cil_tmp21;
#line 929
  __cil_tmp23 = (unsigned int )__cil_tmp22;
#line 929
  __cil_tmp24 = (char *)__mptr;
#line 929
  __cil_tmp25 = __cil_tmp24 - __cil_tmp23;
#line 929
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp25;
#line 931
  increment = 1;
#line 933
  __cil_tmp26 = (struct ttm_lock *)vmaster;
#line 933
  __cil_tmp27 = (bool )1;
#line 933
  ret = ttm_read_lock(__cil_tmp26, __cil_tmp27);
#line 934
  __cil_tmp28 = ret != 0;
#line 934
  __cil_tmp29 = ! __cil_tmp28;
#line 934
  __cil_tmp30 = ! __cil_tmp29;
#line 934
  __cil_tmp31 = (long )__cil_tmp30;
#line 934
  tmp___9 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 934
  if (tmp___9) {
#line 935
    return (ret);
  } else {

  }
#line 937
  if (! num_clips) {
#line 938
    num_clips = 1U;
#line 939
    clips = & norect;
#line 940
    __cil_tmp32 = (unsigned long )(& norect) + 2;
#line 940
    *((unsigned short *)__cil_tmp32) = (unsigned short)0;
#line 940
    __cil_tmp33 = & norect;
#line 940
    __cil_tmp34 = (unsigned long )(& norect) + 2;
#line 940
    *((unsigned short *)__cil_tmp33) = *((unsigned short *)__cil_tmp34);
#line 941
    __cil_tmp35 = (unsigned long )(& norect) + 4;
#line 941
    __cil_tmp36 = (unsigned long )framebuffer;
#line 941
    __cil_tmp37 = __cil_tmp36 + 72;
#line 941
    __cil_tmp38 = *((unsigned int *)__cil_tmp37);
#line 941
    *((unsigned short *)__cil_tmp35) = (unsigned short )__cil_tmp38;
#line 942
    __cil_tmp39 = (unsigned long )(& norect) + 6;
#line 942
    __cil_tmp40 = (unsigned long )framebuffer;
#line 942
    __cil_tmp41 = __cil_tmp40 + 76;
#line 942
    __cil_tmp42 = *((unsigned int *)__cil_tmp41);
#line 942
    *((unsigned short *)__cil_tmp39) = (unsigned short )__cil_tmp42;
  } else
#line 943
  if (flags & 1U) {
#line 944
    num_clips = num_clips / 2U;
#line 945
    increment = 2;
  } else {

  }
  {
#line 948
  __cil_tmp43 = (unsigned long )dev_priv;
#line 948
  __cil_tmp44 = __cil_tmp43 + 2608;
#line 948
  if (*((struct vmw_legacy_display **)__cil_tmp44)) {
    {
#line 949
    __cil_tmp45 = (struct vmw_framebuffer *)vfbd;
#line 949
    ret = do_dmabuf_dirty_ldu(dev_priv, __cil_tmp45, flags, color, clips, num_clips,
                              increment);
    }
  } else {
    {
#line 953
    __cil_tmp46 = (struct vmw_framebuffer *)vfbd;
#line 953
    __cil_tmp47 = (void *)0;
#line 953
    __cil_tmp48 = (struct vmw_fence_obj **)__cil_tmp47;
#line 953
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, __cil_tmp46, flags, color, clips,
                              num_clips, increment, __cil_tmp48);
    }
  }
  }
  {
#line 958
  __cil_tmp49 = (struct ttm_lock *)vmaster;
#line 958
  ttm_read_unlock(__cil_tmp49);
  }
#line 959
  return (ret);
}
}
#line 962 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static struct drm_framebuffer_funcs vmw_framebuffer_dmabuf_funcs  =    {& vmw_framebuffer_dmabuf_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_dmabuf_dirty};
#line 971 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer    *__mptr ;
  int ret ;
  long tmp___8 ;
  int __ret_warn_on ;
  long tmp___9 ;
  struct drm_device *__cil_tmp10 ;
  struct drm_framebuffer *__cil_tmp11 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp12 ;
  struct drm_framebuffer *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_screen_object_display *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_dma_buffer *__cil_tmp25 ;
  bool __cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  int    __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  {
#line 973
  __cil_tmp10 = *((struct drm_device **)vfb);
#line 973
  tmp___7 = vmw_priv(__cil_tmp10);
#line 973
  dev_priv = tmp___7;
#line 975
  __cil_tmp11 = (struct drm_framebuffer *)vfb;
#line 975
  __mptr = (struct drm_framebuffer    *)__cil_tmp11;
#line 975
  __cil_tmp12 = (struct vmw_framebuffer_dmabuf *)0;
#line 975
  __cil_tmp13 = (struct drm_framebuffer *)__cil_tmp12;
#line 975
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 975
  __cil_tmp15 = (char *)__mptr;
#line 975
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
#line 975
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp16;
  }
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 979
    __cil_tmp17 = (unsigned long )dev_priv;
#line 979
    __cil_tmp18 = __cil_tmp17 + 2616;
#line 979
    __cil_tmp19 = *((struct vmw_screen_object_display **)__cil_tmp18);
#line 979
    __cil_tmp20 = ! __cil_tmp19;
#line 979
    __cil_tmp21 = ! __cil_tmp20;
#line 979
    __cil_tmp22 = (long )__cil_tmp21;
#line 979
    tmp___8 = ldv__builtin_expect(__cil_tmp22, 0L);
    }
#line 979
    if (tmp___8) {
      {
#line 979
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 979
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (979), "i" (12UL));
        {
#line 979
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 979
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 979
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  vmw_overlay_pause_all(dev_priv);
#line 983
  __cil_tmp23 = (unsigned long )vfbd;
#line 983
  __cil_tmp24 = __cil_tmp23 + 160;
#line 983
  __cil_tmp25 = *((struct vmw_dma_buffer **)__cil_tmp24);
#line 983
  __cil_tmp26 = (bool )1;
#line 983
  __cil_tmp27 = (bool )0;
#line 983
  ret = vmw_dmabuf_to_start_of_vram(dev_priv, __cil_tmp25, __cil_tmp26, __cil_tmp27);
#line 985
  vmw_overlay_resume_all(dev_priv);
#line 987
  __cil_tmp28 = ret != 0;
#line 987
  __cil_tmp29 = ! __cil_tmp28;
#line 987
  __ret_warn_on = ! __cil_tmp29;
#line 987
  __cil_tmp30 = ! __ret_warn_on;
#line 987
  __cil_tmp31 = ! __cil_tmp30;
#line 987
  __cil_tmp32 = (long )__cil_tmp31;
#line 987
  tmp___9 = ldv__builtin_expect(__cil_tmp32, 0L);
  }
#line 987
  if (tmp___9) {
    {
#line 987
    __cil_tmp33 = (int    )987;
#line 987
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c",
                       __cil_tmp33);
    }
  } else {

  }
  {
#line 987
  __cil_tmp34 = ! __ret_warn_on;
#line 987
  __cil_tmp35 = ! __cil_tmp34;
#line 987
  __cil_tmp36 = (long )__cil_tmp35;
#line 987
  ldv__builtin_expect(__cil_tmp36, 0L);
  }
#line 989
  return (0);
}
}
#line 992 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer    *__mptr ;
  int __ret_warn_on ;
  long tmp___8 ;
  int tmp___9 ;
  struct drm_device *__cil_tmp9 ;
  struct drm_framebuffer *__cil_tmp10 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp11 ;
  struct drm_framebuffer *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_dma_buffer *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_dma_buffer *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  int    __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_dma_buffer *__cil_tmp33 ;
  bool __cil_tmp34 ;

  {
  {
#line 994
  __cil_tmp9 = *((struct drm_device **)vfb);
#line 994
  tmp___7 = vmw_priv(__cil_tmp9);
#line 994
  dev_priv = tmp___7;
#line 996
  __cil_tmp10 = (struct drm_framebuffer *)vfb;
#line 996
  __mptr = (struct drm_framebuffer    *)__cil_tmp10;
#line 996
  __cil_tmp11 = (struct vmw_framebuffer_dmabuf *)0;
#line 996
  __cil_tmp12 = (struct drm_framebuffer *)__cil_tmp11;
#line 996
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 996
  __cil_tmp14 = (char *)__mptr;
#line 996
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
#line 996
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp15;
  }
  {
#line 998
  __cil_tmp16 = (unsigned long )vfbd;
#line 998
  __cil_tmp17 = __cil_tmp16 + 160;
#line 998
  __cil_tmp18 = *((struct vmw_dma_buffer **)__cil_tmp17);
#line 998
  if (! __cil_tmp18) {
    {
#line 999
    __cil_tmp19 = (unsigned long )vfbd;
#line 999
    __cil_tmp20 = __cil_tmp19 + 160;
#line 999
    __cil_tmp21 = *((struct vmw_dma_buffer **)__cil_tmp20);
#line 999
    __cil_tmp22 = ! __cil_tmp21;
#line 999
    __cil_tmp23 = ! __cil_tmp22;
#line 999
    __ret_warn_on = ! __cil_tmp23;
#line 999
    __cil_tmp24 = ! __ret_warn_on;
#line 999
    __cil_tmp25 = ! __cil_tmp24;
#line 999
    __cil_tmp26 = (long )__cil_tmp25;
#line 999
    tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
    }
#line 999
    if (tmp___8) {
      {
#line 999
      __cil_tmp27 = (int    )999;
#line 999
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c",
                         __cil_tmp27);
      }
    } else {

    }
    {
#line 999
    __cil_tmp28 = ! __ret_warn_on;
#line 999
    __cil_tmp29 = ! __cil_tmp28;
#line 999
    __cil_tmp30 = (long )__cil_tmp29;
#line 999
    ldv__builtin_expect(__cil_tmp30, 0L);
    }
#line 1000
    return (0);
  } else {

  }
  }
  {
#line 1003
  __cil_tmp31 = (unsigned long )vfbd;
#line 1003
  __cil_tmp32 = __cil_tmp31 + 160;
#line 1003
  __cil_tmp33 = *((struct vmw_dma_buffer **)__cil_tmp32);
#line 1003
  __cil_tmp34 = (bool )0;
#line 1003
  tmp___9 = vmw_dmabuf_unpin(dev_priv, __cil_tmp33, __cil_tmp34);
  }
#line 1003
  return (tmp___9);
}
}
#line 1006 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                                          struct vmw_framebuffer **out , struct drm_mode_fb_cmd    *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  unsigned int requested_size ;
  int ret ;
  long tmp___7 ;
  void *tmp___8 ;
  struct vmw_dma_buffer *tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  __u32    __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32    __cil_tmp19 ;
  __u32    __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  __u32    __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  __u32    __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  __u32    __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32    __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  __u32    __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  __u32    __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32    __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  __u32    __cil_tmp57 ;
  struct drm_framebuffer *__cil_tmp58 ;
  struct drm_framebuffer_funcs    *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  __u32    __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  __u32    __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  __u32    __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  __u32    __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  __u32    __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct vmw_screen_object_display *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  __u32    __cil_tmp116 ;
  struct drm_framebuffer *__cil_tmp117 ;
  void    *__cil_tmp118 ;

  {
  {
#line 1013
  __cil_tmp12 = (unsigned long )dev_priv;
#line 1013
  __cil_tmp13 = __cil_tmp12 + 2088;
#line 1013
  dev = *((struct drm_device **)__cil_tmp13);
#line 1018
  __cil_tmp14 = (unsigned long )mode_cmd;
#line 1018
  __cil_tmp15 = __cil_tmp14 + 12;
#line 1018
  __cil_tmp16 = *((__u32    *)__cil_tmp15);
#line 1018
  __cil_tmp17 = (unsigned long )mode_cmd;
#line 1018
  __cil_tmp18 = __cil_tmp17 + 8;
#line 1018
  __cil_tmp19 = *((__u32    *)__cil_tmp18);
#line 1018
  __cil_tmp20 = __cil_tmp19 * __cil_tmp16;
#line 1018
  requested_size = (unsigned int )__cil_tmp20;
#line 1019
  __cil_tmp21 = 1UL << 12;
#line 1019
  __cil_tmp22 = 0 + 40;
#line 1019
  __cil_tmp23 = (unsigned long )dmabuf;
#line 1019
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 1019
  __cil_tmp25 = *((unsigned long *)__cil_tmp24);
#line 1019
  __cil_tmp26 = __cil_tmp25 * __cil_tmp21;
#line 1019
  __cil_tmp27 = (unsigned long )requested_size;
#line 1019
  __cil_tmp28 = __cil_tmp27 > __cil_tmp26;
#line 1019
  __cil_tmp29 = ! __cil_tmp28;
#line 1019
  __cil_tmp30 = ! __cil_tmp29;
#line 1019
  __cil_tmp31 = (long )__cil_tmp30;
#line 1019
  tmp___7 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 1019
  if (tmp___7) {
    {
#line 1020
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Screen buffer object size is too small for requested mode.\n");
    }
#line 1022
    return (-22);
  } else {

  }
  {
#line 1026
  __cil_tmp32 = (unsigned long )dev_priv;
#line 1026
  __cil_tmp33 = __cil_tmp32 + 2616;
#line 1026
  if (*((struct vmw_screen_object_display **)__cil_tmp33)) {
    {
#line 1027
    __cil_tmp34 = (unsigned long )mode_cmd;
#line 1027
    __cil_tmp35 = __cil_tmp34 + 20;
#line 1027
    __cil_tmp36 = *((__u32    *)__cil_tmp35);
#line 1028
    if ((int )__cil_tmp36 == 32) {
#line 1028
      goto case_32;
    } else
#line 1029
    if ((int )__cil_tmp36 == 24) {
#line 1029
      goto case_32;
    } else
#line 1037
    if ((int )__cil_tmp36 == 16) {
#line 1037
      goto case_16;
    } else
#line 1038
    if ((int )__cil_tmp36 == 15) {
#line 1038
      goto case_16;
    } else {
      {
#line 1046
      goto switch_default;
#line 1027
      if (0) {
        case_32: /* CIL Label */ 
        case_24: /* CIL Label */ 
        {
#line 1031
        __cil_tmp37 = (unsigned long )mode_cmd;
#line 1031
        __cil_tmp38 = __cil_tmp37 + 16;
#line 1031
        __cil_tmp39 = *((__u32    *)__cil_tmp38);
#line 1031
        if (__cil_tmp39 == 32U) {
#line 1032
          goto switch_break;
        } else {

        }
        }
        {
#line 1034
        __cil_tmp40 = (unsigned long )mode_cmd;
#line 1034
        __cil_tmp41 = __cil_tmp40 + 20;
#line 1034
        __cil_tmp42 = *((__u32    *)__cil_tmp41);
#line 1034
        __cil_tmp43 = (unsigned long )mode_cmd;
#line 1034
        __cil_tmp44 = __cil_tmp43 + 16;
#line 1034
        __cil_tmp45 = *((__u32    *)__cil_tmp44);
#line 1034
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
                __cil_tmp42, __cil_tmp45);
        }
#line 1036
        return (-22);
        case_16: /* CIL Label */ 
        case_15: /* CIL Label */ 
        {
#line 1040
        __cil_tmp46 = (unsigned long )mode_cmd;
#line 1040
        __cil_tmp47 = __cil_tmp46 + 16;
#line 1040
        __cil_tmp48 = *((__u32    *)__cil_tmp47);
#line 1040
        if (__cil_tmp48 == 16U) {
#line 1041
          goto switch_break;
        } else {

        }
        }
        {
#line 1043
        __cil_tmp49 = (unsigned long )mode_cmd;
#line 1043
        __cil_tmp50 = __cil_tmp49 + 20;
#line 1043
        __cil_tmp51 = *((__u32    *)__cil_tmp50);
#line 1043
        __cil_tmp52 = (unsigned long )mode_cmd;
#line 1043
        __cil_tmp53 = __cil_tmp52 + 16;
#line 1043
        __cil_tmp54 = *((__u32    *)__cil_tmp53);
#line 1043
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
                __cil_tmp51, __cil_tmp54);
        }
#line 1045
        return (-22);
        switch_default: /* CIL Label */ 
        {
#line 1047
        __cil_tmp55 = (unsigned long )mode_cmd;
#line 1047
        __cil_tmp56 = __cil_tmp55 + 20;
#line 1047
        __cil_tmp57 = *((__u32    *)__cil_tmp56);
#line 1047
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth: %d\n", __cil_tmp57);
        }
#line 1048
        return (-22);
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
    }
  } else {

  }
  }
  {
#line 1052
  tmp___8 = kzalloc(168UL, 208U);
#line 1052
  vfbd = (struct vmw_framebuffer_dmabuf *)tmp___8;
  }
#line 1053
  if (! vfbd) {
#line 1054
    ret = -12;
#line 1055
    goto out_err1;
  } else {

  }
  {
#line 1058
  __cil_tmp58 = (struct drm_framebuffer *)vfbd;
#line 1058
  __cil_tmp59 = (struct drm_framebuffer_funcs    *)(& vmw_framebuffer_dmabuf_funcs);
#line 1058
  ret = drm_framebuffer_init(dev, __cil_tmp58, __cil_tmp59);
  }
#line 1060
  if (ret) {
#line 1061
    goto out_err2;
  } else {

  }
  {
#line 1063
  tmp___9 = vmw_dmabuf_reference(dmabuf);
  }
#line 1063
  if (tmp___9) {

  } else {
    {
#line 1064
    drm_err("vmw_kms_new_framebuffer_dmabuf", "failed to reference dmabuf %p\n", dmabuf);
    }
#line 1065
    goto out_err3;
  }
#line 1068
  __cil_tmp60 = 0 + 84;
#line 1068
  __cil_tmp61 = 0 + __cil_tmp60;
#line 1068
  __cil_tmp62 = (unsigned long )vfbd;
#line 1068
  __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
#line 1068
  __cil_tmp64 = (unsigned long )mode_cmd;
#line 1068
  __cil_tmp65 = __cil_tmp64 + 16;
#line 1068
  __cil_tmp66 = *((__u32    *)__cil_tmp65);
#line 1068
  *((int *)__cil_tmp63) = (int )__cil_tmp66;
#line 1069
  __cil_tmp67 = 0 * 4UL;
#line 1069
  __cil_tmp68 = 40 + __cil_tmp67;
#line 1069
  __cil_tmp69 = 0 + __cil_tmp68;
#line 1069
  __cil_tmp70 = 0 + __cil_tmp69;
#line 1069
  __cil_tmp71 = (unsigned long )vfbd;
#line 1069
  __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 1069
  __cil_tmp73 = (unsigned long )mode_cmd;
#line 1069
  __cil_tmp74 = __cil_tmp73 + 12;
#line 1069
  __cil_tmp75 = *((__u32    *)__cil_tmp74);
#line 1069
  *((unsigned int *)__cil_tmp72) = (unsigned int )__cil_tmp75;
#line 1070
  __cil_tmp76 = 0 + 80;
#line 1070
  __cil_tmp77 = 0 + __cil_tmp76;
#line 1070
  __cil_tmp78 = (unsigned long )vfbd;
#line 1070
  __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 1070
  __cil_tmp80 = (unsigned long )mode_cmd;
#line 1070
  __cil_tmp81 = __cil_tmp80 + 20;
#line 1070
  __cil_tmp82 = *((__u32    *)__cil_tmp81);
#line 1070
  *((unsigned int *)__cil_tmp79) = (unsigned int )__cil_tmp82;
#line 1071
  __cil_tmp83 = 0 + 72;
#line 1071
  __cil_tmp84 = 0 + __cil_tmp83;
#line 1071
  __cil_tmp85 = (unsigned long )vfbd;
#line 1071
  __cil_tmp86 = __cil_tmp85 + __cil_tmp84;
#line 1071
  __cil_tmp87 = (unsigned long )mode_cmd;
#line 1071
  __cil_tmp88 = __cil_tmp87 + 4;
#line 1071
  __cil_tmp89 = *((__u32    *)__cil_tmp88);
#line 1071
  *((unsigned int *)__cil_tmp86) = (unsigned int )__cil_tmp89;
#line 1072
  __cil_tmp90 = 0 + 76;
#line 1072
  __cil_tmp91 = 0 + __cil_tmp90;
#line 1072
  __cil_tmp92 = (unsigned long )vfbd;
#line 1072
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
#line 1072
  __cil_tmp94 = (unsigned long )mode_cmd;
#line 1072
  __cil_tmp95 = __cil_tmp94 + 8;
#line 1072
  __cil_tmp96 = *((__u32    *)__cil_tmp95);
#line 1072
  *((unsigned int *)__cil_tmp93) = (unsigned int )__cil_tmp96;
  {
#line 1073
  __cil_tmp97 = (unsigned long )dev_priv;
#line 1073
  __cil_tmp98 = __cil_tmp97 + 2616;
#line 1073
  __cil_tmp99 = *((struct vmw_screen_object_display **)__cil_tmp98);
#line 1073
  if (! __cil_tmp99) {
#line 1074
    __cil_tmp100 = 0 + 120;
#line 1074
    __cil_tmp101 = (unsigned long )vfbd;
#line 1074
    __cil_tmp102 = __cil_tmp101 + __cil_tmp100;
#line 1074
    *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp102) = & vmw_framebuffer_dmabuf_pin;
#line 1075
    __cil_tmp103 = 0 + 128;
#line 1075
    __cil_tmp104 = (unsigned long )vfbd;
#line 1075
    __cil_tmp105 = __cil_tmp104 + __cil_tmp103;
#line 1075
    *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp105) = & vmw_framebuffer_dmabuf_unpin;
  } else {

  }
  }
#line 1077
  __cil_tmp106 = 0 + 136;
#line 1077
  __cil_tmp107 = (unsigned long )vfbd;
#line 1077
  __cil_tmp108 = __cil_tmp107 + __cil_tmp106;
#line 1077
  *((bool *)__cil_tmp108) = (bool )1;
#line 1078
  __cil_tmp109 = (unsigned long )vfbd;
#line 1078
  __cil_tmp110 = __cil_tmp109 + 160;
#line 1078
  *((struct vmw_dma_buffer **)__cil_tmp110) = dmabuf;
#line 1079
  __cil_tmp111 = 0 + 152;
#line 1079
  __cil_tmp112 = (unsigned long )vfbd;
#line 1079
  __cil_tmp113 = __cil_tmp112 + __cil_tmp111;
#line 1079
  __cil_tmp114 = (unsigned long )mode_cmd;
#line 1079
  __cil_tmp115 = __cil_tmp114 + 24;
#line 1079
  __cil_tmp116 = *((__u32    *)__cil_tmp115);
#line 1079
  *((uint32_t *)__cil_tmp113) = (uint32_t )__cil_tmp116;
#line 1080
  *out = (struct vmw_framebuffer *)vfbd;
#line 1082
  return (0);
  out_err3: 
  {
#line 1085
  __cil_tmp117 = (struct drm_framebuffer *)vfbd;
#line 1085
  drm_framebuffer_cleanup(__cil_tmp117);
  }
  out_err2: 
  {
#line 1087
  __cil_tmp118 = (void    *)vfbd;
#line 1087
  kfree(__cil_tmp118);
  }
  out_err1: 
#line 1089
  return (ret);
}
}
#line 1096 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev , struct drm_file *file_priv ,
                                                 struct drm_mode_fb_cmd2 *mode_cmd2 ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_framebuffer *vfb ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *bo ;
  struct ttm_base_object *user_obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  int ret ;
  void *tmp___9 ;
  bool tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_framebuffer **__cil_tmp21 ;
  void *__cil_tmp22 ;
  struct vmw_surface **__cil_tmp23 ;
  void *__cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32 __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  __u32 *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  __u32 *__cil_tmp49 ;
  int *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  __u32 __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32 __cil_tmp54 ;
  struct ttm_base_object **__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  __u32 __cil_tmp57 ;
  void *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct ttm_base_object **__cil_tmp60 ;
  struct ttm_base_object *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  __u32 __cil_tmp68 ;
  struct vmw_dma_buffer **__cil_tmp69 ;
  struct vmw_dma_buffer **__cil_tmp70 ;
  struct vmw_dma_buffer *__cil_tmp71 ;
  struct drm_mode_fb_cmd    *__cil_tmp72 ;
  struct vmw_surface **__cil_tmp73 ;
  struct vmw_surface **__cil_tmp74 ;
  struct vmw_surface *__cil_tmp75 ;
  struct drm_mode_fb_cmd    *__cil_tmp76 ;
  struct vmw_dma_buffer **__cil_tmp77 ;
  struct vmw_surface **__cil_tmp78 ;
  long __cil_tmp79 ;
  struct vmw_framebuffer **__cil_tmp80 ;
  struct vmw_framebuffer *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct ttm_base_object **__cil_tmp84 ;
  struct vmw_framebuffer **__cil_tmp85 ;
  struct vmw_framebuffer *__cil_tmp86 ;

  {
  {
#line 1100
  tmp___7 = vmw_priv(dev);
#line 1100
  dev_priv = tmp___7;
#line 1101
  tmp___8 = vmw_fpriv(file_priv);
#line 1101
  __cil_tmp19 = (unsigned long )tmp___8;
#line 1101
  __cil_tmp20 = __cil_tmp19 + 8;
#line 1101
  tfile = *((struct ttm_object_file **)__cil_tmp20);
#line 1102
  __cil_tmp21 = & vfb;
#line 1102
  __cil_tmp22 = (void *)0;
#line 1102
  *__cil_tmp21 = (struct vmw_framebuffer *)__cil_tmp22;
#line 1103
  __cil_tmp23 = & surface;
#line 1103
  __cil_tmp24 = (void *)0;
#line 1103
  *__cil_tmp23 = (struct vmw_surface *)__cil_tmp24;
#line 1104
  __cil_tmp25 = & bo;
#line 1104
  __cil_tmp26 = (void *)0;
#line 1104
  *__cil_tmp25 = (struct vmw_dma_buffer *)__cil_tmp26;
#line 1109
  __cil_tmp27 = (unsigned long )(& mode_cmd) + 4;
#line 1109
  __cil_tmp28 = (unsigned long )mode_cmd2;
#line 1109
  __cil_tmp29 = __cil_tmp28 + 4;
#line 1109
  *((__u32 *)__cil_tmp27) = *((__u32 *)__cil_tmp29);
#line 1110
  __cil_tmp30 = (unsigned long )(& mode_cmd) + 8;
#line 1110
  __cil_tmp31 = (unsigned long )mode_cmd2;
#line 1110
  __cil_tmp32 = __cil_tmp31 + 8;
#line 1110
  *((__u32 *)__cil_tmp30) = *((__u32 *)__cil_tmp32);
#line 1111
  __cil_tmp33 = (unsigned long )(& mode_cmd) + 12;
#line 1111
  __cil_tmp34 = 0 * 4UL;
#line 1111
  __cil_tmp35 = 36 + __cil_tmp34;
#line 1111
  __cil_tmp36 = (unsigned long )mode_cmd2;
#line 1111
  __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
#line 1111
  *((__u32 *)__cil_tmp33) = *((__u32 *)__cil_tmp37);
#line 1112
  __cil_tmp38 = (unsigned long )(& mode_cmd) + 24;
#line 1112
  __cil_tmp39 = 0 * 4UL;
#line 1112
  __cil_tmp40 = 20 + __cil_tmp39;
#line 1112
  __cil_tmp41 = (unsigned long )mode_cmd2;
#line 1112
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 1112
  *((__u32 *)__cil_tmp38) = *((__u32 *)__cil_tmp42);
#line 1113
  __cil_tmp43 = (unsigned long )mode_cmd2;
#line 1113
  __cil_tmp44 = __cil_tmp43 + 12;
#line 1113
  __cil_tmp45 = *((__u32 *)__cil_tmp44);
#line 1113
  __cil_tmp46 = (unsigned long )(& mode_cmd) + 20;
#line 1113
  __cil_tmp47 = (__u32 *)__cil_tmp46;
#line 1113
  __cil_tmp48 = (unsigned long )(& mode_cmd) + 16;
#line 1113
  __cil_tmp49 = (__u32 *)__cil_tmp48;
#line 1113
  __cil_tmp50 = (int *)__cil_tmp49;
#line 1113
  drm_fb_get_bpp_depth(__cil_tmp45, __cil_tmp47, __cil_tmp50);
#line 1122
  __cil_tmp51 = (unsigned long )(& mode_cmd) + 12;
#line 1122
  __cil_tmp52 = *((__u32 *)__cil_tmp51);
#line 1122
  __cil_tmp53 = (unsigned long )(& mode_cmd) + 8;
#line 1122
  __cil_tmp54 = *((__u32 *)__cil_tmp53);
#line 1122
  tmp___10 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp52, __cil_tmp54);
  }
#line 1122
  if (tmp___10) {

  } else {
    {
#line 1125
    drm_err("vmw_kms_fb_create", "VRAM size is too small for requested mode.\n");
#line 1126
    tmp___9 = (void *)ERR_PTR(-12L);
    }
#line 1126
    return ((struct drm_framebuffer *)tmp___9);
  }
  {
#line 1138
  __cil_tmp55 = & user_obj;
#line 1138
  __cil_tmp56 = (unsigned long )(& mode_cmd) + 24;
#line 1138
  __cil_tmp57 = *((__u32 *)__cil_tmp56);
#line 1138
  *__cil_tmp55 = ttm_base_object_lookup(tfile, __cil_tmp57);
#line 1139
  __cil_tmp58 = (void *)0;
#line 1139
  __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1139
  __cil_tmp60 = & user_obj;
#line 1139
  __cil_tmp61 = *__cil_tmp60;
#line 1139
  __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 1139
  __cil_tmp63 = __cil_tmp62 == __cil_tmp59;
#line 1139
  __cil_tmp64 = ! __cil_tmp63;
#line 1139
  __cil_tmp65 = ! __cil_tmp64;
#line 1139
  __cil_tmp66 = (long )__cil_tmp65;
#line 1139
  tmp___12 = ldv__builtin_expect(__cil_tmp66, 0L);
  }
#line 1139
  if (tmp___12) {
    {
#line 1140
    drm_err("vmw_kms_fb_create", "Could not locate requested kms frame buffer.\n");
#line 1141
    tmp___11 = (void *)ERR_PTR(-2L);
    }
#line 1141
    return ((struct drm_framebuffer *)tmp___11);
  } else {

  }
  {
#line 1149
  __cil_tmp67 = (unsigned long )(& mode_cmd) + 24;
#line 1149
  __cil_tmp68 = *((__u32 *)__cil_tmp67);
#line 1149
  ret = vmw_user_lookup_handle(dev_priv, tfile, __cil_tmp68, & surface, & bo);
  }
#line 1152
  if (ret) {
#line 1153
    goto err_out;
  } else {

  }
  {
#line 1156
  __cil_tmp69 = & bo;
#line 1156
  if (*__cil_tmp69) {
    {
#line 1157
    __cil_tmp70 = & bo;
#line 1157
    __cil_tmp71 = *__cil_tmp70;
#line 1157
    __cil_tmp72 = (struct drm_mode_fb_cmd    *)(& mode_cmd);
#line 1157
    ret = vmw_kms_new_framebuffer_dmabuf(dev_priv, __cil_tmp71, & vfb, __cil_tmp72);
    }
  } else {
    {
#line 1159
    __cil_tmp73 = & surface;
#line 1159
    if (*__cil_tmp73) {
      {
#line 1160
      __cil_tmp74 = & surface;
#line 1160
      __cil_tmp75 = *__cil_tmp74;
#line 1160
      __cil_tmp76 = (struct drm_mode_fb_cmd    *)(& mode_cmd);
#line 1160
      ret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, __cil_tmp75, & vfb,
                                            __cil_tmp76);
      }
    } else {
      {
#line 1163
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1163
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1163), "i" (12UL));
        {
#line 1163
        while (1) {
          while_continue___0: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1163
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    }
  }
  }
  err_out: 
  {
#line 1167
  __cil_tmp77 = & bo;
#line 1167
  if (*__cil_tmp77) {
    {
#line 1168
    vmw_dmabuf_unreference(& bo);
    }
  } else {

  }
  }
  {
#line 1169
  __cil_tmp78 = & surface;
#line 1169
  if (*__cil_tmp78) {
    {
#line 1170
    vmw_surface_unreference(& surface);
    }
  } else {

  }
  }
#line 1172
  if (ret) {
    {
#line 1173
    drm_err("vmw_kms_fb_create", "failed to create vmw_framebuffer: %i\n", ret);
#line 1174
    ttm_base_object_unref(& user_obj);
#line 1175
    __cil_tmp79 = (long )ret;
#line 1175
    tmp___13 = (void *)ERR_PTR(__cil_tmp79);
    }
#line 1175
    return ((struct drm_framebuffer *)tmp___13);
  } else {
#line 1177
    __cil_tmp80 = & vfb;
#line 1177
    __cil_tmp81 = *__cil_tmp80;
#line 1177
    __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 1177
    __cil_tmp83 = __cil_tmp82 + 144;
#line 1177
    __cil_tmp84 = & user_obj;
#line 1177
    *((struct ttm_base_object **)__cil_tmp83) = *__cil_tmp84;
  }
  {
#line 1179
  __cil_tmp85 = & vfb;
#line 1179
  __cil_tmp86 = *__cil_tmp85;
#line 1179
  return ((struct drm_framebuffer *)__cil_tmp86);
  }
}
}
#line 1182 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static struct drm_mode_config_funcs vmw_kms_funcs  =    {& vmw_kms_fb_create, (void (*)(struct drm_device *dev ))0};
#line 1186 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *tmp___7 ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_434 *cmd ;
  SVGASignedRect *blits ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int tmp___8 ;
  struct drm_crtc    *__mptr___1 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  long tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  int __min1 ;
  int __min2 ;
  int tmp___16 ;
  int __max1 ;
  int __max2 ;
  int tmp___17 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___18 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___19 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___20 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_device *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  struct drm_crtc *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct list_head *__cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct drm_device *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  struct list_head *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct list_head *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct drm_framebuffer *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct drm_framebuffer *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct vmw_display_unit *__cil_tmp85 ;
  struct drm_crtc *__cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  struct drm_crtc *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct list_head *__cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  void *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  long __cil_tmp106 ;
  long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  void *__cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  void *__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  uint32_t __cil_tmp128 ;
  int32_t __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  uint32_t __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  uint32_t __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  int32_t __cil_tmp139 ;
  uint32_t __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  uint32_t __cil_tmp142 ;
  struct drm_vmw_rect *__cil_tmp143 ;
  struct drm_vmw_rect *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  uint32_t __cil_tmp147 ;
  struct drm_vmw_rect *__cil_tmp148 ;
  int32_t __cil_tmp149 ;
  uint32_t __cil_tmp150 ;
  uint32_t __cil_tmp151 ;
  struct drm_vmw_rect *__cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  struct drm_vmw_rect *__cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  struct drm_vmw_rect *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  int32_t __cil_tmp162 ;
  uint32_t __cil_tmp163 ;
  uint32_t __cil_tmp164 ;
  void *__cil_tmp165 ;
  struct __anonstruct_cmd_434 *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  uint32_t __cil_tmp182 ;
  struct drm_clip_rect *__cil_tmp183 ;
  struct drm_vmw_rect *__cil_tmp184 ;
  int32_t __cil_tmp185 ;
  int32_t __cil_tmp186 ;
  struct drm_clip_rect *__cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  uint32_t __cil_tmp190 ;
  struct drm_vmw_rect *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  uint32_t __cil_tmp194 ;
  struct drm_vmw_rect *__cil_tmp195 ;
  int32_t __cil_tmp196 ;
  uint32_t __cil_tmp197 ;
  uint32_t __cil_tmp198 ;
  uint32_t __cil_tmp199 ;
  struct drm_clip_rect *__cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  struct drm_vmw_rect *__cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  int32_t __cil_tmp206 ;
  int32_t __cil_tmp207 ;
  struct drm_clip_rect *__cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  uint32_t __cil_tmp211 ;
  struct drm_vmw_rect *__cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  uint32_t __cil_tmp215 ;
  struct drm_vmw_rect *__cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  int32_t __cil_tmp219 ;
  uint32_t __cil_tmp220 ;
  uint32_t __cil_tmp221 ;
  uint32_t __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  int __cil_tmp228 ;
  int __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  int __cil_tmp233 ;
  int __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  int __cil_tmp238 ;
  int __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  int __cil_tmp243 ;
  int __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  int __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  int __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  unsigned long __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  int __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  int __cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  int __cil_tmp287 ;
  int *__cil_tmp288 ;
  int __cil_tmp289 ;
  int *__cil_tmp290 ;
  int __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  size_t __cil_tmp297 ;
  void *__cil_tmp298 ;
  void *__cil_tmp299 ;
  uint32_t __cil_tmp300 ;
  uint64_t __cil_tmp301 ;
  void *__cil_tmp302 ;
  struct drm_vmw_fence_rep *__cil_tmp303 ;
  void *__cil_tmp304 ;
  struct vmw_fence_obj **__cil_tmp305 ;
  int __cil_tmp306 ;
  int __cil_tmp307 ;
  int __cil_tmp308 ;
  long __cil_tmp309 ;
  void    *__cil_tmp310 ;
  void    *__cil_tmp311 ;
  int clip_y2312 ;
  int clip_y1313 ;
  int clip_x2314 ;
  int clip_x1315 ;

  {
#line 1200
  ret = 0;
#line 1209
  num_units = 0;
#line 1210
  __cil_tmp51 = 1152 + 296;
#line 1210
  __cil_tmp52 = (unsigned long )dev_priv;
#line 1210
  __cil_tmp53 = __cil_tmp52 + 2088;
#line 1210
  __cil_tmp54 = *((struct drm_device **)__cil_tmp53);
#line 1210
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 1210
  __cil_tmp56 = __cil_tmp55 + __cil_tmp51;
#line 1210
  __cil_tmp57 = *((struct list_head **)__cil_tmp56);
#line 1210
  __mptr = (struct list_head    *)__cil_tmp57;
#line 1210
  __cil_tmp58 = (struct drm_crtc *)0;
#line 1210
  __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1210
  __cil_tmp60 = __cil_tmp59 + 8;
#line 1210
  __cil_tmp61 = (struct list_head *)__cil_tmp60;
#line 1210
  __cil_tmp62 = (unsigned int )__cil_tmp61;
#line 1210
  __cil_tmp63 = (char *)__mptr;
#line 1210
  __cil_tmp64 = __cil_tmp63 - __cil_tmp62;
#line 1210
  crtc = (struct drm_crtc *)__cil_tmp64;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1210
    __cil_tmp65 = 1152 + 296;
#line 1210
    __cil_tmp66 = (unsigned long )dev_priv;
#line 1210
    __cil_tmp67 = __cil_tmp66 + 2088;
#line 1210
    __cil_tmp68 = *((struct drm_device **)__cil_tmp67);
#line 1210
    __cil_tmp69 = (unsigned long )__cil_tmp68;
#line 1210
    __cil_tmp70 = __cil_tmp69 + __cil_tmp65;
#line 1210
    __cil_tmp71 = (struct list_head *)__cil_tmp70;
#line 1210
    __cil_tmp72 = (unsigned long )__cil_tmp71;
#line 1210
    __cil_tmp73 = (unsigned long )crtc;
#line 1210
    __cil_tmp74 = __cil_tmp73 + 8;
#line 1210
    __cil_tmp75 = (struct list_head *)__cil_tmp74;
#line 1210
    __cil_tmp76 = (unsigned long )__cil_tmp75;
#line 1210
    if (__cil_tmp76 != __cil_tmp72) {

    } else {
#line 1210
      goto while_break;
    }
    }
    {
#line 1211
    __cil_tmp77 = (struct drm_framebuffer *)vfb;
#line 1211
    __cil_tmp78 = (unsigned long )__cil_tmp77;
#line 1211
    __cil_tmp79 = (unsigned long )crtc;
#line 1211
    __cil_tmp80 = __cil_tmp79 + 32;
#line 1211
    __cil_tmp81 = *((struct drm_framebuffer **)__cil_tmp80);
#line 1211
    __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 1211
    if (__cil_tmp82 != __cil_tmp78) {
#line 1212
      goto __Cont;
    } else {

    }
    }
#line 1213
    tmp___8 = num_units;
#line 1213
    num_units = num_units + 1;
#line 1213
    __mptr___1 = (struct drm_crtc    *)crtc;
#line 1213
    __cil_tmp83 = tmp___8 * 8UL;
#line 1213
    __cil_tmp84 = (unsigned long )(units) + __cil_tmp83;
#line 1213
    __cil_tmp85 = (struct vmw_display_unit *)0;
#line 1213
    __cil_tmp86 = (struct drm_crtc *)__cil_tmp85;
#line 1213
    __cil_tmp87 = (unsigned int )__cil_tmp86;
#line 1213
    __cil_tmp88 = (char *)__mptr___1;
#line 1213
    __cil_tmp89 = __cil_tmp88 - __cil_tmp87;
#line 1213
    *((struct vmw_display_unit **)__cil_tmp84) = (struct vmw_display_unit *)__cil_tmp89;
    __Cont: /* CIL Label */ 
#line 1210
    __cil_tmp90 = (unsigned long )crtc;
#line 1210
    __cil_tmp91 = __cil_tmp90 + 8;
#line 1210
    __cil_tmp92 = *((struct list_head **)__cil_tmp91);
#line 1210
    __mptr___0 = (struct list_head    *)__cil_tmp92;
#line 1210
    __cil_tmp93 = (struct drm_crtc *)0;
#line 1210
    __cil_tmp94 = (unsigned long )__cil_tmp93;
#line 1210
    __cil_tmp95 = __cil_tmp94 + 8;
#line 1210
    __cil_tmp96 = (struct list_head *)__cil_tmp95;
#line 1210
    __cil_tmp97 = (unsigned int )__cil_tmp96;
#line 1210
    __cil_tmp98 = (char *)__mptr___0;
#line 1210
    __cil_tmp99 = __cil_tmp98 - __cil_tmp97;
#line 1210
    crtc = (struct drm_crtc *)__cil_tmp99;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1216
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1216
    __cil_tmp100 = (void *)0;
#line 1216
    __cil_tmp101 = (unsigned long )__cil_tmp100;
#line 1216
    __cil_tmp102 = (unsigned long )surface;
#line 1216
    __cil_tmp103 = __cil_tmp102 == __cil_tmp101;
#line 1216
    __cil_tmp104 = ! __cil_tmp103;
#line 1216
    __cil_tmp105 = ! __cil_tmp104;
#line 1216
    __cil_tmp106 = (long )__cil_tmp105;
#line 1216
    tmp___9 = ldv__builtin_expect(__cil_tmp106, 0L);
    }
#line 1216
    if (tmp___9) {
      {
#line 1216
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1216
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1216), "i" (12UL));
        {
#line 1216
        while (1) {
          while_continue___2: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1216
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 1216
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1217
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1217
    if (! clips) {
#line 1217
      tmp___10 = 1;
    } else
#line 1217
    if (! num_clips) {
#line 1217
      tmp___10 = 1;
    } else {
#line 1217
      tmp___10 = 0;
    }
    {
#line 1217
    __cil_tmp107 = (long )tmp___10;
#line 1217
    tmp___11 = ldv__builtin_expect(__cil_tmp107, 0L);
    }
#line 1217
    if (tmp___11) {
      {
#line 1217
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1217
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1217), "i" (12UL));
        {
#line 1217
        while (1) {
          while_continue___5: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1217
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {

    }
#line 1217
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1219
  __cil_tmp108 = (unsigned long )num_clips;
#line 1219
  __cil_tmp109 = 8UL * __cil_tmp108;
#line 1219
  tmp___12 = kzalloc(__cil_tmp109, 208U);
#line 1219
  tmp___7 = (struct drm_clip_rect *)tmp___12;
#line 1220
  __cil_tmp110 = (void *)0;
#line 1220
  __cil_tmp111 = (unsigned long )__cil_tmp110;
#line 1220
  __cil_tmp112 = (unsigned long )tmp___7;
#line 1220
  __cil_tmp113 = __cil_tmp112 == __cil_tmp111;
#line 1220
  __cil_tmp114 = ! __cil_tmp113;
#line 1220
  __cil_tmp115 = ! __cil_tmp114;
#line 1220
  __cil_tmp116 = (long )__cil_tmp115;
#line 1220
  tmp___13 = ldv__builtin_expect(__cil_tmp116, 0L);
  }
#line 1220
  if (tmp___13) {
    {
#line 1221
    drm_err("vmw_kms_present", "Temporary cliprect memory alloc failed.\n");
    }
#line 1222
    return (-12);
  } else {

  }
  {
#line 1225
  __cil_tmp117 = (unsigned long )num_clips;
#line 1225
  __cil_tmp118 = 16UL * __cil_tmp117;
#line 1225
  fifo_size = 56UL + __cil_tmp118;
#line 1226
  tmp___14 = kmalloc(fifo_size, 208U);
#line 1226
  cmd = (struct __anonstruct_cmd_434 *)tmp___14;
#line 1227
  __cil_tmp119 = (void *)0;
#line 1227
  __cil_tmp120 = (unsigned long )__cil_tmp119;
#line 1227
  __cil_tmp121 = (unsigned long )cmd;
#line 1227
  __cil_tmp122 = __cil_tmp121 == __cil_tmp120;
#line 1227
  __cil_tmp123 = ! __cil_tmp122;
#line 1227
  __cil_tmp124 = ! __cil_tmp123;
#line 1227
  __cil_tmp125 = (long )__cil_tmp124;
#line 1227
  tmp___15 = ldv__builtin_expect(__cil_tmp125, 0L);
  }
#line 1227
  if (tmp___15) {
    {
#line 1228
    drm_err("vmw_kms_present", "Failed to allocate temporary fifo memory.\n");
#line 1229
    ret = -12;
    }
#line 1230
    goto out_free_tmp;
  } else {

  }
#line 1233
  left = *((int32_t *)clips);
#line 1234
  __cil_tmp126 = (unsigned long )clips;
#line 1234
  __cil_tmp127 = __cil_tmp126 + 8;
#line 1234
  __cil_tmp128 = *((uint32_t *)__cil_tmp127);
#line 1234
  __cil_tmp129 = *((int32_t *)clips);
#line 1234
  __cil_tmp130 = (uint32_t )__cil_tmp129;
#line 1234
  __cil_tmp131 = __cil_tmp130 + __cil_tmp128;
#line 1234
  right = (int )__cil_tmp131;
#line 1235
  __cil_tmp132 = (unsigned long )clips;
#line 1235
  __cil_tmp133 = __cil_tmp132 + 4;
#line 1235
  top = *((int32_t *)__cil_tmp133);
#line 1236
  __cil_tmp134 = (unsigned long )clips;
#line 1236
  __cil_tmp135 = __cil_tmp134 + 12;
#line 1236
  __cil_tmp136 = *((uint32_t *)__cil_tmp135);
#line 1236
  __cil_tmp137 = (unsigned long )clips;
#line 1236
  __cil_tmp138 = __cil_tmp137 + 4;
#line 1236
  __cil_tmp139 = *((int32_t *)__cil_tmp138);
#line 1236
  __cil_tmp140 = (uint32_t )__cil_tmp139;
#line 1236
  __cil_tmp141 = __cil_tmp140 + __cil_tmp136;
#line 1236
  bottom = (int )__cil_tmp141;
#line 1238
  i = 1;
  {
#line 1238
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1238
    __cil_tmp142 = (uint32_t )i;
#line 1238
    if (__cil_tmp142 < num_clips) {

    } else {
#line 1238
      goto while_break___6;
    }
    }
#line 1239
    __min1 = left;
#line 1239
    __cil_tmp143 = clips + i;
#line 1239
    __min2 = *((int32_t *)__cil_tmp143);
#line 1239
    if (__min1 < __min2) {
#line 1239
      tmp___16 = __min1;
    } else {
#line 1239
      tmp___16 = __min2;
    }
#line 1239
    left = tmp___16;
#line 1240
    __max1 = right;
#line 1240
    __cil_tmp144 = clips + i;
#line 1240
    __cil_tmp145 = (unsigned long )__cil_tmp144;
#line 1240
    __cil_tmp146 = __cil_tmp145 + 8;
#line 1240
    __cil_tmp147 = *((uint32_t *)__cil_tmp146);
#line 1240
    __cil_tmp148 = clips + i;
#line 1240
    __cil_tmp149 = *((int32_t *)__cil_tmp148);
#line 1240
    __cil_tmp150 = (uint32_t )__cil_tmp149;
#line 1240
    __cil_tmp151 = __cil_tmp150 + __cil_tmp147;
#line 1240
    __max2 = (int )__cil_tmp151;
#line 1240
    if (__max1 > __max2) {
#line 1240
      tmp___17 = __max1;
    } else {
#line 1240
      tmp___17 = __max2;
    }
#line 1240
    right = tmp___17;
#line 1241
    __min1___0 = top;
#line 1241
    __cil_tmp152 = clips + i;
#line 1241
    __cil_tmp153 = (unsigned long )__cil_tmp152;
#line 1241
    __cil_tmp154 = __cil_tmp153 + 4;
#line 1241
    __min2___0 = *((int32_t *)__cil_tmp154);
#line 1241
    if (__min1___0 < __min2___0) {
#line 1241
      tmp___18 = __min1___0;
    } else {
#line 1241
      tmp___18 = __min2___0;
    }
#line 1241
    top = tmp___18;
#line 1242
    __max1___0 = bottom;
#line 1242
    __cil_tmp155 = clips + i;
#line 1242
    __cil_tmp156 = (unsigned long )__cil_tmp155;
#line 1242
    __cil_tmp157 = __cil_tmp156 + 12;
#line 1242
    __cil_tmp158 = *((uint32_t *)__cil_tmp157);
#line 1242
    __cil_tmp159 = clips + i;
#line 1242
    __cil_tmp160 = (unsigned long )__cil_tmp159;
#line 1242
    __cil_tmp161 = __cil_tmp160 + 4;
#line 1242
    __cil_tmp162 = *((int32_t *)__cil_tmp161);
#line 1242
    __cil_tmp163 = (uint32_t )__cil_tmp162;
#line 1242
    __cil_tmp164 = __cil_tmp163 + __cil_tmp158;
#line 1242
    __max2___0 = (int )__cil_tmp164;
#line 1242
    if (__max1___0 > __max2___0) {
#line 1242
      tmp___19 = __max1___0;
    } else {
#line 1242
      tmp___19 = __max2___0;
    }
#line 1242
    bottom = tmp___19;
#line 1238
    i = i + 1;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1246
  __cil_tmp165 = (void *)cmd;
#line 1246
  memset(__cil_tmp165, 0, fifo_size);
#line 1247
  *((uint32 *)cmd) = (__u32 )1069;
#line 1249
  __cil_tmp166 = cmd + 1;
#line 1249
  blits = (SVGASignedRect *)__cil_tmp166;
#line 1251
  __cil_tmp167 = 8 + 12;
#line 1251
  __cil_tmp168 = (unsigned long )cmd;
#line 1251
  __cil_tmp169 = __cil_tmp168 + __cil_tmp167;
#line 1251
  *((int32 *)__cil_tmp169) = left;
#line 1252
  __cil_tmp170 = 12 + 8;
#line 1252
  __cil_tmp171 = 8 + __cil_tmp170;
#line 1252
  __cil_tmp172 = (unsigned long )cmd;
#line 1252
  __cil_tmp173 = __cil_tmp172 + __cil_tmp171;
#line 1252
  *((int32 *)__cil_tmp173) = right;
#line 1253
  __cil_tmp174 = 12 + 4;
#line 1253
  __cil_tmp175 = 8 + __cil_tmp174;
#line 1253
  __cil_tmp176 = (unsigned long )cmd;
#line 1253
  __cil_tmp177 = __cil_tmp176 + __cil_tmp175;
#line 1253
  *((int32 *)__cil_tmp177) = top;
#line 1254
  __cil_tmp178 = 12 + 12;
#line 1254
  __cil_tmp179 = 8 + __cil_tmp178;
#line 1254
  __cil_tmp180 = (unsigned long )cmd;
#line 1254
  __cil_tmp181 = __cil_tmp180 + __cil_tmp179;
#line 1254
  *((int32 *)__cil_tmp181) = bottom;
#line 1256
  i = 0;
  }
  {
#line 1256
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 1256
    __cil_tmp182 = (uint32_t )i;
#line 1256
    if (__cil_tmp182 < num_clips) {

    } else {
#line 1256
      goto while_break___7;
    }
    }
#line 1257
    __cil_tmp183 = tmp___7 + i;
#line 1257
    __cil_tmp184 = clips + i;
#line 1257
    __cil_tmp185 = *((int32_t *)__cil_tmp184);
#line 1257
    __cil_tmp186 = __cil_tmp185 - left;
#line 1257
    *((unsigned short *)__cil_tmp183) = (unsigned short )__cil_tmp186;
#line 1258
    __cil_tmp187 = tmp___7 + i;
#line 1258
    __cil_tmp188 = (unsigned long )__cil_tmp187;
#line 1258
    __cil_tmp189 = __cil_tmp188 + 4;
#line 1258
    __cil_tmp190 = (uint32_t )left;
#line 1258
    __cil_tmp191 = clips + i;
#line 1258
    __cil_tmp192 = (unsigned long )__cil_tmp191;
#line 1258
    __cil_tmp193 = __cil_tmp192 + 8;
#line 1258
    __cil_tmp194 = *((uint32_t *)__cil_tmp193);
#line 1258
    __cil_tmp195 = clips + i;
#line 1258
    __cil_tmp196 = *((int32_t *)__cil_tmp195);
#line 1258
    __cil_tmp197 = (uint32_t )__cil_tmp196;
#line 1258
    __cil_tmp198 = __cil_tmp197 + __cil_tmp194;
#line 1258
    __cil_tmp199 = __cil_tmp198 - __cil_tmp190;
#line 1258
    *((unsigned short *)__cil_tmp189) = (unsigned short )__cil_tmp199;
#line 1259
    __cil_tmp200 = tmp___7 + i;
#line 1259
    __cil_tmp201 = (unsigned long )__cil_tmp200;
#line 1259
    __cil_tmp202 = __cil_tmp201 + 2;
#line 1259
    __cil_tmp203 = clips + i;
#line 1259
    __cil_tmp204 = (unsigned long )__cil_tmp203;
#line 1259
    __cil_tmp205 = __cil_tmp204 + 4;
#line 1259
    __cil_tmp206 = *((int32_t *)__cil_tmp205);
#line 1259
    __cil_tmp207 = __cil_tmp206 - top;
#line 1259
    *((unsigned short *)__cil_tmp202) = (unsigned short )__cil_tmp207;
#line 1260
    __cil_tmp208 = tmp___7 + i;
#line 1260
    __cil_tmp209 = (unsigned long )__cil_tmp208;
#line 1260
    __cil_tmp210 = __cil_tmp209 + 6;
#line 1260
    __cil_tmp211 = (uint32_t )top;
#line 1260
    __cil_tmp212 = clips + i;
#line 1260
    __cil_tmp213 = (unsigned long )__cil_tmp212;
#line 1260
    __cil_tmp214 = __cil_tmp213 + 12;
#line 1260
    __cil_tmp215 = *((uint32_t *)__cil_tmp214);
#line 1260
    __cil_tmp216 = clips + i;
#line 1260
    __cil_tmp217 = (unsigned long )__cil_tmp216;
#line 1260
    __cil_tmp218 = __cil_tmp217 + 4;
#line 1260
    __cil_tmp219 = *((int32_t *)__cil_tmp218);
#line 1260
    __cil_tmp220 = (uint32_t )__cil_tmp219;
#line 1260
    __cil_tmp221 = __cil_tmp220 + __cil_tmp215;
#line 1260
    __cil_tmp222 = __cil_tmp221 - __cil_tmp211;
#line 1260
    *((unsigned short *)__cil_tmp210) = (unsigned short )__cil_tmp222;
#line 1256
    i = i + 1;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1263
  k = 0;
  {
#line 1263
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1263
    if (k < num_units) {

    } else {
#line 1263
      goto while_break___8;
    }
#line 1264
    __cil_tmp223 = k * 8UL;
#line 1264
    __cil_tmp224 = (unsigned long )(units) + __cil_tmp223;
#line 1264
    unit = *((struct vmw_display_unit **)__cil_tmp224);
#line 1268
    __cil_tmp225 = 0 + 480;
#line 1268
    __cil_tmp226 = (unsigned long )unit;
#line 1268
    __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
#line 1268
    __cil_tmp228 = *((int *)__cil_tmp227);
#line 1268
    __cil_tmp229 = left + destX;
#line 1268
    clip_x1315 = __cil_tmp229 - __cil_tmp228;
#line 1269
    __cil_tmp230 = 0 + 484;
#line 1269
    __cil_tmp231 = (unsigned long )unit;
#line 1269
    __cil_tmp232 = __cil_tmp231 + __cil_tmp230;
#line 1269
    __cil_tmp233 = *((int *)__cil_tmp232);
#line 1269
    __cil_tmp234 = top + destY;
#line 1269
    clip_y1313 = __cil_tmp234 - __cil_tmp233;
#line 1270
    __cil_tmp235 = 0 + 480;
#line 1270
    __cil_tmp236 = (unsigned long )unit;
#line 1270
    __cil_tmp237 = __cil_tmp236 + __cil_tmp235;
#line 1270
    __cil_tmp238 = *((int *)__cil_tmp237);
#line 1270
    __cil_tmp239 = right + destX;
#line 1270
    clip_x2314 = __cil_tmp239 - __cil_tmp238;
#line 1271
    __cil_tmp240 = 0 + 484;
#line 1271
    __cil_tmp241 = (unsigned long )unit;
#line 1271
    __cil_tmp242 = __cil_tmp241 + __cil_tmp240;
#line 1271
    __cil_tmp243 = *((int *)__cil_tmp242);
#line 1271
    __cil_tmp244 = bottom + destY;
#line 1271
    clip_y2312 = __cil_tmp244 - __cil_tmp243;
    {
#line 1274
    __cil_tmp245 = 48 + 68;
#line 1274
    __cil_tmp246 = 0 + __cil_tmp245;
#line 1274
    __cil_tmp247 = (unsigned long )unit;
#line 1274
    __cil_tmp248 = __cil_tmp247 + __cil_tmp246;
#line 1274
    __cil_tmp249 = *((int *)__cil_tmp248);
#line 1274
    if (clip_x1315 >= __cil_tmp249) {
#line 1277
      goto __Cont___0;
    } else {
      {
#line 1274
      __cil_tmp250 = 48 + 88;
#line 1274
      __cil_tmp251 = 0 + __cil_tmp250;
#line 1274
      __cil_tmp252 = (unsigned long )unit;
#line 1274
      __cil_tmp253 = __cil_tmp252 + __cil_tmp251;
#line 1274
      __cil_tmp254 = *((int *)__cil_tmp253);
#line 1274
      if (clip_y1313 >= __cil_tmp254) {
#line 1277
        goto __Cont___0;
      } else
#line 1274
      if (clip_x2314 <= 0) {
#line 1277
        goto __Cont___0;
      } else
#line 1274
      if (clip_y2312 <= 0) {
#line 1277
        goto __Cont___0;
      } else {

      }
      }
    }
    }
    {
#line 1283
    __cil_tmp255 = 8 + 32;
#line 1283
    __cil_tmp256 = (unsigned long )cmd;
#line 1283
    __cil_tmp257 = __cil_tmp256 + __cil_tmp255;
#line 1283
    *((int32 *)__cil_tmp257) = clip_x1315;
#line 1284
    __cil_tmp258 = 32 + 8;
#line 1284
    __cil_tmp259 = 8 + __cil_tmp258;
#line 1284
    __cil_tmp260 = (unsigned long )cmd;
#line 1284
    __cil_tmp261 = __cil_tmp260 + __cil_tmp259;
#line 1284
    *((int32 *)__cil_tmp261) = clip_x2314;
#line 1285
    __cil_tmp262 = 32 + 4;
#line 1285
    __cil_tmp263 = 8 + __cil_tmp262;
#line 1285
    __cil_tmp264 = (unsigned long )cmd;
#line 1285
    __cil_tmp265 = __cil_tmp264 + __cil_tmp263;
#line 1285
    *((int32 *)__cil_tmp265) = clip_y1313;
#line 1286
    __cil_tmp266 = 32 + 12;
#line 1286
    __cil_tmp267 = 8 + __cil_tmp266;
#line 1286
    __cil_tmp268 = (unsigned long )cmd;
#line 1286
    __cil_tmp269 = __cil_tmp268 + __cil_tmp267;
#line 1286
    *((int32 *)__cil_tmp269) = clip_y2312;
#line 1289
    __cil_tmp270 = 48 + 68;
#line 1289
    __cil_tmp271 = 0 + __cil_tmp270;
#line 1289
    __cil_tmp272 = (unsigned long )unit;
#line 1289
    __cil_tmp273 = __cil_tmp272 + __cil_tmp271;
#line 1289
    __cil_tmp274 = *((int *)__cil_tmp273);
#line 1289
    clip_x2314 = __cil_tmp274 - clip_x1315;
#line 1290
    __cil_tmp275 = 48 + 88;
#line 1290
    __cil_tmp276 = 0 + __cil_tmp275;
#line 1290
    __cil_tmp277 = (unsigned long )unit;
#line 1290
    __cil_tmp278 = __cil_tmp277 + __cil_tmp276;
#line 1290
    __cil_tmp279 = *((int *)__cil_tmp278);
#line 1290
    clip_y2312 = __cil_tmp279 - clip_y1313;
#line 1291
    clip_x1315 = 0 - clip_x1315;
#line 1292
    clip_y1313 = 0 - clip_y1313;
#line 1295
    __cil_tmp280 = (unsigned long )cmd;
#line 1295
    __cil_tmp281 = __cil_tmp280 + 8;
#line 1295
    *((uint32 *)__cil_tmp281) = sid;
#line 1296
    __cil_tmp282 = 8 + 28;
#line 1296
    __cil_tmp283 = (unsigned long )cmd;
#line 1296
    __cil_tmp284 = __cil_tmp283 + __cil_tmp282;
#line 1296
    __cil_tmp285 = (unsigned long )unit;
#line 1296
    __cil_tmp286 = __cil_tmp285 + 2032;
#line 1296
    *((uint32 *)__cil_tmp284) = *((unsigned int *)__cil_tmp286);
#line 1299
    __cil_tmp287 = (int )num_clips;
#line 1299
    vmw_clip_cliprects(tmp___7, __cil_tmp287, clip_x1315, clip_x2314, clip_y1313,
                       clip_y2312, blits, & num);
    }
    {
#line 1302
    __cil_tmp288 = & num;
#line 1302
    __cil_tmp289 = *__cil_tmp288;
#line 1302
    if (__cil_tmp289 == 0) {
#line 1303
      goto __Cont___0;
    } else {

    }
    }
    {
#line 1306
    __cil_tmp290 = & num;
#line 1306
    __cil_tmp291 = *__cil_tmp290;
#line 1306
    __cil_tmp292 = (unsigned long )__cil_tmp291;
#line 1306
    __cil_tmp293 = 16UL * __cil_tmp292;
#line 1306
    fifo_size = 56UL + __cil_tmp293;
#line 1307
    __cil_tmp294 = 0 + 4;
#line 1307
    __cil_tmp295 = (unsigned long )cmd;
#line 1307
    __cil_tmp296 = __cil_tmp295 + __cil_tmp294;
#line 1307
    __cil_tmp297 = fifo_size - 8UL;
#line 1307
    *((uint32 *)__cil_tmp296) = (__u32 )__cil_tmp297;
#line 1308
    __cil_tmp298 = (void *)0;
#line 1308
    __cil_tmp299 = (void *)cmd;
#line 1308
    __cil_tmp300 = (uint32_t )fifo_size;
#line 1308
    __cil_tmp301 = (uint64_t )0;
#line 1308
    __cil_tmp302 = (void *)0;
#line 1308
    __cil_tmp303 = (struct drm_vmw_fence_rep *)__cil_tmp302;
#line 1308
    __cil_tmp304 = (void *)0;
#line 1308
    __cil_tmp305 = (struct vmw_fence_obj **)__cil_tmp304;
#line 1308
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp298, __cil_tmp299, __cil_tmp300,
                              __cil_tmp301, __cil_tmp303, __cil_tmp305);
#line 1311
    __cil_tmp306 = ret != 0;
#line 1311
    __cil_tmp307 = ! __cil_tmp306;
#line 1311
    __cil_tmp308 = ! __cil_tmp307;
#line 1311
    __cil_tmp309 = (long )__cil_tmp308;
#line 1311
    tmp___20 = ldv__builtin_expect(__cil_tmp309, 0L);
    }
#line 1311
    if (tmp___20) {
#line 1312
      goto while_break___8;
    } else {

    }
    __Cont___0: /* CIL Label */ 
#line 1263
    k = k + 1;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1315
  __cil_tmp310 = (void    *)cmd;
#line 1315
  kfree(__cil_tmp310);
  }
  out_free_tmp: 
  {
#line 1317
  __cil_tmp311 = (void    *)tmp___7;
#line 1317
  kfree(__cil_tmp311);
  }
#line 1319
  return (ret);
}
}
#line 1322 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer    *__mptr ;
  struct vmw_dma_buffer *dmabuf ;
  struct vmw_display_unit *units[8] ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int ret ;
  int num_units ;
  int blits_pos ;
  struct __anonstruct_cmd_435 *cmd ;
  struct __anonstruct_blits_436 *blits ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  int tmp___7 ;
  struct drm_crtc    *__mptr___2 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  struct drm_vmw_rect *c ;
  int clip_x1 ;
  int clip_x2 ;
  int clip_y1 ;
  int clip_y2 ;
  int dest_x ;
  int dest_y ;
  int _max1 ;
  int _max2 ;
  int tmp___13 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___14 ;
  int _min1 ;
  int _min2 ;
  int tmp___15 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___16 ;
  struct drm_framebuffer *__cil_tmp48 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp49 ;
  struct drm_framebuffer *__cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct drm_device *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct list_head *__cil_tmp62 ;
  struct drm_crtc *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct drm_device *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct list_head *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct drm_framebuffer *__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct drm_framebuffer *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct vmw_display_unit *__cil_tmp90 ;
  struct drm_crtc *__cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct list_head *__cil_tmp97 ;
  struct drm_crtc *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  struct list_head *__cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  void *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  long __cil_tmp111 ;
  long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  void *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  long __cil_tmp123 ;
  void *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  int __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  struct __anonstruct_cmd_435 *__cil_tmp163 ;
  void *__cil_tmp164 ;
  uint32_t __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  struct vmw_display_unit *__cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  int __cil_tmp172 ;
  int32_t __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  uint32_t __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  struct vmw_display_unit *__cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  int __cil_tmp183 ;
  int32_t __cil_tmp184 ;
  int32_t __cil_tmp185 ;
  uint32_t __cil_tmp186 ;
  uint32_t __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  struct vmw_display_unit *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  int __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  int32_t __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint32_t __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  struct vmw_display_unit *__cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  int __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  int32_t __cil_tmp210 ;
  int32_t __cil_tmp211 ;
  uint32_t __cil_tmp212 ;
  uint32_t __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  int __cil_tmp216 ;
  int __cil_tmp217 ;
  int *__cil_tmp218 ;
  int *__cil_tmp219 ;
  int *__cil_tmp220 ;
  int __cil_tmp221 ;
  int *__cil_tmp222 ;
  int __cil_tmp223 ;
  int *__cil_tmp224 ;
  int *__cil_tmp225 ;
  int *__cil_tmp226 ;
  int *__cil_tmp227 ;
  int *__cil_tmp228 ;
  int __cil_tmp229 ;
  int *__cil_tmp230 ;
  int __cil_tmp231 ;
  int *__cil_tmp232 ;
  int *__cil_tmp233 ;
  int *__cil_tmp234 ;
  int *__cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct vmw_display_unit *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  int *__cil_tmp243 ;
  int __cil_tmp244 ;
  int *__cil_tmp245 ;
  int __cil_tmp246 ;
  int *__cil_tmp247 ;
  int *__cil_tmp248 ;
  int *__cil_tmp249 ;
  int *__cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  struct vmw_display_unit *__cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  int *__cil_tmp258 ;
  int __cil_tmp259 ;
  int *__cil_tmp260 ;
  int __cil_tmp261 ;
  int *__cil_tmp262 ;
  int *__cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  struct vmw_display_unit *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  int __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  struct vmw_display_unit *__cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  int __cil_tmp279 ;
  struct __anonstruct_blits_436 *__cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  struct __anonstruct_blits_436 *__cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  struct vmw_display_unit *__cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  struct __anonstruct_blits_436 *__cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  struct __anonstruct_blits_436 *__cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  struct __anonstruct_blits_436 *__cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  struct __anonstruct_blits_436 *__cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  unsigned long __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  struct __anonstruct_blits_436 *__cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct __anonstruct_blits_436 *__cil_tmp314 ;
  unsigned long __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  unsigned long __cil_tmp318 ;
  void *__cil_tmp319 ;
  void *__cil_tmp320 ;
  uint32_t __cil_tmp321 ;
  uint64_t __cil_tmp322 ;
  void *__cil_tmp323 ;
  struct vmw_fence_obj **__cil_tmp324 ;
  void    *__cil_tmp325 ;

  {
#line 1330
  __cil_tmp48 = (struct drm_framebuffer *)vfb;
#line 1330
  __mptr = (struct drm_framebuffer    *)__cil_tmp48;
#line 1330
  __cil_tmp49 = (struct vmw_framebuffer_dmabuf *)0;
#line 1330
  __cil_tmp50 = (struct drm_framebuffer *)__cil_tmp49;
#line 1330
  __cil_tmp51 = (unsigned int )__cil_tmp50;
#line 1330
  __cil_tmp52 = (char *)__mptr;
#line 1330
  __cil_tmp53 = __cil_tmp52 - __cil_tmp51;
#line 1330
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp53;
#line 1331
  __cil_tmp54 = (unsigned long )vfbd;
#line 1331
  __cil_tmp55 = __cil_tmp54 + 160;
#line 1331
  dmabuf = *((struct vmw_dma_buffer **)__cil_tmp55);
#line 1346
  num_units = 0;
#line 1347
  __cil_tmp56 = 1152 + 296;
#line 1347
  __cil_tmp57 = (unsigned long )dev_priv;
#line 1347
  __cil_tmp58 = __cil_tmp57 + 2088;
#line 1347
  __cil_tmp59 = *((struct drm_device **)__cil_tmp58);
#line 1347
  __cil_tmp60 = (unsigned long )__cil_tmp59;
#line 1347
  __cil_tmp61 = __cil_tmp60 + __cil_tmp56;
#line 1347
  __cil_tmp62 = *((struct list_head **)__cil_tmp61);
#line 1347
  __mptr___0 = (struct list_head    *)__cil_tmp62;
#line 1347
  __cil_tmp63 = (struct drm_crtc *)0;
#line 1347
  __cil_tmp64 = (unsigned long )__cil_tmp63;
#line 1347
  __cil_tmp65 = __cil_tmp64 + 8;
#line 1347
  __cil_tmp66 = (struct list_head *)__cil_tmp65;
#line 1347
  __cil_tmp67 = (unsigned int )__cil_tmp66;
#line 1347
  __cil_tmp68 = (char *)__mptr___0;
#line 1347
  __cil_tmp69 = __cil_tmp68 - __cil_tmp67;
#line 1347
  crtc = (struct drm_crtc *)__cil_tmp69;
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1347
    __cil_tmp70 = 1152 + 296;
#line 1347
    __cil_tmp71 = (unsigned long )dev_priv;
#line 1347
    __cil_tmp72 = __cil_tmp71 + 2088;
#line 1347
    __cil_tmp73 = *((struct drm_device **)__cil_tmp72);
#line 1347
    __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 1347
    __cil_tmp75 = __cil_tmp74 + __cil_tmp70;
#line 1347
    __cil_tmp76 = (struct list_head *)__cil_tmp75;
#line 1347
    __cil_tmp77 = (unsigned long )__cil_tmp76;
#line 1347
    __cil_tmp78 = (unsigned long )crtc;
#line 1347
    __cil_tmp79 = __cil_tmp78 + 8;
#line 1347
    __cil_tmp80 = (struct list_head *)__cil_tmp79;
#line 1347
    __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 1347
    if (__cil_tmp81 != __cil_tmp77) {

    } else {
#line 1347
      goto while_break;
    }
    }
    {
#line 1348
    __cil_tmp82 = (struct drm_framebuffer *)vfb;
#line 1348
    __cil_tmp83 = (unsigned long )__cil_tmp82;
#line 1348
    __cil_tmp84 = (unsigned long )crtc;
#line 1348
    __cil_tmp85 = __cil_tmp84 + 32;
#line 1348
    __cil_tmp86 = *((struct drm_framebuffer **)__cil_tmp85);
#line 1348
    __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 1348
    if (__cil_tmp87 != __cil_tmp83) {
#line 1349
      goto __Cont;
    } else {

    }
    }
#line 1350
    tmp___7 = num_units;
#line 1350
    num_units = num_units + 1;
#line 1350
    __mptr___2 = (struct drm_crtc    *)crtc;
#line 1350
    __cil_tmp88 = tmp___7 * 8UL;
#line 1350
    __cil_tmp89 = (unsigned long )(units) + __cil_tmp88;
#line 1350
    __cil_tmp90 = (struct vmw_display_unit *)0;
#line 1350
    __cil_tmp91 = (struct drm_crtc *)__cil_tmp90;
#line 1350
    __cil_tmp92 = (unsigned int )__cil_tmp91;
#line 1350
    __cil_tmp93 = (char *)__mptr___2;
#line 1350
    __cil_tmp94 = __cil_tmp93 - __cil_tmp92;
#line 1350
    *((struct vmw_display_unit **)__cil_tmp89) = (struct vmw_display_unit *)__cil_tmp94;
    __Cont: /* CIL Label */ 
#line 1347
    __cil_tmp95 = (unsigned long )crtc;
#line 1347
    __cil_tmp96 = __cil_tmp95 + 8;
#line 1347
    __cil_tmp97 = *((struct list_head **)__cil_tmp96);
#line 1347
    __mptr___1 = (struct list_head    *)__cil_tmp97;
#line 1347
    __cil_tmp98 = (struct drm_crtc *)0;
#line 1347
    __cil_tmp99 = (unsigned long )__cil_tmp98;
#line 1347
    __cil_tmp100 = __cil_tmp99 + 8;
#line 1347
    __cil_tmp101 = (struct list_head *)__cil_tmp100;
#line 1347
    __cil_tmp102 = (unsigned int )__cil_tmp101;
#line 1347
    __cil_tmp103 = (char *)__mptr___1;
#line 1347
    __cil_tmp104 = __cil_tmp103 - __cil_tmp102;
#line 1347
    crtc = (struct drm_crtc *)__cil_tmp104;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1353
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1353
    __cil_tmp105 = (void *)0;
#line 1353
    __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 1353
    __cil_tmp107 = (unsigned long )dmabuf;
#line 1353
    __cil_tmp108 = __cil_tmp107 == __cil_tmp106;
#line 1353
    __cil_tmp109 = ! __cil_tmp108;
#line 1353
    __cil_tmp110 = ! __cil_tmp109;
#line 1353
    __cil_tmp111 = (long )__cil_tmp110;
#line 1353
    tmp___8 = ldv__builtin_expect(__cil_tmp111, 0L);
    }
#line 1353
    if (tmp___8) {
      {
#line 1353
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1353
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1353), "i" (12UL));
        {
#line 1353
        while (1) {
          while_continue___2: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1353
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 1353
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1354
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1354
    if (! clips) {
#line 1354
      tmp___9 = 1;
    } else
#line 1354
    if (! num_clips) {
#line 1354
      tmp___9 = 1;
    } else {
#line 1354
      tmp___9 = 0;
    }
    {
#line 1354
    __cil_tmp112 = (long )tmp___9;
#line 1354
    tmp___10 = ldv__builtin_expect(__cil_tmp112, 0L);
    }
#line 1354
    if (tmp___10) {
      {
#line 1354
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1354
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1354), "i" (12UL));
        {
#line 1354
        while (1) {
          while_continue___5: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1354
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {

    }
#line 1354
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1357
  __cil_tmp113 = (unsigned long )num_units;
#line 1357
  __cil_tmp114 = (unsigned long )num_clips;
#line 1357
  __cil_tmp115 = 32UL * __cil_tmp114;
#line 1357
  __cil_tmp116 = __cil_tmp115 * __cil_tmp113;
#line 1357
  fifo_size = 20UL + __cil_tmp116;
#line 1358
  tmp___11 = kmalloc(fifo_size, 208U);
#line 1358
  cmd = (struct __anonstruct_cmd_435 *)tmp___11;
#line 1359
  __cil_tmp117 = (void *)0;
#line 1359
  __cil_tmp118 = (unsigned long )__cil_tmp117;
#line 1359
  __cil_tmp119 = (unsigned long )cmd;
#line 1359
  __cil_tmp120 = __cil_tmp119 == __cil_tmp118;
#line 1359
  __cil_tmp121 = ! __cil_tmp120;
#line 1359
  __cil_tmp122 = ! __cil_tmp121;
#line 1359
  __cil_tmp123 = (long )__cil_tmp122;
#line 1359
  tmp___12 = ldv__builtin_expect(__cil_tmp123, 0L);
  }
#line 1359
  if (tmp___12) {
    {
#line 1360
    drm_err("vmw_kms_readback", "Failed to allocate temporary fifo memory.\n");
    }
#line 1361
    return (-12);
  } else {

  }
  {
#line 1364
  __cil_tmp124 = (void *)cmd;
#line 1364
  memset(__cil_tmp124, 0, fifo_size);
#line 1365
  *((uint32_t *)cmd) = (uint32_t )36;
#line 1366
  __cil_tmp125 = 4 + 12;
#line 1366
  __cil_tmp126 = (unsigned long )cmd;
#line 1366
  __cil_tmp127 = __cil_tmp126 + __cil_tmp125;
#line 1366
  __cil_tmp128 = 0 + 84;
#line 1366
  __cil_tmp129 = (unsigned long )vfb;
#line 1366
  __cil_tmp130 = __cil_tmp129 + __cil_tmp128;
#line 1366
  __cil_tmp131 = *((int *)__cil_tmp130);
#line 1366
  *((uint32 *)__cil_tmp127) = (uint32 )__cil_tmp131;
#line 1367
  __cil_tmp132 = 0 + 1;
#line 1367
  __cil_tmp133 = 0 + __cil_tmp132;
#line 1367
  __cil_tmp134 = 12 + __cil_tmp133;
#line 1367
  __cil_tmp135 = 4 + __cil_tmp134;
#line 1367
  __cil_tmp136 = (unsigned long )cmd;
#line 1367
  __cil_tmp137 = __cil_tmp136 + __cil_tmp135;
#line 1367
  __cil_tmp138 = 0 + 80;
#line 1367
  __cil_tmp139 = (unsigned long )vfb;
#line 1367
  __cil_tmp140 = __cil_tmp139 + __cil_tmp138;
#line 1367
  *((uint32 *)__cil_tmp137) = *((unsigned int *)__cil_tmp140);
#line 1368
  __cil_tmp141 = 0 + 2;
#line 1368
  __cil_tmp142 = 0 + __cil_tmp141;
#line 1368
  __cil_tmp143 = 12 + __cil_tmp142;
#line 1368
  __cil_tmp144 = 4 + __cil_tmp143;
#line 1368
  __cil_tmp145 = (unsigned long )cmd;
#line 1368
  __cil_tmp146 = __cil_tmp145 + __cil_tmp144;
#line 1368
  *((uint32 *)__cil_tmp146) = (uint32 )0;
#line 1369
  __cil_tmp147 = 4 + 8;
#line 1369
  __cil_tmp148 = (unsigned long )cmd;
#line 1369
  __cil_tmp149 = __cil_tmp148 + __cil_tmp147;
#line 1369
  __cil_tmp150 = 0 * 4UL;
#line 1369
  __cil_tmp151 = 40 + __cil_tmp150;
#line 1369
  __cil_tmp152 = 0 + __cil_tmp151;
#line 1369
  __cil_tmp153 = (unsigned long )vfb;
#line 1369
  __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
#line 1369
  *((uint32 *)__cil_tmp149) = *((unsigned int *)__cil_tmp154);
#line 1370
  __cil_tmp155 = (unsigned long )cmd;
#line 1370
  __cil_tmp156 = __cil_tmp155 + 4;
#line 1370
  __cil_tmp157 = (unsigned long )vfb;
#line 1370
  __cil_tmp158 = __cil_tmp157 + 152;
#line 1370
  *((uint32 *)__cil_tmp156) = *((uint32_t *)__cil_tmp158);
#line 1371
  __cil_tmp159 = 0 + 4;
#line 1371
  __cil_tmp160 = 4 + __cil_tmp159;
#line 1371
  __cil_tmp161 = (unsigned long )cmd;
#line 1371
  __cil_tmp162 = __cil_tmp161 + __cil_tmp160;
#line 1371
  *((uint32 *)__cil_tmp162) = (uint32 )0;
#line 1373
  __cil_tmp163 = cmd + 1;
#line 1373
  __cil_tmp164 = (void *)__cil_tmp163;
#line 1373
  blits = (struct __anonstruct_blits_436 *)__cil_tmp164;
#line 1374
  blits_pos = 0;
#line 1375
  i = 0;
  }
  {
#line 1375
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1375
    if (i < num_units) {

    } else {
#line 1375
      goto while_break___6;
    }
#line 1376
    c = clips;
#line 1377
    k = 0;
    {
#line 1377
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1377
      __cil_tmp165 = (uint32_t )k;
#line 1377
      if (__cil_tmp165 < num_clips) {

      } else {
#line 1377
        goto while_break___7;
      }
      }
#line 1379
      __cil_tmp166 = 0 + 480;
#line 1379
      __cil_tmp167 = i * 8UL;
#line 1379
      __cil_tmp168 = (unsigned long )(units) + __cil_tmp167;
#line 1379
      __cil_tmp169 = *((struct vmw_display_unit **)__cil_tmp168);
#line 1379
      __cil_tmp170 = (unsigned long )__cil_tmp169;
#line 1379
      __cil_tmp171 = __cil_tmp170 + __cil_tmp166;
#line 1379
      __cil_tmp172 = *((int *)__cil_tmp171);
#line 1379
      __cil_tmp173 = *((int32_t *)c);
#line 1379
      clip_x1 = __cil_tmp173 - __cil_tmp172;
#line 1380
      __cil_tmp174 = (unsigned long )c;
#line 1380
      __cil_tmp175 = __cil_tmp174 + 8;
#line 1380
      __cil_tmp176 = *((uint32_t *)__cil_tmp175);
#line 1380
      __cil_tmp177 = 0 + 480;
#line 1380
      __cil_tmp178 = i * 8UL;
#line 1380
      __cil_tmp179 = (unsigned long )(units) + __cil_tmp178;
#line 1380
      __cil_tmp180 = *((struct vmw_display_unit **)__cil_tmp179);
#line 1380
      __cil_tmp181 = (unsigned long )__cil_tmp180;
#line 1380
      __cil_tmp182 = __cil_tmp181 + __cil_tmp177;
#line 1380
      __cil_tmp183 = *((int *)__cil_tmp182);
#line 1380
      __cil_tmp184 = *((int32_t *)c);
#line 1380
      __cil_tmp185 = __cil_tmp184 - __cil_tmp183;
#line 1380
      __cil_tmp186 = (uint32_t )__cil_tmp185;
#line 1380
      __cil_tmp187 = __cil_tmp186 + __cil_tmp176;
#line 1380
      clip_x2 = (int )__cil_tmp187;
#line 1381
      __cil_tmp188 = 0 + 484;
#line 1381
      __cil_tmp189 = i * 8UL;
#line 1381
      __cil_tmp190 = (unsigned long )(units) + __cil_tmp189;
#line 1381
      __cil_tmp191 = *((struct vmw_display_unit **)__cil_tmp190);
#line 1381
      __cil_tmp192 = (unsigned long )__cil_tmp191;
#line 1381
      __cil_tmp193 = __cil_tmp192 + __cil_tmp188;
#line 1381
      __cil_tmp194 = *((int *)__cil_tmp193);
#line 1381
      __cil_tmp195 = (unsigned long )c;
#line 1381
      __cil_tmp196 = __cil_tmp195 + 4;
#line 1381
      __cil_tmp197 = *((int32_t *)__cil_tmp196);
#line 1381
      clip_y1 = __cil_tmp197 - __cil_tmp194;
#line 1382
      __cil_tmp198 = (unsigned long )c;
#line 1382
      __cil_tmp199 = __cil_tmp198 + 12;
#line 1382
      __cil_tmp200 = *((uint32_t *)__cil_tmp199);
#line 1382
      __cil_tmp201 = 0 + 484;
#line 1382
      __cil_tmp202 = i * 8UL;
#line 1382
      __cil_tmp203 = (unsigned long )(units) + __cil_tmp202;
#line 1382
      __cil_tmp204 = *((struct vmw_display_unit **)__cil_tmp203);
#line 1382
      __cil_tmp205 = (unsigned long )__cil_tmp204;
#line 1382
      __cil_tmp206 = __cil_tmp205 + __cil_tmp201;
#line 1382
      __cil_tmp207 = *((int *)__cil_tmp206);
#line 1382
      __cil_tmp208 = (unsigned long )c;
#line 1382
      __cil_tmp209 = __cil_tmp208 + 4;
#line 1382
      __cil_tmp210 = *((int32_t *)__cil_tmp209);
#line 1382
      __cil_tmp211 = __cil_tmp210 - __cil_tmp207;
#line 1382
      __cil_tmp212 = (uint32_t )__cil_tmp211;
#line 1382
      __cil_tmp213 = __cil_tmp212 + __cil_tmp200;
#line 1382
      clip_y2 = (int )__cil_tmp213;
#line 1383
      dest_x = *((int32_t *)c);
#line 1384
      __cil_tmp214 = (unsigned long )c;
#line 1384
      __cil_tmp215 = __cil_tmp214 + 4;
#line 1384
      dest_y = *((int32_t *)__cil_tmp215);
#line 1389
      if (clip_x1 < 0) {
#line 1390
        __cil_tmp216 = - clip_x1;
#line 1390
        dest_x = dest_x + __cil_tmp216;
      } else {

      }
#line 1391
      if (clip_y1 < 0) {
#line 1392
        __cil_tmp217 = - clip_y1;
#line 1392
        dest_y = dest_y + __cil_tmp217;
      } else {

      }
#line 1395
      __cil_tmp218 = & _max1;
#line 1395
      *__cil_tmp218 = clip_x1;
#line 1395
      __cil_tmp219 = & _max2;
#line 1395
      *__cil_tmp219 = 0;
      {
#line 1395
      __cil_tmp220 = & _max2;
#line 1395
      __cil_tmp221 = *__cil_tmp220;
#line 1395
      __cil_tmp222 = & _max1;
#line 1395
      __cil_tmp223 = *__cil_tmp222;
#line 1395
      if (__cil_tmp223 > __cil_tmp221) {
#line 1395
        __cil_tmp224 = & _max1;
#line 1395
        tmp___13 = *__cil_tmp224;
      } else {
#line 1395
        __cil_tmp225 = & _max2;
#line 1395
        tmp___13 = *__cil_tmp225;
      }
      }
#line 1395
      clip_x1 = tmp___13;
#line 1396
      __cil_tmp226 = & _max1___0;
#line 1396
      *__cil_tmp226 = clip_y1;
#line 1396
      __cil_tmp227 = & _max2___0;
#line 1396
      *__cil_tmp227 = 0;
      {
#line 1396
      __cil_tmp228 = & _max2___0;
#line 1396
      __cil_tmp229 = *__cil_tmp228;
#line 1396
      __cil_tmp230 = & _max1___0;
#line 1396
      __cil_tmp231 = *__cil_tmp230;
#line 1396
      if (__cil_tmp231 > __cil_tmp229) {
#line 1396
        __cil_tmp232 = & _max1___0;
#line 1396
        tmp___14 = *__cil_tmp232;
      } else {
#line 1396
        __cil_tmp233 = & _max2___0;
#line 1396
        tmp___14 = *__cil_tmp233;
      }
      }
#line 1396
      clip_y1 = tmp___14;
#line 1397
      __cil_tmp234 = & _min1;
#line 1397
      *__cil_tmp234 = clip_x2;
#line 1397
      __cil_tmp235 = & _min2;
#line 1397
      __cil_tmp236 = 48 + 68;
#line 1397
      __cil_tmp237 = 0 + __cil_tmp236;
#line 1397
      __cil_tmp238 = i * 8UL;
#line 1397
      __cil_tmp239 = (unsigned long )(units) + __cil_tmp238;
#line 1397
      __cil_tmp240 = *((struct vmw_display_unit **)__cil_tmp239);
#line 1397
      __cil_tmp241 = (unsigned long )__cil_tmp240;
#line 1397
      __cil_tmp242 = __cil_tmp241 + __cil_tmp237;
#line 1397
      *__cil_tmp235 = *((int *)__cil_tmp242);
      {
#line 1397
      __cil_tmp243 = & _min2;
#line 1397
      __cil_tmp244 = *__cil_tmp243;
#line 1397
      __cil_tmp245 = & _min1;
#line 1397
      __cil_tmp246 = *__cil_tmp245;
#line 1397
      if (__cil_tmp246 < __cil_tmp244) {
#line 1397
        __cil_tmp247 = & _min1;
#line 1397
        tmp___15 = *__cil_tmp247;
      } else {
#line 1397
        __cil_tmp248 = & _min2;
#line 1397
        tmp___15 = *__cil_tmp248;
      }
      }
#line 1397
      clip_x2 = tmp___15;
#line 1398
      __cil_tmp249 = & _min1___0;
#line 1398
      *__cil_tmp249 = clip_y2;
#line 1398
      __cil_tmp250 = & _min2___0;
#line 1398
      __cil_tmp251 = 48 + 88;
#line 1398
      __cil_tmp252 = 0 + __cil_tmp251;
#line 1398
      __cil_tmp253 = i * 8UL;
#line 1398
      __cil_tmp254 = (unsigned long )(units) + __cil_tmp253;
#line 1398
      __cil_tmp255 = *((struct vmw_display_unit **)__cil_tmp254);
#line 1398
      __cil_tmp256 = (unsigned long )__cil_tmp255;
#line 1398
      __cil_tmp257 = __cil_tmp256 + __cil_tmp252;
#line 1398
      *__cil_tmp250 = *((int *)__cil_tmp257);
      {
#line 1398
      __cil_tmp258 = & _min2___0;
#line 1398
      __cil_tmp259 = *__cil_tmp258;
#line 1398
      __cil_tmp260 = & _min1___0;
#line 1398
      __cil_tmp261 = *__cil_tmp260;
#line 1398
      if (__cil_tmp261 < __cil_tmp259) {
#line 1398
        __cil_tmp262 = & _min1___0;
#line 1398
        tmp___16 = *__cil_tmp262;
      } else {
#line 1398
        __cil_tmp263 = & _min2___0;
#line 1398
        tmp___16 = *__cil_tmp263;
      }
      }
#line 1398
      clip_y2 = tmp___16;
      {
#line 1401
      __cil_tmp264 = 48 + 68;
#line 1401
      __cil_tmp265 = 0 + __cil_tmp264;
#line 1401
      __cil_tmp266 = i * 8UL;
#line 1401
      __cil_tmp267 = (unsigned long )(units) + __cil_tmp266;
#line 1401
      __cil_tmp268 = *((struct vmw_display_unit **)__cil_tmp267);
#line 1401
      __cil_tmp269 = (unsigned long )__cil_tmp268;
#line 1401
      __cil_tmp270 = __cil_tmp269 + __cil_tmp265;
#line 1401
      __cil_tmp271 = *((int *)__cil_tmp270);
#line 1401
      if (clip_x1 >= __cil_tmp271) {
#line 1404
        goto __Cont___0;
      } else {
        {
#line 1401
        __cil_tmp272 = 48 + 88;
#line 1401
        __cil_tmp273 = 0 + __cil_tmp272;
#line 1401
        __cil_tmp274 = i * 8UL;
#line 1401
        __cil_tmp275 = (unsigned long )(units) + __cil_tmp274;
#line 1401
        __cil_tmp276 = *((struct vmw_display_unit **)__cil_tmp275);
#line 1401
        __cil_tmp277 = (unsigned long )__cil_tmp276;
#line 1401
        __cil_tmp278 = __cil_tmp277 + __cil_tmp273;
#line 1401
        __cil_tmp279 = *((int *)__cil_tmp278);
#line 1401
        if (clip_y1 >= __cil_tmp279) {
#line 1404
          goto __Cont___0;
        } else
#line 1401
        if (clip_x2 <= 0) {
#line 1404
          goto __Cont___0;
        } else
#line 1401
        if (clip_y2 <= 0) {
#line 1404
          goto __Cont___0;
        } else {

        }
        }
      }
      }
#line 1406
      __cil_tmp280 = blits + blits_pos;
#line 1406
      *((uint32_t *)__cil_tmp280) = (uint32_t )38;
#line 1407
      __cil_tmp281 = 4 + 24;
#line 1407
      __cil_tmp282 = blits + blits_pos;
#line 1407
      __cil_tmp283 = (unsigned long )__cil_tmp282;
#line 1407
      __cil_tmp284 = __cil_tmp283 + __cil_tmp281;
#line 1407
      __cil_tmp285 = i * 8UL;
#line 1407
      __cil_tmp286 = (unsigned long )(units) + __cil_tmp285;
#line 1407
      __cil_tmp287 = *((struct vmw_display_unit **)__cil_tmp286);
#line 1407
      __cil_tmp288 = (unsigned long )__cil_tmp287;
#line 1407
      __cil_tmp289 = __cil_tmp288 + 2032;
#line 1407
      *((uint32 *)__cil_tmp284) = *((unsigned int *)__cil_tmp289);
#line 1408
      __cil_tmp290 = blits + blits_pos;
#line 1408
      __cil_tmp291 = (unsigned long )__cil_tmp290;
#line 1408
      __cil_tmp292 = __cil_tmp291 + 4;
#line 1408
      *((int32 *)__cil_tmp292) = dest_x;
#line 1409
      __cil_tmp293 = 0 + 4;
#line 1409
      __cil_tmp294 = 4 + __cil_tmp293;
#line 1409
      __cil_tmp295 = blits + blits_pos;
#line 1409
      __cil_tmp296 = (unsigned long )__cil_tmp295;
#line 1409
      __cil_tmp297 = __cil_tmp296 + __cil_tmp294;
#line 1409
      *((int32 *)__cil_tmp297) = dest_y;
#line 1411
      __cil_tmp298 = 4 + 8;
#line 1411
      __cil_tmp299 = blits + blits_pos;
#line 1411
      __cil_tmp300 = (unsigned long )__cil_tmp299;
#line 1411
      __cil_tmp301 = __cil_tmp300 + __cil_tmp298;
#line 1411
      *((int32 *)__cil_tmp301) = clip_x1;
#line 1412
      __cil_tmp302 = 8 + 4;
#line 1412
      __cil_tmp303 = 4 + __cil_tmp302;
#line 1412
      __cil_tmp304 = blits + blits_pos;
#line 1412
      __cil_tmp305 = (unsigned long )__cil_tmp304;
#line 1412
      __cil_tmp306 = __cil_tmp305 + __cil_tmp303;
#line 1412
      *((int32 *)__cil_tmp306) = clip_y1;
#line 1413
      __cil_tmp307 = 8 + 8;
#line 1413
      __cil_tmp308 = 4 + __cil_tmp307;
#line 1413
      __cil_tmp309 = blits + blits_pos;
#line 1413
      __cil_tmp310 = (unsigned long )__cil_tmp309;
#line 1413
      __cil_tmp311 = __cil_tmp310 + __cil_tmp308;
#line 1413
      *((int32 *)__cil_tmp311) = clip_x2;
#line 1414
      __cil_tmp312 = 8 + 12;
#line 1414
      __cil_tmp313 = 4 + __cil_tmp312;
#line 1414
      __cil_tmp314 = blits + blits_pos;
#line 1414
      __cil_tmp315 = (unsigned long )__cil_tmp314;
#line 1414
      __cil_tmp316 = __cil_tmp315 + __cil_tmp313;
#line 1414
      *((int32 *)__cil_tmp316) = clip_y2;
#line 1415
      blits_pos = blits_pos + 1;
      __Cont___0: /* CIL Label */ 
#line 1377
      k = k + 1;
#line 1377
      c = c + 1;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1375
    i = i + 1;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1419
  __cil_tmp317 = (unsigned long )blits_pos;
#line 1419
  __cil_tmp318 = 32UL * __cil_tmp317;
#line 1419
  fifo_size = 20UL + __cil_tmp318;
#line 1421
  __cil_tmp319 = (void *)0;
#line 1421
  __cil_tmp320 = (void *)cmd;
#line 1421
  __cil_tmp321 = (uint32_t )fifo_size;
#line 1421
  __cil_tmp322 = (uint64_t )0;
#line 1421
  __cil_tmp323 = (void *)0;
#line 1421
  __cil_tmp324 = (struct vmw_fence_obj **)__cil_tmp323;
#line 1421
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp319, __cil_tmp320, __cil_tmp321,
                            __cil_tmp322, user_fence_rep, __cil_tmp324);
#line 1424
  __cil_tmp325 = (void    *)cmd;
#line 1424
  kfree(__cil_tmp325);
  }
#line 1426
  return (ret);
}
}
#line 1429 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_init(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int ret ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;

  {
  {
#line 1431
  __cil_tmp4 = (unsigned long )dev_priv;
#line 1431
  __cil_tmp5 = __cil_tmp4 + 2088;
#line 1431
  dev = *((struct drm_device **)__cil_tmp5);
#line 1434
  drm_mode_config_init(dev);
#line 1435
  __cil_tmp6 = 1152 + 344;
#line 1435
  __cil_tmp7 = (unsigned long )dev;
#line 1435
  __cil_tmp8 = __cil_tmp7 + __cil_tmp6;
#line 1435
  *((struct drm_mode_config_funcs **)__cil_tmp8) = & vmw_kms_funcs;
#line 1436
  __cil_tmp9 = 1152 + 328;
#line 1436
  __cil_tmp10 = (unsigned long )dev;
#line 1436
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
#line 1436
  *((int *)__cil_tmp11) = 1;
#line 1437
  __cil_tmp12 = 1152 + 332;
#line 1437
  __cil_tmp13 = (unsigned long )dev;
#line 1437
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 1437
  *((int *)__cil_tmp14) = 1;
#line 1439
  __cil_tmp15 = 1152 + 336;
#line 1439
  __cil_tmp16 = (unsigned long )dev;
#line 1439
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 1439
  *((int *)__cil_tmp17) = 8192;
#line 1440
  __cil_tmp18 = 1152 + 340;
#line 1440
  __cil_tmp19 = (unsigned long )dev;
#line 1440
  __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
#line 1440
  *((int *)__cil_tmp20) = 8192;
#line 1442
  ret = vmw_kms_init_screen_object_display(dev_priv);
  }
#line 1443
  if (ret) {
    {
#line 1444
    vmw_kms_init_legacy_display_system(dev_priv);
    }
  } else {

  }
#line 1446
  return (0);
}
}
#line 1449 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_close(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct drm_device *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1456
  __cil_tmp2 = (unsigned long )dev_priv;
#line 1456
  __cil_tmp3 = __cil_tmp2 + 2088;
#line 1456
  __cil_tmp4 = *((struct drm_device **)__cil_tmp3);
#line 1456
  drm_mode_config_cleanup(__cil_tmp4);
  }
  {
#line 1457
  __cil_tmp5 = (unsigned long )dev_priv;
#line 1457
  __cil_tmp6 = __cil_tmp5 + 2616;
#line 1457
  if (*((struct vmw_screen_object_display **)__cil_tmp6)) {
    {
#line 1458
    vmw_kms_close_screen_object_display(dev_priv);
    }
  } else {
    {
#line 1460
    vmw_kms_close_legacy_display_system(dev_priv);
    }
  }
  }
#line 1461
  return (0);
}
}
#line 1464 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_cursor_bypass_arg *arg ;
  struct vmw_display_unit *du ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  int ret ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct drm_crtc    *__mptr___1 ;
  struct drm_mode_object    *__mptr___2 ;
  struct drm_crtc    *__mptr___3 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct mutex *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct drm_crtc *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_display_unit *__cil_tmp38 ;
  struct drm_crtc *__cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct list_head *__cil_tmp53 ;
  struct drm_crtc *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct mutex *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  struct drm_crtc *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct drm_mode_object *__cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  struct vmw_display_unit *__cil_tmp74 ;
  struct drm_crtc *__cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct mutex *__cil_tmp89 ;

  {
  {
#line 1467
  arg = (struct drm_vmw_cursor_bypass_arg *)data;
#line 1471
  ret = 0;
#line 1474
  __cil_tmp14 = (unsigned long )dev;
#line 1474
  __cil_tmp15 = __cil_tmp14 + 1152;
#line 1474
  __cil_tmp16 = (struct mutex *)__cil_tmp15;
#line 1474
  mutex_lock(__cil_tmp16);
  }
  {
#line 1475
  __cil_tmp17 = *((uint32_t *)arg);
#line 1475
  if (__cil_tmp17 & 1U) {
#line 1477
    __cil_tmp18 = 1152 + 296;
#line 1477
    __cil_tmp19 = (unsigned long )dev;
#line 1477
    __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
#line 1477
    __cil_tmp21 = *((struct list_head **)__cil_tmp20);
#line 1477
    __mptr = (struct list_head    *)__cil_tmp21;
#line 1477
    __cil_tmp22 = (struct drm_crtc *)0;
#line 1477
    __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1477
    __cil_tmp24 = __cil_tmp23 + 8;
#line 1477
    __cil_tmp25 = (struct list_head *)__cil_tmp24;
#line 1477
    __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 1477
    __cil_tmp27 = (char *)__mptr;
#line 1477
    __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 1477
    crtc = (struct drm_crtc *)__cil_tmp28;
    {
#line 1477
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1477
      __cil_tmp29 = 1152 + 296;
#line 1477
      __cil_tmp30 = (unsigned long )dev;
#line 1477
      __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 1477
      __cil_tmp32 = (struct list_head *)__cil_tmp31;
#line 1477
      __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 1477
      __cil_tmp34 = (unsigned long )crtc;
#line 1477
      __cil_tmp35 = __cil_tmp34 + 8;
#line 1477
      __cil_tmp36 = (struct list_head *)__cil_tmp35;
#line 1477
      __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 1477
      if (__cil_tmp37 != __cil_tmp33) {

      } else {
#line 1477
        goto while_break;
      }
      }
#line 1478
      __mptr___1 = (struct drm_crtc    *)crtc;
#line 1478
      __cil_tmp38 = (struct vmw_display_unit *)0;
#line 1478
      __cil_tmp39 = (struct drm_crtc *)__cil_tmp38;
#line 1478
      __cil_tmp40 = (unsigned int )__cil_tmp39;
#line 1478
      __cil_tmp41 = (char *)__mptr___1;
#line 1478
      __cil_tmp42 = __cil_tmp41 - __cil_tmp40;
#line 1478
      du = (struct vmw_display_unit *)__cil_tmp42;
#line 1479
      __cil_tmp43 = (unsigned long )du;
#line 1479
      __cil_tmp44 = __cil_tmp43 + 2024;
#line 1479
      __cil_tmp45 = (unsigned long )arg;
#line 1479
      __cil_tmp46 = __cil_tmp45 + 16;
#line 1479
      *((int *)__cil_tmp44) = *((int32_t *)__cil_tmp46);
#line 1480
      __cil_tmp47 = (unsigned long )du;
#line 1480
      __cil_tmp48 = __cil_tmp47 + 2028;
#line 1480
      __cil_tmp49 = (unsigned long )arg;
#line 1480
      __cil_tmp50 = __cil_tmp49 + 20;
#line 1480
      *((int *)__cil_tmp48) = *((int32_t *)__cil_tmp50);
#line 1477
      __cil_tmp51 = (unsigned long )crtc;
#line 1477
      __cil_tmp52 = __cil_tmp51 + 8;
#line 1477
      __cil_tmp53 = *((struct list_head **)__cil_tmp52);
#line 1477
      __mptr___0 = (struct list_head    *)__cil_tmp53;
#line 1477
      __cil_tmp54 = (struct drm_crtc *)0;
#line 1477
      __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 1477
      __cil_tmp56 = __cil_tmp55 + 8;
#line 1477
      __cil_tmp57 = (struct list_head *)__cil_tmp56;
#line 1477
      __cil_tmp58 = (unsigned int )__cil_tmp57;
#line 1477
      __cil_tmp59 = (char *)__mptr___0;
#line 1477
      __cil_tmp60 = __cil_tmp59 - __cil_tmp58;
#line 1477
      crtc = (struct drm_crtc *)__cil_tmp60;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1483
    __cil_tmp61 = (unsigned long )dev;
#line 1483
    __cil_tmp62 = __cil_tmp61 + 1152;
#line 1483
    __cil_tmp63 = (struct mutex *)__cil_tmp62;
#line 1483
    mutex_unlock(__cil_tmp63);
    }
#line 1484
    return (0);
  } else {

  }
  }
  {
#line 1487
  __cil_tmp64 = (unsigned long )arg;
#line 1487
  __cil_tmp65 = __cil_tmp64 + 4;
#line 1487
  __cil_tmp66 = *((uint32_t *)__cil_tmp65);
#line 1487
  obj = drm_mode_object_find(dev, __cil_tmp66, 3435973836U);
  }
#line 1488
  if (! obj) {
#line 1489
    ret = -22;
#line 1490
    goto out;
  } else {

  }
#line 1493
  __mptr___2 = (struct drm_mode_object    *)obj;
#line 1493
  __cil_tmp67 = (struct drm_crtc *)0;
#line 1493
  __cil_tmp68 = (unsigned long )__cil_tmp67;
#line 1493
  __cil_tmp69 = __cil_tmp68 + 24;
#line 1493
  __cil_tmp70 = (struct drm_mode_object *)__cil_tmp69;
#line 1493
  __cil_tmp71 = (unsigned int )__cil_tmp70;
#line 1493
  __cil_tmp72 = (char *)__mptr___2;
#line 1493
  __cil_tmp73 = __cil_tmp72 - __cil_tmp71;
#line 1493
  crtc = (struct drm_crtc *)__cil_tmp73;
#line 1494
  __mptr___3 = (struct drm_crtc    *)crtc;
#line 1494
  __cil_tmp74 = (struct vmw_display_unit *)0;
#line 1494
  __cil_tmp75 = (struct drm_crtc *)__cil_tmp74;
#line 1494
  __cil_tmp76 = (unsigned int )__cil_tmp75;
#line 1494
  __cil_tmp77 = (char *)__mptr___3;
#line 1494
  __cil_tmp78 = __cil_tmp77 - __cil_tmp76;
#line 1494
  du = (struct vmw_display_unit *)__cil_tmp78;
#line 1496
  __cil_tmp79 = (unsigned long )du;
#line 1496
  __cil_tmp80 = __cil_tmp79 + 2024;
#line 1496
  __cil_tmp81 = (unsigned long )arg;
#line 1496
  __cil_tmp82 = __cil_tmp81 + 16;
#line 1496
  *((int *)__cil_tmp80) = *((int32_t *)__cil_tmp82);
#line 1497
  __cil_tmp83 = (unsigned long )du;
#line 1497
  __cil_tmp84 = __cil_tmp83 + 2028;
#line 1497
  __cil_tmp85 = (unsigned long )arg;
#line 1497
  __cil_tmp86 = __cil_tmp85 + 20;
#line 1497
  *((int *)__cil_tmp84) = *((int32_t *)__cil_tmp86);
  out: 
  {
#line 1500
  __cil_tmp87 = (unsigned long )dev;
#line 1500
  __cil_tmp88 = __cil_tmp87 + 1152;
#line 1500
  __cil_tmp89 = (struct mutex *)__cil_tmp88;
#line 1500
  mutex_unlock(__cil_tmp89);
  }
#line 1502
  return (ret);
}
}
#line 1505 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) 
{ bool tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 1509
  __cil_tmp10 = (unsigned long )vmw_priv___0;
#line 1509
  __cil_tmp11 = __cil_tmp10 + 2156;
#line 1509
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
#line 1509
  if (__cil_tmp12 & 131072U) {
    {
#line 1510
    vmw_write(vmw_priv___0, 32U, pitch);
    }
  } else {
    {
#line 1511
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    }
#line 1511
    if (tmp___7) {
      {
#line 1512
      __cil_tmp13 = (unsigned long )vmw_priv___0;
#line 1512
      __cil_tmp14 = __cil_tmp13 + 2144;
#line 1512
      __cil_tmp15 = *((__le32 **)__cil_tmp14);
#line 1512
      __cil_tmp16 = __cil_tmp15 + 8;
#line 1512
      __cil_tmp17 = (void *)__cil_tmp16;
#line 1512
      iowrite32(pitch, __cil_tmp17);
      }
    } else {

    }
  }
  }
  {
#line 1513
  vmw_write(vmw_priv___0, 2U, width);
#line 1514
  vmw_write(vmw_priv___0, 3U, height);
#line 1515
  vmw_write(vmw_priv___0, 7U, bpp);
#line 1517
  tmp___9 = vmw_read(vmw_priv___0, 6U);
  }
#line 1517
  if (tmp___9 != depth) {
    {
#line 1518
    tmp___8 = vmw_read(vmw_priv___0, 6U);
#line 1518
    drm_err("vmw_kms_write_svga", "Invalid depth %u for %u bpp, host expects %u\n",
            depth, bpp, tmp___8);
    }
#line 1520
    return (-22);
  } else {

  }
#line 1523
  return (0);
}
}
#line 1526 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  uint32_t __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32_t __cil_tmp69 ;

  {
  {
#line 1531
  __cil_tmp5 = (unsigned long )vmw_priv___0;
#line 1531
  __cil_tmp6 = __cil_tmp5 + 2576;
#line 1531
  *((uint32_t *)__cil_tmp6) = vmw_read(vmw_priv___0, 2U);
#line 1532
  __cil_tmp7 = (unsigned long )vmw_priv___0;
#line 1532
  __cil_tmp8 = __cil_tmp7 + 2580;
#line 1532
  *((uint32_t *)__cil_tmp8) = vmw_read(vmw_priv___0, 3U);
#line 1533
  __cil_tmp9 = (unsigned long )vmw_priv___0;
#line 1533
  __cil_tmp10 = __cil_tmp9 + 2584;
#line 1533
  *((uint32_t *)__cil_tmp10) = vmw_read(vmw_priv___0, 7U);
  }
  {
#line 1534
  __cil_tmp11 = (unsigned long )vmw_priv___0;
#line 1534
  __cil_tmp12 = __cil_tmp11 + 2156;
#line 1534
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
#line 1534
  if (__cil_tmp13 & 131072U) {
    {
#line 1535
    __cil_tmp14 = (unsigned long )vmw_priv___0;
#line 1535
    __cil_tmp15 = __cil_tmp14 + 2592;
#line 1535
    *((uint32_t *)__cil_tmp15) = vmw_read(vmw_priv___0, 32U);
    }
  } else {
    {
#line 1537
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    }
#line 1537
    if (tmp___7) {
      {
#line 1538
      __cil_tmp16 = (unsigned long )vmw_priv___0;
#line 1538
      __cil_tmp17 = __cil_tmp16 + 2592;
#line 1538
      __cil_tmp18 = (unsigned long )vmw_priv___0;
#line 1538
      __cil_tmp19 = __cil_tmp18 + 2144;
#line 1538
      __cil_tmp20 = *((__le32 **)__cil_tmp19);
#line 1538
      __cil_tmp21 = __cil_tmp20 + 8;
#line 1538
      __cil_tmp22 = (void *)__cil_tmp21;
#line 1538
      *((uint32_t *)__cil_tmp17) = ioread32(__cil_tmp22);
      }
    } else {

    }
  }
  }
  {
#line 1541
  __cil_tmp23 = (unsigned long )vmw_priv___0;
#line 1541
  __cil_tmp24 = __cil_tmp23 + 2156;
#line 1541
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
#line 1541
  __cil_tmp26 = __cil_tmp25 & 524288U;
#line 1541
  if (! __cil_tmp26) {
#line 1542
    return (0);
  } else {

  }
  }
  {
#line 1544
  __cil_tmp27 = (unsigned long )vmw_priv___0;
#line 1544
  __cil_tmp28 = __cil_tmp27 + 2596;
#line 1544
  *((uint32_t *)__cil_tmp28) = vmw_read(vmw_priv___0, 34U);
  }
  {
#line 1547
  __cil_tmp29 = (unsigned long )vmw_priv___0;
#line 1547
  __cil_tmp30 = __cil_tmp29 + 2596;
#line 1547
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
#line 1547
  if (__cil_tmp31 == 0U) {
#line 1548
    __cil_tmp32 = (unsigned long )vmw_priv___0;
#line 1548
    __cil_tmp33 = __cil_tmp32 + 2596;
#line 1548
    *((uint32_t *)__cil_tmp33) = (uint32_t )1;
  } else {

  }
  }
#line 1550
  i = (uint32_t )0;
  {
#line 1550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1550
    __cil_tmp34 = (unsigned long )vmw_priv___0;
#line 1550
    __cil_tmp35 = __cil_tmp34 + 2596;
#line 1550
    __cil_tmp36 = *((uint32_t *)__cil_tmp35);
#line 1550
    if (i < __cil_tmp36) {

    } else {
#line 1550
      goto while_break;
    }
    }
    {
#line 1551
    __cil_tmp37 = i * 20UL;
#line 1551
    __cil_tmp38 = 2256 + __cil_tmp37;
#line 1551
    __cil_tmp39 = (unsigned long )vmw_priv___0;
#line 1551
    __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 1551
    save = (struct vmw_vga_topology_state *)__cil_tmp40;
#line 1552
    vmw_write(vmw_priv___0, 35U, i);
#line 1553
    __cil_tmp41 = (unsigned long )save;
#line 1553
    __cil_tmp42 = __cil_tmp41 + 8;
#line 1553
    *((uint32_t *)__cil_tmp42) = vmw_read(vmw_priv___0, 36U);
#line 1554
    __cil_tmp43 = (unsigned long )save;
#line 1554
    __cil_tmp44 = __cil_tmp43 + 12;
#line 1554
    *((uint32_t *)__cil_tmp44) = vmw_read(vmw_priv___0, 37U);
#line 1555
    __cil_tmp45 = (unsigned long )save;
#line 1555
    __cil_tmp46 = __cil_tmp45 + 16;
#line 1555
    *((uint32_t *)__cil_tmp46) = vmw_read(vmw_priv___0, 38U);
#line 1556
    *((uint32_t *)save) = vmw_read(vmw_priv___0, 39U);
#line 1557
    __cil_tmp47 = (unsigned long )save;
#line 1557
    __cil_tmp48 = __cil_tmp47 + 4;
#line 1557
    *((uint32_t *)__cil_tmp48) = vmw_read(vmw_priv___0, 40U);
#line 1558
    vmw_write(vmw_priv___0, 35U, 4294967295U);
    }
#line 1559
    if (i == 0U) {
      {
#line 1559
      __cil_tmp49 = (unsigned long )vmw_priv___0;
#line 1559
      __cil_tmp50 = __cil_tmp49 + 2596;
#line 1559
      __cil_tmp51 = *((uint32_t *)__cil_tmp50);
#line 1559
      if (__cil_tmp51 == 1U) {
        {
#line 1559
        __cil_tmp52 = *((uint32_t *)save);
#line 1559
        if (__cil_tmp52 == 0U) {
          {
#line 1559
          __cil_tmp53 = (unsigned long )save;
#line 1559
          __cil_tmp54 = __cil_tmp53 + 4;
#line 1559
          __cil_tmp55 = *((uint32_t *)__cil_tmp54);
#line 1559
          if (__cil_tmp55 == 0U) {
#line 1567
            __cil_tmp56 = (unsigned long )save;
#line 1567
            __cil_tmp57 = __cil_tmp56 + 12;
#line 1567
            __cil_tmp58 = *((uint32_t *)__cil_tmp57);
#line 1567
            __cil_tmp59 = (unsigned long )vmw_priv___0;
#line 1567
            __cil_tmp60 = __cil_tmp59 + 2576;
#line 1567
            __cil_tmp61 = *((uint32_t *)__cil_tmp60);
#line 1567
            *((uint32_t *)save) = __cil_tmp61 - __cil_tmp58;
#line 1568
            __cil_tmp62 = (unsigned long )save;
#line 1568
            __cil_tmp63 = __cil_tmp62 + 4;
#line 1568
            __cil_tmp64 = (unsigned long )save;
#line 1568
            __cil_tmp65 = __cil_tmp64 + 16;
#line 1568
            __cil_tmp66 = *((uint32_t *)__cil_tmp65);
#line 1568
            __cil_tmp67 = (unsigned long )vmw_priv___0;
#line 1568
            __cil_tmp68 = __cil_tmp67 + 2580;
#line 1568
            __cil_tmp69 = *((uint32_t *)__cil_tmp68);
#line 1568
            *((uint32_t *)__cil_tmp63) = __cil_tmp69 - __cil_tmp66;
          } else {

          }
          }
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
#line 1550
    i = i + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1572
  return (0);
}
}
#line 1575 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  __le32 *__cil_tmp25 ;
  __le32 *__cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;

  {
  {
#line 1580
  __cil_tmp5 = (unsigned long )vmw_priv___0;
#line 1580
  __cil_tmp6 = __cil_tmp5 + 2576;
#line 1580
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
#line 1580
  vmw_write(vmw_priv___0, 2U, __cil_tmp7);
#line 1581
  __cil_tmp8 = (unsigned long )vmw_priv___0;
#line 1581
  __cil_tmp9 = __cil_tmp8 + 2580;
#line 1581
  __cil_tmp10 = *((uint32_t *)__cil_tmp9);
#line 1581
  vmw_write(vmw_priv___0, 3U, __cil_tmp10);
#line 1582
  __cil_tmp11 = (unsigned long )vmw_priv___0;
#line 1582
  __cil_tmp12 = __cil_tmp11 + 2584;
#line 1582
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
#line 1582
  vmw_write(vmw_priv___0, 7U, __cil_tmp13);
  }
  {
#line 1583
  __cil_tmp14 = (unsigned long )vmw_priv___0;
#line 1583
  __cil_tmp15 = __cil_tmp14 + 2156;
#line 1583
  __cil_tmp16 = *((uint32_t *)__cil_tmp15);
#line 1583
  if (__cil_tmp16 & 131072U) {
    {
#line 1584
    __cil_tmp17 = (unsigned long )vmw_priv___0;
#line 1584
    __cil_tmp18 = __cil_tmp17 + 2592;
#line 1584
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 1584
    vmw_write(vmw_priv___0, 32U, __cil_tmp19);
    }
  } else {
    {
#line 1586
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    }
#line 1586
    if (tmp___7) {
      {
#line 1587
      __cil_tmp20 = (unsigned long )vmw_priv___0;
#line 1587
      __cil_tmp21 = __cil_tmp20 + 2592;
#line 1587
      __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 1587
      __cil_tmp23 = (unsigned long )vmw_priv___0;
#line 1587
      __cil_tmp24 = __cil_tmp23 + 2144;
#line 1587
      __cil_tmp25 = *((__le32 **)__cil_tmp24);
#line 1587
      __cil_tmp26 = __cil_tmp25 + 8;
#line 1587
      __cil_tmp27 = (void *)__cil_tmp26;
#line 1587
      iowrite32(__cil_tmp22, __cil_tmp27);
      }
    } else {

    }
  }
  }
  {
#line 1590
  __cil_tmp28 = (unsigned long )vmw_priv___0;
#line 1590
  __cil_tmp29 = __cil_tmp28 + 2156;
#line 1590
  __cil_tmp30 = *((uint32_t *)__cil_tmp29);
#line 1590
  __cil_tmp31 = __cil_tmp30 & 524288U;
#line 1590
  if (! __cil_tmp31) {
#line 1591
    return (0);
  } else {

  }
  }
#line 1593
  i = (uint32_t )0;
  {
#line 1593
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1593
    __cil_tmp32 = (unsigned long )vmw_priv___0;
#line 1593
    __cil_tmp33 = __cil_tmp32 + 2596;
#line 1593
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
#line 1593
    if (i < __cil_tmp34) {

    } else {
#line 1593
      goto while_break;
    }
    }
    {
#line 1594
    __cil_tmp35 = i * 20UL;
#line 1594
    __cil_tmp36 = 2256 + __cil_tmp35;
#line 1594
    __cil_tmp37 = (unsigned long )vmw_priv___0;
#line 1594
    __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 1594
    save = (struct vmw_vga_topology_state *)__cil_tmp38;
#line 1595
    vmw_write(vmw_priv___0, 35U, i);
#line 1596
    __cil_tmp39 = (unsigned long )save;
#line 1596
    __cil_tmp40 = __cil_tmp39 + 8;
#line 1596
    __cil_tmp41 = *((uint32_t *)__cil_tmp40);
#line 1596
    vmw_write(vmw_priv___0, 36U, __cil_tmp41);
#line 1597
    __cil_tmp42 = (unsigned long )save;
#line 1597
    __cil_tmp43 = __cil_tmp42 + 12;
#line 1597
    __cil_tmp44 = *((uint32_t *)__cil_tmp43);
#line 1597
    vmw_write(vmw_priv___0, 37U, __cil_tmp44);
#line 1598
    __cil_tmp45 = (unsigned long )save;
#line 1598
    __cil_tmp46 = __cil_tmp45 + 16;
#line 1598
    __cil_tmp47 = *((uint32_t *)__cil_tmp46);
#line 1598
    vmw_write(vmw_priv___0, 38U, __cil_tmp47);
#line 1599
    __cil_tmp48 = *((uint32_t *)save);
#line 1599
    vmw_write(vmw_priv___0, 39U, __cil_tmp48);
#line 1600
    __cil_tmp49 = (unsigned long )save;
#line 1600
    __cil_tmp50 = __cil_tmp49 + 4;
#line 1600
    __cil_tmp51 = *((uint32_t *)__cil_tmp50);
#line 1600
    vmw_write(vmw_priv___0, 40U, __cil_tmp51);
#line 1601
    vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1593
    i = i + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  return (0);
}
}
#line 1607 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  u64 __cil_tmp7 ;
  u64 __cil_tmp8 ;
  u64 __cil_tmp9 ;
  u64 __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1611
  __cil_tmp4 = (unsigned long )dev_priv;
#line 1611
  __cil_tmp5 = __cil_tmp4 + 2112;
#line 1611
  __cil_tmp6 = *((uint32_t *)__cil_tmp5);
#line 1611
  __cil_tmp7 = (u64 )__cil_tmp6;
#line 1611
  __cil_tmp8 = (u64 )height;
#line 1611
  __cil_tmp9 = (u64 )pitch;
#line 1611
  __cil_tmp10 = __cil_tmp9 * __cil_tmp8;
#line 1611
  __cil_tmp11 = __cil_tmp10 < __cil_tmp7;
#line 1611
  return ((bool )__cil_tmp11);
  }
}
}
#line 1618 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1620
  return ((u32 )0);
}
}
#line 1626 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_enable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1628
  return (-38);
}
}
#line 1634 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_disable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1636
  return;
}
}
#line 1643 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_update_layout(struct vmw_private *dev_priv , unsigned int num , struct drm_vmw_rect *rects ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_connector *con ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct drm_connector    *__mptr___1 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct drm_connector *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct vmw_display_unit *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct drm_connector *__cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  struct drm_vmw_rect *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  struct drm_vmw_rect *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  struct drm_vmw_rect *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  struct drm_vmw_rect *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  bool __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct list_head *__cil_tmp88 ;
  struct drm_connector *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct mutex *__cil_tmp98 ;

  {
  {
#line 1646
  __cil_tmp10 = (unsigned long )dev_priv;
#line 1646
  __cil_tmp11 = __cil_tmp10 + 2088;
#line 1646
  dev = *((struct drm_device **)__cil_tmp11);
#line 1650
  __cil_tmp12 = (unsigned long )dev;
#line 1650
  __cil_tmp13 = __cil_tmp12 + 1152;
#line 1650
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
#line 1650
  mutex_lock(__cil_tmp14);
#line 1664
  __cil_tmp15 = 1152 + 224;
#line 1664
  __cil_tmp16 = (unsigned long )dev;
#line 1664
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 1664
  __cil_tmp18 = *((struct list_head **)__cil_tmp17);
#line 1664
  __mptr = (struct list_head    *)__cil_tmp18;
#line 1664
  __cil_tmp19 = (struct drm_connector *)0;
#line 1664
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 1664
  __cil_tmp21 = __cil_tmp20 + 784;
#line 1664
  __cil_tmp22 = (struct list_head *)__cil_tmp21;
#line 1664
  __cil_tmp23 = (unsigned int )__cil_tmp22;
#line 1664
  __cil_tmp24 = (char *)__mptr;
#line 1664
  __cil_tmp25 = __cil_tmp24 - __cil_tmp23;
#line 1664
  con = (struct drm_connector *)__cil_tmp25;
  }
  {
#line 1664
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1664
    __cil_tmp26 = 1152 + 224;
#line 1664
    __cil_tmp27 = (unsigned long )dev;
#line 1664
    __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
#line 1664
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 1664
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 1664
    __cil_tmp31 = (unsigned long )con;
#line 1664
    __cil_tmp32 = __cil_tmp31 + 784;
#line 1664
    __cil_tmp33 = (struct list_head *)__cil_tmp32;
#line 1664
    __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 1664
    if (__cil_tmp34 != __cil_tmp30) {

    } else {
#line 1664
      goto while_break;
    }
    }
#line 1665
    __mptr___1 = (struct drm_connector    *)con;
#line 1665
    __cil_tmp35 = (struct vmw_display_unit *)0;
#line 1665
    __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 1665
    __cil_tmp37 = __cil_tmp36 + 616;
#line 1665
    __cil_tmp38 = (struct drm_connector *)__cil_tmp37;
#line 1665
    __cil_tmp39 = (unsigned int )__cil_tmp38;
#line 1665
    __cil_tmp40 = (char *)__mptr___1;
#line 1665
    __cil_tmp41 = __cil_tmp40 - __cil_tmp39;
#line 1665
    du = (struct vmw_display_unit *)__cil_tmp41;
    {
#line 1666
    __cil_tmp42 = (unsigned long )du;
#line 1666
    __cil_tmp43 = __cil_tmp42 + 2032;
#line 1666
    __cil_tmp44 = *((unsigned int *)__cil_tmp43);
#line 1666
    if (num > __cil_tmp44) {
#line 1667
      __cil_tmp45 = (unsigned long )du;
#line 1667
      __cil_tmp46 = __cil_tmp45 + 2036;
#line 1667
      __cil_tmp47 = (unsigned long )du;
#line 1667
      __cil_tmp48 = __cil_tmp47 + 2032;
#line 1667
      __cil_tmp49 = *((unsigned int *)__cil_tmp48);
#line 1667
      __cil_tmp50 = rects + __cil_tmp49;
#line 1667
      __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 1667
      __cil_tmp52 = __cil_tmp51 + 8;
#line 1667
      *((unsigned int *)__cil_tmp46) = *((uint32_t *)__cil_tmp52);
#line 1668
      __cil_tmp53 = (unsigned long )du;
#line 1668
      __cil_tmp54 = __cil_tmp53 + 2040;
#line 1668
      __cil_tmp55 = (unsigned long )du;
#line 1668
      __cil_tmp56 = __cil_tmp55 + 2032;
#line 1668
      __cil_tmp57 = *((unsigned int *)__cil_tmp56);
#line 1668
      __cil_tmp58 = rects + __cil_tmp57;
#line 1668
      __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1668
      __cil_tmp60 = __cil_tmp59 + 12;
#line 1668
      *((unsigned int *)__cil_tmp54) = *((uint32_t *)__cil_tmp60);
#line 1669
      __cil_tmp61 = (unsigned long )du;
#line 1669
      __cil_tmp62 = __cil_tmp61 + 2044;
#line 1669
      *((bool *)__cil_tmp62) = (bool )1;
#line 1670
      __cil_tmp63 = (unsigned long )du;
#line 1670
      __cil_tmp64 = __cil_tmp63 + 2056;
#line 1670
      __cil_tmp65 = (unsigned long )du;
#line 1670
      __cil_tmp66 = __cil_tmp65 + 2032;
#line 1670
      __cil_tmp67 = *((unsigned int *)__cil_tmp66);
#line 1670
      __cil_tmp68 = rects + __cil_tmp67;
#line 1670
      *((int *)__cil_tmp64) = *((int32_t *)__cil_tmp68);
#line 1671
      __cil_tmp69 = (unsigned long )du;
#line 1671
      __cil_tmp70 = __cil_tmp69 + 2060;
#line 1671
      __cil_tmp71 = (unsigned long )du;
#line 1671
      __cil_tmp72 = __cil_tmp71 + 2032;
#line 1671
      __cil_tmp73 = *((unsigned int *)__cil_tmp72);
#line 1671
      __cil_tmp74 = rects + __cil_tmp73;
#line 1671
      __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 1671
      __cil_tmp76 = __cil_tmp75 + 4;
#line 1671
      *((int *)__cil_tmp70) = *((int32_t *)__cil_tmp76);
    } else {
#line 1673
      __cil_tmp77 = (unsigned long )du;
#line 1673
      __cil_tmp78 = __cil_tmp77 + 2036;
#line 1673
      *((unsigned int *)__cil_tmp78) = 800U;
#line 1674
      __cil_tmp79 = (unsigned long )du;
#line 1674
      __cil_tmp80 = __cil_tmp79 + 2040;
#line 1674
      *((unsigned int *)__cil_tmp80) = 600U;
#line 1675
      __cil_tmp81 = (unsigned long )du;
#line 1675
      __cil_tmp82 = __cil_tmp81 + 2044;
#line 1675
      *((bool *)__cil_tmp82) = (bool )0;
    }
    }
    {
#line 1677
    __cil_tmp83 = (unsigned long )con;
#line 1677
    __cil_tmp84 = __cil_tmp83 + 840;
#line 1677
    __cil_tmp85 = (bool )1;
#line 1677
    *((enum drm_connector_status *)__cil_tmp84) = vmw_du_connector_detect(con, __cil_tmp85);
#line 1664
    __cil_tmp86 = (unsigned long )con;
#line 1664
    __cil_tmp87 = __cil_tmp86 + 784;
#line 1664
    __cil_tmp88 = *((struct list_head **)__cil_tmp87);
#line 1664
    __mptr___0 = (struct list_head    *)__cil_tmp88;
#line 1664
    __cil_tmp89 = (struct drm_connector *)0;
#line 1664
    __cil_tmp90 = (unsigned long )__cil_tmp89;
#line 1664
    __cil_tmp91 = __cil_tmp90 + 784;
#line 1664
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
#line 1664
    __cil_tmp93 = (unsigned int )__cil_tmp92;
#line 1664
    __cil_tmp94 = (char *)__mptr___0;
#line 1664
    __cil_tmp95 = __cil_tmp94 - __cil_tmp93;
#line 1664
    con = (struct drm_connector *)__cil_tmp95;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1680
  __cil_tmp96 = (unsigned long )dev;
#line 1680
  __cil_tmp97 = __cil_tmp96 + 1152;
#line 1680
  __cil_tmp98 = (struct mutex *)__cil_tmp97;
#line 1680
  mutex_unlock(__cil_tmp98);
  }
#line 1682
  return (0);
}
}
#line 1685 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_framebuffer *old_fb ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer    *__mptr ;
  struct drm_file *file_priv ;
  struct vmw_fence_obj *fence ;
  struct drm_clip_rect clips ;
  int ret ;
  bool tmp___8 ;
  struct drm_crtc    *__mptr___0 ;
  struct drm_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_framebuffer *__cil_tmp18 ;
  struct drm_framebuffer *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_fence_obj **__cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_screen_object_display *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct drm_clip_rect *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct vmw_fence_obj **__cil_tmp46 ;
  struct vmw_fence_obj *__cil_tmp47 ;
  struct vmw_fence_obj **__cil_tmp48 ;
  struct vmw_fence_obj *__cil_tmp49 ;
  struct drm_pending_event *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32 *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  __u32 *__cil_tmp58 ;
  bool __cil_tmp59 ;
  struct vmw_display_unit *__cil_tmp60 ;
  struct drm_crtc *__cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  struct vmw_display_unit *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;

  {
  {
#line 1689
  __cil_tmp15 = *((struct drm_device **)crtc);
#line 1689
  tmp___7 = vmw_priv(__cil_tmp15);
#line 1689
  dev_priv = tmp___7;
#line 1690
  __cil_tmp16 = (unsigned long )crtc;
#line 1690
  __cil_tmp17 = __cil_tmp16 + 32;
#line 1690
  old_fb = *((struct drm_framebuffer **)__cil_tmp17);
#line 1691
  __mptr = (struct drm_framebuffer    *)fb;
#line 1691
  __cil_tmp18 = (struct vmw_framebuffer *)0;
#line 1691
  __cil_tmp19 = (struct drm_framebuffer *)__cil_tmp18;
#line 1691
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 1691
  __cil_tmp21 = (char *)__mptr;
#line 1691
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
#line 1691
  vfb = (struct vmw_framebuffer *)__cil_tmp22;
#line 1692
  __cil_tmp23 = 0 + 24;
#line 1692
  __cil_tmp24 = (unsigned long )event;
#line 1692
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
#line 1692
  file_priv = *((struct drm_file **)__cil_tmp25);
#line 1693
  __cil_tmp26 = & fence;
#line 1693
  __cil_tmp27 = (void *)0;
#line 1693
  *__cil_tmp26 = (struct vmw_fence_obj *)__cil_tmp27;
  }
  {
#line 1698
  __cil_tmp28 = (unsigned long )dev_priv;
#line 1698
  __cil_tmp29 = __cil_tmp28 + 2616;
#line 1698
  __cil_tmp30 = *((struct vmw_screen_object_display **)__cil_tmp29);
#line 1698
  if (! __cil_tmp30) {
#line 1699
    return (-38);
  } else {

  }
  }
  {
#line 1701
  tmp___8 = vmw_kms_screen_object_flippable(dev_priv, crtc);
  }
#line 1701
  if (tmp___8) {

  } else {
#line 1702
    return (-22);
  }
#line 1704
  __cil_tmp31 = (unsigned long )crtc;
#line 1704
  __cil_tmp32 = __cil_tmp31 + 32;
#line 1704
  *((struct drm_framebuffer **)__cil_tmp32) = fb;
#line 1707
  __cil_tmp33 = (unsigned long )(& clips) + 2;
#line 1707
  *((unsigned short *)__cil_tmp33) = (unsigned short)0;
#line 1707
  __cil_tmp34 = & clips;
#line 1707
  __cil_tmp35 = (unsigned long )(& clips) + 2;
#line 1707
  *((unsigned short *)__cil_tmp34) = *((unsigned short *)__cil_tmp35);
#line 1708
  __cil_tmp36 = (unsigned long )(& clips) + 4;
#line 1708
  __cil_tmp37 = (unsigned long )fb;
#line 1708
  __cil_tmp38 = __cil_tmp37 + 72;
#line 1708
  __cil_tmp39 = *((unsigned int *)__cil_tmp38);
#line 1708
  *((unsigned short *)__cil_tmp36) = (unsigned short )__cil_tmp39;
#line 1709
  __cil_tmp40 = (unsigned long )(& clips) + 6;
#line 1709
  __cil_tmp41 = (unsigned long )fb;
#line 1709
  __cil_tmp42 = __cil_tmp41 + 76;
#line 1709
  __cil_tmp43 = *((unsigned int *)__cil_tmp42);
#line 1709
  *((unsigned short *)__cil_tmp40) = (unsigned short )__cil_tmp43;
  {
#line 1711
  __cil_tmp44 = (unsigned long )vfb;
#line 1711
  __cil_tmp45 = __cil_tmp44 + 136;
#line 1711
  if (*((bool *)__cil_tmp45)) {
    {
#line 1712
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
    }
  } else {
    {
#line 1715
    ret = do_surface_dirty_sou(dev_priv, file_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
    }
  }
  }
#line 1719
  if (ret != 0) {
#line 1720
    goto out_no_fence;
  } else {

  }
  {
#line 1721
  __cil_tmp46 = & fence;
#line 1721
  __cil_tmp47 = *__cil_tmp46;
#line 1721
  if (! __cil_tmp47) {
#line 1722
    ret = -22;
#line 1723
    goto out_no_fence;
  } else {

  }
  }
  {
#line 1726
  __cil_tmp48 = & fence;
#line 1726
  __cil_tmp49 = *__cil_tmp48;
#line 1726
  __cil_tmp50 = (struct drm_pending_event *)event;
#line 1726
  __cil_tmp51 = 56 + 16;
#line 1726
  __cil_tmp52 = (unsigned long )event;
#line 1726
  __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
#line 1726
  __cil_tmp54 = (__u32 *)__cil_tmp53;
#line 1726
  __cil_tmp55 = 56 + 20;
#line 1726
  __cil_tmp56 = (unsigned long )event;
#line 1726
  __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
#line 1726
  __cil_tmp58 = (__u32 *)__cil_tmp57;
#line 1726
  __cil_tmp59 = (bool )1;
#line 1726
  ret = vmw_event_fence_action_queue(file_priv, __cil_tmp49, __cil_tmp50, __cil_tmp54,
                                     __cil_tmp58, __cil_tmp59);
#line 1736
  vmw_fence_obj_unreference(& fence);
#line 1738
  __mptr___0 = (struct drm_crtc    *)crtc;
  }
  {
#line 1738
  __cil_tmp60 = (struct vmw_display_unit *)0;
#line 1738
  __cil_tmp61 = (struct drm_crtc *)__cil_tmp60;
#line 1738
  __cil_tmp62 = (unsigned int )__cil_tmp61;
#line 1738
  __cil_tmp63 = (char *)__mptr___0;
#line 1738
  __cil_tmp64 = __cil_tmp63 - __cil_tmp62;
#line 1738
  __cil_tmp65 = (struct vmw_display_unit *)__cil_tmp64;
#line 1738
  __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 1738
  __cil_tmp67 = __cil_tmp66 + 2064;
#line 1738
  if (*((bool *)__cil_tmp67)) {
    {
#line 1739
    vmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);
    }
  } else {

  }
  }
#line 1741
  return (ret);
  out_no_fence: 
#line 1744
  __cil_tmp68 = (unsigned long )crtc;
#line 1744
  __cil_tmp69 = __cil_tmp68 + 32;
#line 1744
  *((struct drm_framebuffer **)__cil_tmp69) = old_fb;
#line 1745
  return (ret);
}
}
#line 1749 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_crtc_save(struct drm_crtc *crtc ) 
{ 

  {
#line 1751
  return;
}
}
#line 1753 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_crtc_restore(struct drm_crtc *crtc ) 
{ 

  {
#line 1755
  return;
}
}
#line 1757 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  int i ;
  struct drm_device *__cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  u16 *__cil_tmp12 ;
  u16 __cil_tmp13 ;
  int __cil_tmp14 ;
  u16 *__cil_tmp15 ;
  u16 __cil_tmp16 ;
  int __cil_tmp17 ;
  u16 *__cil_tmp18 ;
  u16 __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  u16 *__cil_tmp24 ;
  u16 __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  u16 *__cil_tmp33 ;
  u16 __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  u16 *__cil_tmp42 ;
  u16 __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  uint32_t __cil_tmp46 ;

  {
  {
#line 1761
  __cil_tmp10 = *((struct drm_device **)crtc);
#line 1761
  tmp___7 = vmw_priv(__cil_tmp10);
#line 1761
  dev_priv = tmp___7;
#line 1764
  i = 0;
  }
  {
#line 1764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1764
    __cil_tmp11 = (uint32_t )i;
#line 1764
    if (__cil_tmp11 < size) {

    } else {
#line 1764
      goto while_break;
    }
    }
    {
#line 1765
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1765
      __cil_tmp12 = r + i;
#line 1765
      __cil_tmp13 = *__cil_tmp12;
#line 1765
      __cil_tmp14 = (int )__cil_tmp13;
#line 1765
      __cil_tmp15 = g + i;
#line 1765
      __cil_tmp16 = *__cil_tmp15;
#line 1765
      __cil_tmp17 = (int )__cil_tmp16;
#line 1765
      __cil_tmp18 = b + i;
#line 1765
      __cil_tmp19 = *__cil_tmp18;
#line 1765
      __cil_tmp20 = (int )__cil_tmp19;
#line 1765
      drm_ut_debug_printk(1U, "drm", "vmw_du_crtc_gamma_set", "%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n",
                          i, __cil_tmp14, __cil_tmp17, __cil_tmp20);
      }
#line 1765
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1767
    __cil_tmp21 = i * 3;
#line 1767
    __cil_tmp22 = 1024 + __cil_tmp21;
#line 1767
    __cil_tmp23 = (unsigned int )__cil_tmp22;
#line 1767
    __cil_tmp24 = r + i;
#line 1767
    __cil_tmp25 = *__cil_tmp24;
#line 1767
    __cil_tmp26 = (int )__cil_tmp25;
#line 1767
    __cil_tmp27 = __cil_tmp26 >> 8;
#line 1767
    __cil_tmp28 = (uint32_t )__cil_tmp27;
#line 1767
    vmw_write(dev_priv, __cil_tmp23, __cil_tmp28);
#line 1768
    __cil_tmp29 = i * 3;
#line 1768
    __cil_tmp30 = 1024 + __cil_tmp29;
#line 1768
    __cil_tmp31 = __cil_tmp30 + 1;
#line 1768
    __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 1768
    __cil_tmp33 = g + i;
#line 1768
    __cil_tmp34 = *__cil_tmp33;
#line 1768
    __cil_tmp35 = (int )__cil_tmp34;
#line 1768
    __cil_tmp36 = __cil_tmp35 >> 8;
#line 1768
    __cil_tmp37 = (uint32_t )__cil_tmp36;
#line 1768
    vmw_write(dev_priv, __cil_tmp32, __cil_tmp37);
#line 1769
    __cil_tmp38 = i * 3;
#line 1769
    __cil_tmp39 = 1024 + __cil_tmp38;
#line 1769
    __cil_tmp40 = __cil_tmp39 + 2;
#line 1769
    __cil_tmp41 = (unsigned int )__cil_tmp40;
#line 1769
    __cil_tmp42 = b + i;
#line 1769
    __cil_tmp43 = *__cil_tmp42;
#line 1769
    __cil_tmp44 = (int )__cil_tmp43;
#line 1769
    __cil_tmp45 = __cil_tmp44 >> 8;
#line 1769
    __cil_tmp46 = (uint32_t )__cil_tmp45;
#line 1769
    vmw_write(dev_priv, __cil_tmp41, __cil_tmp46);
#line 1764
    i = i + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1771
  return;
}
}
#line 1773 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) 
{ 

  {
#line 1775
  return;
}
}
#line 1777 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_connector_save(struct drm_connector *connector ) 
{ 

  {
#line 1779
  return;
}
}
#line 1781 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void vmw_du_connector_restore(struct drm_connector *connector ) 
{ 

  {
#line 1783
  return;
}
}
#line 1785 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) 
{ uint32_t num_displays ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_display_unit *du ;
  struct drm_connector    *__mptr ;
  int tmp___8 ;
  struct drm_connector    *__mptr___1 ;
  struct vmw_display_unit *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_connector *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct mutex *__cil_tmp24 ;
  struct vmw_display_unit *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct drm_connector *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  struct vmw_display_unit *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  {
#line 1789
  dev = *((struct drm_device **)connector);
#line 1790
  tmp___7 = vmw_priv(dev);
#line 1790
  dev_priv = tmp___7;
#line 1791
  __mptr = (struct drm_connector    *)connector;
#line 1791
  __cil_tmp12 = (struct vmw_display_unit *)0;
#line 1791
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 1791
  __cil_tmp14 = __cil_tmp13 + 616;
#line 1791
  __cil_tmp15 = (struct drm_connector *)__cil_tmp14;
#line 1791
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 1791
  __cil_tmp17 = (char *)__mptr;
#line 1791
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 1791
  du = (struct vmw_display_unit *)__cil_tmp18;
#line 1793
  __cil_tmp19 = (unsigned long )dev_priv;
#line 1793
  __cil_tmp20 = __cil_tmp19 + 2184;
#line 1793
  __cil_tmp21 = (struct mutex *)__cil_tmp20;
#line 1793
  mutex_lock(__cil_tmp21);
#line 1794
  num_displays = vmw_read(dev_priv, 31U);
#line 1795
  __cil_tmp22 = (unsigned long )dev_priv;
#line 1795
  __cil_tmp23 = __cil_tmp22 + 2184;
#line 1795
  __cil_tmp24 = (struct mutex *)__cil_tmp23;
#line 1795
  mutex_unlock(__cil_tmp24);
#line 1797
  __mptr___1 = (struct drm_connector    *)connector;
  }
  {
#line 1797
  __cil_tmp25 = (struct vmw_display_unit *)0;
#line 1797
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 1797
  __cil_tmp27 = __cil_tmp26 + 616;
#line 1797
  __cil_tmp28 = (struct drm_connector *)__cil_tmp27;
#line 1797
  __cil_tmp29 = (unsigned int )__cil_tmp28;
#line 1797
  __cil_tmp30 = (char *)__mptr___1;
#line 1797
  __cil_tmp31 = __cil_tmp30 - __cil_tmp29;
#line 1797
  __cil_tmp32 = (struct vmw_display_unit *)__cil_tmp31;
#line 1797
  __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 1797
  __cil_tmp34 = __cil_tmp33 + 2032;
#line 1797
  __cil_tmp35 = *((unsigned int *)__cil_tmp34);
#line 1797
  if (__cil_tmp35 < num_displays) {
    {
#line 1797
    __cil_tmp36 = (unsigned long )du;
#line 1797
    __cil_tmp37 = __cil_tmp36 + 2044;
#line 1797
    if (*((bool *)__cil_tmp37)) {
#line 1797
      tmp___8 = 1;
    } else {
#line 1797
      tmp___8 = 2;
    }
    }
  } else {
#line 1797
    tmp___8 = 2;
  }
  }
#line 1797
  return ((enum drm_connector_status )tmp___8);
}
}
#line 1802 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static struct drm_display_mode vmw_kms_connector_builtin[19]  = 
#line 1802
  {      {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'8',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 25175, 640, 656, 752, 800,
      0, 480, 489, 492, 525, 0, (unsigned int )((1 << 1) | (1 << 3)), 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'8', (char )'0',
                                                                 (char )'0', (char )'x',
                                                                 (char )'6', (char )'0',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 40000, 800, 840, 968, 1056,
      0, 600, 601, 605, 628, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'0',
                                                                 (char )'2', (char )'4',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806,
      0, (unsigned int )((1 << 1) | (1 << 3)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'1',
                                                                 (char )'5', (char )'2',
                                                                 (char )'x', (char )'8',
                                                                 (char )'6', (char )'4',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798,
      0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'8',
                                                                 (char )'0', (char )'0',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831,
      0, (unsigned int )(1 | (1 << 3)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'9',
                                                                 (char )'6', (char )'0',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'2',
                                                                 (char )'4', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 108000, 1280, 1328, 1440,
      1688, 0, 1024, 1025, 1028, 1066, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'3',
                                                                 (char )'6', (char )'0',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'4',
                                                                 (char )'0', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'5',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 121750, 1400, 1488, 1632,
      1864, 0, 1050, 1053, 1057, 1089, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'4', (char )'4', (char )'0',
                                          (char )'x', (char )'9', (char )'0', (char )'0',
                                          (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934,
      0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'6',
                                                                 (char )'0', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'2', (char )'0',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 162000, 1600, 1664, 1856,
      2160, 0, 1200, 1201, 1204, 1250, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'6',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'5',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 146250, 1680, 1784, 1960,
      2240, 0, 1050, 1053, 1059, 1089, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'7', (char )'9', (char )'2',
                                          (char )'x', (char )'1', (char )'3', (char )'4',
                                          (char )'4', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 204750, 1792, 1920, 2120, 2448, 0, 1344, 1345, 1348,
      1394, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'8',
                                                                 (char )'5', (char )'6',
                                                                 (char )'x', (char )'1',
                                                                 (char )'3', (char )'9',
                                                                 (char )'2', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 218250, 1856, 1952, 2176,
      2528, 0, 1392, 1393, 1396, 1439, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'9', (char )'2', (char )'0',
                                          (char )'x', (char )'1', (char )'2', (char )'0',
                                          (char )'0', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 193250, 1920, 2056, 2256, 2592, 0, 1200, 1203, 1209,
      1245, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'9',
                                                                 (char )'2', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'4', (char )'4',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 234000, 1920, 2048, 2256,
      2600, 0, 1440, 1441, 1444, 1500, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'2', (char )'5', (char )'6', (char )'0',
                                          (char )'x', (char )'1', (char )'6', (char )'0',
                                          (char )'0', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 348500, 2560, 2752, 3032, 3504, 0, 1600, 1603, 1609,
      1658, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'\000'}, (enum drm_mode_status )0,
      0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}};
#line 1886 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
static void vmw_guess_mode_timing(struct drm_display_mode *mode ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  u32 __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  u32 __cil_tmp41 ;
  u32 __cil_tmp42 ;
  u32 __cil_tmp43 ;
  u32 __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_display_mode    *__cil_tmp47 ;

  {
  {
#line 1888
  __cil_tmp2 = (unsigned long )mode;
#line 1888
  __cil_tmp3 = __cil_tmp2 + 72;
#line 1888
  __cil_tmp4 = (unsigned long )mode;
#line 1888
  __cil_tmp5 = __cil_tmp4 + 68;
#line 1888
  __cil_tmp6 = *((int *)__cil_tmp5);
#line 1888
  *((int *)__cil_tmp3) = __cil_tmp6 + 50;
#line 1889
  __cil_tmp7 = (unsigned long )mode;
#line 1889
  __cil_tmp8 = __cil_tmp7 + 76;
#line 1889
  __cil_tmp9 = (unsigned long )mode;
#line 1889
  __cil_tmp10 = __cil_tmp9 + 72;
#line 1889
  __cil_tmp11 = *((int *)__cil_tmp10);
#line 1889
  *((int *)__cil_tmp8) = __cil_tmp11 + 50;
#line 1890
  __cil_tmp12 = (unsigned long )mode;
#line 1890
  __cil_tmp13 = __cil_tmp12 + 80;
#line 1890
  __cil_tmp14 = (unsigned long )mode;
#line 1890
  __cil_tmp15 = __cil_tmp14 + 76;
#line 1890
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 1890
  *((int *)__cil_tmp13) = __cil_tmp16 + 50;
#line 1892
  __cil_tmp17 = (unsigned long )mode;
#line 1892
  __cil_tmp18 = __cil_tmp17 + 92;
#line 1892
  __cil_tmp19 = (unsigned long )mode;
#line 1892
  __cil_tmp20 = __cil_tmp19 + 88;
#line 1892
  __cil_tmp21 = *((int *)__cil_tmp20);
#line 1892
  *((int *)__cil_tmp18) = __cil_tmp21 + 50;
#line 1893
  __cil_tmp22 = (unsigned long )mode;
#line 1893
  __cil_tmp23 = __cil_tmp22 + 96;
#line 1893
  __cil_tmp24 = (unsigned long )mode;
#line 1893
  __cil_tmp25 = __cil_tmp24 + 92;
#line 1893
  __cil_tmp26 = *((int *)__cil_tmp25);
#line 1893
  *((int *)__cil_tmp23) = __cil_tmp26 + 50;
#line 1894
  __cil_tmp27 = (unsigned long )mode;
#line 1894
  __cil_tmp28 = __cil_tmp27 + 100;
#line 1894
  __cil_tmp29 = (unsigned long )mode;
#line 1894
  __cil_tmp30 = __cil_tmp29 + 96;
#line 1894
  __cil_tmp31 = *((int *)__cil_tmp30);
#line 1894
  *((int *)__cil_tmp28) = __cil_tmp31 + 50;
#line 1896
  __cil_tmp32 = (unsigned long )mode;
#line 1896
  __cil_tmp33 = __cil_tmp32 + 64;
#line 1896
  __cil_tmp34 = (unsigned long )mode;
#line 1896
  __cil_tmp35 = __cil_tmp34 + 100;
#line 1896
  __cil_tmp36 = *((int *)__cil_tmp35);
#line 1896
  __cil_tmp37 = (u32 )__cil_tmp36;
#line 1896
  __cil_tmp38 = (unsigned long )mode;
#line 1896
  __cil_tmp39 = __cil_tmp38 + 80;
#line 1896
  __cil_tmp40 = *((int *)__cil_tmp39);
#line 1896
  __cil_tmp41 = (u32 )__cil_tmp40;
#line 1896
  __cil_tmp42 = __cil_tmp41 * __cil_tmp37;
#line 1896
  __cil_tmp43 = __cil_tmp42 / 100U;
#line 1896
  __cil_tmp44 = __cil_tmp43 * 6U;
#line 1896
  *((int *)__cil_tmp33) = (int )__cil_tmp44;
#line 1897
  __cil_tmp45 = (unsigned long )mode;
#line 1897
  __cil_tmp46 = __cil_tmp45 + 204;
#line 1897
  __cil_tmp47 = (struct drm_display_mode    *)mode;
#line 1897
  *((int *)__cil_tmp46) = drm_mode_vrefresh(__cil_tmp47);
  }
#line 1898
  return;
}
}
#line 1901 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) 
{ struct vmw_display_unit *du ;
  struct drm_connector    *__mptr ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *bmode ;
  struct drm_display_mode prefmode ;
  int i ;
  bool tmp___8 ;
  bool tmp___9 ;
  struct vmw_display_unit *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_connector *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  struct drm_display_mode *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  struct drm_display_mode    *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  uint32_t __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  int __cil_tmp121 ;
  uint32_t __cil_tmp122 ;
  void *__cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  struct drm_display_mode *__cil_tmp128 ;
  struct list_head *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  struct drm_display_mode *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  int __cil_tmp143 ;
  uint32_t __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  int __cil_tmp147 ;
  uint32_t __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  uint32_t __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  int __cil_tmp156 ;
  uint32_t __cil_tmp157 ;
  struct drm_display_mode    *__cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  struct drm_display_mode    *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct drm_display_mode *__cil_tmp166 ;
  struct list_head *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  struct list_head *__cil_tmp170 ;

  {
  {
#line 1904
  __mptr = (struct drm_connector    *)connector;
#line 1904
  __cil_tmp15 = (struct vmw_display_unit *)0;
#line 1904
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 1904
  __cil_tmp17 = __cil_tmp16 + 616;
#line 1904
  __cil_tmp18 = (struct drm_connector *)__cil_tmp17;
#line 1904
  __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 1904
  __cil_tmp20 = (char *)__mptr;
#line 1904
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
#line 1904
  du = (struct vmw_display_unit *)__cil_tmp21;
#line 1905
  dev = *((struct drm_device **)connector);
#line 1906
  tmp___7 = vmw_priv(dev);
#line 1906
  dev_priv = tmp___7;
#line 1907
  __cil_tmp22 = (void *)0;
#line 1907
  mode = (struct drm_display_mode *)__cil_tmp22;
#line 1909
  __cil_tmp23 = & prefmode;
#line 1909
  *((struct list_head **)__cil_tmp23) = (struct list_head *)0;
#line 1909
  __cil_tmp24 = 0 + 8;
#line 1909
  __cil_tmp25 = (unsigned long )(& prefmode) + __cil_tmp24;
#line 1909
  *((struct list_head **)__cil_tmp25) = (struct list_head *)0;
#line 1909
  __cil_tmp26 = (unsigned long )(& prefmode) + 16;
#line 1909
  *((uint32_t *)__cil_tmp26) = 0U;
#line 1909
  __cil_tmp27 = 16 + 4;
#line 1909
  __cil_tmp28 = (unsigned long )(& prefmode) + __cil_tmp27;
#line 1909
  *((uint32_t *)__cil_tmp28) = 0U;
#line 1909
  __cil_tmp29 = 0 * 1UL;
#line 1909
  __cil_tmp30 = 24 + __cil_tmp29;
#line 1909
  __cil_tmp31 = (unsigned long )(& prefmode) + __cil_tmp30;
#line 1909
  *((char *)__cil_tmp31) = (char )'p';
#line 1909
  __cil_tmp32 = 1 * 1UL;
#line 1909
  __cil_tmp33 = 24 + __cil_tmp32;
#line 1909
  __cil_tmp34 = (unsigned long )(& prefmode) + __cil_tmp33;
#line 1909
  *((char *)__cil_tmp34) = (char )'r';
#line 1909
  __cil_tmp35 = 2 * 1UL;
#line 1909
  __cil_tmp36 = 24 + __cil_tmp35;
#line 1909
  __cil_tmp37 = (unsigned long )(& prefmode) + __cil_tmp36;
#line 1909
  *((char *)__cil_tmp37) = (char )'e';
#line 1909
  __cil_tmp38 = 3 * 1UL;
#line 1909
  __cil_tmp39 = 24 + __cil_tmp38;
#line 1909
  __cil_tmp40 = (unsigned long )(& prefmode) + __cil_tmp39;
#line 1909
  *((char *)__cil_tmp40) = (char )'f';
#line 1909
  __cil_tmp41 = 4 * 1UL;
#line 1909
  __cil_tmp42 = 24 + __cil_tmp41;
#line 1909
  __cil_tmp43 = (unsigned long )(& prefmode) + __cil_tmp42;
#line 1909
  *((char *)__cil_tmp43) = (char )'e';
#line 1909
  __cil_tmp44 = 5 * 1UL;
#line 1909
  __cil_tmp45 = 24 + __cil_tmp44;
#line 1909
  __cil_tmp46 = (unsigned long )(& prefmode) + __cil_tmp45;
#line 1909
  *((char *)__cil_tmp46) = (char )'r';
#line 1909
  __cil_tmp47 = 6 * 1UL;
#line 1909
  __cil_tmp48 = 24 + __cil_tmp47;
#line 1909
  __cil_tmp49 = (unsigned long )(& prefmode) + __cil_tmp48;
#line 1909
  *((char *)__cil_tmp49) = (char )'r';
#line 1909
  __cil_tmp50 = 7 * 1UL;
#line 1909
  __cil_tmp51 = 24 + __cil_tmp50;
#line 1909
  __cil_tmp52 = (unsigned long )(& prefmode) + __cil_tmp51;
#line 1909
  *((char *)__cil_tmp52) = (char )'e';
#line 1909
  __cil_tmp53 = 8 * 1UL;
#line 1909
  __cil_tmp54 = 24 + __cil_tmp53;
#line 1909
  __cil_tmp55 = (unsigned long )(& prefmode) + __cil_tmp54;
#line 1909
  *((char *)__cil_tmp55) = (char )'d';
#line 1909
  __cil_tmp56 = 9 * 1UL;
#line 1909
  __cil_tmp57 = 24 + __cil_tmp56;
#line 1909
  __cil_tmp58 = (unsigned long )(& prefmode) + __cil_tmp57;
#line 1909
  *((char *)__cil_tmp58) = (char )'\000';
#line 1909
  __cil_tmp59 = (unsigned long )(& prefmode) + 56;
#line 1909
  *((enum drm_mode_status *)__cil_tmp59) = (enum drm_mode_status )0;
#line 1909
  __cil_tmp60 = (unsigned long )(& prefmode) + 60;
#line 1909
  __cil_tmp61 = 1 << 3;
#line 1909
  __cil_tmp62 = 1 << 6;
#line 1909
  __cil_tmp63 = __cil_tmp62 | __cil_tmp61;
#line 1909
  *((unsigned int *)__cil_tmp60) = (unsigned int )__cil_tmp63;
#line 1909
  __cil_tmp64 = (unsigned long )(& prefmode) + 64;
#line 1909
  *((int *)__cil_tmp64) = 0;
#line 1909
  __cil_tmp65 = (unsigned long )(& prefmode) + 68;
#line 1909
  *((int *)__cil_tmp65) = 0;
#line 1909
  __cil_tmp66 = (unsigned long )(& prefmode) + 72;
#line 1909
  *((int *)__cil_tmp66) = 0;
#line 1909
  __cil_tmp67 = (unsigned long )(& prefmode) + 76;
#line 1909
  *((int *)__cil_tmp67) = 0;
#line 1909
  __cil_tmp68 = (unsigned long )(& prefmode) + 80;
#line 1909
  *((int *)__cil_tmp68) = 0;
#line 1909
  __cil_tmp69 = (unsigned long )(& prefmode) + 84;
#line 1909
  *((int *)__cil_tmp69) = 0;
#line 1909
  __cil_tmp70 = (unsigned long )(& prefmode) + 88;
#line 1909
  *((int *)__cil_tmp70) = 0;
#line 1909
  __cil_tmp71 = (unsigned long )(& prefmode) + 92;
#line 1909
  *((int *)__cil_tmp71) = 0;
#line 1909
  __cil_tmp72 = (unsigned long )(& prefmode) + 96;
#line 1909
  *((int *)__cil_tmp72) = 0;
#line 1909
  __cil_tmp73 = (unsigned long )(& prefmode) + 100;
#line 1909
  *((int *)__cil_tmp73) = 0;
#line 1909
  __cil_tmp74 = (unsigned long )(& prefmode) + 104;
#line 1909
  *((int *)__cil_tmp74) = 0;
#line 1909
  __cil_tmp75 = (unsigned long )(& prefmode) + 108;
#line 1909
  __cil_tmp76 = 1 << 2;
#line 1909
  __cil_tmp77 = 1 << 1;
#line 1909
  __cil_tmp78 = __cil_tmp77 | __cil_tmp76;
#line 1909
  *((unsigned int *)__cil_tmp75) = (unsigned int )__cil_tmp78;
#line 1909
  __cil_tmp79 = (unsigned long )(& prefmode) + 112;
#line 1909
  *((int *)__cil_tmp79) = 0;
#line 1909
  __cil_tmp80 = (unsigned long )(& prefmode) + 116;
#line 1909
  *((int *)__cil_tmp80) = 0;
#line 1909
  __cil_tmp81 = (unsigned long )(& prefmode) + 120;
#line 1909
  *((int *)__cil_tmp81) = 0;
#line 1909
  __cil_tmp82 = (unsigned long )(& prefmode) + 124;
#line 1909
  *((int *)__cil_tmp82) = 0;
#line 1909
  __cil_tmp83 = (unsigned long )(& prefmode) + 128;
#line 1909
  *((int *)__cil_tmp83) = 0;
#line 1909
  __cil_tmp84 = (unsigned long )(& prefmode) + 132;
#line 1909
  *((int *)__cil_tmp84) = 0;
#line 1909
  __cil_tmp85 = (unsigned long )(& prefmode) + 136;
#line 1909
  *((int *)__cil_tmp85) = 0;
#line 1909
  __cil_tmp86 = (unsigned long )(& prefmode) + 140;
#line 1909
  *((int *)__cil_tmp86) = 0;
#line 1909
  __cil_tmp87 = (unsigned long )(& prefmode) + 144;
#line 1909
  *((int *)__cil_tmp87) = 0;
#line 1909
  __cil_tmp88 = (unsigned long )(& prefmode) + 148;
#line 1909
  *((int *)__cil_tmp88) = 0;
#line 1909
  __cil_tmp89 = (unsigned long )(& prefmode) + 152;
#line 1909
  *((int *)__cil_tmp89) = 0;
#line 1909
  __cil_tmp90 = (unsigned long )(& prefmode) + 156;
#line 1909
  *((int *)__cil_tmp90) = 0;
#line 1909
  __cil_tmp91 = (unsigned long )(& prefmode) + 160;
#line 1909
  *((int *)__cil_tmp91) = 0;
#line 1909
  __cil_tmp92 = (unsigned long )(& prefmode) + 164;
#line 1909
  *((int *)__cil_tmp92) = 0;
#line 1909
  __cil_tmp93 = (unsigned long )(& prefmode) + 168;
#line 1909
  *((int *)__cil_tmp93) = 0;
#line 1909
  __cil_tmp94 = (unsigned long )(& prefmode) + 172;
#line 1909
  *((int *)__cil_tmp94) = 0;
#line 1909
  __cil_tmp95 = (unsigned long )(& prefmode) + 176;
#line 1909
  *((int *)__cil_tmp95) = 0;
#line 1909
  __cil_tmp96 = (unsigned long )(& prefmode) + 180;
#line 1909
  *((int *)__cil_tmp96) = 0;
#line 1909
  __cil_tmp97 = (unsigned long )(& prefmode) + 184;
#line 1909
  *((int *)__cil_tmp97) = 0;
#line 1909
  __cil_tmp98 = (unsigned long )(& prefmode) + 188;
#line 1909
  *((int *)__cil_tmp98) = 0;
#line 1909
  __cil_tmp99 = (unsigned long )(& prefmode) + 192;
#line 1909
  *((int **)__cil_tmp99) = (int *)0;
#line 1909
  __cil_tmp100 = (unsigned long )(& prefmode) + 200;
#line 1909
  *((int *)__cil_tmp100) = 0;
#line 1909
  __cil_tmp101 = (unsigned long )(& prefmode) + 204;
#line 1909
  *((int *)__cil_tmp101) = 0;
#line 1909
  __cil_tmp102 = (unsigned long )(& prefmode) + 208;
#line 1909
  *((int *)__cil_tmp102) = 0;
#line 1918
  __cil_tmp103 = (struct drm_display_mode    *)(& prefmode);
#line 1918
  mode = drm_mode_duplicate(dev, __cil_tmp103);
  }
#line 1919
  if (! mode) {
#line 1920
    return (0);
  } else {

  }
  {
#line 1921
  __cil_tmp104 = (unsigned long )mode;
#line 1921
  __cil_tmp105 = __cil_tmp104 + 68;
#line 1921
  __cil_tmp106 = (unsigned long )du;
#line 1921
  __cil_tmp107 = __cil_tmp106 + 2036;
#line 1921
  __cil_tmp108 = *((unsigned int *)__cil_tmp107);
#line 1921
  *((int *)__cil_tmp105) = (int )__cil_tmp108;
#line 1922
  __cil_tmp109 = (unsigned long )mode;
#line 1922
  __cil_tmp110 = __cil_tmp109 + 88;
#line 1922
  __cil_tmp111 = (unsigned long )du;
#line 1922
  __cil_tmp112 = __cil_tmp111 + 2040;
#line 1922
  __cil_tmp113 = *((unsigned int *)__cil_tmp112);
#line 1922
  *((int *)__cil_tmp110) = (int )__cil_tmp113;
#line 1923
  vmw_guess_mode_timing(mode);
#line 1925
  __cil_tmp114 = (unsigned long )mode;
#line 1925
  __cil_tmp115 = __cil_tmp114 + 68;
#line 1925
  __cil_tmp116 = *((int *)__cil_tmp115);
#line 1925
  __cil_tmp117 = __cil_tmp116 * 2;
#line 1925
  __cil_tmp118 = (uint32_t )__cil_tmp117;
#line 1925
  __cil_tmp119 = (unsigned long )mode;
#line 1925
  __cil_tmp120 = __cil_tmp119 + 88;
#line 1925
  __cil_tmp121 = *((int *)__cil_tmp120);
#line 1925
  __cil_tmp122 = (uint32_t )__cil_tmp121;
#line 1925
  tmp___8 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp118, __cil_tmp122);
  }
#line 1925
  if (tmp___8) {
    {
#line 1927
    drm_mode_probed_add(connector, mode);
    }
  } else {
    {
#line 1929
    drm_mode_destroy(dev, mode);
#line 1930
    __cil_tmp123 = (void *)0;
#line 1930
    mode = (struct drm_display_mode *)__cil_tmp123;
    }
  }
  {
#line 1933
  __cil_tmp124 = (unsigned long )du;
#line 1933
  __cil_tmp125 = __cil_tmp124 + 2048;
#line 1933
  if (*((struct drm_display_mode **)__cil_tmp125)) {
    {
#line 1934
    __cil_tmp126 = (unsigned long )du;
#line 1934
    __cil_tmp127 = __cil_tmp126 + 2048;
#line 1934
    __cil_tmp128 = *((struct drm_display_mode **)__cil_tmp127);
#line 1934
    __cil_tmp129 = (struct list_head *)__cil_tmp128;
#line 1934
    list_del_init(__cil_tmp129);
#line 1935
    __cil_tmp130 = (unsigned long )du;
#line 1935
    __cil_tmp131 = __cil_tmp130 + 2048;
#line 1935
    __cil_tmp132 = *((struct drm_display_mode **)__cil_tmp131);
#line 1935
    drm_mode_destroy(dev, __cil_tmp132);
    }
  } else {

  }
  }
#line 1939
  __cil_tmp133 = (unsigned long )du;
#line 1939
  __cil_tmp134 = __cil_tmp133 + 2048;
#line 1939
  *((struct drm_display_mode **)__cil_tmp134) = mode;
#line 1942
  i = 0;
  {
#line 1942
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1942
    __cil_tmp135 = i * 216UL;
#line 1942
    __cil_tmp136 = __cil_tmp135 + 60;
#line 1942
    __cil_tmp137 = (unsigned long )(vmw_kms_connector_builtin) + __cil_tmp136;
#line 1942
    __cil_tmp138 = *((unsigned int *)__cil_tmp137);
#line 1942
    if (__cil_tmp138 != 0U) {

    } else {
#line 1942
      goto while_break;
    }
    }
#line 1943
    __cil_tmp139 = i * 216UL;
#line 1943
    __cil_tmp140 = (unsigned long )(vmw_kms_connector_builtin) + __cil_tmp139;
#line 1943
    bmode = (struct drm_display_mode *)__cil_tmp140;
    {
#line 1944
    __cil_tmp141 = (unsigned long )bmode;
#line 1944
    __cil_tmp142 = __cil_tmp141 + 68;
#line 1944
    __cil_tmp143 = *((int *)__cil_tmp142);
#line 1944
    __cil_tmp144 = (uint32_t )__cil_tmp143;
#line 1944
    if (__cil_tmp144 > max_width) {
#line 1946
      goto __Cont;
    } else {
      {
#line 1944
      __cil_tmp145 = (unsigned long )bmode;
#line 1944
      __cil_tmp146 = __cil_tmp145 + 88;
#line 1944
      __cil_tmp147 = *((int *)__cil_tmp146);
#line 1944
      __cil_tmp148 = (uint32_t )__cil_tmp147;
#line 1944
      if (__cil_tmp148 > max_height) {
#line 1946
        goto __Cont;
      } else {

      }
      }
    }
    }
    {
#line 1948
    __cil_tmp149 = (unsigned long )bmode;
#line 1948
    __cil_tmp150 = __cil_tmp149 + 68;
#line 1948
    __cil_tmp151 = *((int *)__cil_tmp150);
#line 1948
    __cil_tmp152 = __cil_tmp151 * 2;
#line 1948
    __cil_tmp153 = (uint32_t )__cil_tmp152;
#line 1948
    __cil_tmp154 = (unsigned long )bmode;
#line 1948
    __cil_tmp155 = __cil_tmp154 + 88;
#line 1948
    __cil_tmp156 = *((int *)__cil_tmp155);
#line 1948
    __cil_tmp157 = (uint32_t )__cil_tmp156;
#line 1948
    tmp___9 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp153, __cil_tmp157);
    }
#line 1948
    if (tmp___9) {

    } else {
#line 1950
      goto __Cont;
    }
    {
#line 1952
    __cil_tmp158 = (struct drm_display_mode    *)bmode;
#line 1952
    mode = drm_mode_duplicate(dev, __cil_tmp158);
    }
#line 1953
    if (! mode) {
#line 1954
      return (0);
    } else {

    }
    {
#line 1955
    __cil_tmp159 = (unsigned long )mode;
#line 1955
    __cil_tmp160 = __cil_tmp159 + 204;
#line 1955
    __cil_tmp161 = (struct drm_display_mode    *)mode;
#line 1955
    *((int *)__cil_tmp160) = drm_mode_vrefresh(__cil_tmp161);
#line 1957
    drm_mode_probed_add(connector, mode);
    }
    __Cont: /* CIL Label */ 
#line 1942
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1961
  __cil_tmp162 = (unsigned long )du;
#line 1961
  __cil_tmp163 = __cil_tmp162 + 2048;
#line 1961
  if (*((struct drm_display_mode **)__cil_tmp163)) {
    {
#line 1962
    __cil_tmp164 = (unsigned long )du;
#line 1962
    __cil_tmp165 = __cil_tmp164 + 2048;
#line 1962
    __cil_tmp166 = *((struct drm_display_mode **)__cil_tmp165);
#line 1962
    __cil_tmp167 = (struct list_head *)__cil_tmp166;
#line 1962
    __cil_tmp168 = (unsigned long )connector;
#line 1962
    __cil_tmp169 = __cil_tmp168 + 848;
#line 1962
    __cil_tmp170 = (struct list_head *)__cil_tmp169;
#line 1962
    list_move(__cil_tmp167, __cil_tmp170);
    }
  } else {

  }
  }
  {
#line 1964
  drm_mode_connector_list_update(connector);
  }
#line 1966
  return (1);
}
}
#line 1969 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) 
{ 

  {
#line 1973
  return (0);
}
}
#line 1977 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_update_layout_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  void *user_rects ;
  struct drm_vmw_rect *rects ;
  unsigned int rects_size ;
  int ret ;
  int i ;
  struct drm_mode_config *mode_config ;
  long tmp___9 ;
  struct drm_vmw_rect def_rect ;
  void *tmp___10 ;
  long tmp___11 ;
  unsigned long tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct drm_master *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct ttm_lock *__cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  struct drm_vmw_rect *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  size_t __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint64_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void *__cil_tmp50 ;
  void    *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  struct drm_vmw_rect *__cil_tmp59 ;
  int32_t __cil_tmp60 ;
  struct drm_vmw_rect *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int32_t __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  struct drm_vmw_rect *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  struct drm_vmw_rect *__cil_tmp73 ;
  int32_t __cil_tmp74 ;
  uint32_t __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  int __cil_tmp79 ;
  uint32_t __cil_tmp80 ;
  struct drm_vmw_rect *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  struct drm_vmw_rect *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  int32_t __cil_tmp88 ;
  uint32_t __cil_tmp89 ;
  uint32_t __cil_tmp90 ;
  uint32_t __cil_tmp91 ;
  void    *__cil_tmp92 ;
  struct ttm_lock *__cil_tmp93 ;

  {
  {
#line 1980
  tmp___7 = vmw_priv(dev);
#line 1980
  dev_priv = tmp___7;
#line 1981
  arg = (struct drm_vmw_update_layout_arg *)data;
#line 1983
  __cil_tmp21 = (unsigned long )file_priv;
#line 1983
  __cil_tmp22 = __cil_tmp21 + 152;
#line 1983
  __cil_tmp23 = *((struct drm_master **)__cil_tmp22);
#line 1983
  tmp___8 = vmw_master(__cil_tmp23);
#line 1983
  vmaster = tmp___8;
#line 1989
  __cil_tmp24 = (unsigned long )dev;
#line 1989
  __cil_tmp25 = __cil_tmp24 + 1152;
#line 1989
  mode_config = (struct drm_mode_config *)__cil_tmp25;
#line 1991
  __cil_tmp26 = (struct ttm_lock *)vmaster;
#line 1991
  __cil_tmp27 = (bool )1;
#line 1991
  ret = ttm_read_lock(__cil_tmp26, __cil_tmp27);
#line 1992
  __cil_tmp28 = ret != 0;
#line 1992
  __cil_tmp29 = ! __cil_tmp28;
#line 1992
  __cil_tmp30 = ! __cil_tmp29;
#line 1992
  __cil_tmp31 = (long )__cil_tmp30;
#line 1992
  tmp___9 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 1992
  if (tmp___9) {
#line 1993
    return (ret);
  } else {

  }
  {
#line 1995
  __cil_tmp32 = *((uint32_t *)arg);
#line 1995
  if (! __cil_tmp32) {
    {
#line 1996
    __cil_tmp33 = & def_rect;
#line 1996
    *((int32_t *)__cil_tmp33) = 0;
#line 1996
    __cil_tmp34 = (unsigned long )(& def_rect) + 4;
#line 1996
    *((int32_t *)__cil_tmp34) = 0;
#line 1996
    __cil_tmp35 = (unsigned long )(& def_rect) + 8;
#line 1996
    *((uint32_t *)__cil_tmp35) = (uint32_t )800;
#line 1996
    __cil_tmp36 = (unsigned long )(& def_rect) + 12;
#line 1996
    *((uint32_t *)__cil_tmp36) = (uint32_t )600;
#line 1997
    vmw_du_update_layout(dev_priv, 1U, & def_rect);
    }
#line 1998
    goto out_unlock;
  } else {

  }
  }
  {
#line 2001
  __cil_tmp37 = *((uint32_t *)arg);
#line 2001
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 2001
  __cil_tmp39 = __cil_tmp38 * 16UL;
#line 2001
  rects_size = (unsigned int )__cil_tmp39;
#line 2002
  __cil_tmp40 = *((uint32_t *)arg);
#line 2002
  __cil_tmp41 = (size_t )__cil_tmp40;
#line 2002
  tmp___10 = kcalloc(__cil_tmp41, 16UL, 208U);
#line 2002
  rects = (struct drm_vmw_rect *)tmp___10;
#line 2004
  __cil_tmp42 = ! rects;
#line 2004
  __cil_tmp43 = ! __cil_tmp42;
#line 2004
  __cil_tmp44 = ! __cil_tmp43;
#line 2004
  __cil_tmp45 = (long )__cil_tmp44;
#line 2004
  tmp___11 = ldv__builtin_expect(__cil_tmp45, 0L);
  }
#line 2004
  if (tmp___11) {
#line 2005
    ret = -12;
#line 2006
    goto out_unlock;
  } else {

  }
  {
#line 2009
  __cil_tmp46 = (unsigned long )arg;
#line 2009
  __cil_tmp47 = __cil_tmp46 + 8;
#line 2009
  __cil_tmp48 = *((uint64_t *)__cil_tmp47);
#line 2009
  __cil_tmp49 = (unsigned long )__cil_tmp48;
#line 2009
  user_rects = (void *)__cil_tmp49;
#line 2010
  __cil_tmp50 = (void *)rects;
#line 2010
  __cil_tmp51 = (void    *)user_rects;
#line 2010
  __cil_tmp52 = (unsigned long )rects_size;
#line 2010
  tmp___12 = (unsigned long )copy_from_user(__cil_tmp50, __cil_tmp51, __cil_tmp52);
#line 2010
  ret = (int )tmp___12;
#line 2011
  __cil_tmp53 = ret != 0;
#line 2011
  __cil_tmp54 = ! __cil_tmp53;
#line 2011
  __cil_tmp55 = ! __cil_tmp54;
#line 2011
  __cil_tmp56 = (long )__cil_tmp55;
#line 2011
  tmp___13 = ldv__builtin_expect(__cil_tmp56, 0L);
  }
#line 2011
  if (tmp___13) {
    {
#line 2012
    drm_err("vmw_kms_update_layout_ioctl", "Failed to get rects.\n");
#line 2013
    ret = -14;
    }
#line 2014
    goto out_free;
  } else {

  }
#line 2017
  i = 0;
  {
#line 2017
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2017
    __cil_tmp57 = *((uint32_t *)arg);
#line 2017
    __cil_tmp58 = (uint32_t )i;
#line 2017
    if (__cil_tmp58 < __cil_tmp57) {

    } else {
#line 2017
      goto while_break;
    }
    }
    {
#line 2018
    __cil_tmp59 = rects + i;
#line 2018
    __cil_tmp60 = *((int32_t *)__cil_tmp59);
#line 2018
    if (__cil_tmp60 < 0) {
      {
#line 2022
      drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2023
      ret = -22;
      }
#line 2024
      goto out_free;
    } else {
      {
#line 2018
      __cil_tmp61 = rects + i;
#line 2018
      __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 2018
      __cil_tmp63 = __cil_tmp62 + 4;
#line 2018
      __cil_tmp64 = *((int32_t *)__cil_tmp63);
#line 2018
      if (__cil_tmp64 < 0) {
        {
#line 2022
        drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2023
        ret = -22;
        }
#line 2024
        goto out_free;
      } else {
        {
#line 2018
        __cil_tmp65 = (unsigned long )mode_config;
#line 2018
        __cil_tmp66 = __cil_tmp65 + 336;
#line 2018
        __cil_tmp67 = *((int *)__cil_tmp66);
#line 2018
        __cil_tmp68 = (uint32_t )__cil_tmp67;
#line 2018
        __cil_tmp69 = rects + i;
#line 2018
        __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 2018
        __cil_tmp71 = __cil_tmp70 + 8;
#line 2018
        __cil_tmp72 = *((uint32_t *)__cil_tmp71);
#line 2018
        __cil_tmp73 = rects + i;
#line 2018
        __cil_tmp74 = *((int32_t *)__cil_tmp73);
#line 2018
        __cil_tmp75 = (uint32_t )__cil_tmp74;
#line 2018
        __cil_tmp76 = __cil_tmp75 + __cil_tmp72;
#line 2018
        if (__cil_tmp76 > __cil_tmp68) {
          {
#line 2022
          drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2023
          ret = -22;
          }
#line 2024
          goto out_free;
        } else {
          {
#line 2018
          __cil_tmp77 = (unsigned long )mode_config;
#line 2018
          __cil_tmp78 = __cil_tmp77 + 340;
#line 2018
          __cil_tmp79 = *((int *)__cil_tmp78);
#line 2018
          __cil_tmp80 = (uint32_t )__cil_tmp79;
#line 2018
          __cil_tmp81 = rects + i;
#line 2018
          __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 2018
          __cil_tmp83 = __cil_tmp82 + 12;
#line 2018
          __cil_tmp84 = *((uint32_t *)__cil_tmp83);
#line 2018
          __cil_tmp85 = rects + i;
#line 2018
          __cil_tmp86 = (unsigned long )__cil_tmp85;
#line 2018
          __cil_tmp87 = __cil_tmp86 + 4;
#line 2018
          __cil_tmp88 = *((int32_t *)__cil_tmp87);
#line 2018
          __cil_tmp89 = (uint32_t )__cil_tmp88;
#line 2018
          __cil_tmp90 = __cil_tmp89 + __cil_tmp84;
#line 2018
          if (__cil_tmp90 > __cil_tmp80) {
            {
#line 2022
            drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2023
            ret = -22;
            }
#line 2024
            goto out_free;
          } else {

          }
          }
        }
        }
      }
      }
    }
    }
#line 2017
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2028
  __cil_tmp91 = *((uint32_t *)arg);
#line 2028
  vmw_du_update_layout(dev_priv, __cil_tmp91, rects);
  }
  out_free: 
  {
#line 2031
  __cil_tmp92 = (void    *)rects;
#line 2031
  kfree(__cil_tmp92);
  }
  out_unlock: 
  {
#line 2033
  __cil_tmp93 = (struct ttm_lock *)vmaster;
#line 2033
  ttm_read_unlock(__cil_tmp93);
  }
#line 2034
  return (ret);
}
}
#line 2059
extern void ldv_initialize(void) ;
#line 2062
extern int __VERIFIER_nondet_int(void) ;
#line 2065 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
int LDV_IN_INTERRUPT  ;
#line 2068 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"
void ldv_main2_sequence_infinite_withcheck_stateful(void) 
{ struct drm_framebuffer *var_group1 ;
  struct drm_file *var_group2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_surface_dirty_12_p4 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p5 ;
  unsigned int *var_vmw_framebuffer_create_handle_9_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_dmabuf_dirty_18_p4 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p5 ;
  struct drm_device *var_group3 ;
  struct drm_mode_fb_cmd2 *var_vmw_kms_fb_create_22_p2 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2196
  LDV_IN_INTERRUPT = 1;
#line 2205
  ldv_initialize();
  }
  {
#line 2213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2213
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 2213
    if (tmp___8) {

    } else {
#line 2213
      goto while_break;
    }
    {
#line 2216
    tmp___7 = __VERIFIER_nondet_int();
    }
#line 2218
    if (tmp___7 == 0) {
#line 2218
      goto case_0;
    } else
#line 2244
    if (tmp___7 == 1) {
#line 2244
      goto case_1;
    } else
#line 2270
    if (tmp___7 == 2) {
#line 2270
      goto case_2;
    } else
#line 2296
    if (tmp___7 == 3) {
#line 2296
      goto case_3;
    } else
#line 2322
    if (tmp___7 == 4) {
#line 2322
      goto case_4;
    } else
#line 2348
    if (tmp___7 == 5) {
#line 2348
      goto case_5;
    } else
#line 2374
    if (tmp___7 == 6) {
#line 2374
      goto case_6;
    } else {
      {
#line 2400
      goto switch_default;
#line 2216
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 2230
        vmw_framebuffer_surface_destroy(var_group1);
        }
#line 2243
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 2256
        vmw_framebuffer_surface_dirty(var_group1, var_group2, var_vmw_framebuffer_surface_dirty_12_p2,
                                      var_vmw_framebuffer_surface_dirty_12_p3, var_vmw_framebuffer_surface_dirty_12_p4,
                                      var_vmw_framebuffer_surface_dirty_12_p5);
        }
#line 2269
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 2280
        vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
        }
#line 2295
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2310
        vmw_framebuffer_dmabuf_destroy(var_group1);
        }
#line 2321
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 2336
        vmw_framebuffer_dmabuf_dirty(var_group1, var_group2, var_vmw_framebuffer_dmabuf_dirty_18_p2,
                                     var_vmw_framebuffer_dmabuf_dirty_18_p3, var_vmw_framebuffer_dmabuf_dirty_18_p4,
                                     var_vmw_framebuffer_dmabuf_dirty_18_p5);
        }
#line 2347
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 2358
        vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
        }
#line 2373
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 2388
        vmw_kms_fb_create(var_group3, var_group2, var_vmw_kms_fb_create_22_p2);
        }
#line 2399
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2400
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2409
  ldv_check_final_state();
  }
#line 2412
  return;
}
}
#line 35 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i )  __attribute__((__no_instrument_function__)) ;
#line 35 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 

  {
#line 37
  *((int *)v) = i;
#line 38
  return;
}
}
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t *lock , char    *name , struct lock_class_key *key ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 285
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 285
  _raw_spin_lock(__cil_tmp2);
  }
#line 286
  return;
}
}
#line 323
__inline static void spin_unlock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 325
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 325
  _raw_spin_unlock(__cil_tmp2);
  }
#line 326
  return;
}
}
#line 79 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t *q , char    *name , struct lock_class_key * ) ;
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char    *name , struct lock_class_key *key ) ;
#line 187 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
extern void iounmap(void volatile   *addr ) ;
#line 317
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
#line 356 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_int ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 67 "include/linux/module.h"
int init_module(void) ;
#line 68
void cleanup_module(void) ;
#line 2401 "include/linux/fs.h"
extern loff_t noop_llseek(struct file *file , loff_t offset , int origin ) ;
#line 792 "include/linux/device.h"
extern void *dev_get_drvdata(struct device    *dev ) ;
#line 773 "include/linux/pci.h"
extern int __attribute__((__warn_unused_result__))  pci_enable_device(struct pci_dev *dev ) ;
#line 790
extern void pci_disable_device(struct pci_dev *dev ) ;
#line 793
extern void pci_set_master(struct pci_dev *dev ) ;
#line 832
extern int pci_save_state(struct pci_dev *dev ) ;
#line 833
extern void pci_restore_state(struct pci_dev *dev ) ;
#line 839
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
#line 904
extern int __attribute__((__warn_unused_result__))  pci_request_regions(struct pci_dev * ,
                                                                        char    * ) ;
#line 906
extern void pci_release_regions(struct pci_dev * ) ;
#line 907
extern int __attribute__((__warn_unused_result__))  pci_request_region(struct pci_dev * ,
                                                                       int  , char    * ) ;
#line 909
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 1358
__inline static void *pci_get_drvdata(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
#line 1358 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct device *__cil_tmp5 ;
  struct device    *__cil_tmp6 ;

  {
  {
#line 1360
  __cil_tmp3 = (unsigned long )pdev;
#line 1360
  __cil_tmp4 = __cil_tmp3 + 144;
#line 1360
  __cil_tmp5 = (struct device *)__cil_tmp4;
#line 1360
  __cil_tmp6 = (struct device    *)__cil_tmp5;
#line 1360
  tmp = dev_get_drvdata(__cil_tmp6);
  }
#line 1360
  return (tmp);
}
}
#line 123 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/mtrr.h"
extern int mtrr_add(unsigned long base , unsigned long size , unsigned int type ,
                    bool increment ) ;
#line 127
extern int mtrr_del(int reg , unsigned long base , unsigned long size ) ;
#line 114 "include/linux/idr.h"
extern void idr_destroy(struct idr *idp ) ;
#line 115
extern void idr_init(struct idr *idp ) ;
#line 1246 "include/drm/drmP.h"
__inline static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags )  __attribute__((__no_instrument_function__)) ;
#line 1246 "include/drm/drmP.h"
__inline static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags ) 
{ int tmp___7 ;
  bool __cil_tmp5 ;

  {
  {
#line 1249
  __cil_tmp5 = (bool )1;
#line 1249
  tmp___7 = mtrr_add(offset, size, flags, __cil_tmp5);
  }
#line 1249
  return (tmp___7);
}
}
#line 1252
__inline static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags )  __attribute__((__no_instrument_function__)) ;
#line 1252 "include/drm/drmP.h"
__inline static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags ) 
{ int tmp___7 ;

  {
  {
#line 1255
  tmp___7 = mtrr_del(handle, offset, size);
  }
#line 1255
  return (tmp___7);
}
}
#line 1294
extern long drm_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) ;
#line 1296
extern long drm_compat_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) ;
#line 1302
extern int drm_open(struct inode *inode , struct file *filp ) ;
#line 1304
extern int drm_fasync(int fd , struct file *filp , int on ) ;
#line 1307
extern int drm_release(struct inode *inode , struct file *filp ) ;
#line 1432
extern int drm_irq_install(struct drm_device *dev ) ;
#line 1433
extern int drm_irq_uninstall(struct drm_device *dev ) ;
#line 1507
extern void drm_put_dev(struct drm_device *dev ) ;
#line 1755
extern int drm_pci_init(struct drm_driver *driver , struct pci_driver *pdriver ) ;
#line 1756
extern void drm_pci_exit(struct drm_driver *driver , struct pci_driver *pdriver ) ;
#line 1757
extern int drm_get_pci_dev(struct pci_dev *pdev , struct pci_device_id    *ent ,
                           struct drm_driver *driver ) ;
#line 346 "include/linux/suspend.h"
extern int register_pm_notifier(struct notifier_block *nb ) ;
#line 347
extern int unregister_pm_notifier(struct notifier_block *nb ) ;
#line 331 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_wait(struct ttm_buffer_object *bo , bool lazy , bool interruptible ,
                       bool no_wait ) ;
#line 536
extern int ttm_bo_create(struct ttm_bo_device *bdev , unsigned long size , enum ttm_bo_type type ,
                         struct ttm_placement *placement , uint32_t page_alignment ,
                         unsigned long buffer_start , bool interruptible , struct file *persistent_swap_storage ,
                         struct ttm_buffer_object **p_bo ) ;
#line 576
extern int ttm_bo_init_mm(struct ttm_bo_device *bdev , unsigned int type , unsigned long p_size ) ;
#line 605
extern int ttm_bo_clean_mm(struct ttm_bo_device *bdev , unsigned int mem_type ) ;
#line 626
extern int ttm_bo_evict_mm(struct ttm_bo_device *bdev , unsigned int mem_type ) ;
#line 730
extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev ) ;
#line 750 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_device_release(struct ttm_bo_device *bdev ) ;
#line 766
extern int ttm_bo_device_init(struct ttm_bo_device *bdev , struct ttm_bo_global *glob ,
                              struct ttm_bo_driver *driver , uint64_t file_page_offset ,
                              bool need_dma32 ) ;
#line 229 "include/drm/ttm/ttm_object.h"
extern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device *tdev ,
                                                    unsigned int hash_order ) ;
#line 244
extern void ttm_object_file_release(struct ttm_object_file **p_tfile ) ;
#line 255
extern struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global *mem_glob ,
                                                        unsigned int hash_order ) ;
#line 269
extern void ttm_object_device_release(struct ttm_object_device **p_tdev ) ;
#line 87 "include/drm/ttm/ttm_lock.h"
extern void ttm_lock_init(struct ttm_lock *lock ) ;
#line 164
extern void ttm_suspend_lock(struct ttm_lock *lock ) ;
#line 173
extern void ttm_suspend_unlock(struct ttm_lock *lock ) ;
#line 187
extern int ttm_vt_lock(struct ttm_lock *lock , bool interruptible , struct ttm_object_file *tfile ) ;
#line 199
extern int ttm_vt_unlock(struct ttm_lock *lock ) ;
#line 239
__inline static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal )  __attribute__((__no_instrument_function__)) ;
#line 239 "include/drm/ttm/ttm_lock.h"
__inline static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
#line 242
  __cil_tmp4 = (unsigned long )lock;
#line 242
  __cil_tmp5 = __cil_tmp4 + 136;
#line 242
  *((bool *)__cil_tmp5) = val;
#line 243
  if (val) {
#line 244
    __cil_tmp6 = (unsigned long )lock;
#line 244
    __cil_tmp7 = __cil_tmp6 + 140;
#line 244
    *((int *)__cil_tmp7) = signal;
  } else {

  }
#line 245
  return;
}
}
#line 65 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) ;
#line 68
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) ;
#line 98
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) ;
#line 100
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) ;
#line 102
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 105
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 108
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 110
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 112
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) ;
#line 368 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) ;
#line 369
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) ;
#line 388
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 390
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 409
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 411
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 413
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 426
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 428
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 435
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 437
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 472
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 474
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 476
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 478
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 480
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) ;
#line 482
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
#line 489
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 491
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 498
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) ;
#line 507
int vmw_ttm_global_init(struct vmw_private *dev_priv ) ;
#line 508
void vmw_ttm_global_release(struct vmw_private *dev_priv ) ;
#line 509
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) ;
#line 517
struct ttm_placement vmw_vram_sys_placement ;
#line 523
struct ttm_bo_driver vmw_bo_driver ;
#line 562
irqreturn_t vmw_irq_handler(int irq , void *arg ) ;
#line 566
void vmw_irq_preinstall(struct drm_device *dev ) ;
#line 567
int vmw_irq_postinstall(struct drm_device *dev ) ;
#line 568
void vmw_irq_uninstall(struct drm_device *dev ) ;
#line 602
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) ;
#line 603
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) ;
#line 605
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) ;
#line 652
int vmw_overlay_init(struct vmw_private *dev_priv ) ;
#line 653
int vmw_overlay_close(struct vmw_private *dev_priv ) ;
#line 654
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 128 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct drm_ioctl_desc vmw_ioctls[21]  = 
#line 128 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
  {      {0U, 17, & vmw_getparam_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 64U) | (sizeof(struct drm_vmw_getparam_arg ) << 16))}, 
        {1U,
      17, & vmw_dmabuf_alloc_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 65U) | (sizeof(union drm_vmw_alloc_dmabuf_arg ) << 16))}, 
        {2U,
      17, & vmw_dmabuf_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 66U) | (sizeof(struct drm_vmw_unref_dmabuf_arg ) << 16))}, 
        {3U,
      26, & vmw_kms_cursor_bypass_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 67U) | (sizeof(struct drm_vmw_cursor_bypass_arg ) << 16))}, 
        {4U,
      26, & vmw_overlay_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 68U) | (sizeof(struct drm_vmw_control_stream_arg ) << 16))}, 
        {5U,
      26, & vmw_stream_claim_ioctl, (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(100 << 8)) | 69U) | (sizeof(struct drm_vmw_stream_arg ) << 16))}, 
        {6U,
      26, & vmw_stream_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 70U) | (sizeof(struct drm_vmw_stream_arg ) << 16))}, 
        {7U,
      17, & vmw_context_define_ioctl, (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(100 << 8)) | 71U) | (sizeof(struct drm_vmw_context_arg ) << 16))}, 
        {8U,
      17, & vmw_context_destroy_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 72U) | (sizeof(struct drm_vmw_context_arg ) << 16))}, 
        {9U,
      17, & vmw_surface_define_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 73U) | (sizeof(union drm_vmw_surface_create_arg ) << 16))}, 
        {10U,
      17, & vmw_surface_destroy_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 74U) | (sizeof(struct drm_vmw_surface_arg ) << 16))}, 
        {11U,
      17, & vmw_surface_reference_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 75U) | (sizeof(union drm_vmw_surface_reference_arg ) << 16))}, 
        {12U,
      17, & vmw_execbuf_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 76U) | (sizeof(struct drm_vmw_execbuf_arg ) << 16))}, 
        {13U,
      17, & vmw_get_cap_3d_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 77U) | (sizeof(struct drm_vmw_get_3d_cap_arg ) << 16))}, 
        {14U,
      17, & vmw_fence_obj_wait_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 78U) | (sizeof(struct drm_vmw_fence_wait_arg ) << 16))}, 
        {15U,
      17, & vmw_fence_obj_signaled_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 79U) | (sizeof(struct drm_vmw_fence_signaled_arg ) << 16))}, 
        {16U,
      17, & vmw_fence_obj_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 80U) | (sizeof(struct drm_vmw_fence_arg ) << 16))}, 
        {17U,
      17, & vmw_fence_event_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 81U) | (sizeof(struct drm_vmw_fence_event_arg ) << 16))}, 
        {18U,
      19, & vmw_present_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 82U) | (sizeof(struct drm_vmw_present_arg ) << 16))}, 
        {19U,
      19, & vmw_present_readback_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 83U) | (sizeof(struct drm_vmw_present_readback_arg ) << 16))}, 
        {20U,
      18, & vmw_kms_update_layout_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 84U) | (sizeof(struct drm_vmw_update_layout_arg ) << 16))}};
#line 182 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct pci_device_id vmw_pci_id_list[2]  = {      {(__u32 )5549, (__u32 )1029, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      (kernel_ulong_t )0}, 
        {(__u32 )0, (__u32 )0, (__u32 )0, 0U, 0U, 0U, 0UL}};
#line 187 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int enable_fbdev  ;
#line 189
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id    *ent ) ;
#line 190
static void vmw_master_init(struct vmw_master *vmaster ) ;
#line 191
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) ;
#line 194 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_enable_fbdev194[38]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 194
  {      (char    )'p',      (char    )'a',      (char const   )'r',      (char const   )'m', 
        (char    )'=',      (char    )'e',      (char const   )'n',      (char const   )'a', 
        (char    )'b',      (char    )'l',      (char const   )'e',      (char const   )'_', 
        (char    )'f',      (char    )'b',      (char const   )'d',      (char const   )'e', 
        (char    )'v',      (char    )':',      (char const   )'E',      (char const   )'n', 
        (char    )'a',      (char    )'b',      (char const   )'l',      (char const   )'e', 
        (char    )' ',      (char    )'v',      (char const   )'m',      (char const   )'w', 
        (char    )'g',      (char    )'f',      (char const   )'x',      (char const   )' ', 
        (char    )'f',      (char    )'b',      (char const   )'d',      (char const   )'e', 
        (char    )'v',      (char    )'\000'};
#line 195 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __param_str_enable_fbdev[13]  = 
#line 195
  {      (char    )'e',      (char    )'n',      (char const   )'a',      (char const   )'b', 
        (char    )'l',      (char    )'e',      (char const   )'_',      (char const   )'f', 
        (char    )'b',      (char    )'d',      (char const   )'e',      (char const   )'v', 
        (char    )'\000'};
#line 195 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct kernel_param    __param_enable_fbdev  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable_fbdev, (struct kernel_param_ops    *)(& param_ops_int),
    (u16 )384, (s16 )0, {(void *)(& enable_fbdev)}};
#line 195 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_enable_fbdevtype195[26]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 195
  {      (char    )'p',      (char    )'a',      (char const   )'r',      (char const   )'m', 
        (char    )'t',      (char    )'y',      (char const   )'p',      (char const   )'e', 
        (char    )'=',      (char    )'e',      (char const   )'n',      (char const   )'a', 
        (char    )'b',      (char    )'l',      (char const   )'e',      (char const   )'_', 
        (char    )'f',      (char    )'b',      (char const   )'d',      (char const   )'e', 
        (char    )'v',      (char    )':',      (char const   )'i',      (char const   )'n', 
        (char    )'t',      (char    )'\000'};
#line 197 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_print_capabilities(uint32_t capabilities ) 
{ 

  {
  {
#line 199
  printk("<6>[drm] Capabilities:\n");
  }
#line 200
  if (capabilities & 2U) {
    {
#line 201
    printk("<6>[drm]   Rect copy.\n");
    }
  } else {

  }
#line 202
  if (capabilities & 32U) {
    {
#line 203
    printk("<6>[drm]   Cursor.\n");
    }
  } else {

  }
#line 204
  if (capabilities & 64U) {
    {
#line 205
    printk("<6>[drm]   Cursor bypass.\n");
    }
  } else {

  }
#line 206
  if (capabilities & 128U) {
    {
#line 207
    printk("<6>[drm]   Cursor bypass 2.\n");
    }
  } else {

  }
#line 208
  if (capabilities & 256U) {
    {
#line 209
    printk("<6>[drm]   8bit emulation.\n");
    }
  } else {

  }
#line 210
  if (capabilities & 512U) {
    {
#line 211
    printk("<6>[drm]   Alpha cursor.\n");
    }
  } else {

  }
#line 212
  if (capabilities & 16384U) {
    {
#line 213
    printk("<6>[drm]   3D.\n");
    }
  } else {

  }
#line 214
  if (capabilities & 32768U) {
    {
#line 215
    printk("<6>[drm]   Extended Fifo.\n");
    }
  } else {

  }
#line 216
  if (capabilities & 65536U) {
    {
#line 217
    printk("<6>[drm]   Multimon.\n");
    }
  } else {

  }
#line 218
  if (capabilities & 131072U) {
    {
#line 219
    printk("<6>[drm]   Pitchlock.\n");
    }
  } else {

  }
#line 220
  if (capabilities & 262144U) {
    {
#line 221
    printk("<6>[drm]   Irq mask.\n");
    }
  } else {

  }
#line 222
  if (capabilities & 524288U) {
    {
#line 223
    printk("<6>[drm]   Display Topology.\n");
    }
  } else {

  }
#line 224
  if (capabilities & 1048576U) {
    {
#line 225
    printk("<6>[drm]   GMR.\n");
    }
  } else {

  }
#line 226
  if (capabilities & 2097152U) {
    {
#line 227
    printk("<6>[drm]   Traces.\n");
    }
  } else {

  }
#line 228
  if (capabilities & 4194304U) {
    {
#line 229
    printk("<6>[drm]   GMR2.\n");
    }
  } else {

  }
#line 230
  if (capabilities & 8388608U) {
    {
#line 231
    printk("<6>[drm]   Screen Object 2.\n");
    }
  } else {

  }
#line 232
  return;
}
}
#line 248 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_dummy_query_bo_prepare(struct vmw_private *dev_priv ) 
{ struct ttm_bo_kmap_obj map ;
  SVGA3dQueryResult volatile   *result ;
  bool dummy ;
  int ret ;
  struct ttm_bo_device *bdev ;
  struct ttm_buffer_object *bo ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  bool __cil_tmp14 ;
  bool __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  bool __cil_tmp20 ;
  bool __cil_tmp21 ;
  bool __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  bool __cil_tmp30 ;
  bool __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  bool __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  {
#line 254
  bdev = (struct ttm_bo_device *)dev_priv;
#line 255
  __cil_tmp11 = (unsigned long )dev_priv;
#line 255
  __cil_tmp12 = __cil_tmp11 + 134744;
#line 255
  bo = *((struct ttm_buffer_object **)__cil_tmp12);
#line 257
  __cil_tmp13 = (bool )0;
#line 257
  __cil_tmp14 = (bool )0;
#line 257
  __cil_tmp15 = (bool )0;
#line 257
  __cil_tmp16 = (uint32_t )0;
#line 257
  ttm_bo_reserve(bo, __cil_tmp13, __cil_tmp14, __cil_tmp15, __cil_tmp16);
#line 258
  __cil_tmp17 = (unsigned long )bdev;
#line 258
  __cil_tmp18 = __cil_tmp17 + 1400;
#line 258
  __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 258
  spin_lock(__cil_tmp19);
#line 259
  __cil_tmp20 = (bool )0;
#line 259
  __cil_tmp21 = (bool )0;
#line 259
  __cil_tmp22 = (bool )0;
#line 259
  ret = ttm_bo_wait(bo, __cil_tmp20, __cil_tmp21, __cil_tmp22);
#line 260
  __cil_tmp23 = (unsigned long )bdev;
#line 260
  __cil_tmp24 = __cil_tmp23 + 1400;
#line 260
  __cil_tmp25 = (spinlock_t *)__cil_tmp24;
#line 260
  spin_unlock(__cil_tmp25);
#line 261
  __cil_tmp26 = ret != 0;
#line 261
  __cil_tmp27 = ! __cil_tmp26;
#line 261
  __cil_tmp28 = ! __cil_tmp27;
#line 261
  __cil_tmp29 = (long )__cil_tmp28;
#line 261
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 261
  if (tmp___7) {
    {
#line 262
    __cil_tmp30 = (bool )0;
#line 262
    __cil_tmp31 = (bool )1;
#line 262
    __cil_tmp32 = (uint32_t )0;
#line 262
    __cil_tmp33 = (bool )0;
#line 262
    vmw_fallback_wait(dev_priv, __cil_tmp30, __cil_tmp31, __cil_tmp32, __cil_tmp33,
                      2500UL);
    }
  } else {

  }
  {
#line 265
  ret = ttm_bo_kmap(bo, 0UL, 1UL, & map);
#line 266
  __cil_tmp34 = ret == 0;
#line 266
  __cil_tmp35 = ! __cil_tmp34;
#line 266
  __cil_tmp36 = ! __cil_tmp35;
#line 266
  __cil_tmp37 = (long )__cil_tmp36;
#line 266
  tmp___9 = ldv__builtin_expect(__cil_tmp37, 1L);
  }
#line 266
  if (tmp___9) {
    {
#line 267
    tmp___8 = ttm_kmap_obj_virtual(& map, & dummy);
#line 267
    result = (SVGA3dQueryResult volatile   *)tmp___8;
#line 268
    *((uint32 volatile   *)result) = (uint32 volatile   )12UL;
#line 269
    __cil_tmp38 = (unsigned long )result;
#line 269
    __cil_tmp39 = __cil_tmp38 + 4;
#line 269
    *((SVGA3dQueryState volatile   *)__cil_tmp39) = (SVGA3dQueryState volatile   )0;
#line 270
    __cil_tmp40 = (unsigned long )result;
#line 270
    __cil_tmp41 = __cil_tmp40 + 8;
#line 270
    *((uint32 volatile   *)__cil_tmp41) = (uint32 volatile   )255;
#line 271
    ttm_bo_kunmap(& map);
    }
  } else {
    {
#line 273
    drm_err("vmw_dummy_query_bo_prepare", "Dummy query buffer map failed.\n");
    }
  }
  {
#line 274
  ttm_bo_unreserve(bo);
  }
#line 275
  return;
}
}
#line 289 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_dummy_query_bo_create(struct vmw_private *dev_priv ) 
{ int tmp___7 ;
  struct ttm_bo_device *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  enum ttm_bo_type __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  bool __cil_tmp7 ;
  void *__cil_tmp8 ;
  struct file *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_buffer_object **__cil_tmp12 ;

  {
  {
#line 291
  __cil_tmp3 = (struct ttm_bo_device *)dev_priv;
#line 291
  __cil_tmp4 = 1UL << 12;
#line 291
  __cil_tmp5 = (enum ttm_bo_type )0;
#line 291
  __cil_tmp6 = (uint32_t )0;
#line 291
  __cil_tmp7 = (bool )0;
#line 291
  __cil_tmp8 = (void *)0;
#line 291
  __cil_tmp9 = (struct file *)__cil_tmp8;
#line 291
  __cil_tmp10 = (unsigned long )dev_priv;
#line 291
  __cil_tmp11 = __cil_tmp10 + 134744;
#line 291
  __cil_tmp12 = (struct ttm_buffer_object **)__cil_tmp11;
#line 291
  tmp___7 = ttm_bo_create(__cil_tmp3, __cil_tmp4, __cil_tmp5, & vmw_vram_sys_placement,
                          __cil_tmp6, 0UL, __cil_tmp7, __cil_tmp9, __cil_tmp12);
  }
#line 291
  return (tmp___7);
}
}
#line 300 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_request_device(struct vmw_private *dev_priv ) 
{ int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct vmw_fifo_state *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_fence_manager *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fence_manager *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_fifo_state *__cil_tmp24 ;

  {
  {
#line 304
  __cil_tmp5 = (unsigned long )dev_priv;
#line 304
  __cil_tmp6 = __cil_tmp5 + 1856;
#line 304
  __cil_tmp7 = (struct vmw_fifo_state *)__cil_tmp6;
#line 304
  ret = vmw_fifo_init(dev_priv, __cil_tmp7);
#line 305
  __cil_tmp8 = ret != 0;
#line 305
  __cil_tmp9 = ! __cil_tmp8;
#line 305
  __cil_tmp10 = ! __cil_tmp9;
#line 305
  __cil_tmp11 = (long )__cil_tmp10;
#line 305
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 0L);
  }
#line 305
  if (tmp___7) {
    {
#line 306
    drm_err("vmw_request_device", "Unable to initialize FIFO.\n");
    }
#line 307
    return (ret);
  } else {

  }
  {
#line 309
  __cil_tmp12 = (unsigned long )dev_priv;
#line 309
  __cil_tmp13 = __cil_tmp12 + 3008;
#line 309
  __cil_tmp14 = *((struct vmw_fence_manager **)__cil_tmp13);
#line 309
  vmw_fence_fifo_up(__cil_tmp14);
#line 310
  ret = vmw_dummy_query_bo_create(dev_priv);
#line 311
  __cil_tmp15 = ret != 0;
#line 311
  __cil_tmp16 = ! __cil_tmp15;
#line 311
  __cil_tmp17 = ! __cil_tmp16;
#line 311
  __cil_tmp18 = (long )__cil_tmp17;
#line 311
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 0L);
  }
#line 311
  if (tmp___8) {
#line 312
    goto out_no_query_bo;
  } else {

  }
  {
#line 313
  vmw_dummy_query_bo_prepare(dev_priv);
  }
#line 315
  return (0);
  out_no_query_bo: 
  {
#line 318
  __cil_tmp19 = (unsigned long )dev_priv;
#line 318
  __cil_tmp20 = __cil_tmp19 + 3008;
#line 318
  __cil_tmp21 = *((struct vmw_fence_manager **)__cil_tmp20);
#line 318
  vmw_fence_fifo_down(__cil_tmp21);
#line 319
  __cil_tmp22 = (unsigned long )dev_priv;
#line 319
  __cil_tmp23 = __cil_tmp22 + 1856;
#line 319
  __cil_tmp24 = (struct vmw_fifo_state *)__cil_tmp23;
#line 319
  vmw_fifo_release(dev_priv, __cil_tmp24);
  }
#line 320
  return (ret);
}
}
#line 323 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_release_device(struct vmw_private *dev_priv ) 
{ long tmp___7 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct ttm_buffer_object *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct ttm_buffer_object **__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_fence_manager *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fifo_state *__cil_tmp21 ;

  {
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 330
    __cil_tmp3 = (void *)0;
#line 330
    __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 330
    __cil_tmp5 = (unsigned long )dev_priv;
#line 330
    __cil_tmp6 = __cil_tmp5 + 134752;
#line 330
    __cil_tmp7 = *((struct ttm_buffer_object **)__cil_tmp6);
#line 330
    __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 330
    __cil_tmp9 = __cil_tmp8 != __cil_tmp4;
#line 330
    __cil_tmp10 = ! __cil_tmp9;
#line 330
    __cil_tmp11 = ! __cil_tmp10;
#line 330
    __cil_tmp12 = (long )__cil_tmp11;
#line 330
    tmp___7 = ldv__builtin_expect(__cil_tmp12, 0L);
    }
#line 330
    if (tmp___7) {
      {
#line 330
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 330
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                             "i" (330), "i" (12UL));
        {
#line 330
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 330
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 330
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  __cil_tmp13 = (unsigned long )dev_priv;
#line 332
  __cil_tmp14 = __cil_tmp13 + 134744;
#line 332
  __cil_tmp15 = (struct ttm_buffer_object **)__cil_tmp14;
#line 332
  ttm_bo_unref(__cil_tmp15);
#line 333
  __cil_tmp16 = (unsigned long )dev_priv;
#line 333
  __cil_tmp17 = __cil_tmp16 + 3008;
#line 333
  __cil_tmp18 = *((struct vmw_fence_manager **)__cil_tmp17);
#line 333
  vmw_fence_fifo_down(__cil_tmp18);
#line 334
  __cil_tmp19 = (unsigned long )dev_priv;
#line 334
  __cil_tmp20 = __cil_tmp19 + 1856;
#line 334
  __cil_tmp21 = (struct vmw_fifo_state *)__cil_tmp20;
#line 334
  vmw_fifo_release(dev_priv, __cil_tmp21);
  }
#line 335
  return;
}
}
#line 343 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) 
{ int ret ;
  long tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct mutex *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct mutex *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  {
#line 346
  ret = 0;
#line 348
  __cil_tmp9 = (unsigned long )dev_priv;
#line 348
  __cil_tmp10 = __cil_tmp9 + 134664;
#line 348
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
#line 348
  mutex_lock(__cil_tmp11);
#line 349
  __cil_tmp12 = (unsigned long )dev_priv;
#line 349
  __cil_tmp13 = __cil_tmp12 + 134736;
#line 349
  tmp___9 = *((uint32_t *)__cil_tmp13);
#line 349
  __cil_tmp14 = (unsigned long )dev_priv;
#line 349
  __cil_tmp15 = __cil_tmp14 + 134736;
#line 349
  __cil_tmp16 = (unsigned long )dev_priv;
#line 349
  __cil_tmp17 = __cil_tmp16 + 134736;
#line 349
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
#line 349
  *((uint32_t *)__cil_tmp15) = __cil_tmp18 + 1U;
  }
#line 349
  if (tmp___9 == 0U) {
#line 349
    tmp___10 = 1;
  } else {
#line 349
    tmp___10 = 0;
  }
  {
#line 349
  __cil_tmp19 = (long )tmp___10;
#line 349
  tmp___11 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 349
  if (tmp___11) {
    {
#line 350
    ret = vmw_request_device(dev_priv);
#line 351
    __cil_tmp20 = ret != 0;
#line 351
    __cil_tmp21 = ! __cil_tmp20;
#line 351
    __cil_tmp22 = ! __cil_tmp21;
#line 351
    __cil_tmp23 = (long )__cil_tmp22;
#line 351
    tmp___7 = ldv__builtin_expect(__cil_tmp23, 0L);
    }
#line 351
    if (tmp___7) {
#line 352
      __cil_tmp24 = (unsigned long )dev_priv;
#line 352
      __cil_tmp25 = __cil_tmp24 + 134736;
#line 352
      __cil_tmp26 = (unsigned long )dev_priv;
#line 352
      __cil_tmp27 = __cil_tmp26 + 134736;
#line 352
      __cil_tmp28 = *((uint32_t *)__cil_tmp27);
#line 352
      *((uint32_t *)__cil_tmp25) = __cil_tmp28 - 1U;
    } else {

    }
  } else
#line 353
  if (unhide_svga) {
    {
#line 354
    __cil_tmp29 = (unsigned long )dev_priv;
#line 354
    __cil_tmp30 = __cil_tmp29 + 2184;
#line 354
    __cil_tmp31 = (struct mutex *)__cil_tmp30;
#line 354
    mutex_lock(__cil_tmp31);
#line 355
    tmp___8 = vmw_read(dev_priv, 1U);
#line 355
    __cil_tmp32 = tmp___8 & 4294967293U;
#line 355
    vmw_write(dev_priv, 1U, __cil_tmp32);
#line 358
    __cil_tmp33 = (unsigned long )dev_priv;
#line 358
    __cil_tmp34 = __cil_tmp33 + 2184;
#line 358
    __cil_tmp35 = (struct mutex *)__cil_tmp34;
#line 358
    mutex_unlock(__cil_tmp35);
    }
  } else {

  }
  {
#line 361
  __cil_tmp36 = (unsigned long )dev_priv;
#line 361
  __cil_tmp37 = __cil_tmp36 + 134664;
#line 361
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
#line 361
  mutex_unlock(__cil_tmp38);
  }
#line 362
  return (ret);
}
}
#line 373 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) 
{ int32_t n3d ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct mutex *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct mutex *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct mutex *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  {
#line 378
  __cil_tmp8 = (unsigned long )dev_priv;
#line 378
  __cil_tmp9 = __cil_tmp8 + 134664;
#line 378
  __cil_tmp10 = (struct mutex *)__cil_tmp9;
#line 378
  mutex_lock(__cil_tmp10);
#line 379
  __cil_tmp11 = (unsigned long )dev_priv;
#line 379
  __cil_tmp12 = __cil_tmp11 + 134736;
#line 379
  __cil_tmp13 = (unsigned long )dev_priv;
#line 379
  __cil_tmp14 = __cil_tmp13 + 134736;
#line 379
  __cil_tmp15 = *((uint32_t *)__cil_tmp14);
#line 379
  *((uint32_t *)__cil_tmp12) = __cil_tmp15 - 1U;
  }
  {
#line 379
  __cil_tmp16 = (unsigned long )dev_priv;
#line 379
  __cil_tmp17 = __cil_tmp16 + 134736;
#line 379
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
#line 379
  if (__cil_tmp18 == 0U) {
#line 379
    tmp___8 = 1;
  } else {
#line 379
    tmp___8 = 0;
  }
  }
  {
#line 379
  __cil_tmp19 = (long )tmp___8;
#line 379
  tmp___9 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 379
  if (tmp___9) {
    {
#line 380
    vmw_release_device(dev_priv);
    }
  } else
#line 381
  if (hide_svga) {
    {
#line 382
    __cil_tmp20 = (unsigned long )dev_priv;
#line 382
    __cil_tmp21 = __cil_tmp20 + 2184;
#line 382
    __cil_tmp22 = (struct mutex *)__cil_tmp21;
#line 382
    mutex_lock(__cil_tmp22);
#line 383
    tmp___7 = vmw_read(dev_priv, 1U);
#line 383
    __cil_tmp23 = tmp___7 | 2U;
#line 383
    vmw_write(dev_priv, 1U, __cil_tmp23);
#line 386
    __cil_tmp24 = (unsigned long )dev_priv;
#line 386
    __cil_tmp25 = __cil_tmp24 + 2184;
#line 386
    __cil_tmp26 = (struct mutex *)__cil_tmp25;
#line 386
    mutex_unlock(__cil_tmp26);
    }
  } else {

  }
  {
#line 389
  __cil_tmp27 = (unsigned long )dev_priv;
#line 389
  __cil_tmp28 = __cil_tmp27 + 134736;
#line 389
  __cil_tmp29 = *((uint32_t *)__cil_tmp28);
#line 389
  n3d = (int32_t )__cil_tmp29;
#line 390
  __cil_tmp30 = (unsigned long )dev_priv;
#line 390
  __cil_tmp31 = __cil_tmp30 + 134664;
#line 390
  __cil_tmp32 = (struct mutex *)__cil_tmp31;
#line 390
  mutex_unlock(__cil_tmp32);
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    __cil_tmp33 = n3d < 0;
#line 392
    __cil_tmp34 = ! __cil_tmp33;
#line 392
    __cil_tmp35 = ! __cil_tmp34;
#line 392
    __cil_tmp36 = (long )__cil_tmp35;
#line 392
    tmp___10 = ldv__builtin_expect(__cil_tmp36, 0L);
    }
#line 392
    if (tmp___10) {
      {
#line 392
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 392
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                             "i" (392), "i" (12UL));
        {
#line 392
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 392
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 392
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 404 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_get_initial_size(struct vmw_private *dev_priv ) 
{ uint32_t width ;
  uint32_t height ;
  uint32_t __max1 ;
  uint32_t __max2 ;
  uint32_t tmp___7 ;
  uint32_t __max1___0 ;
  uint32_t __max2___0 ;
  uint32_t tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;

  {
  {
#line 409
  width = vmw_read(dev_priv, 2U);
#line 410
  height = vmw_read(dev_priv, 3U);
#line 412
  __max1 = width;
#line 412
  __max2 = (uint32_t )800;
  }
#line 412
  if (__max1 > __max2) {
#line 412
    tmp___7 = __max1;
  } else {
#line 412
    tmp___7 = __max2;
  }
#line 412
  width = tmp___7;
#line 413
  __max1___0 = height;
#line 413
  __max2___0 = (uint32_t )600;
#line 413
  if (__max1___0 > __max2___0) {
#line 413
    tmp___8 = __max1___0;
  } else {
#line 413
    tmp___8 = __max2___0;
  }
#line 413
  height = tmp___8;
  {
#line 415
  __cil_tmp10 = (unsigned long )dev_priv;
#line 415
  __cil_tmp11 = __cil_tmp10 + 2124;
#line 415
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
#line 415
  if (width > __cil_tmp12) {
#line 422
    width = (uint32_t )800;
#line 423
    height = (uint32_t )600;
  } else {
    {
#line 415
    __cil_tmp13 = (unsigned long )dev_priv;
#line 415
    __cil_tmp14 = __cil_tmp13 + 2128;
#line 415
    __cil_tmp15 = *((uint32_t *)__cil_tmp14);
#line 415
    if (height > __cil_tmp15) {
#line 422
      width = (uint32_t )800;
#line 423
      height = (uint32_t )600;
    } else {

    }
    }
  }
  }
#line 426
  __cil_tmp16 = (unsigned long )dev_priv;
#line 426
  __cil_tmp17 = __cil_tmp16 + 2132;
#line 426
  *((uint32_t *)__cil_tmp17) = width;
#line 427
  __cil_tmp18 = (unsigned long )dev_priv;
#line 427
  __cil_tmp19 = __cil_tmp18 + 2136;
#line 427
  *((uint32_t *)__cil_tmp19) = height;
#line 428
  return;
}
}
#line 448 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___4  ;
#line 449 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___5  ;
#line 450 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___6  ;
#line 451 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___7  ;
#line 455 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___8  ;
#line 456 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___9  ;
#line 457 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___10  ;
#line 430 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ struct vmw_private *dev_priv ;
  int ret ;
  uint32_t svga_id ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  bool tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  char    *tmp___22 ;
  bool tmp___23 ;
  long tmp___24 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct pci_dev *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct mutex *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct mutex *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  rwlock_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct idr *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct idr *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct idr *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct mutex *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  wait_queue_head_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  wait_queue_head_t *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  atomic_t *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct pci_dev *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  resource_size_t __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct pci_dev *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  resource_size_t __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct pci_dev *__cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  resource_size_t __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  int *__cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  struct mutex *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  uint32_t __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  struct mutex *__cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  uint32_t __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  uint32_t __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  struct mutex *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  uint32_t __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  uint32_t __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  uint32_t __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  uint32_t __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  uint32_t __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  uint32_t __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  unsigned int __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  uint32_t __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  uint32_t __cil_tmp191 ;
  uint32_t __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  uint32_t __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  uint32_t __cil_tmp198 ;
  uint32_t __cil_tmp199 ;
  int __cil_tmp200 ;
  int __cil_tmp201 ;
  int __cil_tmp202 ;
  long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  struct vmw_master *__cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  struct ttm_lock *__cil_tmp209 ;
  bool __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  struct ttm_bo_device *__cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  void *__cil_tmp220 ;
  struct ttm_bo_global *__cil_tmp221 ;
  uint64_t __cil_tmp222 ;
  bool __cil_tmp223 ;
  int __cil_tmp224 ;
  int __cil_tmp225 ;
  int __cil_tmp226 ;
  long __cil_tmp227 ;
  struct ttm_bo_device *__cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  uint32_t __cil_tmp231 ;
  uint32_t __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  int __cil_tmp234 ;
  int __cil_tmp235 ;
  int __cil_tmp236 ;
  long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct ttm_bo_device *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  uint32_t __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  uint32_t __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  uint32_t __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  uint32_t __cil_tmp259 ;
  resource_size_t __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  uint32_t __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  void *__cil_tmp267 ;
  unsigned long __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  __le32 *__cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  int __cil_tmp273 ;
  int __cil_tmp274 ;
  int __cil_tmp275 ;
  long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  uint32_t __cil_tmp279 ;
  unsigned int __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  uint32_t __cil_tmp283 ;
  unsigned int __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  void *__cil_tmp290 ;
  struct ttm_mem_global *__cil_tmp291 ;
  void *__cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  struct ttm_object_device *__cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  int __cil_tmp298 ;
  int __cil_tmp299 ;
  int __cil_tmp300 ;
  long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  struct pci_dev *__cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  int __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct pci_dev *__cil_tmp314 ;
  int __cil_tmp315 ;
  int __cil_tmp316 ;
  int __cil_tmp317 ;
  long __cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  void *__cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;
  struct vmw_fence_manager *__cil_tmp325 ;
  unsigned long __cil_tmp326 ;
  int __cil_tmp327 ;
  int __cil_tmp328 ;
  int __cil_tmp329 ;
  long __cil_tmp330 ;
  bool __cil_tmp331 ;
  int __cil_tmp332 ;
  int __cil_tmp333 ;
  int __cil_tmp334 ;
  long __cil_tmp335 ;
  int __cil_tmp336 ;
  int __cil_tmp337 ;
  int __cil_tmp338 ;
  long __cil_tmp339 ;
  unsigned long __cil_tmp340 ;
  unsigned long __cil_tmp341 ;
  bool __cil_tmp342 ;
  unsigned long __cil_tmp343 ;
  unsigned long __cil_tmp344 ;
  uint32_t __cil_tmp345 ;
  int __cil_tmp346 ;
  int __cil_tmp347 ;
  int __cil_tmp348 ;
  long __cil_tmp349 ;
  unsigned long __cil_tmp350 ;
  unsigned long __cil_tmp351 ;
  unsigned long __cil_tmp352 ;
  unsigned long __cil_tmp353 ;
  struct notifier_block *__cil_tmp354 ;
  unsigned long __cil_tmp355 ;
  unsigned long __cil_tmp356 ;
  unsigned long __cil_tmp357 ;
  unsigned long __cil_tmp358 ;
  bool __cil_tmp359 ;
  unsigned long __cil_tmp360 ;
  unsigned long __cil_tmp361 ;
  struct vmw_fence_manager *__cil_tmp362 ;
  unsigned long __cil_tmp363 ;
  unsigned long __cil_tmp364 ;
  unsigned long __cil_tmp365 ;
  unsigned long __cil_tmp366 ;
  struct pci_dev *__cil_tmp367 ;
  unsigned long __cil_tmp368 ;
  unsigned long __cil_tmp369 ;
  struct pci_dev *__cil_tmp370 ;
  unsigned long __cil_tmp371 ;
  unsigned long __cil_tmp372 ;
  struct ttm_object_device **__cil_tmp373 ;
  unsigned long __cil_tmp374 ;
  unsigned long __cil_tmp375 ;
  __le32 *__cil_tmp376 ;
  void volatile   *__cil_tmp377 ;
  unsigned long __cil_tmp378 ;
  unsigned long __cil_tmp379 ;
  int __cil_tmp380 ;
  unsigned long __cil_tmp381 ;
  unsigned long __cil_tmp382 ;
  uint32_t __cil_tmp383 ;
  unsigned long __cil_tmp384 ;
  unsigned long __cil_tmp385 ;
  unsigned long __cil_tmp386 ;
  uint32_t __cil_tmp387 ;
  unsigned long __cil_tmp388 ;
  unsigned long __cil_tmp389 ;
  unsigned long __cil_tmp390 ;
  struct ttm_bo_device *__cil_tmp391 ;
  struct ttm_bo_device *__cil_tmp392 ;
  struct ttm_bo_device *__cil_tmp393 ;
  unsigned long __cil_tmp394 ;
  unsigned long __cil_tmp395 ;
  struct idr *__cil_tmp396 ;
  unsigned long __cil_tmp397 ;
  unsigned long __cil_tmp398 ;
  struct idr *__cil_tmp399 ;
  unsigned long __cil_tmp400 ;
  unsigned long __cil_tmp401 ;
  struct idr *__cil_tmp402 ;
  void    *__cil_tmp403 ;

  {
  {
#line 436
  tmp___7 = kzalloc(134792UL, 208U);
#line 436
  dev_priv = (struct vmw_private *)tmp___7;
#line 437
  __cil_tmp24 = (void *)0;
#line 437
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 437
  __cil_tmp26 = (unsigned long )dev_priv;
#line 437
  __cil_tmp27 = __cil_tmp26 == __cil_tmp25;
#line 437
  __cil_tmp28 = ! __cil_tmp27;
#line 437
  __cil_tmp29 = ! __cil_tmp28;
#line 437
  __cil_tmp30 = (long )__cil_tmp29;
#line 437
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 0L);
  }
#line 437
  if (tmp___8) {
    {
#line 438
    drm_err("vmw_driver_load", "Failed allocating a device private struct.\n");
    }
#line 439
    return (-12);
  } else {

  }
  {
#line 441
  __cil_tmp31 = (void *)dev_priv;
#line 441
  memset(__cil_tmp31, 0, 134792UL);
#line 443
  __cil_tmp32 = (unsigned long )dev;
#line 443
  __cil_tmp33 = __cil_tmp32 + 1016;
#line 443
  __cil_tmp34 = *((struct pci_dev **)__cil_tmp33);
#line 443
  pci_set_master(__cil_tmp34);
#line 445
  __cil_tmp35 = (unsigned long )dev_priv;
#line 445
  __cil_tmp36 = __cil_tmp35 + 2088;
#line 445
  *((struct drm_device **)__cil_tmp36) = dev;
#line 446
  __cil_tmp37 = (unsigned long )dev_priv;
#line 446
  __cil_tmp38 = __cil_tmp37 + 2096;
#line 446
  *((unsigned long *)__cil_tmp38) = chipset;
#line 447
  __cil_tmp39 = (unsigned long )dev_priv;
#line 447
  __cil_tmp40 = __cil_tmp39 + 2980;
#line 447
  *((uint32_t *)__cil_tmp40) = (uint32_t )-100;
  }
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 448
    __cil_tmp41 = (unsigned long )dev_priv;
#line 448
    __cil_tmp42 = __cil_tmp41 + 2184;
#line 448
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
#line 448
    __mutex_init(__cil_tmp43, "&dev_priv->hw_mutex", & __key___4);
    }
#line 448
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 449
    __cil_tmp44 = (unsigned long )dev_priv;
#line 449
    __cil_tmp45 = __cil_tmp44 + 134304;
#line 449
    __cil_tmp46 = (struct mutex *)__cil_tmp45;
#line 449
    __mutex_init(__cil_tmp46, "&dev_priv->cmdbuf_mutex", & __key___5);
    }
#line 449
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 450
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 450
    __cil_tmp47 = (unsigned long )dev_priv;
#line 450
    __cil_tmp48 = __cil_tmp47 + 134664;
#line 450
    __cil_tmp49 = (struct mutex *)__cil_tmp48;
#line 450
    __mutex_init(__cil_tmp49, "&dev_priv->release_mutex", & __key___6);
    }
#line 450
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 451
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 451
    __cil_tmp50 = (unsigned long )dev_priv;
#line 451
    __cil_tmp51 = __cil_tmp50 + 2632;
#line 451
    __cil_tmp52 = (rwlock_t *)__cil_tmp51;
#line 451
    __rwlock_init(__cil_tmp52, "&dev_priv->resource_lock", & __key___7);
    }
#line 451
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 452
  __cil_tmp53 = (unsigned long )dev_priv;
#line 452
  __cil_tmp54 = __cil_tmp53 + 2656;
#line 452
  __cil_tmp55 = (struct idr *)__cil_tmp54;
#line 452
  idr_init(__cil_tmp55);
#line 453
  __cil_tmp56 = (unsigned long )dev_priv;
#line 453
  __cil_tmp57 = __cil_tmp56 + 2704;
#line 453
  __cil_tmp58 = (struct idr *)__cil_tmp57;
#line 453
  idr_init(__cil_tmp58);
#line 454
  __cil_tmp59 = (unsigned long )dev_priv;
#line 454
  __cil_tmp60 = __cil_tmp59 + 2752;
#line 454
  __cil_tmp61 = (struct idr *)__cil_tmp60;
#line 454
  idr_init(__cil_tmp61);
  }
  {
#line 455
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 455
    __cil_tmp62 = (unsigned long )dev_priv;
#line 455
    __cil_tmp63 = __cil_tmp62 + 2800;
#line 455
    __cil_tmp64 = (struct mutex *)__cil_tmp63;
#line 455
    __mutex_init(__cil_tmp64, "&dev_priv->init_mutex", & __key___8);
    }
#line 455
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 456
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 456
    __cil_tmp65 = (unsigned long )dev_priv;
#line 456
    __cil_tmp66 = __cil_tmp65 + 2888;
#line 456
    __cil_tmp67 = (wait_queue_head_t *)__cil_tmp66;
#line 456
    __init_waitqueue_head(__cil_tmp67, "&dev_priv->fence_queue", & __key___9);
    }
#line 456
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 457
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 457
    __cil_tmp68 = (unsigned long )dev_priv;
#line 457
    __cil_tmp69 = __cil_tmp68 + 2928;
#line 457
    __cil_tmp70 = (wait_queue_head_t *)__cil_tmp69;
#line 457
    __init_waitqueue_head(__cil_tmp70, "&dev_priv->fifo_queue", & __key___10);
    }
#line 457
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 458
  __cil_tmp71 = (unsigned long )dev_priv;
#line 458
  __cil_tmp72 = __cil_tmp71 + 2968;
#line 458
  *((int *)__cil_tmp72) = 0;
#line 459
  __cil_tmp73 = (unsigned long )dev_priv;
#line 459
  __cil_tmp74 = __cil_tmp73 + 2976;
#line 459
  __cil_tmp75 = (atomic_t *)__cil_tmp74;
#line 459
  atomic_set(__cil_tmp75, 0);
#line 460
  __cil_tmp76 = (unsigned long )dev_priv;
#line 460
  __cil_tmp77 = __cil_tmp76 + 134768;
#line 460
  __cil_tmp78 = (struct list_head *)__cil_tmp77;
#line 460
  INIT_LIST_HEAD(__cil_tmp78);
#line 461
  __cil_tmp79 = (unsigned long )dev_priv;
#line 461
  __cil_tmp80 = __cil_tmp79 + 134784;
#line 461
  *((uint32_t *)__cil_tmp80) = (uint32_t )0;
#line 463
  __cil_tmp81 = (unsigned long )dev_priv;
#line 463
  __cil_tmp82 = __cil_tmp81 + 2104;
#line 463
  __cil_tmp83 = 0 * 56UL;
#line 463
  __cil_tmp84 = 920 + __cil_tmp83;
#line 463
  __cil_tmp85 = (unsigned long )dev;
#line 463
  __cil_tmp86 = __cil_tmp85 + 1016;
#line 463
  __cil_tmp87 = *((struct pci_dev **)__cil_tmp86);
#line 463
  __cil_tmp88 = (unsigned long )__cil_tmp87;
#line 463
  __cil_tmp89 = __cil_tmp88 + __cil_tmp84;
#line 463
  __cil_tmp90 = *((resource_size_t *)__cil_tmp89);
#line 463
  *((unsigned int *)__cil_tmp82) = (unsigned int )__cil_tmp90;
#line 464
  __cil_tmp91 = (unsigned long )dev_priv;
#line 464
  __cil_tmp92 = __cil_tmp91 + 2108;
#line 464
  __cil_tmp93 = 1 * 56UL;
#line 464
  __cil_tmp94 = 920 + __cil_tmp93;
#line 464
  __cil_tmp95 = (unsigned long )dev;
#line 464
  __cil_tmp96 = __cil_tmp95 + 1016;
#line 464
  __cil_tmp97 = *((struct pci_dev **)__cil_tmp96);
#line 464
  __cil_tmp98 = (unsigned long )__cil_tmp97;
#line 464
  __cil_tmp99 = __cil_tmp98 + __cil_tmp94;
#line 464
  __cil_tmp100 = *((resource_size_t *)__cil_tmp99);
#line 464
  *((uint32_t *)__cil_tmp92) = (uint32_t )__cil_tmp100;
#line 465
  __cil_tmp101 = (unsigned long )dev_priv;
#line 465
  __cil_tmp102 = __cil_tmp101 + 2116;
#line 465
  __cil_tmp103 = 2 * 56UL;
#line 465
  __cil_tmp104 = 920 + __cil_tmp103;
#line 465
  __cil_tmp105 = (unsigned long )dev;
#line 465
  __cil_tmp106 = __cil_tmp105 + 1016;
#line 465
  __cil_tmp107 = *((struct pci_dev **)__cil_tmp106);
#line 465
  __cil_tmp108 = (unsigned long )__cil_tmp107;
#line 465
  __cil_tmp109 = __cil_tmp108 + __cil_tmp104;
#line 465
  __cil_tmp110 = *((resource_size_t *)__cil_tmp109);
#line 465
  *((uint32_t *)__cil_tmp102) = (uint32_t )__cil_tmp110;
#line 467
  __cil_tmp111 = (unsigned long )dev_priv;
#line 467
  __cil_tmp112 = __cil_tmp111 + 134378;
#line 467
  __cil_tmp113 = & enable_fbdev;
#line 467
  __cil_tmp114 = *__cil_tmp113;
#line 467
  *((bool *)__cil_tmp112) = (bool )__cil_tmp114;
#line 469
  __cil_tmp115 = (unsigned long )dev_priv;
#line 469
  __cil_tmp116 = __cil_tmp115 + 2184;
#line 469
  __cil_tmp117 = (struct mutex *)__cil_tmp116;
#line 469
  mutex_lock(__cil_tmp117);
#line 471
  __cil_tmp118 = 9437184UL << 8;
#line 471
  __cil_tmp119 = __cil_tmp118 | 2UL;
#line 471
  __cil_tmp120 = (uint32_t )__cil_tmp119;
#line 471
  vmw_write(dev_priv, 0U, __cil_tmp120);
#line 472
  svga_id = vmw_read(dev_priv, 0U);
  }
  {
#line 473
  __cil_tmp121 = 9437184UL << 8;
#line 473
  __cil_tmp122 = __cil_tmp121 | 2UL;
#line 473
  __cil_tmp123 = (unsigned long )svga_id;
#line 473
  if (__cil_tmp123 != __cil_tmp122) {
    {
#line 474
    ret = -38;
#line 475
    drm_err("vmw_driver_load", "Unsupported SVGA ID 0x%x\n", svga_id);
#line 476
    __cil_tmp124 = (unsigned long )dev_priv;
#line 476
    __cil_tmp125 = __cil_tmp124 + 2184;
#line 476
    __cil_tmp126 = (struct mutex *)__cil_tmp125;
#line 476
    mutex_unlock(__cil_tmp126);
    }
#line 477
    goto out_err0;
  } else {

  }
  }
  {
#line 480
  __cil_tmp127 = (unsigned long )dev_priv;
#line 480
  __cil_tmp128 = __cil_tmp127 + 2156;
#line 480
  *((uint32_t *)__cil_tmp128) = vmw_read(dev_priv, 17U);
#line 482
  __cil_tmp129 = (unsigned long )dev_priv;
#line 482
  __cil_tmp130 = __cil_tmp129 + 2112;
#line 482
  *((uint32_t *)__cil_tmp130) = vmw_read(dev_priv, 15U);
#line 483
  __cil_tmp131 = (unsigned long )dev_priv;
#line 483
  __cil_tmp132 = __cil_tmp131 + 2120;
#line 483
  *((uint32_t *)__cil_tmp132) = vmw_read(dev_priv, 19U);
#line 484
  __cil_tmp133 = (unsigned long )dev_priv;
#line 484
  __cil_tmp134 = __cil_tmp133 + 2124;
#line 484
  *((uint32_t *)__cil_tmp134) = vmw_read(dev_priv, 4U);
#line 485
  __cil_tmp135 = (unsigned long )dev_priv;
#line 485
  __cil_tmp136 = __cil_tmp135 + 2128;
#line 485
  *((uint32_t *)__cil_tmp136) = vmw_read(dev_priv, 5U);
#line 487
  vmw_get_initial_size(dev_priv);
  }
  {
#line 489
  __cil_tmp137 = (unsigned long )dev_priv;
#line 489
  __cil_tmp138 = __cil_tmp137 + 2156;
#line 489
  __cil_tmp139 = *((uint32_t *)__cil_tmp138);
#line 489
  if (__cil_tmp139 & 1048576U) {
    {
#line 490
    __cil_tmp140 = (unsigned long )dev_priv;
#line 490
    __cil_tmp141 = __cil_tmp140 + 2160;
#line 490
    *((uint32_t *)__cil_tmp141) = vmw_read(dev_priv, 44U);
#line 493
    __cil_tmp142 = (unsigned long )dev_priv;
#line 493
    __cil_tmp143 = __cil_tmp142 + 2164;
#line 493
    *((uint32_t *)__cil_tmp143) = vmw_read(dev_priv, 43U);
    }
  } else {

  }
  }
  {
#line 496
  __cil_tmp144 = (unsigned long )dev_priv;
#line 496
  __cil_tmp145 = __cil_tmp144 + 2156;
#line 496
  __cil_tmp146 = *((uint32_t *)__cil_tmp145);
#line 496
  if (__cil_tmp146 & 4194304U) {
    {
#line 497
    __cil_tmp147 = (unsigned long )dev_priv;
#line 497
    __cil_tmp148 = __cil_tmp147 + 2168;
#line 497
    *((uint32_t *)__cil_tmp148) = vmw_read(dev_priv, 46U);
#line 499
    __cil_tmp149 = (unsigned long )dev_priv;
#line 499
    __cil_tmp150 = __cil_tmp149 + 2172;
#line 499
    *((uint32_t *)__cil_tmp150) = vmw_read(dev_priv, 47U);
#line 501
    __cil_tmp151 = (unsigned long )dev_priv;
#line 501
    __cil_tmp152 = __cil_tmp151 + 2172;
#line 501
    __cil_tmp153 = (unsigned long )dev_priv;
#line 501
    __cil_tmp154 = __cil_tmp153 + 2112;
#line 501
    __cil_tmp155 = *((uint32_t *)__cil_tmp154);
#line 501
    __cil_tmp156 = (unsigned long )dev_priv;
#line 501
    __cil_tmp157 = __cil_tmp156 + 2172;
#line 501
    __cil_tmp158 = *((uint32_t *)__cil_tmp157);
#line 501
    *((uint32_t *)__cil_tmp152) = __cil_tmp158 - __cil_tmp155;
    }
  } else {
#line 507
    __cil_tmp159 = (unsigned long )dev_priv;
#line 507
    __cil_tmp160 = __cil_tmp159 + 2172;
#line 507
    *((uint32_t *)__cil_tmp160) = (uint32_t )536870912;
  }
  }
  {
#line 510
  __cil_tmp161 = (unsigned long )dev_priv;
#line 510
  __cil_tmp162 = __cil_tmp161 + 2184;
#line 510
  __cil_tmp163 = (struct mutex *)__cil_tmp162;
#line 510
  mutex_unlock(__cil_tmp163);
#line 512
  __cil_tmp164 = (unsigned long )dev_priv;
#line 512
  __cil_tmp165 = __cil_tmp164 + 2156;
#line 512
  __cil_tmp166 = *((uint32_t *)__cil_tmp165);
#line 512
  vmw_print_capabilities(__cil_tmp166);
  }
  {
#line 514
  __cil_tmp167 = (unsigned long )dev_priv;
#line 514
  __cil_tmp168 = __cil_tmp167 + 2156;
#line 514
  __cil_tmp169 = *((uint32_t *)__cil_tmp168);
#line 514
  if (__cil_tmp169 & 1048576U) {
    {
#line 515
    __cil_tmp170 = (unsigned long )dev_priv;
#line 515
    __cil_tmp171 = __cil_tmp170 + 2164;
#line 515
    __cil_tmp172 = *((uint32_t *)__cil_tmp171);
#line 515
    printk("<6>[drm] Max GMR ids is %u\n", __cil_tmp172);
#line 517
    __cil_tmp173 = (unsigned long )dev_priv;
#line 517
    __cil_tmp174 = __cil_tmp173 + 2160;
#line 517
    __cil_tmp175 = *((uint32_t *)__cil_tmp174);
#line 517
    printk("<6>[drm] Max GMR descriptors is %u\n", __cil_tmp175);
    }
  } else {

  }
  }
  {
#line 520
  __cil_tmp176 = (unsigned long )dev_priv;
#line 520
  __cil_tmp177 = __cil_tmp176 + 2156;
#line 520
  __cil_tmp178 = *((uint32_t *)__cil_tmp177);
#line 520
  if (__cil_tmp178 & 4194304U) {
    {
#line 521
    __cil_tmp179 = (unsigned long )dev_priv;
#line 521
    __cil_tmp180 = __cil_tmp179 + 2168;
#line 521
    __cil_tmp181 = *((uint32_t *)__cil_tmp180);
#line 521
    printk("<6>[drm] Max number of GMR pages is %u\n", __cil_tmp181);
#line 523
    __cil_tmp182 = (unsigned long )dev_priv;
#line 523
    __cil_tmp183 = __cil_tmp182 + 2172;
#line 523
    __cil_tmp184 = *((uint32_t *)__cil_tmp183);
#line 523
    __cil_tmp185 = __cil_tmp184 / 1024U;
#line 523
    printk("<6>[drm] Max dedicated hypervisor surface memory is %u kiB\n", __cil_tmp185);
    }
  } else {

  }
  }
  {
#line 526
  __cil_tmp186 = (unsigned long )dev_priv;
#line 526
  __cil_tmp187 = __cil_tmp186 + 2108;
#line 526
  __cil_tmp188 = *((uint32_t *)__cil_tmp187);
#line 526
  __cil_tmp189 = (unsigned long )dev_priv;
#line 526
  __cil_tmp190 = __cil_tmp189 + 2112;
#line 526
  __cil_tmp191 = *((uint32_t *)__cil_tmp190);
#line 526
  __cil_tmp192 = __cil_tmp191 / 1024U;
#line 526
  printk("<6>[drm] VRAM at 0x%08x size is %u kiB\n", __cil_tmp188, __cil_tmp192);
#line 528
  __cil_tmp193 = (unsigned long )dev_priv;
#line 528
  __cil_tmp194 = __cil_tmp193 + 2116;
#line 528
  __cil_tmp195 = *((uint32_t *)__cil_tmp194);
#line 528
  __cil_tmp196 = (unsigned long )dev_priv;
#line 528
  __cil_tmp197 = __cil_tmp196 + 2120;
#line 528
  __cil_tmp198 = *((uint32_t *)__cil_tmp197);
#line 528
  __cil_tmp199 = __cil_tmp198 / 1024U;
#line 528
  printk("<6>[drm] MMIO at 0x%08x size is %u kiB\n", __cil_tmp195, __cil_tmp199);
#line 531
  ret = vmw_ttm_global_init(dev_priv);
#line 532
  __cil_tmp200 = ret != 0;
#line 532
  __cil_tmp201 = ! __cil_tmp200;
#line 532
  __cil_tmp202 = ! __cil_tmp201;
#line 532
  __cil_tmp203 = (long )__cil_tmp202;
#line 532
  tmp___9 = ldv__builtin_expect(__cil_tmp203, 0L);
  }
#line 532
  if (tmp___9) {
#line 533
    goto out_err0;
  } else {

  }
  {
#line 536
  __cil_tmp204 = (unsigned long )dev_priv;
#line 536
  __cil_tmp205 = __cil_tmp204 + 134392;
#line 536
  __cil_tmp206 = (struct vmw_master *)__cil_tmp205;
#line 536
  vmw_master_init(__cil_tmp206);
#line 537
  __cil_tmp207 = (unsigned long )dev_priv;
#line 537
  __cil_tmp208 = __cil_tmp207 + 134392;
#line 537
  __cil_tmp209 = (struct ttm_lock *)__cil_tmp208;
#line 537
  __cil_tmp210 = (bool )0;
#line 537
  ttm_lock_set_kill(__cil_tmp209, __cil_tmp210, 15);
#line 538
  __cil_tmp211 = (unsigned long )dev_priv;
#line 538
  __cil_tmp212 = __cil_tmp211 + 134384;
#line 538
  __cil_tmp213 = (unsigned long )dev_priv;
#line 538
  __cil_tmp214 = __cil_tmp213 + 134392;
#line 538
  *((struct vmw_master **)__cil_tmp212) = (struct vmw_master *)__cil_tmp214;
#line 541
  __cil_tmp215 = (struct ttm_bo_device *)dev_priv;
#line 541
  __cil_tmp216 = 0 + 16;
#line 541
  __cil_tmp217 = 1768 + __cil_tmp216;
#line 541
  __cil_tmp218 = (unsigned long )dev_priv;
#line 541
  __cil_tmp219 = __cil_tmp218 + __cil_tmp217;
#line 541
  __cil_tmp220 = *((void **)__cil_tmp219);
#line 541
  __cil_tmp221 = (struct ttm_bo_global *)__cil_tmp220;
#line 541
  __cil_tmp222 = (uint64_t )1048576;
#line 541
  __cil_tmp223 = (bool )0;
#line 541
  ret = ttm_bo_device_init(__cil_tmp215, __cil_tmp221, & vmw_bo_driver, __cil_tmp222,
                           __cil_tmp223);
#line 545
  __cil_tmp224 = ret != 0;
#line 545
  __cil_tmp225 = ! __cil_tmp224;
#line 545
  __cil_tmp226 = ! __cil_tmp225;
#line 545
  __cil_tmp227 = (long )__cil_tmp226;
#line 545
  tmp___10 = ldv__builtin_expect(__cil_tmp227, 0L);
  }
#line 545
  if (tmp___10) {
    {
#line 546
    drm_err("vmw_driver_load", "Failed initializing TTM buffer object driver.\n");
    }
#line 547
    goto out_err1;
  } else {

  }
  {
#line 550
  __cil_tmp228 = (struct ttm_bo_device *)dev_priv;
#line 550
  __cil_tmp229 = (unsigned long )dev_priv;
#line 550
  __cil_tmp230 = __cil_tmp229 + 2112;
#line 550
  __cil_tmp231 = *((uint32_t *)__cil_tmp230);
#line 550
  __cil_tmp232 = __cil_tmp231 >> 12;
#line 550
  __cil_tmp233 = (unsigned long )__cil_tmp232;
#line 550
  ret = ttm_bo_init_mm(__cil_tmp228, 2U, __cil_tmp233);
#line 552
  __cil_tmp234 = ret != 0;
#line 552
  __cil_tmp235 = ! __cil_tmp234;
#line 552
  __cil_tmp236 = ! __cil_tmp235;
#line 552
  __cil_tmp237 = (long )__cil_tmp236;
#line 552
  tmp___11 = ldv__builtin_expect(__cil_tmp237, 0L);
  }
#line 552
  if (tmp___11) {
    {
#line 553
    drm_err("vmw_driver_load", "Failed initializing memory manager for VRAM.\n");
    }
#line 554
    goto out_err2;
  } else {

  }
  {
#line 557
  __cil_tmp238 = (unsigned long )dev_priv;
#line 557
  __cil_tmp239 = __cil_tmp238 + 2176;
#line 557
  *((bool *)__cil_tmp239) = (bool )1;
#line 558
  __cil_tmp240 = (struct ttm_bo_device *)dev_priv;
#line 558
  __cil_tmp241 = (unsigned long )dev_priv;
#line 558
  __cil_tmp242 = __cil_tmp241 + 2164;
#line 558
  __cil_tmp243 = *((uint32_t *)__cil_tmp242);
#line 558
  __cil_tmp244 = (unsigned long )__cil_tmp243;
#line 558
  tmp___12 = ttm_bo_init_mm(__cil_tmp240, 3U, __cil_tmp244);
  }
#line 558
  if (tmp___12 != 0) {
    {
#line 560
    printk("<6>[drm] No GMR memory available. Graphics memory resources are very limited.\n");
#line 562
    __cil_tmp245 = (unsigned long )dev_priv;
#line 562
    __cil_tmp246 = __cil_tmp245 + 2176;
#line 562
    *((bool *)__cil_tmp246) = (bool )0;
    }
  } else {

  }
  {
#line 565
  __cil_tmp247 = (unsigned long )dev_priv;
#line 565
  __cil_tmp248 = __cil_tmp247 + 2152;
#line 565
  __cil_tmp249 = (unsigned long )dev_priv;
#line 565
  __cil_tmp250 = __cil_tmp249 + 2116;
#line 565
  __cil_tmp251 = *((uint32_t *)__cil_tmp250);
#line 565
  __cil_tmp252 = (unsigned long )__cil_tmp251;
#line 565
  __cil_tmp253 = (unsigned long )dev_priv;
#line 565
  __cil_tmp254 = __cil_tmp253 + 2120;
#line 565
  __cil_tmp255 = *((uint32_t *)__cil_tmp254);
#line 565
  __cil_tmp256 = (unsigned long )__cil_tmp255;
#line 565
  *((int *)__cil_tmp248) = drm_mtrr_add(__cil_tmp252, __cil_tmp256, 1U);
#line 568
  __cil_tmp257 = (unsigned long )dev_priv;
#line 568
  __cil_tmp258 = __cil_tmp257 + 2116;
#line 568
  __cil_tmp259 = *((uint32_t *)__cil_tmp258);
#line 568
  __cil_tmp260 = (resource_size_t )__cil_tmp259;
#line 568
  __cil_tmp261 = (unsigned long )dev_priv;
#line 568
  __cil_tmp262 = __cil_tmp261 + 2120;
#line 568
  __cil_tmp263 = *((uint32_t *)__cil_tmp262);
#line 568
  __cil_tmp264 = (unsigned long )__cil_tmp263;
#line 568
  tmp___13 = ioremap_wc(__cil_tmp260, __cil_tmp264);
#line 568
  __cil_tmp265 = (unsigned long )dev_priv;
#line 568
  __cil_tmp266 = __cil_tmp265 + 2144;
#line 568
  *((__le32 **)__cil_tmp266) = (__le32 *)tmp___13;
#line 571
  __cil_tmp267 = (void *)0;
#line 571
  __cil_tmp268 = (unsigned long )__cil_tmp267;
#line 571
  __cil_tmp269 = (unsigned long )dev_priv;
#line 571
  __cil_tmp270 = __cil_tmp269 + 2144;
#line 571
  __cil_tmp271 = *((__le32 **)__cil_tmp270);
#line 571
  __cil_tmp272 = (unsigned long )__cil_tmp271;
#line 571
  __cil_tmp273 = __cil_tmp272 == __cil_tmp268;
#line 571
  __cil_tmp274 = ! __cil_tmp273;
#line 571
  __cil_tmp275 = ! __cil_tmp274;
#line 571
  __cil_tmp276 = (long )__cil_tmp275;
#line 571
  tmp___14 = ldv__builtin_expect(__cil_tmp276, 0L);
  }
#line 571
  if (tmp___14) {
    {
#line 572
    ret = -12;
#line 573
    drm_err("vmw_driver_load", "Failed mapping MMIO.\n");
    }
#line 574
    goto out_err3;
  } else {

  }
  {
#line 578
  __cil_tmp277 = (unsigned long )dev_priv;
#line 578
  __cil_tmp278 = __cil_tmp277 + 2156;
#line 578
  __cil_tmp279 = *((uint32_t *)__cil_tmp278);
#line 578
  __cil_tmp280 = __cil_tmp279 & 524288U;
#line 578
  if (! __cil_tmp280) {
    {
#line 578
    __cil_tmp281 = (unsigned long )dev_priv;
#line 578
    __cil_tmp282 = __cil_tmp281 + 2156;
#line 578
    __cil_tmp283 = *((uint32_t *)__cil_tmp282);
#line 578
    __cil_tmp284 = __cil_tmp283 & 131072U;
#line 578
    if (! __cil_tmp284) {
      {
#line 578
      tmp___15 = vmw_fifo_have_pitchlock(dev_priv);
      }
#line 578
      if (tmp___15) {

      } else {
        {
#line 581
        ret = -38;
#line 582
        drm_err("vmw_driver_load", "Hardware has no pitchlock\n");
        }
#line 583
        goto out_err4;
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 586
  __cil_tmp285 = (unsigned long )dev_priv;
#line 586
  __cil_tmp286 = __cil_tmp285 + 2872;
#line 586
  __cil_tmp287 = 1816 + 16;
#line 586
  __cil_tmp288 = (unsigned long )dev_priv;
#line 586
  __cil_tmp289 = __cil_tmp288 + __cil_tmp287;
#line 586
  __cil_tmp290 = *((void **)__cil_tmp289);
#line 586
  __cil_tmp291 = (struct ttm_mem_global *)__cil_tmp290;
#line 586
  *((struct ttm_object_device **)__cil_tmp286) = ttm_object_device_init(__cil_tmp291,
                                                                        12U);
#line 589
  __cil_tmp292 = (void *)0;
#line 589
  __cil_tmp293 = (unsigned long )__cil_tmp292;
#line 589
  __cil_tmp294 = (unsigned long )dev_priv;
#line 589
  __cil_tmp295 = __cil_tmp294 + 2872;
#line 589
  __cil_tmp296 = *((struct ttm_object_device **)__cil_tmp295);
#line 589
  __cil_tmp297 = (unsigned long )__cil_tmp296;
#line 589
  __cil_tmp298 = __cil_tmp297 == __cil_tmp293;
#line 589
  __cil_tmp299 = ! __cil_tmp298;
#line 589
  __cil_tmp300 = ! __cil_tmp299;
#line 589
  __cil_tmp301 = (long )__cil_tmp300;
#line 589
  tmp___16 = ldv__builtin_expect(__cil_tmp301, 0L);
  }
#line 589
  if (tmp___16) {
    {
#line 590
    drm_err("vmw_driver_load", "Unable to initialize TTM object management.\n");
#line 591
    ret = -12;
    }
#line 592
    goto out_err4;
  } else {

  }
  {
#line 595
  __cil_tmp302 = (unsigned long )dev;
#line 595
  __cil_tmp303 = __cil_tmp302 + 1064;
#line 595
  *((void **)__cil_tmp303) = (void *)dev_priv;
#line 597
  __cil_tmp304 = (unsigned long )dev;
#line 597
  __cil_tmp305 = __cil_tmp304 + 1016;
#line 597
  __cil_tmp306 = *((struct pci_dev **)__cil_tmp305);
#line 597
  ret = (int )pci_request_regions(__cil_tmp306, "vmwgfx probe");
#line 598
  __cil_tmp307 = (unsigned long )dev_priv;
#line 598
  __cil_tmp308 = __cil_tmp307 + 134376;
#line 598
  __cil_tmp309 = ret != 0;
#line 598
  *((bool *)__cil_tmp308) = (bool )__cil_tmp309;
  }
  {
#line 599
  __cil_tmp310 = (unsigned long )dev_priv;
#line 599
  __cil_tmp311 = __cil_tmp310 + 134376;
#line 599
  if (*((bool *)__cil_tmp311)) {
    {
#line 604
    printk("<6>[drm] It appears like vesafb is loaded. Ignore above error if any.\n");
#line 606
    __cil_tmp312 = (unsigned long )dev;
#line 606
    __cil_tmp313 = __cil_tmp312 + 1016;
#line 606
    __cil_tmp314 = *((struct pci_dev **)__cil_tmp313);
#line 606
    ret = (int )pci_request_region(__cil_tmp314, 2, "vmwgfx stealth probe");
#line 607
    __cil_tmp315 = ret != 0;
#line 607
    __cil_tmp316 = ! __cil_tmp315;
#line 607
    __cil_tmp317 = ! __cil_tmp316;
#line 607
    __cil_tmp318 = (long )__cil_tmp317;
#line 607
    tmp___17 = ldv__builtin_expect(__cil_tmp318, 0L);
    }
#line 607
    if (tmp___17) {
      {
#line 608
      drm_err("vmw_driver_load", "Failed reserving the SVGA MMIO resource.\n");
      }
#line 609
      goto out_no_device;
    } else {

    }
  } else {

  }
  }
  {
#line 613
  __cil_tmp319 = (unsigned long )dev_priv;
#line 613
  __cil_tmp320 = __cil_tmp319 + 3008;
#line 613
  *((struct vmw_fence_manager **)__cil_tmp320) = vmw_fence_manager_init(dev_priv);
#line 614
  __cil_tmp321 = (void *)0;
#line 614
  __cil_tmp322 = (unsigned long )__cil_tmp321;
#line 614
  __cil_tmp323 = (unsigned long )dev_priv;
#line 614
  __cil_tmp324 = __cil_tmp323 + 3008;
#line 614
  __cil_tmp325 = *((struct vmw_fence_manager **)__cil_tmp324);
#line 614
  __cil_tmp326 = (unsigned long )__cil_tmp325;
#line 614
  __cil_tmp327 = __cil_tmp326 == __cil_tmp322;
#line 614
  __cil_tmp328 = ! __cil_tmp327;
#line 614
  __cil_tmp329 = ! __cil_tmp328;
#line 614
  __cil_tmp330 = (long )__cil_tmp329;
#line 614
  tmp___18 = ldv__builtin_expect(__cil_tmp330, 0L);
  }
#line 614
  if (tmp___18) {
#line 615
    goto out_no_fman;
  } else {

  }
  {
#line 618
  __cil_tmp331 = (bool )1;
#line 618
  ret = vmw_3d_resource_inc(dev_priv, __cil_tmp331);
#line 619
  __cil_tmp332 = ret != 0;
#line 619
  __cil_tmp333 = ! __cil_tmp332;
#line 619
  __cil_tmp334 = ! __cil_tmp333;
#line 619
  __cil_tmp335 = (long )__cil_tmp334;
#line 619
  tmp___19 = ldv__builtin_expect(__cil_tmp335, 0L);
  }
#line 619
  if (tmp___19) {
#line 620
    goto out_no_fifo;
  } else {

  }
  {
#line 621
  vmw_kms_save_vga(dev_priv);
#line 624
  ret = vmw_kms_init(dev_priv);
#line 625
  __cil_tmp336 = ret != 0;
#line 625
  __cil_tmp337 = ! __cil_tmp336;
#line 625
  __cil_tmp338 = ! __cil_tmp337;
#line 625
  __cil_tmp339 = (long )__cil_tmp338;
#line 625
  tmp___20 = ldv__builtin_expect(__cil_tmp339, 0L);
  }
#line 625
  if (tmp___20) {
#line 626
    goto out_no_kms;
  } else {

  }
  {
#line 627
  vmw_overlay_init(dev_priv);
#line 630
  tmp___23 = vmw_fifo_have_3d(dev_priv);
  }
#line 630
  if (tmp___23) {
#line 630
    tmp___22 = "";
  } else {
#line 630
    tmp___22 = "no ";
  }
  {
#line 630
  printk("<6>[drm] Detected %sdevice 3D availability.\n", tmp___22);
  }
  {
#line 635
  __cil_tmp340 = (unsigned long )dev_priv;
#line 635
  __cil_tmp341 = __cil_tmp340 + 134378;
#line 635
  if (*((bool *)__cil_tmp341)) {
    {
#line 636
    vmw_fb_init(dev_priv);
    }
  } else {
    {
#line 638
    vmw_kms_restore_vga(dev_priv);
#line 639
    __cil_tmp342 = (bool )1;
#line 639
    vmw_3d_resource_dec(dev_priv, __cil_tmp342);
    }
  }
  }
  {
#line 642
  __cil_tmp343 = (unsigned long )dev_priv;
#line 642
  __cil_tmp344 = __cil_tmp343 + 2156;
#line 642
  __cil_tmp345 = *((uint32_t *)__cil_tmp344);
#line 642
  if (__cil_tmp345 & 262144U) {
    {
#line 643
    ret = drm_irq_install(dev);
#line 644
    __cil_tmp346 = ret != 0;
#line 644
    __cil_tmp347 = ! __cil_tmp346;
#line 644
    __cil_tmp348 = ! __cil_tmp347;
#line 644
    __cil_tmp349 = (long )__cil_tmp348;
#line 644
    tmp___24 = ldv__builtin_expect(__cil_tmp349, 0L);
    }
#line 644
    if (tmp___24) {
      {
#line 645
      drm_err("vmw_driver_load", "Failed installing irq: %d\n", ret);
      }
#line 646
      goto out_no_irq;
    } else {

    }
  } else {

  }
  }
  {
#line 650
  __cil_tmp350 = (unsigned long )dev_priv;
#line 650
  __cil_tmp351 = __cil_tmp350 + 134632;
#line 650
  *((int (**)(struct notifier_block * , unsigned long  , void * ))__cil_tmp351) = & vmwgfx_pm_notifier;
#line 651
  __cil_tmp352 = (unsigned long )dev_priv;
#line 651
  __cil_tmp353 = __cil_tmp352 + 134632;
#line 651
  __cil_tmp354 = (struct notifier_block *)__cil_tmp353;
#line 651
  register_pm_notifier(__cil_tmp354);
  }
#line 653
  return (0);
  out_no_irq: 
  {
#line 656
  __cil_tmp355 = (unsigned long )dev_priv;
#line 656
  __cil_tmp356 = __cil_tmp355 + 134378;
#line 656
  if (*((bool *)__cil_tmp356)) {
    {
#line 657
    vmw_fb_close(dev_priv);
    }
  } else {

  }
  }
  {
#line 658
  vmw_overlay_close(dev_priv);
#line 659
  vmw_kms_close(dev_priv);
  }
  out_no_kms: 
  {
#line 662
  __cil_tmp357 = (unsigned long )dev_priv;
#line 662
  __cil_tmp358 = __cil_tmp357 + 134378;
#line 662
  if (*((bool *)__cil_tmp358)) {
    {
#line 663
    vmw_kms_restore_vga(dev_priv);
#line 664
    __cil_tmp359 = (bool )0;
#line 664
    vmw_3d_resource_dec(dev_priv, __cil_tmp359);
    }
  } else {

  }
  }
  out_no_fifo: 
  {
#line 667
  __cil_tmp360 = (unsigned long )dev_priv;
#line 667
  __cil_tmp361 = __cil_tmp360 + 3008;
#line 667
  __cil_tmp362 = *((struct vmw_fence_manager **)__cil_tmp361);
#line 667
  vmw_fence_manager_takedown(__cil_tmp362);
  }
  out_no_fman: 
  {
#line 669
  __cil_tmp363 = (unsigned long )dev_priv;
#line 669
  __cil_tmp364 = __cil_tmp363 + 134376;
#line 669
  if (*((bool *)__cil_tmp364)) {
    {
#line 670
    __cil_tmp365 = (unsigned long )dev;
#line 670
    __cil_tmp366 = __cil_tmp365 + 1016;
#line 670
    __cil_tmp367 = *((struct pci_dev **)__cil_tmp366);
#line 670
    pci_release_region(__cil_tmp367, 2);
    }
  } else {
    {
#line 672
    __cil_tmp368 = (unsigned long )dev;
#line 672
    __cil_tmp369 = __cil_tmp368 + 1016;
#line 672
    __cil_tmp370 = *((struct pci_dev **)__cil_tmp369);
#line 672
    pci_release_regions(__cil_tmp370);
    }
  }
  }
  out_no_device: 
  {
#line 674
  __cil_tmp371 = (unsigned long )dev_priv;
#line 674
  __cil_tmp372 = __cil_tmp371 + 2872;
#line 674
  __cil_tmp373 = (struct ttm_object_device **)__cil_tmp372;
#line 674
  ttm_object_device_release(__cil_tmp373);
  }
  out_err4: 
  {
#line 676
  __cil_tmp374 = (unsigned long )dev_priv;
#line 676
  __cil_tmp375 = __cil_tmp374 + 2144;
#line 676
  __cil_tmp376 = *((__le32 **)__cil_tmp375);
#line 676
  __cil_tmp377 = (void volatile   *)__cil_tmp376;
#line 676
  iounmap(__cil_tmp377);
  }
  out_err3: 
  {
#line 678
  __cil_tmp378 = (unsigned long )dev_priv;
#line 678
  __cil_tmp379 = __cil_tmp378 + 2152;
#line 678
  __cil_tmp380 = *((int *)__cil_tmp379);
#line 678
  __cil_tmp381 = (unsigned long )dev_priv;
#line 678
  __cil_tmp382 = __cil_tmp381 + 2116;
#line 678
  __cil_tmp383 = *((uint32_t *)__cil_tmp382);
#line 678
  __cil_tmp384 = (unsigned long )__cil_tmp383;
#line 678
  __cil_tmp385 = (unsigned long )dev_priv;
#line 678
  __cil_tmp386 = __cil_tmp385 + 2120;
#line 678
  __cil_tmp387 = *((uint32_t *)__cil_tmp386);
#line 678
  __cil_tmp388 = (unsigned long )__cil_tmp387;
#line 678
  drm_mtrr_del(__cil_tmp380, __cil_tmp384, __cil_tmp388, 1U);
  }
  {
#line 680
  __cil_tmp389 = (unsigned long )dev_priv;
#line 680
  __cil_tmp390 = __cil_tmp389 + 2176;
#line 680
  if (*((bool *)__cil_tmp390)) {
    {
#line 681
    __cil_tmp391 = (struct ttm_bo_device *)dev_priv;
#line 681
    ttm_bo_clean_mm(__cil_tmp391, 3U);
    }
  } else {

  }
  }
  {
#line 682
  __cil_tmp392 = (struct ttm_bo_device *)dev_priv;
#line 682
  ttm_bo_clean_mm(__cil_tmp392, 2U);
  }
  out_err2: 
  {
#line 684
  __cil_tmp393 = (struct ttm_bo_device *)dev_priv;
#line 684
  ttm_bo_device_release(__cil_tmp393);
  }
  out_err1: 
  {
#line 686
  vmw_ttm_global_release(dev_priv);
  }
  out_err0: 
  {
#line 688
  __cil_tmp394 = (unsigned long )dev_priv;
#line 688
  __cil_tmp395 = __cil_tmp394 + 2704;
#line 688
  __cil_tmp396 = (struct idr *)__cil_tmp395;
#line 688
  idr_destroy(__cil_tmp396);
#line 689
  __cil_tmp397 = (unsigned long )dev_priv;
#line 689
  __cil_tmp398 = __cil_tmp397 + 2656;
#line 689
  __cil_tmp399 = (struct idr *)__cil_tmp398;
#line 689
  idr_destroy(__cil_tmp399);
#line 690
  __cil_tmp400 = (unsigned long )dev_priv;
#line 690
  __cil_tmp401 = __cil_tmp400 + 2752;
#line 690
  __cil_tmp402 = (struct idr *)__cil_tmp401;
#line 690
  idr_destroy(__cil_tmp402);
#line 691
  __cil_tmp403 = (void    *)dev_priv;
#line 691
  kfree(__cil_tmp403);
  }
#line 692
  return (ret);
}
}
#line 695 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_driver_unload(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct notifier_block *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t *__cil_tmp13 ;
  void    *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_device *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  bool __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_fence_manager *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct pci_dev *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct pci_dev *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct ttm_object_device **__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void volatile   *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_bo_device *__cil_tmp55 ;
  struct ttm_bo_device *__cil_tmp56 ;
  struct ttm_bo_device *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct idr *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct idr *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct idr *__cil_tmp66 ;
  void    *__cil_tmp67 ;

  {
  {
#line 697
  tmp___7 = vmw_priv(dev);
#line 697
  dev_priv = tmp___7;
#line 699
  __cil_tmp4 = (unsigned long )dev_priv;
#line 699
  __cil_tmp5 = __cil_tmp4 + 134632;
#line 699
  __cil_tmp6 = (struct notifier_block *)__cil_tmp5;
#line 699
  unregister_pm_notifier(__cil_tmp6);
  }
  {
#line 701
  __cil_tmp7 = 3032 + 131200;
#line 701
  __cil_tmp8 = (unsigned long )dev_priv;
#line 701
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
#line 701
  if (*((uint32_t **)__cil_tmp9)) {
    {
#line 702
    __cil_tmp10 = 3032 + 131200;
#line 702
    __cil_tmp11 = (unsigned long )dev_priv;
#line 702
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 702
    __cil_tmp13 = *((uint32_t **)__cil_tmp12);
#line 702
    __cil_tmp14 = (void    *)__cil_tmp13;
#line 702
    vfree(__cil_tmp14);
    }
  } else {

  }
  }
  {
#line 703
  __cil_tmp15 = (unsigned long )dev_priv;
#line 703
  __cil_tmp16 = __cil_tmp15 + 2156;
#line 703
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
#line 703
  if (__cil_tmp17 & 262144U) {
    {
#line 704
    __cil_tmp18 = (unsigned long )dev_priv;
#line 704
    __cil_tmp19 = __cil_tmp18 + 2088;
#line 704
    __cil_tmp20 = *((struct drm_device **)__cil_tmp19);
#line 704
    drm_irq_uninstall(__cil_tmp20);
    }
  } else {

  }
  }
  {
#line 705
  __cil_tmp21 = (unsigned long )dev_priv;
#line 705
  __cil_tmp22 = __cil_tmp21 + 134378;
#line 705
  if (*((bool *)__cil_tmp22)) {
    {
#line 706
    vmw_fb_close(dev_priv);
#line 707
    vmw_kms_restore_vga(dev_priv);
#line 708
    __cil_tmp23 = (bool )0;
#line 708
    vmw_3d_resource_dec(dev_priv, __cil_tmp23);
    }
  } else {

  }
  }
  {
#line 710
  vmw_kms_close(dev_priv);
#line 711
  vmw_overlay_close(dev_priv);
#line 712
  __cil_tmp24 = (unsigned long )dev_priv;
#line 712
  __cil_tmp25 = __cil_tmp24 + 3008;
#line 712
  __cil_tmp26 = *((struct vmw_fence_manager **)__cil_tmp25);
#line 712
  vmw_fence_manager_takedown(__cil_tmp26);
  }
  {
#line 713
  __cil_tmp27 = (unsigned long )dev_priv;
#line 713
  __cil_tmp28 = __cil_tmp27 + 134376;
#line 713
  if (*((bool *)__cil_tmp28)) {
    {
#line 714
    __cil_tmp29 = (unsigned long )dev;
#line 714
    __cil_tmp30 = __cil_tmp29 + 1016;
#line 714
    __cil_tmp31 = *((struct pci_dev **)__cil_tmp30);
#line 714
    pci_release_region(__cil_tmp31, 2);
    }
  } else {
    {
#line 716
    __cil_tmp32 = (unsigned long )dev;
#line 716
    __cil_tmp33 = __cil_tmp32 + 1016;
#line 716
    __cil_tmp34 = *((struct pci_dev **)__cil_tmp33);
#line 716
    pci_release_regions(__cil_tmp34);
    }
  }
  }
  {
#line 718
  __cil_tmp35 = (unsigned long )dev_priv;
#line 718
  __cil_tmp36 = __cil_tmp35 + 2872;
#line 718
  __cil_tmp37 = (struct ttm_object_device **)__cil_tmp36;
#line 718
  ttm_object_device_release(__cil_tmp37);
#line 719
  __cil_tmp38 = (unsigned long )dev_priv;
#line 719
  __cil_tmp39 = __cil_tmp38 + 2144;
#line 719
  __cil_tmp40 = *((__le32 **)__cil_tmp39);
#line 719
  __cil_tmp41 = (void volatile   *)__cil_tmp40;
#line 719
  iounmap(__cil_tmp41);
#line 720
  __cil_tmp42 = (unsigned long )dev_priv;
#line 720
  __cil_tmp43 = __cil_tmp42 + 2152;
#line 720
  __cil_tmp44 = *((int *)__cil_tmp43);
#line 720
  __cil_tmp45 = (unsigned long )dev_priv;
#line 720
  __cil_tmp46 = __cil_tmp45 + 2116;
#line 720
  __cil_tmp47 = *((uint32_t *)__cil_tmp46);
#line 720
  __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 720
  __cil_tmp49 = (unsigned long )dev_priv;
#line 720
  __cil_tmp50 = __cil_tmp49 + 2120;
#line 720
  __cil_tmp51 = *((uint32_t *)__cil_tmp50);
#line 720
  __cil_tmp52 = (unsigned long )__cil_tmp51;
#line 720
  drm_mtrr_del(__cil_tmp44, __cil_tmp48, __cil_tmp52, 1U);
  }
  {
#line 722
  __cil_tmp53 = (unsigned long )dev_priv;
#line 722
  __cil_tmp54 = __cil_tmp53 + 2176;
#line 722
  if (*((bool *)__cil_tmp54)) {
    {
#line 723
    __cil_tmp55 = (struct ttm_bo_device *)dev_priv;
#line 723
    ttm_bo_clean_mm(__cil_tmp55, 3U);
    }
  } else {

  }
  }
  {
#line 724
  __cil_tmp56 = (struct ttm_bo_device *)dev_priv;
#line 724
  ttm_bo_clean_mm(__cil_tmp56, 2U);
#line 725
  __cil_tmp57 = (struct ttm_bo_device *)dev_priv;
#line 725
  ttm_bo_device_release(__cil_tmp57);
#line 726
  vmw_ttm_global_release(dev_priv);
#line 727
  __cil_tmp58 = (unsigned long )dev_priv;
#line 727
  __cil_tmp59 = __cil_tmp58 + 2704;
#line 727
  __cil_tmp60 = (struct idr *)__cil_tmp59;
#line 727
  idr_destroy(__cil_tmp60);
#line 728
  __cil_tmp61 = (unsigned long )dev_priv;
#line 728
  __cil_tmp62 = __cil_tmp61 + 2656;
#line 728
  __cil_tmp63 = (struct idr *)__cil_tmp62;
#line 728
  idr_destroy(__cil_tmp63);
#line 729
  __cil_tmp64 = (unsigned long )dev_priv;
#line 729
  __cil_tmp65 = __cil_tmp64 + 2752;
#line 729
  __cil_tmp66 = (struct idr *)__cil_tmp65;
#line 729
  idr_destroy(__cil_tmp66);
#line 731
  __cil_tmp67 = (void    *)dev_priv;
#line 731
  kfree(__cil_tmp67);
  }
#line 733
  return (0);
}
}
#line 736 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_preclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_fence_manager *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct list_head *__cil_tmp12 ;

  {
  {
#line 739
  tmp___7 = vmw_fpriv(file_priv);
#line 739
  vmw_fp = tmp___7;
#line 740
  tmp___8 = vmw_priv(dev);
#line 740
  dev_priv = tmp___8;
#line 742
  __cil_tmp7 = (unsigned long )dev_priv;
#line 742
  __cil_tmp8 = __cil_tmp7 + 3008;
#line 742
  __cil_tmp9 = *((struct vmw_fence_manager **)__cil_tmp8);
#line 742
  __cil_tmp10 = (unsigned long )vmw_fp;
#line 742
  __cil_tmp11 = __cil_tmp10 + 16;
#line 742
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
#line 742
  vmw_event_fence_fpriv_gone(__cil_tmp9, __cil_tmp12);
  }
#line 743
  return;
}
}
#line 745 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_postclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct ttm_object_file **__cil_tmp6 ;
  struct drm_master **__cil_tmp7 ;
  void    *__cil_tmp8 ;

  {
  {
#line 750
  vmw_fp = vmw_fpriv(file_priv);
#line 751
  __cil_tmp4 = (unsigned long )vmw_fp;
#line 751
  __cil_tmp5 = __cil_tmp4 + 8;
#line 751
  __cil_tmp6 = (struct ttm_object_file **)__cil_tmp5;
#line 751
  ttm_object_file_release(__cil_tmp6);
  }
#line 752
  if (*((struct drm_master **)vmw_fp)) {
    {
#line 753
    __cil_tmp7 = (struct drm_master **)vmw_fp;
#line 753
    drm_master_put(__cil_tmp7);
    }
  } else {

  }
  {
#line 754
  __cil_tmp8 = (void    *)vmw_fp;
#line 754
  kfree(__cil_tmp8);
  }
#line 755
  return;
}
}
#line 757 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_driver_open(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  int ret ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct ttm_object_device *__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_object_file *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct address_space *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct file *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct dentry *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct inode *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  void    *__cil_tmp64 ;

  {
  {
#line 759
  tmp___7 = vmw_priv(dev);
#line 759
  dev_priv = tmp___7;
#line 761
  ret = -12;
#line 763
  tmp___8 = kzalloc(32UL, 208U);
#line 763
  vmw_fp = (struct vmw_fpriv *)tmp___8;
#line 764
  __cil_tmp11 = (void *)0;
#line 764
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 764
  __cil_tmp13 = (unsigned long )vmw_fp;
#line 764
  __cil_tmp14 = __cil_tmp13 == __cil_tmp12;
#line 764
  __cil_tmp15 = ! __cil_tmp14;
#line 764
  __cil_tmp16 = ! __cil_tmp15;
#line 764
  __cil_tmp17 = (long )__cil_tmp16;
#line 764
  tmp___9 = ldv__builtin_expect(__cil_tmp17, 0L);
  }
#line 764
  if (tmp___9) {
#line 765
    return (ret);
  } else {

  }
  {
#line 767
  __cil_tmp18 = (unsigned long )vmw_fp;
#line 767
  __cil_tmp19 = __cil_tmp18 + 16;
#line 767
  __cil_tmp20 = (struct list_head *)__cil_tmp19;
#line 767
  INIT_LIST_HEAD(__cil_tmp20);
#line 768
  __cil_tmp21 = (unsigned long )vmw_fp;
#line 768
  __cil_tmp22 = __cil_tmp21 + 8;
#line 768
  __cil_tmp23 = (unsigned long )dev_priv;
#line 768
  __cil_tmp24 = __cil_tmp23 + 2872;
#line 768
  __cil_tmp25 = *((struct ttm_object_device **)__cil_tmp24);
#line 768
  *((struct ttm_object_file **)__cil_tmp22) = ttm_object_file_init(__cil_tmp25, 10U);
#line 769
  __cil_tmp26 = (void *)0;
#line 769
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 769
  __cil_tmp28 = (unsigned long )vmw_fp;
#line 769
  __cil_tmp29 = __cil_tmp28 + 8;
#line 769
  __cil_tmp30 = *((struct ttm_object_file **)__cil_tmp29);
#line 769
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 769
  __cil_tmp32 = __cil_tmp31 == __cil_tmp27;
#line 769
  __cil_tmp33 = ! __cil_tmp32;
#line 769
  __cil_tmp34 = ! __cil_tmp33;
#line 769
  __cil_tmp35 = (long )__cil_tmp34;
#line 769
  tmp___10 = ldv__builtin_expect(__cil_tmp35, 0L);
  }
#line 769
  if (tmp___10) {
#line 770
    goto out_no_tfile;
  } else {

  }
  {
#line 772
  __cil_tmp36 = (unsigned long )file_priv;
#line 772
  __cil_tmp37 = __cil_tmp36 + 136;
#line 772
  *((void **)__cil_tmp37) = (void *)vmw_fp;
#line 774
  __cil_tmp38 = (void *)0;
#line 774
  __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 774
  __cil_tmp40 = 0 + 1640;
#line 774
  __cil_tmp41 = (unsigned long )dev_priv;
#line 774
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 774
  __cil_tmp43 = *((struct address_space **)__cil_tmp42);
#line 774
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 774
  __cil_tmp45 = __cil_tmp44 == __cil_tmp39;
#line 774
  __cil_tmp46 = ! __cil_tmp45;
#line 774
  __cil_tmp47 = ! __cil_tmp46;
#line 774
  __cil_tmp48 = (long )__cil_tmp47;
#line 774
  tmp___11 = ldv__builtin_expect(__cil_tmp48, 0L);
  }
#line 774
  if (tmp___11) {
#line 775
    __cil_tmp49 = 0 + 1640;
#line 775
    __cil_tmp50 = (unsigned long )dev_priv;
#line 775
    __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
#line 775
    __cil_tmp52 = 16 + 8;
#line 775
    __cil_tmp53 = (unsigned long )file_priv;
#line 775
    __cil_tmp54 = __cil_tmp53 + 128;
#line 775
    __cil_tmp55 = *((struct file **)__cil_tmp54);
#line 775
    __cil_tmp56 = (unsigned long )__cil_tmp55;
#line 775
    __cil_tmp57 = __cil_tmp56 + __cil_tmp52;
#line 775
    __cil_tmp58 = *((struct dentry **)__cil_tmp57);
#line 775
    __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 775
    __cil_tmp60 = __cil_tmp59 + 48;
#line 775
    __cil_tmp61 = *((struct inode **)__cil_tmp60);
#line 775
    __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 775
    __cil_tmp63 = __cil_tmp62 + 48;
#line 775
    *((struct address_space **)__cil_tmp51) = *((struct address_space **)__cil_tmp63);
  } else {

  }
#line 778
  return (0);
  out_no_tfile: 
  {
#line 781
  __cil_tmp64 = (void    *)vmw_fp;
#line 781
  kfree(__cil_tmp64);
  }
#line 782
  return (ret);
}
}
#line 785 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static long vmw_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ struct drm_file *file_priv ;
  struct drm_device *dev ;
  unsigned int nr ;
  struct drm_ioctl_desc *ioctl ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_minor *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct drm_driver *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;

  {
#line 788
  __cil_tmp10 = (unsigned long )filp;
#line 788
  __cil_tmp11 = __cil_tmp10 + 200;
#line 788
  __cil_tmp12 = *((void **)__cil_tmp11);
#line 788
  file_priv = (struct drm_file *)__cil_tmp12;
#line 789
  __cil_tmp13 = (unsigned long )file_priv;
#line 789
  __cil_tmp14 = __cil_tmp13 + 40;
#line 789
  __cil_tmp15 = *((struct drm_minor **)__cil_tmp14);
#line 789
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 789
  __cil_tmp17 = __cil_tmp16 + 784;
#line 789
  dev = *((struct drm_device **)__cil_tmp17);
#line 790
  __cil_tmp18 = 1 << 8;
#line 790
  __cil_tmp19 = __cil_tmp18 - 1;
#line 790
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 790
  nr = cmd & __cil_tmp20;
#line 796
  if (nr >= 64U) {
#line 796
    if (nr < 160U) {
      {
#line 796
      __cil_tmp21 = (unsigned long )dev;
#line 796
      __cil_tmp22 = __cil_tmp21 + 1112;
#line 796
      __cil_tmp23 = *((struct drm_driver **)__cil_tmp22);
#line 796
      __cil_tmp24 = (unsigned long )__cil_tmp23;
#line 796
      __cil_tmp25 = __cil_tmp24 + 416;
#line 796
      __cil_tmp26 = *((int *)__cil_tmp25);
#line 796
      __cil_tmp27 = 64 + __cil_tmp26;
#line 796
      __cil_tmp28 = (unsigned int )__cil_tmp27;
#line 796
      if (nr < __cil_tmp28) {
        {
#line 798
        __cil_tmp29 = nr - 64U;
#line 798
        __cil_tmp30 = __cil_tmp29 * 24UL;
#line 798
        __cil_tmp31 = (unsigned long )(vmw_ioctls) + __cil_tmp30;
#line 798
        ioctl = (struct drm_ioctl_desc *)__cil_tmp31;
#line 801
        __cil_tmp32 = (unsigned long )ioctl;
#line 801
        __cil_tmp33 = __cil_tmp32 + 16;
#line 801
        __cil_tmp34 = *((unsigned int *)__cil_tmp33);
#line 801
        __cil_tmp35 = __cil_tmp34 != cmd;
#line 801
        __cil_tmp36 = ! __cil_tmp35;
#line 801
        __cil_tmp37 = ! __cil_tmp36;
#line 801
        __cil_tmp38 = (long )__cil_tmp37;
#line 801
        tmp___7 = ldv__builtin_expect(__cil_tmp38, 0L);
        }
#line 801
        if (tmp___7) {
          {
#line 802
          __cil_tmp39 = nr - 64U;
#line 802
          drm_err("vmw_unlocked_ioctl", "Invalid command format, ioctl %d\n", __cil_tmp39);
          }
#line 804
          return (-22L);
        } else {

        }
      } else {

      }
      }
    } else {

    }
  } else {

  }
  {
#line 808
  tmp___8 = drm_ioctl(filp, cmd, arg);
  }
#line 808
  return (tmp___8);
}
}
#line 811 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_firstopen(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 813
  tmp___7 = vmw_priv(dev);
#line 813
  dev_priv = tmp___7;
#line 814
  __cil_tmp4 = (unsigned long )dev_priv;
#line 814
  __cil_tmp5 = __cil_tmp4 + 134377;
#line 814
  *((bool *)__cil_tmp5) = (bool )1;
  }
#line 816
  return (0);
}
}
#line 819 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_lastclose(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_crtc *crtc ;
  struct drm_mode_set set ;
  int ret ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int __ret_warn_on ;
  long tmp___8 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  struct drm_crtc *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct drm_crtc_funcs    *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int (*   __cil_tmp51)(struct drm_mode_set *set ) ;
  int (*__cil_tmp52)(struct drm_mode_set *set ) ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  long __cil_tmp57 ;
  int    __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  struct drm_crtc *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
#line 821
  tmp___7 = vmw_priv(dev);
#line 821
  dev_priv = tmp___7;
  }
  {
#line 830
  __cil_tmp11 = (unsigned long )dev_priv;
#line 830
  __cil_tmp12 = __cil_tmp11 + 134377;
#line 830
  __cil_tmp13 = *((bool *)__cil_tmp12);
#line 830
  if (! __cil_tmp13) {
#line 831
    return;
  } else {

  }
  }
#line 833
  __cil_tmp14 = (unsigned long )dev_priv;
#line 833
  __cil_tmp15 = __cil_tmp14 + 134377;
#line 833
  *((bool *)__cil_tmp15) = (bool )0;
#line 834
  __cil_tmp16 = (unsigned long )(& set) + 40;
#line 834
  *((uint32_t *)__cil_tmp16) = (uint32_t )0;
#line 835
  __cil_tmp17 = (unsigned long )(& set) + 44;
#line 835
  *((uint32_t *)__cil_tmp17) = (uint32_t )0;
#line 836
  __cil_tmp18 = (unsigned long )(& set) + 16;
#line 836
  __cil_tmp19 = (void *)0;
#line 836
  *((struct drm_framebuffer **)__cil_tmp18) = (struct drm_framebuffer *)__cil_tmp19;
#line 837
  __cil_tmp20 = (unsigned long )(& set) + 32;
#line 837
  __cil_tmp21 = (void *)0;
#line 837
  *((struct drm_display_mode **)__cil_tmp20) = (struct drm_display_mode *)__cil_tmp21;
#line 838
  __cil_tmp22 = (unsigned long )(& set) + 48;
#line 838
  __cil_tmp23 = (void *)0;
#line 838
  *((struct drm_connector ***)__cil_tmp22) = (struct drm_connector **)__cil_tmp23;
#line 839
  __cil_tmp24 = (unsigned long )(& set) + 56;
#line 839
  *((size_t *)__cil_tmp24) = (size_t )0;
#line 841
  __cil_tmp25 = 1152 + 296;
#line 841
  __cil_tmp26 = (unsigned long )dev;
#line 841
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
#line 841
  __cil_tmp28 = *((struct list_head **)__cil_tmp27);
#line 841
  __mptr = (struct list_head    *)__cil_tmp28;
#line 841
  __cil_tmp29 = (struct drm_crtc *)0;
#line 841
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 841
  __cil_tmp31 = __cil_tmp30 + 8;
#line 841
  __cil_tmp32 = (struct list_head *)__cil_tmp31;
#line 841
  __cil_tmp33 = (unsigned int )__cil_tmp32;
#line 841
  __cil_tmp34 = (char *)__mptr;
#line 841
  __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
#line 841
  crtc = (struct drm_crtc *)__cil_tmp35;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 841
    __cil_tmp36 = 1152 + 296;
#line 841
    __cil_tmp37 = (unsigned long )dev;
#line 841
    __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 841
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
#line 841
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 841
    __cil_tmp41 = (unsigned long )crtc;
#line 841
    __cil_tmp42 = __cil_tmp41 + 8;
#line 841
    __cil_tmp43 = (struct list_head *)__cil_tmp42;
#line 841
    __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 841
    if (__cil_tmp44 != __cil_tmp40) {

    } else {
#line 841
      goto while_break;
    }
    }
    {
#line 842
    __cil_tmp45 = (unsigned long )(& set) + 24;
#line 842
    *((struct drm_crtc **)__cil_tmp45) = crtc;
#line 843
    __cil_tmp46 = (unsigned long )crtc;
#line 843
    __cil_tmp47 = __cil_tmp46 + 488;
#line 843
    __cil_tmp48 = *((struct drm_crtc_funcs    **)__cil_tmp47);
#line 843
    __cil_tmp49 = (unsigned long )__cil_tmp48;
#line 843
    __cil_tmp50 = __cil_tmp49 + 56;
#line 843
    __cil_tmp51 = *((int (*   *)(struct drm_mode_set *set ))__cil_tmp50);
#line 843
    __cil_tmp52 = (int (*)(struct drm_mode_set *set ))__cil_tmp51;
#line 843
    ret = (*__cil_tmp52)(& set);
#line 844
    __cil_tmp53 = ret != 0;
#line 844
    __cil_tmp54 = ! __cil_tmp53;
#line 844
    __ret_warn_on = ! __cil_tmp54;
#line 844
    __cil_tmp55 = ! __ret_warn_on;
#line 844
    __cil_tmp56 = ! __cil_tmp55;
#line 844
    __cil_tmp57 = (long )__cil_tmp56;
#line 844
    tmp___8 = ldv__builtin_expect(__cil_tmp57, 0L);
    }
#line 844
    if (tmp___8) {
      {
#line 844
      __cil_tmp58 = (int    )844;
#line 844
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c",
                         __cil_tmp58);
      }
    } else {

    }
    {
#line 844
    __cil_tmp59 = ! __ret_warn_on;
#line 844
    __cil_tmp60 = ! __cil_tmp59;
#line 844
    __cil_tmp61 = (long )__cil_tmp60;
#line 844
    ldv__builtin_expect(__cil_tmp61, 0L);
#line 841
    __cil_tmp62 = (unsigned long )crtc;
#line 841
    __cil_tmp63 = __cil_tmp62 + 8;
#line 841
    __cil_tmp64 = *((struct list_head **)__cil_tmp63);
#line 841
    __mptr___0 = (struct list_head    *)__cil_tmp64;
#line 841
    __cil_tmp65 = (struct drm_crtc *)0;
#line 841
    __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 841
    __cil_tmp67 = __cil_tmp66 + 8;
#line 841
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 841
    __cil_tmp69 = (unsigned int )__cil_tmp68;
#line 841
    __cil_tmp70 = (char *)__mptr___0;
#line 841
    __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
#line 841
    crtc = (struct drm_crtc *)__cil_tmp71;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 847
  return;
}
}
#line 853 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct lock_class_key __key___11  ;
#line 849 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_master_init(struct vmw_master *vmaster ) 
{ struct ttm_lock *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct list_head *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;

  {
  {
#line 851
  __cil_tmp2 = (struct ttm_lock *)vmaster;
#line 851
  ttm_lock_init(__cil_tmp2);
#line 852
  __cil_tmp3 = (unsigned long )vmaster;
#line 852
  __cil_tmp4 = __cil_tmp3 + 224;
#line 852
  __cil_tmp5 = (struct list_head *)__cil_tmp4;
#line 852
  INIT_LIST_HEAD(__cil_tmp5);
  }
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 853
    __cil_tmp6 = (unsigned long )vmaster;
#line 853
    __cil_tmp7 = __cil_tmp6 + 152;
#line 853
    __cil_tmp8 = (struct mutex *)__cil_tmp7;
#line 853
    __mutex_init(__cil_tmp8, "&vmaster->fb_surf_mutex", & __key___11);
    }
#line 853
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  return;
}
}
#line 856 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_master_create(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  void *tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  struct ttm_lock *__cil_tmp13 ;
  bool __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
  {
#line 861
  tmp___7 = kzalloc(240UL, 208U);
#line 861
  vmaster = (struct vmw_master *)tmp___7;
#line 862
  __cil_tmp6 = (void *)0;
#line 862
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 862
  __cil_tmp8 = (unsigned long )vmaster;
#line 862
  __cil_tmp9 = __cil_tmp8 == __cil_tmp7;
#line 862
  __cil_tmp10 = ! __cil_tmp9;
#line 862
  __cil_tmp11 = ! __cil_tmp10;
#line 862
  __cil_tmp12 = (long )__cil_tmp11;
#line 862
  tmp___8 = ldv__builtin_expect(__cil_tmp12, 0L);
  }
#line 862
  if (tmp___8) {
#line 863
    return (-12);
  } else {

  }
  {
#line 865
  vmw_master_init(vmaster);
#line 866
  __cil_tmp13 = (struct ttm_lock *)vmaster;
#line 866
  __cil_tmp14 = (bool )1;
#line 866
  ttm_lock_set_kill(__cil_tmp13, __cil_tmp14, 15);
#line 867
  __cil_tmp15 = (unsigned long )master;
#line 867
  __cil_tmp16 = __cil_tmp15 + 192;
#line 867
  *((void **)__cil_tmp16) = (void *)vmaster;
  }
#line 869
  return (0);
}
}
#line 872 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_master_destroy(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void    *__cil_tmp7 ;

  {
  {
#line 875
  tmp___7 = vmw_master(master);
#line 875
  vmaster = tmp___7;
#line 877
  __cil_tmp5 = (unsigned long )master;
#line 877
  __cil_tmp6 = __cil_tmp5 + 192;
#line 877
  *((void **)__cil_tmp6) = (void *)0;
#line 878
  __cil_tmp7 = (void    *)vmaster;
#line 878
  kfree(__cil_tmp7);
  }
#line 879
  return;
}
}
#line 882 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_master_set(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_master *active ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct drm_master *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  bool __cil_tmp24 ;
  bool __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct mutex *__cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_master *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  struct ttm_lock *__cil_tmp46 ;
  bool __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_object_file *__cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  long __cil_tmp54 ;
  struct ttm_lock *__cil_tmp55 ;
  bool __cil_tmp56 ;
  struct ttm_bo_device *__cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  void *__cil_tmp64 ;
  struct ttm_lock *__cil_tmp65 ;
  bool __cil_tmp66 ;
  struct ttm_lock *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct drm_master *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct drm_master *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  long __cil_tmp77 ;
  struct drm_master **__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  bool __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct mutex *__cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct mutex *__cil_tmp90 ;
  bool __cil_tmp91 ;

  {
  {
#line 886
  tmp___7 = vmw_priv(dev);
#line 886
  dev_priv = tmp___7;
#line 887
  tmp___8 = vmw_fpriv(file_priv);
#line 887
  vmw_fp = tmp___8;
#line 888
  __cil_tmp17 = (unsigned long )dev_priv;
#line 888
  __cil_tmp18 = __cil_tmp17 + 134384;
#line 888
  active = *((struct vmw_master **)__cil_tmp18);
#line 889
  __cil_tmp19 = (unsigned long )file_priv;
#line 889
  __cil_tmp20 = __cil_tmp19 + 152;
#line 889
  __cil_tmp21 = *((struct drm_master **)__cil_tmp20);
#line 889
  tmp___9 = vmw_master(__cil_tmp21);
#line 889
  vmaster = tmp___9;
#line 890
  ret = 0;
  }
  {
#line 892
  __cil_tmp22 = (unsigned long )dev_priv;
#line 892
  __cil_tmp23 = __cil_tmp22 + 134378;
#line 892
  __cil_tmp24 = *((bool *)__cil_tmp23);
#line 892
  if (! __cil_tmp24) {
    {
#line 893
    __cil_tmp25 = (bool )1;
#line 893
    ret = vmw_3d_resource_inc(dev_priv, __cil_tmp25);
#line 894
    __cil_tmp26 = ret != 0;
#line 894
    __cil_tmp27 = ! __cil_tmp26;
#line 894
    __cil_tmp28 = ! __cil_tmp27;
#line 894
    __cil_tmp29 = (long )__cil_tmp28;
#line 894
    tmp___10 = ldv__builtin_expect(__cil_tmp29, 0L);
    }
#line 894
    if (tmp___10) {
#line 895
      return (ret);
    } else {

    }
    {
#line 896
    vmw_kms_save_vga(dev_priv);
#line 897
    __cil_tmp30 = (unsigned long )dev_priv;
#line 897
    __cil_tmp31 = __cil_tmp30 + 2184;
#line 897
    __cil_tmp32 = (struct mutex *)__cil_tmp31;
#line 897
    mutex_lock(__cil_tmp32);
#line 898
    __cil_tmp33 = (uint32_t )0;
#line 898
    vmw_write(dev_priv, 45U, __cil_tmp33);
#line 899
    __cil_tmp34 = (unsigned long )dev_priv;
#line 899
    __cil_tmp35 = __cil_tmp34 + 2184;
#line 899
    __cil_tmp36 = (struct mutex *)__cil_tmp35;
#line 899
    mutex_unlock(__cil_tmp36);
    }
  } else {

  }
  }
#line 902
  if (active) {
    {
#line 903
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 903
      __cil_tmp37 = (unsigned long )dev_priv;
#line 903
      __cil_tmp38 = __cil_tmp37 + 134392;
#line 903
      __cil_tmp39 = (struct vmw_master *)__cil_tmp38;
#line 903
      __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 903
      __cil_tmp41 = (unsigned long )active;
#line 903
      __cil_tmp42 = __cil_tmp41 != __cil_tmp40;
#line 903
      __cil_tmp43 = ! __cil_tmp42;
#line 903
      __cil_tmp44 = ! __cil_tmp43;
#line 903
      __cil_tmp45 = (long )__cil_tmp44;
#line 903
      tmp___11 = ldv__builtin_expect(__cil_tmp45, 0L);
      }
#line 903
      if (tmp___11) {
        {
#line 903
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 903
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                               "i" (903), "i" (12UL));
          {
#line 903
          while (1) {
            while_continue___1: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 903
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {

      }
#line 903
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 904
    __cil_tmp46 = (struct ttm_lock *)active;
#line 904
    __cil_tmp47 = (bool )0;
#line 904
    __cil_tmp48 = (unsigned long )vmw_fp;
#line 904
    __cil_tmp49 = __cil_tmp48 + 8;
#line 904
    __cil_tmp50 = *((struct ttm_object_file **)__cil_tmp49);
#line 904
    ret = ttm_vt_lock(__cil_tmp46, __cil_tmp47, __cil_tmp50);
#line 905
    __cil_tmp51 = ret != 0;
#line 905
    __cil_tmp52 = ! __cil_tmp51;
#line 905
    __cil_tmp53 = ! __cil_tmp52;
#line 905
    __cil_tmp54 = (long )__cil_tmp53;
#line 905
    tmp___12 = ldv__builtin_expect(__cil_tmp54, 0L);
    }
#line 905
    if (tmp___12) {
#line 906
      goto out_no_active_lock;
    } else {

    }
    {
#line 908
    __cil_tmp55 = (struct ttm_lock *)active;
#line 908
    __cil_tmp56 = (bool )1;
#line 908
    ttm_lock_set_kill(__cil_tmp55, __cil_tmp56, 15);
#line 909
    __cil_tmp57 = (struct ttm_bo_device *)dev_priv;
#line 909
    ret = ttm_bo_evict_mm(__cil_tmp57, 2U);
#line 910
    __cil_tmp58 = ret != 0;
#line 910
    __cil_tmp59 = ! __cil_tmp58;
#line 910
    __cil_tmp60 = ! __cil_tmp59;
#line 910
    __cil_tmp61 = (long )__cil_tmp60;
#line 910
    tmp___13 = ldv__builtin_expect(__cil_tmp61, 0L);
    }
#line 910
    if (tmp___13) {
      {
#line 911
      drm_err("vmw_master_set", "Unable to clean VRAM on master drop.\n");
      }
    } else {

    }
#line 915
    __cil_tmp62 = (unsigned long )dev_priv;
#line 915
    __cil_tmp63 = __cil_tmp62 + 134384;
#line 915
    __cil_tmp64 = (void *)0;
#line 915
    *((struct vmw_master **)__cil_tmp63) = (struct vmw_master *)__cil_tmp64;
  } else {

  }
  {
#line 918
  __cil_tmp65 = (struct ttm_lock *)vmaster;
#line 918
  __cil_tmp66 = (bool )0;
#line 918
  ttm_lock_set_kill(__cil_tmp65, __cil_tmp66, 15);
  }
#line 919
  if (! from_open) {
    {
#line 920
    __cil_tmp67 = (struct ttm_lock *)vmaster;
#line 920
    ttm_vt_unlock(__cil_tmp67);
    }
    {
#line 921
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 921
      __cil_tmp68 = (unsigned long )file_priv;
#line 921
      __cil_tmp69 = __cil_tmp68 + 152;
#line 921
      __cil_tmp70 = *((struct drm_master **)__cil_tmp69);
#line 921
      __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 921
      __cil_tmp72 = *((struct drm_master **)vmw_fp);
#line 921
      __cil_tmp73 = (unsigned long )__cil_tmp72;
#line 921
      __cil_tmp74 = __cil_tmp73 != __cil_tmp71;
#line 921
      __cil_tmp75 = ! __cil_tmp74;
#line 921
      __cil_tmp76 = ! __cil_tmp75;
#line 921
      __cil_tmp77 = (long )__cil_tmp76;
#line 921
      tmp___14 = ldv__builtin_expect(__cil_tmp77, 0L);
      }
#line 921
      if (tmp___14) {
        {
#line 921
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 921
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                               "i" (921), "i" (12UL));
          {
#line 921
          while (1) {
            while_continue___4: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 921
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {

      }
#line 921
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 922
    __cil_tmp78 = (struct drm_master **)vmw_fp;
#line 922
    drm_master_put(__cil_tmp78);
    }
  } else {

  }
#line 925
  __cil_tmp79 = (unsigned long )dev_priv;
#line 925
  __cil_tmp80 = __cil_tmp79 + 134384;
#line 925
  *((struct vmw_master **)__cil_tmp80) = vmaster;
#line 927
  return (0);
  out_no_active_lock: 
  {
#line 930
  __cil_tmp81 = (unsigned long )dev_priv;
#line 930
  __cil_tmp82 = __cil_tmp81 + 134378;
#line 930
  __cil_tmp83 = *((bool *)__cil_tmp82);
#line 930
  if (! __cil_tmp83) {
    {
#line 931
    __cil_tmp84 = (unsigned long )dev_priv;
#line 931
    __cil_tmp85 = __cil_tmp84 + 2184;
#line 931
    __cil_tmp86 = (struct mutex *)__cil_tmp85;
#line 931
    mutex_lock(__cil_tmp86);
#line 932
    __cil_tmp87 = (uint32_t )1;
#line 932
    vmw_write(dev_priv, 45U, __cil_tmp87);
#line 933
    __cil_tmp88 = (unsigned long )dev_priv;
#line 933
    __cil_tmp89 = __cil_tmp88 + 2184;
#line 933
    __cil_tmp90 = (struct mutex *)__cil_tmp89;
#line 933
    mutex_unlock(__cil_tmp90);
#line 934
    vmw_kms_restore_vga(dev_priv);
#line 935
    __cil_tmp91 = (bool )1;
#line 935
    vmw_3d_resource_dec(dev_priv, __cil_tmp91);
    }
  } else {

  }
  }
#line 937
  return (ret);
}
}
#line 940 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_master_drop(struct drm_device *dev , struct drm_file *file_priv ,
                            bool from_release ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_master *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_master *__cil_tmp18 ;
  struct ttm_lock *__cil_tmp19 ;
  bool __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_object_file *__cil_tmp23 ;
  bool __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct drm_master **__cil_tmp30 ;
  struct ttm_lock *__cil_tmp31 ;
  bool __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  bool __cil_tmp35 ;
  struct ttm_bo_device *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct mutex *__cil_tmp47 ;
  bool __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_lock *__cil_tmp55 ;
  bool __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct ttm_lock *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;

  {
  {
#line 944
  tmp___7 = vmw_priv(dev);
#line 944
  dev_priv = tmp___7;
#line 945
  tmp___8 = vmw_fpriv(file_priv);
#line 945
  vmw_fp = tmp___8;
#line 946
  __cil_tmp13 = (unsigned long )file_priv;
#line 946
  __cil_tmp14 = __cil_tmp13 + 152;
#line 946
  __cil_tmp15 = *((struct drm_master **)__cil_tmp14);
#line 946
  tmp___9 = vmw_master(__cil_tmp15);
#line 946
  vmaster = tmp___9;
#line 954
  __cil_tmp16 = (unsigned long )file_priv;
#line 954
  __cil_tmp17 = __cil_tmp16 + 152;
#line 954
  __cil_tmp18 = *((struct drm_master **)__cil_tmp17);
#line 954
  *((struct drm_master **)vmw_fp) = drm_master_get(__cil_tmp18);
#line 955
  __cil_tmp19 = (struct ttm_lock *)vmaster;
#line 955
  __cil_tmp20 = (bool )0;
#line 955
  __cil_tmp21 = (unsigned long )vmw_fp;
#line 955
  __cil_tmp22 = __cil_tmp21 + 8;
#line 955
  __cil_tmp23 = *((struct ttm_object_file **)__cil_tmp22);
#line 955
  ret = ttm_vt_lock(__cil_tmp19, __cil_tmp20, __cil_tmp23);
#line 956
  __cil_tmp24 = (bool )0;
#line 956
  __cil_tmp25 = (uint32_t )0;
#line 956
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp24, __cil_tmp25);
#line 958
  __cil_tmp26 = ret != 0;
#line 958
  __cil_tmp27 = ! __cil_tmp26;
#line 958
  __cil_tmp28 = ! __cil_tmp27;
#line 958
  __cil_tmp29 = (long )__cil_tmp28;
#line 958
  tmp___10 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 958
  if (tmp___10) {
    {
#line 959
    drm_err("vmw_master_drop", "Unable to lock TTM at VT switch.\n");
#line 960
    __cil_tmp30 = (struct drm_master **)vmw_fp;
#line 960
    drm_master_put(__cil_tmp30);
    }
  } else {

  }
  {
#line 963
  __cil_tmp31 = (struct ttm_lock *)vmaster;
#line 963
  __cil_tmp32 = (bool )1;
#line 963
  ttm_lock_set_kill(__cil_tmp31, __cil_tmp32, 15);
  }
  {
#line 965
  __cil_tmp33 = (unsigned long )dev_priv;
#line 965
  __cil_tmp34 = __cil_tmp33 + 134378;
#line 965
  __cil_tmp35 = *((bool *)__cil_tmp34);
#line 965
  if (! __cil_tmp35) {
    {
#line 966
    __cil_tmp36 = (struct ttm_bo_device *)dev_priv;
#line 966
    ret = ttm_bo_evict_mm(__cil_tmp36, 2U);
#line 967
    __cil_tmp37 = ret != 0;
#line 967
    __cil_tmp38 = ! __cil_tmp37;
#line 967
    __cil_tmp39 = ! __cil_tmp38;
#line 967
    __cil_tmp40 = (long )__cil_tmp39;
#line 967
    tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
    }
#line 967
    if (tmp___11) {
      {
#line 968
      drm_err("vmw_master_drop", "Unable to clean VRAM on master drop.\n");
      }
    } else {

    }
    {
#line 969
    __cil_tmp41 = (unsigned long )dev_priv;
#line 969
    __cil_tmp42 = __cil_tmp41 + 2184;
#line 969
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
#line 969
    mutex_lock(__cil_tmp43);
#line 970
    __cil_tmp44 = (uint32_t )1;
#line 970
    vmw_write(dev_priv, 45U, __cil_tmp44);
#line 971
    __cil_tmp45 = (unsigned long )dev_priv;
#line 971
    __cil_tmp46 = __cil_tmp45 + 2184;
#line 971
    __cil_tmp47 = (struct mutex *)__cil_tmp46;
#line 971
    mutex_unlock(__cil_tmp47);
#line 972
    vmw_kms_restore_vga(dev_priv);
#line 973
    __cil_tmp48 = (bool )1;
#line 973
    vmw_3d_resource_dec(dev_priv, __cil_tmp48);
    }
  } else {

  }
  }
  {
#line 976
  __cil_tmp49 = (unsigned long )dev_priv;
#line 976
  __cil_tmp50 = __cil_tmp49 + 134384;
#line 976
  __cil_tmp51 = (unsigned long )dev_priv;
#line 976
  __cil_tmp52 = __cil_tmp51 + 134392;
#line 976
  *((struct vmw_master **)__cil_tmp50) = (struct vmw_master *)__cil_tmp52;
#line 977
  __cil_tmp53 = (unsigned long )dev_priv;
#line 977
  __cil_tmp54 = __cil_tmp53 + 134392;
#line 977
  __cil_tmp55 = (struct ttm_lock *)__cil_tmp54;
#line 977
  __cil_tmp56 = (bool )0;
#line 977
  ttm_lock_set_kill(__cil_tmp55, __cil_tmp56, 15);
#line 978
  __cil_tmp57 = (unsigned long )dev_priv;
#line 978
  __cil_tmp58 = __cil_tmp57 + 134392;
#line 978
  __cil_tmp59 = (struct ttm_lock *)__cil_tmp58;
#line 978
  ttm_vt_unlock(__cil_tmp59);
  }
  {
#line 980
  __cil_tmp60 = (unsigned long )dev_priv;
#line 980
  __cil_tmp61 = __cil_tmp60 + 134378;
#line 980
  if (*((bool *)__cil_tmp61)) {
    {
#line 981
    vmw_fb_on(dev_priv);
    }
  } else {

  }
  }
#line 982
  return;
}
}
#line 985 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_remove(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp___7 ;

  {
  {
#line 987
  tmp___7 = pci_get_drvdata(pdev);
#line 987
  dev = (struct drm_device *)tmp___7;
#line 989
  drm_put_dev(dev);
  }
#line 990
  return;
}
}
#line 992 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) 
{ struct vmw_private *dev_priv ;
  struct notifier_block    *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_private *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct notifier_block *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_lock *__cil_tmp16 ;
  bool __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  struct ttm_bo_device *__cil_tmp19 ;
  struct ttm_lock *__cil_tmp20 ;

  {
#line 996
  __mptr = (struct notifier_block    *)nb;
#line 996
  __cil_tmp7 = (struct vmw_private *)0;
#line 996
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 996
  __cil_tmp9 = __cil_tmp8 + 134632;
#line 996
  __cil_tmp10 = (struct notifier_block *)__cil_tmp9;
#line 996
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 996
  __cil_tmp12 = (char *)__mptr;
#line 996
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 996
  dev_priv = (struct vmw_private *)__cil_tmp13;
#line 997
  __cil_tmp14 = (unsigned long )dev_priv;
#line 997
  __cil_tmp15 = __cil_tmp14 + 134384;
#line 997
  vmaster = *((struct vmw_master **)__cil_tmp15);
#line 1000
  if ((int )val == 1) {
#line 1000
    goto case_1;
  } else
#line 1001
  if ((int )val == 3) {
#line 1001
    goto case_1;
  } else
#line 1012
  if ((int )val == 2) {
#line 1012
    goto case_2;
  } else
#line 1013
  if ((int )val == 4) {
#line 1013
    goto case_2;
  } else
#line 1014
  if ((int )val == 6) {
#line 1014
    goto case_2;
  } else
#line 1018
  if ((int )val == 5) {
#line 1018
    goto case_5;
  } else {
    {
#line 1020
    goto switch_default;
#line 999
    if (0) {
      case_1: /* CIL Label */ 
      case_3: /* CIL Label */ 
      {
#line 1002
      __cil_tmp16 = (struct ttm_lock *)vmaster;
#line 1002
      ttm_suspend_lock(__cil_tmp16);
#line 1008
      __cil_tmp17 = (bool )0;
#line 1008
      __cil_tmp18 = (uint32_t )0;
#line 1008
      vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp17, __cil_tmp18);
#line 1009
      __cil_tmp19 = (struct ttm_bo_device *)dev_priv;
#line 1009
      ttm_bo_swapout_all(__cil_tmp19);
      }
#line 1011
      goto switch_break;
      case_2: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 1015
      __cil_tmp20 = (struct ttm_lock *)vmaster;
#line 1015
      ttm_suspend_unlock(__cil_tmp20);
      }
#line 1017
      goto switch_break;
      case_5: /* CIL Label */ 
#line 1019
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1021
      goto switch_break;
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
#line 1023
  return (0);
}
}
#line 1030 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_pci_suspend(struct pci_dev *pdev , int state_event10 ) 
{ struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
  {
#line 1032
  tmp___7 = pci_get_drvdata(pdev);
#line 1032
  dev = (struct drm_device *)tmp___7;
#line 1033
  tmp___8 = vmw_priv(dev);
#line 1033
  dev_priv = tmp___8;
  }
  {
#line 1035
  __cil_tmp7 = (unsigned long )dev_priv;
#line 1035
  __cil_tmp8 = __cil_tmp7 + 134736;
#line 1035
  __cil_tmp9 = *((uint32_t *)__cil_tmp8);
#line 1035
  if (__cil_tmp9 != 0U) {
    {
#line 1036
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
    }
#line 1038
    return (-16);
  } else {

  }
  }
  {
#line 1041
  pci_save_state(pdev);
#line 1042
  pci_disable_device(pdev);
#line 1043
  pci_set_power_state(pdev, 3);
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_pci_resume(struct pci_dev *pdev ) 
{ int tmp___7 ;

  {
  {
#line 1049
  pci_set_power_state(pdev, 0);
#line 1050
  pci_restore_state(pdev);
#line 1051
  tmp___7 = (int )pci_enable_device(pdev);
  }
#line 1051
  return (tmp___7);
}
}
#line 1054 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_pm_suspend(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device    *__mptr ;
  struct pm_message dummy ;
  int tmp___7 ;
  struct pci_dev *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct device *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int dummy_event13 ;

  {
  {
#line 1056
  __mptr = (struct device    *)kdev;
#line 1056
  __cil_tmp6 = (struct pci_dev *)0;
#line 1056
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 1056
  __cil_tmp8 = __cil_tmp7 + 144;
#line 1056
  __cil_tmp9 = (struct device *)__cil_tmp8;
#line 1056
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 1056
  __cil_tmp11 = (char *)__mptr;
#line 1056
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 1056
  pdev = (struct pci_dev *)__cil_tmp12;
#line 1059
  dummy_event13 = 0;
#line 1061
  tmp___7 = vmw_pci_suspend(pdev, dummy_event13);
  }
#line 1061
  return (tmp___7);
}
}
#line 1064 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_pm_resume(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device    *__mptr ;
  int tmp___7 ;
  struct pci_dev *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct device *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1066
  __mptr = (struct device    *)kdev;
#line 1066
  __cil_tmp5 = (struct pci_dev *)0;
#line 1066
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 1066
  __cil_tmp7 = __cil_tmp6 + 144;
#line 1066
  __cil_tmp8 = (struct device *)__cil_tmp7;
#line 1066
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 1066
  __cil_tmp10 = (char *)__mptr;
#line 1066
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 1066
  pdev = (struct pci_dev *)__cil_tmp11;
#line 1068
  tmp___7 = vmw_pci_resume(pdev);
  }
#line 1068
  return (tmp___7);
}
}
#line 1071 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_pm_prepare(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device    *__mptr ;
  struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct pci_dev *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct device *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  bool __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  bool __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;

  {
  {
#line 1073
  __mptr = (struct device    *)kdev;
#line 1073
  __cil_tmp8 = (struct pci_dev *)0;
#line 1073
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 1073
  __cil_tmp10 = __cil_tmp9 + 144;
#line 1073
  __cil_tmp11 = (struct device *)__cil_tmp10;
#line 1073
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 1073
  __cil_tmp13 = (char *)__mptr;
#line 1073
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 1073
  pdev = (struct pci_dev *)__cil_tmp14;
#line 1074
  tmp___7 = pci_get_drvdata(pdev);
#line 1074
  dev = (struct drm_device *)tmp___7;
#line 1075
  tmp___8 = vmw_priv(dev);
#line 1075
  dev_priv = tmp___8;
#line 1081
  __cil_tmp15 = (unsigned long )dev_priv;
#line 1081
  __cil_tmp16 = __cil_tmp15 + 134656;
#line 1081
  *((bool *)__cil_tmp16) = (bool )1;
  }
  {
#line 1082
  __cil_tmp17 = (unsigned long )dev_priv;
#line 1082
  __cil_tmp18 = __cil_tmp17 + 134378;
#line 1082
  if (*((bool *)__cil_tmp18)) {
    {
#line 1083
    __cil_tmp19 = (bool )1;
#line 1083
    vmw_3d_resource_dec(dev_priv, __cil_tmp19);
    }
  } else {

  }
  }
  {
#line 1085
  __cil_tmp20 = (unsigned long )dev_priv;
#line 1085
  __cil_tmp21 = __cil_tmp20 + 134736;
#line 1085
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 1085
  if (__cil_tmp22 != 0U) {
    {
#line 1087
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
    }
    {
#line 1090
    __cil_tmp23 = (unsigned long )dev_priv;
#line 1090
    __cil_tmp24 = __cil_tmp23 + 134378;
#line 1090
    if (*((bool *)__cil_tmp24)) {
      {
#line 1091
      __cil_tmp25 = (bool )1;
#line 1091
      vmw_3d_resource_inc(dev_priv, __cil_tmp25);
      }
    } else {

    }
    }
#line 1092
    __cil_tmp26 = (unsigned long )dev_priv;
#line 1092
    __cil_tmp27 = __cil_tmp26 + 134656;
#line 1092
    *((bool *)__cil_tmp27) = (bool )0;
#line 1093
    return (-16);
  } else {

  }
  }
#line 1096
  return (0);
}
}
#line 1099 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmw_pm_complete(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device    *__mptr ;
  struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct pci_dev *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct device *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  bool __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;

  {
  {
#line 1101
  __mptr = (struct device    *)kdev;
#line 1101
  __cil_tmp8 = (struct pci_dev *)0;
#line 1101
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 1101
  __cil_tmp10 = __cil_tmp9 + 144;
#line 1101
  __cil_tmp11 = (struct device *)__cil_tmp10;
#line 1101
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 1101
  __cil_tmp13 = (char *)__mptr;
#line 1101
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 1101
  pdev = (struct pci_dev *)__cil_tmp14;
#line 1102
  tmp___7 = pci_get_drvdata(pdev);
#line 1102
  dev = (struct drm_device *)tmp___7;
#line 1103
  tmp___8 = vmw_priv(dev);
#line 1103
  dev_priv = tmp___8;
  }
  {
#line 1109
  __cil_tmp15 = (unsigned long )dev_priv;
#line 1109
  __cil_tmp16 = __cil_tmp15 + 134378;
#line 1109
  if (*((bool *)__cil_tmp16)) {
    {
#line 1110
    __cil_tmp17 = (bool )0;
#line 1110
    vmw_3d_resource_inc(dev_priv, __cil_tmp17);
    }
  } else {

  }
  }
#line 1112
  __cil_tmp18 = (unsigned long )dev_priv;
#line 1112
  __cil_tmp19 = __cil_tmp18 + 134656;
#line 1112
  *((bool *)__cil_tmp19) = (bool )0;
#line 1113
  return;
}
}
#line 1115 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct dev_pm_ops    vmw_pm_ops  = 
#line 1115
     {& vmw_pm_prepare, & vmw_pm_complete, & vmw_pm_suspend, & vmw_pm_resume, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0};
#line 1122 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct file_operations    vmwgfx_driver_fops  = 
#line 1122
     {& __this_module, & noop_llseek, & vmw_fops_read, (ssize_t (*)(struct file * ,
                                                                  char    * ,
                                                                  size_t  , loff_t * ))0,
    (ssize_t (*)(struct kiocb * , struct iovec    * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec    * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char    * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, & vmw_fops_poll,
    & vmw_unlocked_ioctl, & drm_compat_ioctl, & vmw_mmap, & drm_open, (int (*)(struct file * ,
                                                                               fl_owner_t id ))0,
    & drm_release, (int (*)(struct file * , loff_t  , loff_t  , int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, & drm_fasync, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (long (*)(struct file *file ,
                                                                        int mode ,
                                                                        loff_t offset ,
                                                                        loff_t len ))0};
#line 1137 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct drm_driver driver  = 
#line 1137
     {& vmw_driver_load, & vmw_firstopen, & vmw_driver_open, & vmw_preclose, & vmw_postclose,
    & vmw_lastclose, & vmw_driver_unload, (int (*)(struct drm_device * , pm_message_t state ))0,
    (int (*)(struct drm_device * ))0, (int (*)(struct drm_device *dev , void *data ,
                                               struct drm_file *file_priv ))0, (int (*)(struct drm_device * ))((void *)0),
    (int (*)(struct drm_device *dev , int context ))0, & vmw_get_vblank_counter, & vmw_enable_vblank,
    & vmw_disable_vblank, (int (*)(struct drm_device *dev ))0, (int (*)(struct drm_device *dev ,
                                                                        int crtc ,
                                                                        int *vpos ,
                                                                        int *hpos ))0,
    (int (*)(struct drm_device *dev , int crtc , int *max_error , struct timeval *vblank_time ,
             unsigned int flags ))0, & vmw_irq_handler, & vmw_irq_preinstall, & vmw_irq_postinstall,
    & vmw_irq_uninstall, (void (*)(struct drm_device *dev , struct drm_file *file_priv ))0,
    (void (*)(struct drm_device *dev , struct drm_file *file_priv ))((void *)0), (void (*)(struct drm_device *dev ,
                                                                                           struct drm_file *file_priv ))0,
    (void (*)(struct drm_device *dev , struct drm_set_version *sv ))0, & vmw_master_create,
    & vmw_master_destroy, & vmw_master_set, & vmw_master_drop, (int (*)(struct drm_minor *minor ))0,
    (void (*)(struct drm_minor *minor ))0, (int (*)(struct drm_gem_object *obj ))0,
    (void (*)(struct drm_gem_object *obj ))0, (int (*)(struct drm_gem_object * , struct drm_file * ))0,
    (void (*)(struct drm_gem_object * , struct drm_file * ))0, (int (*)(struct drm_device *dev ,
                                                                        struct drm_file *file_priv ,
                                                                        uint32_t handle ,
                                                                        uint32_t flags ,
                                                                        int *prime_fd ))0,
    (int (*)(struct drm_device *dev , struct drm_file *file_priv , int prime_fd ,
             uint32_t *handle ))0, (struct dma_buf *(*)(struct drm_device *dev , struct drm_gem_object *obj ,
                                                        int flags ))0, (struct drm_gem_object *(*)(struct drm_device *dev ,
                                                                                                   struct dma_buf *dma_buf ))0,
    (void (*)(struct drm_device *dev , bool state ))0, (int (*)(struct drm_file *file_priv ,
                                                                struct drm_device *dev ,
                                                                struct drm_mode_create_dumb *args ))0,
    (int (*)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
             uint64_t *offset ))0, (int (*)(struct drm_file *file_priv , struct drm_device *dev ,
                                            uint32_t handle ))0, (struct vm_operations_struct *)0,
    2, 4, 0, (char *)"vmwgfx", (char *)"Linux drm driver for VMware graphics devices",
    (char *)"20120209", (u32 )8384, 0, vmw_ioctls, (int )(sizeof(vmw_ioctls) / sizeof(vmw_ioctls[0]) + sizeof(struct __anonstruct_437 )),
    & vmwgfx_driver_fops, {(struct pci_driver *)0}, (struct drm_bus *)0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
#line 1171 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static struct pci_driver vmw_pci_driver  = 
#line 1171
     {{(struct list_head *)0, (struct list_head *)0}, "vmwgfx", (struct pci_device_id    *)(vmw_pci_id_list),
    & vmw_probe, & vmw_remove, (int (*)(struct pci_dev *dev , pm_message_t state ))0,
    (int (*)(struct pci_dev *dev , pm_message_t state ))0, (int (*)(struct pci_dev *dev ))0,
    (int (*)(struct pci_dev *dev ))0, (void (*)(struct pci_dev *dev ))0, (struct pci_error_handlers *)0,
    {(char    *)0, (struct bus_type *)0, (struct module *)0, (char    *)0,
     (_Bool)0, (struct of_device_id    *)0, (int (*)(struct device *dev ))0,
     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                 pm_message_t state ))0,
     (int (*)(struct device *dev ))0, (struct attribute_group    **)0, & vmw_pm_ops,
     (struct driver_private *)0}, {{{{{{0U}}, 0U, 0U, (void *)0}}}, {(struct list_head *)0,
                                                                     (struct list_head *)0}}};
#line 1181 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id    *ent ) 
{ int tmp___7 ;

  {
  {
#line 1183
  tmp___7 = drm_get_pci_dev(pdev, ent, & driver);
  }
#line 1183
  return (tmp___7);
}
}
#line 1186
static int vmwgfx_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 1186 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int vmwgfx_init(void) 
{ int ret ;

  {
  {
#line 1189
  ret = drm_pci_init(& driver, & vmw_pci_driver);
  }
#line 1190
  if (ret) {
    {
#line 1191
    drm_err("vmwgfx_init", "Failed initializing DRM.\n");
    }
  } else {

  }
#line 1192
  return (ret);
}
}
#line 1195
static void vmwgfx_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
#line 1195 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static void vmwgfx_exit(void) 
{ 

  {
  {
#line 1197
  drm_pci_exit(& driver, & vmw_pci_driver);
  }
#line 1198
  return;
}
}
#line 1200 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
int init_module(void) 
{ int tmp___7 ;

  {
  {
#line 1200
  tmp___7 = vmwgfx_init();
  }
#line 1200
  return (tmp___7);
}
}
#line 1201 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
void cleanup_module(void) 
{ 

  {
  {
#line 1201
  vmwgfx_exit();
  }
#line 1201
  return;
}
}
#line 1203 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_author1203[30]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 1203
  {      (char    )'a',      (char    )'u',      (char const   )'t',      (char const   )'h', 
        (char    )'o',      (char    )'r',      (char const   )'=',      (char const   )'V', 
        (char    )'M',      (char    )'w',      (char const   )'a',      (char const   )'r', 
        (char    )'e',      (char    )' ',      (char const   )'I',      (char const   )'n', 
        (char    )'c',      (char    )'.',      (char const   )' ',      (char const   )'a', 
        (char    )'n',      (char    )'d',      (char const   )' ',      (char const   )'o', 
        (char    )'t',      (char    )'h',      (char const   )'e',      (char const   )'r', 
        (char    )'s',      (char    )'\000'};
#line 1204 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_description1204[61]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 1204
  {      (char    )'d',      (char    )'e',      (char const   )'s',      (char const   )'c', 
        (char    )'r',      (char    )'i',      (char const   )'p',      (char const   )'t', 
        (char    )'i',      (char    )'o',      (char const   )'n',      (char const   )'=', 
        (char    )'S',      (char    )'t',      (char const   )'a',      (char const   )'n', 
        (char    )'d',      (char    )'a',      (char const   )'l',      (char const   )'o', 
        (char    )'n',      (char    )'e',      (char const   )' ',      (char const   )'d', 
        (char    )'r',      (char    )'m',      (char const   )' ',      (char const   )'d', 
        (char    )'r',      (char    )'i',      (char const   )'v',      (char const   )'e', 
        (char    )'r',      (char    )' ',      (char const   )'f',      (char const   )'o', 
        (char    )'r',      (char    )' ',      (char const   )'t',      (char const   )'h', 
        (char    )'e',      (char    )' ',      (char const   )'V',      (char const   )'M', 
        (char    )'w',      (char    )'a',      (char const   )'r',      (char const   )'e', 
        (char    )' ',      (char    )'S',      (char const   )'V',      (char const   )'G', 
        (char    )'A',      (char    )' ',      (char const   )'d',      (char const   )'e', 
        (char    )'v',      (char    )'i',      (char const   )'c',      (char const   )'e', 
        (char    )'\000'};
#line 1205 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_license1205[34]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 1205
  {      (char    )'l',      (char    )'i',      (char const   )'c',      (char const   )'e', 
        (char    )'n',      (char    )'s',      (char const   )'e',      (char const   )'=', 
        (char    )'G',      (char    )'P',      (char const   )'L',      (char const   )' ', 
        (char    )'a',      (char    )'n',      (char const   )'d',      (char const   )' ', 
        (char    )'a',      (char    )'d',      (char const   )'d',      (char const   )'i', 
        (char    )'t',      (char    )'i',      (char const   )'o',      (char const   )'n', 
        (char    )'a',      (char    )'l',      (char const   )' ',      (char const   )'r', 
        (char    )'i',      (char    )'g',      (char const   )'h',      (char const   )'t', 
        (char    )'s',      (char    )'\000'};
#line 1206 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static char    __mod_version1209[16]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 1206
  {      (char    )'v',      (char    )'e',      (char const   )'r',      (char const   )'s', 
        (char    )'i',      (char    )'o',      (char const   )'n',      (char const   )'=', 
        (char    )'2',      (char    )'.',      (char const   )'4',      (char const   )'.', 
        (char    )'0',      (char    )'.',      (char const   )'0',      (char const   )'\000'};
#line 1230
extern void ldv_check_return_value(int res ) ;
#line 2362 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int res_vmw_driver_open_12  ;
#line 2606 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
static int res_vmw_probe_29  ;
#line 1242 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"
void main(void) 
{ struct device *var_group1 ;
  struct file *var_group2 ;
  unsigned int var_vmw_unlocked_ioctl_13_p1 ;
  unsigned long var_vmw_unlocked_ioctl_13_p2 ;
  struct drm_device *var_group3 ;
  unsigned long var_vmw_driver_load_8_p1 ;
  struct drm_master *var_group4 ;
  struct drm_file *var_group5 ;
  bool var_vmw_master_set_19_p2 ;
  bool var_vmw_master_drop_20_p2 ;
  struct pci_dev *var_group6 ;
  struct pci_device_id    *var_vmw_probe_29_p1 ;
  int tmp___7 ;
  int ldv_s_driver_drm_driver ;
  int ldv_s_vmw_pci_driver_pci_driver ;
  int tmp___8 ;
  int tmp___9 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 2692
  LDV_IN_INTERRUPT = 1;
#line 2701
  ldv_initialize();
#line 2781
  tmp___7 = vmwgfx_init();
  }
#line 2781
  if (tmp___7) {
#line 2782
    goto ldv_final;
  } else {

  }
#line 2787
  ldv_s_driver_drm_driver = 0;
#line 2790
  ldv_s_vmw_pci_driver_pci_driver = 0;
  {
#line 2794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2794
    tmp___9 = __VERIFIER_nondet_int();
    }
#line 2794
    if (tmp___9) {

    } else {
      {
#line 2794
      __cil_tmp18 = ldv_s_driver_drm_driver == 0;
#line 2794
      if (! __cil_tmp18) {

      } else {
        {
#line 2794
        __cil_tmp19 = ldv_s_vmw_pci_driver_pci_driver == 0;
#line 2794
        if (! __cil_tmp19) {

        } else {
#line 2794
          goto while_break;
        }
        }
      }
      }
    }
    {
#line 2799
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 2801
    if (tmp___8 == 0) {
#line 2801
      goto case_0;
    } else
#line 2893
    if (tmp___8 == 1) {
#line 2893
      goto case_1;
    } else
#line 2985
    if (tmp___8 == 2) {
#line 2985
      goto case_2;
    } else
#line 3077
    if (tmp___8 == 3) {
#line 3077
      goto case_3;
    } else
#line 3169
    if (tmp___8 == 4) {
#line 3169
      goto case_4;
    } else
#line 3261
    if (tmp___8 == 5) {
#line 3261
      goto case_5;
    } else
#line 3356
    if (tmp___8 == 6) {
#line 3356
      goto case_6;
    } else
#line 3448
    if (tmp___8 == 7) {
#line 3448
      goto case_7;
    } else
#line 3540
    if (tmp___8 == 8) {
#line 3540
      goto case_8;
    } else
#line 3632
    if (tmp___8 == 9) {
#line 3632
      goto case_9;
    } else
#line 3724
    if (tmp___8 == 10) {
#line 3724
      goto case_10;
    } else
#line 3816
    if (tmp___8 == 11) {
#line 3816
      goto case_11;
    } else
#line 3908
    if (tmp___8 == 12) {
#line 3908
      goto case_12;
    } else
#line 4000
    if (tmp___8 == 13) {
#line 4000
      goto case_13;
    } else
#line 4092
    if (tmp___8 == 14) {
#line 4092
      goto case_14;
    } else
#line 4184
    if (tmp___8 == 15) {
#line 4184
      goto case_15;
    } else
#line 4276
    if (tmp___8 == 16) {
#line 4276
      goto case_16;
    } else
#line 4369
    if (tmp___8 == 17) {
#line 4369
      goto case_17;
    } else {
      {
#line 4461
      goto switch_default;
#line 2799
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 2881
        vmw_pm_prepare(var_group1);
        }
#line 2892
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 2973
        vmw_pm_complete(var_group1);
        }
#line 2984
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 3065
        vmw_pm_suspend(var_group1);
        }
#line 3076
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 3157
        vmw_pm_resume(var_group1);
        }
#line 3168
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 3249
        vmw_unlocked_ioctl(var_group2, var_vmw_unlocked_ioctl_13_p1, var_vmw_unlocked_ioctl_13_p2);
        }
#line 3260
        goto switch_break;
        case_5: /* CIL Label */ 
#line 3264
        if (ldv_s_driver_drm_driver == 0) {
          {
#line 3341
          res_vmw_driver_open_12 = vmw_driver_open(var_group3, var_group5);
#line 3342
          ldv_check_return_value(res_vmw_driver_open_12);
          }
#line 3343
          if (res_vmw_driver_open_12) {
#line 3344
            goto ldv_module_exit;
          } else {

          }
#line 3349
          ldv_s_driver_drm_driver = 0;
        } else {

        }
#line 3355
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 3436
        vmw_driver_load(var_group3, var_vmw_driver_load_8_p1);
        }
#line 3447
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 3528
        vmw_driver_unload(var_group3);
        }
#line 3539
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 3620
        vmw_firstopen(var_group3);
        }
#line 3631
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 3712
        vmw_lastclose(var_group3);
        }
#line 3723
        goto switch_break;
        case_10: /* CIL Label */ 
        {
#line 3804
        vmw_master_create(var_group3, var_group4);
        }
#line 3815
        goto switch_break;
        case_11: /* CIL Label */ 
        {
#line 3896
        vmw_master_destroy(var_group3, var_group4);
        }
#line 3907
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 3988
        vmw_master_set(var_group3, var_group5, var_vmw_master_set_19_p2);
        }
#line 3999
        goto switch_break;
        case_13: /* CIL Label */ 
        {
#line 4080
        vmw_master_drop(var_group3, var_group5, var_vmw_master_drop_20_p2);
        }
#line 4091
        goto switch_break;
        case_14: /* CIL Label */ 
        {
#line 4172
        vmw_preclose(var_group3, var_group5);
        }
#line 4183
        goto switch_break;
        case_15: /* CIL Label */ 
        {
#line 4264
        vmw_postclose(var_group3, var_group5);
        }
#line 4275
        goto switch_break;
        case_16: /* CIL Label */ 
#line 4279
        if (ldv_s_vmw_pci_driver_pci_driver == 0) {
          {
#line 4358
          res_vmw_probe_29 = vmw_probe(var_group6, var_vmw_probe_29_p1);
#line 4359
          ldv_check_return_value(res_vmw_probe_29);
          }
#line 4360
          if (res_vmw_probe_29) {
#line 4361
            goto ldv_module_exit;
          } else {

          }
#line 4362
          ldv_s_vmw_pci_driver_pci_driver = 0;
        } else {

        }
#line 4368
        goto switch_break;
        case_17: /* CIL Label */ 
        {
#line 4449
        vmw_remove(var_group6);
        }
#line 4460
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 4461
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  ldv_module_exit: 
  {
#line 4547
  vmwgfx_exit();
  }
  ldv_final: 
  {
#line 4550
  ldv_check_final_state();
  }
#line 4553
  return;
}
}
#line 62 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/string_64.h"
extern char *strcpy(char *dest , char    *src ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t *lock , char    *name , struct lock_class_key *key ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 42
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return ((struct raw_spinlock *)lock);
}
}
#line 338
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ struct raw_spinlock *__cil_tmp5 ;

  {
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    __cil_tmp5 = (struct raw_spinlock *)lock;
#line 340
    _raw_spin_unlock_irqrestore(__cil_tmp5, flags);
    }
#line 340
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return;
}
}
#line 382 "include/linux/workqueue.h"
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
#line 395
extern bool flush_delayed_work_sync(struct delayed_work *work ) ;
#line 898 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num )  __attribute__((__no_instrument_function__)) ;
#line 898 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ struct apertures_struct *a ;
  void *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 899
  __cil_tmp4 = (unsigned long )max_num;
#line 899
  __cil_tmp5 = __cil_tmp4 * 16UL;
#line 899
  __cil_tmp6 = 8UL + __cil_tmp5;
#line 899
  tmp___7 = kzalloc(__cil_tmp6, 208U);
#line 899
  a = (struct apertures_struct *)tmp___7;
  }
#line 901
  if (! a) {
    {
#line 902
    __cil_tmp7 = (void *)0;
#line 902
    return ((struct apertures_struct *)__cil_tmp7);
    }
  } else {

  }
#line 903
  *((unsigned int *)a) = max_num;
#line 904
  return (a);
}
}
#line 988
extern void cfb_fillrect(struct fb_info *info , struct fb_fillrect    *rect ) ;
#line 989
extern void cfb_copyarea(struct fb_info *info , struct fb_copyarea    *area ) ;
#line 990
extern void cfb_imageblit(struct fb_info *info , struct fb_image    *image ) ;
#line 1003
extern int register_framebuffer(struct fb_info *fb_info ) ;
#line 1004
extern int unregister_framebuffer(struct fb_info *fb_info ) ;
#line 1047
extern void fb_deferred_io_init(struct fb_info *info ) ;
#line 1051
extern void fb_deferred_io_cleanup(struct fb_info *info ) ;
#line 1075
extern struct fb_info *framebuffer_alloc(size_t size , struct device *dev ) ;
#line 1076
extern void framebuffer_release(struct fb_info *info ) ;
#line 134 "include/drm/ttm/ttm_lock.h"
extern void ttm_write_unlock(struct ttm_lock *lock ) ;
#line 146
extern int ttm_write_lock(struct ttm_lock *lock , bool interruptible ) ;
#line 420 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) ;
#line 421
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object *bo ) ) ;
#line 516
struct ttm_placement vmw_vram_ne_placement ;
#line 604
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) ;
#line 656
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) ;
#line 69 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                            unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  u32 *pal ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u32 *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned int __cil_tmp31 ;

  {
#line 73
  __cil_tmp9 = (unsigned long )info;
#line 73
  __cil_tmp10 = __cil_tmp9 + 1160;
#line 73
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 73
  par = (struct vmw_fb_par *)__cil_tmp11;
#line 74
  __cil_tmp12 = 0 * 4UL;
#line 74
  __cil_tmp13 = 56 + __cil_tmp12;
#line 74
  __cil_tmp14 = (unsigned long )par;
#line 74
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
#line 74
  pal = (u32 *)__cil_tmp15;
#line 76
  if (regno > 15U) {
    {
#line 77
    drm_err("vmw_fb_setcolreg", "Bad regno %u.\n", regno);
    }
#line 78
    return (1);
  } else {

  }
  {
#line 81
  __cil_tmp16 = (unsigned long )par;
#line 81
  __cil_tmp17 = __cil_tmp16 + 124;
#line 81
  __cil_tmp18 = *((unsigned int *)__cil_tmp17);
#line 82
  if ((int )__cil_tmp18 == 24) {
#line 82
    goto case_24;
  } else
#line 83
  if ((int )__cil_tmp18 == 32) {
#line 83
    goto case_24;
  } else {
    {
#line 88
    goto switch_default;
#line 81
    if (0) {
      case_24: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 84
      __cil_tmp19 = pal + regno;
#line 84
      __cil_tmp20 = blue & 65280U;
#line 84
      __cil_tmp21 = __cil_tmp20 >> 8;
#line 84
      __cil_tmp22 = green & 65280U;
#line 84
      __cil_tmp23 = red & 65280U;
#line 84
      __cil_tmp24 = __cil_tmp23 << 8;
#line 84
      __cil_tmp25 = __cil_tmp24 | __cil_tmp22;
#line 84
      *__cil_tmp19 = __cil_tmp25 | __cil_tmp21;
#line 87
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 89
      __cil_tmp26 = (unsigned long )par;
#line 89
      __cil_tmp27 = __cil_tmp26 + 124;
#line 89
      __cil_tmp28 = *((unsigned int *)__cil_tmp27);
#line 89
      __cil_tmp29 = (unsigned long )par;
#line 89
      __cil_tmp30 = __cil_tmp29 + 128;
#line 89
      __cil_tmp31 = *((unsigned int *)__cil_tmp30);
#line 89
      drm_err("vmw_fb_setcolreg", "Bad depth %u, bpp %u.\n", __cil_tmp28, __cil_tmp31);
      }
#line 90
      return (1);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  }
#line 93
  return (0);
}
}
#line 96 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_check_var(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ int depth ;
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  bool tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  __u32 __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32 __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  __u32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  __u32 __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  __u32 __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  __u32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  __u32 __cil_tmp79 ;
  __u32 __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  __u32 __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  __u32 __cil_tmp89 ;
  __u32 __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  __u32 __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  __u32 __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  __u32 __cil_tmp100 ;
  __u32 __cil_tmp101 ;

  {
#line 99
  __cil_tmp7 = (unsigned long )var;
#line 99
  __cil_tmp8 = __cil_tmp7 + 24;
#line 99
  __cil_tmp9 = *((__u32 *)__cil_tmp8);
#line 99
  depth = (int )__cil_tmp9;
#line 100
  __cil_tmp10 = (unsigned long )info;
#line 100
  __cil_tmp11 = __cil_tmp10 + 1160;
#line 100
  __cil_tmp12 = *((void **)__cil_tmp11);
#line 100
  par = (struct vmw_fb_par *)__cil_tmp12;
#line 101
  vmw_priv___0 = *((struct vmw_private **)par);
  {
#line 103
  __cil_tmp13 = (unsigned long )var;
#line 103
  __cil_tmp14 = __cil_tmp13 + 24;
#line 103
  __cil_tmp15 = *((__u32 *)__cil_tmp14);
#line 104
  if ((int )__cil_tmp15 == 32) {
#line 104
    goto case_32;
  } else {
    {
#line 107
    goto switch_default;
#line 103
    if (0) {
      case_32: /* CIL Label */ 
      {
#line 105
      __cil_tmp16 = 68 + 4;
#line 105
      __cil_tmp17 = (unsigned long )var;
#line 105
      __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 105
      __cil_tmp19 = *((__u32 *)__cil_tmp18);
#line 105
      if (__cil_tmp19 > 0U) {
#line 105
        depth = 32;
      } else {
#line 105
        depth = 24;
      }
      }
#line 106
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      __cil_tmp20 = (unsigned long )var;
#line 108
      __cil_tmp21 = __cil_tmp20 + 24;
#line 108
      __cil_tmp22 = *((__u32 *)__cil_tmp21);
#line 108
      drm_err("vmw_fb_check_var", "Bad bpp %u.\n", __cil_tmp22);
      }
#line 109
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  }
#line 113
  if (depth == 24) {
#line 113
    goto case_24;
  } else
#line 123
  if (depth == 32) {
#line 123
    goto case_32___0;
  } else {
    {
#line 133
    goto switch_default___0;
#line 112
    if (0) {
      case_24: /* CIL Label */ 
#line 114
      __cil_tmp23 = (unsigned long )var;
#line 114
      __cil_tmp24 = __cil_tmp23 + 32;
#line 114
      *((__u32 *)__cil_tmp24) = (__u32 )16;
#line 115
      __cil_tmp25 = (unsigned long )var;
#line 115
      __cil_tmp26 = __cil_tmp25 + 44;
#line 115
      *((__u32 *)__cil_tmp26) = (__u32 )8;
#line 116
      __cil_tmp27 = (unsigned long )var;
#line 116
      __cil_tmp28 = __cil_tmp27 + 56;
#line 116
      *((__u32 *)__cil_tmp28) = (__u32 )0;
#line 117
      __cil_tmp29 = 32 + 4;
#line 117
      __cil_tmp30 = (unsigned long )var;
#line 117
      __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 117
      *((__u32 *)__cil_tmp31) = (__u32 )8;
#line 118
      __cil_tmp32 = 44 + 4;
#line 118
      __cil_tmp33 = (unsigned long )var;
#line 118
      __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 118
      *((__u32 *)__cil_tmp34) = (__u32 )8;
#line 119
      __cil_tmp35 = 56 + 4;
#line 119
      __cil_tmp36 = (unsigned long )var;
#line 119
      __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
#line 119
      *((__u32 *)__cil_tmp37) = (__u32 )8;
#line 120
      __cil_tmp38 = 68 + 4;
#line 120
      __cil_tmp39 = (unsigned long )var;
#line 120
      __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 120
      *((__u32 *)__cil_tmp40) = (__u32 )0;
#line 121
      __cil_tmp41 = (unsigned long )var;
#line 121
      __cil_tmp42 = __cil_tmp41 + 68;
#line 121
      *((__u32 *)__cil_tmp42) = (__u32 )0;
#line 122
      goto switch_break___0;
      case_32___0: /* CIL Label */ 
#line 124
      __cil_tmp43 = (unsigned long )var;
#line 124
      __cil_tmp44 = __cil_tmp43 + 32;
#line 124
      *((__u32 *)__cil_tmp44) = (__u32 )16;
#line 125
      __cil_tmp45 = (unsigned long )var;
#line 125
      __cil_tmp46 = __cil_tmp45 + 44;
#line 125
      *((__u32 *)__cil_tmp46) = (__u32 )8;
#line 126
      __cil_tmp47 = (unsigned long )var;
#line 126
      __cil_tmp48 = __cil_tmp47 + 56;
#line 126
      *((__u32 *)__cil_tmp48) = (__u32 )0;
#line 127
      __cil_tmp49 = 32 + 4;
#line 127
      __cil_tmp50 = (unsigned long )var;
#line 127
      __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
#line 127
      *((__u32 *)__cil_tmp51) = (__u32 )8;
#line 128
      __cil_tmp52 = 44 + 4;
#line 128
      __cil_tmp53 = (unsigned long )var;
#line 128
      __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
#line 128
      *((__u32 *)__cil_tmp54) = (__u32 )8;
#line 129
      __cil_tmp55 = 56 + 4;
#line 129
      __cil_tmp56 = (unsigned long )var;
#line 129
      __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
#line 129
      *((__u32 *)__cil_tmp57) = (__u32 )8;
#line 130
      __cil_tmp58 = 68 + 4;
#line 130
      __cil_tmp59 = (unsigned long )var;
#line 130
      __cil_tmp60 = __cil_tmp59 + __cil_tmp58;
#line 130
      *((__u32 *)__cil_tmp60) = (__u32 )8;
#line 131
      __cil_tmp61 = (unsigned long )var;
#line 131
      __cil_tmp62 = __cil_tmp61 + 68;
#line 131
      *((__u32 *)__cil_tmp62) = (__u32 )24;
#line 132
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 134
      drm_err("vmw_fb_check_var", "Bad depth %u.\n", depth);
      }
#line 135
      return (-22);
    } else {
      switch_break___0: /* CIL Label */ ;
    }
    }
  }
  {
#line 138
  __cil_tmp63 = (unsigned long )vmw_priv___0;
#line 138
  __cil_tmp64 = __cil_tmp63 + 2156;
#line 138
  __cil_tmp65 = *((uint32_t *)__cil_tmp64);
#line 138
  __cil_tmp66 = __cil_tmp65 & 524288U;
#line 138
  if (! __cil_tmp66) {
    {
#line 138
    __cil_tmp67 = (unsigned long )var;
#line 138
    __cil_tmp68 = __cil_tmp67 + 16;
#line 138
    __cil_tmp69 = *((__u32 *)__cil_tmp68);
#line 138
    if (__cil_tmp69 != 0U) {
      {
#line 140
      drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
      }
#line 141
      return (-22);
    } else {
      {
#line 138
      __cil_tmp70 = (unsigned long )var;
#line 138
      __cil_tmp71 = __cil_tmp70 + 20;
#line 138
      __cil_tmp72 = *((__u32 *)__cil_tmp71);
#line 138
      if (__cil_tmp72 != 0U) {
        {
#line 140
        drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
        }
#line 141
        return (-22);
      } else {

      }
      }
    }
    }
  } else {

  }
  }
  {
#line 144
  __cil_tmp73 = (unsigned long )par;
#line 144
  __cil_tmp74 = __cil_tmp73 + 132;
#line 144
  __cil_tmp75 = *((unsigned int *)__cil_tmp74);
#line 144
  __cil_tmp76 = *((__u32 *)var);
#line 144
  __cil_tmp77 = (unsigned long )var;
#line 144
  __cil_tmp78 = __cil_tmp77 + 16;
#line 144
  __cil_tmp79 = *((__u32 *)__cil_tmp78);
#line 144
  __cil_tmp80 = __cil_tmp79 + __cil_tmp76;
#line 144
  if (__cil_tmp80 > __cil_tmp75) {
    {
#line 146
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
    }
#line 147
    return (-22);
  } else {
    {
#line 144
    __cil_tmp81 = (unsigned long )par;
#line 144
    __cil_tmp82 = __cil_tmp81 + 136;
#line 144
    __cil_tmp83 = *((unsigned int *)__cil_tmp82);
#line 144
    __cil_tmp84 = (unsigned long )var;
#line 144
    __cil_tmp85 = __cil_tmp84 + 4;
#line 144
    __cil_tmp86 = *((__u32 *)__cil_tmp85);
#line 144
    __cil_tmp87 = (unsigned long )var;
#line 144
    __cil_tmp88 = __cil_tmp87 + 20;
#line 144
    __cil_tmp89 = *((__u32 *)__cil_tmp88);
#line 144
    __cil_tmp90 = __cil_tmp89 + __cil_tmp86;
#line 144
    if (__cil_tmp90 > __cil_tmp83) {
      {
#line 146
      drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
      }
#line 147
      return (-22);
    } else {

    }
    }
  }
  }
  {
#line 150
  __cil_tmp91 = 320 + 48;
#line 150
  __cil_tmp92 = (unsigned long )info;
#line 150
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
#line 150
  __cil_tmp94 = *((__u32 *)__cil_tmp93);
#line 150
  __cil_tmp95 = (unsigned long )var;
#line 150
  __cil_tmp96 = __cil_tmp95 + 4;
#line 150
  __cil_tmp97 = *((__u32 *)__cil_tmp96);
#line 150
  __cil_tmp98 = (unsigned long )var;
#line 150
  __cil_tmp99 = __cil_tmp98 + 20;
#line 150
  __cil_tmp100 = *((__u32 *)__cil_tmp99);
#line 150
  __cil_tmp101 = __cil_tmp100 + __cil_tmp97;
#line 150
  tmp___7 = vmw_kms_validate_mode_vram(vmw_priv___0, __cil_tmp94, __cil_tmp101);
  }
#line 150
  if (tmp___7) {

  } else {
    {
#line 153
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
    }
#line 154
    return (-22);
  }
#line 157
  return (0);
}
}
#line 160 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_set_par(struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  int ret ;
  int __ret_warn_on ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  __u32 __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  __u32 __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  __u32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  __u32 __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  __u32 __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32 __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  __u32 __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  long __cil_tmp52 ;
  int    __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;

  {
  {
#line 162
  __cil_tmp9 = (unsigned long )info;
#line 162
  __cil_tmp10 = __cil_tmp9 + 1160;
#line 162
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 162
  par = (struct vmw_fb_par *)__cil_tmp11;
#line 163
  vmw_priv___0 = *((struct vmw_private **)par);
#line 166
  __cil_tmp12 = (unsigned long )info;
#line 166
  __cil_tmp13 = __cil_tmp12 + 160;
#line 166
  __cil_tmp14 = *((__u32 *)__cil_tmp13);
#line 166
  __cil_tmp15 = 160 + 4;
#line 166
  __cil_tmp16 = (unsigned long )info;
#line 166
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 166
  __cil_tmp18 = *((__u32 *)__cil_tmp17);
#line 166
  __cil_tmp19 = 320 + 48;
#line 166
  __cil_tmp20 = (unsigned long )info;
#line 166
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 166
  __cil_tmp22 = *((__u32 *)__cil_tmp21);
#line 166
  __cil_tmp23 = (unsigned long )par;
#line 166
  __cil_tmp24 = __cil_tmp23 + 128;
#line 166
  __cil_tmp25 = *((unsigned int *)__cil_tmp24);
#line 166
  __cil_tmp26 = (unsigned long )par;
#line 166
  __cil_tmp27 = __cil_tmp26 + 124;
#line 166
  __cil_tmp28 = *((unsigned int *)__cil_tmp27);
#line 166
  ret = vmw_kms_write_svga(vmw_priv___0, __cil_tmp14, __cil_tmp18, __cil_tmp22, __cil_tmp25,
                           __cil_tmp28);
  }
#line 169
  if (ret) {
#line 170
    return (ret);
  } else {

  }
  {
#line 172
  __cil_tmp29 = (unsigned long )vmw_priv___0;
#line 172
  __cil_tmp30 = __cil_tmp29 + 2156;
#line 172
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
#line 172
  if (__cil_tmp31 & 524288U) {
    {
#line 174
    __cil_tmp32 = (uint32_t )1;
#line 174
    vmw_write(vmw_priv___0, 34U, __cil_tmp32);
#line 175
    __cil_tmp33 = (uint32_t )0;
#line 175
    vmw_write(vmw_priv___0, 35U, __cil_tmp33);
#line 176
    __cil_tmp34 = (uint32_t )1;
#line 176
    vmw_write(vmw_priv___0, 36U, __cil_tmp34);
#line 177
    __cil_tmp35 = 160 + 16;
#line 177
    __cil_tmp36 = (unsigned long )info;
#line 177
    __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
#line 177
    __cil_tmp38 = *((__u32 *)__cil_tmp37);
#line 177
    vmw_write(vmw_priv___0, 37U, __cil_tmp38);
#line 178
    __cil_tmp39 = 160 + 20;
#line 178
    __cil_tmp40 = (unsigned long )info;
#line 178
    __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 178
    __cil_tmp42 = *((__u32 *)__cil_tmp41);
#line 178
    vmw_write(vmw_priv___0, 38U, __cil_tmp42);
#line 179
    __cil_tmp43 = (unsigned long )info;
#line 179
    __cil_tmp44 = __cil_tmp43 + 160;
#line 179
    __cil_tmp45 = *((__u32 *)__cil_tmp44);
#line 179
    vmw_write(vmw_priv___0, 39U, __cil_tmp45);
#line 180
    __cil_tmp46 = 160 + 4;
#line 180
    __cil_tmp47 = (unsigned long )info;
#line 180
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 180
    __cil_tmp49 = *((__u32 *)__cil_tmp48);
#line 180
    vmw_write(vmw_priv___0, 40U, __cil_tmp49);
#line 181
    vmw_write(vmw_priv___0, 35U, 4294967295U);
    }
  } else {

  }
  }
  {
#line 187
  tmp___7 = vmw_read(vmw_priv___0, 14U);
  }
#line 187
  if (tmp___7 != 0U) {
#line 187
    tmp___8 = 1;
  } else {
#line 187
    tmp___8 = 0;
  }
  {
#line 187
  __ret_warn_on = tmp___8;
#line 187
  __cil_tmp50 = ! __ret_warn_on;
#line 187
  __cil_tmp51 = ! __cil_tmp50;
#line 187
  __cil_tmp52 = (long )__cil_tmp51;
#line 187
  tmp___9 = ldv__builtin_expect(__cil_tmp52, 0L);
  }
#line 187
  if (tmp___9) {
    {
#line 187
    __cil_tmp53 = (int    )187;
#line 187
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c",
                       __cil_tmp53);
    }
  } else {

  }
  {
#line 187
  __cil_tmp54 = ! __ret_warn_on;
#line 187
  __cil_tmp55 = ! __cil_tmp54;
#line 187
  __cil_tmp56 = (long )__cil_tmp55;
#line 187
  ldv__builtin_expect(__cil_tmp56, 0L);
  }
#line 189
  return (0);
}
}
#line 192 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_pan_display(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 

  {
#line 195
  return (0);
}
}
#line 198 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_blank(int blank , struct fb_info *info ) 
{ 

  {
#line 200
  return (0);
}
}
#line 207 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_fb_dirty_flush(struct vmw_fb_par *par ) 
{ struct vmw_private *vmw_priv___0 ;
  struct fb_info *info ;
  int stride ;
  int *src ;
  __le32 *vram_mem ;
  unsigned long flags ;
  unsigned int x ;
  unsigned int y ;
  unsigned int w ;
  unsigned int h ;
  int i ;
  int k ;
  struct __anonstruct_cmd_430___0 *cmd ;
  raw_spinlock_t *tmp___7 ;
  unsigned int _min1 ;
  __u32 _min2 ;
  unsigned int tmp___8 ;
  unsigned int _min1___0 ;
  __u32 _min2___0 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  __u32 __cil_tmp34 ;
  __u32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  char *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  spinlock_t *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  bool __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  spinlock_t *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned int *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  __u32 *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  __u32 *__cil_tmp67 ;
  __u32 __cil_tmp68 ;
  unsigned int *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int *__cil_tmp71 ;
  __u32 *__cil_tmp72 ;
  unsigned int *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  __u32 *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  __u32 *__cil_tmp81 ;
  __u32 __cil_tmp82 ;
  unsigned int *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int *__cil_tmp85 ;
  __u32 *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  spinlock_t *__cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  unsigned int __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  __u32 __cil_tmp107 ;
  __u32 __cil_tmp108 ;
  __u32 __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  __u32 __cil_tmp119 ;
  __u32 __cil_tmp120 ;
  __u32 __cil_tmp121 ;
  int *__cil_tmp122 ;
  int __cil_tmp123 ;
  u32 __cil_tmp124 ;
  __le32 *__cil_tmp125 ;
  void *__cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  int __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;

  {
#line 209
  vmw_priv___0 = *((struct vmw_private **)par);
#line 210
  __cil_tmp28 = (unsigned long )vmw_priv___0;
#line 210
  __cil_tmp29 = __cil_tmp28 + 2600;
#line 210
  __cil_tmp30 = *((void **)__cil_tmp29);
#line 210
  info = (struct fb_info *)__cil_tmp30;
#line 211
  __cil_tmp31 = 320 + 48;
#line 211
  __cil_tmp32 = (unsigned long )info;
#line 211
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 211
  __cil_tmp34 = *((__u32 *)__cil_tmp33);
#line 211
  __cil_tmp35 = __cil_tmp34 / 4U;
#line 211
  stride = (int )__cil_tmp35;
#line 212
  __cil_tmp36 = (unsigned long )info;
#line 212
  __cil_tmp37 = __cil_tmp36 + 1120;
#line 212
  __cil_tmp38 = *((char **)__cil_tmp37);
#line 212
  src = (int *)__cil_tmp38;
#line 213
  __cil_tmp39 = (unsigned long )par;
#line 213
  __cil_tmp40 = __cil_tmp39 + 144;
#line 213
  __cil_tmp41 = *((void **)__cil_tmp40);
#line 213
  vram_mem = (__le32 *)__cil_tmp41;
  {
#line 222
  __cil_tmp42 = (unsigned long )vmw_priv___0;
#line 222
  __cil_tmp43 = __cil_tmp42 + 134656;
#line 222
  if (*((bool *)__cil_tmp43)) {
#line 223
    return;
  } else {

  }
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 225
      __cil_tmp44 = (unsigned long )par;
#line 225
      __cil_tmp45 = __cil_tmp44 + 160;
#line 225
      __cil_tmp46 = (spinlock_t *)__cil_tmp45;
#line 225
      tmp___7 = spinlock_check(__cil_tmp46);
#line 225
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 225
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  __cil_tmp47 = 160 + 24;
#line 226
  __cil_tmp48 = (unsigned long )par;
#line 226
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 226
  __cil_tmp50 = *((bool *)__cil_tmp49);
#line 226
  if (! __cil_tmp50) {
    {
#line 227
    __cil_tmp51 = (unsigned long )par;
#line 227
    __cil_tmp52 = __cil_tmp51 + 160;
#line 227
    __cil_tmp53 = (spinlock_t *)__cil_tmp52;
#line 227
    spin_unlock_irqrestore(__cil_tmp53, flags);
    }
#line 228
    return;
  } else {

  }
  }
#line 230
  __cil_tmp54 = 160 + 28;
#line 230
  __cil_tmp55 = (unsigned long )par;
#line 230
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 230
  x = *((unsigned int *)__cil_tmp56);
#line 231
  __cil_tmp57 = 160 + 32;
#line 231
  __cil_tmp58 = (unsigned long )par;
#line 231
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 231
  y = *((unsigned int *)__cil_tmp59);
#line 232
  __cil_tmp60 = & _min1;
#line 232
  __cil_tmp61 = 160 + 36;
#line 232
  __cil_tmp62 = (unsigned long )par;
#line 232
  __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
#line 232
  *__cil_tmp60 = *((unsigned int *)__cil_tmp63);
#line 232
  __cil_tmp64 = & _min2;
#line 232
  __cil_tmp65 = (unsigned long )info;
#line 232
  __cil_tmp66 = __cil_tmp65 + 160;
#line 232
  *__cil_tmp64 = *((__u32 *)__cil_tmp66);
  {
#line 232
  __cil_tmp67 = & _min2;
#line 232
  __cil_tmp68 = *__cil_tmp67;
#line 232
  __cil_tmp69 = & _min1;
#line 232
  __cil_tmp70 = *__cil_tmp69;
#line 232
  if (__cil_tmp70 < __cil_tmp68) {
#line 232
    __cil_tmp71 = & _min1;
#line 232
    tmp___8 = *__cil_tmp71;
  } else {
#line 232
    __cil_tmp72 = & _min2;
#line 232
    tmp___8 = *__cil_tmp72;
  }
  }
#line 232
  w = tmp___8 - x;
#line 233
  __cil_tmp73 = & _min1___0;
#line 233
  __cil_tmp74 = 160 + 40;
#line 233
  __cil_tmp75 = (unsigned long )par;
#line 233
  __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
#line 233
  *__cil_tmp73 = *((unsigned int *)__cil_tmp76);
#line 233
  __cil_tmp77 = & _min2___0;
#line 233
  __cil_tmp78 = 160 + 4;
#line 233
  __cil_tmp79 = (unsigned long )info;
#line 233
  __cil_tmp80 = __cil_tmp79 + __cil_tmp78;
#line 233
  *__cil_tmp77 = *((__u32 *)__cil_tmp80);
  {
#line 233
  __cil_tmp81 = & _min2___0;
#line 233
  __cil_tmp82 = *__cil_tmp81;
#line 233
  __cil_tmp83 = & _min1___0;
#line 233
  __cil_tmp84 = *__cil_tmp83;
#line 233
  if (__cil_tmp84 < __cil_tmp82) {
#line 233
    __cil_tmp85 = & _min1___0;
#line 233
    tmp___9 = *__cil_tmp85;
  } else {
#line 233
    __cil_tmp86 = & _min2___0;
#line 233
    tmp___9 = *__cil_tmp86;
  }
  }
  {
#line 233
  h = tmp___9 - y;
#line 234
  tmp___10 = 0U;
#line 234
  __cil_tmp87 = 160 + 36;
#line 234
  __cil_tmp88 = (unsigned long )par;
#line 234
  __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
#line 234
  *((unsigned int *)__cil_tmp89) = tmp___10;
#line 234
  __cil_tmp90 = 160 + 28;
#line 234
  __cil_tmp91 = (unsigned long )par;
#line 234
  __cil_tmp92 = __cil_tmp91 + __cil_tmp90;
#line 234
  *((unsigned int *)__cil_tmp92) = tmp___10;
#line 235
  tmp___11 = 0U;
#line 235
  __cil_tmp93 = 160 + 40;
#line 235
  __cil_tmp94 = (unsigned long )par;
#line 235
  __cil_tmp95 = __cil_tmp94 + __cil_tmp93;
#line 235
  *((unsigned int *)__cil_tmp95) = tmp___11;
#line 235
  __cil_tmp96 = 160 + 32;
#line 235
  __cil_tmp97 = (unsigned long )par;
#line 235
  __cil_tmp98 = __cil_tmp97 + __cil_tmp96;
#line 235
  *((unsigned int *)__cil_tmp98) = tmp___11;
#line 236
  __cil_tmp99 = (unsigned long )par;
#line 236
  __cil_tmp100 = __cil_tmp99 + 160;
#line 236
  __cil_tmp101 = (spinlock_t *)__cil_tmp100;
#line 236
  spin_unlock_irqrestore(__cil_tmp101, flags);
#line 238
  __cil_tmp102 = (unsigned int )stride;
#line 238
  __cil_tmp103 = y * __cil_tmp102;
#line 238
  i = (int )__cil_tmp103;
  }
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 238
    __cil_tmp104 = 320 + 24;
#line 238
    __cil_tmp105 = (unsigned long )info;
#line 238
    __cil_tmp106 = __cil_tmp105 + __cil_tmp104;
#line 238
    __cil_tmp107 = *((__u32 *)__cil_tmp106);
#line 238
    __cil_tmp108 = __cil_tmp107 / 4U;
#line 238
    __cil_tmp109 = (__u32 )i;
#line 238
    if (__cil_tmp109 < __cil_tmp108) {

    } else {
#line 238
      goto while_break___1;
    }
    }
#line 239
    __cil_tmp110 = (unsigned int )i;
#line 239
    __cil_tmp111 = __cil_tmp110 + x;
#line 239
    k = (int )__cil_tmp111;
    {
#line 239
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 239
      __cil_tmp112 = (unsigned int )i;
#line 239
      __cil_tmp113 = __cil_tmp112 + x;
#line 239
      __cil_tmp114 = __cil_tmp113 + w;
#line 239
      __cil_tmp115 = (unsigned int )k;
#line 239
      if (__cil_tmp115 < __cil_tmp114) {
        {
#line 239
        __cil_tmp116 = 320 + 24;
#line 239
        __cil_tmp117 = (unsigned long )info;
#line 239
        __cil_tmp118 = __cil_tmp117 + __cil_tmp116;
#line 239
        __cil_tmp119 = *((__u32 *)__cil_tmp118);
#line 239
        __cil_tmp120 = __cil_tmp119 / 4U;
#line 239
        __cil_tmp121 = (__u32 )k;
#line 239
        if (__cil_tmp121 < __cil_tmp120) {

        } else {
#line 239
          goto while_break___2;
        }
        }
      } else {
#line 239
        goto while_break___2;
      }
      }
      {
#line 240
      __cil_tmp122 = src + k;
#line 240
      __cil_tmp123 = *__cil_tmp122;
#line 240
      __cil_tmp124 = (u32 )__cil_tmp123;
#line 240
      __cil_tmp125 = vram_mem + k;
#line 240
      __cil_tmp126 = (void *)__cil_tmp125;
#line 240
      iowrite32(__cil_tmp124, __cil_tmp126);
#line 239
      k = k + 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 238
    i = i + stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 247
  __cil_tmp127 = (uint32_t )20UL;
#line 247
  tmp___12 = vmw_fifo_reserve(vmw_priv___0, __cil_tmp127);
#line 247
  cmd = (struct __anonstruct_cmd_430___0 *)tmp___12;
#line 248
  __cil_tmp128 = (void *)0;
#line 248
  __cil_tmp129 = (unsigned long )__cil_tmp128;
#line 248
  __cil_tmp130 = (unsigned long )cmd;
#line 248
  __cil_tmp131 = __cil_tmp130 == __cil_tmp129;
#line 248
  __cil_tmp132 = ! __cil_tmp131;
#line 248
  __cil_tmp133 = ! __cil_tmp132;
#line 248
  __cil_tmp134 = (long )__cil_tmp133;
#line 248
  tmp___13 = ldv__builtin_expect(__cil_tmp134, 0L);
  }
#line 248
  if (tmp___13) {
    {
#line 249
    drm_err("vmw_fb_dirty_flush", "Fifo reserve failed.\n");
    }
#line 250
    return;
  } else {

  }
  {
#line 253
  *((uint32_t *)cmd) = (__u32 )1;
#line 254
  __cil_tmp135 = (unsigned long )cmd;
#line 254
  __cil_tmp136 = __cil_tmp135 + 4;
#line 254
  *((uint32 *)__cil_tmp136) = x;
#line 255
  __cil_tmp137 = 4 + 4;
#line 255
  __cil_tmp138 = (unsigned long )cmd;
#line 255
  __cil_tmp139 = __cil_tmp138 + __cil_tmp137;
#line 255
  *((uint32 *)__cil_tmp139) = y;
#line 256
  __cil_tmp140 = 4 + 8;
#line 256
  __cil_tmp141 = (unsigned long )cmd;
#line 256
  __cil_tmp142 = __cil_tmp141 + __cil_tmp140;
#line 256
  *((uint32 *)__cil_tmp142) = w;
#line 257
  __cil_tmp143 = 4 + 12;
#line 257
  __cil_tmp144 = (unsigned long )cmd;
#line 257
  __cil_tmp145 = __cil_tmp144 + __cil_tmp143;
#line 257
  *((uint32 *)__cil_tmp145) = h;
#line 258
  __cil_tmp146 = (uint32_t )20UL;
#line 258
  vmw_fifo_commit(vmw_priv___0, __cil_tmp146);
  }
#line 259
  return;
}
}
#line 261 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_fb_dirty_mark(struct vmw_fb_par *par , unsigned int x1 , unsigned int y1 ,
                              unsigned int width , unsigned int height ) 
{ struct fb_info *info ;
  unsigned long flags ;
  unsigned int x2 ;
  unsigned int y2 ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_private *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct delayed_work *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;

  {
#line 265
  __cil_tmp13 = *((struct vmw_private **)par);
#line 265
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 265
  __cil_tmp15 = __cil_tmp14 + 2600;
#line 265
  __cil_tmp16 = *((void **)__cil_tmp15);
#line 265
  info = (struct fb_info *)__cil_tmp16;
#line 267
  x2 = x1 + width;
#line 268
  y2 = y1 + height;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 270
      __cil_tmp17 = (unsigned long )par;
#line 270
      __cil_tmp18 = __cil_tmp17 + 160;
#line 270
      __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 270
      tmp___7 = spinlock_check(__cil_tmp19);
#line 270
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 270
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  __cil_tmp20 = 160 + 36;
#line 271
  __cil_tmp21 = (unsigned long )par;
#line 271
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
#line 271
  __cil_tmp23 = *((unsigned int *)__cil_tmp22);
#line 271
  __cil_tmp24 = 160 + 28;
#line 271
  __cil_tmp25 = (unsigned long )par;
#line 271
  __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
#line 271
  __cil_tmp27 = *((unsigned int *)__cil_tmp26);
#line 271
  if (__cil_tmp27 == __cil_tmp23) {
#line 272
    __cil_tmp28 = 160 + 28;
#line 272
    __cil_tmp29 = (unsigned long )par;
#line 272
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 272
    *((unsigned int *)__cil_tmp30) = x1;
#line 273
    __cil_tmp31 = 160 + 32;
#line 273
    __cil_tmp32 = (unsigned long )par;
#line 273
    __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 273
    *((unsigned int *)__cil_tmp33) = y1;
#line 274
    __cil_tmp34 = 160 + 36;
#line 274
    __cil_tmp35 = (unsigned long )par;
#line 274
    __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
#line 274
    *((unsigned int *)__cil_tmp36) = x2;
#line 275
    __cil_tmp37 = 160 + 40;
#line 275
    __cil_tmp38 = (unsigned long )par;
#line 275
    __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
#line 275
    *((unsigned int *)__cil_tmp39) = y2;
    {
#line 278
    __cil_tmp40 = 160 + 24;
#line 278
    __cil_tmp41 = (unsigned long )par;
#line 278
    __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 278
    if (*((bool *)__cil_tmp42)) {
      {
#line 279
      __cil_tmp43 = (unsigned long )info;
#line 279
      __cil_tmp44 = __cil_tmp43 + 960;
#line 279
      __cil_tmp45 = (struct delayed_work *)__cil_tmp44;
#line 279
      schedule_delayed_work(__cil_tmp45, 8UL);
      }
    } else {

    }
    }
  } else {
    {
#line 281
    __cil_tmp46 = 160 + 28;
#line 281
    __cil_tmp47 = (unsigned long )par;
#line 281
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 281
    __cil_tmp49 = *((unsigned int *)__cil_tmp48);
#line 281
    if (x1 < __cil_tmp49) {
#line 282
      __cil_tmp50 = 160 + 28;
#line 282
      __cil_tmp51 = (unsigned long )par;
#line 282
      __cil_tmp52 = __cil_tmp51 + __cil_tmp50;
#line 282
      *((unsigned int *)__cil_tmp52) = x1;
    } else {

    }
    }
    {
#line 283
    __cil_tmp53 = 160 + 32;
#line 283
    __cil_tmp54 = (unsigned long )par;
#line 283
    __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
#line 283
    __cil_tmp56 = *((unsigned int *)__cil_tmp55);
#line 283
    if (y1 < __cil_tmp56) {
#line 284
      __cil_tmp57 = 160 + 32;
#line 284
      __cil_tmp58 = (unsigned long )par;
#line 284
      __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 284
      *((unsigned int *)__cil_tmp59) = y1;
    } else {

    }
    }
    {
#line 285
    __cil_tmp60 = 160 + 36;
#line 285
    __cil_tmp61 = (unsigned long )par;
#line 285
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 285
    __cil_tmp63 = *((unsigned int *)__cil_tmp62);
#line 285
    if (x2 > __cil_tmp63) {
#line 286
      __cil_tmp64 = 160 + 36;
#line 286
      __cil_tmp65 = (unsigned long )par;
#line 286
      __cil_tmp66 = __cil_tmp65 + __cil_tmp64;
#line 286
      *((unsigned int *)__cil_tmp66) = x2;
    } else {

    }
    }
    {
#line 287
    __cil_tmp67 = 160 + 40;
#line 287
    __cil_tmp68 = (unsigned long )par;
#line 287
    __cil_tmp69 = __cil_tmp68 + __cil_tmp67;
#line 287
    __cil_tmp70 = *((unsigned int *)__cil_tmp69);
#line 287
    if (y2 > __cil_tmp70) {
#line 288
      __cil_tmp71 = 160 + 40;
#line 288
      __cil_tmp72 = (unsigned long )par;
#line 288
      __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
#line 288
      *((unsigned int *)__cil_tmp73) = y2;
    } else {

    }
    }
  }
  }
  {
#line 290
  __cil_tmp74 = (unsigned long )par;
#line 290
  __cil_tmp75 = __cil_tmp74 + 160;
#line 290
  __cil_tmp76 = (spinlock_t *)__cil_tmp75;
#line 290
  spin_unlock_irqrestore(__cil_tmp76, flags);
  }
#line 291
  return;
}
}
#line 293 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_deferred_io(struct fb_info *info , struct list_head *pagelist ) 
{ struct vmw_fb_par *par ;
  unsigned long start ;
  unsigned long end ;
  unsigned long min ;
  unsigned long max ;
  unsigned long flags ;
  struct page *page ;
  int y1 ;
  int y2 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___7 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___8 ;
  raw_spinlock_t *tmp___9 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  struct list_head *__cil_tmp26 ;
  struct page *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long *__cil_tmp44 ;
  unsigned long *__cil_tmp45 ;
  unsigned long *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long *__cil_tmp50 ;
  unsigned long *__cil_tmp51 ;
  unsigned long *__cil_tmp52 ;
  unsigned long *__cil_tmp53 ;
  unsigned long *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long *__cil_tmp58 ;
  unsigned long *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct list_head *__cil_tmp62 ;
  struct page *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  __u32 __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  __u32 __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  spinlock_t *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  spinlock_t *__cil_tmp102 ;

  {
#line 296
  __cil_tmp23 = (unsigned long )info;
#line 296
  __cil_tmp24 = __cil_tmp23 + 1160;
#line 296
  __cil_tmp25 = *((void **)__cil_tmp24);
#line 296
  par = (struct vmw_fb_par *)__cil_tmp25;
#line 302
  min = ~ 0UL;
#line 303
  max = 0UL;
#line 304
  __cil_tmp26 = *((struct list_head **)pagelist);
#line 304
  __mptr = (struct list_head    *)__cil_tmp26;
#line 304
  __cil_tmp27 = (struct page *)0;
#line 304
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 304
  __cil_tmp29 = __cil_tmp28 + 32;
#line 304
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
#line 304
  __cil_tmp31 = (unsigned int )__cil_tmp30;
#line 304
  __cil_tmp32 = (char *)__mptr;
#line 304
  __cil_tmp33 = __cil_tmp32 - __cil_tmp31;
#line 304
  page = (struct page *)__cil_tmp33;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 304
    __cil_tmp34 = (unsigned long )pagelist;
#line 304
    __cil_tmp35 = (unsigned long )page;
#line 304
    __cil_tmp36 = __cil_tmp35 + 32;
#line 304
    __cil_tmp37 = (struct list_head *)__cil_tmp36;
#line 304
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 304
    if (__cil_tmp38 != __cil_tmp34) {

    } else {
#line 304
      goto while_break;
    }
    }
#line 305
    __cil_tmp39 = (unsigned long )page;
#line 305
    __cil_tmp40 = __cil_tmp39 + 16;
#line 305
    __cil_tmp41 = *((unsigned long *)__cil_tmp40);
#line 305
    start = __cil_tmp41 << 12;
#line 306
    __cil_tmp42 = 1UL << 12;
#line 306
    __cil_tmp43 = start + __cil_tmp42;
#line 306
    end = __cil_tmp43 - 1UL;
#line 307
    __cil_tmp44 = & _min1;
#line 307
    *__cil_tmp44 = min;
#line 307
    __cil_tmp45 = & _min2;
#line 307
    *__cil_tmp45 = start;
    {
#line 307
    __cil_tmp46 = & _min2;
#line 307
    __cil_tmp47 = *__cil_tmp46;
#line 307
    __cil_tmp48 = & _min1;
#line 307
    __cil_tmp49 = *__cil_tmp48;
#line 307
    if (__cil_tmp49 < __cil_tmp47) {
#line 307
      __cil_tmp50 = & _min1;
#line 307
      tmp___7 = *__cil_tmp50;
    } else {
#line 307
      __cil_tmp51 = & _min2;
#line 307
      tmp___7 = *__cil_tmp51;
    }
    }
#line 307
    min = tmp___7;
#line 308
    __cil_tmp52 = & _max1;
#line 308
    *__cil_tmp52 = max;
#line 308
    __cil_tmp53 = & _max2;
#line 308
    *__cil_tmp53 = end;
    {
#line 308
    __cil_tmp54 = & _max2;
#line 308
    __cil_tmp55 = *__cil_tmp54;
#line 308
    __cil_tmp56 = & _max1;
#line 308
    __cil_tmp57 = *__cil_tmp56;
#line 308
    if (__cil_tmp57 > __cil_tmp55) {
#line 308
      __cil_tmp58 = & _max1;
#line 308
      tmp___8 = *__cil_tmp58;
    } else {
#line 308
      __cil_tmp59 = & _max2;
#line 308
      tmp___8 = *__cil_tmp59;
    }
    }
#line 308
    max = tmp___8;
#line 304
    __cil_tmp60 = (unsigned long )page;
#line 304
    __cil_tmp61 = __cil_tmp60 + 32;
#line 304
    __cil_tmp62 = *((struct list_head **)__cil_tmp61);
#line 304
    __mptr___0 = (struct list_head    *)__cil_tmp62;
#line 304
    __cil_tmp63 = (struct page *)0;
#line 304
    __cil_tmp64 = (unsigned long )__cil_tmp63;
#line 304
    __cil_tmp65 = __cil_tmp64 + 32;
#line 304
    __cil_tmp66 = (struct list_head *)__cil_tmp65;
#line 304
    __cil_tmp67 = (unsigned int )__cil_tmp66;
#line 304
    __cil_tmp68 = (char *)__mptr___0;
#line 304
    __cil_tmp69 = __cil_tmp68 - __cil_tmp67;
#line 304
    page = (struct page *)__cil_tmp69;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  if (min < max) {
#line 312
    __cil_tmp70 = 320 + 48;
#line 312
    __cil_tmp71 = (unsigned long )info;
#line 312
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 312
    __cil_tmp73 = *((__u32 *)__cil_tmp72);
#line 312
    __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 312
    __cil_tmp75 = min / __cil_tmp74;
#line 312
    y1 = (int )__cil_tmp75;
#line 313
    __cil_tmp76 = 320 + 48;
#line 313
    __cil_tmp77 = (unsigned long )info;
#line 313
    __cil_tmp78 = __cil_tmp77 + __cil_tmp76;
#line 313
    __cil_tmp79 = *((__u32 *)__cil_tmp78);
#line 313
    __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 313
    __cil_tmp81 = max / __cil_tmp80;
#line 313
    __cil_tmp82 = __cil_tmp81 + 1UL;
#line 313
    y2 = (int )__cil_tmp82;
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 315
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 315
        __cil_tmp83 = (unsigned long )par;
#line 315
        __cil_tmp84 = __cil_tmp83 + 160;
#line 315
        __cil_tmp85 = (spinlock_t *)__cil_tmp84;
#line 315
        tmp___9 = spinlock_check(__cil_tmp85);
#line 315
        flags = _raw_spin_lock_irqsave(tmp___9);
        }
#line 315
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 315
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 316
    __cil_tmp86 = 160 + 28;
#line 316
    __cil_tmp87 = (unsigned long )par;
#line 316
    __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
#line 316
    *((unsigned int *)__cil_tmp88) = 0U;
#line 317
    __cil_tmp89 = 160 + 32;
#line 317
    __cil_tmp90 = (unsigned long )par;
#line 317
    __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
#line 317
    *((unsigned int *)__cil_tmp91) = (unsigned int )y1;
#line 318
    __cil_tmp92 = 160 + 36;
#line 318
    __cil_tmp93 = (unsigned long )par;
#line 318
    __cil_tmp94 = __cil_tmp93 + __cil_tmp92;
#line 318
    __cil_tmp95 = (unsigned long )info;
#line 318
    __cil_tmp96 = __cil_tmp95 + 160;
#line 318
    *((unsigned int *)__cil_tmp94) = *((__u32 *)__cil_tmp96);
#line 319
    __cil_tmp97 = 160 + 40;
#line 319
    __cil_tmp98 = (unsigned long )par;
#line 319
    __cil_tmp99 = __cil_tmp98 + __cil_tmp97;
#line 319
    *((unsigned int *)__cil_tmp99) = (unsigned int )y2;
#line 320
    __cil_tmp100 = (unsigned long )par;
#line 320
    __cil_tmp101 = __cil_tmp100 + 160;
#line 320
    __cil_tmp102 = (spinlock_t *)__cil_tmp101;
#line 320
    spin_unlock_irqrestore(__cil_tmp102, flags);
    }
  } else {

  }
  {
#line 323
  vmw_fb_dirty_flush(par);
  }
#line 324
  return;
}
}
#line 326 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
struct fb_deferred_io vmw_defio  =    {8UL, {{0}, {{{{{0U}}, 0U, 0U, (void *)0}}}, {(struct list_head *)0, (struct list_head *)0},
          (struct task_struct *)0, (char    *)0, (void *)0}, {(struct list_head *)0,
                                                                   (struct list_head *)0},
    & vmw_deferred_io};
#line 335 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_fb_fillrect(struct fb_info *info , struct fb_fillrect    *rect ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32    __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32    __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32    __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32    __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 337
  cfb_fillrect(info, rect);
#line 338
  __cil_tmp3 = (unsigned long )info;
#line 338
  __cil_tmp4 = __cil_tmp3 + 1160;
#line 338
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 338
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
#line 338
  __cil_tmp7 = *((__u32    *)rect);
#line 338
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 338
  __cil_tmp9 = (unsigned long )rect;
#line 338
  __cil_tmp10 = __cil_tmp9 + 4;
#line 338
  __cil_tmp11 = *((__u32    *)__cil_tmp10);
#line 338
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 338
  __cil_tmp13 = (unsigned long )rect;
#line 338
  __cil_tmp14 = __cil_tmp13 + 8;
#line 338
  __cil_tmp15 = *((__u32    *)__cil_tmp14);
#line 338
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 338
  __cil_tmp17 = (unsigned long )rect;
#line 338
  __cil_tmp18 = __cil_tmp17 + 12;
#line 338
  __cil_tmp19 = *((__u32    *)__cil_tmp18);
#line 338
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 338
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  }
#line 340
  return;
}
}
#line 342 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_fb_copyarea(struct fb_info *info , struct fb_copyarea    *region ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32    __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32    __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32    __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32    __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 344
  cfb_copyarea(info, region);
#line 345
  __cil_tmp3 = (unsigned long )info;
#line 345
  __cil_tmp4 = __cil_tmp3 + 1160;
#line 345
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 345
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
#line 345
  __cil_tmp7 = *((__u32    *)region);
#line 345
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 345
  __cil_tmp9 = (unsigned long )region;
#line 345
  __cil_tmp10 = __cil_tmp9 + 4;
#line 345
  __cil_tmp11 = *((__u32    *)__cil_tmp10);
#line 345
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 345
  __cil_tmp13 = (unsigned long )region;
#line 345
  __cil_tmp14 = __cil_tmp13 + 8;
#line 345
  __cil_tmp15 = *((__u32    *)__cil_tmp14);
#line 345
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 345
  __cil_tmp17 = (unsigned long )region;
#line 345
  __cil_tmp18 = __cil_tmp17 + 12;
#line 345
  __cil_tmp19 = *((__u32    *)__cil_tmp18);
#line 345
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 345
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  }
#line 347
  return;
}
}
#line 349 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static void vmw_fb_imageblit(struct fb_info *info , struct fb_image    *image ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32    __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32    __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32    __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32    __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 351
  cfb_imageblit(info, image);
#line 352
  __cil_tmp3 = (unsigned long )info;
#line 352
  __cil_tmp4 = __cil_tmp3 + 1160;
#line 352
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 352
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
#line 352
  __cil_tmp7 = *((__u32    *)image);
#line 352
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 352
  __cil_tmp9 = (unsigned long )image;
#line 352
  __cil_tmp10 = __cil_tmp9 + 4;
#line 352
  __cil_tmp11 = *((__u32    *)__cil_tmp10);
#line 352
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 352
  __cil_tmp13 = (unsigned long )image;
#line 352
  __cil_tmp14 = __cil_tmp13 + 8;
#line 352
  __cil_tmp15 = *((__u32    *)__cil_tmp14);
#line 352
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 352
  __cil_tmp17 = (unsigned long )image;
#line 352
  __cil_tmp18 = __cil_tmp17 + 12;
#line 352
  __cil_tmp19 = *((__u32    *)__cil_tmp18);
#line 352
  __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 352
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  }
#line 354
  return;
}
}
#line 360 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static struct fb_ops vmw_fb_ops  = 
#line 360
     {& __this_module, (int (*)(struct fb_info *info , int user ))0, (int (*)(struct fb_info *info ,
                                                                            int user ))0,
    (ssize_t (*)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ))0,
    (ssize_t (*)(struct fb_info *info , char    *buf , size_t count , loff_t *ppos ))0,
    & vmw_fb_check_var, & vmw_fb_set_par, & vmw_fb_setcolreg, (int (*)(struct fb_cmap *cmap ,
                                                                       struct fb_info *info ))0,
    & vmw_fb_blank, & vmw_fb_pan_display, & vmw_fb_fillrect, & vmw_fb_copyarea, & vmw_fb_imageblit,
    (int (*)(struct fb_info *info , struct fb_cursor *cursor ))0, (void (*)(struct fb_info *info ,
                                                                            int angle ))0,
    (int (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info , unsigned int cmd ,
                                                unsigned long arg ))0, (int (*)(struct fb_info *info ,
                                                                                unsigned int cmd ,
                                                                                unsigned long arg ))0,
    (int (*)(struct fb_info *info , struct vm_area_struct *vma ))0, (void (*)(struct fb_info *info ,
                                                                              struct fb_blit_caps *caps ,
                                                                              struct fb_var_screeninfo *var ))0,
    (void (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info ))0};
#line 372 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static int vmw_fb_create_bo(struct vmw_private *vmw_priv___0 , size_t size , struct vmw_dma_buffer **out ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_placement ne_placement ;
  int ret ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  struct ttm_placement *__cil_tmp10 ;
  struct ttm_placement *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct ttm_lock *__cil_tmp19 ;
  bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  bool __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_lock *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;

  {
  {
#line 376
  __cil_tmp10 = & ne_placement;
#line 376
  __cil_tmp11 = & vmw_vram_ne_placement;
#line 376
  *__cil_tmp10 = *__cil_tmp11;
#line 379
  __cil_tmp12 = (unsigned long )(& ne_placement) + 4;
#line 379
  __cil_tmp13 = 1UL << 12;
#line 379
  __cil_tmp14 = size + __cil_tmp13;
#line 379
  __cil_tmp15 = __cil_tmp14 - 1UL;
#line 379
  __cil_tmp16 = __cil_tmp15 >> 12;
#line 379
  *((unsigned int *)__cil_tmp12) = (unsigned int )__cil_tmp16;
#line 382
  __cil_tmp17 = (unsigned long )vmw_priv___0;
#line 382
  __cil_tmp18 = __cil_tmp17 + 134392;
#line 382
  __cil_tmp19 = (struct ttm_lock *)__cil_tmp18;
#line 382
  __cil_tmp20 = (bool )0;
#line 382
  ret = ttm_write_lock(__cil_tmp19, __cil_tmp20);
#line 383
  __cil_tmp21 = ret != 0;
#line 383
  __cil_tmp22 = ! __cil_tmp21;
#line 383
  __cil_tmp23 = ! __cil_tmp22;
#line 383
  __cil_tmp24 = (long )__cil_tmp23;
#line 383
  tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 383
  if (tmp___7) {
#line 384
    return (ret);
  } else {

  }
  {
#line 386
  tmp___8 = kmalloc(416UL, 208U);
#line 386
  vmw_bo = (struct vmw_dma_buffer *)tmp___8;
  }
#line 387
  if (! vmw_bo) {
#line 388
    goto err_unlock;
  } else {

  }
  {
#line 390
  __cil_tmp25 = (bool )0;
#line 390
  ret = vmw_dmabuf_init(vmw_priv___0, vmw_bo, size, & ne_placement, __cil_tmp25, & vmw_dmabuf_bo_free);
#line 394
  __cil_tmp26 = ret != 0;
#line 394
  __cil_tmp27 = ! __cil_tmp26;
#line 394
  __cil_tmp28 = ! __cil_tmp27;
#line 394
  __cil_tmp29 = (long )__cil_tmp28;
#line 394
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 394
  if (tmp___9) {
#line 395
    goto err_unlock;
  } else {

  }
  {
#line 397
  *out = vmw_bo;
#line 399
  __cil_tmp30 = (unsigned long )vmw_priv___0;
#line 399
  __cil_tmp31 = __cil_tmp30 + 134392;
#line 399
  __cil_tmp32 = (struct ttm_lock *)__cil_tmp31;
#line 399
  ttm_write_unlock(__cil_tmp32);
  }
#line 401
  return (0);
  err_unlock: 
  {
#line 404
  __cil_tmp33 = (unsigned long )vmw_priv___0;
#line 404
  __cil_tmp34 = __cil_tmp33 + 134392;
#line 404
  __cil_tmp35 = (struct ttm_lock *)__cil_tmp34;
#line 404
  ttm_write_unlock(__cil_tmp35);
  }
#line 405
  return (ret);
}
}
#line 531 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
static struct lock_class_key __key___12  ;
#line 408 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) 
{ struct device *device ;
  struct vmw_fb_par *par ;
  struct fb_info *info ;
  unsigned int initial_width ;
  unsigned int initial_height ;
  unsigned int fb_width ;
  unsigned int fb_height ;
  unsigned int fb_bpp ;
  unsigned int fb_depth ;
  unsigned int fb_offset ;
  unsigned int fb_pitch ;
  unsigned int fb_size ;
  int ret ;
  uint32_t _min1 ;
  unsigned int _min2 ;
  uint32_t tmp___7 ;
  uint32_t _min1___0 ;
  unsigned int _min2___0 ;
  uint32_t tmp___8 ;
  uint32_t _min1___1 ;
  unsigned int _min2___1 ;
  uint32_t tmp___9 ;
  uint32_t _min1___2 ;
  unsigned int _min2___2 ;
  uint32_t tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct drm_device *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct pci_dev *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned int *__cil_tmp44 ;
  unsigned int *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  uint32_t *__cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  uint32_t *__cil_tmp49 ;
  unsigned int *__cil_tmp50 ;
  uint32_t *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned int *__cil_tmp54 ;
  unsigned int *__cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  uint32_t *__cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  uint32_t *__cil_tmp59 ;
  unsigned int *__cil_tmp60 ;
  uint32_t *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned int *__cil_tmp64 ;
  unsigned int *__cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  uint32_t *__cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  uint32_t *__cil_tmp69 ;
  unsigned int *__cil_tmp70 ;
  uint32_t *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned int *__cil_tmp74 ;
  unsigned int *__cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  uint32_t *__cil_tmp77 ;
  uint32_t __cil_tmp78 ;
  uint32_t *__cil_tmp79 ;
  unsigned int *__cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  void *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  void *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  void *__cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  long __cil_tmp109 ;
  size_t __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  struct vmw_dma_buffer **__cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  struct vmw_dma_buffer *__cil_tmp120 ;
  struct ttm_buffer_object *__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  struct vmw_dma_buffer *__cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  struct ttm_bo_kmap_obj *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct ttm_bo_kmap_obj *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  bool *__cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  char *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  u32 *__cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  void *__cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  struct apertures_struct *__cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  struct apertures_struct *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  uint32_t __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  struct apertures_struct *__cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  uint32_t __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  unsigned long __cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  spinlock_t *__cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  struct raw_spinlock *__cil_tmp305 ;
  unsigned long __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  int __cil_tmp308 ;
  int __cil_tmp309 ;
  int __cil_tmp310 ;
  long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct ttm_bo_kmap_obj *__cil_tmp314 ;
  unsigned long __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  struct vmw_dma_buffer **__cil_tmp317 ;
  struct ttm_buffer_object **__cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  void *__cil_tmp321 ;
  void    *__cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;

  {
#line 410
  __cil_tmp33 = (unsigned long )vmw_priv___0;
#line 410
  __cil_tmp34 = __cil_tmp33 + 2088;
#line 410
  __cil_tmp35 = *((struct drm_device **)__cil_tmp34);
#line 410
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 410
  __cil_tmp37 = __cil_tmp36 + 1016;
#line 410
  __cil_tmp38 = *((struct pci_dev **)__cil_tmp37);
#line 410
  __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 410
  __cil_tmp40 = __cil_tmp39 + 144;
#line 410
  device = (struct device *)__cil_tmp40;
#line 418
  fb_bpp = 32U;
#line 419
  fb_depth = 24U;
#line 422
  __cil_tmp41 = & _min1;
#line 422
  __cil_tmp42 = (unsigned long )vmw_priv___0;
#line 422
  __cil_tmp43 = __cil_tmp42 + 2124;
#line 422
  *__cil_tmp41 = *((uint32_t *)__cil_tmp43);
#line 422
  __cil_tmp44 = & _min2;
#line 422
  *__cil_tmp44 = 2048U;
  {
#line 422
  __cil_tmp45 = & _min2;
#line 422
  __cil_tmp46 = *__cil_tmp45;
#line 422
  __cil_tmp47 = & _min1;
#line 422
  __cil_tmp48 = *__cil_tmp47;
#line 422
  if (__cil_tmp48 < __cil_tmp46) {
#line 422
    __cil_tmp49 = & _min1;
#line 422
    tmp___7 = *__cil_tmp49;
  } else {
#line 422
    __cil_tmp50 = & _min2;
#line 422
    tmp___7 = *__cil_tmp50;
  }
  }
#line 422
  fb_width = tmp___7;
#line 423
  __cil_tmp51 = & _min1___0;
#line 423
  __cil_tmp52 = (unsigned long )vmw_priv___0;
#line 423
  __cil_tmp53 = __cil_tmp52 + 2128;
#line 423
  *__cil_tmp51 = *((uint32_t *)__cil_tmp53);
#line 423
  __cil_tmp54 = & _min2___0;
#line 423
  *__cil_tmp54 = 2048U;
  {
#line 423
  __cil_tmp55 = & _min2___0;
#line 423
  __cil_tmp56 = *__cil_tmp55;
#line 423
  __cil_tmp57 = & _min1___0;
#line 423
  __cil_tmp58 = *__cil_tmp57;
#line 423
  if (__cil_tmp58 < __cil_tmp56) {
#line 423
    __cil_tmp59 = & _min1___0;
#line 423
    tmp___8 = *__cil_tmp59;
  } else {
#line 423
    __cil_tmp60 = & _min2___0;
#line 423
    tmp___8 = *__cil_tmp60;
  }
  }
#line 423
  fb_height = tmp___8;
#line 425
  __cil_tmp61 = & _min1___1;
#line 425
  __cil_tmp62 = (unsigned long )vmw_priv___0;
#line 425
  __cil_tmp63 = __cil_tmp62 + 2132;
#line 425
  *__cil_tmp61 = *((uint32_t *)__cil_tmp63);
#line 425
  __cil_tmp64 = & _min2___1;
#line 425
  *__cil_tmp64 = fb_width;
  {
#line 425
  __cil_tmp65 = & _min2___1;
#line 425
  __cil_tmp66 = *__cil_tmp65;
#line 425
  __cil_tmp67 = & _min1___1;
#line 425
  __cil_tmp68 = *__cil_tmp67;
#line 425
  if (__cil_tmp68 < __cil_tmp66) {
#line 425
    __cil_tmp69 = & _min1___1;
#line 425
    tmp___9 = *__cil_tmp69;
  } else {
#line 425
    __cil_tmp70 = & _min2___1;
#line 425
    tmp___9 = *__cil_tmp70;
  }
  }
#line 425
  initial_width = tmp___9;
#line 426
  __cil_tmp71 = & _min1___2;
#line 426
  __cil_tmp72 = (unsigned long )vmw_priv___0;
#line 426
  __cil_tmp73 = __cil_tmp72 + 2136;
#line 426
  *__cil_tmp71 = *((uint32_t *)__cil_tmp73);
#line 426
  __cil_tmp74 = & _min2___2;
#line 426
  *__cil_tmp74 = fb_height;
  {
#line 426
  __cil_tmp75 = & _min2___2;
#line 426
  __cil_tmp76 = *__cil_tmp75;
#line 426
  __cil_tmp77 = & _min1___2;
#line 426
  __cil_tmp78 = *__cil_tmp77;
#line 426
  if (__cil_tmp78 < __cil_tmp76) {
#line 426
    __cil_tmp79 = & _min1___2;
#line 426
    tmp___10 = *__cil_tmp79;
  } else {
#line 426
    __cil_tmp80 = & _min2___2;
#line 426
    tmp___10 = *__cil_tmp80;
  }
  }
  {
#line 426
  initial_height = tmp___10;
#line 428
  __cil_tmp81 = fb_width * fb_bpp;
#line 428
  fb_pitch = __cil_tmp81 / 8U;
#line 429
  fb_size = fb_pitch * fb_height;
#line 430
  fb_offset = vmw_read(vmw_priv___0, 14U);
#line 432
  info = framebuffer_alloc(208UL, device);
  }
#line 433
  if (! info) {
#line 434
    return (-12);
  } else {

  }
  {
#line 439
  __cil_tmp82 = (unsigned long )vmw_priv___0;
#line 439
  __cil_tmp83 = __cil_tmp82 + 2600;
#line 439
  *((void **)__cil_tmp83) = (void *)info;
#line 440
  __cil_tmp84 = (unsigned long )info;
#line 440
  __cil_tmp85 = __cil_tmp84 + 1160;
#line 440
  __cil_tmp86 = *((void **)__cil_tmp85);
#line 440
  par = (struct vmw_fb_par *)__cil_tmp86;
#line 441
  *((struct vmw_private **)par) = vmw_priv___0;
#line 442
  __cil_tmp87 = (unsigned long )par;
#line 442
  __cil_tmp88 = __cil_tmp87 + 124;
#line 442
  *((unsigned int *)__cil_tmp88) = fb_depth;
#line 443
  __cil_tmp89 = (unsigned long )par;
#line 443
  __cil_tmp90 = __cil_tmp89 + 128;
#line 443
  *((unsigned int *)__cil_tmp90) = fb_bpp;
#line 444
  __cil_tmp91 = (unsigned long )par;
#line 444
  __cil_tmp92 = __cil_tmp91 + 8;
#line 444
  *((void **)__cil_tmp92) = (void *)0;
#line 445
  __cil_tmp93 = (unsigned long )par;
#line 445
  __cil_tmp94 = __cil_tmp93 + 132;
#line 445
  *((unsigned int *)__cil_tmp94) = fb_width;
#line 446
  __cil_tmp95 = (unsigned long )par;
#line 446
  __cil_tmp96 = __cil_tmp95 + 136;
#line 446
  *((unsigned int *)__cil_tmp96) = fb_height;
#line 451
  __cil_tmp97 = (unsigned long )par;
#line 451
  __cil_tmp98 = __cil_tmp97 + 8;
#line 451
  __cil_tmp99 = (unsigned long )fb_size;
#line 451
  *((void **)__cil_tmp98) = vmalloc(__cil_tmp99);
#line 452
  __cil_tmp100 = (void *)0;
#line 452
  __cil_tmp101 = (unsigned long )__cil_tmp100;
#line 452
  __cil_tmp102 = (unsigned long )par;
#line 452
  __cil_tmp103 = __cil_tmp102 + 8;
#line 452
  __cil_tmp104 = *((void **)__cil_tmp103);
#line 452
  __cil_tmp105 = (unsigned long )__cil_tmp104;
#line 452
  __cil_tmp106 = __cil_tmp105 == __cil_tmp101;
#line 452
  __cil_tmp107 = ! __cil_tmp106;
#line 452
  __cil_tmp108 = ! __cil_tmp107;
#line 452
  __cil_tmp109 = (long )__cil_tmp108;
#line 452
  tmp___11 = ldv__builtin_expect(__cil_tmp109, 0L);
  }
#line 452
  if (tmp___11) {
#line 453
    ret = -12;
#line 454
    goto err_free;
  } else {

  }
  {
#line 457
  __cil_tmp110 = (size_t )fb_size;
#line 457
  __cil_tmp111 = (unsigned long )par;
#line 457
  __cil_tmp112 = __cil_tmp111 + 16;
#line 457
  __cil_tmp113 = (struct vmw_dma_buffer **)__cil_tmp112;
#line 457
  ret = vmw_fb_create_bo(vmw_priv___0, __cil_tmp110, __cil_tmp113);
#line 458
  __cil_tmp114 = ret != 0;
#line 458
  __cil_tmp115 = ! __cil_tmp114;
#line 458
  __cil_tmp116 = ! __cil_tmp115;
#line 458
  __cil_tmp117 = (long )__cil_tmp116;
#line 458
  tmp___12 = ldv__builtin_expect(__cil_tmp117, 0L);
  }
#line 458
  if (tmp___12) {
#line 459
    goto err_free;
  } else {

  }
  {
#line 461
  __cil_tmp118 = (unsigned long )par;
#line 461
  __cil_tmp119 = __cil_tmp118 + 16;
#line 461
  __cil_tmp120 = *((struct vmw_dma_buffer **)__cil_tmp119);
#line 461
  __cil_tmp121 = (struct ttm_buffer_object *)__cil_tmp120;
#line 461
  __cil_tmp122 = 0 + 40;
#line 461
  __cil_tmp123 = (unsigned long )par;
#line 461
  __cil_tmp124 = __cil_tmp123 + 16;
#line 461
  __cil_tmp125 = *((struct vmw_dma_buffer **)__cil_tmp124);
#line 461
  __cil_tmp126 = (unsigned long )__cil_tmp125;
#line 461
  __cil_tmp127 = __cil_tmp126 + __cil_tmp122;
#line 461
  __cil_tmp128 = *((unsigned long *)__cil_tmp127);
#line 461
  __cil_tmp129 = (unsigned long )par;
#line 461
  __cil_tmp130 = __cil_tmp129 + 24;
#line 461
  __cil_tmp131 = (struct ttm_bo_kmap_obj *)__cil_tmp130;
#line 461
  ret = ttm_bo_kmap(__cil_tmp121, 0UL, __cil_tmp128, __cil_tmp131);
#line 465
  __cil_tmp132 = ret != 0;
#line 465
  __cil_tmp133 = ! __cil_tmp132;
#line 465
  __cil_tmp134 = ! __cil_tmp133;
#line 465
  __cil_tmp135 = (long )__cil_tmp134;
#line 465
  tmp___13 = ldv__builtin_expect(__cil_tmp135, 0L);
  }
#line 465
  if (tmp___13) {
#line 466
    goto err_unref;
  } else {

  }
  {
#line 467
  __cil_tmp136 = (unsigned long )par;
#line 467
  __cil_tmp137 = __cil_tmp136 + 144;
#line 467
  __cil_tmp138 = (unsigned long )par;
#line 467
  __cil_tmp139 = __cil_tmp138 + 24;
#line 467
  __cil_tmp140 = (struct ttm_bo_kmap_obj *)__cil_tmp139;
#line 467
  __cil_tmp141 = (unsigned long )par;
#line 467
  __cil_tmp142 = __cil_tmp141 + 156;
#line 467
  __cil_tmp143 = (bool *)__cil_tmp142;
#line 467
  *((void **)__cil_tmp137) = ttm_kmap_obj_virtual(__cil_tmp140, __cil_tmp143);
#line 468
  __cil_tmp144 = (unsigned long )par;
#line 468
  __cil_tmp145 = __cil_tmp144 + 152;
#line 468
  *((unsigned int *)__cil_tmp145) = fb_size;
#line 473
  __cil_tmp146 = 0 * 1UL;
#line 473
  __cil_tmp147 = 0 + __cil_tmp146;
#line 473
  __cil_tmp148 = 320 + __cil_tmp147;
#line 473
  __cil_tmp149 = (unsigned long )info;
#line 473
  __cil_tmp150 = __cil_tmp149 + __cil_tmp148;
#line 473
  __cil_tmp151 = (char *)__cil_tmp150;
#line 473
  strcpy(__cil_tmp151, "svgadrmfb");
#line 474
  __cil_tmp152 = 320 + 28;
#line 474
  __cil_tmp153 = (unsigned long )info;
#line 474
  __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
#line 474
  *((__u32 *)__cil_tmp154) = (__u32 )0;
#line 475
  __cil_tmp155 = 320 + 36;
#line 475
  __cil_tmp156 = (unsigned long )info;
#line 475
  __cil_tmp157 = __cil_tmp156 + __cil_tmp155;
#line 475
  *((__u32 *)__cil_tmp157) = (__u32 )2;
#line 476
  __cil_tmp158 = 320 + 32;
#line 476
  __cil_tmp159 = (unsigned long )info;
#line 476
  __cil_tmp160 = __cil_tmp159 + __cil_tmp158;
#line 476
  *((__u32 *)__cil_tmp160) = (__u32 )0;
#line 477
  __cil_tmp161 = 320 + 40;
#line 477
  __cil_tmp162 = (unsigned long )info;
#line 477
  __cil_tmp163 = __cil_tmp162 + __cil_tmp161;
#line 477
  *((__u16 *)__cil_tmp163) = (__u16 )1;
#line 478
  __cil_tmp164 = 320 + 42;
#line 478
  __cil_tmp165 = (unsigned long )info;
#line 478
  __cil_tmp166 = __cil_tmp165 + __cil_tmp164;
#line 478
  *((__u16 *)__cil_tmp166) = (__u16 )1;
#line 479
  __cil_tmp167 = 320 + 44;
#line 479
  __cil_tmp168 = (unsigned long )info;
#line 479
  __cil_tmp169 = __cil_tmp168 + __cil_tmp167;
#line 479
  *((__u16 *)__cil_tmp169) = (__u16 )0;
#line 480
  __cil_tmp170 = 320 + 68;
#line 480
  __cil_tmp171 = (unsigned long )info;
#line 480
  __cil_tmp172 = __cil_tmp171 + __cil_tmp170;
#line 480
  *((__u32 *)__cil_tmp172) = (__u32 )0;
#line 481
  __cil_tmp173 = 320 + 48;
#line 481
  __cil_tmp174 = (unsigned long )info;
#line 481
  __cil_tmp175 = __cil_tmp174 + __cil_tmp173;
#line 481
  *((__u32 *)__cil_tmp175) = fb_pitch;
#line 483
  __cil_tmp176 = 320 + 16;
#line 483
  __cil_tmp177 = (unsigned long )info;
#line 483
  __cil_tmp178 = __cil_tmp177 + __cil_tmp176;
#line 483
  *((unsigned long *)__cil_tmp178) = 0UL;
#line 484
  __cil_tmp179 = 320 + 24;
#line 484
  __cil_tmp180 = (unsigned long )info;
#line 484
  __cil_tmp181 = __cil_tmp180 + __cil_tmp179;
#line 484
  *((__u32 *)__cil_tmp181) = fb_size;
#line 486
  __cil_tmp182 = (unsigned long )info;
#line 486
  __cil_tmp183 = __cil_tmp182 + 1136;
#line 486
  __cil_tmp184 = 0 * 4UL;
#line 486
  __cil_tmp185 = 56 + __cil_tmp184;
#line 486
  __cil_tmp186 = (unsigned long )par;
#line 486
  __cil_tmp187 = __cil_tmp186 + __cil_tmp185;
#line 486
  __cil_tmp188 = (u32 *)__cil_tmp187;
#line 486
  *((void **)__cil_tmp183) = (void *)__cil_tmp188;
#line 487
  __cil_tmp189 = (unsigned long )info;
#line 487
  __cil_tmp190 = __cil_tmp189 + 1120;
#line 487
  __cil_tmp191 = (unsigned long )par;
#line 487
  __cil_tmp192 = __cil_tmp191 + 8;
#line 487
  __cil_tmp193 = *((void **)__cil_tmp192);
#line 487
  *((char **)__cil_tmp190) = (char *)__cil_tmp193;
#line 488
  __cil_tmp194 = (unsigned long )info;
#line 488
  __cil_tmp195 = __cil_tmp194 + 1128;
#line 488
  *((unsigned long *)__cil_tmp195) = (unsigned long )fb_size;
#line 490
  __cil_tmp196 = (unsigned long )info;
#line 490
  __cil_tmp197 = __cil_tmp196 + 8;
#line 490
  *((int *)__cil_tmp197) = 1;
#line 491
  __cil_tmp198 = (unsigned long )info;
#line 491
  __cil_tmp199 = __cil_tmp198 + 1080;
#line 491
  *((struct fb_ops **)__cil_tmp199) = & vmw_fb_ops;
#line 494
  __cil_tmp200 = 160 + 32;
#line 494
  __cil_tmp201 = (unsigned long )info;
#line 494
  __cil_tmp202 = __cil_tmp201 + __cil_tmp200;
#line 494
  *((__u32 *)__cil_tmp202) = (__u32 )16;
#line 495
  __cil_tmp203 = 160 + 44;
#line 495
  __cil_tmp204 = (unsigned long )info;
#line 495
  __cil_tmp205 = __cil_tmp204 + __cil_tmp203;
#line 495
  *((__u32 *)__cil_tmp205) = (__u32 )8;
#line 496
  __cil_tmp206 = 160 + 56;
#line 496
  __cil_tmp207 = (unsigned long )info;
#line 496
  __cil_tmp208 = __cil_tmp207 + __cil_tmp206;
#line 496
  *((__u32 *)__cil_tmp208) = (__u32 )0;
#line 497
  __cil_tmp209 = 32 + 4;
#line 497
  __cil_tmp210 = 160 + __cil_tmp209;
#line 497
  __cil_tmp211 = (unsigned long )info;
#line 497
  __cil_tmp212 = __cil_tmp211 + __cil_tmp210;
#line 497
  *((__u32 *)__cil_tmp212) = (__u32 )8;
#line 498
  __cil_tmp213 = 44 + 4;
#line 498
  __cil_tmp214 = 160 + __cil_tmp213;
#line 498
  __cil_tmp215 = (unsigned long )info;
#line 498
  __cil_tmp216 = __cil_tmp215 + __cil_tmp214;
#line 498
  *((__u32 *)__cil_tmp216) = (__u32 )8;
#line 499
  __cil_tmp217 = 56 + 4;
#line 499
  __cil_tmp218 = 160 + __cil_tmp217;
#line 499
  __cil_tmp219 = (unsigned long )info;
#line 499
  __cil_tmp220 = __cil_tmp219 + __cil_tmp218;
#line 499
  *((__u32 *)__cil_tmp220) = (__u32 )8;
#line 500
  __cil_tmp221 = 160 + 68;
#line 500
  __cil_tmp222 = (unsigned long )info;
#line 500
  __cil_tmp223 = __cil_tmp222 + __cil_tmp221;
#line 500
  *((__u32 *)__cil_tmp223) = (__u32 )0;
#line 501
  __cil_tmp224 = 68 + 4;
#line 501
  __cil_tmp225 = 160 + __cil_tmp224;
#line 501
  __cil_tmp226 = (unsigned long )info;
#line 501
  __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
#line 501
  *((__u32 *)__cil_tmp227) = (__u32 )0;
#line 503
  __cil_tmp228 = 160 + 8;
#line 503
  __cil_tmp229 = (unsigned long )info;
#line 503
  __cil_tmp230 = __cil_tmp229 + __cil_tmp228;
#line 503
  *((__u32 *)__cil_tmp230) = fb_width;
#line 504
  __cil_tmp231 = 160 + 12;
#line 504
  __cil_tmp232 = (unsigned long )info;
#line 504
  __cil_tmp233 = __cil_tmp232 + __cil_tmp231;
#line 504
  *((__u32 *)__cil_tmp233) = fb_height;
#line 505
  __cil_tmp234 = 160 + 24;
#line 505
  __cil_tmp235 = (unsigned long )info;
#line 505
  __cil_tmp236 = __cil_tmp235 + __cil_tmp234;
#line 505
  __cil_tmp237 = (unsigned long )par;
#line 505
  __cil_tmp238 = __cil_tmp237 + 128;
#line 505
  *((__u32 *)__cil_tmp236) = *((unsigned int *)__cil_tmp238);
#line 506
  __cil_tmp239 = 160 + 16;
#line 506
  __cil_tmp240 = (unsigned long )info;
#line 506
  __cil_tmp241 = __cil_tmp240 + __cil_tmp239;
#line 506
  *((__u32 *)__cil_tmp241) = (__u32 )0;
#line 507
  __cil_tmp242 = 160 + 20;
#line 507
  __cil_tmp243 = (unsigned long )info;
#line 507
  __cil_tmp244 = __cil_tmp243 + __cil_tmp242;
#line 507
  *((__u32 *)__cil_tmp244) = (__u32 )0;
#line 508
  __cil_tmp245 = 160 + 84;
#line 508
  __cil_tmp246 = (unsigned long )info;
#line 508
  __cil_tmp247 = __cil_tmp246 + __cil_tmp245;
#line 508
  *((__u32 *)__cil_tmp247) = (__u32 )0;
#line 509
  __cil_tmp248 = 160 + 88;
#line 509
  __cil_tmp249 = (unsigned long )info;
#line 509
  __cil_tmp250 = __cil_tmp249 + __cil_tmp248;
#line 509
  *((__u32 *)__cil_tmp250) = (__u32 )-1;
#line 510
  __cil_tmp251 = 160 + 92;
#line 510
  __cil_tmp252 = (unsigned long )info;
#line 510
  __cil_tmp253 = __cil_tmp252 + __cil_tmp251;
#line 510
  *((__u32 *)__cil_tmp253) = (__u32 )-1;
#line 512
  __cil_tmp254 = (unsigned long )info;
#line 512
  __cil_tmp255 = __cil_tmp254 + 160;
#line 512
  *((__u32 *)__cil_tmp255) = initial_width;
#line 513
  __cil_tmp256 = 160 + 4;
#line 513
  __cil_tmp257 = (unsigned long )info;
#line 513
  __cil_tmp258 = __cil_tmp257 + __cil_tmp256;
#line 513
  *((__u32 *)__cil_tmp258) = initial_height;
#line 517
  __cil_tmp259 = (unsigned long )info;
#line 517
  __cil_tmp260 = __cil_tmp259 + 1168;
#line 517
  *((struct apertures_struct **)__cil_tmp260) = alloc_apertures(1U);
  }
  {
#line 518
  __cil_tmp261 = (unsigned long )info;
#line 518
  __cil_tmp262 = __cil_tmp261 + 1168;
#line 518
  __cil_tmp263 = *((struct apertures_struct **)__cil_tmp262);
#line 518
  if (! __cil_tmp263) {
#line 519
    ret = -12;
#line 520
    goto err_aper;
  } else {

  }
  }
#line 522
  __cil_tmp264 = 0 * 16UL;
#line 522
  __cil_tmp265 = 8 + __cil_tmp264;
#line 522
  __cil_tmp266 = (unsigned long )info;
#line 522
  __cil_tmp267 = __cil_tmp266 + 1168;
#line 522
  __cil_tmp268 = *((struct apertures_struct **)__cil_tmp267);
#line 522
  __cil_tmp269 = (unsigned long )__cil_tmp268;
#line 522
  __cil_tmp270 = __cil_tmp269 + __cil_tmp265;
#line 522
  __cil_tmp271 = (unsigned long )vmw_priv___0;
#line 522
  __cil_tmp272 = __cil_tmp271 + 2108;
#line 522
  __cil_tmp273 = *((uint32_t *)__cil_tmp272);
#line 522
  *((resource_size_t *)__cil_tmp270) = (resource_size_t )__cil_tmp273;
#line 523
  __cil_tmp274 = 0 * 16UL;
#line 523
  __cil_tmp275 = __cil_tmp274 + 8;
#line 523
  __cil_tmp276 = 8 + __cil_tmp275;
#line 523
  __cil_tmp277 = (unsigned long )info;
#line 523
  __cil_tmp278 = __cil_tmp277 + 1168;
#line 523
  __cil_tmp279 = *((struct apertures_struct **)__cil_tmp278);
#line 523
  __cil_tmp280 = (unsigned long )__cil_tmp279;
#line 523
  __cil_tmp281 = __cil_tmp280 + __cil_tmp276;
#line 523
  __cil_tmp282 = (unsigned long )vmw_priv___0;
#line 523
  __cil_tmp283 = __cil_tmp282 + 2112;
#line 523
  __cil_tmp284 = *((uint32_t *)__cil_tmp283);
#line 523
  *((resource_size_t *)__cil_tmp281) = (resource_size_t )__cil_tmp284;
#line 528
  tmp___14 = 0U;
#line 528
  __cil_tmp285 = 160 + 36;
#line 528
  __cil_tmp286 = (unsigned long )par;
#line 528
  __cil_tmp287 = __cil_tmp286 + __cil_tmp285;
#line 528
  *((unsigned int *)__cil_tmp287) = tmp___14;
#line 528
  __cil_tmp288 = 160 + 28;
#line 528
  __cil_tmp289 = (unsigned long )par;
#line 528
  __cil_tmp290 = __cil_tmp289 + __cil_tmp288;
#line 528
  *((unsigned int *)__cil_tmp290) = tmp___14;
#line 529
  tmp___15 = 0U;
#line 529
  __cil_tmp291 = 160 + 40;
#line 529
  __cil_tmp292 = (unsigned long )par;
#line 529
  __cil_tmp293 = __cil_tmp292 + __cil_tmp291;
#line 529
  *((unsigned int *)__cil_tmp293) = tmp___15;
#line 529
  __cil_tmp294 = 160 + 32;
#line 529
  __cil_tmp295 = (unsigned long )par;
#line 529
  __cil_tmp296 = __cil_tmp295 + __cil_tmp294;
#line 529
  *((unsigned int *)__cil_tmp296) = tmp___15;
#line 530
  __cil_tmp297 = 160 + 24;
#line 530
  __cil_tmp298 = (unsigned long )par;
#line 530
  __cil_tmp299 = __cil_tmp298 + __cil_tmp297;
#line 530
  *((bool *)__cil_tmp299) = (bool )1;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 531
    __cil_tmp300 = (unsigned long )par;
#line 531
    __cil_tmp301 = __cil_tmp300 + 160;
#line 531
    __cil_tmp302 = (spinlock_t *)__cil_tmp301;
#line 531
    spinlock_check(__cil_tmp302);
    }
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 531
      __cil_tmp303 = (unsigned long )par;
#line 531
      __cil_tmp304 = __cil_tmp303 + 160;
#line 531
      __cil_tmp305 = (struct raw_spinlock *)__cil_tmp304;
#line 531
      __raw_spin_lock_init(__cil_tmp305, "&(&par->dirty.lock)->rlock", & __key___12);
      }
#line 531
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 531
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 532
  __cil_tmp306 = (unsigned long )info;
#line 532
  __cil_tmp307 = __cil_tmp306 + 1072;
#line 532
  *((struct fb_deferred_io **)__cil_tmp307) = & vmw_defio;
#line 533
  fb_deferred_io_init(info);
#line 535
  ret = register_framebuffer(info);
#line 536
  __cil_tmp308 = ret != 0;
#line 536
  __cil_tmp309 = ! __cil_tmp308;
#line 536
  __cil_tmp310 = ! __cil_tmp309;
#line 536
  __cil_tmp311 = (long )__cil_tmp310;
#line 536
  tmp___16 = ldv__builtin_expect(__cil_tmp311, 0L);
  }
#line 536
  if (tmp___16) {
#line 537
    goto err_defio;
  } else {

  }
#line 539
  return (0);
  err_defio: 
  {
#line 542
  fb_deferred_io_cleanup(info);
  }
  err_aper: 
  {
#line 544
  __cil_tmp312 = (unsigned long )par;
#line 544
  __cil_tmp313 = __cil_tmp312 + 24;
#line 544
  __cil_tmp314 = (struct ttm_bo_kmap_obj *)__cil_tmp313;
#line 544
  ttm_bo_kunmap(__cil_tmp314);
  }
  err_unref: 
  {
#line 546
  __cil_tmp315 = (unsigned long )par;
#line 546
  __cil_tmp316 = __cil_tmp315 + 16;
#line 546
  __cil_tmp317 = (struct vmw_dma_buffer **)__cil_tmp316;
#line 546
  __cil_tmp318 = (struct ttm_buffer_object **)__cil_tmp317;
#line 546
  ttm_bo_unref(__cil_tmp318);
  }
  err_free: 
  {
#line 548
  __cil_tmp319 = (unsigned long )par;
#line 548
  __cil_tmp320 = __cil_tmp319 + 8;
#line 548
  __cil_tmp321 = *((void **)__cil_tmp320);
#line 548
  __cil_tmp322 = (void    *)__cil_tmp321;
#line 548
  vfree(__cil_tmp322);
#line 549
  framebuffer_release(info);
#line 550
  __cil_tmp323 = (unsigned long )vmw_priv___0;
#line 550
  __cil_tmp324 = __cil_tmp323 + 2600;
#line 550
  *((void **)__cil_tmp324) = (void *)0;
  }
#line 552
  return (ret);
}
}
#line 555 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  struct ttm_buffer_object *bo ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  struct ttm_buffer_object **__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_dma_buffer *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_bo_kmap_obj *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void *__cil_tmp26 ;
  void    *__cil_tmp27 ;

  {
  {
#line 561
  __cil_tmp5 = (unsigned long )vmw_priv___0;
#line 561
  __cil_tmp6 = __cil_tmp5 + 2600;
#line 561
  __cil_tmp7 = *((void **)__cil_tmp6);
#line 561
  if (! __cil_tmp7) {
#line 562
    return (0);
  } else {

  }
  }
  {
#line 564
  __cil_tmp8 = (unsigned long )vmw_priv___0;
#line 564
  __cil_tmp9 = __cil_tmp8 + 2600;
#line 564
  __cil_tmp10 = *((void **)__cil_tmp9);
#line 564
  info = (struct fb_info *)__cil_tmp10;
#line 565
  __cil_tmp11 = (unsigned long )info;
#line 565
  __cil_tmp12 = __cil_tmp11 + 1160;
#line 565
  __cil_tmp13 = *((void **)__cil_tmp12);
#line 565
  par = (struct vmw_fb_par *)__cil_tmp13;
#line 566
  __cil_tmp14 = & bo;
#line 566
  __cil_tmp15 = (unsigned long )par;
#line 566
  __cil_tmp16 = __cil_tmp15 + 16;
#line 566
  __cil_tmp17 = *((struct vmw_dma_buffer **)__cil_tmp16);
#line 566
  *__cil_tmp14 = (struct ttm_buffer_object *)__cil_tmp17;
#line 567
  __cil_tmp18 = (unsigned long )par;
#line 567
  __cil_tmp19 = __cil_tmp18 + 16;
#line 567
  __cil_tmp20 = (void *)0;
#line 567
  *((struct vmw_dma_buffer **)__cil_tmp19) = (struct vmw_dma_buffer *)__cil_tmp20;
#line 570
  fb_deferred_io_cleanup(info);
#line 571
  unregister_framebuffer(info);
#line 573
  __cil_tmp21 = (unsigned long )par;
#line 573
  __cil_tmp22 = __cil_tmp21 + 24;
#line 573
  __cil_tmp23 = (struct ttm_bo_kmap_obj *)__cil_tmp22;
#line 573
  ttm_bo_kunmap(__cil_tmp23);
#line 574
  ttm_bo_unref(& bo);
#line 576
  __cil_tmp24 = (unsigned long )par;
#line 576
  __cil_tmp25 = __cil_tmp24 + 8;
#line 576
  __cil_tmp26 = *((void **)__cil_tmp25);
#line 576
  __cil_tmp27 = (void    *)__cil_tmp26;
#line 576
  vfree(__cil_tmp27);
#line 577
  framebuffer_release(info);
  }
#line 579
  return (0);
}
}
#line 582 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct delayed_work *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct ttm_bo_kmap_obj *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct vmw_dma_buffer *__cil_tmp36 ;
  bool __cil_tmp37 ;

  {
  {
#line 588
  __cil_tmp8 = (unsigned long )vmw_priv___0;
#line 588
  __cil_tmp9 = __cil_tmp8 + 2600;
#line 588
  __cil_tmp10 = *((void **)__cil_tmp9);
#line 588
  if (! __cil_tmp10) {
#line 589
    return (-22);
  } else {

  }
  }
#line 591
  __cil_tmp11 = (unsigned long )vmw_priv___0;
#line 591
  __cil_tmp12 = __cil_tmp11 + 2600;
#line 591
  __cil_tmp13 = *((void **)__cil_tmp12);
#line 591
  info = (struct fb_info *)__cil_tmp13;
#line 592
  __cil_tmp14 = (unsigned long )info;
#line 592
  __cil_tmp15 = __cil_tmp14 + 1160;
#line 592
  __cil_tmp16 = *((void **)__cil_tmp15);
#line 592
  par = (struct vmw_fb_par *)__cil_tmp16;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 594
      __cil_tmp17 = (unsigned long )par;
#line 594
      __cil_tmp18 = __cil_tmp17 + 160;
#line 594
      __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 594
      tmp___7 = spinlock_check(__cil_tmp19);
#line 594
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 594
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 594
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  __cil_tmp20 = 160 + 24;
#line 595
  __cil_tmp21 = (unsigned long )par;
#line 595
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
#line 595
  *((bool *)__cil_tmp22) = (bool )0;
#line 596
  __cil_tmp23 = (unsigned long )par;
#line 596
  __cil_tmp24 = __cil_tmp23 + 160;
#line 596
  __cil_tmp25 = (spinlock_t *)__cil_tmp24;
#line 596
  spin_unlock_irqrestore(__cil_tmp25, flags);
#line 598
  __cil_tmp26 = (unsigned long )info;
#line 598
  __cil_tmp27 = __cil_tmp26 + 960;
#line 598
  __cil_tmp28 = (struct delayed_work *)__cil_tmp27;
#line 598
  flush_delayed_work_sync(__cil_tmp28);
#line 600
  __cil_tmp29 = (unsigned long )par;
#line 600
  __cil_tmp30 = __cil_tmp29 + 144;
#line 600
  *((void **)__cil_tmp30) = (void *)0;
#line 601
  __cil_tmp31 = (unsigned long )par;
#line 601
  __cil_tmp32 = __cil_tmp31 + 24;
#line 601
  __cil_tmp33 = (struct ttm_bo_kmap_obj *)__cil_tmp32;
#line 601
  ttm_bo_kunmap(__cil_tmp33);
#line 603
  __cil_tmp34 = (unsigned long )par;
#line 603
  __cil_tmp35 = __cil_tmp34 + 16;
#line 603
  __cil_tmp36 = *((struct vmw_dma_buffer **)__cil_tmp35);
#line 603
  __cil_tmp37 = (bool )0;
#line 603
  vmw_dmabuf_unpin(vmw_priv___0, __cil_tmp36, __cil_tmp37);
  }
#line 605
  return (0);
}
}
#line 608 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  bool dummy ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  raw_spinlock_t *tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_dma_buffer *__cil_tmp29 ;
  bool __cil_tmp30 ;
  bool __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_dma_buffer *__cil_tmp38 ;
  struct ttm_buffer_object *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_dma_buffer *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct ttm_bo_kmap_obj *__cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct ttm_bo_kmap_obj *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  spinlock_t *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  spinlock_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  __u32 __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  __u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct delayed_work *__cil_tmp77 ;

  {
  {
#line 616
  __cil_tmp12 = (unsigned long )vmw_priv___0;
#line 616
  __cil_tmp13 = __cil_tmp12 + 2600;
#line 616
  __cil_tmp14 = *((void **)__cil_tmp13);
#line 616
  if (! __cil_tmp14) {
#line 617
    return (-22);
  } else {

  }
  }
#line 619
  __cil_tmp15 = (unsigned long )vmw_priv___0;
#line 619
  __cil_tmp16 = __cil_tmp15 + 2600;
#line 619
  __cil_tmp17 = *((void **)__cil_tmp16);
#line 619
  info = (struct fb_info *)__cil_tmp17;
#line 620
  __cil_tmp18 = (unsigned long )info;
#line 620
  __cil_tmp19 = __cil_tmp18 + 1160;
#line 620
  __cil_tmp20 = *((void **)__cil_tmp19);
#line 620
  par = (struct vmw_fb_par *)__cil_tmp20;
  {
#line 623
  __cil_tmp21 = (void *)0;
#line 623
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 623
  __cil_tmp23 = (unsigned long )par;
#line 623
  __cil_tmp24 = __cil_tmp23 + 144;
#line 623
  __cil_tmp25 = *((void **)__cil_tmp24);
#line 623
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 623
  if (__cil_tmp26 != __cil_tmp22) {
#line 624
    return (0);
  } else {

  }
  }
  {
#line 627
  vmw_overlay_stop_all(vmw_priv___0);
#line 629
  __cil_tmp27 = (unsigned long )par;
#line 629
  __cil_tmp28 = __cil_tmp27 + 16;
#line 629
  __cil_tmp29 = *((struct vmw_dma_buffer **)__cil_tmp28);
#line 629
  __cil_tmp30 = (bool )1;
#line 629
  __cil_tmp31 = (bool )0;
#line 629
  ret = vmw_dmabuf_to_start_of_vram(vmw_priv___0, __cil_tmp29, __cil_tmp30, __cil_tmp31);
#line 630
  __cil_tmp32 = ret != 0;
#line 630
  __cil_tmp33 = ! __cil_tmp32;
#line 630
  __cil_tmp34 = ! __cil_tmp33;
#line 630
  __cil_tmp35 = (long )__cil_tmp34;
#line 630
  tmp___7 = ldv__builtin_expect(__cil_tmp35, 0L);
  }
#line 630
  if (tmp___7) {
    {
#line 631
    drm_err("vmw_fb_on", "could not move buffer to start of VRAM\n");
    }
#line 632
    goto err_no_buffer;
  } else {

  }
  {
#line 635
  __cil_tmp36 = (unsigned long )par;
#line 635
  __cil_tmp37 = __cil_tmp36 + 16;
#line 635
  __cil_tmp38 = *((struct vmw_dma_buffer **)__cil_tmp37);
#line 635
  __cil_tmp39 = (struct ttm_buffer_object *)__cil_tmp38;
#line 635
  __cil_tmp40 = 0 + 40;
#line 635
  __cil_tmp41 = (unsigned long )par;
#line 635
  __cil_tmp42 = __cil_tmp41 + 16;
#line 635
  __cil_tmp43 = *((struct vmw_dma_buffer **)__cil_tmp42);
#line 635
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 635
  __cil_tmp45 = __cil_tmp44 + __cil_tmp40;
#line 635
  __cil_tmp46 = *((unsigned long *)__cil_tmp45);
#line 635
  __cil_tmp47 = (unsigned long )par;
#line 635
  __cil_tmp48 = __cil_tmp47 + 24;
#line 635
  __cil_tmp49 = (struct ttm_bo_kmap_obj *)__cil_tmp48;
#line 635
  ret = ttm_bo_kmap(__cil_tmp39, 0UL, __cil_tmp46, __cil_tmp49);
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 639
    __cil_tmp50 = ret != 0;
#line 639
    __cil_tmp51 = ! __cil_tmp50;
#line 639
    __cil_tmp52 = ! __cil_tmp51;
#line 639
    __cil_tmp53 = (long )__cil_tmp52;
#line 639
    tmp___8 = ldv__builtin_expect(__cil_tmp53, 0L);
    }
#line 639
    if (tmp___8) {
      {
#line 639
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 639
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"),
                             "i" (639), "i" (12UL));
        {
#line 639
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 639
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 639
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  __cil_tmp54 = (unsigned long )par;
#line 640
  __cil_tmp55 = __cil_tmp54 + 144;
#line 640
  __cil_tmp56 = (unsigned long )par;
#line 640
  __cil_tmp57 = __cil_tmp56 + 24;
#line 640
  __cil_tmp58 = (struct ttm_bo_kmap_obj *)__cil_tmp57;
#line 640
  *((void **)__cil_tmp55) = ttm_kmap_obj_virtual(__cil_tmp58, & dummy);
  }
  {
#line 642
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 642
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 642
      __cil_tmp59 = (unsigned long )par;
#line 642
      __cil_tmp60 = __cil_tmp59 + 160;
#line 642
      __cil_tmp61 = (spinlock_t *)__cil_tmp60;
#line 642
      tmp___9 = spinlock_check(__cil_tmp61);
#line 642
      flags = _raw_spin_lock_irqsave(tmp___9);
      }
#line 642
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 642
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 643
  __cil_tmp62 = 160 + 24;
#line 643
  __cil_tmp63 = (unsigned long )par;
#line 643
  __cil_tmp64 = __cil_tmp63 + __cil_tmp62;
#line 643
  *((bool *)__cil_tmp64) = (bool )1;
#line 644
  __cil_tmp65 = (unsigned long )par;
#line 644
  __cil_tmp66 = __cil_tmp65 + 160;
#line 644
  __cil_tmp67 = (spinlock_t *)__cil_tmp66;
#line 644
  spin_unlock_irqrestore(__cil_tmp67, flags);
  }
  err_no_buffer: 
  {
#line 647
  vmw_fb_set_par(info);
#line 649
  __cil_tmp68 = (unsigned long )info;
#line 649
  __cil_tmp69 = __cil_tmp68 + 160;
#line 649
  __cil_tmp70 = *((__u32 *)__cil_tmp69);
#line 649
  __cil_tmp71 = 160 + 4;
#line 649
  __cil_tmp72 = (unsigned long )info;
#line 649
  __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
#line 649
  __cil_tmp74 = *((__u32 *)__cil_tmp73);
#line 649
  vmw_fb_dirty_mark(par, 0U, 0U, __cil_tmp70, __cil_tmp74);
#line 653
  __cil_tmp75 = (unsigned long )info;
#line 653
  __cil_tmp76 = __cil_tmp75 + 960;
#line 653
  __cil_tmp77 = (struct delayed_work *)__cil_tmp76;
#line 653
  schedule_delayed_work(__cil_tmp77, 0UL);
  }
#line 655
  return (0);
}
}
#line 689 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"
void ldv_main4_sequence_infinite_withcheck_stateful(void) 
{ struct fb_info *var_group1 ;
  struct list_head *var_group2 ;
  struct fb_var_screeninfo *var_group3 ;
  unsigned int var_vmw_fb_setcolreg_0_p0 ;
  unsigned int var_vmw_fb_setcolreg_0_p1 ;
  unsigned int var_vmw_fb_setcolreg_0_p2 ;
  unsigned int var_vmw_fb_setcolreg_0_p3 ;
  unsigned int var_vmw_fb_setcolreg_0_p4 ;
  struct fb_info *var_vmw_fb_setcolreg_0_p5 ;
  struct fb_fillrect    *var_vmw_fb_fillrect_8_p1 ;
  struct fb_copyarea    *var_vmw_fb_copyarea_9_p1 ;
  struct fb_image    *var_vmw_fb_imageblit_10_p1 ;
  int var_vmw_fb_blank_4_p0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 795
  LDV_IN_INTERRUPT = 1;
#line 804
  ldv_initialize();
  }
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 810
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 810
    if (tmp___8) {

    } else {
#line 810
      goto while_break;
    }
    {
#line 813
    tmp___7 = __VERIFIER_nondet_int();
    }
#line 815
    if (tmp___7 == 0) {
#line 815
      goto case_0;
    } else
#line 835
    if (tmp___7 == 1) {
#line 835
      goto case_1;
    } else
#line 857
    if (tmp___7 == 2) {
#line 857
      goto case_2;
    } else
#line 879
    if (tmp___7 == 3) {
#line 879
      goto case_3;
    } else
#line 901
    if (tmp___7 == 4) {
#line 901
      goto case_4;
    } else
#line 921
    if (tmp___7 == 5) {
#line 921
      goto case_5;
    } else
#line 941
    if (tmp___7 == 6) {
#line 941
      goto case_6;
    } else
#line 961
    if (tmp___7 == 7) {
#line 961
      goto case_7;
    } else
#line 983
    if (tmp___7 == 8) {
#line 983
      goto case_8;
    } else {
      {
#line 1005
      goto switch_default;
#line 813
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 827
        vmw_deferred_io(var_group1, var_group2);
        }
#line 834
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 845
        vmw_fb_check_var(var_group3, var_group1);
        }
#line 856
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 867
        vmw_fb_set_par(var_group1);
        }
#line 878
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 889
        vmw_fb_setcolreg(var_vmw_fb_setcolreg_0_p0, var_vmw_fb_setcolreg_0_p1, var_vmw_fb_setcolreg_0_p2,
                         var_vmw_fb_setcolreg_0_p3, var_vmw_fb_setcolreg_0_p4, var_vmw_fb_setcolreg_0_p5);
        }
#line 900
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 913
        vmw_fb_fillrect(var_group1, var_vmw_fb_fillrect_8_p1);
        }
#line 920
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 933
        vmw_fb_copyarea(var_group1, var_vmw_fb_copyarea_9_p1);
        }
#line 940
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 953
        vmw_fb_imageblit(var_group1, var_vmw_fb_imageblit_10_p1);
        }
#line 960
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 971
        vmw_fb_pan_display(var_group3, var_group1);
        }
#line 982
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 993
        vmw_fb_blank(var_vmw_fb_blank_4_p0, var_group1);
        }
#line 1004
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1005
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1014
  ldv_check_final_state();
  }
#line 1017
  return;
}
}
#line 208 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void  volatile   *src , size_t count )  __attribute__((__no_instrument_function__)) ;
#line 208 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void  volatile   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void    *__cil_tmp6 ;

  {
  {
#line 211
  __len = count;
#line 211
  __cil_tmp6 = (void    *)src;
#line 211
  __ret = __builtin_memcpy(dst, __cil_tmp6, __len);
  }
#line 212
  return;
}
}
#line 1305 "include/drm/drmP.h"
extern ssize_t drm_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
#line 1314
extern unsigned int drm_poll(struct file *filp , struct poll_table_struct *wait ) ;
#line 497 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) ;
#line 661
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) ;
#line 662
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) ;
#line 32 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_getparam_arg *param ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___11 ;
  __le32 *fifo_mem ;
  struct vmw_fifo_state    *fifo ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_fifo_state *__cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned int    __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t    __cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t __cil_tmp42 ;

  {
  {
#line 35
  tmp___7 = vmw_priv(dev);
#line 35
  dev_priv = tmp___7;
#line 36
  param = (struct drm_vmw_getparam_arg *)data;
  }
  {
#line 39
  __cil_tmp15 = (unsigned long )param;
#line 39
  __cil_tmp16 = __cil_tmp15 + 8;
#line 39
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
#line 40
  if ((int )__cil_tmp17 == 0) {
#line 40
    goto case_0;
  } else
#line 43
  if ((int )__cil_tmp17 == 1) {
#line 43
    goto case_1;
  } else
#line 46
  if ((int )__cil_tmp17 == 2) {
#line 46
    goto case_2;
  } else
#line 49
  if ((int )__cil_tmp17 == 3) {
#line 49
    goto case_3;
  } else
#line 52
  if ((int )__cil_tmp17 == 4) {
#line 52
    goto case_4;
  } else
#line 55
  if ((int )__cil_tmp17 == 5) {
#line 55
    goto case_5;
  } else
#line 58
  if ((int )__cil_tmp17 == 6) {
#line 58
    goto case_6;
  } else {
    {
#line 71
    goto switch_default;
#line 39
    if (0) {
      case_0: /* CIL Label */ 
      {
#line 41
      tmp___8 = vmw_overlay_num_overlays(dev_priv);
#line 41
      *((uint64_t *)param) = (uint64_t )tmp___8;
      }
#line 42
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 44
      tmp___9 = vmw_overlay_num_free_overlays(dev_priv);
#line 44
      *((uint64_t *)param) = (uint64_t )tmp___9;
      }
#line 45
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 47
      tmp___11 = vmw_fifo_have_3d(dev_priv);
      }
#line 47
      if (tmp___11) {
#line 47
        *((uint64_t *)param) = (uint64_t )1;
      } else {
#line 47
        *((uint64_t *)param) = (uint64_t )0;
      }
#line 48
      goto switch_break;
      case_3: /* CIL Label */ 
#line 50
      __cil_tmp18 = (unsigned long )dev_priv;
#line 50
      __cil_tmp19 = __cil_tmp18 + 2156;
#line 50
      __cil_tmp20 = *((uint32_t *)__cil_tmp19);
#line 50
      *((uint64_t *)param) = (uint64_t )__cil_tmp20;
#line 51
      goto switch_break;
      case_4: /* CIL Label */ 
#line 53
      __cil_tmp21 = 1856 + 36;
#line 53
      __cil_tmp22 = (unsigned long )dev_priv;
#line 53
      __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 53
      __cil_tmp24 = *((uint32_t *)__cil_tmp23);
#line 53
      *((uint64_t *)param) = (uint64_t )__cil_tmp24;
#line 54
      goto switch_break;
      case_5: /* CIL Label */ 
#line 56
      __cil_tmp25 = (unsigned long )dev_priv;
#line 56
      __cil_tmp26 = __cil_tmp25 + 2112;
#line 56
      __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 56
      *((uint64_t *)param) = (uint64_t )__cil_tmp27;
#line 57
      goto switch_break;
      case_6: /* CIL Label */ 
#line 60
      __cil_tmp28 = (unsigned long )dev_priv;
#line 60
      __cil_tmp29 = __cil_tmp28 + 2144;
#line 60
      fifo_mem = *((__le32 **)__cil_tmp29);
#line 61
      __cil_tmp30 = (unsigned long )dev_priv;
#line 61
      __cil_tmp31 = __cil_tmp30 + 1856;
#line 61
      __cil_tmp32 = (struct vmw_fifo_state *)__cil_tmp31;
#line 61
      fifo = (struct vmw_fifo_state    *)__cil_tmp32;
      {
#line 63
      __cil_tmp33 = 1 << 8;
#line 63
      __cil_tmp34 = (unsigned int    )__cil_tmp33;
#line 63
      __cil_tmp35 = (unsigned long )fifo;
#line 63
      __cil_tmp36 = __cil_tmp35 + 36;
#line 63
      __cil_tmp37 = *((uint32_t    *)__cil_tmp36);
#line 63
      if (__cil_tmp37 & __cil_tmp34) {
#line 63
        tmp___12 = 17;
      } else {
#line 63
        tmp___12 = 7;
      }
      }
      {
#line 63
      __cil_tmp38 = fifo_mem + tmp___12;
#line 63
      __cil_tmp39 = (void *)__cil_tmp38;
#line 63
      tmp___13 = ioread32(__cil_tmp39);
#line 63
      *((uint64_t *)param) = (uint64_t )tmp___13;
      }
#line 69
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 72
      __cil_tmp40 = (unsigned long )param;
#line 72
      __cil_tmp41 = __cil_tmp40 + 8;
#line 72
      __cil_tmp42 = *((uint32_t *)__cil_tmp41);
#line 72
      drm_err("vmw_getparam_ioctl", "Illegal vmwgfx get param request: %d\n", __cil_tmp42);
      }
#line 74
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  }
#line 77
  return (0);
}
}
#line 81 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_get_3d_cap_arg *arg ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t size ;
  __le32 *fifo_mem ;
  void *buffer ;
  void *bounce ;
  int ret ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint64_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void  volatile   *__cil_tmp41 ;
  size_t __cil_tmp42 ;
  void    *__cil_tmp43 ;
  void    *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;

  {
  {
#line 84
  arg = (struct drm_vmw_get_3d_cap_arg *)data;
#line 86
  tmp___7 = vmw_priv(dev);
#line 86
  dev_priv = tmp___7;
#line 89
  __cil_tmp15 = *((uint64_t *)arg);
#line 89
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 89
  buffer = (void *)__cil_tmp16;
#line 93
  __cil_tmp17 = (unsigned long )arg;
#line 93
  __cil_tmp18 = __cil_tmp17 + 12;
#line 93
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 93
  __cil_tmp20 = __cil_tmp19 != 0U;
#line 93
  __cil_tmp21 = ! __cil_tmp20;
#line 93
  __cil_tmp22 = ! __cil_tmp21;
#line 93
  __cil_tmp23 = (long )__cil_tmp22;
#line 93
  tmp___8 = ldv__builtin_expect(__cil_tmp23, 0L);
  }
#line 93
  if (tmp___8) {
    {
#line 94
    drm_err("vmw_get_cap_3d_ioctl", "Illegal GET_3D_CAP argument.\n");
    }
#line 95
    return (-22);
  } else {

  }
#line 98
  __cil_tmp24 = 256 << 2;
#line 98
  size = (uint32_t )__cil_tmp24;
  {
#line 100
  __cil_tmp25 = (unsigned long )arg;
#line 100
  __cil_tmp26 = __cil_tmp25 + 8;
#line 100
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 100
  if (__cil_tmp27 < size) {
#line 101
    __cil_tmp28 = (unsigned long )arg;
#line 101
    __cil_tmp29 = __cil_tmp28 + 8;
#line 101
    size = *((uint32_t *)__cil_tmp29);
  } else {

  }
  }
  {
#line 103
  __cil_tmp30 = (unsigned long )size;
#line 103
  bounce = vmalloc(__cil_tmp30);
#line 104
  __cil_tmp31 = (void *)0;
#line 104
  __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 104
  __cil_tmp33 = (unsigned long )bounce;
#line 104
  __cil_tmp34 = __cil_tmp33 == __cil_tmp32;
#line 104
  __cil_tmp35 = ! __cil_tmp34;
#line 104
  __cil_tmp36 = ! __cil_tmp35;
#line 104
  __cil_tmp37 = (long )__cil_tmp36;
#line 104
  tmp___9 = ldv__builtin_expect(__cil_tmp37, 0L);
  }
#line 104
  if (tmp___9) {
    {
#line 105
    drm_err("vmw_get_cap_3d_ioctl", "Failed to allocate bounce buffer for 3D caps.\n");
    }
#line 106
    return (-12);
  } else {

  }
  {
#line 109
  __cil_tmp38 = (unsigned long )dev_priv;
#line 109
  __cil_tmp39 = __cil_tmp38 + 2144;
#line 109
  fifo_mem = *((__le32 **)__cil_tmp39);
#line 110
  __cil_tmp40 = fifo_mem + 32;
#line 110
  __cil_tmp41 = (void  volatile   *)__cil_tmp40;
#line 110
  __cil_tmp42 = (size_t )size;
#line 110
  memcpy_fromio(bounce, __cil_tmp41, __cil_tmp42);
#line 112
  __cil_tmp43 = (void    *)bounce;
#line 112
  ret = (int )copy_to_user(buffer, __cil_tmp43, size);
#line 113
  __cil_tmp44 = (void    *)bounce;
#line 113
  vfree(__cil_tmp44);
#line 115
  __cil_tmp45 = ret != 0;
#line 115
  __cil_tmp46 = ! __cil_tmp45;
#line 115
  __cil_tmp47 = ! __cil_tmp46;
#line 115
  __cil_tmp48 = (long )__cil_tmp47;
#line 115
  tmp___10 = ldv__builtin_expect(__cil_tmp48, 0L);
  }
#line 115
  if (tmp___10) {
    {
#line 116
    drm_err("vmw_get_cap_3d_ioctl", "Failed to report 3D caps info.\n");
    }
  } else {

  }
#line 118
  return (ret);
}
}
#line 121 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct drm_vmw_present_arg *arg ;
  struct vmw_surface *surface ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___10 ;
  void *tmp___11 ;
  unsigned long tmp___12 ;
  long tmp___13 ;
  struct drm_framebuffer    *__mptr ;
  struct drm_mode_object    *__mptr___0 ;
  long tmp___14 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint64_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  size_t __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void    *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  struct drm_framebuffer *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_mode_object *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  struct drm_framebuffer *__cil_tmp67 ;
  struct vmw_framebuffer *__cil_tmp68 ;
  struct drm_framebuffer *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  struct ttm_lock *__cil_tmp73 ;
  bool __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  uint32_t __cil_tmp81 ;
  struct vmw_surface **__cil_tmp82 ;
  struct vmw_surface *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  int32_t __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  int32_t __cil_tmp92 ;
  struct ttm_lock *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct mutex *__cil_tmp96 ;
  void    *__cil_tmp97 ;

  {
  {
#line 124
  tmp___7 = vmw_fpriv(file_priv);
#line 124
  __cil_tmp25 = (unsigned long )tmp___7;
#line 124
  __cil_tmp26 = __cil_tmp25 + 8;
#line 124
  tfile = *((struct ttm_object_file **)__cil_tmp26);
#line 125
  tmp___8 = vmw_priv(dev);
#line 125
  dev_priv = tmp___8;
#line 126
  arg = (struct drm_vmw_present_arg *)data;
#line 129
  __cil_tmp27 = (unsigned long )file_priv;
#line 129
  __cil_tmp28 = __cil_tmp27 + 152;
#line 129
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
#line 129
  tmp___9 = vmw_master(__cil_tmp29);
#line 129
  vmaster = tmp___9;
#line 131
  __cil_tmp30 = (void *)0;
#line 131
  clips = (struct drm_vmw_rect *)__cil_tmp30;
#line 137
  __cil_tmp31 = (unsigned long )arg;
#line 137
  __cil_tmp32 = __cil_tmp31 + 24;
#line 137
  num_clips = *((uint32_t *)__cil_tmp32);
#line 138
  __cil_tmp33 = (unsigned long )arg;
#line 138
  __cil_tmp34 = __cil_tmp33 + 16;
#line 138
  __cil_tmp35 = *((uint64_t *)__cil_tmp34);
#line 138
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 138
  clips_ptr = (struct drm_vmw_rect *)__cil_tmp36;
#line 140
  __cil_tmp37 = num_clips == 0U;
#line 140
  __cil_tmp38 = ! __cil_tmp37;
#line 140
  __cil_tmp39 = ! __cil_tmp38;
#line 140
  __cil_tmp40 = (long )__cil_tmp39;
#line 140
  tmp___10 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 140
  if (tmp___10) {
#line 141
    return (0);
  } else {

  }
  {
#line 143
  __cil_tmp41 = (void *)0;
#line 143
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 143
  __cil_tmp43 = (unsigned long )clips_ptr;
#line 143
  if (__cil_tmp43 == __cil_tmp42) {
    {
#line 144
    drm_err("vmw_present_ioctl", "Variable clips_ptr must be specified.\n");
#line 145
    ret = -22;
    }
#line 146
    goto out_clips;
  } else {

  }
  }
  {
#line 149
  __cil_tmp44 = (size_t )num_clips;
#line 149
  tmp___11 = kcalloc(__cil_tmp44, 16UL, 208U);
#line 149
  clips = (struct drm_vmw_rect *)tmp___11;
  }
  {
#line 150
  __cil_tmp45 = (void *)0;
#line 150
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 150
  __cil_tmp47 = (unsigned long )clips;
#line 150
  if (__cil_tmp47 == __cil_tmp46) {
    {
#line 151
    drm_err("vmw_present_ioctl", "Failed to allocate clip rect list.\n");
#line 152
    ret = -12;
    }
#line 153
    goto out_clips;
  } else {

  }
  }
  {
#line 156
  __cil_tmp48 = (void *)clips;
#line 156
  __cil_tmp49 = (void    *)clips_ptr;
#line 156
  __cil_tmp50 = (unsigned long )num_clips;
#line 156
  __cil_tmp51 = __cil_tmp50 * 16UL;
#line 156
  tmp___12 = (unsigned long )copy_from_user(__cil_tmp48, __cil_tmp49, __cil_tmp51);
#line 156
  ret = (int )tmp___12;
  }
#line 157
  if (ret) {
    {
#line 158
    drm_err("vmw_present_ioctl", "Failed to copy clip rects from userspace.\n");
#line 159
    ret = -14;
    }
#line 160
    goto out_no_mode_mutex;
  } else {

  }
  {
#line 163
  __cil_tmp52 = (unsigned long )dev;
#line 163
  __cil_tmp53 = __cil_tmp52 + 1152;
#line 163
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
#line 163
  ret = (int )mutex_lock_interruptible(__cil_tmp54);
#line 164
  __cil_tmp55 = ret != 0;
#line 164
  __cil_tmp56 = ! __cil_tmp55;
#line 164
  __cil_tmp57 = ! __cil_tmp56;
#line 164
  __cil_tmp58 = (long )__cil_tmp57;
#line 164
  tmp___13 = ldv__builtin_expect(__cil_tmp58, 0L);
  }
#line 164
  if (tmp___13) {
#line 165
    ret = -512;
#line 166
    goto out_no_mode_mutex;
  } else {

  }
  {
#line 169
  __cil_tmp59 = *((uint32_t *)arg);
#line 169
  obj = drm_mode_object_find(dev, __cil_tmp59, 4227595259U);
  }
#line 170
  if (! obj) {
    {
#line 171
    drm_err("vmw_present_ioctl", "Invalid framebuffer id.\n");
#line 172
    ret = -22;
    }
#line 173
    goto out_no_ttm_lock;
  } else {

  }
  {
#line 175
  __mptr___0 = (struct drm_mode_object    *)obj;
#line 175
  __cil_tmp60 = (struct drm_framebuffer *)0;
#line 175
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 175
  __cil_tmp62 = __cil_tmp61 + 24;
#line 175
  __cil_tmp63 = (struct drm_mode_object *)__cil_tmp62;
#line 175
  __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 175
  __cil_tmp65 = (char *)__mptr___0;
#line 175
  __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
#line 175
  __cil_tmp67 = (struct drm_framebuffer *)__cil_tmp66;
#line 175
  __mptr = (struct drm_framebuffer    *)__cil_tmp67;
#line 175
  __cil_tmp68 = (struct vmw_framebuffer *)0;
#line 175
  __cil_tmp69 = (struct drm_framebuffer *)__cil_tmp68;
#line 175
  __cil_tmp70 = (unsigned int )__cil_tmp69;
#line 175
  __cil_tmp71 = (char *)__mptr;
#line 175
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
#line 175
  vfb = (struct vmw_framebuffer *)__cil_tmp72;
#line 177
  __cil_tmp73 = (struct ttm_lock *)vmaster;
#line 177
  __cil_tmp74 = (bool )1;
#line 177
  ret = ttm_read_lock(__cil_tmp73, __cil_tmp74);
#line 178
  __cil_tmp75 = ret != 0;
#line 178
  __cil_tmp76 = ! __cil_tmp75;
#line 178
  __cil_tmp77 = ! __cil_tmp76;
#line 178
  __cil_tmp78 = (long )__cil_tmp77;
#line 178
  tmp___14 = ldv__builtin_expect(__cil_tmp78, 0L);
  }
#line 178
  if (tmp___14) {
#line 179
    goto out_no_ttm_lock;
  } else {

  }
  {
#line 181
  __cil_tmp79 = (unsigned long )arg;
#line 181
  __cil_tmp80 = __cil_tmp79 + 4;
#line 181
  __cil_tmp81 = *((uint32_t *)__cil_tmp80);
#line 181
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, __cil_tmp81, & surface);
  }
#line 183
  if (ret) {
#line 184
    goto out_no_surface;
  } else {

  }
  {
#line 186
  __cil_tmp82 = & surface;
#line 186
  __cil_tmp83 = *__cil_tmp82;
#line 186
  __cil_tmp84 = (unsigned long )arg;
#line 186
  __cil_tmp85 = __cil_tmp84 + 4;
#line 186
  __cil_tmp86 = *((uint32_t *)__cil_tmp85);
#line 186
  __cil_tmp87 = (unsigned long )arg;
#line 186
  __cil_tmp88 = __cil_tmp87 + 8;
#line 186
  __cil_tmp89 = *((int32_t *)__cil_tmp88);
#line 186
  __cil_tmp90 = (unsigned long )arg;
#line 186
  __cil_tmp91 = __cil_tmp90 + 12;
#line 186
  __cil_tmp92 = *((int32_t *)__cil_tmp91);
#line 186
  ret = vmw_kms_present(dev_priv, file_priv, vfb, __cil_tmp83, __cil_tmp86, __cil_tmp89,
                        __cil_tmp92, clips, num_clips);
#line 192
  vmw_surface_unreference(& surface);
  }
  out_no_surface: 
  {
#line 195
  __cil_tmp93 = (struct ttm_lock *)vmaster;
#line 195
  ttm_read_unlock(__cil_tmp93);
  }
  out_no_ttm_lock: 
  {
#line 198
  __cil_tmp94 = (unsigned long )dev;
#line 198
  __cil_tmp95 = __cil_tmp94 + 1152;
#line 198
  __cil_tmp96 = (struct mutex *)__cil_tmp95;
#line 198
  mutex_unlock(__cil_tmp96);
  }
  out_no_mode_mutex: 
  {
#line 201
  __cil_tmp97 = (void    *)clips;
#line 201
  kfree(__cil_tmp97);
  }
  out_clips: 
#line 203
  return (ret);
}
}
#line 206 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_present_readback_arg *arg ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___9 ;
  void *tmp___10 ;
  unsigned long tmp___11 ;
  long tmp___12 ;
  struct drm_framebuffer    *__mptr ;
  struct drm_mode_object    *__mptr___0 ;
  long tmp___13 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint64_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint64_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  size_t __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void    *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  struct drm_framebuffer *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_mode_object *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  struct drm_framebuffer *__cil_tmp67 ;
  struct vmw_framebuffer *__cil_tmp68 ;
  struct drm_framebuffer *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  bool __cil_tmp75 ;
  struct ttm_lock *__cil_tmp76 ;
  bool __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  long __cil_tmp81 ;
  struct ttm_lock *__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct mutex *__cil_tmp85 ;
  void    *__cil_tmp86 ;

  {
  {
#line 209
  tmp___7 = vmw_priv(dev);
#line 209
  dev_priv = tmp___7;
#line 210
  arg = (struct drm_vmw_present_readback_arg *)data;
#line 212
  __cil_tmp23 = (unsigned long )arg;
#line 212
  __cil_tmp24 = __cil_tmp23 + 16;
#line 212
  __cil_tmp25 = *((uint64_t *)__cil_tmp24);
#line 212
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 212
  user_fence_rep = (struct drm_vmw_fence_rep *)__cil_tmp26;
#line 215
  __cil_tmp27 = (unsigned long )file_priv;
#line 215
  __cil_tmp28 = __cil_tmp27 + 152;
#line 215
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
#line 215
  tmp___8 = vmw_master(__cil_tmp29);
#line 215
  vmaster = tmp___8;
#line 217
  __cil_tmp30 = (void *)0;
#line 217
  clips = (struct drm_vmw_rect *)__cil_tmp30;
#line 223
  __cil_tmp31 = (unsigned long )arg;
#line 223
  __cil_tmp32 = __cil_tmp31 + 4;
#line 223
  num_clips = *((uint32_t *)__cil_tmp32);
#line 224
  __cil_tmp33 = (unsigned long )arg;
#line 224
  __cil_tmp34 = __cil_tmp33 + 8;
#line 224
  __cil_tmp35 = *((uint64_t *)__cil_tmp34);
#line 224
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 224
  clips_ptr = (struct drm_vmw_rect *)__cil_tmp36;
#line 226
  __cil_tmp37 = num_clips == 0U;
#line 226
  __cil_tmp38 = ! __cil_tmp37;
#line 226
  __cil_tmp39 = ! __cil_tmp38;
#line 226
  __cil_tmp40 = (long )__cil_tmp39;
#line 226
  tmp___9 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 226
  if (tmp___9) {
#line 227
    return (0);
  } else {

  }
  {
#line 229
  __cil_tmp41 = (void *)0;
#line 229
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 229
  __cil_tmp43 = (unsigned long )clips_ptr;
#line 229
  if (__cil_tmp43 == __cil_tmp42) {
    {
#line 230
    drm_err("vmw_present_readback_ioctl", "Argument clips_ptr must be specified.\n");
#line 231
    ret = -22;
    }
#line 232
    goto out_clips;
  } else {

  }
  }
  {
#line 235
  __cil_tmp44 = (size_t )num_clips;
#line 235
  tmp___10 = kcalloc(__cil_tmp44, 16UL, 208U);
#line 235
  clips = (struct drm_vmw_rect *)tmp___10;
  }
  {
#line 236
  __cil_tmp45 = (void *)0;
#line 236
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 236
  __cil_tmp47 = (unsigned long )clips;
#line 236
  if (__cil_tmp47 == __cil_tmp46) {
    {
#line 237
    drm_err("vmw_present_readback_ioctl", "Failed to allocate clip rect list.\n");
#line 238
    ret = -12;
    }
#line 239
    goto out_clips;
  } else {

  }
  }
  {
#line 242
  __cil_tmp48 = (void *)clips;
#line 242
  __cil_tmp49 = (void    *)clips_ptr;
#line 242
  __cil_tmp50 = (unsigned long )num_clips;
#line 242
  __cil_tmp51 = __cil_tmp50 * 16UL;
#line 242
  tmp___11 = (unsigned long )copy_from_user(__cil_tmp48, __cil_tmp49, __cil_tmp51);
#line 242
  ret = (int )tmp___11;
  }
#line 243
  if (ret) {
    {
#line 244
    drm_err("vmw_present_readback_ioctl", "Failed to copy clip rects from userspace.\n");
#line 245
    ret = -14;
    }
#line 246
    goto out_no_mode_mutex;
  } else {

  }
  {
#line 249
  __cil_tmp52 = (unsigned long )dev;
#line 249
  __cil_tmp53 = __cil_tmp52 + 1152;
#line 249
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
#line 249
  ret = (int )mutex_lock_interruptible(__cil_tmp54);
#line 250
  __cil_tmp55 = ret != 0;
#line 250
  __cil_tmp56 = ! __cil_tmp55;
#line 250
  __cil_tmp57 = ! __cil_tmp56;
#line 250
  __cil_tmp58 = (long )__cil_tmp57;
#line 250
  tmp___12 = ldv__builtin_expect(__cil_tmp58, 0L);
  }
#line 250
  if (tmp___12) {
#line 251
    ret = -512;
#line 252
    goto out_no_mode_mutex;
  } else {

  }
  {
#line 255
  __cil_tmp59 = *((uint32_t *)arg);
#line 255
  obj = drm_mode_object_find(dev, __cil_tmp59, 4227595259U);
  }
#line 256
  if (! obj) {
    {
#line 257
    drm_err("vmw_present_readback_ioctl", "Invalid framebuffer id.\n");
#line 258
    ret = -22;
    }
#line 259
    goto out_no_ttm_lock;
  } else {

  }
#line 262
  __mptr___0 = (struct drm_mode_object    *)obj;
#line 262
  __cil_tmp60 = (struct drm_framebuffer *)0;
#line 262
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 262
  __cil_tmp62 = __cil_tmp61 + 24;
#line 262
  __cil_tmp63 = (struct drm_mode_object *)__cil_tmp62;
#line 262
  __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 262
  __cil_tmp65 = (char *)__mptr___0;
#line 262
  __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
#line 262
  __cil_tmp67 = (struct drm_framebuffer *)__cil_tmp66;
#line 262
  __mptr = (struct drm_framebuffer    *)__cil_tmp67;
#line 262
  __cil_tmp68 = (struct vmw_framebuffer *)0;
#line 262
  __cil_tmp69 = (struct drm_framebuffer *)__cil_tmp68;
#line 262
  __cil_tmp70 = (unsigned int )__cil_tmp69;
#line 262
  __cil_tmp71 = (char *)__mptr;
#line 262
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
#line 262
  vfb = (struct vmw_framebuffer *)__cil_tmp72;
  {
#line 263
  __cil_tmp73 = (unsigned long )vfb;
#line 263
  __cil_tmp74 = __cil_tmp73 + 136;
#line 263
  __cil_tmp75 = *((bool *)__cil_tmp74);
#line 263
  if (! __cil_tmp75) {
    {
#line 264
    drm_err("vmw_present_readback_ioctl", "Framebuffer not dmabuf backed.\n");
#line 265
    ret = -22;
    }
#line 266
    goto out_no_ttm_lock;
  } else {

  }
  }
  {
#line 269
  __cil_tmp76 = (struct ttm_lock *)vmaster;
#line 269
  __cil_tmp77 = (bool )1;
#line 269
  ret = ttm_read_lock(__cil_tmp76, __cil_tmp77);
#line 270
  __cil_tmp78 = ret != 0;
#line 270
  __cil_tmp79 = ! __cil_tmp78;
#line 270
  __cil_tmp80 = ! __cil_tmp79;
#line 270
  __cil_tmp81 = (long )__cil_tmp80;
#line 270
  tmp___13 = ldv__builtin_expect(__cil_tmp81, 0L);
  }
#line 270
  if (tmp___13) {
#line 271
    goto out_no_ttm_lock;
  } else {

  }
  {
#line 273
  ret = vmw_kms_readback(dev_priv, file_priv, vfb, user_fence_rep, clips, num_clips);
#line 277
  __cil_tmp82 = (struct ttm_lock *)vmaster;
#line 277
  ttm_read_unlock(__cil_tmp82);
  }
  out_no_ttm_lock: 
  {
#line 280
  __cil_tmp83 = (unsigned long )dev;
#line 280
  __cil_tmp84 = __cil_tmp83 + 1152;
#line 280
  __cil_tmp85 = (struct mutex *)__cil_tmp84;
#line 280
  mutex_unlock(__cil_tmp85);
  }
  out_no_mode_mutex: 
  {
#line 283
  __cil_tmp86 = (void    *)clips;
#line 283
  kfree(__cil_tmp86);
  }
  out_clips: 
#line 285
  return (ret);
}
}
#line 298 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct drm_minor *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_device *__cil_tmp15 ;
  uint32_t __cil_tmp16 ;

  {
  {
#line 300
  __cil_tmp7 = (unsigned long )filp;
#line 300
  __cil_tmp8 = __cil_tmp7 + 200;
#line 300
  __cil_tmp9 = *((void **)__cil_tmp8);
#line 300
  file_priv = (struct drm_file *)__cil_tmp9;
#line 301
  __cil_tmp10 = (unsigned long )file_priv;
#line 301
  __cil_tmp11 = __cil_tmp10 + 40;
#line 301
  __cil_tmp12 = *((struct drm_minor **)__cil_tmp11);
#line 301
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 301
  __cil_tmp14 = __cil_tmp13 + 784;
#line 301
  __cil_tmp15 = *((struct drm_device **)__cil_tmp14);
#line 301
  tmp___7 = vmw_priv(__cil_tmp15);
#line 301
  dev_priv = tmp___7;
#line 304
  __cil_tmp16 = (uint32_t )1;
#line 304
  vmw_fifo_ping_host(dev_priv, __cil_tmp16);
#line 305
  tmp___8 = drm_poll(filp, wait);
  }
#line 305
  return (tmp___8);
}
}
#line 320 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c"
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  ssize_t tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct drm_minor *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct drm_device *__cil_tmp17 ;
  uint32_t __cil_tmp18 ;

  {
  {
#line 323
  __cil_tmp9 = (unsigned long )filp;
#line 323
  __cil_tmp10 = __cil_tmp9 + 200;
#line 323
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 323
  file_priv = (struct drm_file *)__cil_tmp11;
#line 324
  __cil_tmp12 = (unsigned long )file_priv;
#line 324
  __cil_tmp13 = __cil_tmp12 + 40;
#line 324
  __cil_tmp14 = *((struct drm_minor **)__cil_tmp13);
#line 324
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 324
  __cil_tmp16 = __cil_tmp15 + 784;
#line 324
  __cil_tmp17 = *((struct drm_device **)__cil_tmp16);
#line 324
  tmp___7 = vmw_priv(__cil_tmp17);
#line 324
  dev_priv = tmp___7;
#line 327
  __cil_tmp18 = (uint32_t )1;
#line 327
  vmw_fifo_ping_host(dev_priv, __cil_tmp18);
#line 328
  tmp___8 = drm_read(filp, buffer, count, offset);
  }
#line 328
  return (tmp___8);
}
}
#line 77 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 77 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
#line 81
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (*((int *)v)), "=qm" (c): "ir" (i): "memory");
#line 84
  return ((int )c);
}
}
#line 18 "include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 19
extern void _raw_write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 30
extern void _raw_read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 31
extern void _raw_write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 30 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
#line 30 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ atomic_t *__cil_tmp2 ;

  {
  {
#line 32
  __cil_tmp2 = (atomic_t *)kref;
#line 32
  atomic_set(__cil_tmp2, 1);
  }
#line 33
  return;
}
}
#line 63
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
#line 63 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) ) 
{ int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  int    __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  atomic_t *__cil_tmp20 ;

  {
  {
#line 66
  __cil_tmp7 = (void *)0;
#line 66
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 66
  __cil_tmp9 = (unsigned long )release;
#line 66
  __cil_tmp10 = __cil_tmp9 == __cil_tmp8;
#line 66
  __cil_tmp11 = ! __cil_tmp10;
#line 66
  __ret_warn_on = ! __cil_tmp11;
#line 66
  __cil_tmp12 = ! __ret_warn_on;
#line 66
  __cil_tmp13 = ! __cil_tmp12;
#line 66
  __cil_tmp14 = (long )__cil_tmp13;
#line 66
  tmp = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 66
  if (tmp) {
    {
#line 66
    __cil_tmp15 = (int    )66;
#line 66
    warn_slowpath_null("include/linux/kref.h", __cil_tmp15);
    }
  } else {

  }
  {
#line 66
  __cil_tmp16 = ! __ret_warn_on;
#line 66
  __cil_tmp17 = ! __cil_tmp16;
#line 66
  __cil_tmp18 = (long )__cil_tmp17;
#line 66
  ldv__builtin_expect(__cil_tmp18, 0L);
#line 68
  __cil_tmp19 = (int )count;
#line 68
  __cil_tmp20 = (atomic_t *)kref;
#line 68
  tmp___0 = atomic_sub_and_test(__cil_tmp19, __cil_tmp20);
  }
#line 68
  if (tmp___0) {
    {
#line 69
    (*release)(kref);
    }
#line 70
    return (1);
  } else {

  }
#line 72
  return (0);
}
}
#line 92
__inline static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
#line 92 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) 
{ int tmp ;

  {
  {
#line 94
  tmp = kref_sub(kref, 1U, release);
  }
#line 94
  return (tmp);
}
}
#line 104 "include/linux/idr.h"
extern void *idr_find(struct idr *idp , int id ) ;
#line 105
extern int idr_pre_get(struct idr *idp , gfp_t gfp_mask ) ;
#line 107
extern int idr_get_new_above(struct idr *idp , void *ptr , int starting_id , int *id ) ;
#line 112
extern void idr_remove(struct idr *idp , int id ) ;
#line 453 "include/drm/ttm/ttm_bo_api.h"
extern size_t ttm_bo_acc_size(struct ttm_bo_device *bdev , unsigned long bo_size ,
                              unsigned int struct_size ) ;
#line 496
extern int ttm_bo_init(struct ttm_bo_device *bdev , struct ttm_buffer_object *bo ,
                       unsigned long size , enum ttm_bo_type type , struct ttm_placement *placement ,
                       uint32_t page_alignment , unsigned long buffer_start , bool interrubtible ,
                       struct file *persistent_swap_storage , size_t acc_size , void (*destroy)(struct ttm_buffer_object * ) ) ;
#line 150 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_alloc(struct ttm_mem_global *glob , uint64_t memory , bool no_wait ,
                                bool interruptible ) ;
#line 152
extern void ttm_mem_global_free(struct ttm_mem_global *glob , uint64_t amount ) ;
#line 159
extern size_t ttm_round_pot(size_t size ) ;
#line 147 "include/drm/ttm/ttm_object.h"
extern int ttm_base_object_init(struct ttm_object_file *tfile , struct ttm_base_object *base ,
                                bool shareable , enum ttm_object_type type , void (*refcount_release)(struct ttm_base_object ** ) ,
                                void (*ref_obj_release)(struct ttm_base_object * ,
                                                        enum ttm_ref_type ref_type ) ) ;
#line 202
extern int ttm_ref_object_add(struct ttm_object_file *tfile , struct ttm_base_object *base ,
                              enum ttm_ref_type ref_type , bool *existed ) ;
#line 385 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) ;
#line 401
void vmw_surface_res_free(struct vmw_resource *res ) ;
#line 402
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource *res ) ) ;
#line 415
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) ;
#line 439
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) ;
#line 464
void vmw_bo_get_guest_ptr(struct ttm_buffer_object    *bo , SVGAGuestPtr *ptr ) ;
#line 522
struct ttm_placement vmw_srf_placement ;
#line 659
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) ;
#line 660
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) ;
#line 705
__inline static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv )  __attribute__((__no_instrument_function__)) ;
#line 705 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 707
  __cil_tmp2 = 1816 + 16;
#line 707
  __cil_tmp3 = (unsigned long )dev_priv;
#line 707
  __cil_tmp4 = __cil_tmp3 + __cil_tmp2;
#line 707
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 707
  return ((struct ttm_mem_global *)__cil_tmp5);
  }
}
}
#line 72 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static uint64_t vmw_user_context_size  ;
#line 73 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static uint64_t vmw_user_surface_size  ;
#line 74 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static uint64_t vmw_user_stream_size  ;
#line 76
__inline static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
#line 76 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
__inline static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct ttm_buffer_object    *__mptr ;
  struct vmw_dma_buffer *__cil_tmp3 ;
  struct ttm_buffer_object *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 79
  __mptr = (struct ttm_buffer_object    *)bo;
  {
#line 79
  __cil_tmp3 = (struct vmw_dma_buffer *)0;
#line 79
  __cil_tmp4 = (struct ttm_buffer_object *)__cil_tmp3;
#line 79
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 79
  __cil_tmp6 = (char *)__mptr;
#line 79
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
#line 79
  return ((struct vmw_dma_buffer *)__cil_tmp7);
  }
}
}
#line 82
__inline static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
#line 82 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
__inline static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  struct vmw_dma_buffer    *__mptr ;
  struct vmw_user_dma_buffer *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct vmw_dma_buffer *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 85
  tmp___7 = vmw_dma_buffer(bo);
#line 85
  vmw_bo = tmp___7;
#line 86
  __mptr = (struct vmw_dma_buffer    *)vmw_bo;
  }
  {
#line 86
  __cil_tmp5 = (struct vmw_user_dma_buffer *)0;
#line 86
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 86
  __cil_tmp7 = __cil_tmp6 + 64;
#line 86
  __cil_tmp8 = (struct vmw_dma_buffer *)__cil_tmp7;
#line 86
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 86
  __cil_tmp10 = (char *)__mptr;
#line 86
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 86
  return ((struct vmw_user_dma_buffer *)__cil_tmp11);
  }
}
}
#line 89 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) 
{ struct kref *__cil_tmp2 ;

  {
  {
#line 91
  __cil_tmp2 = (struct kref *)res;
#line 91
  kref_get(__cil_tmp2);
  }
#line 92
  return (res);
}
}
#line 103 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_resource_release_id(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  rwlock_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct idr *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  rwlock_t *__cil_tmp21 ;

  {
  {
#line 105
  __cil_tmp3 = (unsigned long )res;
#line 105
  __cil_tmp4 = __cil_tmp3 + 8;
#line 105
  dev_priv = *((struct vmw_private **)__cil_tmp4);
#line 107
  __cil_tmp5 = (unsigned long )dev_priv;
#line 107
  __cil_tmp6 = __cil_tmp5 + 2632;
#line 107
  __cil_tmp7 = (rwlock_t *)__cil_tmp6;
#line 107
  _raw_write_lock(__cil_tmp7);
  }
  {
#line 108
  __cil_tmp8 = (unsigned long )res;
#line 108
  __cil_tmp9 = __cil_tmp8 + 24;
#line 108
  __cil_tmp10 = *((int *)__cil_tmp9);
#line 108
  if (__cil_tmp10 != -1) {
    {
#line 109
    __cil_tmp11 = (unsigned long )res;
#line 109
    __cil_tmp12 = __cil_tmp11 + 16;
#line 109
    __cil_tmp13 = *((struct idr **)__cil_tmp12);
#line 109
    __cil_tmp14 = (unsigned long )res;
#line 109
    __cil_tmp15 = __cil_tmp14 + 24;
#line 109
    __cil_tmp16 = *((int *)__cil_tmp15);
#line 109
    idr_remove(__cil_tmp13, __cil_tmp16);
    }
  } else {

  }
  }
  {
#line 110
  __cil_tmp17 = (unsigned long )res;
#line 110
  __cil_tmp18 = __cil_tmp17 + 24;
#line 110
  *((int *)__cil_tmp18) = -1;
#line 111
  __cil_tmp19 = (unsigned long )dev_priv;
#line 111
  __cil_tmp20 = __cil_tmp19 + 2632;
#line 111
  __cil_tmp21 = (rwlock_t *)__cil_tmp20;
#line 111
  _raw_write_unlock(__cil_tmp21);
  }
#line 112
  return;
}
}
#line 114 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_resource_release(struct kref *kref ) 
{ struct vmw_resource *res ;
  struct kref    *__mptr ;
  struct vmw_private *dev_priv ;
  int id ;
  struct idr *idr ;
  long tmp___7 ;
  struct vmw_resource *__cil_tmp8 ;
  struct kref *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void (*__cil_tmp25)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void (*__cil_tmp29)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  rwlock_t *__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void (*__cil_tmp37)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  void (*__cil_tmp45)(struct vmw_resource *res ) ;
  void *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void (*__cil_tmp50)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void (*__cil_tmp54)(struct vmw_resource *res ) ;
  void    *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  rwlock_t *__cil_tmp58 ;

  {
#line 117
  __mptr = (struct kref    *)kref;
#line 117
  __cil_tmp8 = (struct vmw_resource *)0;
#line 117
  __cil_tmp9 = (struct kref *)__cil_tmp8;
#line 117
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 117
  __cil_tmp11 = (char *)__mptr;
#line 117
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 117
  res = (struct vmw_resource *)__cil_tmp12;
#line 118
  __cil_tmp13 = (unsigned long )res;
#line 118
  __cil_tmp14 = __cil_tmp13 + 8;
#line 118
  dev_priv = *((struct vmw_private **)__cil_tmp14);
#line 119
  __cil_tmp15 = (unsigned long )res;
#line 119
  __cil_tmp16 = __cil_tmp15 + 24;
#line 119
  id = *((int *)__cil_tmp16);
#line 120
  __cil_tmp17 = (unsigned long )res;
#line 120
  __cil_tmp18 = __cil_tmp17 + 16;
#line 120
  idr = *((struct idr **)__cil_tmp18);
#line 122
  __cil_tmp19 = (unsigned long )res;
#line 122
  __cil_tmp20 = __cil_tmp19 + 32;
#line 122
  *((bool *)__cil_tmp20) = (bool )0;
  {
#line 123
  __cil_tmp21 = (void *)0;
#line 123
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 123
  __cil_tmp23 = (unsigned long )res;
#line 123
  __cil_tmp24 = __cil_tmp23 + 40;
#line 123
  __cil_tmp25 = *((void (**)(struct vmw_resource *res ))__cil_tmp24);
#line 123
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 123
  if (__cil_tmp26 != __cil_tmp22) {
    {
#line 124
    __cil_tmp27 = (unsigned long )res;
#line 124
    __cil_tmp28 = __cil_tmp27 + 40;
#line 124
    __cil_tmp29 = *((void (**)(struct vmw_resource *res ))__cil_tmp28);
#line 124
    (*__cil_tmp29)(res);
    }
  } else {

  }
  }
  {
#line 125
  __cil_tmp30 = (unsigned long )dev_priv;
#line 125
  __cil_tmp31 = __cil_tmp30 + 2632;
#line 125
  __cil_tmp32 = (rwlock_t *)__cil_tmp31;
#line 125
  _raw_write_unlock(__cil_tmp32);
#line 127
  __cil_tmp33 = (void *)0;
#line 127
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 127
  __cil_tmp35 = (unsigned long )res;
#line 127
  __cil_tmp36 = __cil_tmp35 + 48;
#line 127
  __cil_tmp37 = *((void (**)(struct vmw_resource *res ))__cil_tmp36);
#line 127
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 127
  __cil_tmp39 = __cil_tmp38 != __cil_tmp34;
#line 127
  __cil_tmp40 = ! __cil_tmp39;
#line 127
  __cil_tmp41 = ! __cil_tmp40;
#line 127
  __cil_tmp42 = (long )__cil_tmp41;
#line 127
  tmp___7 = ldv__builtin_expect(__cil_tmp42, 1L);
  }
#line 127
  if (tmp___7) {
    {
#line 128
    __cil_tmp43 = (unsigned long )res;
#line 128
    __cil_tmp44 = __cil_tmp43 + 48;
#line 128
    __cil_tmp45 = *((void (**)(struct vmw_resource *res ))__cil_tmp44);
#line 128
    (*__cil_tmp45)(res);
    }
  } else {

  }
  {
#line 130
  __cil_tmp46 = (void *)0;
#line 130
  __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 130
  __cil_tmp48 = (unsigned long )res;
#line 130
  __cil_tmp49 = __cil_tmp48 + 56;
#line 130
  __cil_tmp50 = *((void (**)(struct vmw_resource *res ))__cil_tmp49);
#line 130
  __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 130
  if (__cil_tmp51 != __cil_tmp47) {
    {
#line 131
    __cil_tmp52 = (unsigned long )res;
#line 131
    __cil_tmp53 = __cil_tmp52 + 56;
#line 131
    __cil_tmp54 = *((void (**)(struct vmw_resource *res ))__cil_tmp53);
#line 131
    (*__cil_tmp54)(res);
    }
  } else {
    {
#line 133
    __cil_tmp55 = (void    *)res;
#line 133
    kfree(__cil_tmp55);
    }
  }
  }
  {
#line 135
  __cil_tmp56 = (unsigned long )dev_priv;
#line 135
  __cil_tmp57 = __cil_tmp56 + 2632;
#line 135
  __cil_tmp58 = (rwlock_t *)__cil_tmp57;
#line 135
  _raw_write_lock(__cil_tmp58);
  }
#line 137
  if (id != -1) {
    {
#line 138
    idr_remove(idr, id);
    }
  } else {

  }
#line 139
  return;
}
}
#line 141 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
void vmw_resource_unreference(struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  struct vmw_private *dev_priv ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  rwlock_t *__cil_tmp9 ;
  struct kref *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  rwlock_t *__cil_tmp13 ;

  {
  {
#line 143
  res = *p_res;
#line 144
  __cil_tmp4 = (unsigned long )res;
#line 144
  __cil_tmp5 = __cil_tmp4 + 8;
#line 144
  dev_priv = *((struct vmw_private **)__cil_tmp5);
#line 146
  __cil_tmp6 = (void *)0;
#line 146
  *p_res = (struct vmw_resource *)__cil_tmp6;
#line 147
  __cil_tmp7 = (unsigned long )dev_priv;
#line 147
  __cil_tmp8 = __cil_tmp7 + 2632;
#line 147
  __cil_tmp9 = (rwlock_t *)__cil_tmp8;
#line 147
  _raw_write_lock(__cil_tmp9);
#line 148
  __cil_tmp10 = (struct kref *)res;
#line 148
  kref_put(__cil_tmp10, & vmw_resource_release);
#line 149
  __cil_tmp11 = (unsigned long )dev_priv;
#line 149
  __cil_tmp12 = __cil_tmp11 + 2632;
#line 149
  __cil_tmp13 = (rwlock_t *)__cil_tmp12;
#line 149
  _raw_write_unlock(__cil_tmp13);
  }
#line 150
  return;
}
}
#line 162 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static int vmw_resource_alloc_id(struct vmw_private *dev_priv , struct vmw_resource *res ) 
{ int ret ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct idr *__cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  rwlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct idr *__cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  rwlock_t *__cil_tmp31 ;

  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    __cil_tmp8 = (unsigned long )res;
#line 167
    __cil_tmp9 = __cil_tmp8 + 24;
#line 167
    __cil_tmp10 = *((int *)__cil_tmp9);
#line 167
    __cil_tmp11 = __cil_tmp10 != -1;
#line 167
    __cil_tmp12 = ! __cil_tmp11;
#line 167
    __cil_tmp13 = ! __cil_tmp12;
#line 167
    __cil_tmp14 = (long )__cil_tmp13;
#line 167
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    }
#line 167
    if (tmp___7) {
      {
#line 167
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 167
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (167), "i" (12UL));
        {
#line 167
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 167
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 170
    __cil_tmp15 = (unsigned long )res;
#line 170
    __cil_tmp16 = __cil_tmp15 + 16;
#line 170
    __cil_tmp17 = *((struct idr **)__cil_tmp16);
#line 170
    tmp___8 = idr_pre_get(__cil_tmp17, 208U);
    }
#line 170
    if (tmp___8 == 0) {
#line 170
      tmp___9 = 1;
    } else {
#line 170
      tmp___9 = 0;
    }
    {
#line 170
    __cil_tmp18 = (long )tmp___9;
#line 170
    tmp___10 = ldv__builtin_expect(__cil_tmp18, 0L);
    }
#line 170
    if (tmp___10) {
#line 171
      return (-12);
    } else {

    }
    {
#line 173
    __cil_tmp19 = (unsigned long )dev_priv;
#line 173
    __cil_tmp20 = __cil_tmp19 + 2632;
#line 173
    __cil_tmp21 = (rwlock_t *)__cil_tmp20;
#line 173
    _raw_write_lock(__cil_tmp21);
#line 174
    __cil_tmp22 = (unsigned long )res;
#line 174
    __cil_tmp23 = __cil_tmp22 + 16;
#line 174
    __cil_tmp24 = *((struct idr **)__cil_tmp23);
#line 174
    __cil_tmp25 = (void *)res;
#line 174
    __cil_tmp26 = (unsigned long )res;
#line 174
    __cil_tmp27 = __cil_tmp26 + 24;
#line 174
    __cil_tmp28 = (int *)__cil_tmp27;
#line 174
    ret = idr_get_new_above(__cil_tmp24, __cil_tmp25, 1, __cil_tmp28);
#line 175
    __cil_tmp29 = (unsigned long )dev_priv;
#line 175
    __cil_tmp30 = __cil_tmp29 + 2632;
#line 175
    __cil_tmp31 = (rwlock_t *)__cil_tmp30;
#line 175
    _raw_write_unlock(__cil_tmp31);
    }
#line 169
    if (ret == -11) {

    } else {
#line 169
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 179
  return (ret);
}
}
#line 183 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                             struct idr *idr , enum ttm_object_type obj_type , bool delay_id ,
                             void (*res_free)(struct vmw_resource *res ) , void (*remove_from_lists)(struct vmw_resource *res ) ) 
{ int tmp___7 ;
  struct kref *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;

  {
  {
#line 192
  __cil_tmp9 = (struct kref *)res;
#line 192
  kref_init(__cil_tmp9);
#line 193
  __cil_tmp10 = (unsigned long )res;
#line 193
  __cil_tmp11 = __cil_tmp10 + 48;
#line 193
  __cil_tmp12 = (void *)0;
#line 193
  *((void (**)(struct vmw_resource *res ))__cil_tmp11) = (void (*)(struct vmw_resource *res ))__cil_tmp12;
#line 194
  __cil_tmp13 = (unsigned long )res;
#line 194
  __cil_tmp14 = __cil_tmp13 + 56;
#line 194
  *((void (**)(struct vmw_resource *res ))__cil_tmp14) = res_free;
#line 195
  __cil_tmp15 = (unsigned long )res;
#line 195
  __cil_tmp16 = __cil_tmp15 + 40;
#line 195
  *((void (**)(struct vmw_resource *res ))__cil_tmp16) = remove_from_lists;
#line 196
  __cil_tmp17 = (unsigned long )res;
#line 196
  __cil_tmp18 = __cil_tmp17 + 28;
#line 196
  *((enum ttm_object_type *)__cil_tmp18) = obj_type;
#line 197
  __cil_tmp19 = (unsigned long )res;
#line 197
  __cil_tmp20 = __cil_tmp19 + 16;
#line 197
  *((struct idr **)__cil_tmp20) = idr;
#line 198
  __cil_tmp21 = (unsigned long )res;
#line 198
  __cil_tmp22 = __cil_tmp21 + 32;
#line 198
  *((bool *)__cil_tmp22) = (bool )0;
#line 199
  __cil_tmp23 = (unsigned long )res;
#line 199
  __cil_tmp24 = __cil_tmp23 + 8;
#line 199
  *((struct vmw_private **)__cil_tmp24) = dev_priv;
#line 200
  __cil_tmp25 = (unsigned long )res;
#line 200
  __cil_tmp26 = __cil_tmp25 + 80;
#line 200
  __cil_tmp27 = (struct list_head *)__cil_tmp26;
#line 200
  INIT_LIST_HEAD(__cil_tmp27);
#line 201
  __cil_tmp28 = (unsigned long )res;
#line 201
  __cil_tmp29 = __cil_tmp28 + 64;
#line 201
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
#line 201
  INIT_LIST_HEAD(__cil_tmp30);
#line 202
  __cil_tmp31 = (unsigned long )res;
#line 202
  __cil_tmp32 = __cil_tmp31 + 24;
#line 202
  *((int *)__cil_tmp32) = -1;
  }
#line 203
  if (delay_id) {
#line 204
    return (0);
  } else {
    {
#line 206
    tmp___7 = vmw_resource_alloc_id(dev_priv, res);
    }
#line 206
    return (tmp___7);
  }
}
}
#line 222 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  rwlock_t *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  rwlock_t *__cil_tmp15 ;

  {
  {
#line 225
  __cil_tmp4 = (unsigned long )res;
#line 225
  __cil_tmp5 = __cil_tmp4 + 8;
#line 225
  dev_priv = *((struct vmw_private **)__cil_tmp5);
#line 227
  __cil_tmp6 = (unsigned long )dev_priv;
#line 227
  __cil_tmp7 = __cil_tmp6 + 2632;
#line 227
  __cil_tmp8 = (rwlock_t *)__cil_tmp7;
#line 227
  _raw_write_lock(__cil_tmp8);
#line 228
  __cil_tmp9 = (unsigned long )res;
#line 228
  __cil_tmp10 = __cil_tmp9 + 32;
#line 228
  *((bool *)__cil_tmp10) = (bool )1;
#line 229
  __cil_tmp11 = (unsigned long )res;
#line 229
  __cil_tmp12 = __cil_tmp11 + 48;
#line 229
  *((void (**)(struct vmw_resource *res ))__cil_tmp12) = hw_destroy;
#line 230
  __cil_tmp13 = (unsigned long )dev_priv;
#line 230
  __cil_tmp14 = __cil_tmp13 + 2632;
#line 230
  __cil_tmp15 = (rwlock_t *)__cil_tmp14;
#line 230
  _raw_write_unlock(__cil_tmp15);
  }
#line 231
  return;
}
}
#line 233 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv , struct idr *idr ,
                                         int id ) 
{ struct vmw_resource *res ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  rwlock_t *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct kref *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  rwlock_t *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  void *__cil_tmp25 ;

  {
  {
#line 238
  __cil_tmp7 = (unsigned long )dev_priv;
#line 238
  __cil_tmp8 = __cil_tmp7 + 2632;
#line 238
  __cil_tmp9 = (rwlock_t *)__cil_tmp8;
#line 238
  _raw_read_lock(__cil_tmp9);
#line 239
  tmp___7 = idr_find(idr, id);
#line 239
  res = (struct vmw_resource *)tmp___7;
  }
#line 240
  if (res) {
    {
#line 240
    __cil_tmp10 = (unsigned long )res;
#line 240
    __cil_tmp11 = __cil_tmp10 + 32;
#line 240
    if (*((bool *)__cil_tmp11)) {
      {
#line 241
      __cil_tmp12 = (struct kref *)res;
#line 241
      kref_get(__cil_tmp12);
      }
    } else {
#line 243
      __cil_tmp13 = (void *)0;
#line 243
      res = (struct vmw_resource *)__cil_tmp13;
    }
    }
  } else {
#line 243
    __cil_tmp14 = (void *)0;
#line 243
    res = (struct vmw_resource *)__cil_tmp14;
  }
  {
#line 244
  __cil_tmp15 = (unsigned long )dev_priv;
#line 244
  __cil_tmp16 = __cil_tmp15 + 2632;
#line 244
  __cil_tmp17 = (rwlock_t *)__cil_tmp16;
#line 244
  _raw_read_unlock(__cil_tmp17);
#line 246
  __cil_tmp18 = (void *)0;
#line 246
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 246
  __cil_tmp20 = (unsigned long )res;
#line 246
  __cil_tmp21 = __cil_tmp20 == __cil_tmp19;
#line 246
  __cil_tmp22 = ! __cil_tmp21;
#line 246
  __cil_tmp23 = ! __cil_tmp22;
#line 246
  __cil_tmp24 = (long )__cil_tmp23;
#line 246
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 246
  if (tmp___8) {
    {
#line 247
    __cil_tmp25 = (void *)0;
#line 247
    return ((struct vmw_resource *)__cil_tmp25);
    }
  } else {

  }
#line 249
  return (res);
}
}
#line 256 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_hw_context_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct __anonstruct_cmd_429___1 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  bool __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  bool __cil_tmp30 ;

  {
  {
#line 259
  __cil_tmp6 = (unsigned long )res;
#line 259
  __cil_tmp7 = __cil_tmp6 + 8;
#line 259
  dev_priv = *((struct vmw_private **)__cil_tmp7);
#line 266
  __cil_tmp8 = (bool )1;
#line 266
  __cil_tmp9 = (unsigned long )res;
#line 266
  __cil_tmp10 = __cil_tmp9 + 24;
#line 266
  __cil_tmp11 = *((int *)__cil_tmp10);
#line 266
  __cil_tmp12 = (uint32_t )__cil_tmp11;
#line 266
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp8, __cil_tmp12);
#line 268
  __cil_tmp13 = (uint32_t )12UL;
#line 268
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp13);
#line 268
  cmd = (struct __anonstruct_cmd_429___1 *)tmp___7;
#line 269
  __cil_tmp14 = (void *)0;
#line 269
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 269
  __cil_tmp16 = (unsigned long )cmd;
#line 269
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
#line 269
  __cil_tmp18 = ! __cil_tmp17;
#line 269
  __cil_tmp19 = ! __cil_tmp18;
#line 269
  __cil_tmp20 = (long )__cil_tmp19;
#line 269
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 269
  if (tmp___8) {
    {
#line 270
    drm_err("vmw_hw_context_destroy", "Failed reserving FIFO space for surface destruction.\n");
    }
#line 272
    return;
  } else {

  }
  {
#line 275
  *((uint32 *)cmd) = (__u32 )1046;
#line 276
  __cil_tmp21 = 0 + 4;
#line 276
  __cil_tmp22 = (unsigned long )cmd;
#line 276
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 276
  *((uint32 *)__cil_tmp23) = (__u32 )4UL;
#line 277
  __cil_tmp24 = (unsigned long )cmd;
#line 277
  __cil_tmp25 = __cil_tmp24 + 8;
#line 277
  __cil_tmp26 = (unsigned long )res;
#line 277
  __cil_tmp27 = __cil_tmp26 + 24;
#line 277
  __cil_tmp28 = *((int *)__cil_tmp27);
#line 277
  *((uint32 *)__cil_tmp25) = (__u32 )__cil_tmp28;
#line 279
  __cil_tmp29 = (uint32_t )12UL;
#line 279
  vmw_fifo_commit(dev_priv, __cil_tmp29);
#line 280
  __cil_tmp30 = (bool )0;
#line 280
  vmw_3d_resource_dec(dev_priv, __cil_tmp30);
  }
#line 281
  return;
}
}
#line 283 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static int vmw_context_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                            void (*res_free)(struct vmw_resource *res ) ) 
{ int ret ;
  struct __anonstruct_cmd_430___1 *cmd ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  struct vmw_resource **__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct idr *__cil_tmp14 ;
  enum ttm_object_type __cil_tmp15 ;
  bool __cil_tmp16 ;
  void *__cil_tmp17 ;
  void (*__cil_tmp18)(struct vmw_resource *res ) ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct vmw_resource **__cil_tmp23 ;
  struct vmw_resource *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_resource **__cil_tmp45 ;
  struct vmw_resource *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  bool __cil_tmp51 ;
  struct vmw_resource **__cil_tmp52 ;
  struct vmw_resource *__cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct vmw_resource **__cil_tmp57 ;
  struct vmw_resource *__cil_tmp58 ;
  void    *__cil_tmp59 ;
  struct vmw_resource **__cil_tmp60 ;
  struct vmw_resource *__cil_tmp61 ;

  {
  {
#line 294
  __cil_tmp10 = & res;
#line 294
  __cil_tmp11 = *__cil_tmp10;
#line 294
  __cil_tmp12 = (unsigned long )dev_priv;
#line 294
  __cil_tmp13 = __cil_tmp12 + 2656;
#line 294
  __cil_tmp14 = (struct idr *)__cil_tmp13;
#line 294
  __cil_tmp15 = (enum ttm_object_type )256;
#line 294
  __cil_tmp16 = (bool )0;
#line 294
  __cil_tmp17 = (void *)0;
#line 294
  __cil_tmp18 = (void (*)(struct vmw_resource *res ))__cil_tmp17;
#line 294
  ret = vmw_resource_init(dev_priv, __cil_tmp11, __cil_tmp14, __cil_tmp15, __cil_tmp16,
                          res_free, __cil_tmp18);
#line 297
  __cil_tmp19 = ret != 0;
#line 297
  __cil_tmp20 = ! __cil_tmp19;
#line 297
  __cil_tmp21 = ! __cil_tmp20;
#line 297
  __cil_tmp22 = (long )__cil_tmp21;
#line 297
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 297
  if (tmp___7) {
    {
#line 298
    drm_err("vmw_context_init", "Failed to allocate a resource id.\n");
    }
#line 299
    goto out_early;
  } else {

  }
  {
#line 302
  __cil_tmp23 = & res;
#line 302
  __cil_tmp24 = *__cil_tmp23;
#line 302
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 302
  __cil_tmp26 = __cil_tmp25 + 24;
#line 302
  __cil_tmp27 = *((int *)__cil_tmp26);
#line 302
  __cil_tmp28 = __cil_tmp27 >= 256;
#line 302
  __cil_tmp29 = ! __cil_tmp28;
#line 302
  __cil_tmp30 = ! __cil_tmp29;
#line 302
  __cil_tmp31 = (long )__cil_tmp30;
#line 302
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 302
  if (tmp___8) {
    {
#line 303
    drm_err("vmw_context_init", "Out of hw context ids.\n");
#line 304
    vmw_resource_unreference(& res);
    }
#line 305
    return (-12);
  } else {

  }
  {
#line 308
  __cil_tmp32 = (uint32_t )12UL;
#line 308
  tmp___9 = vmw_fifo_reserve(dev_priv, __cil_tmp32);
#line 308
  cmd = (struct __anonstruct_cmd_430___1 *)tmp___9;
#line 309
  __cil_tmp33 = (void *)0;
#line 309
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 309
  __cil_tmp35 = (unsigned long )cmd;
#line 309
  __cil_tmp36 = __cil_tmp35 == __cil_tmp34;
#line 309
  __cil_tmp37 = ! __cil_tmp36;
#line 309
  __cil_tmp38 = ! __cil_tmp37;
#line 309
  __cil_tmp39 = (long )__cil_tmp38;
#line 309
  tmp___10 = ldv__builtin_expect(__cil_tmp39, 0L);
  }
#line 309
  if (tmp___10) {
    {
#line 310
    drm_err("vmw_context_init", "Fifo reserve failed.\n");
#line 311
    vmw_resource_unreference(& res);
    }
#line 312
    return (-12);
  } else {

  }
  {
#line 315
  *((uint32 *)cmd) = (__u32 )1045;
#line 316
  __cil_tmp40 = 0 + 4;
#line 316
  __cil_tmp41 = (unsigned long )cmd;
#line 316
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 316
  *((uint32 *)__cil_tmp42) = (__u32 )4UL;
#line 317
  __cil_tmp43 = (unsigned long )cmd;
#line 317
  __cil_tmp44 = __cil_tmp43 + 8;
#line 317
  __cil_tmp45 = & res;
#line 317
  __cil_tmp46 = *__cil_tmp45;
#line 317
  __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 317
  __cil_tmp48 = __cil_tmp47 + 24;
#line 317
  __cil_tmp49 = *((int *)__cil_tmp48);
#line 317
  *((uint32 *)__cil_tmp44) = (__u32 )__cil_tmp49;
#line 319
  __cil_tmp50 = (uint32_t )12UL;
#line 319
  vmw_fifo_commit(dev_priv, __cil_tmp50);
#line 320
  __cil_tmp51 = (bool )0;
#line 320
  vmw_3d_resource_inc(dev_priv, __cil_tmp51);
#line 321
  __cil_tmp52 = & res;
#line 321
  __cil_tmp53 = *__cil_tmp52;
#line 321
  vmw_resource_activate(__cil_tmp53, & vmw_hw_context_destroy);
  }
#line 322
  return (0);
  out_early: 
  {
#line 325
  __cil_tmp54 = (void *)0;
#line 325
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 325
  __cil_tmp56 = (unsigned long )res_free;
#line 325
  if (__cil_tmp56 == __cil_tmp55) {
    {
#line 326
    __cil_tmp57 = & res;
#line 326
    __cil_tmp58 = *__cil_tmp57;
#line 326
    __cil_tmp59 = (void    *)__cil_tmp58;
#line 326
    kfree(__cil_tmp59);
    }
  } else {
    {
#line 328
    __cil_tmp60 = & res;
#line 328
    __cil_tmp61 = *__cil_tmp60;
#line 328
    (*res_free)(__cil_tmp61);
    }
  }
  }
#line 329
  return (ret);
}
}
#line 332 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) 
{ struct vmw_resource *res ;
  void *tmp___7 ;
  int ret ;
  long tmp___8 ;
  struct vmw_resource *tmp___9 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void (*__cil_tmp16)(struct vmw_resource *res ) ;
  void *__cil_tmp17 ;

  {
  {
#line 334
  tmp___7 = kmalloc(96UL, 208U);
#line 334
  res = (struct vmw_resource *)tmp___7;
#line 337
  __cil_tmp7 = (void *)0;
#line 337
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 337
  __cil_tmp9 = (unsigned long )res;
#line 337
  __cil_tmp10 = __cil_tmp9 == __cil_tmp8;
#line 337
  __cil_tmp11 = ! __cil_tmp10;
#line 337
  __cil_tmp12 = ! __cil_tmp11;
#line 337
  __cil_tmp13 = (long )__cil_tmp12;
#line 337
  tmp___8 = ldv__builtin_expect(__cil_tmp13, 0L);
  }
#line 337
  if (tmp___8) {
    {
#line 338
    __cil_tmp14 = (void *)0;
#line 338
    return ((struct vmw_resource *)__cil_tmp14);
    }
  } else {

  }
  {
#line 340
  __cil_tmp15 = (void *)0;
#line 340
  __cil_tmp16 = (void (*)(struct vmw_resource *res ))__cil_tmp15;
#line 340
  ret = vmw_context_init(dev_priv, res, __cil_tmp16);
  }
#line 341
  if (ret == 0) {
#line 341
    tmp___9 = res;
  } else {
#line 341
    __cil_tmp17 = (void *)0;
#line 341
    tmp___9 = (struct vmw_resource *)__cil_tmp17;
  }
#line 341
  return (tmp___9);
}
}
#line 348 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_context_free(struct vmw_resource *res ) 
{ struct vmw_user_context *ctx ;
  struct vmw_resource    *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_context *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void    *__cil_tmp15 ;

  {
  {
#line 351
  __mptr = (struct vmw_resource    *)res;
#line 351
  __cil_tmp6 = (struct vmw_user_context *)0;
#line 351
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 351
  __cil_tmp8 = __cil_tmp7 + 64;
#line 351
  __cil_tmp9 = (struct vmw_resource *)__cil_tmp8;
#line 351
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 351
  __cil_tmp11 = (char *)__mptr;
#line 351
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 351
  ctx = (struct vmw_user_context *)__cil_tmp12;
#line 352
  __cil_tmp13 = (unsigned long )res;
#line 352
  __cil_tmp14 = __cil_tmp13 + 8;
#line 352
  dev_priv = *((struct vmw_private **)__cil_tmp14);
#line 354
  __cil_tmp15 = (void    *)ctx;
#line 354
  kfree(__cil_tmp15);
#line 355
  tmp___7 = vmw_mem_glob(dev_priv);
#line 355
  ttm_mem_global_free(tmp___7, vmw_user_context_size);
  }
#line 357
  return;
}
}
#line 364 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_context_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_context *ctx ;
  struct ttm_base_object    *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_context *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 366
  base = *p_base;
#line 368
  __mptr = (struct ttm_base_object    *)base;
#line 368
  __cil_tmp6 = (struct vmw_user_context *)0;
#line 368
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
#line 368
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 368
  __cil_tmp9 = (char *)__mptr;
#line 368
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 368
  ctx = (struct vmw_user_context *)__cil_tmp10;
#line 369
  __cil_tmp11 = & res;
#line 369
  __cil_tmp12 = (unsigned long )ctx;
#line 369
  __cil_tmp13 = __cil_tmp12 + 64;
#line 369
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
#line 371
  __cil_tmp14 = (void *)0;
#line 371
  *p_base = (struct ttm_base_object *)__cil_tmp14;
#line 372
  vmw_resource_unreference(& res);
  }
#line 373
  return;
}
}
#line 375 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_resource *res ;
  struct vmw_user_context *ctx ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  int ret ;
  long tmp___9 ;
  struct vmw_resource    *__mptr ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_resource **__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct idr *__cil_tmp19 ;
  int32_t __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_resource **__cil_tmp23 ;
  struct vmw_resource *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_resource **__cil_tmp31 ;
  struct vmw_resource *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  void (*__cil_tmp35)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp36 ;
  struct vmw_resource **__cil_tmp37 ;
  struct vmw_resource *__cil_tmp38 ;
  struct vmw_user_context *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_resource *__cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_object_file *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  bool __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  enum ttm_ref_type __cil_tmp61 ;

  {
  {
#line 378
  tmp___7 = vmw_priv(dev);
#line 378
  dev_priv = tmp___7;
#line 381
  arg = (struct drm_vmw_context_arg *)data;
#line 382
  tmp___8 = vmw_fpriv(file_priv);
#line 382
  __cil_tmp14 = (unsigned long )tmp___8;
#line 382
  __cil_tmp15 = __cil_tmp14 + 8;
#line 382
  tfile = *((struct ttm_object_file **)__cil_tmp15);
#line 383
  ret = 0;
#line 385
  __cil_tmp16 = & res;
#line 385
  __cil_tmp17 = (unsigned long )dev_priv;
#line 385
  __cil_tmp18 = __cil_tmp17 + 2656;
#line 385
  __cil_tmp19 = (struct idr *)__cil_tmp18;
#line 385
  __cil_tmp20 = *((int32_t *)arg);
#line 385
  *__cil_tmp16 = vmw_resource_lookup(dev_priv, __cil_tmp19, __cil_tmp20);
#line 386
  __cil_tmp21 = (void *)0;
#line 386
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 386
  __cil_tmp23 = & res;
#line 386
  __cil_tmp24 = *__cil_tmp23;
#line 386
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 386
  __cil_tmp26 = __cil_tmp25 == __cil_tmp22;
#line 386
  __cil_tmp27 = ! __cil_tmp26;
#line 386
  __cil_tmp28 = ! __cil_tmp27;
#line 386
  __cil_tmp29 = (long )__cil_tmp28;
#line 386
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 386
  if (tmp___9) {
#line 387
    return (-22);
  } else {

  }
  {
#line 389
  __cil_tmp30 = (unsigned long )(& vmw_user_context_free);
#line 389
  __cil_tmp31 = & res;
#line 389
  __cil_tmp32 = *__cil_tmp31;
#line 389
  __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 389
  __cil_tmp34 = __cil_tmp33 + 56;
#line 389
  __cil_tmp35 = *((void (**)(struct vmw_resource *res ))__cil_tmp34);
#line 389
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 389
  if (__cil_tmp36 != __cil_tmp30) {
#line 390
    ret = -22;
#line 391
    goto out;
  } else {

  }
  }
#line 394
  __cil_tmp37 = & res;
#line 394
  __cil_tmp38 = *__cil_tmp37;
#line 394
  __mptr = (struct vmw_resource    *)__cil_tmp38;
#line 394
  __cil_tmp39 = (struct vmw_user_context *)0;
#line 394
  __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 394
  __cil_tmp41 = __cil_tmp40 + 64;
#line 394
  __cil_tmp42 = (struct vmw_resource *)__cil_tmp41;
#line 394
  __cil_tmp43 = (unsigned int )__cil_tmp42;
#line 394
  __cil_tmp44 = (char *)__mptr;
#line 394
  __cil_tmp45 = __cil_tmp44 - __cil_tmp43;
#line 394
  ctx = (struct vmw_user_context *)__cil_tmp45;
  {
#line 395
  __cil_tmp46 = (unsigned long )tfile;
#line 395
  __cil_tmp47 = 0 + 32;
#line 395
  __cil_tmp48 = (unsigned long )ctx;
#line 395
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 395
  __cil_tmp50 = *((struct ttm_object_file **)__cil_tmp49);
#line 395
  __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 395
  if (__cil_tmp51 != __cil_tmp46) {
    {
#line 395
    __cil_tmp52 = 0 + 28;
#line 395
    __cil_tmp53 = (unsigned long )ctx;
#line 395
    __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
#line 395
    __cil_tmp55 = *((bool *)__cil_tmp54);
#line 395
    if (! __cil_tmp55) {
#line 396
      ret = -1;
#line 397
      goto out;
    } else {

    }
    }
  } else {

  }
  }
  {
#line 400
  __cil_tmp56 = 0 + 16;
#line 400
  __cil_tmp57 = 0 + __cil_tmp56;
#line 400
  __cil_tmp58 = (unsigned long )ctx;
#line 400
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 400
  __cil_tmp60 = *((unsigned long *)__cil_tmp59);
#line 400
  __cil_tmp61 = (enum ttm_ref_type )0;
#line 400
  ttm_ref_object_base_unref(tfile, __cil_tmp60, __cil_tmp61);
  }
  out: 
  {
#line 402
  vmw_resource_unreference(& res);
  }
#line 403
  return (ret);
}
}
#line 406 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  int ret ;
  size_t tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct ttm_mem_global *tmp___14 ;
  long tmp___15 ;
  void *tmp___16 ;
  struct ttm_mem_global *tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  size_t __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;
  bool __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  bool __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  struct vmw_resource **__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  void *__cil_tmp63 ;
  struct vmw_resource **__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  long __cil_tmp69 ;
  struct vmw_resource **__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  struct ttm_base_object *__cil_tmp74 ;
  bool __cil_tmp75 ;
  enum ttm_object_type __cil_tmp76 ;
  void *__cil_tmp77 ;
  void (*__cil_tmp78)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct vmw_resource **__cil_tmp83 ;
  struct vmw_resource *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct ttm_lock *__cil_tmp87 ;

  {
  {
#line 409
  tmp___7 = vmw_priv(dev);
#line 409
  dev_priv = tmp___7;
#line 413
  arg = (struct drm_vmw_context_arg *)data;
#line 414
  tmp___9 = vmw_fpriv(file_priv);
#line 414
  __cil_tmp25 = (unsigned long )tmp___9;
#line 414
  __cil_tmp26 = __cil_tmp25 + 8;
#line 414
  tfile = *((struct ttm_object_file **)__cil_tmp26);
#line 415
  __cil_tmp27 = (unsigned long )file_priv;
#line 415
  __cil_tmp28 = __cil_tmp27 + 152;
#line 415
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
#line 415
  tmp___10 = vmw_master(__cil_tmp29);
#line 415
  vmaster = tmp___10;
#line 424
  __cil_tmp30 = vmw_user_context_size == 0ULL;
#line 424
  __cil_tmp31 = ! __cil_tmp30;
#line 424
  __cil_tmp32 = ! __cil_tmp31;
#line 424
  __cil_tmp33 = (long )__cil_tmp32;
#line 424
  tmp___12 = ldv__builtin_expect(__cil_tmp33, 0L);
  }
#line 424
  if (tmp___12) {
    {
#line 425
    tmp___11 = ttm_round_pot(160UL);
#line 425
    __cil_tmp34 = tmp___11 + 128UL;
#line 425
    vmw_user_context_size = (uint64_t )__cil_tmp34;
    }
  } else {

  }
  {
#line 427
  __cil_tmp35 = (struct ttm_lock *)vmaster;
#line 427
  __cil_tmp36 = (bool )1;
#line 427
  ret = ttm_read_lock(__cil_tmp35, __cil_tmp36);
#line 428
  __cil_tmp37 = ret != 0;
#line 428
  __cil_tmp38 = ! __cil_tmp37;
#line 428
  __cil_tmp39 = ! __cil_tmp38;
#line 428
  __cil_tmp40 = (long )__cil_tmp39;
#line 428
  tmp___13 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 428
  if (tmp___13) {
#line 429
    return (ret);
  } else {

  }
  {
#line 431
  tmp___14 = vmw_mem_glob(dev_priv);
#line 431
  __cil_tmp41 = (bool )0;
#line 431
  __cil_tmp42 = (bool )1;
#line 431
  ret = ttm_mem_global_alloc(tmp___14, vmw_user_context_size, __cil_tmp41, __cil_tmp42);
#line 434
  __cil_tmp43 = ret != 0;
#line 434
  __cil_tmp44 = ! __cil_tmp43;
#line 434
  __cil_tmp45 = ! __cil_tmp44;
#line 434
  __cil_tmp46 = (long )__cil_tmp45;
#line 434
  tmp___15 = ldv__builtin_expect(__cil_tmp46, 0L);
  }
#line 434
  if (tmp___15) {
#line 435
    if (ret != -512) {
      {
#line 436
      drm_err("vmw_context_define_ioctl", "Out of graphics memory for context creation.\n");
      }
    } else {

    }
#line 438
    goto out_unlock;
  } else {

  }
  {
#line 441
  tmp___16 = kmalloc(160UL, 208U);
#line 441
  ctx = (struct vmw_user_context *)tmp___16;
#line 442
  __cil_tmp47 = (void *)0;
#line 442
  __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 442
  __cil_tmp49 = (unsigned long )ctx;
#line 442
  __cil_tmp50 = __cil_tmp49 == __cil_tmp48;
#line 442
  __cil_tmp51 = ! __cil_tmp50;
#line 442
  __cil_tmp52 = ! __cil_tmp51;
#line 442
  __cil_tmp53 = (long )__cil_tmp52;
#line 442
  tmp___18 = ldv__builtin_expect(__cil_tmp53, 0L);
  }
#line 442
  if (tmp___18) {
    {
#line 443
    tmp___17 = vmw_mem_glob(dev_priv);
#line 443
    ttm_mem_global_free(tmp___17, vmw_user_context_size);
#line 445
    ret = -12;
    }
#line 446
    goto out_unlock;
  } else {

  }
  {
#line 449
  __cil_tmp54 = & res;
#line 449
  __cil_tmp55 = (unsigned long )ctx;
#line 449
  __cil_tmp56 = __cil_tmp55 + 64;
#line 449
  *__cil_tmp54 = (struct vmw_resource *)__cil_tmp56;
#line 450
  __cil_tmp57 = 0 + 28;
#line 450
  __cil_tmp58 = (unsigned long )ctx;
#line 450
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 450
  *((bool *)__cil_tmp59) = (bool )0;
#line 451
  __cil_tmp60 = 0 + 32;
#line 451
  __cil_tmp61 = (unsigned long )ctx;
#line 451
  __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 451
  __cil_tmp63 = (void *)0;
#line 451
  *((struct ttm_object_file **)__cil_tmp62) = (struct ttm_object_file *)__cil_tmp63;
#line 457
  __cil_tmp64 = & res;
#line 457
  __cil_tmp65 = *__cil_tmp64;
#line 457
  ret = vmw_context_init(dev_priv, __cil_tmp65, & vmw_user_context_free);
#line 458
  __cil_tmp66 = ret != 0;
#line 458
  __cil_tmp67 = ! __cil_tmp66;
#line 458
  __cil_tmp68 = ! __cil_tmp67;
#line 458
  __cil_tmp69 = (long )__cil_tmp68;
#line 458
  tmp___19 = ldv__builtin_expect(__cil_tmp69, 0L);
  }
#line 458
  if (tmp___19) {
#line 459
    goto out_unlock;
  } else {

  }
  {
#line 461
  __cil_tmp70 = & tmp___8;
#line 461
  __cil_tmp71 = (unsigned long )ctx;
#line 461
  __cil_tmp72 = __cil_tmp71 + 64;
#line 461
  __cil_tmp73 = (struct vmw_resource *)__cil_tmp72;
#line 461
  *__cil_tmp70 = vmw_resource_reference(__cil_tmp73);
#line 462
  __cil_tmp74 = (struct ttm_base_object *)ctx;
#line 462
  __cil_tmp75 = (bool )0;
#line 462
  __cil_tmp76 = (enum ttm_object_type )256;
#line 462
  __cil_tmp77 = (void *)0;
#line 462
  __cil_tmp78 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp77;
#line 462
  ret = ttm_base_object_init(tfile, __cil_tmp74, __cil_tmp75, __cil_tmp76, & vmw_user_context_base_release,
                             __cil_tmp78);
#line 465
  __cil_tmp79 = ret != 0;
#line 465
  __cil_tmp80 = ! __cil_tmp79;
#line 465
  __cil_tmp81 = ! __cil_tmp80;
#line 465
  __cil_tmp82 = (long )__cil_tmp81;
#line 465
  tmp___20 = ldv__builtin_expect(__cil_tmp82, 0L);
  }
#line 465
  if (tmp___20) {
    {
#line 466
    vmw_resource_unreference(& tmp___8);
    }
#line 467
    goto out_err;
  } else {

  }
#line 470
  __cil_tmp83 = & res;
#line 470
  __cil_tmp84 = *__cil_tmp83;
#line 470
  __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 470
  __cil_tmp86 = __cil_tmp85 + 24;
#line 470
  *((int32_t *)arg) = *((int *)__cil_tmp86);
  out_err: 
  {
#line 472
  vmw_resource_unreference(& res);
  }
  out_unlock: 
  {
#line 474
  __cil_tmp87 = (struct ttm_lock *)vmaster;
#line 474
  ttm_read_unlock(__cil_tmp87);
  }
#line 475
  return (ret);
}
}
#line 479 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  int ret ;
  void *tmp___7 ;
  struct vmw_user_context *ctx ;
  struct vmw_resource    *__mptr ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  rwlock_t *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct idr *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_user_context *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_resource *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct ttm_object_file *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  bool __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  rwlock_t *__cil_tmp37 ;

  {
  {
#line 485
  ret = 0;
#line 487
  __cil_tmp10 = (unsigned long )dev_priv;
#line 487
  __cil_tmp11 = __cil_tmp10 + 2632;
#line 487
  __cil_tmp12 = (rwlock_t *)__cil_tmp11;
#line 487
  _raw_read_lock(__cil_tmp12);
#line 488
  __cil_tmp13 = (unsigned long )dev_priv;
#line 488
  __cil_tmp14 = __cil_tmp13 + 2656;
#line 488
  __cil_tmp15 = (struct idr *)__cil_tmp14;
#line 488
  tmp___7 = idr_find(__cil_tmp15, id);
#line 488
  res = (struct vmw_resource *)tmp___7;
  }
#line 489
  if (res) {
    {
#line 489
    __cil_tmp16 = (unsigned long )res;
#line 489
    __cil_tmp17 = __cil_tmp16 + 32;
#line 489
    if (*((bool *)__cil_tmp17)) {
#line 491
      __mptr = (struct vmw_resource    *)res;
#line 491
      __cil_tmp18 = (struct vmw_user_context *)0;
#line 491
      __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 491
      __cil_tmp20 = __cil_tmp19 + 64;
#line 491
      __cil_tmp21 = (struct vmw_resource *)__cil_tmp20;
#line 491
      __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 491
      __cil_tmp23 = (char *)__mptr;
#line 491
      __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 491
      ctx = (struct vmw_user_context *)__cil_tmp24;
      {
#line 492
      __cil_tmp25 = (unsigned long )tfile;
#line 492
      __cil_tmp26 = 0 + 32;
#line 492
      __cil_tmp27 = (unsigned long )ctx;
#line 492
      __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
#line 492
      __cil_tmp29 = *((struct ttm_object_file **)__cil_tmp28);
#line 492
      __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 492
      if (__cil_tmp30 != __cil_tmp25) {
        {
#line 492
        __cil_tmp31 = 0 + 28;
#line 492
        __cil_tmp32 = (unsigned long )ctx;
#line 492
        __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 492
        __cil_tmp34 = *((bool *)__cil_tmp33);
#line 492
        if (! __cil_tmp34) {
#line 493
          ret = -1;
        } else {

        }
        }
      } else {

      }
      }
#line 494
      if (p_res) {
        {
#line 495
        *p_res = vmw_resource_reference(res);
        }
      } else {

      }
    } else {
#line 497
      ret = -22;
    }
    }
  } else {
#line 497
    ret = -22;
  }
  {
#line 498
  __cil_tmp35 = (unsigned long )dev_priv;
#line 498
  __cil_tmp36 = __cil_tmp35 + 2632;
#line 498
  __cil_tmp37 = (rwlock_t *)__cil_tmp36;
#line 498
  _raw_read_unlock(__cil_tmp37);
  }
#line 500
  return (ret);
}
}
#line 521 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static struct vmw_bpp    vmw_sf_bpp[121]  = 
#line 521
  {      {(uint8_t )0, (uint8_t )0}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )4, (uint8_t )16}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )64, (uint8_t )64}, 
        {(uint8_t )12, (uint8_t )12}, 
        {(uint8_t )12, (uint8_t )12}, 
        {(uint8_t )12, (uint8_t )8}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )4, (uint8_t )16}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )24, (uint8_t )24}, 
        {(uint8_t )32, (uint8_t )32}};
#line 605
__inline static uint32_t vmw_surface_dma_size(struct vmw_surface    *srf )  __attribute__((__no_instrument_function__)) ;
#line 605 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
__inline static uint32_t vmw_surface_dma_size(struct vmw_surface    *srf ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  uint32_t    __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 607
  __cil_tmp2 = (unsigned long )srf;
#line 607
  __cil_tmp3 = __cil_tmp2 + 152;
#line 607
  __cil_tmp4 = *((uint32_t    *)__cil_tmp3);
#line 607
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 607
  __cil_tmp6 = __cil_tmp5 * 84UL;
#line 607
  return ((uint32_t )__cil_tmp6);
  }
}
}
#line 619
__inline static uint32_t vmw_surface_define_size(struct vmw_surface    *srf )  __attribute__((__no_instrument_function__)) ;
#line 619 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
__inline static uint32_t vmw_surface_define_size(struct vmw_surface    *srf ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  uint32_t    __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 621
  __cil_tmp2 = (unsigned long )srf;
#line 621
  __cil_tmp3 = __cil_tmp2 + 152;
#line 621
  __cil_tmp4 = *((uint32_t    *)__cil_tmp3);
#line 621
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 621
  __cil_tmp6 = __cil_tmp5 * 12UL;
#line 621
  __cil_tmp7 = 44UL + __cil_tmp6;
#line 621
  return ((uint32_t )__cil_tmp7);
  }
}
}
#line 632
__inline static uint32_t vmw_surface_destroy_size(void)  __attribute__((__no_instrument_function__)) ;
#line 632 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
__inline static uint32_t vmw_surface_destroy_size(void) 
{ 

  {
#line 634
  return ((uint32_t )12UL);
}
}
#line 643 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_surface_destroy_encode(uint32_t id , void *cmd_space ) 
{ struct vmw_surface_destroy *cmd ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;

  {
#line 646
  cmd = (struct vmw_surface_destroy *)cmd_space;
#line 649
  *((uint32 *)cmd) = (uint32 )1041;
#line 650
  __cil_tmp4 = 0 + 4;
#line 650
  __cil_tmp5 = (unsigned long )cmd;
#line 650
  __cil_tmp6 = __cil_tmp5 + __cil_tmp4;
#line 650
  *((uint32 *)__cil_tmp6) = (uint32 )4UL;
#line 651
  __cil_tmp7 = (unsigned long )cmd;
#line 651
  __cil_tmp8 = __cil_tmp7 + 8;
#line 651
  *((uint32 *)__cil_tmp8) = id;
#line 652
  return;
}
}
#line 660 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_surface_define_encode(struct vmw_surface    *srf , void *cmd_space ) 
{ struct vmw_surface_define *cmd ;
  struct drm_vmw_size *src_size ;
  SVGA3dSize *cmd_size ;
  uint32_t cmd_len ;
  int i ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  uint32_t    __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int    __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t    __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t    __cil_tmp34 ;
  __u32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_vmw_size *   __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t    __cil_tmp50 ;
  uint32_t    __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;

  {
#line 663
  cmd = (struct vmw_surface_define *)cmd_space;
#line 670
  __cil_tmp8 = (unsigned long )srf;
#line 670
  __cil_tmp9 = __cil_tmp8 + 152;
#line 670
  __cil_tmp10 = *((uint32_t    *)__cil_tmp9);
#line 670
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 670
  __cil_tmp12 = __cil_tmp11 * 12UL;
#line 670
  __cil_tmp13 = 36UL + __cil_tmp12;
#line 670
  cmd_len = (uint32_t )__cil_tmp13;
#line 672
  *((uint32 *)cmd) = (uint32 )1040;
#line 673
  __cil_tmp14 = 0 + 4;
#line 673
  __cil_tmp15 = (unsigned long )cmd;
#line 673
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
#line 673
  *((uint32 *)__cil_tmp16) = cmd_len;
#line 674
  __cil_tmp17 = (unsigned long )cmd;
#line 674
  __cil_tmp18 = __cil_tmp17 + 8;
#line 674
  __cil_tmp19 = 0 + 24;
#line 674
  __cil_tmp20 = (unsigned long )srf;
#line 674
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 674
  __cil_tmp22 = *((int    *)__cil_tmp21);
#line 674
  *((uint32 *)__cil_tmp18) = (uint32 )__cil_tmp22;
#line 675
  __cil_tmp23 = 8 + 4;
#line 675
  __cil_tmp24 = (unsigned long )cmd;
#line 675
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
#line 675
  __cil_tmp26 = (unsigned long )srf;
#line 675
  __cil_tmp27 = __cil_tmp26 + 112;
#line 675
  __cil_tmp28 = *((uint32_t    *)__cil_tmp27);
#line 675
  *((SVGA3dSurfaceFlags *)__cil_tmp25) = (SVGA3dSurfaceFlags )__cil_tmp28;
#line 676
  __cil_tmp29 = 8 + 8;
#line 676
  __cil_tmp30 = (unsigned long )cmd;
#line 676
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 676
  __cil_tmp32 = (unsigned long )srf;
#line 676
  __cil_tmp33 = __cil_tmp32 + 116;
#line 676
  __cil_tmp34 = *((uint32_t    *)__cil_tmp33);
#line 676
  __cil_tmp35 = (__u32 )__cil_tmp34;
#line 676
  *((SVGA3dSurfaceFormat *)__cil_tmp31) = (SVGA3dSurfaceFormat )__cil_tmp35;
#line 677
  i = 0;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (i < 6) {

    } else {
#line 677
      goto while_break;
    }
#line 678
    __cil_tmp36 = i * 4UL;
#line 678
    __cil_tmp37 = 12 + __cil_tmp36;
#line 678
    __cil_tmp38 = 8 + __cil_tmp37;
#line 678
    __cil_tmp39 = (unsigned long )cmd;
#line 678
    __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 678
    __cil_tmp41 = i * 4UL;
#line 678
    __cil_tmp42 = 120 + __cil_tmp41;
#line 678
    __cil_tmp43 = (unsigned long )srf;
#line 678
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 678
    *((uint32 *)__cil_tmp40) = *((uint32_t    *)__cil_tmp44);
#line 677
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  cmd = cmd + 1;
#line 681
  cmd_size = (SVGA3dSize *)cmd;
#line 682
  __cil_tmp45 = (unsigned long )srf;
#line 682
  __cil_tmp46 = __cil_tmp45 + 144;
#line 682
  __cil_tmp47 = *((struct drm_vmw_size *   *)__cil_tmp46);
#line 682
  src_size = (struct drm_vmw_size *)__cil_tmp47;
#line 684
  i = 0;
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 684
    __cil_tmp48 = (unsigned long )srf;
#line 684
    __cil_tmp49 = __cil_tmp48 + 152;
#line 684
    __cil_tmp50 = *((uint32_t    *)__cil_tmp49);
#line 684
    __cil_tmp51 = (uint32_t    )i;
#line 684
    if (__cil_tmp51 < __cil_tmp50) {

    } else {
#line 684
      goto while_break___0;
    }
    }
#line 685
    *((uint32 *)cmd_size) = *((uint32_t *)src_size);
#line 686
    __cil_tmp52 = (unsigned long )cmd_size;
#line 686
    __cil_tmp53 = __cil_tmp52 + 4;
#line 686
    __cil_tmp54 = (unsigned long )src_size;
#line 686
    __cil_tmp55 = __cil_tmp54 + 4;
#line 686
    *((uint32 *)__cil_tmp53) = *((uint32_t *)__cil_tmp55);
#line 687
    __cil_tmp56 = (unsigned long )cmd_size;
#line 687
    __cil_tmp57 = __cil_tmp56 + 8;
#line 687
    __cil_tmp58 = (unsigned long )src_size;
#line 687
    __cil_tmp59 = __cil_tmp58 + 8;
#line 687
    *((uint32 *)__cil_tmp57) = *((uint32_t *)__cil_tmp59);
#line 684
    i = i + 1;
#line 684
    cmd_size = cmd_size + 1;
#line 684
    src_size = src_size + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 689
  return;
}
}
#line 701 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_surface_dma_encode(struct vmw_surface *srf , void *cmd_space , SVGAGuestPtr    *ptr ,
                                   bool to_surface ) 
{ uint32_t i ;
  uint32_t bpp ;
  uint32_t stride_bpp ;
  struct vmw_surface_dma *cmd ;
  SVGA3dCmdHeader *header ;
  SVGA3dCmdSurfaceDMA *body ;
  SVGA3dCopyBox *cb ;
  SVGA3dCmdSurfaceDMASuffix *suffix ;
  struct vmw_surface_offset    *cur_offset ;
  struct drm_vmw_size    *cur_size ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint8_t    __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint8_t    __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_surface_offset *__cil_tmp39 ;
  struct vmw_surface_offset *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct drm_vmw_size *__cil_tmp43 ;
  struct drm_vmw_size *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  SVGAGuestPtr    __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  uint32_t    __cil_tmp56 ;
  uint32 __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  uint32 __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t    __cil_tmp66 ;
  uint32_t    __cil_tmp67 ;
  uint32_t    __cil_tmp68 ;
  uint32_t    __cil_tmp69 ;
  uint32_t    __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  uint32_t    __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  uint32_t    __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  uint32_t    __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  uint32_t    __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  uint32_t    __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  uint32_t    __cil_tmp118 ;
  uint32 __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  uint32_t    __cil_tmp122 ;
  uint32 __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32 __cil_tmp127 ;
  uint32 __cil_tmp128 ;
  uint32 __cil_tmp129 ;
  uint32 __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  uint32 __cil_tmp49_offset137 ;
  uint32 __cil_tmp49_gmrId138 ;
  uint32    __cil_tmp139 ;
  uint32    __cil_tmp140 ;

  {
#line 707
  __cil_tmp15 = (unsigned long )srf;
#line 707
  __cil_tmp16 = __cil_tmp15 + 116;
#line 707
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
#line 707
  __cil_tmp18 = __cil_tmp17 * 2UL;
#line 707
  __cil_tmp19 = (unsigned long )(vmw_sf_bpp) + __cil_tmp18;
#line 707
  __cil_tmp20 = *((uint8_t    *)__cil_tmp19);
#line 707
  bpp = (uint32_t )__cil_tmp20;
#line 708
  __cil_tmp21 = (unsigned long )srf;
#line 708
  __cil_tmp22 = __cil_tmp21 + 116;
#line 708
  __cil_tmp23 = *((uint32_t *)__cil_tmp22);
#line 708
  __cil_tmp24 = __cil_tmp23 * 2UL;
#line 708
  __cil_tmp25 = __cil_tmp24 + 1;
#line 708
  __cil_tmp26 = (unsigned long )(vmw_sf_bpp) + __cil_tmp25;
#line 708
  __cil_tmp27 = *((uint8_t    *)__cil_tmp26);
#line 708
  stride_bpp = (uint32_t )__cil_tmp27;
#line 709
  cmd = (struct vmw_surface_dma *)cmd_space;
#line 711
  i = (uint32_t )0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    __cil_tmp28 = (unsigned long )srf;
#line 711
    __cil_tmp29 = __cil_tmp28 + 152;
#line 711
    __cil_tmp30 = *((uint32_t *)__cil_tmp29);
#line 711
    if (i < __cil_tmp30) {

    } else {
#line 711
      goto while_break;
    }
    }
#line 712
    header = (SVGA3dCmdHeader *)cmd;
#line 713
    __cil_tmp31 = (unsigned long )cmd;
#line 713
    __cil_tmp32 = __cil_tmp31 + 8;
#line 713
    body = (SVGA3dCmdSurfaceDMA *)__cil_tmp32;
#line 714
    __cil_tmp33 = (unsigned long )cmd;
#line 714
    __cil_tmp34 = __cil_tmp33 + 36;
#line 714
    cb = (SVGA3dCopyBox *)__cil_tmp34;
#line 715
    __cil_tmp35 = (unsigned long )cmd;
#line 715
    __cil_tmp36 = __cil_tmp35 + 72;
#line 715
    suffix = (SVGA3dCmdSurfaceDMASuffix *)__cil_tmp36;
#line 716
    __cil_tmp37 = (unsigned long )srf;
#line 716
    __cil_tmp38 = __cil_tmp37 + 192;
#line 716
    __cil_tmp39 = *((struct vmw_surface_offset **)__cil_tmp38);
#line 716
    __cil_tmp40 = __cil_tmp39 + i;
#line 716
    cur_offset = (struct vmw_surface_offset    *)__cil_tmp40;
#line 717
    __cil_tmp41 = (unsigned long )srf;
#line 717
    __cil_tmp42 = __cil_tmp41 + 144;
#line 717
    __cil_tmp43 = *((struct drm_vmw_size **)__cil_tmp42);
#line 717
    __cil_tmp44 = __cil_tmp43 + i;
#line 717
    cur_size = (struct drm_vmw_size    *)__cil_tmp44;
#line 719
    *((uint32 *)header) = (uint32 )1044;
#line 720
    __cil_tmp45 = (unsigned long )header;
#line 720
    __cil_tmp46 = __cil_tmp45 + 4;
#line 720
    __cil_tmp47 = 28UL + 36UL;
#line 720
    __cil_tmp48 = __cil_tmp47 + 12UL;
#line 720
    *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp48;
#line 722
    __cil_tmp139 = ptr->gmrId;
#line 722
    __cil_tmp140 = ptr->offset;
#line 722
    __cil_tmp49_gmrId138 = __cil_tmp139;
#line 722
    __cil_tmp49_offset137 = __cil_tmp140;
#line 722
    *((SVGAGuestPtr *)body) = (SVGAGuestPtr )__cil_tmp49;
#line 723
    __cil_tmp50 = 0 + 4;
#line 723
    __cil_tmp51 = 0 + __cil_tmp50;
#line 723
    __cil_tmp52 = (unsigned long )body;
#line 723
    __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
#line 723
    __cil_tmp54 = (unsigned long )cur_offset;
#line 723
    __cil_tmp55 = __cil_tmp54 + 8;
#line 723
    __cil_tmp56 = *((uint32_t    *)__cil_tmp55);
#line 723
    __cil_tmp57 = (uint32 )__cil_tmp56;
#line 723
    __cil_tmp58 = 0 + 4;
#line 723
    __cil_tmp59 = 0 + __cil_tmp58;
#line 723
    __cil_tmp60 = (unsigned long )body;
#line 723
    __cil_tmp61 = __cil_tmp60 + __cil_tmp59;
#line 723
    __cil_tmp62 = *((uint32 *)__cil_tmp61);
#line 723
    *((uint32 *)__cil_tmp53) = __cil_tmp62 + __cil_tmp57;
#line 724
    __cil_tmp63 = 0 + 8;
#line 724
    __cil_tmp64 = (unsigned long )body;
#line 724
    __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
#line 724
    __cil_tmp66 = (uint32_t    )stride_bpp;
#line 724
    __cil_tmp67 = *((uint32_t    *)cur_size);
#line 724
    __cil_tmp68 = __cil_tmp67 * __cil_tmp66;
#line 724
    __cil_tmp69 = __cil_tmp68 + 7U;
#line 724
    __cil_tmp70 = __cil_tmp69 >> 3;
#line 724
    *((uint32 *)__cil_tmp65) = (uint32 )__cil_tmp70;
#line 725
    __cil_tmp71 = (unsigned long )body;
#line 725
    __cil_tmp72 = __cil_tmp71 + 12;
#line 725
    __cil_tmp73 = 0 + 24;
#line 725
    __cil_tmp74 = (unsigned long )srf;
#line 725
    __cil_tmp75 = __cil_tmp74 + __cil_tmp73;
#line 725
    __cil_tmp76 = *((int *)__cil_tmp75);
#line 725
    *((uint32 *)__cil_tmp72) = (uint32 )__cil_tmp76;
#line 726
    __cil_tmp77 = 12 + 4;
#line 726
    __cil_tmp78 = (unsigned long )body;
#line 726
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 726
    __cil_tmp80 = *((uint32_t    *)cur_offset);
#line 726
    *((uint32 *)__cil_tmp79) = (uint32 )__cil_tmp80;
#line 727
    __cil_tmp81 = 12 + 8;
#line 727
    __cil_tmp82 = (unsigned long )body;
#line 727
    __cil_tmp83 = __cil_tmp82 + __cil_tmp81;
#line 727
    __cil_tmp84 = (unsigned long )cur_offset;
#line 727
    __cil_tmp85 = __cil_tmp84 + 4;
#line 727
    __cil_tmp86 = *((uint32_t    *)__cil_tmp85);
#line 727
    *((uint32 *)__cil_tmp83) = (uint32 )__cil_tmp86;
#line 728
    if (to_surface) {
#line 728
      __cil_tmp87 = (unsigned long )body;
#line 728
      __cil_tmp88 = __cil_tmp87 + 24;
#line 728
      *((SVGA3dTransferType *)__cil_tmp88) = (SVGA3dTransferType )1;
    } else {
#line 728
      __cil_tmp89 = (unsigned long )body;
#line 728
      __cil_tmp90 = __cil_tmp89 + 24;
#line 728
      *((SVGA3dTransferType *)__cil_tmp90) = (SVGA3dTransferType )2;
    }
#line 730
    *((uint32 *)cb) = (uint32 )0;
#line 731
    __cil_tmp91 = (unsigned long )cb;
#line 731
    __cil_tmp92 = __cil_tmp91 + 4;
#line 731
    *((uint32 *)__cil_tmp92) = (uint32 )0;
#line 732
    __cil_tmp93 = (unsigned long )cb;
#line 732
    __cil_tmp94 = __cil_tmp93 + 8;
#line 732
    *((uint32 *)__cil_tmp94) = (uint32 )0;
#line 733
    __cil_tmp95 = (unsigned long )cb;
#line 733
    __cil_tmp96 = __cil_tmp95 + 24;
#line 733
    *((uint32 *)__cil_tmp96) = (uint32 )0;
#line 734
    __cil_tmp97 = (unsigned long )cb;
#line 734
    __cil_tmp98 = __cil_tmp97 + 28;
#line 734
    *((uint32 *)__cil_tmp98) = (uint32 )0;
#line 735
    __cil_tmp99 = (unsigned long )cb;
#line 735
    __cil_tmp100 = __cil_tmp99 + 32;
#line 735
    *((uint32 *)__cil_tmp100) = (uint32 )0;
#line 736
    __cil_tmp101 = (unsigned long )cb;
#line 736
    __cil_tmp102 = __cil_tmp101 + 12;
#line 736
    __cil_tmp103 = *((uint32_t    *)cur_size);
#line 736
    *((uint32 *)__cil_tmp102) = (uint32 )__cil_tmp103;
#line 737
    __cil_tmp104 = (unsigned long )cb;
#line 737
    __cil_tmp105 = __cil_tmp104 + 16;
#line 737
    __cil_tmp106 = (unsigned long )cur_size;
#line 737
    __cil_tmp107 = __cil_tmp106 + 4;
#line 737
    __cil_tmp108 = *((uint32_t    *)__cil_tmp107);
#line 737
    *((uint32 *)__cil_tmp105) = (uint32 )__cil_tmp108;
#line 738
    __cil_tmp109 = (unsigned long )cb;
#line 738
    __cil_tmp110 = __cil_tmp109 + 20;
#line 738
    __cil_tmp111 = (unsigned long )cur_size;
#line 738
    __cil_tmp112 = __cil_tmp111 + 8;
#line 738
    __cil_tmp113 = *((uint32_t    *)__cil_tmp112);
#line 738
    *((uint32 *)__cil_tmp110) = (uint32 )__cil_tmp113;
#line 740
    *((uint32 *)suffix) = (uint32 )12UL;
#line 741
    __cil_tmp114 = (unsigned long )suffix;
#line 741
    __cil_tmp115 = __cil_tmp114 + 4;
#line 741
    __cil_tmp116 = (unsigned long )cur_size;
#line 741
    __cil_tmp117 = __cil_tmp116 + 8;
#line 741
    __cil_tmp118 = *((uint32_t    *)__cil_tmp117);
#line 741
    __cil_tmp119 = (uint32 )__cil_tmp118;
#line 741
    __cil_tmp120 = (unsigned long )cur_size;
#line 741
    __cil_tmp121 = __cil_tmp120 + 4;
#line 741
    __cil_tmp122 = *((uint32_t    *)__cil_tmp121);
#line 741
    __cil_tmp123 = (uint32 )__cil_tmp122;
#line 741
    __cil_tmp124 = 0 + 8;
#line 741
    __cil_tmp125 = (unsigned long )body;
#line 741
    __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 741
    __cil_tmp127 = *((uint32 *)__cil_tmp126);
#line 741
    __cil_tmp128 = __cil_tmp127 * __cil_tmp123;
#line 741
    __cil_tmp129 = __cil_tmp128 * __cil_tmp119;
#line 741
    __cil_tmp130 = __cil_tmp129 * bpp;
#line 741
    *((uint32 *)__cil_tmp115) = __cil_tmp130 / stride_bpp;
#line 743
    __cil_tmp131 = (unsigned long )suffix;
#line 743
    __cil_tmp132 = __cil_tmp131 + 8;
#line 743
    *((uint32 *)__cil_tmp132) = (uint32 )0;
#line 744
    __cil_tmp133 = (unsigned long )suffix;
#line 744
    __cil_tmp134 = __cil_tmp133 + 8;
#line 744
    ((struct __anonstruct_SVGA3dSurfaceDMAFlags_107 *)__cil_tmp134)->unsynchronized = (uint32 )0;
#line 745
    __cil_tmp135 = (unsigned long )suffix;
#line 745
    __cil_tmp136 = __cil_tmp135 + 8;
#line 745
    ((struct __anonstruct_SVGA3dSurfaceDMAFlags_107 *)__cil_tmp136)->reserved = (uint32 )0;
#line 746
    cmd = cmd + 1;
#line 711
    i = i + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return;
}
}
#line 751 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_hw_surface_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  void *cmd ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  struct vmw_resource    *__mptr ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct mutex *__cil_tmp27 ;
  struct vmw_surface *__cil_tmp28 ;
  struct vmw_resource *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  bool __cil_tmp44 ;

  {
#line 754
  __cil_tmp9 = (unsigned long )res;
#line 754
  __cil_tmp10 = __cil_tmp9 + 8;
#line 754
  dev_priv = *((struct vmw_private **)__cil_tmp10);
  {
#line 758
  __cil_tmp11 = (unsigned long )res;
#line 758
  __cil_tmp12 = __cil_tmp11 + 24;
#line 758
  __cil_tmp13 = *((int *)__cil_tmp12);
#line 758
  if (__cil_tmp13 != -1) {
    {
#line 760
    tmp___7 = vmw_surface_destroy_size();
#line 760
    cmd = vmw_fifo_reserve(dev_priv, tmp___7);
#line 761
    __cil_tmp14 = (void *)0;
#line 761
    __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 761
    __cil_tmp16 = (unsigned long )cmd;
#line 761
    __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
#line 761
    __cil_tmp18 = ! __cil_tmp17;
#line 761
    __cil_tmp19 = ! __cil_tmp18;
#line 761
    __cil_tmp20 = (long )__cil_tmp19;
#line 761
    tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
    }
#line 761
    if (tmp___8) {
      {
#line 762
      drm_err("vmw_hw_surface_destroy", "Failed reserving FIFO space for surface destruction.\n");
      }
#line 764
      return;
    } else {

    }
    {
#line 767
    __cil_tmp21 = (unsigned long )res;
#line 767
    __cil_tmp22 = __cil_tmp21 + 24;
#line 767
    __cil_tmp23 = *((int *)__cil_tmp22);
#line 767
    __cil_tmp24 = (uint32_t )__cil_tmp23;
#line 767
    vmw_surface_destroy_encode(__cil_tmp24, cmd);
#line 768
    tmp___9 = vmw_surface_destroy_size();
#line 768
    vmw_fifo_commit(dev_priv, tmp___9);
#line 776
    __cil_tmp25 = (unsigned long )dev_priv;
#line 776
    __cil_tmp26 = __cil_tmp25 + 134304;
#line 776
    __cil_tmp27 = (struct mutex *)__cil_tmp26;
#line 776
    mutex_lock(__cil_tmp27);
#line 777
    __mptr = (struct vmw_resource    *)res;
#line 777
    __cil_tmp28 = (struct vmw_surface *)0;
#line 777
    __cil_tmp29 = (struct vmw_resource *)__cil_tmp28;
#line 777
    __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 777
    __cil_tmp31 = (char *)__mptr;
#line 777
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 777
    srf = (struct vmw_surface *)__cil_tmp32;
#line 778
    __cil_tmp33 = (unsigned long )dev_priv;
#line 778
    __cil_tmp34 = __cil_tmp33 + 134784;
#line 778
    __cil_tmp35 = (unsigned long )srf;
#line 778
    __cil_tmp36 = __cil_tmp35 + 200;
#line 778
    __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 778
    __cil_tmp38 = (unsigned long )dev_priv;
#line 778
    __cil_tmp39 = __cil_tmp38 + 134784;
#line 778
    __cil_tmp40 = *((uint32_t *)__cil_tmp39);
#line 778
    *((uint32_t *)__cil_tmp34) = __cil_tmp40 - __cil_tmp37;
#line 779
    __cil_tmp41 = (unsigned long )dev_priv;
#line 779
    __cil_tmp42 = __cil_tmp41 + 134304;
#line 779
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
#line 779
    mutex_unlock(__cil_tmp43);
    }
  } else {

  }
  }
  {
#line 782
  __cil_tmp44 = (bool )0;
#line 782
  vmw_3d_resource_dec(dev_priv, __cil_tmp44);
  }
#line 783
  return;
}
}
#line 785 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
void vmw_surface_res_free(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource    *__mptr ;
  struct vmw_surface *__cil_tmp4 ;
  struct vmw_resource *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct ttm_buffer_object **__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_surface_offset *__cil_tmp16 ;
  void    *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_vmw_size *__cil_tmp20 ;
  void    *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t *__cil_tmp25 ;
  void    *__cil_tmp26 ;
  void    *__cil_tmp27 ;

  {
#line 787
  __mptr = (struct vmw_resource    *)res;
#line 787
  __cil_tmp4 = (struct vmw_surface *)0;
#line 787
  __cil_tmp5 = (struct vmw_resource *)__cil_tmp4;
#line 787
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 787
  __cil_tmp7 = (char *)__mptr;
#line 787
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 787
  srf = (struct vmw_surface *)__cil_tmp8;
  {
#line 789
  __cil_tmp9 = (unsigned long )srf;
#line 789
  __cil_tmp10 = __cil_tmp9 + 184;
#line 789
  if (*((struct ttm_buffer_object **)__cil_tmp10)) {
    {
#line 790
    __cil_tmp11 = (unsigned long )srf;
#line 790
    __cil_tmp12 = __cil_tmp11 + 184;
#line 790
    __cil_tmp13 = (struct ttm_buffer_object **)__cil_tmp12;
#line 790
    ttm_bo_unref(__cil_tmp13);
    }
  } else {

  }
  }
  {
#line 791
  __cil_tmp14 = (unsigned long )srf;
#line 791
  __cil_tmp15 = __cil_tmp14 + 192;
#line 791
  __cil_tmp16 = *((struct vmw_surface_offset **)__cil_tmp15);
#line 791
  __cil_tmp17 = (void    *)__cil_tmp16;
#line 791
  kfree(__cil_tmp17);
#line 792
  __cil_tmp18 = (unsigned long )srf;
#line 792
  __cil_tmp19 = __cil_tmp18 + 144;
#line 792
  __cil_tmp20 = *((struct drm_vmw_size **)__cil_tmp19);
#line 792
  __cil_tmp21 = (void    *)__cil_tmp20;
#line 792
  kfree(__cil_tmp21);
#line 793
  __cil_tmp22 = 160 + 16;
#line 793
  __cil_tmp23 = (unsigned long )srf;
#line 793
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 793
  __cil_tmp25 = *((uint32_t **)__cil_tmp24);
#line 793
  __cil_tmp26 = (void    *)__cil_tmp25;
#line 793
  kfree(__cil_tmp26);
#line 794
  __cil_tmp27 = (void    *)srf;
#line 794
  kfree(__cil_tmp27);
  }
#line 795
  return;
}
}
#line 812 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_do_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  uint32_t tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  SVGAGuestPtr ptr ;
  uint32_t tmp___16 ;
  struct vmw_fence_obj *fence ;
  long tmp___17 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct ttm_buffer_object *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_validate_buffer *__cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct ttm_buffer_object *__cil_tmp58 ;
  bool __cil_tmp59 ;
  bool __cil_tmp60 ;
  bool __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  long __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  struct vmw_surface    *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct vmw_surface    *__cil_tmp80 ;
  void *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  long __cil_tmp87 ;
  struct vmw_surface    *__cil_tmp88 ;
  void *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct vmw_surface    *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  struct ttm_buffer_object *__cil_tmp95 ;
  struct ttm_buffer_object    *__cil_tmp96 ;
  void *__cil_tmp97 ;
  SVGAGuestPtr    *__cil_tmp98 ;
  bool __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  void *__cil_tmp102 ;
  struct drm_file *__cil_tmp103 ;
  void *__cil_tmp104 ;
  uint32_t *__cil_tmp105 ;
  struct vmw_fence_obj **__cil_tmp106 ;
  struct vmw_fence_obj *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct vmw_fence_obj **__cil_tmp111 ;
  struct vmw_fence_obj *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  struct ttm_buffer_object **__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  struct ttm_buffer_object **__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  struct ttm_buffer_object **__cil_tmp136 ;

  {
  {
#line 815
  res = (struct vmw_resource *)srf;
#line 822
  __cil_tmp22 = (unsigned long )res;
#line 822
  __cil_tmp23 = __cil_tmp22 + 24;
#line 822
  __cil_tmp24 = *((int *)__cil_tmp23);
#line 822
  __cil_tmp25 = __cil_tmp24 != -1;
#line 822
  __cil_tmp26 = ! __cil_tmp25;
#line 822
  __cil_tmp27 = ! __cil_tmp26;
#line 822
  __cil_tmp28 = (long )__cil_tmp27;
#line 822
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 1L);
  }
#line 822
  if (tmp___7) {
#line 823
    return (0);
  } else {

  }
  {
#line 825
  __cil_tmp29 = (unsigned long )dev_priv;
#line 825
  __cil_tmp30 = __cil_tmp29 + 2172;
#line 825
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
#line 825
  __cil_tmp32 = (unsigned long )srf;
#line 825
  __cil_tmp33 = __cil_tmp32 + 200;
#line 825
  __cil_tmp34 = *((uint32_t *)__cil_tmp33);
#line 825
  __cil_tmp35 = (unsigned long )dev_priv;
#line 825
  __cil_tmp36 = __cil_tmp35 + 134784;
#line 825
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 825
  __cil_tmp38 = __cil_tmp37 + __cil_tmp34;
#line 825
  __cil_tmp39 = __cil_tmp38 >= __cil_tmp31;
#line 825
  __cil_tmp40 = ! __cil_tmp39;
#line 825
  __cil_tmp41 = ! __cil_tmp40;
#line 825
  __cil_tmp42 = (long )__cil_tmp41;
#line 825
  tmp___8 = ldv__builtin_expect(__cil_tmp42, 0L);
  }
#line 825
  if (tmp___8) {
#line 827
    return (-16);
  } else {

  }
  {
#line 833
  __cil_tmp43 = (unsigned long )srf;
#line 833
  __cil_tmp44 = __cil_tmp43 + 184;
#line 833
  if (*((struct ttm_buffer_object **)__cil_tmp44)) {
    {
#line 834
    INIT_LIST_HEAD(& val_list);
#line 835
    __cil_tmp45 = (unsigned long )(& val_buf) + 16;
#line 835
    __cil_tmp46 = (unsigned long )srf;
#line 835
    __cil_tmp47 = __cil_tmp46 + 184;
#line 835
    __cil_tmp48 = *((struct ttm_buffer_object **)__cil_tmp47);
#line 835
    *((struct ttm_buffer_object **)__cil_tmp45) = ttm_bo_reference(__cil_tmp48);
#line 836
    __cil_tmp49 = (unsigned long )(& val_buf) + 24;
#line 836
    *((void **)__cil_tmp49) = (void *)1UL;
#line 838
    __cil_tmp50 = & val_buf;
#line 838
    __cil_tmp51 = (struct list_head *)__cil_tmp50;
#line 838
    list_add_tail(__cil_tmp51, & val_list);
#line 839
    ret = ttm_eu_reserve_buffers(& val_list);
#line 840
    __cil_tmp52 = ret != 0;
#line 840
    __cil_tmp53 = ! __cil_tmp52;
#line 840
    __cil_tmp54 = ! __cil_tmp53;
#line 840
    __cil_tmp55 = (long )__cil_tmp54;
#line 840
    tmp___9 = ldv__builtin_expect(__cil_tmp55, 0L);
    }
#line 840
    if (tmp___9) {
#line 841
      goto out_no_reserve;
    } else {

    }
    {
#line 843
    __cil_tmp56 = (unsigned long )srf;
#line 843
    __cil_tmp57 = __cil_tmp56 + 184;
#line 843
    __cil_tmp58 = *((struct ttm_buffer_object **)__cil_tmp57);
#line 843
    __cil_tmp59 = (bool )1;
#line 843
    __cil_tmp60 = (bool )0;
#line 843
    __cil_tmp61 = (bool )0;
#line 843
    ret = ttm_bo_validate(__cil_tmp58, & vmw_srf_placement, __cil_tmp59, __cil_tmp60,
                          __cil_tmp61);
#line 845
    __cil_tmp62 = ret != 0;
#line 845
    __cil_tmp63 = ! __cil_tmp62;
#line 845
    __cil_tmp64 = ! __cil_tmp63;
#line 845
    __cil_tmp65 = (long )__cil_tmp64;
#line 845
    tmp___10 = ldv__builtin_expect(__cil_tmp65, 0L);
    }
#line 845
    if (tmp___10) {
#line 846
      goto out_no_id;
    } else {

    }
  } else {

  }
  }
  {
#line 853
  ret = vmw_resource_alloc_id(dev_priv, res);
#line 854
  __cil_tmp66 = ret != 0;
#line 854
  __cil_tmp67 = ! __cil_tmp66;
#line 854
  __cil_tmp68 = ! __cil_tmp67;
#line 854
  __cil_tmp69 = (long )__cil_tmp68;
#line 854
  tmp___11 = ldv__builtin_expect(__cil_tmp69, 0L);
  }
#line 854
  if (tmp___11) {
    {
#line 855
    drm_err("vmw_surface_do_validate", "Failed to allocate a surface id.\n");
    }
#line 856
    goto out_no_id;
  } else {

  }
  {
#line 858
  __cil_tmp70 = (unsigned long )res;
#line 858
  __cil_tmp71 = __cil_tmp70 + 24;
#line 858
  __cil_tmp72 = *((int *)__cil_tmp71);
#line 858
  __cil_tmp73 = __cil_tmp72 >= 32768;
#line 858
  __cil_tmp74 = ! __cil_tmp73;
#line 858
  __cil_tmp75 = ! __cil_tmp74;
#line 858
  __cil_tmp76 = (long )__cil_tmp75;
#line 858
  tmp___12 = ldv__builtin_expect(__cil_tmp76, 0L);
  }
#line 858
  if (tmp___12) {
#line 859
    ret = -16;
#line 860
    goto out_no_fifo;
  } else {

  }
  {
#line 868
  __cil_tmp77 = (struct vmw_surface    *)srf;
#line 868
  submit_size = vmw_surface_define_size(__cil_tmp77);
  }
  {
#line 869
  __cil_tmp78 = (unsigned long )srf;
#line 869
  __cil_tmp79 = __cil_tmp78 + 184;
#line 869
  if (*((struct ttm_buffer_object **)__cil_tmp79)) {
    {
#line 870
    __cil_tmp80 = (struct vmw_surface    *)srf;
#line 870
    tmp___13 = vmw_surface_dma_size(__cil_tmp80);
#line 870
    submit_size = submit_size + tmp___13;
    }
  } else {

  }
  }
  {
#line 872
  tmp___14 = vmw_fifo_reserve(dev_priv, submit_size);
#line 872
  cmd = (uint8_t *)tmp___14;
#line 873
  __cil_tmp81 = (void *)0;
#line 873
  __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 873
  __cil_tmp83 = (unsigned long )cmd;
#line 873
  __cil_tmp84 = __cil_tmp83 == __cil_tmp82;
#line 873
  __cil_tmp85 = ! __cil_tmp84;
#line 873
  __cil_tmp86 = ! __cil_tmp85;
#line 873
  __cil_tmp87 = (long )__cil_tmp86;
#line 873
  tmp___15 = ldv__builtin_expect(__cil_tmp87, 0L);
  }
#line 873
  if (tmp___15) {
    {
#line 874
    drm_err("vmw_surface_do_validate", "Failed reserving FIFO space for surface validation.\n");
#line 876
    ret = -12;
    }
#line 877
    goto out_no_fifo;
  } else {

  }
  {
#line 880
  __cil_tmp88 = (struct vmw_surface    *)srf;
#line 880
  __cil_tmp89 = (void *)cmd;
#line 880
  vmw_surface_define_encode(__cil_tmp88, __cil_tmp89);
  }
  {
#line 881
  __cil_tmp90 = (unsigned long )srf;
#line 881
  __cil_tmp91 = __cil_tmp90 + 184;
#line 881
  if (*((struct ttm_buffer_object **)__cil_tmp91)) {
    {
#line 884
    __cil_tmp92 = (struct vmw_surface    *)srf;
#line 884
    tmp___16 = vmw_surface_define_size(__cil_tmp92);
#line 884
    cmd = cmd + tmp___16;
#line 885
    __cil_tmp93 = (unsigned long )srf;
#line 885
    __cil_tmp94 = __cil_tmp93 + 184;
#line 885
    __cil_tmp95 = *((struct ttm_buffer_object **)__cil_tmp94);
#line 885
    __cil_tmp96 = (struct ttm_buffer_object    *)__cil_tmp95;
#line 885
    vmw_bo_get_guest_ptr(__cil_tmp96, & ptr);
#line 886
    __cil_tmp97 = (void *)cmd;
#line 886
    __cil_tmp98 = (SVGAGuestPtr    *)(& ptr);
#line 886
    __cil_tmp99 = (bool )1;
#line 886
    vmw_surface_dma_encode(srf, __cil_tmp97, __cil_tmp98, __cil_tmp99);
    }
  } else {

  }
  }
  {
#line 889
  vmw_fifo_commit(dev_priv, submit_size);
  }
  {
#line 895
  __cil_tmp100 = (unsigned long )srf;
#line 895
  __cil_tmp101 = __cil_tmp100 + 184;
#line 895
  if (*((struct ttm_buffer_object **)__cil_tmp101)) {
    {
#line 898
    __cil_tmp102 = (void *)0;
#line 898
    __cil_tmp103 = (struct drm_file *)__cil_tmp102;
#line 898
    __cil_tmp104 = (void *)0;
#line 898
    __cil_tmp105 = (uint32_t *)__cil_tmp104;
#line 898
    vmw_execbuf_fence_commands(__cil_tmp103, dev_priv, & fence, __cil_tmp105);
#line 900
    __cil_tmp106 = & fence;
#line 900
    __cil_tmp107 = *__cil_tmp106;
#line 900
    __cil_tmp108 = (void *)__cil_tmp107;
#line 900
    ttm_eu_fence_buffer_objects(& val_list, __cil_tmp108);
#line 901
    __cil_tmp109 = (void *)0;
#line 901
    __cil_tmp110 = (unsigned long )__cil_tmp109;
#line 901
    __cil_tmp111 = & fence;
#line 901
    __cil_tmp112 = *__cil_tmp111;
#line 901
    __cil_tmp113 = (unsigned long )__cil_tmp112;
#line 901
    __cil_tmp114 = __cil_tmp113 != __cil_tmp110;
#line 901
    __cil_tmp115 = ! __cil_tmp114;
#line 901
    __cil_tmp116 = ! __cil_tmp115;
#line 901
    __cil_tmp117 = (long )__cil_tmp116;
#line 901
    tmp___17 = ldv__builtin_expect(__cil_tmp117, 1L);
    }
#line 901
    if (tmp___17) {
      {
#line 902
      vmw_fence_obj_unreference(& fence);
      }
    } else {

    }
    {
#line 903
    __cil_tmp118 = (unsigned long )(& val_buf) + 16;
#line 903
    __cil_tmp119 = (struct ttm_buffer_object **)__cil_tmp118;
#line 903
    ttm_bo_unref(__cil_tmp119);
#line 904
    __cil_tmp120 = (unsigned long )srf;
#line 904
    __cil_tmp121 = __cil_tmp120 + 184;
#line 904
    __cil_tmp122 = (struct ttm_buffer_object **)__cil_tmp121;
#line 904
    ttm_bo_unref(__cil_tmp122);
    }
  } else {

  }
  }
#line 911
  __cil_tmp123 = (unsigned long )dev_priv;
#line 911
  __cil_tmp124 = __cil_tmp123 + 134784;
#line 911
  __cil_tmp125 = (unsigned long )srf;
#line 911
  __cil_tmp126 = __cil_tmp125 + 200;
#line 911
  __cil_tmp127 = *((uint32_t *)__cil_tmp126);
#line 911
  __cil_tmp128 = (unsigned long )dev_priv;
#line 911
  __cil_tmp129 = __cil_tmp128 + 134784;
#line 911
  __cil_tmp130 = *((uint32_t *)__cil_tmp129);
#line 911
  *((uint32_t *)__cil_tmp124) = __cil_tmp130 + __cil_tmp127;
#line 913
  return (0);
  out_no_fifo: 
  {
#line 916
  vmw_resource_release_id(res);
  }
  out_no_id: 
  {
#line 919
  __cil_tmp131 = (unsigned long )srf;
#line 919
  __cil_tmp132 = __cil_tmp131 + 184;
#line 919
  if (*((struct ttm_buffer_object **)__cil_tmp132)) {
    {
#line 920
    ttm_eu_backoff_reservation(& val_list);
    }
  } else {

  }
  }
  out_no_reserve: 
  {
#line 922
  __cil_tmp133 = (unsigned long )srf;
#line 922
  __cil_tmp134 = __cil_tmp133 + 184;
#line 922
  if (*((struct ttm_buffer_object **)__cil_tmp134)) {
    {
#line 923
    __cil_tmp135 = (unsigned long )(& val_buf) + 16;
#line 923
    __cil_tmp136 = (struct ttm_buffer_object **)__cil_tmp135;
#line 923
    ttm_bo_unref(__cil_tmp136);
    }
  } else {

  }
  }
#line 924
  return (ret);
}
}
#line 936 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_evict(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  struct vmw_fence_obj *fence ;
  SVGAGuestPtr ptr ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  uint32_t tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_buffer_object *__cil_tmp30 ;
  struct ttm_bo_device *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  enum ttm_bo_type __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  bool __cil_tmp38 ;
  void *__cil_tmp39 ;
  struct file *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct ttm_buffer_object **__cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_buffer_object *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct ttm_validate_buffer *__cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct ttm_buffer_object *__cil_tmp61 ;
  bool __cil_tmp62 ;
  bool __cil_tmp63 ;
  bool __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  long __cil_tmp68 ;
  struct vmw_surface    *__cil_tmp69 ;
  void *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object *__cil_tmp79 ;
  struct ttm_buffer_object    *__cil_tmp80 ;
  void *__cil_tmp81 ;
  SVGAGuestPtr    *__cil_tmp82 ;
  bool __cil_tmp83 ;
  struct vmw_surface    *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int __cil_tmp87 ;
  uint32_t __cil_tmp88 ;
  void *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  uint32_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  void *__cil_tmp98 ;
  struct drm_file *__cil_tmp99 ;
  void *__cil_tmp100 ;
  uint32_t *__cil_tmp101 ;
  struct vmw_fence_obj **__cil_tmp102 ;
  struct vmw_fence_obj *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct vmw_fence_obj **__cil_tmp107 ;
  struct vmw_fence_obj *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  struct ttm_buffer_object **__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  struct ttm_buffer_object **__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  struct ttm_buffer_object **__cil_tmp122 ;

  {
#line 939
  res = (struct vmw_resource *)srf;
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 948
    __cil_tmp21 = (unsigned long )res;
#line 948
    __cil_tmp22 = __cil_tmp21 + 24;
#line 948
    __cil_tmp23 = *((int *)__cil_tmp22);
#line 948
    __cil_tmp24 = __cil_tmp23 == -1;
#line 948
    __cil_tmp25 = ! __cil_tmp24;
#line 948
    __cil_tmp26 = ! __cil_tmp25;
#line 948
    __cil_tmp27 = (long )__cil_tmp26;
#line 948
    tmp___7 = ldv__builtin_expect(__cil_tmp27, 0L);
    }
#line 948
    if (tmp___7) {
      {
#line 948
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 948
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (948), "i" (12UL));
        {
#line 948
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 948
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 948
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 954
  __cil_tmp28 = (unsigned long )srf;
#line 954
  __cil_tmp29 = __cil_tmp28 + 184;
#line 954
  __cil_tmp30 = *((struct ttm_buffer_object **)__cil_tmp29);
#line 954
  if (! __cil_tmp30) {
    {
#line 955
    __cil_tmp31 = (struct ttm_bo_device *)dev_priv;
#line 955
    __cil_tmp32 = (unsigned long )srf;
#line 955
    __cil_tmp33 = __cil_tmp32 + 200;
#line 955
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
#line 955
    __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 955
    __cil_tmp36 = (enum ttm_bo_type )0;
#line 955
    __cil_tmp37 = (uint32_t )0;
#line 955
    __cil_tmp38 = (bool )1;
#line 955
    __cil_tmp39 = (void *)0;
#line 955
    __cil_tmp40 = (struct file *)__cil_tmp39;
#line 955
    __cil_tmp41 = (unsigned long )srf;
#line 955
    __cil_tmp42 = __cil_tmp41 + 184;
#line 955
    __cil_tmp43 = (struct ttm_buffer_object **)__cil_tmp42;
#line 955
    ret = ttm_bo_create(__cil_tmp31, __cil_tmp35, __cil_tmp36, & vmw_srf_placement,
                        __cil_tmp37, 0UL, __cil_tmp38, __cil_tmp40, __cil_tmp43);
#line 959
    __cil_tmp44 = ret != 0;
#line 959
    __cil_tmp45 = ! __cil_tmp44;
#line 959
    __cil_tmp46 = ! __cil_tmp45;
#line 959
    __cil_tmp47 = (long )__cil_tmp46;
#line 959
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 0L);
    }
#line 959
    if (tmp___8) {
#line 960
      return (ret);
    } else {

    }
  } else {

  }
  }
  {
#line 967
  INIT_LIST_HEAD(& val_list);
#line 968
  __cil_tmp48 = (unsigned long )(& val_buf) + 16;
#line 968
  __cil_tmp49 = (unsigned long )srf;
#line 968
  __cil_tmp50 = __cil_tmp49 + 184;
#line 968
  __cil_tmp51 = *((struct ttm_buffer_object **)__cil_tmp50);
#line 968
  *((struct ttm_buffer_object **)__cil_tmp48) = ttm_bo_reference(__cil_tmp51);
#line 969
  __cil_tmp52 = (unsigned long )(& val_buf) + 24;
#line 969
  *((void **)__cil_tmp52) = (void *)1UL;
#line 971
  __cil_tmp53 = & val_buf;
#line 971
  __cil_tmp54 = (struct list_head *)__cil_tmp53;
#line 971
  list_add_tail(__cil_tmp54, & val_list);
#line 972
  ret = ttm_eu_reserve_buffers(& val_list);
#line 973
  __cil_tmp55 = ret != 0;
#line 973
  __cil_tmp56 = ! __cil_tmp55;
#line 973
  __cil_tmp57 = ! __cil_tmp56;
#line 973
  __cil_tmp58 = (long )__cil_tmp57;
#line 973
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 0L);
  }
#line 973
  if (tmp___9) {
#line 974
    goto out_no_reserve;
  } else {

  }
  {
#line 976
  __cil_tmp59 = (unsigned long )srf;
#line 976
  __cil_tmp60 = __cil_tmp59 + 184;
#line 976
  __cil_tmp61 = *((struct ttm_buffer_object **)__cil_tmp60);
#line 976
  __cil_tmp62 = (bool )1;
#line 976
  __cil_tmp63 = (bool )0;
#line 976
  __cil_tmp64 = (bool )0;
#line 976
  ret = ttm_bo_validate(__cil_tmp61, & vmw_srf_placement, __cil_tmp62, __cil_tmp63,
                        __cil_tmp64);
#line 978
  __cil_tmp65 = ret != 0;
#line 978
  __cil_tmp66 = ! __cil_tmp65;
#line 978
  __cil_tmp67 = ! __cil_tmp66;
#line 978
  __cil_tmp68 = (long )__cil_tmp67;
#line 978
  tmp___10 = ldv__builtin_expect(__cil_tmp68, 0L);
  }
#line 978
  if (tmp___10) {
#line 979
    goto out_no_fifo;
  } else {

  }
  {
#line 986
  __cil_tmp69 = (struct vmw_surface    *)srf;
#line 986
  tmp___11 = vmw_surface_dma_size(__cil_tmp69);
#line 986
  tmp___12 = vmw_surface_destroy_size();
#line 986
  submit_size = tmp___11 + tmp___12;
#line 987
  tmp___13 = vmw_fifo_reserve(dev_priv, submit_size);
#line 987
  cmd = (uint8_t *)tmp___13;
#line 988
  __cil_tmp70 = (void *)0;
#line 988
  __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 988
  __cil_tmp72 = (unsigned long )cmd;
#line 988
  __cil_tmp73 = __cil_tmp72 == __cil_tmp71;
#line 988
  __cil_tmp74 = ! __cil_tmp73;
#line 988
  __cil_tmp75 = ! __cil_tmp74;
#line 988
  __cil_tmp76 = (long )__cil_tmp75;
#line 988
  tmp___14 = ldv__builtin_expect(__cil_tmp76, 0L);
  }
#line 988
  if (tmp___14) {
    {
#line 989
    drm_err("vmw_surface_evict", "Failed reserving FIFO space for surface eviction.\n");
#line 991
    ret = -12;
    }
#line 992
    goto out_no_fifo;
  } else {

  }
  {
#line 995
  __cil_tmp77 = (unsigned long )srf;
#line 995
  __cil_tmp78 = __cil_tmp77 + 184;
#line 995
  __cil_tmp79 = *((struct ttm_buffer_object **)__cil_tmp78);
#line 995
  __cil_tmp80 = (struct ttm_buffer_object    *)__cil_tmp79;
#line 995
  vmw_bo_get_guest_ptr(__cil_tmp80, & ptr);
#line 996
  __cil_tmp81 = (void *)cmd;
#line 996
  __cil_tmp82 = (SVGAGuestPtr    *)(& ptr);
#line 996
  __cil_tmp83 = (bool )0;
#line 996
  vmw_surface_dma_encode(srf, __cil_tmp81, __cil_tmp82, __cil_tmp83);
#line 997
  __cil_tmp84 = (struct vmw_surface    *)srf;
#line 997
  tmp___15 = vmw_surface_dma_size(__cil_tmp84);
#line 997
  cmd = cmd + tmp___15;
#line 998
  __cil_tmp85 = (unsigned long )res;
#line 998
  __cil_tmp86 = __cil_tmp85 + 24;
#line 998
  __cil_tmp87 = *((int *)__cil_tmp86);
#line 998
  __cil_tmp88 = (uint32_t )__cil_tmp87;
#line 998
  __cil_tmp89 = (void *)cmd;
#line 998
  vmw_surface_destroy_encode(__cil_tmp88, __cil_tmp89);
#line 999
  vmw_fifo_commit(dev_priv, submit_size);
#line 1005
  __cil_tmp90 = (unsigned long )dev_priv;
#line 1005
  __cil_tmp91 = __cil_tmp90 + 134784;
#line 1005
  __cil_tmp92 = (unsigned long )srf;
#line 1005
  __cil_tmp93 = __cil_tmp92 + 200;
#line 1005
  __cil_tmp94 = *((uint32_t *)__cil_tmp93);
#line 1005
  __cil_tmp95 = (unsigned long )dev_priv;
#line 1005
  __cil_tmp96 = __cil_tmp95 + 134784;
#line 1005
  __cil_tmp97 = *((uint32_t *)__cil_tmp96);
#line 1005
  *((uint32_t *)__cil_tmp91) = __cil_tmp97 - __cil_tmp94;
#line 1011
  __cil_tmp98 = (void *)0;
#line 1011
  __cil_tmp99 = (struct drm_file *)__cil_tmp98;
#line 1011
  __cil_tmp100 = (void *)0;
#line 1011
  __cil_tmp101 = (uint32_t *)__cil_tmp100;
#line 1011
  vmw_execbuf_fence_commands(__cil_tmp99, dev_priv, & fence, __cil_tmp101);
#line 1013
  __cil_tmp102 = & fence;
#line 1013
  __cil_tmp103 = *__cil_tmp102;
#line 1013
  __cil_tmp104 = (void *)__cil_tmp103;
#line 1013
  ttm_eu_fence_buffer_objects(& val_list, __cil_tmp104);
#line 1014
  __cil_tmp105 = (void *)0;
#line 1014
  __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 1014
  __cil_tmp107 = & fence;
#line 1014
  __cil_tmp108 = *__cil_tmp107;
#line 1014
  __cil_tmp109 = (unsigned long )__cil_tmp108;
#line 1014
  __cil_tmp110 = __cil_tmp109 != __cil_tmp106;
#line 1014
  __cil_tmp111 = ! __cil_tmp110;
#line 1014
  __cil_tmp112 = ! __cil_tmp111;
#line 1014
  __cil_tmp113 = (long )__cil_tmp112;
#line 1014
  tmp___16 = ldv__builtin_expect(__cil_tmp113, 1L);
  }
#line 1014
  if (tmp___16) {
    {
#line 1015
    vmw_fence_obj_unreference(& fence);
    }
  } else {

  }
  {
#line 1016
  __cil_tmp114 = (unsigned long )(& val_buf) + 16;
#line 1016
  __cil_tmp115 = (struct ttm_buffer_object **)__cil_tmp114;
#line 1016
  ttm_bo_unref(__cil_tmp115);
#line 1022
  vmw_resource_release_id(res);
  }
#line 1024
  return (0);
  out_no_fifo: 
  {
#line 1028
  __cil_tmp116 = (unsigned long )srf;
#line 1028
  __cil_tmp117 = __cil_tmp116 + 184;
#line 1028
  if (*((struct ttm_buffer_object **)__cil_tmp117)) {
    {
#line 1029
    ttm_eu_backoff_reservation(& val_list);
    }
  } else {

  }
  }
  out_no_reserve: 
  {
#line 1031
  __cil_tmp118 = (unsigned long )(& val_buf) + 16;
#line 1031
  __cil_tmp119 = (struct ttm_buffer_object **)__cil_tmp118;
#line 1031
  ttm_bo_unref(__cil_tmp119);
#line 1032
  __cil_tmp120 = (unsigned long )srf;
#line 1032
  __cil_tmp121 = __cil_tmp120 + 184;
#line 1032
  __cil_tmp122 = (struct ttm_buffer_object **)__cil_tmp121;
#line 1032
  ttm_bo_unref(__cil_tmp122);
  }
#line 1033
  return (ret);
}
}
#line 1050 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ int ret ;
  struct vmw_surface *evict_srf ;
  long tmp___7 ;
  int tmp___8 ;
  struct list_head    *__mptr ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  rwlock_t *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  rwlock_t *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  rwlock_t *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  struct list_head    *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  rwlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct vmw_surface **__cil_tmp36 ;
  struct vmw_surface *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  struct vmw_surface *__cil_tmp44 ;
  struct vmw_surface **__cil_tmp45 ;
  struct vmw_surface *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct list_head *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  rwlock_t *__cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  struct vmw_surface *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  rwlock_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  rwlock_t *__cil_tmp71 ;

  {
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1057
    __cil_tmp10 = (unsigned long )dev_priv;
#line 1057
    __cil_tmp11 = __cil_tmp10 + 2632;
#line 1057
    __cil_tmp12 = (rwlock_t *)__cil_tmp11;
#line 1057
    _raw_write_lock(__cil_tmp12);
#line 1058
    __cil_tmp13 = (unsigned long )srf;
#line 1058
    __cil_tmp14 = __cil_tmp13 + 96;
#line 1058
    __cil_tmp15 = (struct list_head *)__cil_tmp14;
#line 1058
    list_del_init(__cil_tmp15);
#line 1059
    __cil_tmp16 = (unsigned long )dev_priv;
#line 1059
    __cil_tmp17 = __cil_tmp16 + 2632;
#line 1059
    __cil_tmp18 = (rwlock_t *)__cil_tmp17;
#line 1059
    _raw_write_unlock(__cil_tmp18);
#line 1061
    ret = vmw_surface_do_validate(dev_priv, srf);
#line 1062
    __cil_tmp19 = ret != -16;
#line 1062
    __cil_tmp20 = ! __cil_tmp19;
#line 1062
    __cil_tmp21 = ! __cil_tmp20;
#line 1062
    __cil_tmp22 = (long )__cil_tmp21;
#line 1062
    tmp___7 = ldv__builtin_expect(__cil_tmp22, 1L);
    }
#line 1062
    if (tmp___7) {
#line 1063
      goto while_break;
    } else {

    }
    {
#line 1065
    __cil_tmp23 = (unsigned long )dev_priv;
#line 1065
    __cil_tmp24 = __cil_tmp23 + 2632;
#line 1065
    __cil_tmp25 = (rwlock_t *)__cil_tmp24;
#line 1065
    _raw_write_lock(__cil_tmp25);
#line 1066
    __cil_tmp26 = (unsigned long )dev_priv;
#line 1066
    __cil_tmp27 = __cil_tmp26 + 134768;
#line 1066
    __cil_tmp28 = (struct list_head *)__cil_tmp27;
#line 1066
    __cil_tmp29 = (struct list_head    *)__cil_tmp28;
#line 1066
    tmp___8 = list_empty(__cil_tmp29);
    }
#line 1066
    if (tmp___8) {
      {
#line 1067
      drm_err("vmw_surface_validate", "Out of device memory for surfaces.\n");
#line 1068
      ret = -16;
#line 1069
      __cil_tmp30 = (unsigned long )dev_priv;
#line 1069
      __cil_tmp31 = __cil_tmp30 + 2632;
#line 1069
      __cil_tmp32 = (rwlock_t *)__cil_tmp31;
#line 1069
      _raw_write_unlock(__cil_tmp32);
      }
#line 1070
      goto while_break;
    } else {

    }
    {
#line 1074
    __cil_tmp33 = (unsigned long )dev_priv;
#line 1074
    __cil_tmp34 = __cil_tmp33 + 134768;
#line 1074
    __cil_tmp35 = *((struct list_head **)__cil_tmp34);
#line 1074
    __mptr = (struct list_head    *)__cil_tmp35;
#line 1074
    __cil_tmp36 = & evict_srf;
#line 1074
    __cil_tmp37 = (struct vmw_surface *)0;
#line 1074
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 1074
    __cil_tmp39 = __cil_tmp38 + 96;
#line 1074
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
#line 1074
    __cil_tmp41 = (unsigned int )__cil_tmp40;
#line 1074
    __cil_tmp42 = (char *)__mptr;
#line 1074
    __cil_tmp43 = __cil_tmp42 - __cil_tmp41;
#line 1074
    __cil_tmp44 = (struct vmw_surface *)__cil_tmp43;
#line 1074
    *__cil_tmp36 = vmw_surface_reference(__cil_tmp44);
#line 1077
    __cil_tmp45 = & evict_srf;
#line 1077
    __cil_tmp46 = *__cil_tmp45;
#line 1077
    __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 1077
    __cil_tmp48 = __cil_tmp47 + 96;
#line 1077
    __cil_tmp49 = (struct list_head *)__cil_tmp48;
#line 1077
    list_del_init(__cil_tmp49);
#line 1079
    __cil_tmp50 = (unsigned long )dev_priv;
#line 1079
    __cil_tmp51 = __cil_tmp50 + 2632;
#line 1079
    __cil_tmp52 = (rwlock_t *)__cil_tmp51;
#line 1079
    _raw_write_unlock(__cil_tmp52);
#line 1080
    __cil_tmp53 = & evict_srf;
#line 1080
    __cil_tmp54 = *__cil_tmp53;
#line 1080
    vmw_surface_evict(dev_priv, __cil_tmp54);
#line 1082
    vmw_surface_unreference(& evict_srf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1086
  if (ret != 0) {
    {
#line 1086
    __cil_tmp55 = 0 + 24;
#line 1086
    __cil_tmp56 = (unsigned long )srf;
#line 1086
    __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
#line 1086
    __cil_tmp58 = *((int *)__cil_tmp57);
#line 1086
    if (__cil_tmp58 != -1) {
#line 1086
      tmp___9 = 1;
    } else {
#line 1086
      tmp___9 = 0;
    }
    }
  } else {
#line 1086
    tmp___9 = 0;
  }
  {
#line 1086
  __cil_tmp59 = (long )tmp___9;
#line 1086
  tmp___10 = ldv__builtin_expect(__cil_tmp59, 0L);
  }
#line 1086
  if (tmp___10) {
    {
#line 1087
    __cil_tmp60 = (unsigned long )dev_priv;
#line 1087
    __cil_tmp61 = __cil_tmp60 + 2632;
#line 1087
    __cil_tmp62 = (rwlock_t *)__cil_tmp61;
#line 1087
    _raw_write_lock(__cil_tmp62);
#line 1088
    __cil_tmp63 = (unsigned long )srf;
#line 1088
    __cil_tmp64 = __cil_tmp63 + 96;
#line 1088
    __cil_tmp65 = (struct list_head *)__cil_tmp64;
#line 1088
    __cil_tmp66 = (unsigned long )dev_priv;
#line 1088
    __cil_tmp67 = __cil_tmp66 + 134768;
#line 1088
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 1088
    list_add_tail(__cil_tmp65, __cil_tmp68);
#line 1089
    __cil_tmp69 = (unsigned long )dev_priv;
#line 1089
    __cil_tmp70 = __cil_tmp69 + 2632;
#line 1089
    __cil_tmp71 = (rwlock_t *)__cil_tmp70;
#line 1089
    _raw_write_unlock(__cil_tmp71);
    }
  } else {

  }
#line 1092
  return (ret);
}
}
#line 1104 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_surface_remove_from_lists(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource    *__mptr ;
  struct vmw_surface *__cil_tmp4 ;
  struct vmw_resource *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;

  {
  {
#line 1106
  __mptr = (struct vmw_resource    *)res;
#line 1106
  __cil_tmp4 = (struct vmw_surface *)0;
#line 1106
  __cil_tmp5 = (struct vmw_resource *)__cil_tmp4;
#line 1106
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 1106
  __cil_tmp7 = (char *)__mptr;
#line 1106
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 1106
  srf = (struct vmw_surface *)__cil_tmp8;
#line 1108
  __cil_tmp9 = (unsigned long )srf;
#line 1108
  __cil_tmp10 = __cil_tmp9 + 96;
#line 1108
  __cil_tmp11 = (struct list_head *)__cil_tmp10;
#line 1108
  list_del_init(__cil_tmp11);
  }
#line 1109
  return;
}
}
#line 1111 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource *res ) ) 
{ int ret ;
  struct vmw_resource *res ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct idr *__cil_tmp20 ;
  enum ttm_object_type __cil_tmp21 ;
  bool __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  bool __cil_tmp27 ;

  {
#line 1116
  res = (struct vmw_resource *)srf;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1118
    __cil_tmp8 = (void *)0;
#line 1118
    __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 1118
    __cil_tmp10 = (unsigned long )res_free;
#line 1118
    __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
#line 1118
    __cil_tmp12 = ! __cil_tmp11;
#line 1118
    __cil_tmp13 = ! __cil_tmp12;
#line 1118
    __cil_tmp14 = (long )__cil_tmp13;
#line 1118
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    }
#line 1118
    if (tmp___7) {
      {
#line 1118
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1118
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1118), "i" (12UL));
        {
#line 1118
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1118
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 1118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1119
  __cil_tmp15 = (unsigned long )srf;
#line 1119
  __cil_tmp16 = __cil_tmp15 + 96;
#line 1119
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
#line 1119
  INIT_LIST_HEAD(__cil_tmp17);
#line 1120
  __cil_tmp18 = (unsigned long )dev_priv;
#line 1120
  __cil_tmp19 = __cil_tmp18 + 2704;
#line 1120
  __cil_tmp20 = (struct idr *)__cil_tmp19;
#line 1120
  __cil_tmp21 = (enum ttm_object_type )257;
#line 1120
  __cil_tmp22 = (bool )1;
#line 1120
  ret = vmw_resource_init(dev_priv, res, __cil_tmp20, __cil_tmp21, __cil_tmp22, res_free,
                          & vmw_surface_remove_from_lists);
#line 1124
  __cil_tmp23 = ret != 0;
#line 1124
  __cil_tmp24 = ! __cil_tmp23;
#line 1124
  __cil_tmp25 = ! __cil_tmp24;
#line 1124
  __cil_tmp26 = (long )__cil_tmp25;
#line 1124
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 1124
  if (tmp___8) {
    {
#line 1125
    (*res_free)(res);
    }
  } else {

  }
  {
#line 1132
  __cil_tmp27 = (bool )0;
#line 1132
  vmw_3d_resource_inc(dev_priv, __cil_tmp27);
#line 1133
  vmw_resource_activate(res, & vmw_hw_surface_destroy);
  }
#line 1134
  return (ret);
}
}
#line 1137 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_surface_free(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource    *__mptr ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface    *__mptr___0 ;
  struct vmw_private *dev_priv ;
  uint32_t size ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_surface *__cil_tmp9 ;
  struct vmw_resource *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct vmw_user_surface *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_surface *__cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_buffer_object **__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_surface_offset *__cil_tmp33 ;
  void    *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct drm_vmw_size *__cil_tmp37 ;
  void    *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  void    *__cil_tmp43 ;
  void    *__cil_tmp44 ;
  uint64_t __cil_tmp45 ;

  {
#line 1139
  __mptr = (struct vmw_resource    *)res;
#line 1139
  __cil_tmp9 = (struct vmw_surface *)0;
#line 1139
  __cil_tmp10 = (struct vmw_resource *)__cil_tmp9;
#line 1139
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 1139
  __cil_tmp12 = (char *)__mptr;
#line 1139
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 1139
  srf = (struct vmw_surface *)__cil_tmp13;
#line 1141
  __mptr___0 = (struct vmw_surface    *)srf;
#line 1141
  __cil_tmp14 = (struct vmw_user_surface *)0;
#line 1141
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 1141
  __cil_tmp16 = __cil_tmp15 + 64;
#line 1141
  __cil_tmp17 = (struct vmw_surface *)__cil_tmp16;
#line 1141
  __cil_tmp18 = (unsigned int )__cil_tmp17;
#line 1141
  __cil_tmp19 = (char *)__mptr___0;
#line 1141
  __cil_tmp20 = __cil_tmp19 - __cil_tmp18;
#line 1141
  user_srf = (struct vmw_user_surface *)__cil_tmp20;
#line 1142
  __cil_tmp21 = 0 + 8;
#line 1142
  __cil_tmp22 = (unsigned long )srf;
#line 1142
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 1142
  dev_priv = *((struct vmw_private **)__cil_tmp23);
#line 1143
  __cil_tmp24 = (unsigned long )user_srf;
#line 1143
  __cil_tmp25 = __cil_tmp24 + 272;
#line 1143
  size = *((uint32_t *)__cil_tmp25);
  {
#line 1145
  __cil_tmp26 = (unsigned long )srf;
#line 1145
  __cil_tmp27 = __cil_tmp26 + 184;
#line 1145
  if (*((struct ttm_buffer_object **)__cil_tmp27)) {
    {
#line 1146
    __cil_tmp28 = (unsigned long )srf;
#line 1146
    __cil_tmp29 = __cil_tmp28 + 184;
#line 1146
    __cil_tmp30 = (struct ttm_buffer_object **)__cil_tmp29;
#line 1146
    ttm_bo_unref(__cil_tmp30);
    }
  } else {

  }
  }
  {
#line 1147
  __cil_tmp31 = (unsigned long )srf;
#line 1147
  __cil_tmp32 = __cil_tmp31 + 192;
#line 1147
  __cil_tmp33 = *((struct vmw_surface_offset **)__cil_tmp32);
#line 1147
  __cil_tmp34 = (void    *)__cil_tmp33;
#line 1147
  kfree(__cil_tmp34);
#line 1148
  __cil_tmp35 = (unsigned long )srf;
#line 1148
  __cil_tmp36 = __cil_tmp35 + 144;
#line 1148
  __cil_tmp37 = *((struct drm_vmw_size **)__cil_tmp36);
#line 1148
  __cil_tmp38 = (void    *)__cil_tmp37;
#line 1148
  kfree(__cil_tmp38);
#line 1149
  __cil_tmp39 = 160 + 16;
#line 1149
  __cil_tmp40 = (unsigned long )srf;
#line 1149
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 1149
  __cil_tmp42 = *((uint32_t **)__cil_tmp41);
#line 1149
  __cil_tmp43 = (void    *)__cil_tmp42;
#line 1149
  kfree(__cil_tmp43);
#line 1150
  __cil_tmp44 = (void    *)user_srf;
#line 1150
  kfree(__cil_tmp44);
#line 1151
  tmp___7 = vmw_mem_glob(dev_priv);
#line 1151
  __cil_tmp45 = (uint64_t )size;
#line 1151
  ttm_mem_global_free(tmp___7, __cil_tmp45);
  }
#line 1152
  return;
}
}
#line 1167 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
void vmw_resource_unreserve(struct list_head *list ) 
{ struct vmw_resource *res ;
  struct vmw_surface *srf ;
  rwlock_t *lock ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  long tmp___7 ;
  struct vmw_resource    *__mptr___1 ;
  void *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void (*__cil_tmp26)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void (*__cil_tmp31)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_private *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_surface *__cil_tmp45 ;
  struct vmw_resource *__cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct vmw_private *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct list_head *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  void *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;

  {
#line 1171
  __cil_tmp9 = (void *)0;
#line 1171
  lock = (rwlock_t *)__cil_tmp9;
#line 1173
  __cil_tmp10 = *((struct list_head **)list);
#line 1173
  __mptr = (struct list_head    *)__cil_tmp10;
#line 1173
  __cil_tmp11 = (struct vmw_resource *)0;
#line 1173
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 1173
  __cil_tmp13 = __cil_tmp12 + 64;
#line 1173
  __cil_tmp14 = (struct list_head *)__cil_tmp13;
#line 1173
  __cil_tmp15 = (unsigned int )__cil_tmp14;
#line 1173
  __cil_tmp16 = (char *)__mptr;
#line 1173
  __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
#line 1173
  res = (struct vmw_resource *)__cil_tmp17;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1173
    __cil_tmp18 = (unsigned long )list;
#line 1173
    __cil_tmp19 = (unsigned long )res;
#line 1173
    __cil_tmp20 = __cil_tmp19 + 64;
#line 1173
    __cil_tmp21 = (struct list_head *)__cil_tmp20;
#line 1173
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 1173
    if (__cil_tmp22 != __cil_tmp18) {

    } else {
#line 1173
      goto while_break;
    }
    }
    {
#line 1175
    __cil_tmp23 = (unsigned long )(& vmw_surface_res_free);
#line 1175
    __cil_tmp24 = (unsigned long )res;
#line 1175
    __cil_tmp25 = __cil_tmp24 + 56;
#line 1175
    __cil_tmp26 = *((void (**)(struct vmw_resource *res ))__cil_tmp25);
#line 1175
    __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 1175
    if (__cil_tmp27 != __cil_tmp23) {
      {
#line 1175
      __cil_tmp28 = (unsigned long )(& vmw_user_surface_free);
#line 1175
      __cil_tmp29 = (unsigned long )res;
#line 1175
      __cil_tmp30 = __cil_tmp29 + 56;
#line 1175
      __cil_tmp31 = *((void (**)(struct vmw_resource *res ))__cil_tmp30);
#line 1175
      __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 1175
      if (__cil_tmp32 != __cil_tmp28) {
#line 1177
        goto __Cont;
      } else {

      }
      }
    } else {

    }
    }
    {
#line 1179
    __cil_tmp33 = (void *)0;
#line 1179
    __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 1179
    __cil_tmp35 = (unsigned long )lock;
#line 1179
    __cil_tmp36 = __cil_tmp35 == __cil_tmp34;
#line 1179
    __cil_tmp37 = ! __cil_tmp36;
#line 1179
    __cil_tmp38 = ! __cil_tmp37;
#line 1179
    __cil_tmp39 = (long )__cil_tmp38;
#line 1179
    tmp___7 = ldv__builtin_expect(__cil_tmp39, 0L);
    }
#line 1179
    if (tmp___7) {
      {
#line 1180
      __cil_tmp40 = (unsigned long )res;
#line 1180
      __cil_tmp41 = __cil_tmp40 + 8;
#line 1180
      __cil_tmp42 = *((struct vmw_private **)__cil_tmp41);
#line 1180
      __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 1180
      __cil_tmp44 = __cil_tmp43 + 2632;
#line 1180
      lock = (rwlock_t *)__cil_tmp44;
#line 1181
      _raw_write_lock(lock);
      }
    } else {

    }
    {
#line 1184
    __mptr___1 = (struct vmw_resource    *)res;
#line 1184
    __cil_tmp45 = (struct vmw_surface *)0;
#line 1184
    __cil_tmp46 = (struct vmw_resource *)__cil_tmp45;
#line 1184
    __cil_tmp47 = (unsigned int )__cil_tmp46;
#line 1184
    __cil_tmp48 = (char *)__mptr___1;
#line 1184
    __cil_tmp49 = __cil_tmp48 - __cil_tmp47;
#line 1184
    srf = (struct vmw_surface *)__cil_tmp49;
#line 1185
    __cil_tmp50 = (unsigned long )srf;
#line 1185
    __cil_tmp51 = __cil_tmp50 + 96;
#line 1185
    __cil_tmp52 = (struct list_head *)__cil_tmp51;
#line 1185
    list_del_init(__cil_tmp52);
#line 1186
    __cil_tmp53 = (unsigned long )srf;
#line 1186
    __cil_tmp54 = __cil_tmp53 + 96;
#line 1186
    __cil_tmp55 = (struct list_head *)__cil_tmp54;
#line 1186
    __cil_tmp56 = (unsigned long )res;
#line 1186
    __cil_tmp57 = __cil_tmp56 + 8;
#line 1186
    __cil_tmp58 = *((struct vmw_private **)__cil_tmp57);
#line 1186
    __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1186
    __cil_tmp60 = __cil_tmp59 + 134768;
#line 1186
    __cil_tmp61 = (struct list_head *)__cil_tmp60;
#line 1186
    list_add_tail(__cil_tmp55, __cil_tmp61);
    }
    __Cont: /* CIL Label */ 
#line 1173
    __cil_tmp62 = (unsigned long )res;
#line 1173
    __cil_tmp63 = __cil_tmp62 + 64;
#line 1173
    __cil_tmp64 = *((struct list_head **)__cil_tmp63);
#line 1173
    __mptr___0 = (struct list_head    *)__cil_tmp64;
#line 1173
    __cil_tmp65 = (struct vmw_resource *)0;
#line 1173
    __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 1173
    __cil_tmp67 = __cil_tmp66 + 64;
#line 1173
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 1173
    __cil_tmp69 = (unsigned int )__cil_tmp68;
#line 1173
    __cil_tmp70 = (char *)__mptr___0;
#line 1173
    __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
#line 1173
    res = (struct vmw_resource *)__cil_tmp71;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1189
  __cil_tmp72 = (void *)0;
#line 1189
  __cil_tmp73 = (unsigned long )__cil_tmp72;
#line 1189
  __cil_tmp74 = (unsigned long )lock;
#line 1189
  if (__cil_tmp74 != __cil_tmp73) {
    {
#line 1190
    _raw_write_unlock(lock);
    }
  } else {

  }
  }
#line 1191
  return;
}
}
#line 1198 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) 
{ int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long __cil_tmp9 ;

  {
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (*out_surf) {
#line 1206
      tmp___7 = 1;
    } else
#line 1206
    if (*out_buf) {
#line 1206
      tmp___7 = 1;
    } else {
#line 1206
      tmp___7 = 0;
    }
    {
#line 1206
    __cil_tmp9 = (long )tmp___7;
#line 1206
    tmp___8 = ldv__builtin_expect(__cil_tmp9, 0L);
    }
#line 1206
    if (tmp___8) {
      {
#line 1206
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1206
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1206), "i" (12UL));
        {
#line 1206
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1206
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 1206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1208
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, handle, out_surf);
  }
#line 1209
  if (! ret) {
#line 1210
    return (0);
  } else {

  }
  {
#line 1212
  ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);
  }
#line 1213
  return (ret);
}
}
#line 1217 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) 
{ struct vmw_resource *res ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object    *__mptr ;
  struct ttm_base_object **__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_base_object **__cil_tmp16 ;
  struct ttm_base_object *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct ttm_base_object **__cil_tmp23 ;
  struct ttm_base_object *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  enum ttm_object_type __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  struct ttm_base_object **__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  struct vmw_user_surface *__cil_tmp35 ;
  struct ttm_base_object *__cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  rwlock_t *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  rwlock_t *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void (*__cil_tmp54)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  rwlock_t *__cil_tmp58 ;
  struct kref *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  rwlock_t *__cil_tmp62 ;

  {
  {
#line 1225
  ret = -22;
#line 1227
  __cil_tmp13 = & base;
#line 1227
  *__cil_tmp13 = ttm_base_object_lookup(tfile, handle);
#line 1228
  __cil_tmp14 = (void *)0;
#line 1228
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 1228
  __cil_tmp16 = & base;
#line 1228
  __cil_tmp17 = *__cil_tmp16;
#line 1228
  __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 1228
  __cil_tmp19 = __cil_tmp18 == __cil_tmp15;
#line 1228
  __cil_tmp20 = ! __cil_tmp19;
#line 1228
  __cil_tmp21 = ! __cil_tmp20;
#line 1228
  __cil_tmp22 = (long )__cil_tmp21;
#line 1228
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 1228
  if (tmp___7) {
#line 1229
    return (-22);
  } else {

  }
  {
#line 1231
  __cil_tmp23 = & base;
#line 1231
  __cil_tmp24 = *__cil_tmp23;
#line 1231
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 1231
  __cil_tmp26 = __cil_tmp25 + 24;
#line 1231
  __cil_tmp27 = *((enum ttm_object_type *)__cil_tmp26);
#line 1231
  __cil_tmp28 = (unsigned int )__cil_tmp27;
#line 1231
  __cil_tmp29 = __cil_tmp28 != 257U;
#line 1231
  __cil_tmp30 = ! __cil_tmp29;
#line 1231
  __cil_tmp31 = ! __cil_tmp30;
#line 1231
  __cil_tmp32 = (long )__cil_tmp31;
#line 1231
  tmp___8 = ldv__builtin_expect(__cil_tmp32, 0L);
  }
#line 1231
  if (tmp___8) {
#line 1232
    goto out_bad_resource;
  } else {

  }
  {
#line 1234
  __cil_tmp33 = & base;
#line 1234
  __cil_tmp34 = *__cil_tmp33;
#line 1234
  __mptr = (struct ttm_base_object    *)__cil_tmp34;
#line 1234
  __cil_tmp35 = (struct vmw_user_surface *)0;
#line 1234
  __cil_tmp36 = (struct ttm_base_object *)__cil_tmp35;
#line 1234
  __cil_tmp37 = (unsigned int )__cil_tmp36;
#line 1234
  __cil_tmp38 = (char *)__mptr;
#line 1234
  __cil_tmp39 = __cil_tmp38 - __cil_tmp37;
#line 1234
  user_srf = (struct vmw_user_surface *)__cil_tmp39;
#line 1235
  __cil_tmp40 = (unsigned long )user_srf;
#line 1235
  __cil_tmp41 = __cil_tmp40 + 64;
#line 1235
  srf = (struct vmw_surface *)__cil_tmp41;
#line 1236
  res = (struct vmw_resource *)srf;
#line 1238
  __cil_tmp42 = (unsigned long )dev_priv;
#line 1238
  __cil_tmp43 = __cil_tmp42 + 2632;
#line 1238
  __cil_tmp44 = (rwlock_t *)__cil_tmp43;
#line 1238
  _raw_read_lock(__cil_tmp44);
  }
  {
#line 1240
  __cil_tmp45 = (unsigned long )res;
#line 1240
  __cil_tmp46 = __cil_tmp45 + 32;
#line 1240
  __cil_tmp47 = *((bool *)__cil_tmp46);
#line 1240
  if (! __cil_tmp47) {
    {
#line 1241
    __cil_tmp48 = (unsigned long )dev_priv;
#line 1241
    __cil_tmp49 = __cil_tmp48 + 2632;
#line 1241
    __cil_tmp50 = (rwlock_t *)__cil_tmp49;
#line 1241
    _raw_read_unlock(__cil_tmp50);
    }
#line 1242
    goto out_bad_resource;
  } else {
    {
#line 1240
    __cil_tmp51 = (unsigned long )(& vmw_user_surface_free);
#line 1240
    __cil_tmp52 = (unsigned long )res;
#line 1240
    __cil_tmp53 = __cil_tmp52 + 56;
#line 1240
    __cil_tmp54 = *((void (**)(struct vmw_resource *res ))__cil_tmp53);
#line 1240
    __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 1240
    if (__cil_tmp55 != __cil_tmp51) {
      {
#line 1241
      __cil_tmp56 = (unsigned long )dev_priv;
#line 1241
      __cil_tmp57 = __cil_tmp56 + 2632;
#line 1241
      __cil_tmp58 = (rwlock_t *)__cil_tmp57;
#line 1241
      _raw_read_unlock(__cil_tmp58);
      }
#line 1242
      goto out_bad_resource;
    } else {

    }
    }
  }
  }
  {
#line 1245
  __cil_tmp59 = (struct kref *)res;
#line 1245
  kref_get(__cil_tmp59);
#line 1246
  __cil_tmp60 = (unsigned long )dev_priv;
#line 1246
  __cil_tmp61 = __cil_tmp60 + 2632;
#line 1246
  __cil_tmp62 = (rwlock_t *)__cil_tmp61;
#line 1246
  _raw_read_unlock(__cil_tmp62);
#line 1248
  *out = srf;
#line 1249
  ret = 0;
  }
  out_bad_resource: 
  {
#line 1252
  ttm_base_object_unref(& base);
  }
#line 1254
  return (ret);
}
}
#line 1257 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_surface_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object    *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_surface *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 1259
  base = *p_base;
#line 1261
  __mptr = (struct ttm_base_object    *)base;
#line 1261
  __cil_tmp6 = (struct vmw_user_surface *)0;
#line 1261
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
#line 1261
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 1261
  __cil_tmp9 = (char *)__mptr;
#line 1261
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 1261
  user_srf = (struct vmw_user_surface *)__cil_tmp10;
#line 1262
  __cil_tmp11 = & res;
#line 1262
  __cil_tmp12 = (unsigned long )user_srf;
#line 1262
  __cil_tmp13 = __cil_tmp12 + 64;
#line 1262
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
#line 1264
  __cil_tmp14 = (void *)0;
#line 1264
  *p_base = (struct ttm_base_object *)__cil_tmp14;
#line 1265
  vmw_resource_unreference(& res);
  }
#line 1266
  return;
}
}
#line 1268 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_surface_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  {
#line 1271
  arg = (struct drm_vmw_surface_arg *)data;
#line 1272
  tmp___7 = vmw_fpriv(file_priv);
#line 1272
  __cil_tmp8 = (unsigned long )tmp___7;
#line 1272
  __cil_tmp9 = __cil_tmp8 + 8;
#line 1272
  tfile = *((struct ttm_object_file **)__cil_tmp9);
#line 1274
  __cil_tmp10 = *((int32_t *)arg);
#line 1274
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1274
  __cil_tmp12 = (enum ttm_ref_type )0;
#line 1274
  tmp___8 = ttm_ref_object_base_unref(tfile, __cil_tmp11, __cil_tmp12);
  }
#line 1274
  return (tmp___8);
}
}
#line 1277 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *srf ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  union drm_vmw_surface_create_arg *arg ;
  struct drm_vmw_surface_create_req *req ;
  struct drm_vmw_surface_arg *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct drm_vmw_size *user_sizes ;
  int ret ;
  int i ;
  int j ;
  uint32_t cur_bo_offset ;
  struct drm_vmw_size *cur_size ;
  struct vmw_surface_offset *cur_offset ;
  uint32_t stride_bpp ;
  uint32_t bpp ;
  uint32_t num_sizes ;
  uint32_t size ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  long tmp___15 ;
  struct ttm_mem_global *tmp___16 ;
  long tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  size_t __len ;
  void *__ret ;
  void *tmp___20 ;
  long tmp___21 ;
  void *tmp___22 ;
  long tmp___23 ;
  unsigned long tmp___24 ;
  long tmp___25 ;
  uint32_t stride ;
  void *tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;
  struct ttm_mem_global *tmp___29 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_master *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  size_t __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  uint32_t __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint64_t __cil_tmp69 ;
  uint64_t __cil_tmp70 ;
  uint64_t __cil_tmp71 ;
  uint64_t __cil_tmp72 ;
  uint64_t __cil_tmp73 ;
  struct ttm_lock *__cil_tmp74 ;
  bool __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  long __cil_tmp79 ;
  uint64_t __cil_tmp80 ;
  bool __cil_tmp81 ;
  bool __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  long __cil_tmp86 ;
  void *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct vmw_resource **__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  int32_t __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  void *__cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  uint32_t *__cil_tmp115 ;
  void *__cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  uint32_t *__cil_tmp121 ;
  void    *__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32_t *__cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  uint32_t *__cil_tmp133 ;
  void    *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  void *__cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  struct drm_vmw_size *__cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  int __cil_tmp154 ;
  long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  void *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  struct drm_vmw_size *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  int __cil_tmp169 ;
  int __cil_tmp170 ;
  int __cil_tmp171 ;
  long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  uint64_t __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  struct drm_vmw_size *__cil_tmp179 ;
  void *__cil_tmp180 ;
  void    *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  int __cil_tmp187 ;
  int __cil_tmp188 ;
  int __cil_tmp189 ;
  long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  uint32_t __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint8_t    __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  uint32_t __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  uint8_t    __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  uint32_t __cil_tmp212 ;
  uint32_t __cil_tmp213 ;
  uint32_t __cil_tmp214 ;
  uint32_t __cil_tmp215 ;
  uint32_t __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  uint32_t __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  uint32_t __cil_tmp226 ;
  uint32_t __cil_tmp227 ;
  uint32_t __cil_tmp228 ;
  uint32_t __cil_tmp229 ;
  uint32_t __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  uint32_t __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct drm_vmw_size *__cil_tmp240 ;
  struct drm_vmw_size *__cil_tmp241 ;
  uint32_t __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  struct drm_vmw_size *__cil_tmp245 ;
  struct drm_vmw_size *__cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  uint32_t __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  uint32_t __cil_tmp252 ;
  size_t __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  uint32_t *__cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  void *__cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  void *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  void *__cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  void *__cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  void *__cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  void *__cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  void *__cil_tmp290 ;
  int __cil_tmp291 ;
  int __cil_tmp292 ;
  int __cil_tmp293 ;
  long __cil_tmp294 ;
  struct vmw_resource **__cil_tmp295 ;
  struct vmw_resource *__cil_tmp296 ;
  struct ttm_base_object *__cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  unsigned long __cil_tmp299 ;
  int32_t __cil_tmp300 ;
  bool __cil_tmp301 ;
  enum ttm_object_type __cil_tmp302 ;
  void *__cil_tmp303 ;
  void (*__cil_tmp304)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp305 ;
  int __cil_tmp306 ;
  int __cil_tmp307 ;
  long __cil_tmp308 ;
  unsigned long __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  int32_t __cil_tmp314 ;
  uint32 __cil_tmp315 ;
  struct ttm_lock *__cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  unsigned long __cil_tmp318 ;
  struct vmw_surface_offset *__cil_tmp319 ;
  void    *__cil_tmp320 ;
  unsigned long __cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  struct drm_vmw_size *__cil_tmp323 ;
  void    *__cil_tmp324 ;
  void    *__cil_tmp325 ;
  uint64_t __cil_tmp326 ;
  struct ttm_lock *__cil_tmp327 ;

  {
  {
#line 1280
  tmp___7 = vmw_priv(dev);
#line 1280
  dev_priv = tmp___7;
#line 1285
  arg = (union drm_vmw_surface_create_arg *)data;
#line 1287
  req = (struct drm_vmw_surface_create_req *)arg;
#line 1288
  rep = (struct drm_vmw_surface_arg *)arg;
#line 1289
  tmp___9 = vmw_fpriv(file_priv);
#line 1289
  __cil_tmp50 = (unsigned long )tmp___9;
#line 1289
  __cil_tmp51 = __cil_tmp50 + 8;
#line 1289
  tfile = *((struct ttm_object_file **)__cil_tmp51);
#line 1300
  __cil_tmp52 = (unsigned long )file_priv;
#line 1300
  __cil_tmp53 = __cil_tmp52 + 152;
#line 1300
  __cil_tmp54 = *((struct drm_master **)__cil_tmp53);
#line 1300
  tmp___10 = vmw_master(__cil_tmp54);
#line 1300
  vmaster = tmp___10;
#line 1302
  __cil_tmp55 = vmw_user_surface_size == 0ULL;
#line 1302
  __cil_tmp56 = ! __cil_tmp55;
#line 1302
  __cil_tmp57 = ! __cil_tmp56;
#line 1302
  __cil_tmp58 = (long )__cil_tmp57;
#line 1302
  tmp___12 = ldv__builtin_expect(__cil_tmp58, 0L);
  }
#line 1302
  if (tmp___12) {
    {
#line 1303
    tmp___11 = ttm_round_pot(280UL);
#line 1303
    __cil_tmp59 = tmp___11 + 128UL;
#line 1303
    vmw_user_surface_size = (uint64_t )__cil_tmp59;
    }
  } else {

  }
#line 1306
  num_sizes = (uint32_t )0;
#line 1307
  i = 0;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1307
    if (i < 6) {

    } else {
#line 1307
      goto while_break;
    }
#line 1308
    __cil_tmp60 = i * 4UL;
#line 1308
    __cil_tmp61 = 8 + __cil_tmp60;
#line 1308
    __cil_tmp62 = (unsigned long )req;
#line 1308
    __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
#line 1308
    __cil_tmp64 = *((uint32_t *)__cil_tmp63);
#line 1308
    num_sizes = num_sizes + __cil_tmp64;
#line 1307
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  if (num_sizes > 144U) {
#line 1312
    return (-22);
  } else {

  }
  {
#line 1314
  __cil_tmp65 = (unsigned long )num_sizes;
#line 1314
  __cil_tmp66 = __cil_tmp65 * 16UL;
#line 1314
  tmp___13 = ttm_round_pot(__cil_tmp66);
#line 1314
  __cil_tmp67 = (unsigned long )num_sizes;
#line 1314
  __cil_tmp68 = __cil_tmp67 * 12UL;
#line 1314
  tmp___14 = ttm_round_pot(__cil_tmp68);
#line 1314
  __cil_tmp69 = (uint64_t )tmp___14;
#line 1314
  __cil_tmp70 = (uint64_t )tmp___13;
#line 1314
  __cil_tmp71 = vmw_user_surface_size + 128ULL;
#line 1314
  __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 1314
  __cil_tmp73 = __cil_tmp72 + __cil_tmp69;
#line 1314
  size = (uint32_t )__cil_tmp73;
#line 1319
  __cil_tmp74 = (struct ttm_lock *)vmaster;
#line 1319
  __cil_tmp75 = (bool )1;
#line 1319
  ret = ttm_read_lock(__cil_tmp74, __cil_tmp75);
#line 1320
  __cil_tmp76 = ret != 0;
#line 1320
  __cil_tmp77 = ! __cil_tmp76;
#line 1320
  __cil_tmp78 = ! __cil_tmp77;
#line 1320
  __cil_tmp79 = (long )__cil_tmp78;
#line 1320
  tmp___15 = ldv__builtin_expect(__cil_tmp79, 0L);
  }
#line 1320
  if (tmp___15) {
#line 1321
    return (ret);
  } else {

  }
  {
#line 1323
  tmp___16 = vmw_mem_glob(dev_priv);
#line 1323
  __cil_tmp80 = (uint64_t )size;
#line 1323
  __cil_tmp81 = (bool )0;
#line 1323
  __cil_tmp82 = (bool )1;
#line 1323
  ret = ttm_mem_global_alloc(tmp___16, __cil_tmp80, __cil_tmp81, __cil_tmp82);
#line 1325
  __cil_tmp83 = ret != 0;
#line 1325
  __cil_tmp84 = ! __cil_tmp83;
#line 1325
  __cil_tmp85 = ! __cil_tmp84;
#line 1325
  __cil_tmp86 = (long )__cil_tmp85;
#line 1325
  tmp___17 = ldv__builtin_expect(__cil_tmp86, 0L);
  }
#line 1325
  if (tmp___17) {
#line 1326
    if (ret != -512) {
      {
#line 1327
      drm_err("vmw_surface_define_ioctl", "Out of graphics memory for surface creation.\n");
      }
    } else {

    }
#line 1329
    goto out_unlock;
  } else {

  }
  {
#line 1332
  tmp___18 = kmalloc(280UL, 208U);
#line 1332
  user_srf = (struct vmw_user_surface *)tmp___18;
#line 1333
  __cil_tmp87 = (void *)0;
#line 1333
  __cil_tmp88 = (unsigned long )__cil_tmp87;
#line 1333
  __cil_tmp89 = (unsigned long )user_srf;
#line 1333
  __cil_tmp90 = __cil_tmp89 == __cil_tmp88;
#line 1333
  __cil_tmp91 = ! __cil_tmp90;
#line 1333
  __cil_tmp92 = ! __cil_tmp91;
#line 1333
  __cil_tmp93 = (long )__cil_tmp92;
#line 1333
  tmp___19 = ldv__builtin_expect(__cil_tmp93, 0L);
  }
#line 1333
  if (tmp___19) {
#line 1334
    ret = -12;
#line 1335
    goto out_no_user_srf;
  } else {

  }
#line 1338
  __cil_tmp94 = (unsigned long )user_srf;
#line 1338
  __cil_tmp95 = __cil_tmp94 + 64;
#line 1338
  srf = (struct vmw_surface *)__cil_tmp95;
#line 1339
  __cil_tmp96 = & res;
#line 1339
  *__cil_tmp96 = (struct vmw_resource *)srf;
#line 1341
  __cil_tmp97 = (unsigned long )srf;
#line 1341
  __cil_tmp98 = __cil_tmp97 + 112;
#line 1341
  *((uint32_t *)__cil_tmp98) = *((uint32_t *)req);
#line 1342
  __cil_tmp99 = (unsigned long )srf;
#line 1342
  __cil_tmp100 = __cil_tmp99 + 116;
#line 1342
  __cil_tmp101 = (unsigned long )req;
#line 1342
  __cil_tmp102 = __cil_tmp101 + 4;
#line 1342
  *((uint32_t *)__cil_tmp100) = *((uint32_t *)__cil_tmp102);
#line 1343
  __cil_tmp103 = (unsigned long )srf;
#line 1343
  __cil_tmp104 = __cil_tmp103 + 156;
#line 1343
  __cil_tmp105 = (unsigned long )req;
#line 1343
  __cil_tmp106 = __cil_tmp105 + 44;
#line 1343
  __cil_tmp107 = *((int32_t *)__cil_tmp106);
#line 1343
  *((bool *)__cil_tmp104) = (bool )__cil_tmp107;
#line 1344
  __cil_tmp108 = (unsigned long )srf;
#line 1344
  __cil_tmp109 = __cil_tmp108 + 184;
#line 1344
  __cil_tmp110 = (void *)0;
#line 1344
  *((struct ttm_buffer_object **)__cil_tmp109) = (struct ttm_buffer_object *)__cil_tmp110;
#line 1346
  __len = 24UL;
#line 1346
  if (__len >= 64UL) {
    {
#line 1346
    __cil_tmp111 = 0 * 4UL;
#line 1346
    __cil_tmp112 = 120 + __cil_tmp111;
#line 1346
    __cil_tmp113 = (unsigned long )srf;
#line 1346
    __cil_tmp114 = __cil_tmp113 + __cil_tmp112;
#line 1346
    __cil_tmp115 = (uint32_t *)__cil_tmp114;
#line 1346
    __cil_tmp116 = (void *)__cil_tmp115;
#line 1346
    __cil_tmp117 = 0 * 4UL;
#line 1346
    __cil_tmp118 = 8 + __cil_tmp117;
#line 1346
    __cil_tmp119 = (unsigned long )req;
#line 1346
    __cil_tmp120 = __cil_tmp119 + __cil_tmp118;
#line 1346
    __cil_tmp121 = (uint32_t *)__cil_tmp120;
#line 1346
    __cil_tmp122 = (void    *)__cil_tmp121;
#line 1346
    __ret = __memcpy(__cil_tmp116, __cil_tmp122, __len);
    }
  } else {
    {
#line 1346
    __cil_tmp123 = 0 * 4UL;
#line 1346
    __cil_tmp124 = 120 + __cil_tmp123;
#line 1346
    __cil_tmp125 = (unsigned long )srf;
#line 1346
    __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 1346
    __cil_tmp127 = (uint32_t *)__cil_tmp126;
#line 1346
    __cil_tmp128 = (void *)__cil_tmp127;
#line 1346
    __cil_tmp129 = 0 * 4UL;
#line 1346
    __cil_tmp130 = 8 + __cil_tmp129;
#line 1346
    __cil_tmp131 = (unsigned long )req;
#line 1346
    __cil_tmp132 = __cil_tmp131 + __cil_tmp130;
#line 1346
    __cil_tmp133 = (uint32_t *)__cil_tmp132;
#line 1346
    __cil_tmp134 = (void    *)__cil_tmp133;
#line 1346
    __ret = __builtin_memcpy(__cil_tmp128, __cil_tmp134, __len);
    }
  }
  {
#line 1347
  __cil_tmp135 = (unsigned long )srf;
#line 1347
  __cil_tmp136 = __cil_tmp135 + 152;
#line 1347
  *((uint32_t *)__cil_tmp136) = num_sizes;
#line 1348
  __cil_tmp137 = (unsigned long )user_srf;
#line 1348
  __cil_tmp138 = __cil_tmp137 + 272;
#line 1348
  *((uint32_t *)__cil_tmp138) = size;
#line 1350
  __cil_tmp139 = (unsigned long )srf;
#line 1350
  __cil_tmp140 = __cil_tmp139 + 152;
#line 1350
  __cil_tmp141 = *((uint32_t *)__cil_tmp140);
#line 1350
  __cil_tmp142 = (unsigned long )__cil_tmp141;
#line 1350
  __cil_tmp143 = __cil_tmp142 * 16UL;
#line 1350
  tmp___20 = kmalloc(__cil_tmp143, 208U);
#line 1350
  __cil_tmp144 = (unsigned long )srf;
#line 1350
  __cil_tmp145 = __cil_tmp144 + 144;
#line 1350
  *((struct drm_vmw_size **)__cil_tmp145) = (struct drm_vmw_size *)tmp___20;
#line 1351
  __cil_tmp146 = (void *)0;
#line 1351
  __cil_tmp147 = (unsigned long )__cil_tmp146;
#line 1351
  __cil_tmp148 = (unsigned long )srf;
#line 1351
  __cil_tmp149 = __cil_tmp148 + 144;
#line 1351
  __cil_tmp150 = *((struct drm_vmw_size **)__cil_tmp149);
#line 1351
  __cil_tmp151 = (unsigned long )__cil_tmp150;
#line 1351
  __cil_tmp152 = __cil_tmp151 == __cil_tmp147;
#line 1351
  __cil_tmp153 = ! __cil_tmp152;
#line 1351
  __cil_tmp154 = ! __cil_tmp153;
#line 1351
  __cil_tmp155 = (long )__cil_tmp154;
#line 1351
  tmp___21 = ldv__builtin_expect(__cil_tmp155, 0L);
  }
#line 1351
  if (tmp___21) {
#line 1352
    ret = -12;
#line 1353
    goto out_no_sizes;
  } else {

  }
  {
#line 1355
  __cil_tmp156 = (unsigned long )srf;
#line 1355
  __cil_tmp157 = __cil_tmp156 + 152;
#line 1355
  __cil_tmp158 = *((uint32_t *)__cil_tmp157);
#line 1355
  __cil_tmp159 = (unsigned long )__cil_tmp158;
#line 1355
  __cil_tmp160 = __cil_tmp159 * 12UL;
#line 1355
  tmp___22 = kmalloc(__cil_tmp160, 208U);
#line 1355
  __cil_tmp161 = (unsigned long )srf;
#line 1355
  __cil_tmp162 = __cil_tmp161 + 192;
#line 1355
  *((struct vmw_surface_offset **)__cil_tmp162) = (struct vmw_surface_offset *)tmp___22;
#line 1357
  __cil_tmp163 = (void *)0;
#line 1357
  __cil_tmp164 = (unsigned long )__cil_tmp163;
#line 1357
  __cil_tmp165 = (unsigned long )srf;
#line 1357
  __cil_tmp166 = __cil_tmp165 + 144;
#line 1357
  __cil_tmp167 = *((struct drm_vmw_size **)__cil_tmp166);
#line 1357
  __cil_tmp168 = (unsigned long )__cil_tmp167;
#line 1357
  __cil_tmp169 = __cil_tmp168 == __cil_tmp164;
#line 1357
  __cil_tmp170 = ! __cil_tmp169;
#line 1357
  __cil_tmp171 = ! __cil_tmp170;
#line 1357
  __cil_tmp172 = (long )__cil_tmp171;
#line 1357
  tmp___23 = ldv__builtin_expect(__cil_tmp172, 0L);
  }
#line 1357
  if (tmp___23) {
#line 1358
    ret = -12;
#line 1359
    goto out_no_offsets;
  } else {

  }
  {
#line 1362
  __cil_tmp173 = (unsigned long )req;
#line 1362
  __cil_tmp174 = __cil_tmp173 + 32;
#line 1362
  __cil_tmp175 = *((uint64_t *)__cil_tmp174);
#line 1362
  __cil_tmp176 = (unsigned long )__cil_tmp175;
#line 1362
  user_sizes = (struct drm_vmw_size *)__cil_tmp176;
#line 1365
  __cil_tmp177 = (unsigned long )srf;
#line 1365
  __cil_tmp178 = __cil_tmp177 + 144;
#line 1365
  __cil_tmp179 = *((struct drm_vmw_size **)__cil_tmp178);
#line 1365
  __cil_tmp180 = (void *)__cil_tmp179;
#line 1365
  __cil_tmp181 = (void    *)user_sizes;
#line 1365
  __cil_tmp182 = (unsigned long )srf;
#line 1365
  __cil_tmp183 = __cil_tmp182 + 152;
#line 1365
  __cil_tmp184 = *((uint32_t *)__cil_tmp183);
#line 1365
  __cil_tmp185 = (unsigned long )__cil_tmp184;
#line 1365
  __cil_tmp186 = __cil_tmp185 * 16UL;
#line 1365
  tmp___24 = (unsigned long )copy_from_user(__cil_tmp180, __cil_tmp181, __cil_tmp186);
#line 1365
  ret = (int )tmp___24;
#line 1367
  __cil_tmp187 = ret != 0;
#line 1367
  __cil_tmp188 = ! __cil_tmp187;
#line 1367
  __cil_tmp189 = ! __cil_tmp188;
#line 1367
  __cil_tmp190 = (long )__cil_tmp189;
#line 1367
  tmp___25 = ldv__builtin_expect(__cil_tmp190, 0L);
  }
#line 1367
  if (tmp___25) {
#line 1368
    ret = -14;
#line 1369
    goto out_no_copy;
  } else {

  }
#line 1372
  cur_bo_offset = (uint32_t )0;
#line 1373
  __cil_tmp191 = (unsigned long )srf;
#line 1373
  __cil_tmp192 = __cil_tmp191 + 192;
#line 1373
  cur_offset = *((struct vmw_surface_offset **)__cil_tmp192);
#line 1374
  __cil_tmp193 = (unsigned long )srf;
#line 1374
  __cil_tmp194 = __cil_tmp193 + 144;
#line 1374
  cur_size = *((struct drm_vmw_size **)__cil_tmp194);
#line 1376
  __cil_tmp195 = (unsigned long )srf;
#line 1376
  __cil_tmp196 = __cil_tmp195 + 116;
#line 1376
  __cil_tmp197 = *((uint32_t *)__cil_tmp196);
#line 1376
  __cil_tmp198 = __cil_tmp197 * 2UL;
#line 1376
  __cil_tmp199 = (unsigned long )(vmw_sf_bpp) + __cil_tmp198;
#line 1376
  __cil_tmp200 = *((uint8_t    *)__cil_tmp199);
#line 1376
  bpp = (uint32_t )__cil_tmp200;
#line 1377
  __cil_tmp201 = (unsigned long )srf;
#line 1377
  __cil_tmp202 = __cil_tmp201 + 116;
#line 1377
  __cil_tmp203 = *((uint32_t *)__cil_tmp202);
#line 1377
  __cil_tmp204 = __cil_tmp203 * 2UL;
#line 1377
  __cil_tmp205 = __cil_tmp204 + 1;
#line 1377
  __cil_tmp206 = (unsigned long )(vmw_sf_bpp) + __cil_tmp205;
#line 1377
  __cil_tmp207 = *((uint8_t    *)__cil_tmp206);
#line 1377
  stride_bpp = (uint32_t )__cil_tmp207;
#line 1379
  i = 0;
  {
#line 1379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1379
    if (i < 6) {

    } else {
#line 1379
      goto while_break___0;
    }
#line 1380
    j = 0;
    {
#line 1380
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1380
      __cil_tmp208 = i * 4UL;
#line 1380
      __cil_tmp209 = 120 + __cil_tmp208;
#line 1380
      __cil_tmp210 = (unsigned long )srf;
#line 1380
      __cil_tmp211 = __cil_tmp210 + __cil_tmp209;
#line 1380
      __cil_tmp212 = *((uint32_t *)__cil_tmp211);
#line 1380
      __cil_tmp213 = (uint32_t )j;
#line 1380
      if (__cil_tmp213 < __cil_tmp212) {

      } else {
#line 1380
        goto while_break___1;
      }
      }
#line 1381
      __cil_tmp214 = *((uint32_t *)cur_size);
#line 1381
      __cil_tmp215 = __cil_tmp214 * stride_bpp;
#line 1381
      __cil_tmp216 = __cil_tmp215 + 7U;
#line 1381
      stride = __cil_tmp216 >> 3;
#line 1384
      *((uint32_t *)cur_offset) = (uint32_t )i;
#line 1385
      __cil_tmp217 = (unsigned long )cur_offset;
#line 1385
      __cil_tmp218 = __cil_tmp217 + 4;
#line 1385
      *((uint32_t *)__cil_tmp218) = (uint32_t )j;
#line 1386
      __cil_tmp219 = (unsigned long )cur_offset;
#line 1386
      __cil_tmp220 = __cil_tmp219 + 8;
#line 1386
      *((uint32_t *)__cil_tmp220) = cur_bo_offset;
#line 1387
      __cil_tmp221 = (unsigned long )cur_size;
#line 1387
      __cil_tmp222 = __cil_tmp221 + 8;
#line 1387
      __cil_tmp223 = *((uint32_t *)__cil_tmp222);
#line 1387
      __cil_tmp224 = (unsigned long )cur_size;
#line 1387
      __cil_tmp225 = __cil_tmp224 + 4;
#line 1387
      __cil_tmp226 = *((uint32_t *)__cil_tmp225);
#line 1387
      __cil_tmp227 = stride * __cil_tmp226;
#line 1387
      __cil_tmp228 = __cil_tmp227 * __cil_tmp223;
#line 1387
      __cil_tmp229 = __cil_tmp228 * bpp;
#line 1387
      __cil_tmp230 = __cil_tmp229 / stride_bpp;
#line 1387
      cur_bo_offset = cur_bo_offset + __cil_tmp230;
#line 1389
      cur_offset = cur_offset + 1;
#line 1390
      cur_size = cur_size + 1;
#line 1380
      j = j + 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1379
    i = i + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1393
  __cil_tmp231 = (unsigned long )srf;
#line 1393
  __cil_tmp232 = __cil_tmp231 + 200;
#line 1393
  *((uint32_t *)__cil_tmp232) = cur_bo_offset;
  {
#line 1395
  __cil_tmp233 = (unsigned long )srf;
#line 1395
  __cil_tmp234 = __cil_tmp233 + 156;
#line 1395
  if (*((bool *)__cil_tmp234)) {
    {
#line 1395
    __cil_tmp235 = (unsigned long )srf;
#line 1395
    __cil_tmp236 = __cil_tmp235 + 152;
#line 1395
    __cil_tmp237 = *((uint32_t *)__cil_tmp236);
#line 1395
    if (__cil_tmp237 == 1U) {
      {
#line 1395
      __cil_tmp238 = (unsigned long )srf;
#line 1395
      __cil_tmp239 = __cil_tmp238 + 144;
#line 1395
      __cil_tmp240 = *((struct drm_vmw_size **)__cil_tmp239);
#line 1395
      __cil_tmp241 = __cil_tmp240 + 0;
#line 1395
      __cil_tmp242 = *((uint32_t *)__cil_tmp241);
#line 1395
      if (__cil_tmp242 == 64U) {
        {
#line 1395
        __cil_tmp243 = (unsigned long )srf;
#line 1395
        __cil_tmp244 = __cil_tmp243 + 144;
#line 1395
        __cil_tmp245 = *((struct drm_vmw_size **)__cil_tmp244);
#line 1395
        __cil_tmp246 = __cil_tmp245 + 0;
#line 1395
        __cil_tmp247 = (unsigned long )__cil_tmp246;
#line 1395
        __cil_tmp248 = __cil_tmp247 + 4;
#line 1395
        __cil_tmp249 = *((uint32_t *)__cil_tmp248);
#line 1395
        if (__cil_tmp249 == 64U) {
          {
#line 1395
          __cil_tmp250 = (unsigned long )srf;
#line 1395
          __cil_tmp251 = __cil_tmp250 + 116;
#line 1395
          __cil_tmp252 = *((uint32_t *)__cil_tmp251);
#line 1395
          if (__cil_tmp252 == 2U) {
            {
#line 1402
            __cil_tmp253 = (size_t )16384;
#line 1402
            tmp___26 = kzalloc(__cil_tmp253, 208U);
#line 1402
            __cil_tmp254 = 160 + 16;
#line 1402
            __cil_tmp255 = (unsigned long )srf;
#line 1402
            __cil_tmp256 = __cil_tmp255 + __cil_tmp254;
#line 1402
            *((uint32_t **)__cil_tmp256) = (uint32_t *)tmp___26;
            }
            {
#line 1403
            __cil_tmp257 = 160 + 16;
#line 1403
            __cil_tmp258 = (unsigned long )srf;
#line 1403
            __cil_tmp259 = __cil_tmp258 + __cil_tmp257;
#line 1403
            __cil_tmp260 = *((uint32_t **)__cil_tmp259);
#line 1403
            if (! __cil_tmp260) {
              {
#line 1404
              drm_err("vmw_surface_define_ioctl", "Failed to allocate cursor_image\n");
#line 1405
              ret = -12;
              }
#line 1406
              goto out_no_copy;
            } else {

            }
            }
          } else {
#line 1409
            __cil_tmp261 = 160 + 16;
#line 1409
            __cil_tmp262 = (unsigned long )srf;
#line 1409
            __cil_tmp263 = __cil_tmp262 + __cil_tmp261;
#line 1409
            __cil_tmp264 = (void *)0;
#line 1409
            *((uint32_t **)__cil_tmp263) = (uint32_t *)__cil_tmp264;
          }
          }
        } else {
#line 1409
          __cil_tmp265 = 160 + 16;
#line 1409
          __cil_tmp266 = (unsigned long )srf;
#line 1409
          __cil_tmp267 = __cil_tmp266 + __cil_tmp265;
#line 1409
          __cil_tmp268 = (void *)0;
#line 1409
          *((uint32_t **)__cil_tmp267) = (uint32_t *)__cil_tmp268;
        }
        }
      } else {
#line 1409
        __cil_tmp269 = 160 + 16;
#line 1409
        __cil_tmp270 = (unsigned long )srf;
#line 1409
        __cil_tmp271 = __cil_tmp270 + __cil_tmp269;
#line 1409
        __cil_tmp272 = (void *)0;
#line 1409
        *((uint32_t **)__cil_tmp271) = (uint32_t *)__cil_tmp272;
      }
      }
    } else {
#line 1409
      __cil_tmp273 = 160 + 16;
#line 1409
      __cil_tmp274 = (unsigned long )srf;
#line 1409
      __cil_tmp275 = __cil_tmp274 + __cil_tmp273;
#line 1409
      __cil_tmp276 = (void *)0;
#line 1409
      *((uint32_t **)__cil_tmp275) = (uint32_t *)__cil_tmp276;
    }
    }
  } else {
#line 1409
    __cil_tmp277 = 160 + 16;
#line 1409
    __cil_tmp278 = (unsigned long )srf;
#line 1409
    __cil_tmp279 = __cil_tmp278 + __cil_tmp277;
#line 1409
    __cil_tmp280 = (void *)0;
#line 1409
    *((uint32_t **)__cil_tmp279) = (uint32_t *)__cil_tmp280;
  }
  }
  {
#line 1411
  __cil_tmp281 = (unsigned long )srf;
#line 1411
  __cil_tmp282 = __cil_tmp281 + 160;
#line 1411
  __cil_tmp283 = (void *)0;
#line 1411
  *((struct drm_crtc **)__cil_tmp282) = (struct drm_crtc *)__cil_tmp283;
#line 1413
  __cil_tmp284 = 0 + 28;
#line 1413
  __cil_tmp285 = (unsigned long )user_srf;
#line 1413
  __cil_tmp286 = __cil_tmp285 + __cil_tmp284;
#line 1413
  *((bool *)__cil_tmp286) = (bool )0;
#line 1414
  __cil_tmp287 = 0 + 32;
#line 1414
  __cil_tmp288 = (unsigned long )user_srf;
#line 1414
  __cil_tmp289 = __cil_tmp288 + __cil_tmp287;
#line 1414
  __cil_tmp290 = (void *)0;
#line 1414
  *((struct ttm_object_file **)__cil_tmp289) = (struct ttm_object_file *)__cil_tmp290;
#line 1421
  ret = vmw_surface_init(dev_priv, srf, & vmw_user_surface_free);
#line 1422
  __cil_tmp291 = ret != 0;
#line 1422
  __cil_tmp292 = ! __cil_tmp291;
#line 1422
  __cil_tmp293 = ! __cil_tmp292;
#line 1422
  __cil_tmp294 = (long )__cil_tmp293;
#line 1422
  tmp___27 = ldv__builtin_expect(__cil_tmp294, 0L);
  }
#line 1422
  if (tmp___27) {
#line 1423
    goto out_unlock;
  } else {

  }
  {
#line 1425
  __cil_tmp295 = & tmp___8;
#line 1425
  __cil_tmp296 = (struct vmw_resource *)srf;
#line 1425
  *__cil_tmp295 = vmw_resource_reference(__cil_tmp296);
#line 1426
  __cil_tmp297 = (struct ttm_base_object *)user_srf;
#line 1426
  __cil_tmp298 = (unsigned long )req;
#line 1426
  __cil_tmp299 = __cil_tmp298 + 40;
#line 1426
  __cil_tmp300 = *((int32_t *)__cil_tmp299);
#line 1426
  __cil_tmp301 = (bool )__cil_tmp300;
#line 1426
  __cil_tmp302 = (enum ttm_object_type )257;
#line 1426
  __cil_tmp303 = (void *)0;
#line 1426
  __cil_tmp304 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp303;
#line 1426
  ret = ttm_base_object_init(tfile, __cil_tmp297, __cil_tmp301, __cil_tmp302, & vmw_user_surface_base_release,
                             __cil_tmp304);
#line 1430
  __cil_tmp305 = ret != 0;
#line 1430
  __cil_tmp306 = ! __cil_tmp305;
#line 1430
  __cil_tmp307 = ! __cil_tmp306;
#line 1430
  __cil_tmp308 = (long )__cil_tmp307;
#line 1430
  tmp___28 = ldv__builtin_expect(__cil_tmp308, 0L);
  }
#line 1430
  if (tmp___28) {
    {
#line 1431
    vmw_resource_unreference(& tmp___8);
#line 1432
    vmw_resource_unreference(& res);
    }
#line 1433
    goto out_unlock;
  } else {

  }
#line 1436
  __cil_tmp309 = 0 + 16;
#line 1436
  __cil_tmp310 = 0 + __cil_tmp309;
#line 1436
  __cil_tmp311 = (unsigned long )user_srf;
#line 1436
  __cil_tmp312 = __cil_tmp311 + __cil_tmp310;
#line 1436
  __cil_tmp313 = *((unsigned long *)__cil_tmp312);
#line 1436
  *((int32_t *)rep) = (int32_t )__cil_tmp313;
  {
#line 1437
  __cil_tmp314 = *((int32_t *)rep);
#line 1437
  __cil_tmp315 = (uint32 )__cil_tmp314;
#line 1437
  if (__cil_tmp315 == 4294967295U) {
    {
#line 1438
    drm_err("vmw_surface_define_ioctl", "Created bad Surface ID.\n");
    }
  } else {

  }
  }
  {
#line 1440
  vmw_resource_unreference(& res);
#line 1442
  __cil_tmp316 = (struct ttm_lock *)vmaster;
#line 1442
  ttm_read_unlock(__cil_tmp316);
  }
#line 1443
  return (0);
  out_no_copy: 
  {
#line 1445
  __cil_tmp317 = (unsigned long )srf;
#line 1445
  __cil_tmp318 = __cil_tmp317 + 192;
#line 1445
  __cil_tmp319 = *((struct vmw_surface_offset **)__cil_tmp318);
#line 1445
  __cil_tmp320 = (void    *)__cil_tmp319;
#line 1445
  kfree(__cil_tmp320);
  }
  out_no_offsets: 
  {
#line 1447
  __cil_tmp321 = (unsigned long )srf;
#line 1447
  __cil_tmp322 = __cil_tmp321 + 144;
#line 1447
  __cil_tmp323 = *((struct drm_vmw_size **)__cil_tmp322);
#line 1447
  __cil_tmp324 = (void    *)__cil_tmp323;
#line 1447
  kfree(__cil_tmp324);
  }
  out_no_sizes: 
  {
#line 1449
  __cil_tmp325 = (void    *)user_srf;
#line 1449
  kfree(__cil_tmp325);
  }
  out_no_user_srf: 
  {
#line 1451
  tmp___29 = vmw_mem_glob(dev_priv);
#line 1451
  __cil_tmp326 = (uint64_t )size;
#line 1451
  ttm_mem_global_free(tmp___29, __cil_tmp326);
  }
  out_unlock: 
  {
#line 1453
  __cil_tmp327 = (struct ttm_lock *)vmaster;
#line 1453
  ttm_read_unlock(__cil_tmp327);
  }
#line 1454
  return (ret);
}
}
#line 1457 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ union drm_vmw_surface_reference_arg *arg ;
  struct drm_vmw_surface_arg *req ;
  struct drm_vmw_surface_create_req *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct drm_vmw_size *user_sizes ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___8 ;
  long tmp___9 ;
  struct ttm_base_object    *__mptr ;
  long tmp___10 ;
  size_t __len ;
  void *__ret ;
  long tmp___11 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_base_object **__cil_tmp23 ;
  int32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct ttm_base_object **__cil_tmp28 ;
  struct ttm_base_object *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  struct ttm_base_object **__cil_tmp35 ;
  struct ttm_base_object *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  enum ttm_object_type __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  struct ttm_base_object **__cil_tmp45 ;
  struct ttm_base_object *__cil_tmp46 ;
  struct vmw_user_surface *__cil_tmp47 ;
  struct ttm_base_object *__cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  enum ttm_ref_type __cil_tmp55 ;
  void *__cil_tmp56 ;
  bool *__cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t *__cil_tmp72 ;
  void *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  uint32_t *__cil_tmp78 ;
  void    *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t *__cil_tmp84 ;
  void *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  uint32_t *__cil_tmp90 ;
  void    *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  uint64_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  void *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct drm_vmw_size *__cil_tmp99 ;
  void    *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  uint32_t __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  uint32_t __cil_tmp113 ;

  {
  {
#line 1460
  arg = (union drm_vmw_surface_reference_arg *)data;
#line 1462
  req = (struct drm_vmw_surface_arg *)arg;
#line 1463
  rep = (struct drm_vmw_surface_create_req *)arg;
#line 1464
  tmp___7 = vmw_fpriv(file_priv);
#line 1464
  __cil_tmp21 = (unsigned long )tmp___7;
#line 1464
  __cil_tmp22 = __cil_tmp21 + 8;
#line 1464
  tfile = *((struct ttm_object_file **)__cil_tmp22);
#line 1469
  ret = -22;
#line 1471
  __cil_tmp23 = & base;
#line 1471
  __cil_tmp24 = *((int32_t *)req);
#line 1471
  __cil_tmp25 = (uint32_t )__cil_tmp24;
#line 1471
  *__cil_tmp23 = ttm_base_object_lookup(tfile, __cil_tmp25);
#line 1472
  __cil_tmp26 = (void *)0;
#line 1472
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 1472
  __cil_tmp28 = & base;
#line 1472
  __cil_tmp29 = *__cil_tmp28;
#line 1472
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 1472
  __cil_tmp31 = __cil_tmp30 == __cil_tmp27;
#line 1472
  __cil_tmp32 = ! __cil_tmp31;
#line 1472
  __cil_tmp33 = ! __cil_tmp32;
#line 1472
  __cil_tmp34 = (long )__cil_tmp33;
#line 1472
  tmp___8 = ldv__builtin_expect(__cil_tmp34, 0L);
  }
#line 1472
  if (tmp___8) {
    {
#line 1473
    drm_err("vmw_surface_reference_ioctl", "Could not find surface to reference.\n");
    }
#line 1474
    return (-22);
  } else {

  }
  {
#line 1477
  __cil_tmp35 = & base;
#line 1477
  __cil_tmp36 = *__cil_tmp35;
#line 1477
  __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 1477
  __cil_tmp38 = __cil_tmp37 + 24;
#line 1477
  __cil_tmp39 = *((enum ttm_object_type *)__cil_tmp38);
#line 1477
  __cil_tmp40 = (unsigned int )__cil_tmp39;
#line 1477
  __cil_tmp41 = __cil_tmp40 != 257U;
#line 1477
  __cil_tmp42 = ! __cil_tmp41;
#line 1477
  __cil_tmp43 = ! __cil_tmp42;
#line 1477
  __cil_tmp44 = (long )__cil_tmp43;
#line 1477
  tmp___9 = ldv__builtin_expect(__cil_tmp44, 0L);
  }
#line 1477
  if (tmp___9) {
#line 1478
    goto out_bad_resource;
  } else {

  }
  {
#line 1480
  __cil_tmp45 = & base;
#line 1480
  __cil_tmp46 = *__cil_tmp45;
#line 1480
  __mptr = (struct ttm_base_object    *)__cil_tmp46;
#line 1480
  __cil_tmp47 = (struct vmw_user_surface *)0;
#line 1480
  __cil_tmp48 = (struct ttm_base_object *)__cil_tmp47;
#line 1480
  __cil_tmp49 = (unsigned int )__cil_tmp48;
#line 1480
  __cil_tmp50 = (char *)__mptr;
#line 1480
  __cil_tmp51 = __cil_tmp50 - __cil_tmp49;
#line 1480
  user_srf = (struct vmw_user_surface *)__cil_tmp51;
#line 1481
  __cil_tmp52 = (unsigned long )user_srf;
#line 1481
  __cil_tmp53 = __cil_tmp52 + 64;
#line 1481
  srf = (struct vmw_surface *)__cil_tmp53;
#line 1483
  __cil_tmp54 = (struct ttm_base_object *)user_srf;
#line 1483
  __cil_tmp55 = (enum ttm_ref_type )0;
#line 1483
  __cil_tmp56 = (void *)0;
#line 1483
  __cil_tmp57 = (bool *)__cil_tmp56;
#line 1483
  ret = ttm_ref_object_add(tfile, __cil_tmp54, __cil_tmp55, __cil_tmp57);
#line 1484
  __cil_tmp58 = ret != 0;
#line 1484
  __cil_tmp59 = ! __cil_tmp58;
#line 1484
  __cil_tmp60 = ! __cil_tmp59;
#line 1484
  __cil_tmp61 = (long )__cil_tmp60;
#line 1484
  tmp___10 = ldv__builtin_expect(__cil_tmp61, 0L);
  }
#line 1484
  if (tmp___10) {
    {
#line 1485
    drm_err("vmw_surface_reference_ioctl", "Could not add a reference to a surface.\n");
    }
#line 1486
    goto out_bad_resource;
  } else {

  }
#line 1489
  __cil_tmp62 = (unsigned long )srf;
#line 1489
  __cil_tmp63 = __cil_tmp62 + 112;
#line 1489
  *((uint32_t *)rep) = *((uint32_t *)__cil_tmp63);
#line 1490
  __cil_tmp64 = (unsigned long )rep;
#line 1490
  __cil_tmp65 = __cil_tmp64 + 4;
#line 1490
  __cil_tmp66 = (unsigned long )srf;
#line 1490
  __cil_tmp67 = __cil_tmp66 + 116;
#line 1490
  *((uint32_t *)__cil_tmp65) = *((uint32_t *)__cil_tmp67);
#line 1491
  __len = 24UL;
#line 1491
  if (__len >= 64UL) {
    {
#line 1491
    __cil_tmp68 = 0 * 4UL;
#line 1491
    __cil_tmp69 = 8 + __cil_tmp68;
#line 1491
    __cil_tmp70 = (unsigned long )rep;
#line 1491
    __cil_tmp71 = __cil_tmp70 + __cil_tmp69;
#line 1491
    __cil_tmp72 = (uint32_t *)__cil_tmp71;
#line 1491
    __cil_tmp73 = (void *)__cil_tmp72;
#line 1491
    __cil_tmp74 = 0 * 4UL;
#line 1491
    __cil_tmp75 = 120 + __cil_tmp74;
#line 1491
    __cil_tmp76 = (unsigned long )srf;
#line 1491
    __cil_tmp77 = __cil_tmp76 + __cil_tmp75;
#line 1491
    __cil_tmp78 = (uint32_t *)__cil_tmp77;
#line 1491
    __cil_tmp79 = (void    *)__cil_tmp78;
#line 1491
    __ret = __memcpy(__cil_tmp73, __cil_tmp79, __len);
    }
  } else {
    {
#line 1491
    __cil_tmp80 = 0 * 4UL;
#line 1491
    __cil_tmp81 = 8 + __cil_tmp80;
#line 1491
    __cil_tmp82 = (unsigned long )rep;
#line 1491
    __cil_tmp83 = __cil_tmp82 + __cil_tmp81;
#line 1491
    __cil_tmp84 = (uint32_t *)__cil_tmp83;
#line 1491
    __cil_tmp85 = (void *)__cil_tmp84;
#line 1491
    __cil_tmp86 = 0 * 4UL;
#line 1491
    __cil_tmp87 = 120 + __cil_tmp86;
#line 1491
    __cil_tmp88 = (unsigned long )srf;
#line 1491
    __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
#line 1491
    __cil_tmp90 = (uint32_t *)__cil_tmp89;
#line 1491
    __cil_tmp91 = (void    *)__cil_tmp90;
#line 1491
    __ret = __builtin_memcpy(__cil_tmp85, __cil_tmp91, __len);
    }
  }
#line 1492
  __cil_tmp92 = (unsigned long )rep;
#line 1492
  __cil_tmp93 = __cil_tmp92 + 32;
#line 1492
  __cil_tmp94 = *((uint64_t *)__cil_tmp93);
#line 1492
  __cil_tmp95 = (unsigned long )__cil_tmp94;
#line 1492
  user_sizes = (struct drm_vmw_size *)__cil_tmp95;
#line 1495
  if (user_sizes) {
    {
#line 1496
    __cil_tmp96 = (void *)user_sizes;
#line 1496
    __cil_tmp97 = (unsigned long )srf;
#line 1496
    __cil_tmp98 = __cil_tmp97 + 144;
#line 1496
    __cil_tmp99 = *((struct drm_vmw_size **)__cil_tmp98);
#line 1496
    __cil_tmp100 = (void    *)__cil_tmp99;
#line 1496
    __cil_tmp101 = (unsigned long )srf;
#line 1496
    __cil_tmp102 = __cil_tmp101 + 152;
#line 1496
    __cil_tmp103 = *((uint32_t *)__cil_tmp102);
#line 1496
    __cil_tmp104 = (unsigned long )__cil_tmp103;
#line 1496
    __cil_tmp105 = __cil_tmp104 * 16UL;
#line 1496
    __cil_tmp106 = (unsigned int )__cil_tmp105;
#line 1496
    ret = (int )copy_to_user(__cil_tmp96, __cil_tmp100, __cil_tmp106);
    }
  } else {

  }
  {
#line 1498
  __cil_tmp107 = ret != 0;
#line 1498
  __cil_tmp108 = ! __cil_tmp107;
#line 1498
  __cil_tmp109 = ! __cil_tmp108;
#line 1498
  __cil_tmp110 = (long )__cil_tmp109;
#line 1498
  tmp___11 = ldv__builtin_expect(__cil_tmp110, 0L);
  }
#line 1498
  if (tmp___11) {
    {
#line 1499
    __cil_tmp111 = (unsigned long )srf;
#line 1499
    __cil_tmp112 = __cil_tmp111 + 152;
#line 1499
    __cil_tmp113 = *((uint32_t *)__cil_tmp112);
#line 1499
    drm_err("vmw_surface_reference_ioctl", "copy_to_user failed %p %u\n", user_sizes,
            __cil_tmp113);
#line 1501
    ret = -14;
    }
  } else {

  }
  out_bad_resource: 
  {
#line 1505
  ttm_base_object_unref(& base);
  }
#line 1507
  return (ret);
}
}
#line 1510 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) 
{ struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object    *__mptr ;
  struct ttm_base_object **__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct ttm_base_object **__cil_tmp14 ;
  struct ttm_base_object *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  struct ttm_base_object **__cil_tmp21 ;
  struct ttm_base_object *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  enum ttm_object_type __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  struct ttm_base_object **__cil_tmp31 ;
  struct ttm_base_object *__cil_tmp32 ;
  struct vmw_user_surface *__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  {
#line 1517
  ret = -1;
#line 1519
  __cil_tmp11 = & base;
#line 1519
  *__cil_tmp11 = ttm_base_object_lookup(tfile, handle);
#line 1520
  __cil_tmp12 = (void *)0;
#line 1520
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 1520
  __cil_tmp14 = & base;
#line 1520
  __cil_tmp15 = *__cil_tmp14;
#line 1520
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 1520
  __cil_tmp17 = __cil_tmp16 == __cil_tmp13;
#line 1520
  __cil_tmp18 = ! __cil_tmp17;
#line 1520
  __cil_tmp19 = ! __cil_tmp18;
#line 1520
  __cil_tmp20 = (long )__cil_tmp19;
#line 1520
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 1520
  if (tmp___7) {
#line 1521
    return (-22);
  } else {

  }
  {
#line 1523
  __cil_tmp21 = & base;
#line 1523
  __cil_tmp22 = *__cil_tmp21;
#line 1523
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1523
  __cil_tmp24 = __cil_tmp23 + 24;
#line 1523
  __cil_tmp25 = *((enum ttm_object_type *)__cil_tmp24);
#line 1523
  __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 1523
  __cil_tmp27 = __cil_tmp26 != 257U;
#line 1523
  __cil_tmp28 = ! __cil_tmp27;
#line 1523
  __cil_tmp29 = ! __cil_tmp28;
#line 1523
  __cil_tmp30 = (long )__cil_tmp29;
#line 1523
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 0L);
  }
#line 1523
  if (tmp___8) {
#line 1524
    goto out_bad_surface;
  } else {

  }
#line 1526
  __cil_tmp31 = & base;
#line 1526
  __cil_tmp32 = *__cil_tmp31;
#line 1526
  __mptr = (struct ttm_base_object    *)__cil_tmp32;
#line 1526
  __cil_tmp33 = (struct vmw_user_surface *)0;
#line 1526
  __cil_tmp34 = (struct ttm_base_object *)__cil_tmp33;
#line 1526
  __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 1526
  __cil_tmp36 = (char *)__mptr;
#line 1526
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
#line 1526
  user_srf = (struct vmw_user_surface *)__cil_tmp37;
#line 1527
  __cil_tmp38 = 0 + 24;
#line 1527
  __cil_tmp39 = 64 + __cil_tmp38;
#line 1527
  __cil_tmp40 = (unsigned long )user_srf;
#line 1527
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 1527
  *id = *((int *)__cil_tmp41);
#line 1528
  ret = 0;
  out_bad_surface: 
  {
#line 1536
  ttm_base_object_unref(& base);
  }
#line 1537
  return (ret);
}
}
#line 1543 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  void    *__cil_tmp4 ;

  {
  {
#line 1545
  tmp___7 = vmw_dma_buffer(bo);
#line 1545
  vmw_bo = tmp___7;
#line 1547
  __cil_tmp4 = (void    *)vmw_bo;
#line 1547
  kfree(__cil_tmp4);
  }
#line 1548
  return;
}
}
#line 1550 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object *bo ) ) 
{ struct ttm_bo_device *bdev ;
  size_t acc_size ;
  int ret ;
  long tmp___7 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  struct ttm_buffer_object *__cil_tmp20 ;
  enum ttm_bo_type __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  void *__cil_tmp23 ;
  struct file *__cil_tmp24 ;

  {
#line 1556
  bdev = (struct ttm_bo_device *)dev_priv;
  {
#line 1560
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1560
    __cil_tmp11 = ! bo_free;
#line 1560
    __cil_tmp12 = ! __cil_tmp11;
#line 1560
    __cil_tmp13 = ! __cil_tmp12;
#line 1560
    __cil_tmp14 = (long )__cil_tmp13;
#line 1560
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    }
#line 1560
    if (tmp___7) {
      {
#line 1560
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1560
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1560), "i" (12UL));
        {
#line 1560
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1560
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 1560
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1562
  __cil_tmp15 = (unsigned int )416UL;
#line 1562
  acc_size = ttm_bo_acc_size(bdev, size, __cil_tmp15);
#line 1563
  __cil_tmp16 = (void *)vmw_bo;
#line 1563
  memset(__cil_tmp16, 0, 416UL);
#line 1565
  __cil_tmp17 = (unsigned long )vmw_bo;
#line 1565
  __cil_tmp18 = __cil_tmp17 + 384;
#line 1565
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
#line 1565
  INIT_LIST_HEAD(__cil_tmp19);
#line 1567
  __cil_tmp20 = (struct ttm_buffer_object *)vmw_bo;
#line 1567
  __cil_tmp21 = (enum ttm_bo_type )0;
#line 1567
  __cil_tmp22 = (uint32_t )0;
#line 1567
  __cil_tmp23 = (void *)0;
#line 1567
  __cil_tmp24 = (struct file *)__cil_tmp23;
#line 1567
  ret = ttm_bo_init(bdev, __cil_tmp20, size, __cil_tmp21, placement, __cil_tmp22,
                    0UL, interruptible, __cil_tmp24, acc_size, bo_free);
  }
#line 1571
  return (ret);
}
}
#line 1574 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct vmw_user_dma_buffer *tmp___7 ;
  void    *__cil_tmp4 ;

  {
  {
#line 1576
  tmp___7 = vmw_user_dma_buffer(bo);
#line 1576
  vmw_user_bo = tmp___7;
#line 1578
  __cil_tmp4 = (void    *)vmw_user_bo;
#line 1578
  kfree(__cil_tmp4);
  }
#line 1579
  return;
}
}
#line 1581 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_dmabuf_release(struct ttm_base_object **p_base ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  struct ttm_buffer_object *bo ;
  long tmp___7 ;
  struct ttm_base_object    *__mptr ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct vmw_user_dma_buffer *__cil_tmp15 ;
  struct ttm_base_object *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct ttm_buffer_object **__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;

  {
  {
#line 1584
  base = *p_base;
#line 1587
  __cil_tmp7 = (void *)0;
#line 1587
  *p_base = (struct ttm_base_object *)__cil_tmp7;
#line 1589
  __cil_tmp8 = (void *)0;
#line 1589
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 1589
  __cil_tmp10 = (unsigned long )base;
#line 1589
  __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
#line 1589
  __cil_tmp12 = ! __cil_tmp11;
#line 1589
  __cil_tmp13 = ! __cil_tmp12;
#line 1589
  __cil_tmp14 = (long )__cil_tmp13;
#line 1589
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 1589
  if (tmp___7) {
#line 1590
    return;
  } else {

  }
  {
#line 1592
  __mptr = (struct ttm_base_object    *)base;
#line 1592
  __cil_tmp15 = (struct vmw_user_dma_buffer *)0;
#line 1592
  __cil_tmp16 = (struct ttm_base_object *)__cil_tmp15;
#line 1592
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 1592
  __cil_tmp18 = (char *)__mptr;
#line 1592
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 1592
  vmw_user_bo = (struct vmw_user_dma_buffer *)__cil_tmp19;
#line 1593
  __cil_tmp20 = & bo;
#line 1593
  __cil_tmp21 = (unsigned long )vmw_user_bo;
#line 1593
  __cil_tmp22 = __cil_tmp21 + 64;
#line 1593
  *__cil_tmp20 = (struct ttm_buffer_object *)__cil_tmp22;
#line 1594
  ttm_bo_unref(& bo);
  }
#line 1595
  return;
}
}
#line 1597 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  union drm_vmw_alloc_dmabuf_arg *arg ;
  struct drm_vmw_alloc_dmabuf_req *req ;
  struct drm_vmw_dmabuf_rep *rep ;
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_buffer_object *tmp___8 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct vmw_fpriv *tmp___14 ;
  long tmp___15 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_master *__cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct ttm_lock *__cil_tmp30 ;
  bool __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  void    *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_dma_buffer *__cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  size_t __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  struct ttm_buffer_object **__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_buffer_object *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct ttm_object_file *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  bool __cil_tmp55 ;
  enum ttm_object_type __cil_tmp56 ;
  void *__cil_tmp57 ;
  void (*__cil_tmp58)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct ttm_lock *__cil_tmp83 ;

  {
  {
#line 1600
  tmp___7 = vmw_priv(dev);
#line 1600
  dev_priv = tmp___7;
#line 1601
  arg = (union drm_vmw_alloc_dmabuf_arg *)data;
#line 1603
  req = (struct drm_vmw_alloc_dmabuf_req *)arg;
#line 1604
  rep = (struct drm_vmw_dmabuf_rep *)arg;
#line 1607
  __cil_tmp20 = (unsigned long )file_priv;
#line 1607
  __cil_tmp21 = __cil_tmp20 + 152;
#line 1607
  __cil_tmp22 = *((struct drm_master **)__cil_tmp21);
#line 1607
  tmp___9 = vmw_master(__cil_tmp22);
#line 1607
  vmaster = tmp___9;
#line 1610
  tmp___10 = kzalloc(480UL, 208U);
#line 1610
  vmw_user_bo = (struct vmw_user_dma_buffer *)tmp___10;
#line 1611
  __cil_tmp23 = (void *)0;
#line 1611
  __cil_tmp24 = (unsigned long )__cil_tmp23;
#line 1611
  __cil_tmp25 = (unsigned long )vmw_user_bo;
#line 1611
  __cil_tmp26 = __cil_tmp25 == __cil_tmp24;
#line 1611
  __cil_tmp27 = ! __cil_tmp26;
#line 1611
  __cil_tmp28 = ! __cil_tmp27;
#line 1611
  __cil_tmp29 = (long )__cil_tmp28;
#line 1611
  tmp___11 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 1611
  if (tmp___11) {
#line 1612
    return (-12);
  } else {

  }
  {
#line 1614
  __cil_tmp30 = (struct ttm_lock *)vmaster;
#line 1614
  __cil_tmp31 = (bool )1;
#line 1614
  ret = ttm_read_lock(__cil_tmp30, __cil_tmp31);
#line 1615
  __cil_tmp32 = ret != 0;
#line 1615
  __cil_tmp33 = ! __cil_tmp32;
#line 1615
  __cil_tmp34 = ! __cil_tmp33;
#line 1615
  __cil_tmp35 = (long )__cil_tmp34;
#line 1615
  tmp___12 = ldv__builtin_expect(__cil_tmp35, 0L);
  }
#line 1615
  if (tmp___12) {
    {
#line 1616
    __cil_tmp36 = (void    *)vmw_user_bo;
#line 1616
    kfree(__cil_tmp36);
    }
#line 1617
    return (ret);
  } else {

  }
  {
#line 1620
  __cil_tmp37 = (unsigned long )vmw_user_bo;
#line 1620
  __cil_tmp38 = __cil_tmp37 + 64;
#line 1620
  __cil_tmp39 = (struct vmw_dma_buffer *)__cil_tmp38;
#line 1620
  __cil_tmp40 = *((uint32_t *)req);
#line 1620
  __cil_tmp41 = (size_t )__cil_tmp40;
#line 1620
  __cil_tmp42 = (bool )1;
#line 1620
  ret = vmw_dmabuf_init(dev_priv, __cil_tmp39, __cil_tmp41, & vmw_vram_sys_placement,
                        __cil_tmp42, & vmw_user_dmabuf_destroy);
#line 1623
  __cil_tmp43 = ret != 0;
#line 1623
  __cil_tmp44 = ! __cil_tmp43;
#line 1623
  __cil_tmp45 = ! __cil_tmp44;
#line 1623
  __cil_tmp46 = (long )__cil_tmp45;
#line 1623
  tmp___13 = ldv__builtin_expect(__cil_tmp46, 0L);
  }
#line 1623
  if (tmp___13) {
#line 1624
    goto out_no_dmabuf;
  } else {

  }
  {
#line 1626
  __cil_tmp47 = & tmp___8;
#line 1626
  __cil_tmp48 = (unsigned long )vmw_user_bo;
#line 1626
  __cil_tmp49 = __cil_tmp48 + 64;
#line 1626
  __cil_tmp50 = (struct ttm_buffer_object *)__cil_tmp49;
#line 1626
  *__cil_tmp47 = ttm_bo_reference(__cil_tmp50);
#line 1627
  tmp___14 = vmw_fpriv(file_priv);
#line 1627
  __cil_tmp51 = (unsigned long )tmp___14;
#line 1627
  __cil_tmp52 = __cil_tmp51 + 8;
#line 1627
  __cil_tmp53 = *((struct ttm_object_file **)__cil_tmp52);
#line 1627
  __cil_tmp54 = (struct ttm_base_object *)vmw_user_bo;
#line 1627
  __cil_tmp55 = (bool )0;
#line 1627
  __cil_tmp56 = (enum ttm_object_type )1;
#line 1627
  __cil_tmp57 = (void *)0;
#line 1627
  __cil_tmp58 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp57;
#line 1627
  ret = ttm_base_object_init(__cil_tmp53, __cil_tmp54, __cil_tmp55, __cil_tmp56, & vmw_user_dmabuf_release,
                             __cil_tmp58);
#line 1632
  __cil_tmp59 = ret != 0;
#line 1632
  __cil_tmp60 = ! __cil_tmp59;
#line 1632
  __cil_tmp61 = ! __cil_tmp60;
#line 1632
  __cil_tmp62 = (long )__cil_tmp61;
#line 1632
  tmp___15 = ldv__builtin_expect(__cil_tmp62, 0L);
  }
#line 1632
  if (tmp___15) {
#line 1633
    goto out_no_base_object;
  } else {
#line 1635
    __cil_tmp63 = (unsigned long )rep;
#line 1635
    __cil_tmp64 = __cil_tmp63 + 8;
#line 1635
    __cil_tmp65 = 0 + 16;
#line 1635
    __cil_tmp66 = 0 + __cil_tmp65;
#line 1635
    __cil_tmp67 = (unsigned long )vmw_user_bo;
#line 1635
    __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
#line 1635
    __cil_tmp69 = *((unsigned long *)__cil_tmp68);
#line 1635
    *((uint32_t *)__cil_tmp64) = (uint32_t )__cil_tmp69;
#line 1636
    __cil_tmp70 = 0 + 48;
#line 1636
    __cil_tmp71 = 64 + __cil_tmp70;
#line 1636
    __cil_tmp72 = (unsigned long )vmw_user_bo;
#line 1636
    __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
#line 1636
    *((uint64_t *)rep) = *((uint64_t *)__cil_tmp73);
#line 1637
    __cil_tmp74 = (unsigned long )rep;
#line 1637
    __cil_tmp75 = __cil_tmp74 + 12;
#line 1637
    __cil_tmp76 = 0 + 16;
#line 1637
    __cil_tmp77 = 0 + __cil_tmp76;
#line 1637
    __cil_tmp78 = (unsigned long )vmw_user_bo;
#line 1637
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 1637
    __cil_tmp80 = *((unsigned long *)__cil_tmp79);
#line 1637
    *((uint32_t *)__cil_tmp75) = (uint32_t )__cil_tmp80;
#line 1638
    __cil_tmp81 = (unsigned long )rep;
#line 1638
    __cil_tmp82 = __cil_tmp81 + 16;
#line 1638
    *((uint32_t *)__cil_tmp82) = (uint32_t )0;
  }
  out_no_base_object: 
  {
#line 1642
  ttm_bo_unref(& tmp___8);
  }
  out_no_dmabuf: 
  {
#line 1644
  __cil_tmp83 = (struct ttm_lock *)vmaster;
#line 1644
  ttm_read_unlock(__cil_tmp83);
  }
#line 1646
  return (ret);
}
}
#line 1649 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_unref_dmabuf_arg *arg ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct ttm_object_file *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  {
#line 1652
  arg = (struct drm_vmw_unref_dmabuf_arg *)data;
#line 1655
  tmp___7 = vmw_fpriv(file_priv);
#line 1655
  __cil_tmp7 = (unsigned long )tmp___7;
#line 1655
  __cil_tmp8 = __cil_tmp7 + 8;
#line 1655
  __cil_tmp9 = *((struct ttm_object_file **)__cil_tmp8);
#line 1655
  __cil_tmp10 = *((uint32_t *)arg);
#line 1655
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1655
  __cil_tmp12 = (enum ttm_ref_type )0;
#line 1655
  tmp___8 = ttm_ref_object_base_unref(__cil_tmp9, __cil_tmp11, __cil_tmp12);
  }
#line 1655
  return (tmp___8);
}
}
#line 1660 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  bool __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  {
#line 1663
  tmp___7 = vmw_dma_buffer(bo);
#line 1663
  vmw_bo = tmp___7;
#line 1665
  __cil_tmp6 = (unsigned long )vmw_bo;
#line 1665
  __cil_tmp7 = __cil_tmp6 + 408;
#line 1665
  __cil_tmp8 = *((bool *)__cil_tmp7);
#line 1665
  __cil_tmp9 = ! __cil_tmp8;
#line 1665
  __cil_tmp10 = ! __cil_tmp9;
#line 1665
  __cil_tmp11 = (long )__cil_tmp10;
#line 1665
  tmp___8 = ldv__builtin_expect(__cil_tmp11, 1L);
  }
#line 1665
  if (tmp___8) {
    {
#line 1666
    __cil_tmp12 = (unsigned long )vmw_bo;
#line 1666
    __cil_tmp13 = __cil_tmp12 + 404;
#line 1666
    return (*((uint32_t *)__cil_tmp13));
    }
  } else {

  }
#line 1668
  __cil_tmp14 = (unsigned long )vmw_bo;
#line 1668
  __cil_tmp15 = __cil_tmp14 + 404;
#line 1668
  *((uint32_t *)__cil_tmp15) = cur_validate_node;
#line 1669
  __cil_tmp16 = (unsigned long )vmw_bo;
#line 1669
  __cil_tmp17 = __cil_tmp16 + 408;
#line 1669
  *((bool *)__cil_tmp17) = (bool )1;
#line 1671
  return (cur_validate_node);
}
}
#line 1674 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 1676
  tmp___7 = vmw_dma_buffer(bo);
#line 1676
  vmw_bo = tmp___7;
#line 1678
  __cil_tmp4 = (unsigned long )vmw_bo;
#line 1678
  __cil_tmp5 = __cil_tmp4 + 408;
#line 1678
  *((bool *)__cil_tmp5) = (bool )0;
  }
#line 1679
  return;
}
}
#line 1681 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object    *__mptr ;
  struct ttm_base_object **__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_base_object **__cil_tmp12 ;
  struct ttm_base_object *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct ttm_base_object **__cil_tmp20 ;
  struct ttm_base_object *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  enum ttm_object_type __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct ttm_base_object **__cil_tmp31 ;
  struct ttm_base_object *__cil_tmp32 ;
  struct vmw_user_dma_buffer *__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct ttm_buffer_object *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;

  {
  {
#line 1687
  __cil_tmp9 = & base;
#line 1687
  *__cil_tmp9 = ttm_base_object_lookup(tfile, handle);
#line 1688
  __cil_tmp10 = (void *)0;
#line 1688
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1688
  __cil_tmp12 = & base;
#line 1688
  __cil_tmp13 = *__cil_tmp12;
#line 1688
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1688
  __cil_tmp15 = __cil_tmp14 == __cil_tmp11;
#line 1688
  __cil_tmp16 = ! __cil_tmp15;
#line 1688
  __cil_tmp17 = ! __cil_tmp16;
#line 1688
  __cil_tmp18 = (long )__cil_tmp17;
#line 1688
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  }
#line 1688
  if (tmp___7) {
    {
#line 1689
    __cil_tmp19 = (unsigned long )handle;
#line 1689
    printk("<3>Invalid buffer object handle 0x%08lx.\n", __cil_tmp19);
    }
#line 1691
    return (-3);
  } else {

  }
  {
#line 1694
  __cil_tmp20 = & base;
#line 1694
  __cil_tmp21 = *__cil_tmp20;
#line 1694
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 1694
  __cil_tmp23 = __cil_tmp22 + 24;
#line 1694
  __cil_tmp24 = *((enum ttm_object_type *)__cil_tmp23);
#line 1694
  __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 1694
  __cil_tmp26 = __cil_tmp25 != 1U;
#line 1694
  __cil_tmp27 = ! __cil_tmp26;
#line 1694
  __cil_tmp28 = ! __cil_tmp27;
#line 1694
  __cil_tmp29 = (long )__cil_tmp28;
#line 1694
  tmp___8 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 1694
  if (tmp___8) {
    {
#line 1695
    ttm_base_object_unref(& base);
#line 1696
    __cil_tmp30 = (unsigned long )handle;
#line 1696
    printk("<3>Invalid buffer object handle 0x%08lx.\n", __cil_tmp30);
    }
#line 1698
    return (-22);
  } else {

  }
  {
#line 1701
  __cil_tmp31 = & base;
#line 1701
  __cil_tmp32 = *__cil_tmp31;
#line 1701
  __mptr = (struct ttm_base_object    *)__cil_tmp32;
#line 1701
  __cil_tmp33 = (struct vmw_user_dma_buffer *)0;
#line 1701
  __cil_tmp34 = (struct ttm_base_object *)__cil_tmp33;
#line 1701
  __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 1701
  __cil_tmp36 = (char *)__mptr;
#line 1701
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
#line 1701
  vmw_user_bo = (struct vmw_user_dma_buffer *)__cil_tmp37;
#line 1702
  __cil_tmp38 = (unsigned long )vmw_user_bo;
#line 1702
  __cil_tmp39 = __cil_tmp38 + 64;
#line 1702
  __cil_tmp40 = (struct ttm_buffer_object *)__cil_tmp39;
#line 1702
  ttm_bo_reference(__cil_tmp40);
#line 1703
  ttm_base_object_unref(& base);
#line 1704
  __cil_tmp41 = (unsigned long )vmw_user_bo;
#line 1704
  __cil_tmp42 = __cil_tmp41 + 64;
#line 1704
  *out = (struct vmw_dma_buffer *)__cil_tmp42;
  }
#line 1706
  return (0);
}
}
#line 1713 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_stream_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_stream *stream ;
  int ret ;
  struct vmw_resource    *__mptr ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_stream *__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  int    __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;

  {
  {
#line 1715
  __cil_tmp8 = (unsigned long )res;
#line 1715
  __cil_tmp9 = __cil_tmp8 + 8;
#line 1715
  dev_priv = *((struct vmw_private **)__cil_tmp9);
#line 1719
  printk("<6>[drm] %s: unref\n", "vmw_stream_destroy");
#line 1720
  __mptr = (struct vmw_resource    *)res;
#line 1720
  __cil_tmp10 = (struct vmw_stream *)0;
#line 1720
  __cil_tmp11 = (struct vmw_resource *)__cil_tmp10;
#line 1720
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 1720
  __cil_tmp13 = (char *)__mptr;
#line 1720
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 1720
  stream = (struct vmw_stream *)__cil_tmp14;
#line 1722
  __cil_tmp15 = (unsigned long )stream;
#line 1722
  __cil_tmp16 = __cil_tmp15 + 96;
#line 1722
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
#line 1722
  ret = vmw_overlay_unref(dev_priv, __cil_tmp17);
#line 1723
  __cil_tmp18 = ret != 0;
#line 1723
  __cil_tmp19 = ! __cil_tmp18;
#line 1723
  __ret_warn_on = ! __cil_tmp19;
#line 1723
  __cil_tmp20 = ! __ret_warn_on;
#line 1723
  __cil_tmp21 = ! __cil_tmp20;
#line 1723
  __cil_tmp22 = (long )__cil_tmp21;
#line 1723
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  }
#line 1723
  if (tmp___7) {
    {
#line 1723
    __cil_tmp23 = (int    )1723;
#line 1723
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c",
                       __cil_tmp23);
    }
  } else {

  }
  {
#line 1723
  __cil_tmp24 = ! __ret_warn_on;
#line 1723
  __cil_tmp25 = ! __cil_tmp24;
#line 1723
  __cil_tmp26 = (long )__cil_tmp25;
#line 1723
  ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 1724
  return;
}
}
#line 1726 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static int vmw_stream_init(struct vmw_private *dev_priv , struct vmw_stream *stream ,
                           void (*res_free)(struct vmw_resource *res ) ) 
{ struct vmw_resource *res ;
  int ret ;
  long tmp___7 ;
  struct vmw_resource **__cil_tmp7 ;
  struct vmw_resource **__cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct idr *__cil_tmp12 ;
  enum ttm_object_type __cil_tmp13 ;
  bool __cil_tmp14 ;
  void *__cil_tmp15 ;
  void (*__cil_tmp16)(struct vmw_resource *res ) ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void    *__cil_tmp24 ;
  struct vmw_resource *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t *__cil_tmp28 ;
  struct vmw_resource *__cil_tmp29 ;

  {
  {
#line 1730
  __cil_tmp7 = & res;
#line 1730
  *__cil_tmp7 = (struct vmw_resource *)stream;
#line 1733
  __cil_tmp8 = & res;
#line 1733
  __cil_tmp9 = *__cil_tmp8;
#line 1733
  __cil_tmp10 = (unsigned long )dev_priv;
#line 1733
  __cil_tmp11 = __cil_tmp10 + 2752;
#line 1733
  __cil_tmp12 = (struct idr *)__cil_tmp11;
#line 1733
  __cil_tmp13 = (enum ttm_object_type )258;
#line 1733
  __cil_tmp14 = (bool )0;
#line 1733
  __cil_tmp15 = (void *)0;
#line 1733
  __cil_tmp16 = (void (*)(struct vmw_resource *res ))__cil_tmp15;
#line 1733
  ret = vmw_resource_init(dev_priv, __cil_tmp9, __cil_tmp12, __cil_tmp13, __cil_tmp14,
                          res_free, __cil_tmp16);
#line 1736
  __cil_tmp17 = ret != 0;
#line 1736
  __cil_tmp18 = ! __cil_tmp17;
#line 1736
  __cil_tmp19 = ! __cil_tmp18;
#line 1736
  __cil_tmp20 = (long )__cil_tmp19;
#line 1736
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 1736
  if (tmp___7) {
    {
#line 1737
    __cil_tmp21 = (void *)0;
#line 1737
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 1737
    __cil_tmp23 = (unsigned long )res_free;
#line 1737
    if (__cil_tmp23 == __cil_tmp22) {
      {
#line 1738
      __cil_tmp24 = (void    *)stream;
#line 1738
      kfree(__cil_tmp24);
      }
    } else {
      {
#line 1740
      __cil_tmp25 = (struct vmw_resource *)stream;
#line 1740
      (*res_free)(__cil_tmp25);
      }
    }
    }
#line 1741
    return (ret);
  } else {

  }
  {
#line 1744
  __cil_tmp26 = (unsigned long )stream;
#line 1744
  __cil_tmp27 = __cil_tmp26 + 96;
#line 1744
  __cil_tmp28 = (uint32_t *)__cil_tmp27;
#line 1744
  ret = vmw_overlay_claim(dev_priv, __cil_tmp28);
  }
#line 1745
  if (ret) {
    {
#line 1746
    vmw_resource_unreference(& res);
    }
#line 1747
    return (ret);
  } else {

  }
  {
#line 1750
  printk("<6>[drm] %s: claimed\n", "vmw_stream_init");
#line 1752
  __cil_tmp29 = (struct vmw_resource *)stream;
#line 1752
  vmw_resource_activate(__cil_tmp29, & vmw_stream_destroy);
  }
#line 1753
  return (0);
}
}
#line 1760 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_stream_free(struct vmw_resource *res ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource    *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_stream *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void    *__cil_tmp15 ;

  {
  {
#line 1763
  __mptr = (struct vmw_resource    *)res;
#line 1763
  __cil_tmp6 = (struct vmw_user_stream *)0;
#line 1763
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 1763
  __cil_tmp8 = __cil_tmp7 + 64;
#line 1763
  __cil_tmp9 = (struct vmw_resource *)__cil_tmp8;
#line 1763
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 1763
  __cil_tmp11 = (char *)__mptr;
#line 1763
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 1763
  stream = (struct vmw_user_stream *)__cil_tmp12;
#line 1764
  __cil_tmp13 = (unsigned long )res;
#line 1764
  __cil_tmp14 = __cil_tmp13 + 8;
#line 1764
  dev_priv = *((struct vmw_private **)__cil_tmp14);
#line 1766
  __cil_tmp15 = (void    *)stream;
#line 1766
  kfree(__cil_tmp15);
#line 1767
  tmp___7 = vmw_mem_glob(dev_priv);
#line 1767
  ttm_mem_global_free(tmp___7, vmw_user_stream_size);
  }
#line 1769
  return;
}
}
#line 1776 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
static void vmw_user_stream_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_stream *stream ;
  struct ttm_base_object    *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_stream *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 1778
  base = *p_base;
#line 1780
  __mptr = (struct ttm_base_object    *)base;
#line 1780
  __cil_tmp6 = (struct vmw_user_stream *)0;
#line 1780
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
#line 1780
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 1780
  __cil_tmp9 = (char *)__mptr;
#line 1780
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 1780
  stream = (struct vmw_user_stream *)__cil_tmp10;
#line 1781
  __cil_tmp11 = & res;
#line 1781
  __cil_tmp12 = (unsigned long )stream;
#line 1781
  __cil_tmp13 = __cil_tmp12 + 64;
#line 1781
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
#line 1783
  __cil_tmp14 = (void *)0;
#line 1783
  *p_base = (struct ttm_base_object *)__cil_tmp14;
#line 1784
  vmw_resource_unreference(& res);
  }
#line 1785
  return;
}
}
#line 1787 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_resource *res ;
  struct vmw_user_stream *stream ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  int ret ;
  long tmp___9 ;
  struct vmw_resource    *__mptr ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_resource **__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct idr *__cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_resource **__cil_tmp24 ;
  struct vmw_resource *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_resource **__cil_tmp32 ;
  struct vmw_resource *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  void (*__cil_tmp36)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp37 ;
  struct vmw_resource **__cil_tmp38 ;
  struct vmw_resource *__cil_tmp39 ;
  struct vmw_user_stream *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_resource *__cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_object_file *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  enum ttm_ref_type __cil_tmp58 ;

  {
  {
#line 1790
  tmp___7 = vmw_priv(dev);
#line 1790
  dev_priv = tmp___7;
#line 1793
  arg = (struct drm_vmw_stream_arg *)data;
#line 1794
  tmp___8 = vmw_fpriv(file_priv);
#line 1794
  __cil_tmp14 = (unsigned long )tmp___8;
#line 1794
  __cil_tmp15 = __cil_tmp14 + 8;
#line 1794
  tfile = *((struct ttm_object_file **)__cil_tmp15);
#line 1795
  ret = 0;
#line 1797
  __cil_tmp16 = & res;
#line 1797
  __cil_tmp17 = (unsigned long )dev_priv;
#line 1797
  __cil_tmp18 = __cil_tmp17 + 2752;
#line 1797
  __cil_tmp19 = (struct idr *)__cil_tmp18;
#line 1797
  __cil_tmp20 = *((uint32_t *)arg);
#line 1797
  __cil_tmp21 = (int )__cil_tmp20;
#line 1797
  *__cil_tmp16 = vmw_resource_lookup(dev_priv, __cil_tmp19, __cil_tmp21);
#line 1798
  __cil_tmp22 = (void *)0;
#line 1798
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1798
  __cil_tmp24 = & res;
#line 1798
  __cil_tmp25 = *__cil_tmp24;
#line 1798
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 1798
  __cil_tmp27 = __cil_tmp26 == __cil_tmp23;
#line 1798
  __cil_tmp28 = ! __cil_tmp27;
#line 1798
  __cil_tmp29 = ! __cil_tmp28;
#line 1798
  __cil_tmp30 = (long )__cil_tmp29;
#line 1798
  tmp___9 = ldv__builtin_expect(__cil_tmp30, 0L);
  }
#line 1798
  if (tmp___9) {
#line 1799
    return (-22);
  } else {

  }
  {
#line 1801
  __cil_tmp31 = (unsigned long )(& vmw_user_stream_free);
#line 1801
  __cil_tmp32 = & res;
#line 1801
  __cil_tmp33 = *__cil_tmp32;
#line 1801
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 1801
  __cil_tmp35 = __cil_tmp34 + 56;
#line 1801
  __cil_tmp36 = *((void (**)(struct vmw_resource *res ))__cil_tmp35);
#line 1801
  __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 1801
  if (__cil_tmp37 != __cil_tmp31) {
#line 1802
    ret = -22;
#line 1803
    goto out;
  } else {

  }
  }
#line 1806
  __cil_tmp38 = & res;
#line 1806
  __cil_tmp39 = *__cil_tmp38;
#line 1806
  __mptr = (struct vmw_resource    *)__cil_tmp39;
#line 1806
  __cil_tmp40 = (struct vmw_user_stream *)0;
#line 1806
  __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 1806
  __cil_tmp42 = __cil_tmp41 + 64;
#line 1806
  __cil_tmp43 = (struct vmw_resource *)__cil_tmp42;
#line 1806
  __cil_tmp44 = (unsigned int )__cil_tmp43;
#line 1806
  __cil_tmp45 = (char *)__mptr;
#line 1806
  __cil_tmp46 = __cil_tmp45 - __cil_tmp44;
#line 1806
  stream = (struct vmw_user_stream *)__cil_tmp46;
  {
#line 1807
  __cil_tmp47 = (unsigned long )tfile;
#line 1807
  __cil_tmp48 = 0 + 32;
#line 1807
  __cil_tmp49 = (unsigned long )stream;
#line 1807
  __cil_tmp50 = __cil_tmp49 + __cil_tmp48;
#line 1807
  __cil_tmp51 = *((struct ttm_object_file **)__cil_tmp50);
#line 1807
  __cil_tmp52 = (unsigned long )__cil_tmp51;
#line 1807
  if (__cil_tmp52 != __cil_tmp47) {
#line 1808
    ret = -22;
#line 1809
    goto out;
  } else {

  }
  }
  {
#line 1812
  __cil_tmp53 = 0 + 16;
#line 1812
  __cil_tmp54 = 0 + __cil_tmp53;
#line 1812
  __cil_tmp55 = (unsigned long )stream;
#line 1812
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 1812
  __cil_tmp57 = *((unsigned long *)__cil_tmp56);
#line 1812
  __cil_tmp58 = (enum ttm_ref_type )0;
#line 1812
  ttm_ref_object_base_unref(tfile, __cil_tmp57, __cil_tmp58);
  }
  out: 
  {
#line 1814
  vmw_resource_unreference(& res);
  }
#line 1815
  return (ret);
}
}
#line 1818 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  int ret ;
  size_t tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct ttm_mem_global *tmp___14 ;
  long tmp___15 ;
  void *tmp___16 ;
  struct ttm_mem_global *tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  size_t __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;
  bool __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  bool __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  struct vmw_resource **__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct vmw_stream *__cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  long __cil_tmp70 ;
  struct vmw_resource **__cil_tmp71 ;
  struct vmw_resource **__cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  struct ttm_base_object *__cil_tmp74 ;
  bool __cil_tmp75 ;
  enum ttm_object_type __cil_tmp76 ;
  void *__cil_tmp77 ;
  void (*__cil_tmp78)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct vmw_resource **__cil_tmp83 ;
  struct vmw_resource *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int __cil_tmp87 ;
  struct ttm_lock *__cil_tmp88 ;

  {
  {
#line 1821
  tmp___7 = vmw_priv(dev);
#line 1821
  dev_priv = tmp___7;
#line 1825
  arg = (struct drm_vmw_stream_arg *)data;
#line 1826
  tmp___9 = vmw_fpriv(file_priv);
#line 1826
  __cil_tmp25 = (unsigned long )tmp___9;
#line 1826
  __cil_tmp26 = __cil_tmp25 + 8;
#line 1826
  tfile = *((struct ttm_object_file **)__cil_tmp26);
#line 1827
  __cil_tmp27 = (unsigned long )file_priv;
#line 1827
  __cil_tmp28 = __cil_tmp27 + 152;
#line 1827
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
#line 1827
  tmp___10 = vmw_master(__cil_tmp29);
#line 1827
  vmaster = tmp___10;
#line 1835
  __cil_tmp30 = vmw_user_stream_size == 0ULL;
#line 1835
  __cil_tmp31 = ! __cil_tmp30;
#line 1835
  __cil_tmp32 = ! __cil_tmp31;
#line 1835
  __cil_tmp33 = (long )__cil_tmp32;
#line 1835
  tmp___12 = ldv__builtin_expect(__cil_tmp33, 0L);
  }
#line 1835
  if (tmp___12) {
    {
#line 1836
    tmp___11 = ttm_round_pot(168UL);
#line 1836
    __cil_tmp34 = tmp___11 + 128UL;
#line 1836
    vmw_user_stream_size = (uint64_t )__cil_tmp34;
    }
  } else {

  }
  {
#line 1838
  __cil_tmp35 = (struct ttm_lock *)vmaster;
#line 1838
  __cil_tmp36 = (bool )1;
#line 1838
  ret = ttm_read_lock(__cil_tmp35, __cil_tmp36);
#line 1839
  __cil_tmp37 = ret != 0;
#line 1839
  __cil_tmp38 = ! __cil_tmp37;
#line 1839
  __cil_tmp39 = ! __cil_tmp38;
#line 1839
  __cil_tmp40 = (long )__cil_tmp39;
#line 1839
  tmp___13 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 1839
  if (tmp___13) {
#line 1840
    return (ret);
  } else {

  }
  {
#line 1842
  tmp___14 = vmw_mem_glob(dev_priv);
#line 1842
  __cil_tmp41 = (bool )0;
#line 1842
  __cil_tmp42 = (bool )1;
#line 1842
  ret = ttm_mem_global_alloc(tmp___14, vmw_user_stream_size, __cil_tmp41, __cil_tmp42);
#line 1845
  __cil_tmp43 = ret != 0;
#line 1845
  __cil_tmp44 = ! __cil_tmp43;
#line 1845
  __cil_tmp45 = ! __cil_tmp44;
#line 1845
  __cil_tmp46 = (long )__cil_tmp45;
#line 1845
  tmp___15 = ldv__builtin_expect(__cil_tmp46, 0L);
  }
#line 1845
  if (tmp___15) {
#line 1846
    if (ret != -512) {
      {
#line 1847
      drm_err("vmw_stream_claim_ioctl", "Out of graphics memory for stream creation.\n");
      }
    } else {

    }
#line 1849
    goto out_unlock;
  } else {

  }
  {
#line 1853
  tmp___16 = kmalloc(168UL, 208U);
#line 1853
  stream = (struct vmw_user_stream *)tmp___16;
#line 1854
  __cil_tmp47 = (void *)0;
#line 1854
  __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 1854
  __cil_tmp49 = (unsigned long )stream;
#line 1854
  __cil_tmp50 = __cil_tmp49 == __cil_tmp48;
#line 1854
  __cil_tmp51 = ! __cil_tmp50;
#line 1854
  __cil_tmp52 = ! __cil_tmp51;
#line 1854
  __cil_tmp53 = (long )__cil_tmp52;
#line 1854
  tmp___18 = ldv__builtin_expect(__cil_tmp53, 0L);
  }
#line 1854
  if (tmp___18) {
    {
#line 1855
    tmp___17 = vmw_mem_glob(dev_priv);
#line 1855
    ttm_mem_global_free(tmp___17, vmw_user_stream_size);
#line 1857
    ret = -12;
    }
#line 1858
    goto out_unlock;
  } else {

  }
  {
#line 1861
  __cil_tmp54 = & res;
#line 1861
  __cil_tmp55 = (unsigned long )stream;
#line 1861
  __cil_tmp56 = __cil_tmp55 + 64;
#line 1861
  *__cil_tmp54 = (struct vmw_resource *)__cil_tmp56;
#line 1862
  __cil_tmp57 = 0 + 28;
#line 1862
  __cil_tmp58 = (unsigned long )stream;
#line 1862
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 1862
  *((bool *)__cil_tmp59) = (bool )0;
#line 1863
  __cil_tmp60 = 0 + 32;
#line 1863
  __cil_tmp61 = (unsigned long )stream;
#line 1863
  __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 1863
  __cil_tmp63 = (void *)0;
#line 1863
  *((struct ttm_object_file **)__cil_tmp62) = (struct ttm_object_file *)__cil_tmp63;
#line 1869
  __cil_tmp64 = (unsigned long )stream;
#line 1869
  __cil_tmp65 = __cil_tmp64 + 64;
#line 1869
  __cil_tmp66 = (struct vmw_stream *)__cil_tmp65;
#line 1869
  ret = vmw_stream_init(dev_priv, __cil_tmp66, & vmw_user_stream_free);
#line 1870
  __cil_tmp67 = ret != 0;
#line 1870
  __cil_tmp68 = ! __cil_tmp67;
#line 1870
  __cil_tmp69 = ! __cil_tmp68;
#line 1870
  __cil_tmp70 = (long )__cil_tmp69;
#line 1870
  tmp___19 = ldv__builtin_expect(__cil_tmp70, 0L);
  }
#line 1870
  if (tmp___19) {
#line 1871
    goto out_unlock;
  } else {

  }
  {
#line 1873
  __cil_tmp71 = & tmp___8;
#line 1873
  __cil_tmp72 = & res;
#line 1873
  __cil_tmp73 = *__cil_tmp72;
#line 1873
  *__cil_tmp71 = vmw_resource_reference(__cil_tmp73);
#line 1874
  __cil_tmp74 = (struct ttm_base_object *)stream;
#line 1874
  __cil_tmp75 = (bool )0;
#line 1874
  __cil_tmp76 = (enum ttm_object_type )258;
#line 1874
  __cil_tmp77 = (void *)0;
#line 1874
  __cil_tmp78 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp77;
#line 1874
  ret = ttm_base_object_init(tfile, __cil_tmp74, __cil_tmp75, __cil_tmp76, & vmw_user_stream_base_release,
                             __cil_tmp78);
#line 1877
  __cil_tmp79 = ret != 0;
#line 1877
  __cil_tmp80 = ! __cil_tmp79;
#line 1877
  __cil_tmp81 = ! __cil_tmp80;
#line 1877
  __cil_tmp82 = (long )__cil_tmp81;
#line 1877
  tmp___20 = ldv__builtin_expect(__cil_tmp82, 0L);
  }
#line 1877
  if (tmp___20) {
    {
#line 1878
    vmw_resource_unreference(& tmp___8);
    }
#line 1879
    goto out_err;
  } else {

  }
#line 1882
  __cil_tmp83 = & res;
#line 1882
  __cil_tmp84 = *__cil_tmp83;
#line 1882
  __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 1882
  __cil_tmp86 = __cil_tmp85 + 24;
#line 1882
  __cil_tmp87 = *((int *)__cil_tmp86);
#line 1882
  *((uint32_t *)arg) = (uint32_t )__cil_tmp87;
  out_err: 
  {
#line 1884
  vmw_resource_unreference(& res);
  }
  out_unlock: 
  {
#line 1886
  __cil_tmp88 = (struct ttm_lock *)vmaster;
#line 1886
  ttm_read_unlock(__cil_tmp88);
  }
#line 1887
  return (ret);
}
}
#line 1890 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  int ret ;
  long tmp___7 ;
  struct vmw_resource    *__mptr ;
  struct vmw_resource **__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct idr *__cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_resource **__cil_tmp18 ;
  struct vmw_resource *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_resource **__cil_tmp26 ;
  struct vmw_resource *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void (*__cil_tmp30)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp31 ;
  struct vmw_resource **__cil_tmp32 ;
  struct vmw_resource *__cil_tmp33 ;
  struct vmw_user_stream *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_resource *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct ttm_object_file *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct vmw_resource **__cil_tmp50 ;

  {
  {
#line 1898
  __cil_tmp10 = & res;
#line 1898
  __cil_tmp11 = (unsigned long )dev_priv;
#line 1898
  __cil_tmp12 = __cil_tmp11 + 2752;
#line 1898
  __cil_tmp13 = (struct idr *)__cil_tmp12;
#line 1898
  __cil_tmp14 = *inout_id;
#line 1898
  __cil_tmp15 = (int )__cil_tmp14;
#line 1898
  *__cil_tmp10 = vmw_resource_lookup(dev_priv, __cil_tmp13, __cil_tmp15);
#line 1899
  __cil_tmp16 = (void *)0;
#line 1899
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 1899
  __cil_tmp18 = & res;
#line 1899
  __cil_tmp19 = *__cil_tmp18;
#line 1899
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 1899
  __cil_tmp21 = __cil_tmp20 == __cil_tmp17;
#line 1899
  __cil_tmp22 = ! __cil_tmp21;
#line 1899
  __cil_tmp23 = ! __cil_tmp22;
#line 1899
  __cil_tmp24 = (long )__cil_tmp23;
#line 1899
  tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 1899
  if (tmp___7) {
#line 1900
    return (-22);
  } else {

  }
  {
#line 1902
  __cil_tmp25 = (unsigned long )(& vmw_user_stream_free);
#line 1902
  __cil_tmp26 = & res;
#line 1902
  __cil_tmp27 = *__cil_tmp26;
#line 1902
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 1902
  __cil_tmp29 = __cil_tmp28 + 56;
#line 1902
  __cil_tmp30 = *((void (**)(struct vmw_resource *res ))__cil_tmp29);
#line 1902
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 1902
  if (__cil_tmp31 != __cil_tmp25) {
#line 1903
    ret = -22;
#line 1904
    goto err_ref;
  } else {

  }
  }
#line 1907
  __cil_tmp32 = & res;
#line 1907
  __cil_tmp33 = *__cil_tmp32;
#line 1907
  __mptr = (struct vmw_resource    *)__cil_tmp33;
#line 1907
  __cil_tmp34 = (struct vmw_user_stream *)0;
#line 1907
  __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 1907
  __cil_tmp36 = __cil_tmp35 + 64;
#line 1907
  __cil_tmp37 = (struct vmw_resource *)__cil_tmp36;
#line 1907
  __cil_tmp38 = (unsigned int )__cil_tmp37;
#line 1907
  __cil_tmp39 = (char *)__mptr;
#line 1907
  __cil_tmp40 = __cil_tmp39 - __cil_tmp38;
#line 1907
  stream = (struct vmw_user_stream *)__cil_tmp40;
  {
#line 1908
  __cil_tmp41 = (unsigned long )tfile;
#line 1908
  __cil_tmp42 = 0 + 32;
#line 1908
  __cil_tmp43 = (unsigned long )stream;
#line 1908
  __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 1908
  __cil_tmp45 = *((struct ttm_object_file **)__cil_tmp44);
#line 1908
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 1908
  if (__cil_tmp46 != __cil_tmp41) {
#line 1909
    ret = -1;
#line 1910
    goto err_ref;
  } else {

  }
  }
#line 1913
  __cil_tmp47 = 64 + 96;
#line 1913
  __cil_tmp48 = (unsigned long )stream;
#line 1913
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 1913
  *inout_id = *((uint32_t *)__cil_tmp49);
#line 1914
  __cil_tmp50 = & res;
#line 1914
  *out = *__cil_tmp50;
#line 1915
  return (0);
  err_ref: 
  {
#line 1917
  vmw_resource_unreference(& res);
  }
#line 1918
  return (ret);
}
}
#line 603 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_tt_init(struct ttm_tt *ttm , struct ttm_bo_device *bdev , unsigned long size ,
                       uint32_t page_flags , struct page *dummy_read_page ) ;
#line 617
extern void ttm_tt_fini(struct ttm_tt *ttm ) ;
#line 1009
extern struct ttm_mem_type_manager_func    ttm_bo_manager_func ;
#line 72 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) ;
#line 77
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) ;
#line 84
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) ;
#line 519 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct ttm_placement vmw_vram_gmr_ne_placement ;
#line 520
struct ttm_placement vmw_sys_placement ;
#line 521
struct ttm_placement vmw_evictable_placement ;
#line 668
struct ttm_mem_type_manager_func    vmw_gmrid_manager_func ;
#line 48 "include/drm/ttm/ttm_page_alloc.h"
extern int ttm_pool_populate(struct ttm_tt *ttm ) ;
#line 57
extern void ttm_pool_unpopulate(struct ttm_tt *ttm ) ;
#line 34 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t vram_placement_flags  =    (uint32_t )((1 << 2) | (1 << 16));
#line 37 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t vram_ne_placement_flags  =    (uint32_t )(((1 << 2) | (1 << 16)) | (1 << 21));
#line 41 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t sys_placement_flags  =    (uint32_t )(1 | (1 << 16));
#line 44 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t gmr_placement_flags  =    (uint32_t )((1 << 3) | (1 << 16));
#line 47 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t gmr_ne_placement_flags  =    (uint32_t )(((1 << 3) | (1 << 16)) | (1 << 21));
#line 51 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_vram_placement  =    {0U, 0U, 1U, (uint32_t    *)(& vram_placement_flags), 1U, (uint32_t    *)(& vram_placement_flags)};
#line 60 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t vram_gmr_placement_flags[2]  = {      (uint32_t )((1 << 2) | (1 << 16)),      (uint32_t )((1 << 3) | (1 << 16))};
#line 65 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t gmr_vram_placement_flags[2]  = {      (uint32_t )((1 << 3) | (1 << 16)),      (uint32_t )((1 << 2) | (1 << 16))};
#line 70 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_vram_gmr_placement  =    {0U, 0U, 2U, (uint32_t    *)(vram_gmr_placement_flags), 1U, (uint32_t    *)(& gmr_placement_flags)};
#line 79 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t vram_gmr_ne_placement_flags[2]  = {      (uint32_t )(((1 << 2) | (1 << 16)) | (1 << 21)),      (uint32_t )(((1 << 3) | (1 << 16)) | (1 << 21))};
#line 84 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_vram_gmr_ne_placement  =    {0U, 0U, 2U, (uint32_t    *)(vram_gmr_ne_placement_flags), 1U, (uint32_t    *)(& gmr_ne_placement_flags)};
#line 93 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_vram_sys_placement  =    {0U, 0U, 1U, (uint32_t    *)(& vram_placement_flags), 1U, (uint32_t    *)(& sys_placement_flags)};
#line 102 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_vram_ne_placement  =    {0U, 0U, 1U, (uint32_t    *)(& vram_ne_placement_flags), 1U, (uint32_t    *)(& vram_ne_placement_flags)};
#line 111 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_sys_placement  =    {0U, 0U, 1U, (uint32_t    *)(& sys_placement_flags), 1U, (uint32_t    *)(& sys_placement_flags)};
#line 120 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static uint32_t evictable_placement_flags[3]  = {      (uint32_t )(1 | (1 << 16)),      (uint32_t )((1 << 2) | (1 << 16)),      (uint32_t )((1 << 3) | (1 << 16))};
#line 126 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_evictable_placement  =    {0U, 0U, 3U, (uint32_t    *)(evictable_placement_flags), 1U, (uint32_t    *)(& sys_placement_flags)};
#line 135 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_placement vmw_srf_placement  =    {0U, 0U, 1U, (uint32_t    *)(& gmr_placement_flags), 2U, (uint32_t    *)(gmr_vram_placement_flags)};
#line 150 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_ttm_bind(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt    *__mptr ;
  int tmp___7 ;
  struct vmw_ttm_tt *__cil_tmp6 ;
  struct ttm_tt *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_private *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct page **__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;

  {
  {
#line 152
  __mptr = (struct ttm_tt    *)ttm;
#line 152
  __cil_tmp6 = (struct vmw_ttm_tt *)0;
#line 152
  __cil_tmp7 = (struct ttm_tt *)__cil_tmp6;
#line 152
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 152
  __cil_tmp9 = (char *)__mptr;
#line 152
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 152
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp10;
#line 154
  __cil_tmp11 = (unsigned long )vmw_be;
#line 154
  __cil_tmp12 = __cil_tmp11 + 88;
#line 154
  __cil_tmp13 = (unsigned long )bo_mem;
#line 154
  __cil_tmp14 = __cil_tmp13 + 8;
#line 154
  __cil_tmp15 = *((unsigned long *)__cil_tmp14);
#line 154
  *((int *)__cil_tmp12) = (int )__cil_tmp15;
#line 156
  __cil_tmp16 = (unsigned long )vmw_be;
#line 156
  __cil_tmp17 = __cil_tmp16 + 80;
#line 156
  __cil_tmp18 = *((struct vmw_private **)__cil_tmp17);
#line 156
  __cil_tmp19 = (unsigned long )ttm;
#line 156
  __cil_tmp20 = __cil_tmp19 + 24;
#line 156
  __cil_tmp21 = *((struct page ***)__cil_tmp20);
#line 156
  __cil_tmp22 = (unsigned long )ttm;
#line 156
  __cil_tmp23 = __cil_tmp22 + 40;
#line 156
  __cil_tmp24 = *((unsigned long *)__cil_tmp23);
#line 156
  __cil_tmp25 = (unsigned long )vmw_be;
#line 156
  __cil_tmp26 = __cil_tmp25 + 88;
#line 156
  __cil_tmp27 = *((int *)__cil_tmp26);
#line 156
  tmp___7 = vmw_gmr_bind(__cil_tmp18, __cil_tmp21, __cil_tmp24, __cil_tmp27);
  }
#line 156
  return (tmp___7);
}
}
#line 160 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_ttm_unbind(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt    *__mptr ;
  struct vmw_ttm_tt *__cil_tmp4 ;
  struct ttm_tt *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_private *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 162
  __mptr = (struct ttm_tt    *)ttm;
#line 162
  __cil_tmp4 = (struct vmw_ttm_tt *)0;
#line 162
  __cil_tmp5 = (struct ttm_tt *)__cil_tmp4;
#line 162
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 162
  __cil_tmp7 = (char *)__mptr;
#line 162
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 162
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp8;
#line 164
  __cil_tmp9 = (unsigned long )vmw_be;
#line 164
  __cil_tmp10 = __cil_tmp9 + 80;
#line 164
  __cil_tmp11 = *((struct vmw_private **)__cil_tmp10);
#line 164
  __cil_tmp12 = (unsigned long )vmw_be;
#line 164
  __cil_tmp13 = __cil_tmp12 + 88;
#line 164
  __cil_tmp14 = *((int *)__cil_tmp13);
#line 164
  vmw_gmr_unbind(__cil_tmp11, __cil_tmp14);
  }
#line 165
  return (0);
}
}
#line 168 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static void vmw_ttm_destroy(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt    *__mptr ;
  struct vmw_ttm_tt *__cil_tmp4 ;
  struct ttm_tt *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  void    *__cil_tmp9 ;

  {
  {
#line 170
  __mptr = (struct ttm_tt    *)ttm;
#line 170
  __cil_tmp4 = (struct vmw_ttm_tt *)0;
#line 170
  __cil_tmp5 = (struct ttm_tt *)__cil_tmp4;
#line 170
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 170
  __cil_tmp7 = (char *)__mptr;
#line 170
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 170
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp8;
#line 172
  ttm_tt_fini(ttm);
#line 173
  __cil_tmp9 = (void    *)vmw_be;
#line 173
  kfree(__cil_tmp9);
  }
#line 174
  return;
}
}
#line 176 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static struct ttm_backend_func vmw_ttm_func  =    {& vmw_ttm_bind, & vmw_ttm_unbind, & vmw_ttm_destroy};
#line 182 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_tt *vmw_ttm_tt_create(struct ttm_bo_device *bdev , unsigned long size ,
                                 uint32_t page_flags , struct page *dummy_read_page ) 
{ struct vmw_ttm_tt *vmw_be ;
  void *tmp___7 ;
  struct ttm_bo_device    *__mptr ;
  int tmp___8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_private *__cil_tmp15 ;
  struct ttm_bo_device *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct ttm_tt *__cil_tmp20 ;
  void    *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
  {
#line 188
  tmp___7 = kmalloc(96UL, 208U);
#line 188
  vmw_be = (struct vmw_ttm_tt *)tmp___7;
  }
#line 189
  if (! vmw_be) {
    {
#line 190
    __cil_tmp9 = (void *)0;
#line 190
    return ((struct ttm_tt *)__cil_tmp9);
    }
  } else {

  }
  {
#line 192
  __cil_tmp10 = 0 + 8;
#line 192
  __cil_tmp11 = (unsigned long )vmw_be;
#line 192
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 192
  *((struct ttm_backend_func **)__cil_tmp12) = & vmw_ttm_func;
#line 193
  __mptr = (struct ttm_bo_device    *)bdev;
#line 193
  __cil_tmp13 = (unsigned long )vmw_be;
#line 193
  __cil_tmp14 = __cil_tmp13 + 80;
#line 193
  __cil_tmp15 = (struct vmw_private *)0;
#line 193
  __cil_tmp16 = (struct ttm_bo_device *)__cil_tmp15;
#line 193
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 193
  __cil_tmp18 = (char *)__mptr;
#line 193
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 193
  *((struct vmw_private **)__cil_tmp14) = (struct vmw_private *)__cil_tmp19;
#line 195
  __cil_tmp20 = (struct ttm_tt *)vmw_be;
#line 195
  tmp___8 = ttm_tt_init(__cil_tmp20, bdev, size, page_flags, dummy_read_page);
  }
#line 195
  if (tmp___8) {
    {
#line 196
    __cil_tmp21 = (void    *)vmw_be;
#line 196
    kfree(__cil_tmp21);
    }
    {
#line 197
    __cil_tmp22 = (void *)0;
#line 197
    return ((struct ttm_tt *)__cil_tmp22);
    }
  } else {

  }
#line 200
  return ((struct ttm_tt *)vmw_be);
}
}
#line 203 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
int vmw_invalidate_caches(struct ttm_bo_device *bdev , uint32_t flags ) 
{ 

  {
#line 205
  return (0);
}
}
#line 208 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
int vmw_init_mem_type(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 212
  if ((int )type == 0) {
#line 212
    goto case_0;
  } else
#line 219
  if ((int )type == 2) {
#line 219
    goto case_2;
  } else
#line 227
  if ((int )type == 3) {
#line 227
    goto case_3;
  } else {
    {
#line 239
    goto switch_default;
#line 211
    if (0) {
      case_0: /* CIL Label */ 
#line 215
      __cil_tmp4 = (unsigned long )man;
#line 215
      __cil_tmp5 = __cil_tmp4 + 12;
#line 215
      __cil_tmp6 = 1 << 1;
#line 215
      *((uint32_t *)__cil_tmp5) = (uint32_t )__cil_tmp6;
#line 216
      __cil_tmp7 = (unsigned long )man;
#line 216
      __cil_tmp8 = __cil_tmp7 + 32;
#line 216
      __cil_tmp9 = 1 << 16;
#line 216
      *((uint32_t *)__cil_tmp8) = (uint32_t )__cil_tmp9;
#line 217
      __cil_tmp10 = (unsigned long )man;
#line 217
      __cil_tmp11 = __cil_tmp10 + 36;
#line 217
      __cil_tmp12 = 1 << 16;
#line 217
      *((uint32_t *)__cil_tmp11) = (uint32_t )__cil_tmp12;
#line 218
      goto switch_break;
      case_2: /* CIL Label */ 
#line 221
      __cil_tmp13 = (unsigned long )man;
#line 221
      __cil_tmp14 = __cil_tmp13 + 40;
#line 221
      *((struct ttm_mem_type_manager_func    **)__cil_tmp14) = & ttm_bo_manager_func;
#line 222
      __cil_tmp15 = (unsigned long )man;
#line 222
      __cil_tmp16 = __cil_tmp15 + 16;
#line 222
      *((unsigned long *)__cil_tmp16) = 0UL;
#line 223
      __cil_tmp17 = (unsigned long )man;
#line 223
      __cil_tmp18 = __cil_tmp17 + 12;
#line 223
      __cil_tmp19 = 1 << 1;
#line 223
      __cil_tmp20 = 1 | __cil_tmp19;
#line 223
      *((uint32_t *)__cil_tmp18) = (uint32_t )__cil_tmp20;
#line 224
      __cil_tmp21 = (unsigned long )man;
#line 224
      __cil_tmp22 = __cil_tmp21 + 32;
#line 224
      __cil_tmp23 = 1 << 16;
#line 224
      *((uint32_t *)__cil_tmp22) = (uint32_t )__cil_tmp23;
#line 225
      __cil_tmp24 = (unsigned long )man;
#line 225
      __cil_tmp25 = __cil_tmp24 + 36;
#line 225
      __cil_tmp26 = 1 << 16;
#line 225
      *((uint32_t *)__cil_tmp25) = (uint32_t )__cil_tmp26;
#line 226
      goto switch_break;
      case_3: /* CIL Label */ 
#line 233
      __cil_tmp27 = (unsigned long )man;
#line 233
      __cil_tmp28 = __cil_tmp27 + 40;
#line 233
      *((struct ttm_mem_type_manager_func    **)__cil_tmp28) = & vmw_gmrid_manager_func;
#line 234
      __cil_tmp29 = (unsigned long )man;
#line 234
      __cil_tmp30 = __cil_tmp29 + 16;
#line 234
      *((unsigned long *)__cil_tmp30) = 0UL;
#line 235
      __cil_tmp31 = (unsigned long )man;
#line 235
      __cil_tmp32 = __cil_tmp31 + 12;
#line 235
      __cil_tmp33 = 1 << 1;
#line 235
      __cil_tmp34 = 1 << 3;
#line 235
      __cil_tmp35 = __cil_tmp34 | __cil_tmp33;
#line 235
      *((uint32_t *)__cil_tmp32) = (uint32_t )__cil_tmp35;
#line 236
      __cil_tmp36 = (unsigned long )man;
#line 236
      __cil_tmp37 = __cil_tmp36 + 32;
#line 236
      __cil_tmp38 = 1 << 16;
#line 236
      *((uint32_t *)__cil_tmp37) = (uint32_t )__cil_tmp38;
#line 237
      __cil_tmp39 = (unsigned long )man;
#line 237
      __cil_tmp40 = __cil_tmp39 + 36;
#line 237
      __cil_tmp41 = 1 << 16;
#line 237
      *((uint32_t *)__cil_tmp40) = (uint32_t )__cil_tmp41;
#line 238
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 240
      drm_err("vmw_init_mem_type", "Unsupported memory type %u\n", type);
      }
#line 241
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
#line 243
  return (0);
}
}
#line 246 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
void vmw_evict_flags(struct ttm_buffer_object *bo , struct ttm_placement *placement ) 
{ struct ttm_placement *__cil_tmp3 ;

  {
#line 249
  __cil_tmp3 = & vmw_sys_placement;
#line 249
  *placement = *__cil_tmp3;
#line 250
  return;
}
}
#line 256 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_verify_access(struct ttm_buffer_object *bo , struct file *filp ) 
{ 

  {
#line 258
  return (0);
}
}
#line 261 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_ttm_io_mem_reserve(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ struct ttm_mem_type_manager *man ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device    *__mptr ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct vmw_private *__cil_tmp13 ;
  struct ttm_bo_device *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;

  {
#line 263
  __cil_tmp6 = (unsigned long )mem;
#line 263
  __cil_tmp7 = __cil_tmp6 + 36;
#line 263
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
#line 263
  __cil_tmp9 = __cil_tmp8 * 168UL;
#line 263
  __cil_tmp10 = 56 + __cil_tmp9;
#line 263
  __cil_tmp11 = (unsigned long )bdev;
#line 263
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 263
  man = (struct ttm_mem_type_manager *)__cil_tmp12;
#line 264
  __mptr = (struct ttm_bo_device    *)bdev;
#line 264
  __cil_tmp13 = (struct vmw_private *)0;
#line 264
  __cil_tmp14 = (struct ttm_bo_device *)__cil_tmp13;
#line 264
  __cil_tmp15 = (unsigned int )__cil_tmp14;
#line 264
  __cil_tmp16 = (char *)__mptr;
#line 264
  __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
#line 264
  dev_priv = (struct vmw_private *)__cil_tmp17;
#line 266
  __cil_tmp18 = (unsigned long )mem;
#line 266
  __cil_tmp19 = __cil_tmp18 + 48;
#line 266
  *((void **)__cil_tmp19) = (void *)0;
#line 267
  __cil_tmp20 = 48 + 32;
#line 267
  __cil_tmp21 = (unsigned long )mem;
#line 267
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
#line 267
  *((bool *)__cil_tmp22) = (bool )0;
#line 268
  __cil_tmp23 = 48 + 24;
#line 268
  __cil_tmp24 = (unsigned long )mem;
#line 268
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
#line 268
  *((unsigned long *)__cil_tmp25) = 0UL;
#line 269
  __cil_tmp26 = 48 + 16;
#line 269
  __cil_tmp27 = (unsigned long )mem;
#line 269
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
#line 269
  __cil_tmp29 = (unsigned long )mem;
#line 269
  __cil_tmp30 = __cil_tmp29 + 24;
#line 269
  __cil_tmp31 = *((unsigned long *)__cil_tmp30);
#line 269
  *((unsigned long *)__cil_tmp28) = __cil_tmp31 << 12;
#line 270
  __cil_tmp32 = 48 + 8;
#line 270
  __cil_tmp33 = (unsigned long )mem;
#line 270
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 270
  *((unsigned long *)__cil_tmp34) = 0UL;
  {
#line 271
  __cil_tmp35 = 1 << 1;
#line 271
  __cil_tmp36 = (unsigned int )__cil_tmp35;
#line 271
  __cil_tmp37 = (unsigned long )man;
#line 271
  __cil_tmp38 = __cil_tmp37 + 12;
#line 271
  __cil_tmp39 = *((uint32_t *)__cil_tmp38);
#line 271
  __cil_tmp40 = __cil_tmp39 & __cil_tmp36;
#line 271
  if (! __cil_tmp40) {
#line 272
    return (-22);
  } else {

  }
  }
  {
#line 273
  __cil_tmp41 = (unsigned long )mem;
#line 273
  __cil_tmp42 = __cil_tmp41 + 36;
#line 273
  __cil_tmp43 = *((uint32_t *)__cil_tmp42);
#line 274
  if ((int )__cil_tmp43 == 0) {
#line 274
    goto case_0;
  } else
#line 275
  if ((int )__cil_tmp43 == 3) {
#line 275
    goto case_0;
  } else
#line 277
  if ((int )__cil_tmp43 == 2) {
#line 277
    goto case_2;
  } else {
    {
#line 282
    goto switch_default;
#line 273
    if (0) {
      case_0: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 276
      return (0);
      case_2: /* CIL Label */ 
#line 278
      __cil_tmp44 = 48 + 24;
#line 278
      __cil_tmp45 = (unsigned long )mem;
#line 278
      __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
#line 278
      __cil_tmp47 = (unsigned long )mem;
#line 278
      __cil_tmp48 = __cil_tmp47 + 8;
#line 278
      __cil_tmp49 = *((unsigned long *)__cil_tmp48);
#line 278
      *((unsigned long *)__cil_tmp46) = __cil_tmp49 << 12;
#line 279
      __cil_tmp50 = 48 + 8;
#line 279
      __cil_tmp51 = (unsigned long )mem;
#line 279
      __cil_tmp52 = __cil_tmp51 + __cil_tmp50;
#line 279
      __cil_tmp53 = (unsigned long )dev_priv;
#line 279
      __cil_tmp54 = __cil_tmp53 + 2108;
#line 279
      __cil_tmp55 = *((uint32_t *)__cil_tmp54);
#line 279
      *((unsigned long *)__cil_tmp52) = (unsigned long )__cil_tmp55;
#line 280
      __cil_tmp56 = 48 + 32;
#line 280
      __cil_tmp57 = (unsigned long )mem;
#line 280
      __cil_tmp58 = __cil_tmp57 + __cil_tmp56;
#line 280
      *((bool *)__cil_tmp58) = (bool )1;
#line 281
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 283
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  }
#line 285
  return (0);
}
}
#line 288 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static void vmw_ttm_io_mem_free(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 

  {
#line 290
  return;
}
}
#line 292 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_ttm_fault_reserve_notify(struct ttm_buffer_object *bo ) 
{ 

  {
#line 294
  return (0);
}
}
#line 302 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static void *vmw_sync_obj_ref(void *sync_obj ) 
{ struct vmw_fence_obj *tmp___7 ;
  struct vmw_fence_obj *__cil_tmp3 ;

  {
  {
#line 305
  __cil_tmp3 = (struct vmw_fence_obj *)sync_obj;
#line 305
  tmp___7 = vmw_fence_obj_reference(__cil_tmp3);
  }
#line 305
  return ((void *)tmp___7);
}
}
#line 309 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static void vmw_sync_obj_unref(void **sync_obj ) 
{ struct vmw_fence_obj **__cil_tmp2 ;

  {
  {
#line 311
  __cil_tmp2 = (struct vmw_fence_obj **)sync_obj;
#line 311
  vmw_fence_obj_unreference(__cil_tmp2);
  }
#line 312
  return;
}
}
#line 314 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_sync_obj_flush(void *sync_obj , void *sync_arg ) 
{ struct vmw_fence_obj *__cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = (struct vmw_fence_obj *)sync_obj;
#line 316
  vmw_fence_obj_flush(__cil_tmp3);
  }
#line 317
  return (0);
}
}
#line 320 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static bool vmw_sync_obj_signaled(void *sync_obj , void *sync_arg ) 
{ unsigned long flags ;
  bool tmp___7 ;
  struct vmw_fence_obj *__cil_tmp5 ;
  uint32_t __cil_tmp6 ;

  {
  {
#line 322
  flags = (unsigned long )sync_arg;
#line 323
  __cil_tmp5 = (struct vmw_fence_obj *)sync_obj;
#line 323
  __cil_tmp6 = (uint32_t )flags;
#line 323
  tmp___7 = vmw_fence_obj_signaled(__cil_tmp5, __cil_tmp6);
  }
#line 323
  return (tmp___7);
}
}
#line 328 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
static int vmw_sync_obj_wait(void *sync_obj , void *sync_arg , bool lazy , bool interruptible ) 
{ unsigned long flags ;
  int tmp___7 ;
  struct vmw_fence_obj *__cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  {
#line 331
  flags = (unsigned long )sync_arg;
#line 333
  __cil_tmp7 = (struct vmw_fence_obj *)sync_obj;
#line 333
  __cil_tmp8 = (uint32_t )flags;
#line 333
  tmp___7 = vmw_fence_obj_wait(__cil_tmp7, __cil_tmp8, lazy, interruptible, 1250UL);
  }
#line 333
  return (tmp___7);
}
}
#line 339 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
struct ttm_bo_driver vmw_bo_driver  = 
#line 339
     {& vmw_ttm_tt_create, & ttm_pool_populate, & ttm_pool_unpopulate, & vmw_invalidate_caches,
    & vmw_init_mem_type, & vmw_evict_flags, (int (*)(struct ttm_buffer_object *bo ,
                                                     bool evict , bool interruptible ,
                                                     bool no_wait_reserve , bool no_wait_gpu ,
                                                     struct ttm_mem_reg *new_mem ))((void *)0),
    & vmw_verify_access, & vmw_sync_obj_signaled, & vmw_sync_obj_wait, & vmw_sync_obj_flush,
    & vmw_sync_obj_unref, & vmw_sync_obj_ref, (void (*)(struct ttm_buffer_object *bo ,
                                                        struct ttm_mem_reg *new_mem ))((void *)0),
    & vmw_ttm_fault_reserve_notify, (void (*)(struct ttm_buffer_object *bo ))((void *)0),
    & vmw_ttm_io_mem_reserve, & vmw_ttm_io_mem_free};
#line 391 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c"
void ldv_main7_sequence_infinite_withcheck_stateful(void) 
{ struct ttm_tt *var_group1 ;
  struct ttm_mem_reg *var_group2 ;
  struct ttm_bo_device *var_group3 ;
  uint32_t var_vmw_invalidate_caches_4_p1 ;
  uint32_t var_vmw_init_mem_type_5_p1 ;
  struct ttm_mem_type_manager *var_vmw_init_mem_type_5_p2 ;
  struct ttm_buffer_object *var_group4 ;
  struct ttm_placement *var_group5 ;
  struct file *var_group6 ;
  void *var_vmw_sync_obj_signaled_14_p0 ;
  void *var_vmw_sync_obj_signaled_14_p1 ;
  void *var_vmw_sync_obj_wait_15_p0 ;
  void *var_vmw_sync_obj_wait_15_p1 ;
  bool var_vmw_sync_obj_wait_15_p2 ;
  bool var_vmw_sync_obj_wait_15_p3 ;
  void *var_vmw_sync_obj_flush_13_p0 ;
  void *var_vmw_sync_obj_flush_13_p1 ;
  void **var_vmw_sync_obj_unref_12_p0 ;
  void *var_vmw_sync_obj_ref_11_p0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 469
  LDV_IN_INTERRUPT = 1;
#line 478
  ldv_initialize();
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 484
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 484
    if (tmp___8) {

    } else {
#line 484
      goto while_break;
    }
    {
#line 487
    tmp___7 = __VERIFIER_nondet_int();
    }
#line 489
    if (tmp___7 == 0) {
#line 489
      goto case_0;
    } else
#line 505
    if (tmp___7 == 1) {
#line 505
      goto case_1;
    } else
#line 521
    if (tmp___7 == 2) {
#line 521
      goto case_2;
    } else
#line 537
    if (tmp___7 == 3) {
#line 537
      goto case_3;
    } else
#line 553
    if (tmp___7 == 4) {
#line 553
      goto case_4;
    } else
#line 569
    if (tmp___7 == 5) {
#line 569
      goto case_5;
    } else
#line 585
    if (tmp___7 == 6) {
#line 585
      goto case_6;
    } else
#line 601
    if (tmp___7 == 7) {
#line 601
      goto case_7;
    } else
#line 617
    if (tmp___7 == 8) {
#line 617
      goto case_8;
    } else
#line 633
    if (tmp___7 == 9) {
#line 633
      goto case_9;
    } else
#line 649
    if (tmp___7 == 10) {
#line 649
      goto case_10;
    } else
#line 665
    if (tmp___7 == 11) {
#line 665
      goto case_11;
    } else {
      {
#line 681
      goto switch_default;
#line 487
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 497
        vmw_ttm_bind(var_group1, var_group2);
        }
#line 504
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 513
        vmw_ttm_unbind(var_group1);
        }
#line 520
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 529
        vmw_ttm_destroy(var_group1);
        }
#line 536
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 545
        vmw_invalidate_caches(var_group3, var_vmw_invalidate_caches_4_p1);
        }
#line 552
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 561
        vmw_init_mem_type(var_group3, var_vmw_init_mem_type_5_p1, var_vmw_init_mem_type_5_p2);
        }
#line 568
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 577
        vmw_evict_flags(var_group4, var_group5);
        }
#line 584
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 593
        vmw_verify_access(var_group4, var_group6);
        }
#line 600
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 609
        vmw_sync_obj_signaled(var_vmw_sync_obj_signaled_14_p0, var_vmw_sync_obj_signaled_14_p1);
        }
#line 616
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 625
        vmw_sync_obj_wait(var_vmw_sync_obj_wait_15_p0, var_vmw_sync_obj_wait_15_p1,
                          var_vmw_sync_obj_wait_15_p2, var_vmw_sync_obj_wait_15_p3);
        }
#line 632
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 641
        vmw_sync_obj_flush(var_vmw_sync_obj_flush_13_p0, var_vmw_sync_obj_flush_13_p1);
        }
#line 648
        goto switch_break;
        case_10: /* CIL Label */ 
        {
#line 657
        vmw_sync_obj_unref(var_vmw_sync_obj_unref_12_p0);
        }
#line 664
        goto switch_break;
        case_11: /* CIL Label */ 
        {
#line 673
        vmw_sync_obj_ref(var_vmw_sync_obj_ref_11_p0);
        }
#line 680
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 681
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 690
  ldv_check_final_state();
  }
#line 693
  return;
}
}
#line 315 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long  volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 315 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long  volatile   *addr ) 
{ int oldbit ;
  unsigned long *__cil_tmp4 ;

  {
#line 319
  __cil_tmp4 = (unsigned long *)addr;
#line 319
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*__cil_tmp4), "Ir" (nr));
#line 324
  return (oldbit);
}
}
#line 10 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/current.h"
extern struct task_struct *current_task  __attribute__((__section__(".data..percpu"))) ;
#line 12
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void)  __attribute__((__no_instrument_function__)) ;
#line 12 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/current.h"
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ struct task_struct *pfo_ret__ ;

  {
#line 14
  if ((int )8UL == 1) {
#line 14
    goto case_1;
  } else
#line 14
  if ((int )8UL == 2) {
#line 14
    goto case_2;
  } else
#line 14
  if ((int )8UL == 4) {
#line 14
    goto case_4;
  } else
#line 14
  if ((int )8UL == 8) {
#line 14
    goto case_8;
  } else {
    {
#line 14
    goto switch_default;
#line 14
    if (0) {
      case_1: /* CIL Label */ 
#line 14
      __asm__  ("mov"
                "b "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
      goto switch_break;
      case_2: /* CIL Label */ 
#line 14
      __asm__  ("mov"
                "w "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto switch_break;
      case_4: /* CIL Label */ 
#line 14
      __asm__  ("mov"
                "l "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto switch_break;
      case_8: /* CIL Label */ 
#line 14
      __asm__  ("mov"
                "q "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 14
      __bad_percpu_size();
      }
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
#line 14
  return (pfo_ret__);
}
}
#line 15 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 119 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 119 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;
  int __cil_tmp3 ;

  {
#line 123
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "decl %0; sete %1": "+m" (*((int *)v)), "=qm" (c): : "memory");
  {
#line 126
  __cil_tmp3 = (int )c;
#line 126
  return (__cil_tmp3 != 0);
  }
}
}
#line 173
__inline static int atomic_add_return(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 173 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __ret ;

  {
#line 182
  __ret = i;
#line 182
  if ((int )4UL == 1) {
#line 182
    goto case_1;
  } else
#line 182
  if ((int )4UL == 2) {
#line 182
    goto case_2;
  } else
#line 182
  if ((int )4UL == 4) {
#line 182
    goto case_4;
  } else
#line 182
  if ((int )4UL == 8) {
#line 182
    goto case_8;
  } else {
    {
#line 182
    goto switch_default;
#line 182
    if (0) {
      case_1: /* CIL Label */ 
#line 182
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "b %b0, %1\n": "+q" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
#line 182
      goto switch_break;
      case_2: /* CIL Label */ 
#line 182
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "w %w0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
#line 182
      goto switch_break;
      case_4: /* CIL Label */ 
#line 182
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "l %0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
#line 182
      goto switch_break;
      case_8: /* CIL Label */ 
#line 182
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "q %q0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
#line 182
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 182
      __xadd_wrong_size();
      }
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
#line 182
  return (i + __ret);
}
}
#line 82 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 82 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp___0 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  __u32 *__cil_tmp7 ;
  unsigned long *__cil_tmp8 ;
  unsigned long  volatile   *__cil_tmp9 ;

  {
  {
#line 84
  __cil_tmp5 = (unsigned long )ti;
#line 84
  __cil_tmp6 = __cil_tmp5 + 16;
#line 84
  __cil_tmp7 = (__u32 *)__cil_tmp6;
#line 84
  __cil_tmp8 = (unsigned long *)__cil_tmp7;
#line 84
  __cil_tmp9 = (unsigned long  volatile   *)__cil_tmp8;
#line 84
  tmp___0 = variable_test_bit(flag, __cil_tmp9);
  }
#line 84
  return (tmp___0);
}
}
#line 155 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
#line 584
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 586
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 589
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
#line 67 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore *sem , char    *name , struct lock_class_key *key ) ;
#line 90
extern void down_write(struct rw_semaphore *sem ) ;
#line 105
extern void up_write(struct rw_semaphore *sem ) ;
#line 82 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
#line 214 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void    *src , size_t count )  __attribute__((__no_instrument_function__)) ;
#line 214 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void    *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void *__cil_tmp6 ;

  {
  {
#line 217
  __len = count;
#line 217
  __cil_tmp6 = (void *)dst;
#line 217
  __ret = __builtin_memcpy(__cil_tmp6, src, __len);
  }
#line 218
  return;
}
}
#line 358 "include/linux/sched.h"
extern long schedule_timeout(long timeout ) ;
#line 2563
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2563 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  struct thread_info *__cil_tmp7 ;

  {
  {
#line 2565
  __cil_tmp4 = (unsigned long )tsk;
#line 2565
  __cil_tmp5 = __cil_tmp4 + 8;
#line 2565
  __cil_tmp6 = *((void **)__cil_tmp5);
#line 2565
  __cil_tmp7 = (struct thread_info *)__cil_tmp6;
#line 2565
  tmp___7 = test_ti_thread_flag(__cil_tmp7, flag);
  }
#line 2565
  return (tmp___7);
}
}
#line 2589
__inline static int signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2589 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long __cil_tmp5 ;

  {
  {
#line 2591
  tmp___7 = test_tsk_thread_flag(p, 2);
  }
#line 2591
  if (tmp___7) {
#line 2591
    tmp___8 = 1;
  } else {
#line 2591
    tmp___8 = 0;
  }
  {
#line 2591
  __cil_tmp5 = (long )tmp___8;
#line 2591
  tmp___9 = ldv__builtin_expect(__cil_tmp5, 0L);
  }
#line 2591
  return ((int )tmp___9);
}
}
#line 589 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) ;
#line 590
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) ;
#line 591
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) ;
#line 32 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t fifo_min ;
  uint32_t hwversion ;
  struct vmw_fifo_state    *fifo ;
  int tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_fifo_state *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned int    __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t    __cil_tmp24 ;
  __le32 *__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_screen_object_display *__cil_tmp29 ;

  {
#line 34
  __cil_tmp7 = (unsigned long )dev_priv;
#line 34
  __cil_tmp8 = __cil_tmp7 + 2144;
#line 34
  fifo_mem = *((__le32 **)__cil_tmp8);
#line 36
  __cil_tmp9 = (unsigned long )dev_priv;
#line 36
  __cil_tmp10 = __cil_tmp9 + 1856;
#line 36
  __cil_tmp11 = (struct vmw_fifo_state *)__cil_tmp10;
#line 36
  fifo = (struct vmw_fifo_state    *)__cil_tmp11;
  {
#line 38
  __cil_tmp12 = (unsigned long )dev_priv;
#line 38
  __cil_tmp13 = __cil_tmp12 + 2156;
#line 38
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
#line 38
  __cil_tmp15 = __cil_tmp14 & 32768U;
#line 38
  if (! __cil_tmp15) {
#line 39
    return ((bool )0);
  } else {

  }
  }
  {
#line 41
  __cil_tmp16 = fifo_mem + 0;
#line 41
  __cil_tmp17 = (void *)__cil_tmp16;
#line 41
  fifo_min = ioread32(__cil_tmp17);
  }
  {
#line 42
  __cil_tmp18 = 7UL * 4UL;
#line 42
  __cil_tmp19 = (unsigned long )fifo_min;
#line 42
  if (__cil_tmp19 <= __cil_tmp18) {
#line 43
    return ((bool )0);
  } else {

  }
  }
  {
#line 45
  __cil_tmp20 = 1 << 8;
#line 45
  __cil_tmp21 = (unsigned int    )__cil_tmp20;
#line 45
  __cil_tmp22 = (unsigned long )fifo;
#line 45
  __cil_tmp23 = __cil_tmp22 + 36;
#line 45
  __cil_tmp24 = *((uint32_t    *)__cil_tmp23);
#line 45
  if (__cil_tmp24 & __cil_tmp21) {
#line 45
    tmp___7 = 17;
  } else {
#line 45
    tmp___7 = 7;
  }
  }
  {
#line 45
  __cil_tmp25 = fifo_mem + tmp___7;
#line 45
  __cil_tmp26 = (void *)__cil_tmp25;
#line 45
  hwversion = ioread32(__cil_tmp26);
  }
#line 51
  if (hwversion == 0U) {
#line 52
    return ((bool )0);
  } else {

  }
#line 54
  if (hwversion < 131073U) {
#line 55
    return ((bool )0);
  } else {

  }
  {
#line 58
  __cil_tmp27 = (unsigned long )dev_priv;
#line 58
  __cil_tmp28 = __cil_tmp27 + 2616;
#line 58
  __cil_tmp29 = *((struct vmw_screen_object_display **)__cil_tmp28);
#line 58
  if (! __cil_tmp29) {
#line 59
    return ((bool )0);
  } else {

  }
  }
#line 61
  return ((bool )1);
}
}
#line 64 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t caps ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  __le32 *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 66
  __cil_tmp4 = (unsigned long )dev_priv;
#line 66
  __cil_tmp5 = __cil_tmp4 + 2144;
#line 66
  fifo_mem = *((__le32 **)__cil_tmp5);
  {
#line 69
  __cil_tmp6 = (unsigned long )dev_priv;
#line 69
  __cil_tmp7 = __cil_tmp6 + 2156;
#line 69
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
#line 69
  __cil_tmp9 = __cil_tmp8 & 32768U;
#line 69
  if (! __cil_tmp9) {
#line 70
    return ((bool )0);
  } else {

  }
  }
  {
#line 72
  __cil_tmp10 = fifo_mem + 4;
#line 72
  __cil_tmp11 = (void *)__cil_tmp10;
#line 72
  caps = ioread32(__cil_tmp11);
  }
  {
#line 73
  __cil_tmp12 = 1 << 2;
#line 73
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 73
  if (caps & __cil_tmp13) {
#line 74
    return ((bool )1);
  } else {

  }
  }
#line 76
  return ((bool )0);
}
}
#line 95 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static struct lock_class_key __key___13  ;
#line 96 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static struct lock_class_key __key___14  ;
#line 79 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t dummy ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  int tmp___12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  __le32 *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct mutex *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct rw_semaphore *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct mutex *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  __le32 *__cil_tmp59 ;
  void *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint32_t __cil_tmp63 ;
  __le32 *__cil_tmp64 ;
  void *__cil_tmp65 ;
  __le32 *__cil_tmp66 ;
  void *__cil_tmp67 ;
  __le32 *__cil_tmp68 ;
  void *__cil_tmp69 ;
  u32 __cil_tmp70 ;
  __le32 *__cil_tmp71 ;
  void *__cil_tmp72 ;
  uint32_t __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct mutex *__cil_tmp76 ;
  __le32 *__cil_tmp77 ;
  void *__cil_tmp78 ;
  __le32 *__cil_tmp79 ;
  void *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  __le32 *__cil_tmp83 ;
  void *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  atomic_t *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  uint32_t __cil_tmp93 ;
  int __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  __le32 *__cil_tmp98 ;
  void *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct vmw_marker_queue *__cil_tmp102 ;

  {
  {
#line 81
  __cil_tmp13 = (unsigned long )dev_priv;
#line 81
  __cil_tmp14 = __cil_tmp13 + 2144;
#line 81
  fifo_mem = *((__le32 **)__cil_tmp14);
#line 86
  __cil_tmp15 = (unsigned long )fifo;
#line 86
  __cil_tmp16 = __cil_tmp15 + 24;
#line 86
  *((unsigned long *)__cil_tmp16) = 1048576UL;
#line 87
  __cil_tmp17 = (unsigned long )fifo;
#line 87
  __cil_tmp18 = __cil_tmp17 + 24;
#line 87
  __cil_tmp19 = *((unsigned long *)__cil_tmp18);
#line 87
  tmp___7 = vmalloc(__cil_tmp19);
#line 87
  __cil_tmp20 = (unsigned long )fifo;
#line 87
  __cil_tmp21 = __cil_tmp20 + 16;
#line 87
  *((__le32 **)__cil_tmp21) = (__le32 *)tmp___7;
#line 88
  __cil_tmp22 = (void *)0;
#line 88
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 88
  __cil_tmp24 = (unsigned long )fifo;
#line 88
  __cil_tmp25 = __cil_tmp24 + 16;
#line 88
  __cil_tmp26 = *((__le32 **)__cil_tmp25);
#line 88
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 88
  __cil_tmp28 = __cil_tmp27 == __cil_tmp23;
#line 88
  __cil_tmp29 = ! __cil_tmp28;
#line 88
  __cil_tmp30 = ! __cil_tmp29;
#line 88
  __cil_tmp31 = (long )__cil_tmp30;
#line 88
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  }
#line 88
  if (tmp___8) {
#line 89
    return (-12);
  } else {

  }
#line 91
  __cil_tmp32 = (unsigned long )fifo;
#line 91
  __cil_tmp33 = __cil_tmp32 + 8;
#line 91
  __cil_tmp34 = (void *)0;
#line 91
  *((__le32 **)__cil_tmp33) = (__le32 *)__cil_tmp34;
#line 92
  *((unsigned long *)fifo) = 0UL;
#line 93
  __cil_tmp35 = (unsigned long )fifo;
#line 93
  __cil_tmp36 = __cil_tmp35 + 32;
#line 93
  *((bool *)__cil_tmp36) = (bool )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    __cil_tmp37 = (unsigned long )fifo;
#line 95
    __cil_tmp38 = __cil_tmp37 + 40;
#line 95
    __cil_tmp39 = (struct mutex *)__cil_tmp38;
#line 95
    __mutex_init(__cil_tmp39, "&fifo->fifo_mutex", & __key___13);
    }
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 96
    __cil_tmp40 = (unsigned long )fifo;
#line 96
    __cil_tmp41 = __cil_tmp40 + 112;
#line 96
    __cil_tmp42 = (struct rw_semaphore *)__cil_tmp41;
#line 96
    __init_rwsem(__cil_tmp42, "&fifo->rwsem", & __key___14);
    }
#line 96
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 102
  tmp___9 = vmw_read(dev_priv, 2U);
#line 102
  printk("<6>[drm] width %d\n", tmp___9);
#line 103
  tmp___10 = vmw_read(dev_priv, 3U);
#line 103
  printk("<6>[drm] height %d\n", tmp___10);
#line 104
  tmp___11 = vmw_read(dev_priv, 7U);
#line 104
  printk("<6>[drm] bpp %d\n", tmp___11);
#line 106
  __cil_tmp43 = (unsigned long )dev_priv;
#line 106
  __cil_tmp44 = __cil_tmp43 + 2184;
#line 106
  __cil_tmp45 = (struct mutex *)__cil_tmp44;
#line 106
  mutex_lock(__cil_tmp45);
#line 107
  __cil_tmp46 = (unsigned long )dev_priv;
#line 107
  __cil_tmp47 = __cil_tmp46 + 3024;
#line 107
  *((uint32_t *)__cil_tmp47) = vmw_read(dev_priv, 1U);
#line 108
  __cil_tmp48 = (unsigned long )dev_priv;
#line 108
  __cil_tmp49 = __cil_tmp48 + 3028;
#line 108
  *((uint32_t *)__cil_tmp49) = vmw_read(dev_priv, 20U);
#line 109
  __cil_tmp50 = (unsigned long )dev_priv;
#line 109
  __cil_tmp51 = __cil_tmp50 + 3020;
#line 109
  *((uint32_t *)__cil_tmp51) = vmw_read(dev_priv, 45U);
#line 110
  __cil_tmp52 = (uint32_t )1;
#line 110
  vmw_write(dev_priv, 1U, __cil_tmp52);
#line 112
  min = (uint32_t )4;
  }
  {
#line 113
  __cil_tmp53 = (unsigned long )dev_priv;
#line 113
  __cil_tmp54 = __cil_tmp53 + 2156;
#line 113
  __cil_tmp55 = *((uint32_t *)__cil_tmp54);
#line 113
  if (__cil_tmp55 & 32768U) {
    {
#line 114
    min = vmw_read(dev_priv, 30U);
    }
  } else {

  }
  }
#line 115
  min = min << 2;
  {
#line 117
  __cil_tmp56 = 1UL << 12;
#line 117
  __cil_tmp57 = (unsigned long )min;
#line 117
  if (__cil_tmp57 < __cil_tmp56) {
#line 118
    __cil_tmp58 = 1UL << 12;
#line 118
    min = (uint32_t )__cil_tmp58;
  } else {

  }
  }
  {
#line 120
  __cil_tmp59 = fifo_mem + 0;
#line 120
  __cil_tmp60 = (void *)__cil_tmp59;
#line 120
  iowrite32(min, __cil_tmp60);
#line 121
  __cil_tmp61 = (unsigned long )dev_priv;
#line 121
  __cil_tmp62 = __cil_tmp61 + 2120;
#line 121
  __cil_tmp63 = *((uint32_t *)__cil_tmp62);
#line 121
  __cil_tmp64 = fifo_mem + 1;
#line 121
  __cil_tmp65 = (void *)__cil_tmp64;
#line 121
  iowrite32(__cil_tmp63, __cil_tmp65);
#line 122
  __asm__  volatile   ("sfence": : : "memory");
#line 123
  __cil_tmp66 = fifo_mem + 2;
#line 123
  __cil_tmp67 = (void *)__cil_tmp66;
#line 123
  iowrite32(min, __cil_tmp67);
#line 124
  __cil_tmp68 = fifo_mem + 3;
#line 124
  __cil_tmp69 = (void *)__cil_tmp68;
#line 124
  iowrite32(min, __cil_tmp69);
#line 125
  __cil_tmp70 = (u32 )0;
#line 125
  __cil_tmp71 = fifo_mem + 290;
#line 125
  __cil_tmp72 = (void *)__cil_tmp71;
#line 125
  iowrite32(__cil_tmp70, __cil_tmp72);
#line 126
  __asm__  volatile   ("mfence": : : "memory");
#line 128
  __cil_tmp73 = (uint32_t )1;
#line 128
  vmw_write(dev_priv, 20U, __cil_tmp73);
#line 129
  __cil_tmp74 = (unsigned long )dev_priv;
#line 129
  __cil_tmp75 = __cil_tmp74 + 2184;
#line 129
  __cil_tmp76 = (struct mutex *)__cil_tmp75;
#line 129
  mutex_unlock(__cil_tmp76);
#line 131
  __cil_tmp77 = fifo_mem + 1;
#line 131
  __cil_tmp78 = (void *)__cil_tmp77;
#line 131
  max = ioread32(__cil_tmp78);
#line 132
  __cil_tmp79 = fifo_mem + 0;
#line 132
  __cil_tmp80 = (void *)__cil_tmp79;
#line 132
  min = ioread32(__cil_tmp80);
#line 133
  __cil_tmp81 = (unsigned long )fifo;
#line 133
  __cil_tmp82 = __cil_tmp81 + 36;
#line 133
  __cil_tmp83 = fifo_mem + 4;
#line 133
  __cil_tmp84 = (void *)__cil_tmp83;
#line 133
  *((uint32_t *)__cil_tmp82) = ioread32(__cil_tmp84);
#line 135
  __cil_tmp85 = (unsigned long )fifo;
#line 135
  __cil_tmp86 = __cil_tmp85 + 36;
#line 135
  __cil_tmp87 = *((uint32_t *)__cil_tmp86);
#line 135
  printk("<6>[drm] Fifo max 0x%08x min 0x%08x cap 0x%08x\n", max, min, __cil_tmp87);
#line 140
  __cil_tmp88 = (unsigned long )dev_priv;
#line 140
  __cil_tmp89 = __cil_tmp88 + 2880;
#line 140
  __cil_tmp90 = (atomic_t *)__cil_tmp89;
#line 140
  __cil_tmp91 = (unsigned long )dev_priv;
#line 140
  __cil_tmp92 = __cil_tmp91 + 2980;
#line 140
  __cil_tmp93 = *((uint32_t *)__cil_tmp92);
#line 140
  __cil_tmp94 = (int )__cil_tmp93;
#line 140
  atomic_set(__cil_tmp90, __cil_tmp94);
#line 141
  __cil_tmp95 = (unsigned long )dev_priv;
#line 141
  __cil_tmp96 = __cil_tmp95 + 2980;
#line 141
  __cil_tmp97 = *((uint32_t *)__cil_tmp96);
#line 141
  __cil_tmp98 = fifo_mem + 6;
#line 141
  __cil_tmp99 = (void *)__cil_tmp98;
#line 141
  iowrite32(__cil_tmp97, __cil_tmp99);
#line 142
  __cil_tmp100 = (unsigned long )fifo;
#line 142
  __cil_tmp101 = __cil_tmp100 + 160;
#line 142
  __cil_tmp102 = (struct vmw_marker_queue *)__cil_tmp101;
#line 142
  vmw_marker_queue_init(__cil_tmp102);
#line 143
  tmp___12 = vmw_fifo_send_fence(dev_priv, & dummy);
  }
#line 143
  return (tmp___12);
}
}
#line 146 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) 
{ __le32 *fifo_mem ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  __le32 *__cil_tmp12 ;
  void *__cil_tmp13 ;
  long __cil_tmp14 ;
  u32 __cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct mutex *__cil_tmp20 ;

  {
  {
#line 148
  __cil_tmp7 = (unsigned long )dev_priv;
#line 148
  __cil_tmp8 = __cil_tmp7 + 2144;
#line 148
  fifo_mem = *((__le32 **)__cil_tmp8);
#line 150
  __cil_tmp9 = (unsigned long )dev_priv;
#line 150
  __cil_tmp10 = __cil_tmp9 + 2184;
#line 150
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
#line 150
  mutex_lock(__cil_tmp11);
#line 152
  __cil_tmp12 = fifo_mem + 290;
#line 152
  __cil_tmp13 = (void *)__cil_tmp12;
#line 152
  tmp___7 = ioread32(__cil_tmp13);
  }
#line 152
  if (tmp___7 == 0U) {
#line 152
    tmp___8 = 1;
  } else {
#line 152
    tmp___8 = 0;
  }
  {
#line 152
  __cil_tmp14 = (long )tmp___8;
#line 152
  tmp___9 = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 152
  if (tmp___9) {
    {
#line 153
    __cil_tmp15 = (u32 )1;
#line 153
    __cil_tmp16 = fifo_mem + 290;
#line 153
    __cil_tmp17 = (void *)__cil_tmp16;
#line 153
    iowrite32(__cil_tmp15, __cil_tmp17);
#line 154
    vmw_write(dev_priv, 21U, reason);
    }
  } else {

  }
  {
#line 157
  __cil_tmp18 = (unsigned long )dev_priv;
#line 157
  __cil_tmp19 = __cil_tmp18 + 2184;
#line 157
  __cil_tmp20 = (struct mutex *)__cil_tmp19;
#line 157
  mutex_unlock(__cil_tmp20);
  }
#line 158
  return;
}
}
#line 160 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct mutex *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_marker_queue *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  __le32 *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  __le32 *__cil_tmp44 ;
  void    *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  __le32 *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void    *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  void *__cil_tmp65 ;

  {
  {
#line 162
  __cil_tmp7 = (unsigned long )dev_priv;
#line 162
  __cil_tmp8 = __cil_tmp7 + 2144;
#line 162
  fifo_mem = *((__le32 **)__cil_tmp8);
#line 164
  __cil_tmp9 = (unsigned long )dev_priv;
#line 164
  __cil_tmp10 = __cil_tmp9 + 2184;
#line 164
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
#line 164
  mutex_lock(__cil_tmp11);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    tmp___7 = vmw_read(dev_priv, 22U);
    }
#line 166
    if (tmp___7 != 0U) {

    } else {
#line 166
      goto while_break;
    }
    {
#line 167
    __cil_tmp12 = (uint32_t )1;
#line 167
    vmw_write(dev_priv, 21U, __cil_tmp12);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  __cil_tmp13 = (unsigned long )dev_priv;
#line 169
  __cil_tmp14 = __cil_tmp13 + 2980;
#line 169
  __cil_tmp15 = fifo_mem + 6;
#line 169
  __cil_tmp16 = (void *)__cil_tmp15;
#line 169
  *((uint32_t *)__cil_tmp14) = ioread32(__cil_tmp16);
#line 171
  __cil_tmp17 = (unsigned long )dev_priv;
#line 171
  __cil_tmp18 = __cil_tmp17 + 3028;
#line 171
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 171
  vmw_write(dev_priv, 20U, __cil_tmp19);
#line 173
  __cil_tmp20 = (unsigned long )dev_priv;
#line 173
  __cil_tmp21 = __cil_tmp20 + 3024;
#line 173
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 173
  vmw_write(dev_priv, 1U, __cil_tmp22);
#line 175
  __cil_tmp23 = (unsigned long )dev_priv;
#line 175
  __cil_tmp24 = __cil_tmp23 + 3020;
#line 175
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
#line 175
  vmw_write(dev_priv, 45U, __cil_tmp25);
#line 178
  __cil_tmp26 = (unsigned long )dev_priv;
#line 178
  __cil_tmp27 = __cil_tmp26 + 2184;
#line 178
  __cil_tmp28 = (struct mutex *)__cil_tmp27;
#line 178
  mutex_unlock(__cil_tmp28);
#line 179
  __cil_tmp29 = (unsigned long )fifo;
#line 179
  __cil_tmp30 = __cil_tmp29 + 160;
#line 179
  __cil_tmp31 = (struct vmw_marker_queue *)__cil_tmp30;
#line 179
  vmw_marker_queue_takedown(__cil_tmp31);
#line 181
  __cil_tmp32 = (void *)0;
#line 181
  __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 181
  __cil_tmp34 = (unsigned long )fifo;
#line 181
  __cil_tmp35 = __cil_tmp34 + 16;
#line 181
  __cil_tmp36 = *((__le32 **)__cil_tmp35);
#line 181
  __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 181
  __cil_tmp38 = __cil_tmp37 != __cil_tmp33;
#line 181
  __cil_tmp39 = ! __cil_tmp38;
#line 181
  __cil_tmp40 = ! __cil_tmp39;
#line 181
  __cil_tmp41 = (long )__cil_tmp40;
#line 181
  tmp___8 = ldv__builtin_expect(__cil_tmp41, 1L);
  }
#line 181
  if (tmp___8) {
    {
#line 182
    __cil_tmp42 = (unsigned long )fifo;
#line 182
    __cil_tmp43 = __cil_tmp42 + 16;
#line 182
    __cil_tmp44 = *((__le32 **)__cil_tmp43);
#line 182
    __cil_tmp45 = (void    *)__cil_tmp44;
#line 182
    vfree(__cil_tmp45);
#line 183
    __cil_tmp46 = (unsigned long )fifo;
#line 183
    __cil_tmp47 = __cil_tmp46 + 16;
#line 183
    __cil_tmp48 = (void *)0;
#line 183
    *((__le32 **)__cil_tmp47) = (__le32 *)__cil_tmp48;
    }
  } else {

  }
  {
#line 186
  __cil_tmp49 = (void *)0;
#line 186
  __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 186
  __cil_tmp51 = (unsigned long )fifo;
#line 186
  __cil_tmp52 = __cil_tmp51 + 8;
#line 186
  __cil_tmp53 = *((__le32 **)__cil_tmp52);
#line 186
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 186
  __cil_tmp55 = __cil_tmp54 != __cil_tmp50;
#line 186
  __cil_tmp56 = ! __cil_tmp55;
#line 186
  __cil_tmp57 = ! __cil_tmp56;
#line 186
  __cil_tmp58 = (long )__cil_tmp57;
#line 186
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 1L);
  }
#line 186
  if (tmp___9) {
    {
#line 187
    __cil_tmp59 = (unsigned long )fifo;
#line 187
    __cil_tmp60 = __cil_tmp59 + 8;
#line 187
    __cil_tmp61 = *((__le32 **)__cil_tmp60);
#line 187
    __cil_tmp62 = (void    *)__cil_tmp61;
#line 187
    vfree(__cil_tmp62);
#line 188
    __cil_tmp63 = (unsigned long )fifo;
#line 188
    __cil_tmp64 = __cil_tmp63 + 8;
#line 188
    __cil_tmp65 = (void *)0;
#line 188
    *((__le32 **)__cil_tmp64) = (__le32 *)__cil_tmp65;
    }
  } else {

  }
#line 190
  return;
}
}
#line 192 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static bool vmw_fifo_is_full(struct vmw_private *dev_priv , uint32_t bytes ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  unsigned int tmp___7 ;
  uint32_t next_cmd ;
  unsigned int tmp___8 ;
  uint32_t min ;
  unsigned int tmp___9 ;
  uint32_t stop ;
  unsigned int tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  __le32 *__cil_tmp14 ;
  void *__cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  __le32 *__cil_tmp18 ;
  void *__cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  void *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  {
#line 194
  __cil_tmp12 = (unsigned long )dev_priv;
#line 194
  __cil_tmp13 = __cil_tmp12 + 2144;
#line 194
  fifo_mem = *((__le32 **)__cil_tmp13);
#line 195
  __cil_tmp14 = fifo_mem + 1;
#line 195
  __cil_tmp15 = (void *)__cil_tmp14;
#line 195
  tmp___7 = ioread32(__cil_tmp15);
#line 195
  max = tmp___7;
#line 196
  __cil_tmp16 = fifo_mem + 2;
#line 196
  __cil_tmp17 = (void *)__cil_tmp16;
#line 196
  tmp___8 = ioread32(__cil_tmp17);
#line 196
  next_cmd = tmp___8;
#line 197
  __cil_tmp18 = fifo_mem + 0;
#line 197
  __cil_tmp19 = (void *)__cil_tmp18;
#line 197
  tmp___9 = ioread32(__cil_tmp19);
#line 197
  min = tmp___9;
#line 198
  __cil_tmp20 = fifo_mem + 3;
#line 198
  __cil_tmp21 = (void *)__cil_tmp20;
#line 198
  tmp___10 = ioread32(__cil_tmp21);
#line 198
  stop = tmp___10;
  }
  {
#line 200
  __cil_tmp22 = stop - min;
#line 200
  __cil_tmp23 = max - next_cmd;
#line 200
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 200
  __cil_tmp25 = __cil_tmp24 <= bytes;
#line 200
  return ((bool )__cil_tmp25);
  }
}
}
#line 203 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                               unsigned long timeout ) 
{ int ret ;
  unsigned long end_jiffies ;
  wait_queue_t __wait ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  struct task_struct *tmp___10 ;
  int tmp___11 ;
  unsigned long volatile   __cil_tmp17 ;
  unsigned long volatile   __cil_tmp18 ;
  wait_queue_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  wait_queue_head_t *__cil_tmp29 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  wait_queue_head_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  wait_queue_head_t *__cil_tmp38 ;
  void *__cil_tmp39 ;

  {
  {
#line 207
  ret = 0;
#line 208
  __cil_tmp17 = (unsigned long volatile   )timeout;
#line 208
  __cil_tmp18 = jiffies + __cil_tmp17;
#line 208
  end_jiffies = (unsigned long )__cil_tmp18;
#line 209
  tmp___7 = get_current();
#line 209
  __cil_tmp19 = & __wait;
#line 209
  *((unsigned int *)__cil_tmp19) = 0U;
#line 209
  __cil_tmp20 = (unsigned long )(& __wait) + 8;
#line 209
  *((void **)__cil_tmp20) = (void *)tmp___7;
#line 209
  __cil_tmp21 = (unsigned long )(& __wait) + 16;
#line 209
  *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp21) = & autoremove_wake_function;
#line 209
  __cil_tmp22 = (unsigned long )(& __wait) + 24;
#line 209
  __cil_tmp23 = (unsigned long )(& __wait) + 24;
#line 209
  *((struct list_head **)__cil_tmp22) = (struct list_head *)__cil_tmp23;
#line 209
  __cil_tmp24 = 24 + 8;
#line 209
  __cil_tmp25 = (unsigned long )(& __wait) + __cil_tmp24;
#line 209
  __cil_tmp26 = (unsigned long )(& __wait) + 24;
#line 209
  *((struct list_head **)__cil_tmp25) = (struct list_head *)__cil_tmp26;
#line 211
  printk("<6>[drm] Fifo wait noirq.\n");
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (interruptible) {
#line 214
      tmp___8 = 1;
    } else {
#line 214
      tmp___8 = 2;
    }
    {
#line 214
    __cil_tmp27 = (unsigned long )dev_priv;
#line 214
    __cil_tmp28 = __cil_tmp27 + 2928;
#line 214
    __cil_tmp29 = (wait_queue_head_t *)__cil_tmp28;
#line 214
    prepare_to_wait(__cil_tmp29, & __wait, tmp___8);
#line 217
    tmp___9 = vmw_fifo_is_full(dev_priv, bytes);
    }
#line 217
    if (tmp___9) {

    } else {
#line 218
      goto while_break;
    }
    {
#line 219
    __cil_tmp30 = (long )end_jiffies;
#line 219
    __cil_tmp31 = (long )jiffies;
#line 219
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 219
    if (__cil_tmp32 >= 0L) {
      {
#line 220
      ret = -16;
#line 221
      drm_err("vmw_fifo_wait_noirq", "SVGA device lockup.\n");
      }
#line 222
      goto while_break;
    } else {

    }
    }
    {
#line 224
    schedule_timeout(1L);
    }
#line 225
    if (interruptible) {
      {
#line 225
      tmp___10 = get_current();
#line 225
      tmp___11 = signal_pending(tmp___10);
      }
#line 225
      if (tmp___11) {
#line 226
        ret = -512;
#line 227
        goto while_break;
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  __cil_tmp33 = (unsigned long )dev_priv;
#line 230
  __cil_tmp34 = __cil_tmp33 + 2928;
#line 230
  __cil_tmp35 = (wait_queue_head_t *)__cil_tmp34;
#line 230
  finish_wait(__cil_tmp35, & __wait);
#line 231
  __cil_tmp36 = (unsigned long )dev_priv;
#line 231
  __cil_tmp37 = __cil_tmp36 + 2928;
#line 231
  __cil_tmp38 = (wait_queue_head_t *)__cil_tmp37;
#line 231
  __cil_tmp39 = (void *)0;
#line 231
  __wake_up(__cil_tmp38, 3U, 0, __cil_tmp39);
#line 232
  printk("<6>[drm] Fifo noirq exit.\n");
  }
#line 233
  return (ret);
}
}
#line 236 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static int vmw_fifo_wait(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                         unsigned long timeout ) 
{ long ret ;
  unsigned long irq_flags ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  raw_spinlock_t *tmp___11 ;
  int tmp___12 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___13 ;
  bool tmp___14 ;
  struct task_struct *tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  raw_spinlock_t *tmp___23 ;
  int tmp___24 ;
  long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct mutex *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  atomic_t *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  spinlock_t *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32_t __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  spinlock_t *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct mutex *__cil_tmp66 ;
  wait_queue_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  wait_queue_head_t *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  wait_queue_head_t *__cil_tmp80 ;
  wait_queue_t *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  wait_queue_head_t *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  wait_queue_head_t *__cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  long __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  struct mutex *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  atomic_t *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  spinlock_t *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  uint32_t __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  uint32_t __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  spinlock_t *__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  struct mutex *__cil_tmp125 ;

  {
  {
#line 240
  ret = 1L;
#line 243
  tmp___7 = vmw_fifo_is_full(dev_priv, bytes);
  }
#line 243
  if (tmp___7) {
#line 243
    tmp___8 = 0;
  } else {
#line 243
    tmp___8 = 1;
  }
  {
#line 243
  __cil_tmp33 = (long )tmp___8;
#line 243
  tmp___9 = ldv__builtin_expect(__cil_tmp33, 1L);
  }
#line 243
  if (tmp___9) {
#line 244
    return (0);
  } else {

  }
  {
#line 246
  __cil_tmp34 = (uint32_t )2;
#line 246
  vmw_fifo_ping_host(dev_priv, __cil_tmp34);
  }
  {
#line 247
  __cil_tmp35 = (unsigned long )dev_priv;
#line 247
  __cil_tmp36 = __cil_tmp35 + 2156;
#line 247
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 247
  __cil_tmp38 = __cil_tmp37 & 262144U;
#line 247
  if (! __cil_tmp38) {
    {
#line 248
    tmp___10 = vmw_fifo_wait_noirq(dev_priv, bytes, interruptible, timeout);
    }
#line 248
    return (tmp___10);
  } else {

  }
  }
  {
#line 251
  __cil_tmp39 = (unsigned long )dev_priv;
#line 251
  __cil_tmp40 = __cil_tmp39 + 2184;
#line 251
  __cil_tmp41 = (struct mutex *)__cil_tmp40;
#line 251
  mutex_lock(__cil_tmp41);
#line 252
  __cil_tmp42 = (unsigned long )dev_priv;
#line 252
  __cil_tmp43 = __cil_tmp42 + 2976;
#line 252
  __cil_tmp44 = (atomic_t *)__cil_tmp43;
#line 252
  tmp___12 = atomic_add_return(1, __cil_tmp44);
  }
#line 252
  if (tmp___12 > 0) {
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 253
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 253
        __cil_tmp45 = (unsigned long )dev_priv;
#line 253
        __cil_tmp46 = __cil_tmp45 + 2984;
#line 253
        __cil_tmp47 = (spinlock_t *)__cil_tmp46;
#line 253
        tmp___11 = spinlock_check(__cil_tmp47);
#line 253
        irq_flags = _raw_spin_lock_irqsave(tmp___11);
        }
#line 253
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 253
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 254
    __cil_tmp48 = (unsigned long )dev_priv;
#line 254
    __cil_tmp49 = __cil_tmp48 + 2104;
#line 254
    __cil_tmp50 = *((unsigned int *)__cil_tmp49);
#line 254
    __cil_tmp51 = __cil_tmp50 + 8U;
#line 254
    __cil_tmp52 = (int )__cil_tmp51;
#line 254
    outl(2U, __cil_tmp52);
#line 256
    __cil_tmp53 = (unsigned long )dev_priv;
#line 256
    __cil_tmp54 = __cil_tmp53 + 3016;
#line 256
    __cil_tmp55 = (unsigned long )dev_priv;
#line 256
    __cil_tmp56 = __cil_tmp55 + 3016;
#line 256
    __cil_tmp57 = *((uint32_t *)__cil_tmp56);
#line 256
    *((uint32_t *)__cil_tmp54) = __cil_tmp57 | 2U;
#line 257
    __cil_tmp58 = (unsigned long )dev_priv;
#line 257
    __cil_tmp59 = __cil_tmp58 + 3016;
#line 257
    __cil_tmp60 = *((uint32_t *)__cil_tmp59);
#line 257
    vmw_write(dev_priv, 33U, __cil_tmp60);
#line 258
    __cil_tmp61 = (unsigned long )dev_priv;
#line 258
    __cil_tmp62 = __cil_tmp61 + 2984;
#line 258
    __cil_tmp63 = (spinlock_t *)__cil_tmp62;
#line 258
    spin_unlock_irqrestore(__cil_tmp63, irq_flags);
    }
  } else {

  }
  {
#line 260
  __cil_tmp64 = (unsigned long )dev_priv;
#line 260
  __cil_tmp65 = __cil_tmp64 + 2184;
#line 260
  __cil_tmp66 = (struct mutex *)__cil_tmp65;
#line 260
  mutex_unlock(__cil_tmp66);
  }
#line 262
  if (interruptible) {
    {
#line 263
    __ret = (long )timeout;
#line 263
    tmp___17 = vmw_fifo_is_full(dev_priv, bytes);
    }
#line 263
    if (tmp___17) {
      {
#line 263
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 263
        tmp___13 = get_current();
#line 263
        __cil_tmp67 = & __wait;
#line 263
        *((unsigned int *)__cil_tmp67) = 0U;
#line 263
        __cil_tmp68 = (unsigned long )(& __wait) + 8;
#line 263
        *((void **)__cil_tmp68) = (void *)tmp___13;
#line 263
        __cil_tmp69 = (unsigned long )(& __wait) + 16;
#line 263
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp69) = & autoremove_wake_function;
#line 263
        __cil_tmp70 = (unsigned long )(& __wait) + 24;
#line 263
        __cil_tmp71 = (unsigned long )(& __wait) + 24;
#line 263
        *((struct list_head **)__cil_tmp70) = (struct list_head *)__cil_tmp71;
#line 263
        __cil_tmp72 = 24 + 8;
#line 263
        __cil_tmp73 = (unsigned long )(& __wait) + __cil_tmp72;
#line 263
        __cil_tmp74 = (unsigned long )(& __wait) + 24;
#line 263
        *((struct list_head **)__cil_tmp73) = (struct list_head *)__cil_tmp74;
        }
        {
#line 263
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 263
          __cil_tmp75 = (unsigned long )dev_priv;
#line 263
          __cil_tmp76 = __cil_tmp75 + 2928;
#line 263
          __cil_tmp77 = (wait_queue_head_t *)__cil_tmp76;
#line 263
          prepare_to_wait(__cil_tmp77, & __wait, 1);
#line 263
          tmp___14 = vmw_fifo_is_full(dev_priv, bytes);
          }
#line 263
          if (tmp___14) {

          } else {
#line 263
            goto while_break___2;
          }
          {
#line 263
          tmp___15 = get_current();
#line 263
          tmp___16 = signal_pending(tmp___15);
          }
#line 263
          if (tmp___16) {

          } else {
            {
#line 263
            __ret = schedule_timeout(__ret);
            }
#line 263
            if (! __ret) {
#line 263
              goto while_break___2;
            } else {

            }
#line 263
            goto __Cont;
          }
#line 263
          __ret = -512L;
#line 263
          goto while_break___2;
          __Cont: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 263
        __cil_tmp78 = (unsigned long )dev_priv;
#line 263
        __cil_tmp79 = __cil_tmp78 + 2928;
#line 263
        __cil_tmp80 = (wait_queue_head_t *)__cil_tmp79;
#line 263
        finish_wait(__cil_tmp80, & __wait);
        }
#line 263
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 263
    ret = __ret;
  } else {
    {
#line 267
    __ret___0 = (long )timeout;
#line 267
    tmp___20 = vmw_fifo_is_full(dev_priv, bytes);
    }
#line 267
    if (tmp___20) {
      {
#line 267
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 267
        tmp___18 = get_current();
#line 267
        __cil_tmp81 = & __wait___0;
#line 267
        *((unsigned int *)__cil_tmp81) = 0U;
#line 267
        __cil_tmp82 = (unsigned long )(& __wait___0) + 8;
#line 267
        *((void **)__cil_tmp82) = (void *)tmp___18;
#line 267
        __cil_tmp83 = (unsigned long )(& __wait___0) + 16;
#line 267
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp83) = & autoremove_wake_function;
#line 267
        __cil_tmp84 = (unsigned long )(& __wait___0) + 24;
#line 267
        __cil_tmp85 = (unsigned long )(& __wait___0) + 24;
#line 267
        *((struct list_head **)__cil_tmp84) = (struct list_head *)__cil_tmp85;
#line 267
        __cil_tmp86 = 24 + 8;
#line 267
        __cil_tmp87 = (unsigned long )(& __wait___0) + __cil_tmp86;
#line 267
        __cil_tmp88 = (unsigned long )(& __wait___0) + 24;
#line 267
        *((struct list_head **)__cil_tmp87) = (struct list_head *)__cil_tmp88;
        }
        {
#line 267
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 267
          __cil_tmp89 = (unsigned long )dev_priv;
#line 267
          __cil_tmp90 = __cil_tmp89 + 2928;
#line 267
          __cil_tmp91 = (wait_queue_head_t *)__cil_tmp90;
#line 267
          prepare_to_wait(__cil_tmp91, & __wait___0, 2);
#line 267
          tmp___19 = vmw_fifo_is_full(dev_priv, bytes);
          }
#line 267
          if (tmp___19) {

          } else {
#line 267
            goto while_break___4;
          }
          {
#line 267
          __ret___0 = schedule_timeout(__ret___0);
          }
#line 267
          if (! __ret___0) {
#line 267
            goto while_break___4;
          } else {

          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 267
        __cil_tmp92 = (unsigned long )dev_priv;
#line 267
        __cil_tmp93 = __cil_tmp92 + 2928;
#line 267
        __cil_tmp94 = (wait_queue_head_t *)__cil_tmp93;
#line 267
        finish_wait(__cil_tmp94, & __wait___0);
        }
#line 267
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {

    }
#line 267
    ret = __ret___0;
  }
  {
#line 271
  __cil_tmp95 = ret == 0L;
#line 271
  __cil_tmp96 = ! __cil_tmp95;
#line 271
  __cil_tmp97 = ! __cil_tmp96;
#line 271
  __cil_tmp98 = (long )__cil_tmp97;
#line 271
  tmp___22 = ldv__builtin_expect(__cil_tmp98, 0L);
  }
#line 271
  if (tmp___22) {
#line 272
    ret = -16L;
  } else {
    {
#line 273
    __cil_tmp99 = ret > 0L;
#line 273
    __cil_tmp100 = ! __cil_tmp99;
#line 273
    __cil_tmp101 = ! __cil_tmp100;
#line 273
    __cil_tmp102 = (long )__cil_tmp101;
#line 273
    tmp___21 = ldv__builtin_expect(__cil_tmp102, 1L);
    }
#line 273
    if (tmp___21) {
#line 274
      ret = 0L;
    } else {

    }
  }
  {
#line 276
  __cil_tmp103 = (unsigned long )dev_priv;
#line 276
  __cil_tmp104 = __cil_tmp103 + 2184;
#line 276
  __cil_tmp105 = (struct mutex *)__cil_tmp104;
#line 276
  mutex_lock(__cil_tmp105);
#line 277
  __cil_tmp106 = (unsigned long )dev_priv;
#line 277
  __cil_tmp107 = __cil_tmp106 + 2976;
#line 277
  __cil_tmp108 = (atomic_t *)__cil_tmp107;
#line 277
  tmp___24 = atomic_dec_and_test(__cil_tmp108);
  }
#line 277
  if (tmp___24) {
    {
#line 278
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 278
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 278
        __cil_tmp109 = (unsigned long )dev_priv;
#line 278
        __cil_tmp110 = __cil_tmp109 + 2984;
#line 278
        __cil_tmp111 = (spinlock_t *)__cil_tmp110;
#line 278
        tmp___23 = spinlock_check(__cil_tmp111);
#line 278
        irq_flags = _raw_spin_lock_irqsave(tmp___23);
        }
#line 278
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 278
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 279
    __cil_tmp112 = (unsigned long )dev_priv;
#line 279
    __cil_tmp113 = __cil_tmp112 + 3016;
#line 279
    __cil_tmp114 = (unsigned long )dev_priv;
#line 279
    __cil_tmp115 = __cil_tmp114 + 3016;
#line 279
    __cil_tmp116 = *((uint32_t *)__cil_tmp115);
#line 279
    *((uint32_t *)__cil_tmp113) = __cil_tmp116 & 4294967293U;
#line 280
    __cil_tmp117 = (unsigned long )dev_priv;
#line 280
    __cil_tmp118 = __cil_tmp117 + 3016;
#line 280
    __cil_tmp119 = *((uint32_t *)__cil_tmp118);
#line 280
    vmw_write(dev_priv, 33U, __cil_tmp119);
#line 281
    __cil_tmp120 = (unsigned long )dev_priv;
#line 281
    __cil_tmp121 = __cil_tmp120 + 2984;
#line 281
    __cil_tmp122 = (spinlock_t *)__cil_tmp121;
#line 281
    spin_unlock_irqrestore(__cil_tmp122, irq_flags);
    }
  } else {

  }
  {
#line 283
  __cil_tmp123 = (unsigned long )dev_priv;
#line 283
  __cil_tmp124 = __cil_tmp123 + 2184;
#line 283
  __cil_tmp125 = (struct mutex *)__cil_tmp124;
#line 283
  mutex_unlock(__cil_tmp125);
  }
#line 285
  return ((int )ret);
}
}
#line 298 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t next_cmd ;
  uint32_t reserveable ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  uint32_t stop ;
  unsigned int tmp___10 ;
  bool need_bounce ;
  bool reserve_in_place ;
  long tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  void *tmp___17 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct mutex *__cil_tmp35 ;
  __le32 *__cil_tmp36 ;
  void *__cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  void *__cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void *__cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  void *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  __le32 *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  __le32 *__cil_tmp62 ;
  void *__cil_tmp63 ;
  uint32_t __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  long __cil_tmp66 ;
  bool __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  long __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  bool __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  __le32 *__cil_tmp85 ;
  void *__cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  __le32 *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  __le32 *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  __le32 *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct mutex *__cil_tmp106 ;

  {
  {
#line 300
  __cil_tmp24 = (unsigned long )dev_priv;
#line 300
  __cil_tmp25 = __cil_tmp24 + 1856;
#line 300
  fifo_state = (struct vmw_fifo_state *)__cil_tmp25;
#line 301
  __cil_tmp26 = (unsigned long )dev_priv;
#line 301
  __cil_tmp27 = __cil_tmp26 + 2144;
#line 301
  fifo_mem = *((__le32 **)__cil_tmp27);
#line 305
  __cil_tmp28 = 1 << 6;
#line 305
  __cil_tmp29 = (unsigned int )__cil_tmp28;
#line 305
  __cil_tmp30 = (unsigned long )fifo_state;
#line 305
  __cil_tmp31 = __cil_tmp30 + 36;
#line 305
  __cil_tmp32 = *((uint32_t *)__cil_tmp31);
#line 305
  reserveable = __cil_tmp32 & __cil_tmp29;
#line 308
  __cil_tmp33 = (unsigned long )fifo_state;
#line 308
  __cil_tmp34 = __cil_tmp33 + 40;
#line 308
  __cil_tmp35 = (struct mutex *)__cil_tmp34;
#line 308
  mutex_lock(__cil_tmp35);
#line 309
  __cil_tmp36 = fifo_mem + 1;
#line 309
  __cil_tmp37 = (void *)__cil_tmp36;
#line 309
  max = ioread32(__cil_tmp37);
#line 310
  __cil_tmp38 = fifo_mem + 0;
#line 310
  __cil_tmp39 = (void *)__cil_tmp38;
#line 310
  min = ioread32(__cil_tmp39);
#line 311
  __cil_tmp40 = fifo_mem + 2;
#line 311
  __cil_tmp41 = (void *)__cil_tmp40;
#line 311
  next_cmd = ioread32(__cil_tmp41);
#line 313
  __cil_tmp42 = max - min;
#line 313
  __cil_tmp43 = bytes >= __cil_tmp42;
#line 313
  __cil_tmp44 = ! __cil_tmp43;
#line 313
  __cil_tmp45 = ! __cil_tmp44;
#line 313
  __cil_tmp46 = (long )__cil_tmp45;
#line 313
  tmp___7 = ldv__builtin_expect(__cil_tmp46, 0L);
  }
#line 313
  if (tmp___7) {
#line 314
    goto out_err;
  } else {

  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    __cil_tmp47 = *((unsigned long *)fifo_state);
#line 316
    __cil_tmp48 = __cil_tmp47 != 0UL;
#line 316
    __cil_tmp49 = ! __cil_tmp48;
#line 316
    __cil_tmp50 = ! __cil_tmp49;
#line 316
    __cil_tmp51 = (long )__cil_tmp50;
#line 316
    tmp___8 = ldv__builtin_expect(__cil_tmp51, 0L);
    }
#line 316
    if (tmp___8) {
      {
#line 316
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 316
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (316), "i" (12UL));
        {
#line 316
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 316
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 316
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 317
    __cil_tmp52 = (void *)0;
#line 317
    __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 317
    __cil_tmp54 = (unsigned long )fifo_state;
#line 317
    __cil_tmp55 = __cil_tmp54 + 8;
#line 317
    __cil_tmp56 = *((__le32 **)__cil_tmp55);
#line 317
    __cil_tmp57 = (unsigned long )__cil_tmp56;
#line 317
    __cil_tmp58 = __cil_tmp57 != __cil_tmp53;
#line 317
    __cil_tmp59 = ! __cil_tmp58;
#line 317
    __cil_tmp60 = ! __cil_tmp59;
#line 317
    __cil_tmp61 = (long )__cil_tmp60;
#line 317
    tmp___9 = ldv__builtin_expect(__cil_tmp61, 0L);
    }
#line 317
    if (tmp___9) {
      {
#line 317
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 317
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (317), "i" (12UL));
        {
#line 317
        while (1) {
          while_continue___4: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 317
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {

    }
#line 317
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 319
  *((unsigned long *)fifo_state) = (unsigned long )bytes;
  {
#line 321
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 322
    __cil_tmp62 = fifo_mem + 3;
#line 322
    __cil_tmp63 = (void *)__cil_tmp62;
#line 322
    tmp___10 = ioread32(__cil_tmp63);
#line 322
    stop = tmp___10;
#line 323
    need_bounce = (bool )0;
#line 324
    reserve_in_place = (bool )0;
    }
#line 326
    if (next_cmd >= stop) {
      {
#line 327
      __cil_tmp64 = next_cmd + bytes;
#line 327
      if (__cil_tmp64 < max) {
#line 327
        tmp___13 = 1;
      } else {
        {
#line 327
        __cil_tmp65 = next_cmd + bytes;
#line 327
        if (__cil_tmp65 == max) {
#line 327
          if (stop > min) {
#line 327
            tmp___13 = 1;
          } else {
#line 327
            tmp___13 = 0;
          }
        } else {
#line 327
          tmp___13 = 0;
        }
        }
      }
      }
      {
#line 327
      __cil_tmp66 = (long )tmp___13;
#line 327
      tmp___14 = ldv__builtin_expect(__cil_tmp66, 1L);
      }
#line 327
      if (tmp___14) {
#line 329
        reserve_in_place = (bool )1;
      } else {
        {
#line 331
        tmp___12 = vmw_fifo_is_full(dev_priv, bytes);
        }
#line 331
        if (tmp___12) {
          {
#line 332
          __cil_tmp67 = (bool )0;
#line 332
          ret = vmw_fifo_wait(dev_priv, bytes, __cil_tmp67, 750UL);
#line 334
          __cil_tmp68 = ret != 0;
#line 334
          __cil_tmp69 = ! __cil_tmp68;
#line 334
          __cil_tmp70 = ! __cil_tmp69;
#line 334
          __cil_tmp71 = (long )__cil_tmp70;
#line 334
          tmp___11 = ldv__builtin_expect(__cil_tmp71, 0L);
          }
#line 334
          if (tmp___11) {
#line 335
            goto out_err;
          } else {

          }
        } else {
#line 337
          need_bounce = (bool )1;
        }
      }
    } else {
      {
#line 341
      __cil_tmp72 = next_cmd + bytes;
#line 341
      __cil_tmp73 = __cil_tmp72 < stop;
#line 341
      __cil_tmp74 = ! __cil_tmp73;
#line 341
      __cil_tmp75 = ! __cil_tmp74;
#line 341
      __cil_tmp76 = (long )__cil_tmp75;
#line 341
      tmp___16 = ldv__builtin_expect(__cil_tmp76, 1L);
      }
#line 341
      if (tmp___16) {
#line 342
        reserve_in_place = (bool )1;
      } else {
        {
#line 344
        __cil_tmp77 = (bool )0;
#line 344
        ret = vmw_fifo_wait(dev_priv, bytes, __cil_tmp77, 750UL);
#line 346
        __cil_tmp78 = ret != 0;
#line 346
        __cil_tmp79 = ! __cil_tmp78;
#line 346
        __cil_tmp80 = ! __cil_tmp79;
#line 346
        __cil_tmp81 = (long )__cil_tmp80;
#line 346
        tmp___15 = ldv__builtin_expect(__cil_tmp81, 0L);
        }
#line 346
        if (tmp___15) {
#line 347
          goto out_err;
        } else {

        }
      }
    }
#line 351
    if (reserve_in_place) {
#line 352
      if (reserveable) {
#line 352
        goto _L;
      } else {
        {
#line 352
        __cil_tmp82 = (unsigned long )bytes;
#line 352
        if (__cil_tmp82 <= 4UL) {
          _L: /* CIL Label */ 
#line 353
          __cil_tmp83 = (unsigned long )fifo_state;
#line 353
          __cil_tmp84 = __cil_tmp83 + 32;
#line 353
          *((bool *)__cil_tmp84) = (bool )0;
#line 355
          if (reserveable) {
            {
#line 356
            __cil_tmp85 = fifo_mem + 14;
#line 356
            __cil_tmp86 = (void *)__cil_tmp85;
#line 356
            iowrite32(bytes, __cil_tmp86);
            }
          } else {

          }
          {
#line 358
          __cil_tmp87 = next_cmd >> 2;
#line 358
          __cil_tmp88 = fifo_mem + __cil_tmp87;
#line 358
          return ((void *)__cil_tmp88);
          }
        } else {
#line 360
          need_bounce = (bool )1;
        }
        }
      }
    } else {

    }
#line 364
    if (need_bounce) {
#line 365
      __cil_tmp89 = (unsigned long )fifo_state;
#line 365
      __cil_tmp90 = __cil_tmp89 + 32;
#line 365
      *((bool *)__cil_tmp90) = (bool )1;
      {
#line 366
      __cil_tmp91 = (unsigned long )fifo_state;
#line 366
      __cil_tmp92 = __cil_tmp91 + 24;
#line 366
      __cil_tmp93 = *((unsigned long *)__cil_tmp92);
#line 366
      __cil_tmp94 = (unsigned long )bytes;
#line 366
      if (__cil_tmp94 < __cil_tmp93) {
        {
#line 367
        __cil_tmp95 = (unsigned long )fifo_state;
#line 367
        __cil_tmp96 = __cil_tmp95 + 16;
#line 367
        __cil_tmp97 = *((__le32 **)__cil_tmp96);
#line 367
        return ((void *)__cil_tmp97);
        }
      } else {
        {
#line 369
        __cil_tmp98 = (unsigned long )bytes;
#line 369
        tmp___17 = vmalloc(__cil_tmp98);
#line 369
        __cil_tmp99 = (unsigned long )fifo_state;
#line 369
        __cil_tmp100 = __cil_tmp99 + 8;
#line 369
        *((__le32 **)__cil_tmp100) = (__le32 *)tmp___17;
        }
        {
#line 370
        __cil_tmp101 = (unsigned long )fifo_state;
#line 370
        __cil_tmp102 = __cil_tmp101 + 8;
#line 370
        __cil_tmp103 = *((__le32 **)__cil_tmp102);
#line 370
        return ((void *)__cil_tmp103);
        }
      }
      }
    } else {

    }
  }
  while_break___5: /* CIL Label */ ;
  }
  out_err: 
  {
#line 375
  *((unsigned long *)fifo_state) = 0UL;
#line 376
  __cil_tmp104 = (unsigned long )fifo_state;
#line 376
  __cil_tmp105 = __cil_tmp104 + 40;
#line 376
  __cil_tmp106 = (struct mutex *)__cil_tmp105;
#line 376
  mutex_unlock(__cil_tmp106);
  }
#line 377
  return ((void *)0);
}
}
#line 380 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                              uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t chunk_size ;
  uint32_t rest ;
  uint32_t *buffer ;
  __le32 *tmp___7 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  __le32 *__cil_tmp24 ;
  void volatile   *__cil_tmp25 ;
  void    *__cil_tmp26 ;
  size_t __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  __le32 *__cil_tmp29 ;
  void volatile   *__cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t *__cil_tmp32 ;
  void    *__cil_tmp33 ;
  size_t __cil_tmp34 ;

  {
#line 385
  chunk_size = max - next_cmd;
  {
#line 387
  __cil_tmp11 = (void *)0;
#line 387
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 387
  __cil_tmp13 = (unsigned long )fifo_state;
#line 387
  __cil_tmp14 = __cil_tmp13 + 8;
#line 387
  __cil_tmp15 = *((__le32 **)__cil_tmp14);
#line 387
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 387
  if (__cil_tmp16 != __cil_tmp12) {
#line 387
    __cil_tmp17 = (unsigned long )fifo_state;
#line 387
    __cil_tmp18 = __cil_tmp17 + 8;
#line 387
    tmp___7 = *((__le32 **)__cil_tmp18);
  } else {
#line 387
    __cil_tmp19 = (unsigned long )fifo_state;
#line 387
    __cil_tmp20 = __cil_tmp19 + 16;
#line 387
    tmp___7 = *((__le32 **)__cil_tmp20);
  }
  }
#line 387
  buffer = tmp___7;
#line 390
  if (bytes < chunk_size) {
#line 391
    chunk_size = bytes;
  } else {

  }
  {
#line 393
  __cil_tmp21 = fifo_mem + 14;
#line 393
  __cil_tmp22 = (void *)__cil_tmp21;
#line 393
  iowrite32(bytes, __cil_tmp22);
#line 394
  __asm__  volatile   ("mfence": : : "memory");
#line 395
  __cil_tmp23 = next_cmd >> 2;
#line 395
  __cil_tmp24 = fifo_mem + __cil_tmp23;
#line 395
  __cil_tmp25 = (void volatile   *)__cil_tmp24;
#line 395
  __cil_tmp26 = (void    *)buffer;
#line 395
  __cil_tmp27 = (size_t )chunk_size;
#line 395
  memcpy_toio(__cil_tmp25, __cil_tmp26, __cil_tmp27);
#line 396
  rest = bytes - chunk_size;
  }
#line 397
  if (rest) {
    {
#line 398
    __cil_tmp28 = min >> 2;
#line 398
    __cil_tmp29 = fifo_mem + __cil_tmp28;
#line 398
    __cil_tmp30 = (void volatile   *)__cil_tmp29;
#line 398
    __cil_tmp31 = chunk_size >> 2;
#line 398
    __cil_tmp32 = buffer + __cil_tmp31;
#line 398
    __cil_tmp33 = (void    *)__cil_tmp32;
#line 398
    __cil_tmp34 = (size_t )rest;
#line 398
    memcpy_toio(__cil_tmp30, __cil_tmp33, __cil_tmp34);
    }
  } else {

  }
#line 400
  return;
}
}
#line 402 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
static void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                               uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t *buffer ;
  __le32 *tmp___7 ;
  uint32_t *tmp___8 ;
  long tmp___9 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  __le32 *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;

  {
  {
#line 407
  __cil_tmp11 = (void *)0;
#line 407
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 407
  __cil_tmp13 = (unsigned long )fifo_state;
#line 407
  __cil_tmp14 = __cil_tmp13 + 8;
#line 407
  __cil_tmp15 = *((__le32 **)__cil_tmp14);
#line 407
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 407
  if (__cil_tmp16 != __cil_tmp12) {
#line 407
    __cil_tmp17 = (unsigned long )fifo_state;
#line 407
    __cil_tmp18 = __cil_tmp17 + 8;
#line 407
    tmp___7 = *((__le32 **)__cil_tmp18);
  } else {
#line 407
    __cil_tmp19 = (unsigned long )fifo_state;
#line 407
    __cil_tmp20 = __cil_tmp19 + 16;
#line 407
    tmp___7 = *((__le32 **)__cil_tmp20);
  }
  }
#line 407
  buffer = tmp___7;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (bytes > 0U) {

    } else {
#line 410
      goto while_break;
    }
    {
#line 411
    tmp___8 = buffer;
#line 411
    buffer = buffer + 1;
#line 411
    __cil_tmp21 = *tmp___8;
#line 411
    __cil_tmp22 = next_cmd >> 2;
#line 411
    __cil_tmp23 = fifo_mem + __cil_tmp22;
#line 411
    __cil_tmp24 = (void *)__cil_tmp23;
#line 411
    iowrite32(__cil_tmp21, __cil_tmp24);
#line 412
    __cil_tmp25 = (unsigned long )next_cmd;
#line 412
    __cil_tmp26 = __cil_tmp25 + 4UL;
#line 412
    next_cmd = (uint32_t )__cil_tmp26;
#line 413
    __cil_tmp27 = next_cmd == max;
#line 413
    __cil_tmp28 = ! __cil_tmp27;
#line 413
    __cil_tmp29 = ! __cil_tmp28;
#line 413
    __cil_tmp30 = (long )__cil_tmp29;
#line 413
    tmp___9 = ldv__builtin_expect(__cil_tmp30, 0L);
    }
#line 413
    if (tmp___9) {
#line 414
      next_cmd = min;
    } else {

    }
    {
#line 415
    __asm__  volatile   ("mfence": : : "memory");
#line 416
    __cil_tmp31 = fifo_mem + 2;
#line 416
    __cil_tmp32 = (void *)__cil_tmp31;
#line 416
    iowrite32(next_cmd, __cil_tmp32);
#line 417
    __asm__  volatile   ("mfence": : : "memory");
#line 418
    __cil_tmp33 = (unsigned long )bytes;
#line 418
    __cil_tmp34 = __cil_tmp33 - 4UL;
#line 418
    bytes = (uint32_t )__cil_tmp34;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t next_cmd ;
  unsigned int tmp___7 ;
  uint32_t max ;
  unsigned int tmp___8 ;
  uint32_t min ;
  unsigned int tmp___9 ;
  bool reserveable ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  __le32 *__cil_tmp18 ;
  void *__cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  void *__cil_tmp21 ;
  __le32 *__cil_tmp22 ;
  void *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  __le32 *__cil_tmp47 ;
  void    *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  void *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct rw_semaphore *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  __le32 *__cil_tmp58 ;
  void *__cil_tmp59 ;
  u32 __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct rw_semaphore *__cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct mutex *__cil_tmp69 ;

  {
  {
#line 424
  __cil_tmp14 = (unsigned long )dev_priv;
#line 424
  __cil_tmp15 = __cil_tmp14 + 1856;
#line 424
  fifo_state = (struct vmw_fifo_state *)__cil_tmp15;
#line 425
  __cil_tmp16 = (unsigned long )dev_priv;
#line 425
  __cil_tmp17 = __cil_tmp16 + 2144;
#line 425
  fifo_mem = *((__le32 **)__cil_tmp17);
#line 426
  __cil_tmp18 = fifo_mem + 2;
#line 426
  __cil_tmp19 = (void *)__cil_tmp18;
#line 426
  tmp___7 = ioread32(__cil_tmp19);
#line 426
  next_cmd = tmp___7;
#line 427
  __cil_tmp20 = fifo_mem + 1;
#line 427
  __cil_tmp21 = (void *)__cil_tmp20;
#line 427
  tmp___8 = ioread32(__cil_tmp21);
#line 427
  max = tmp___8;
#line 428
  __cil_tmp22 = fifo_mem + 0;
#line 428
  __cil_tmp23 = (void *)__cil_tmp22;
#line 428
  tmp___9 = ioread32(__cil_tmp23);
#line 428
  min = tmp___9;
#line 429
  __cil_tmp24 = 1 << 6;
#line 429
  __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 429
  __cil_tmp26 = (unsigned long )fifo_state;
#line 429
  __cil_tmp27 = __cil_tmp26 + 36;
#line 429
  __cil_tmp28 = *((uint32_t *)__cil_tmp27);
#line 429
  __cil_tmp29 = __cil_tmp28 & __cil_tmp25;
#line 429
  reserveable = (bool )__cil_tmp29;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    __cil_tmp30 = bytes & 3U;
#line 431
    __cil_tmp31 = __cil_tmp30 != 0U;
#line 431
    __cil_tmp32 = ! __cil_tmp31;
#line 431
    __cil_tmp33 = ! __cil_tmp32;
#line 431
    __cil_tmp34 = (long )__cil_tmp33;
#line 431
    tmp___10 = ldv__builtin_expect(__cil_tmp34, 0L);
    }
#line 431
    if (tmp___10) {
      {
#line 431
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 431
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (431), "i" (12UL));
        {
#line 431
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 431
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 431
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 432
    __cil_tmp35 = *((unsigned long *)fifo_state);
#line 432
    __cil_tmp36 = (unsigned long )bytes;
#line 432
    __cil_tmp37 = __cil_tmp36 > __cil_tmp35;
#line 432
    __cil_tmp38 = ! __cil_tmp37;
#line 432
    __cil_tmp39 = ! __cil_tmp38;
#line 432
    __cil_tmp40 = (long )__cil_tmp39;
#line 432
    tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
    }
#line 432
    if (tmp___11) {
      {
#line 432
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 432
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (432), "i" (12UL));
        {
#line 432
        while (1) {
          while_continue___4: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 432
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {

    }
#line 432
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 434
  *((unsigned long *)fifo_state) = 0UL;
  {
#line 436
  __cil_tmp41 = (unsigned long )fifo_state;
#line 436
  __cil_tmp42 = __cil_tmp41 + 32;
#line 436
  if (*((bool *)__cil_tmp42)) {
#line 437
    if (reserveable) {
      {
#line 438
      vmw_fifo_res_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
      }
    } else {
      {
#line 441
      vmw_fifo_slow_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
      }
    }
    {
#line 444
    __cil_tmp43 = (unsigned long )fifo_state;
#line 444
    __cil_tmp44 = __cil_tmp43 + 8;
#line 444
    if (*((__le32 **)__cil_tmp44)) {
      {
#line 445
      __cil_tmp45 = (unsigned long )fifo_state;
#line 445
      __cil_tmp46 = __cil_tmp45 + 8;
#line 445
      __cil_tmp47 = *((__le32 **)__cil_tmp46);
#line 445
      __cil_tmp48 = (void    *)__cil_tmp47;
#line 445
      vfree(__cil_tmp48);
#line 446
      __cil_tmp49 = (unsigned long )fifo_state;
#line 446
      __cil_tmp50 = __cil_tmp49 + 8;
#line 446
      __cil_tmp51 = (void *)0;
#line 446
      *((__le32 **)__cil_tmp50) = (__le32 *)__cil_tmp51;
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 451
  __cil_tmp52 = (unsigned long )fifo_state;
#line 451
  __cil_tmp53 = __cil_tmp52 + 112;
#line 451
  __cil_tmp54 = (struct rw_semaphore *)__cil_tmp53;
#line 451
  down_write(__cil_tmp54);
  }
  {
#line 452
  __cil_tmp55 = (unsigned long )fifo_state;
#line 452
  __cil_tmp56 = __cil_tmp55 + 32;
#line 452
  if (*((bool *)__cil_tmp56)) {
#line 452
    goto _L;
  } else
#line 452
  if (reserveable) {
    _L: /* CIL Label */ 
#line 453
    next_cmd = next_cmd + bytes;
#line 454
    if (next_cmd >= max) {
#line 455
      __cil_tmp57 = max - min;
#line 455
      next_cmd = next_cmd - __cil_tmp57;
    } else {

    }
    {
#line 456
    __asm__  volatile   ("mfence": : : "memory");
#line 457
    __cil_tmp58 = fifo_mem + 2;
#line 457
    __cil_tmp59 = (void *)__cil_tmp58;
#line 457
    iowrite32(next_cmd, __cil_tmp59);
    }
  } else {

  }
  }
#line 460
  if (reserveable) {
    {
#line 461
    __cil_tmp60 = (u32 )0;
#line 461
    __cil_tmp61 = fifo_mem + 14;
#line 461
    __cil_tmp62 = (void *)__cil_tmp61;
#line 461
    iowrite32(__cil_tmp60, __cil_tmp62);
    }
  } else {

  }
  {
#line 462
  __asm__  volatile   ("mfence": : : "memory");
#line 463
  __cil_tmp63 = (unsigned long )fifo_state;
#line 463
  __cil_tmp64 = __cil_tmp63 + 112;
#line 463
  __cil_tmp65 = (struct rw_semaphore *)__cil_tmp64;
#line 463
  up_write(__cil_tmp65);
#line 464
  __cil_tmp66 = (uint32_t )1;
#line 464
  vmw_fifo_ping_host(dev_priv, __cil_tmp66);
#line 465
  __cil_tmp67 = (unsigned long )fifo_state;
#line 465
  __cil_tmp68 = __cil_tmp67 + 40;
#line 465
  __cil_tmp69 = (struct mutex *)__cil_tmp68;
#line 465
  mutex_unlock(__cil_tmp69);
  }
#line 466
  return;
}
}
#line 468 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  struct svga_fifo_cmd_fence *cmd_fence ;
  void *fm ;
  int ret ;
  uint32_t bytes ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  atomic_t *__cil_tmp23 ;
  atomic_t    *__cil_tmp24 ;
  bool __cil_tmp25 ;
  bool __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  bool __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  atomic_t *__cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  __le32 *__cil_tmp42 ;
  void *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct vmw_marker_queue *__cil_tmp46 ;
  uint32_t __cil_tmp47 ;

  {
  {
#line 470
  __cil_tmp11 = (unsigned long )dev_priv;
#line 470
  __cil_tmp12 = __cil_tmp11 + 1856;
#line 470
  fifo_state = (struct vmw_fifo_state *)__cil_tmp12;
#line 473
  ret = 0;
#line 474
  __cil_tmp13 = 4UL + 4UL;
#line 474
  bytes = (uint32_t )__cil_tmp13;
#line 476
  fm = vmw_fifo_reserve(dev_priv, bytes);
#line 477
  __cil_tmp14 = (void *)0;
#line 477
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 477
  __cil_tmp16 = (unsigned long )fm;
#line 477
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
#line 477
  __cil_tmp18 = ! __cil_tmp17;
#line 477
  __cil_tmp19 = ! __cil_tmp18;
#line 477
  __cil_tmp20 = (long )__cil_tmp19;
#line 477
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 477
  if (tmp___8) {
    {
#line 478
    __cil_tmp21 = (unsigned long )dev_priv;
#line 478
    __cil_tmp22 = __cil_tmp21 + 2880;
#line 478
    __cil_tmp23 = (atomic_t *)__cil_tmp22;
#line 478
    __cil_tmp24 = (atomic_t    *)__cil_tmp23;
#line 478
    tmp___7 = atomic_read(__cil_tmp24);
#line 478
    *seqno = (uint32_t )tmp___7;
#line 479
    ret = -12;
#line 480
    __cil_tmp25 = (bool )0;
#line 480
    __cil_tmp26 = (bool )1;
#line 480
    __cil_tmp27 = *seqno;
#line 480
    __cil_tmp28 = (bool )0;
#line 480
    vmw_fallback_wait(dev_priv, __cil_tmp25, __cil_tmp26, __cil_tmp27, __cil_tmp28,
                      750UL);
    }
#line 482
    goto out_err;
  } else {

  }
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 486
    __cil_tmp29 = (unsigned long )dev_priv;
#line 486
    __cil_tmp30 = __cil_tmp29 + 2880;
#line 486
    __cil_tmp31 = (atomic_t *)__cil_tmp30;
#line 486
    tmp___9 = atomic_add_return(1, __cil_tmp31);
#line 486
    *seqno = (uint32_t )tmp___9;
    }
    {
#line 485
    __cil_tmp32 = *seqno;
#line 485
    if (__cil_tmp32 == 0U) {

    } else {
#line 485
      goto while_break;
    }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  __cil_tmp33 = (unsigned long )fifo_state;
#line 489
  __cil_tmp34 = __cil_tmp33 + 36;
#line 489
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 489
  __cil_tmp36 = __cil_tmp35 & 1U;
#line 489
  if (! __cil_tmp36) {
    {
#line 496
    __cil_tmp37 = (uint32_t )0;
#line 496
    vmw_fifo_commit(dev_priv, __cil_tmp37);
    }
#line 497
    return (0);
  } else {

  }
  }
  {
#line 500
  __cil_tmp38 = (__le32 *)fm;
#line 500
  *__cil_tmp38 = (__u32 )30;
#line 501
  __cil_tmp39 = (unsigned long )fm;
#line 501
  __cil_tmp40 = __cil_tmp39 + 4UL;
#line 501
  cmd_fence = (struct svga_fifo_cmd_fence *)__cil_tmp40;
#line 504
  __cil_tmp41 = *seqno;
#line 504
  __cil_tmp42 = (__le32 *)cmd_fence;
#line 504
  __cil_tmp43 = (void *)__cil_tmp42;
#line 504
  iowrite32(__cil_tmp41, __cil_tmp43);
#line 505
  vmw_fifo_commit(dev_priv, bytes);
#line 506
  __cil_tmp44 = (unsigned long )fifo_state;
#line 506
  __cil_tmp45 = __cil_tmp44 + 160;
#line 506
  __cil_tmp46 = (struct vmw_marker_queue *)__cil_tmp45;
#line 506
  __cil_tmp47 = *seqno;
#line 506
  vmw_marker_push(__cil_tmp46, __cil_tmp47);
#line 507
  vmw_update_seqno(dev_priv, fifo_state);
  }
  out_err: 
#line 510
  return (ret);
}
}
#line 530 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) 
{ struct ttm_buffer_object *bo ;
  struct __anonstruct_cmd_429___2 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t __cil_tmp50 ;

  {
  {
#line 539
  __cil_tmp7 = (unsigned long )dev_priv;
#line 539
  __cil_tmp8 = __cil_tmp7 + 134744;
#line 539
  bo = *((struct ttm_buffer_object **)__cil_tmp8);
#line 545
  __cil_tmp9 = (uint32_t )24UL;
#line 545
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp9);
#line 545
  cmd = (struct __anonstruct_cmd_429___2 *)tmp___7;
#line 547
  __cil_tmp10 = (void *)0;
#line 547
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 547
  __cil_tmp12 = (unsigned long )cmd;
#line 547
  __cil_tmp13 = __cil_tmp12 == __cil_tmp11;
#line 547
  __cil_tmp14 = ! __cil_tmp13;
#line 547
  __cil_tmp15 = ! __cil_tmp14;
#line 547
  __cil_tmp16 = (long )__cil_tmp15;
#line 547
  tmp___8 = ldv__builtin_expect(__cil_tmp16, 0L);
  }
#line 547
  if (tmp___8) {
    {
#line 548
    drm_err("vmw_fifo_emit_dummy_query", "Out of fifo space for dummy query.\n");
    }
#line 549
    return (-12);
  } else {

  }
#line 552
  *((uint32 *)cmd) = (uint32 )1067;
#line 553
  __cil_tmp17 = 0 + 4;
#line 553
  __cil_tmp18 = (unsigned long )cmd;
#line 553
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 553
  *((uint32 *)__cil_tmp19) = (uint32 )16UL;
#line 554
  __cil_tmp20 = (unsigned long )cmd;
#line 554
  __cil_tmp21 = __cil_tmp20 + 8;
#line 554
  *((uint32 *)__cil_tmp21) = cid;
#line 555
  __cil_tmp22 = 8 + 4;
#line 555
  __cil_tmp23 = (unsigned long )cmd;
#line 555
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 555
  *((SVGA3dQueryType *)__cil_tmp24) = (SVGA3dQueryType )0;
  {
#line 557
  __cil_tmp25 = 112 + 36;
#line 557
  __cil_tmp26 = (unsigned long )bo;
#line 557
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
#line 557
  __cil_tmp28 = *((uint32_t *)__cil_tmp27);
#line 557
  if (__cil_tmp28 == 2U) {
#line 558
    __cil_tmp29 = 8 + 8;
#line 558
    __cil_tmp30 = (unsigned long )cmd;
#line 558
    __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 558
    *((uint32 *)__cil_tmp31) = (uint32 )-2;
#line 559
    __cil_tmp32 = 8 + 4;
#line 559
    __cil_tmp33 = 8 + __cil_tmp32;
#line 559
    __cil_tmp34 = (unsigned long )cmd;
#line 559
    __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 559
    __cil_tmp36 = (unsigned long )bo;
#line 559
    __cil_tmp37 = __cil_tmp36 + 368;
#line 559
    __cil_tmp38 = *((unsigned long *)__cil_tmp37);
#line 559
    *((uint32 *)__cil_tmp35) = (uint32 )__cil_tmp38;
  } else {
#line 561
    __cil_tmp39 = 8 + 8;
#line 561
    __cil_tmp40 = (unsigned long )cmd;
#line 561
    __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 561
    __cil_tmp42 = 112 + 8;
#line 561
    __cil_tmp43 = (unsigned long )bo;
#line 561
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 561
    __cil_tmp45 = *((unsigned long *)__cil_tmp44);
#line 561
    *((uint32 *)__cil_tmp41) = (uint32 )__cil_tmp45;
#line 562
    __cil_tmp46 = 8 + 4;
#line 562
    __cil_tmp47 = 8 + __cil_tmp46;
#line 562
    __cil_tmp48 = (unsigned long )cmd;
#line 562
    __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
#line 562
    *((uint32 *)__cil_tmp49) = (uint32 )0;
  }
  }
  {
#line 565
  __cil_tmp50 = (uint32_t )24UL;
#line 565
  vmw_fifo_commit(dev_priv, __cil_tmp50);
  }
#line 567
  return (0);
}
}
#line 80 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore *sem ) ;
#line 100
extern void up_read(struct rw_semaphore *sem ) ;
#line 362 "include/linux/sched.h"
extern void schedule(void) ;
#line 75 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fences_update(struct vmw_fence_manager *fman ) ;
#line 563 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) ;
#line 569
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) ;
#line 579
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) ;
#line 580
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) ;
#line 581
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) ;
#line 582
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) ;
#line 593
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) ;
#line 33 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
irqreturn_t vmw_irq_handler(int irq , void *arg ) 
{ struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  uint32_t masked_status ;
  long tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_fence_manager *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  wait_queue_head_t *__cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  wait_queue_head_t *__cil_tmp40 ;
  void *__cil_tmp41 ;

  {
  {
#line 35
  dev = (struct drm_device *)arg;
#line 36
  tmp___7 = vmw_priv(dev);
#line 36
  dev_priv = tmp___7;
#line 39
  __cil_tmp9 = (unsigned long )dev_priv;
#line 39
  __cil_tmp10 = __cil_tmp9 + 2984;
#line 39
  __cil_tmp11 = (spinlock_t *)__cil_tmp10;
#line 39
  spin_lock(__cil_tmp11);
#line 40
  __cil_tmp12 = (unsigned long )dev_priv;
#line 40
  __cil_tmp13 = __cil_tmp12 + 2104;
#line 40
  __cil_tmp14 = *((unsigned int *)__cil_tmp13);
#line 40
  __cil_tmp15 = __cil_tmp14 + 8U;
#line 40
  __cil_tmp16 = (int )__cil_tmp15;
#line 40
  status = inl(__cil_tmp16);
#line 41
  __cil_tmp17 = (unsigned long )dev_priv;
#line 41
  __cil_tmp18 = __cil_tmp17 + 3016;
#line 41
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 41
  masked_status = status & __cil_tmp19;
#line 42
  __cil_tmp20 = (unsigned long )dev_priv;
#line 42
  __cil_tmp21 = __cil_tmp20 + 2984;
#line 42
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
#line 42
  spin_unlock(__cil_tmp22);
#line 44
  __cil_tmp23 = ! status;
#line 44
  __cil_tmp24 = ! __cil_tmp23;
#line 44
  __cil_tmp25 = (long )__cil_tmp24;
#line 44
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 1L);
  }
#line 44
  if (tmp___8) {
    {
#line 45
    __cil_tmp26 = (unsigned long )dev_priv;
#line 45
    __cil_tmp27 = __cil_tmp26 + 2104;
#line 45
    __cil_tmp28 = *((unsigned int *)__cil_tmp27);
#line 45
    __cil_tmp29 = __cil_tmp28 + 8U;
#line 45
    __cil_tmp30 = (int )__cil_tmp29;
#line 45
    outl(status, __cil_tmp30);
    }
  } else {

  }
#line 47
  if (! masked_status) {
#line 48
    return ((irqreturn_t )0);
  } else {

  }
#line 50
  if (masked_status & 5U) {
    {
#line 52
    __cil_tmp31 = (unsigned long )dev_priv;
#line 52
    __cil_tmp32 = __cil_tmp31 + 3008;
#line 52
    __cil_tmp33 = *((struct vmw_fence_manager **)__cil_tmp32);
#line 52
    vmw_fences_update(__cil_tmp33);
#line 53
    __cil_tmp34 = (unsigned long )dev_priv;
#line 53
    __cil_tmp35 = __cil_tmp34 + 2888;
#line 53
    __cil_tmp36 = (wait_queue_head_t *)__cil_tmp35;
#line 53
    __cil_tmp37 = (void *)0;
#line 53
    __wake_up(__cil_tmp36, 3U, 0, __cil_tmp37);
    }
  } else {

  }
#line 56
  if (masked_status & 2U) {
    {
#line 57
    __cil_tmp38 = (unsigned long )dev_priv;
#line 57
    __cil_tmp39 = __cil_tmp38 + 2928;
#line 57
    __cil_tmp40 = (wait_queue_head_t *)__cil_tmp39;
#line 57
    __cil_tmp41 = (void *)0;
#line 57
    __wake_up(__cil_tmp40, 3U, 0, __cil_tmp41);
    }
  } else {

  }
#line 60
  return ((irqreturn_t )1);
}
}
#line 63 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
static bool vmw_fifo_idle(struct vmw_private *dev_priv , uint32_t seqno ) 
{ uint32_t busy ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct mutex *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 67
  __cil_tmp4 = (unsigned long )dev_priv;
#line 67
  __cil_tmp5 = __cil_tmp4 + 2184;
#line 67
  __cil_tmp6 = (struct mutex *)__cil_tmp5;
#line 67
  mutex_lock(__cil_tmp6);
#line 68
  busy = vmw_read(dev_priv, 22U);
#line 69
  __cil_tmp7 = (unsigned long )dev_priv;
#line 69
  __cil_tmp8 = __cil_tmp7 + 2184;
#line 69
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
#line 69
  mutex_unlock(__cil_tmp9);
  }
  {
#line 71
  __cil_tmp10 = busy == 0U;
#line 71
  return ((bool )__cil_tmp10);
  }
}
}
#line 74 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) 
{ __le32 *fifo_mem ;
  uint32_t seqno ;
  unsigned int tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  __le32 *__cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_marker_queue *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_fence_manager *__cil_tmp20 ;

  {
  {
#line 77
  __cil_tmp6 = (unsigned long )dev_priv;
#line 77
  __cil_tmp7 = __cil_tmp6 + 2144;
#line 77
  fifo_mem = *((__le32 **)__cil_tmp7);
#line 78
  __cil_tmp8 = fifo_mem + 6;
#line 78
  __cil_tmp9 = (void *)__cil_tmp8;
#line 78
  tmp___7 = ioread32(__cil_tmp9);
#line 78
  seqno = tmp___7;
  }
  {
#line 80
  __cil_tmp10 = (unsigned long )dev_priv;
#line 80
  __cil_tmp11 = __cil_tmp10 + 2980;
#line 80
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
#line 80
  if (__cil_tmp12 != seqno) {
    {
#line 81
    __cil_tmp13 = (unsigned long )dev_priv;
#line 81
    __cil_tmp14 = __cil_tmp13 + 2980;
#line 81
    *((uint32_t *)__cil_tmp14) = seqno;
#line 82
    __cil_tmp15 = (unsigned long )fifo_state;
#line 82
    __cil_tmp16 = __cil_tmp15 + 160;
#line 82
    __cil_tmp17 = (struct vmw_marker_queue *)__cil_tmp16;
#line 82
    vmw_marker_pull(__cil_tmp17, seqno);
#line 83
    __cil_tmp18 = (unsigned long )dev_priv;
#line 83
    __cil_tmp19 = __cil_tmp18 + 3008;
#line 83
    __cil_tmp20 = *((struct vmw_fence_manager **)__cil_tmp19);
#line 83
    vmw_fences_update(__cil_tmp20);
    }
  } else {

  }
  }
#line 85
  return;
}
}
#line 87 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  bool ret ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  atomic_t *__cil_tmp37 ;
  atomic_t    *__cil_tmp38 ;
  int __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  int __cil_tmp43 ;

  {
  {
#line 93
  __cil_tmp9 = 1 << 24;
#line 93
  __cil_tmp10 = (uint32_t )__cil_tmp9;
#line 93
  __cil_tmp11 = (unsigned long )dev_priv;
#line 93
  __cil_tmp12 = __cil_tmp11 + 2980;
#line 93
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
#line 93
  __cil_tmp14 = __cil_tmp13 - seqno;
#line 93
  __cil_tmp15 = __cil_tmp14 < __cil_tmp10;
#line 93
  __cil_tmp16 = ! __cil_tmp15;
#line 93
  __cil_tmp17 = ! __cil_tmp16;
#line 93
  __cil_tmp18 = (long )__cil_tmp17;
#line 93
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 1L);
  }
#line 93
  if (tmp___7) {
#line 94
    return ((bool )1);
  } else {

  }
  {
#line 96
  __cil_tmp19 = (unsigned long )dev_priv;
#line 96
  __cil_tmp20 = __cil_tmp19 + 1856;
#line 96
  fifo_state = (struct vmw_fifo_state *)__cil_tmp20;
#line 97
  vmw_update_seqno(dev_priv, fifo_state);
#line 98
  __cil_tmp21 = 1 << 24;
#line 98
  __cil_tmp22 = (uint32_t )__cil_tmp21;
#line 98
  __cil_tmp23 = (unsigned long )dev_priv;
#line 98
  __cil_tmp24 = __cil_tmp23 + 2980;
#line 98
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
#line 98
  __cil_tmp26 = __cil_tmp25 - seqno;
#line 98
  __cil_tmp27 = __cil_tmp26 < __cil_tmp22;
#line 98
  __cil_tmp28 = ! __cil_tmp27;
#line 98
  __cil_tmp29 = ! __cil_tmp28;
#line 98
  __cil_tmp30 = (long )__cil_tmp29;
#line 98
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 1L);
  }
#line 98
  if (tmp___8) {
#line 99
    return ((bool )1);
  } else {

  }
  {
#line 101
  __cil_tmp31 = (unsigned long )fifo_state;
#line 101
  __cil_tmp32 = __cil_tmp31 + 36;
#line 101
  __cil_tmp33 = *((uint32_t *)__cil_tmp32);
#line 101
  __cil_tmp34 = __cil_tmp33 & 1U;
#line 101
  if (! __cil_tmp34) {
    {
#line 101
    tmp___9 = vmw_fifo_idle(dev_priv, seqno);
    }
#line 101
    if (tmp___9) {
#line 103
      return ((bool )1);
    } else {

    }
  } else {

  }
  }
  {
#line 110
  __cil_tmp35 = (unsigned long )dev_priv;
#line 110
  __cil_tmp36 = __cil_tmp35 + 2880;
#line 110
  __cil_tmp37 = (atomic_t *)__cil_tmp36;
#line 110
  __cil_tmp38 = (atomic_t    *)__cil_tmp37;
#line 110
  tmp___10 = atomic_read(__cil_tmp38);
#line 110
  __cil_tmp39 = 1 << 24;
#line 110
  __cil_tmp40 = (uint32_t )__cil_tmp39;
#line 110
  __cil_tmp41 = (uint32_t )tmp___10;
#line 110
  __cil_tmp42 = __cil_tmp41 - seqno;
#line 110
  __cil_tmp43 = __cil_tmp42 > __cil_tmp40;
#line 110
  ret = (bool )__cil_tmp43;
  }
#line 113
  return (ret);
}
}
#line 116 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) 
{ struct vmw_fifo_state *fifo_state ;
  uint32_t count ;
  uint32_t signal_seq ;
  int ret ;
  unsigned long end_jiffies ;
  bool (*wait_condition)(struct vmw_private * , uint32_t  ) ;
  wait_queue_t __wait ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  int tmp___14 ;
  __le32 *fifo_mem ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long volatile   __cil_tmp29 ;
  unsigned long volatile   __cil_tmp30 ;
  wait_queue_t *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct rw_semaphore *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  atomic_t *__cil_tmp44 ;
  atomic_t    *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  wait_queue_head_t *__cil_tmp48 ;
  long __cil_tmp49 ;
  long __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  wait_queue_head_t *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  __le32 *__cil_tmp58 ;
  void *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  wait_queue_head_t *__cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct rw_semaphore *__cil_tmp66 ;

  {
  {
#line 123
  __cil_tmp27 = (unsigned long )dev_priv;
#line 123
  __cil_tmp28 = __cil_tmp27 + 1856;
#line 123
  fifo_state = (struct vmw_fifo_state *)__cil_tmp28;
#line 125
  count = (uint32_t )0;
#line 128
  __cil_tmp29 = (unsigned long volatile   )timeout;
#line 128
  __cil_tmp30 = jiffies + __cil_tmp29;
#line 128
  end_jiffies = (unsigned long )__cil_tmp30;
#line 130
  tmp___7 = get_current();
#line 130
  __cil_tmp31 = & __wait;
#line 130
  *((unsigned int *)__cil_tmp31) = 0U;
#line 130
  __cil_tmp32 = (unsigned long )(& __wait) + 8;
#line 130
  *((void **)__cil_tmp32) = (void *)tmp___7;
#line 130
  __cil_tmp33 = (unsigned long )(& __wait) + 16;
#line 130
  *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp33) = & autoremove_wake_function;
#line 130
  __cil_tmp34 = (unsigned long )(& __wait) + 24;
#line 130
  __cil_tmp35 = (unsigned long )(& __wait) + 24;
#line 130
  *((struct list_head **)__cil_tmp34) = (struct list_head *)__cil_tmp35;
#line 130
  __cil_tmp36 = 24 + 8;
#line 130
  __cil_tmp37 = (unsigned long )(& __wait) + __cil_tmp36;
#line 130
  __cil_tmp38 = (unsigned long )(& __wait) + 24;
#line 130
  *((struct list_head **)__cil_tmp37) = (struct list_head *)__cil_tmp38;
  }
#line 132
  if (fifo_idle) {
#line 132
    wait_condition = & vmw_fifo_idle;
  } else {
#line 132
    wait_condition = & vmw_seqno_passed;
  }
#line 139
  if (fifo_idle) {
    {
#line 140
    __cil_tmp39 = (unsigned long )fifo_state;
#line 140
    __cil_tmp40 = __cil_tmp39 + 112;
#line 140
    __cil_tmp41 = (struct rw_semaphore *)__cil_tmp40;
#line 140
    down_read(__cil_tmp41);
    }
  } else {

  }
  {
#line 141
  __cil_tmp42 = (unsigned long )dev_priv;
#line 141
  __cil_tmp43 = __cil_tmp42 + 2880;
#line 141
  __cil_tmp44 = (atomic_t *)__cil_tmp43;
#line 141
  __cil_tmp45 = (atomic_t    *)__cil_tmp44;
#line 141
  tmp___8 = atomic_read(__cil_tmp45);
#line 141
  signal_seq = (uint32_t )tmp___8;
#line 142
  ret = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (interruptible) {
#line 145
      tmp___9 = 1;
    } else {
#line 145
      tmp___9 = 2;
    }
    {
#line 145
    __cil_tmp46 = (unsigned long )dev_priv;
#line 145
    __cil_tmp47 = __cil_tmp46 + 2888;
#line 145
    __cil_tmp48 = (wait_queue_head_t *)__cil_tmp47;
#line 145
    prepare_to_wait(__cil_tmp48, & __wait, tmp___9);
#line 148
    tmp___10 = (*wait_condition)(dev_priv, seqno);
    }
#line 148
    if (tmp___10) {
#line 149
      goto while_break;
    } else {

    }
    {
#line 150
    __cil_tmp49 = (long )end_jiffies;
#line 150
    __cil_tmp50 = (long )jiffies;
#line 150
    __cil_tmp51 = __cil_tmp50 - __cil_tmp49;
#line 150
    if (__cil_tmp51 >= 0L) {
      {
#line 151
      drm_err("vmw_fallback_wait", "SVGA device lockup.\n");
      }
#line 152
      goto while_break;
    } else {

    }
    }
#line 154
    if (lazy) {
      {
#line 155
      schedule_timeout(1L);
      }
    } else {
#line 156
      count = count + 1U;
      {
#line 156
      __cil_tmp52 = count & 15U;
#line 156
      if (__cil_tmp52 == 0U) {
        {
#line 162
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 162
          tmp___11 = get_current();
#line 162
          *((long volatile   *)tmp___11) = (long volatile   )0;
          }
#line 162
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 163
        schedule();
        }
        {
#line 164
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 164
          tmp___12 = get_current();
          }
#line 164
          if (interruptible) {
#line 164
            *((long volatile   *)tmp___12) = (long volatile   )1;
          } else {
#line 164
            *((long volatile   *)tmp___12) = (long volatile   )2;
          }
#line 164
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {

      }
      }
    }
#line 168
    if (interruptible) {
      {
#line 168
      tmp___13 = get_current();
#line 168
      tmp___14 = signal_pending(tmp___13);
      }
#line 168
      if (tmp___14) {
#line 169
        ret = -512;
#line 170
        goto while_break;
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  __cil_tmp53 = (unsigned long )dev_priv;
#line 173
  __cil_tmp54 = __cil_tmp53 + 2888;
#line 173
  __cil_tmp55 = (wait_queue_head_t *)__cil_tmp54;
#line 173
  finish_wait(__cil_tmp55, & __wait);
  }
#line 174
  if (ret == 0) {
#line 174
    if (fifo_idle) {
      {
#line 175
      __cil_tmp56 = (unsigned long )dev_priv;
#line 175
      __cil_tmp57 = __cil_tmp56 + 2144;
#line 175
      fifo_mem = *((__le32 **)__cil_tmp57);
#line 176
      __cil_tmp58 = fifo_mem + 6;
#line 176
      __cil_tmp59 = (void *)__cil_tmp58;
#line 176
      iowrite32(signal_seq, __cil_tmp59);
      }
    } else {

    }
  } else {

  }
  {
#line 178
  __cil_tmp60 = (unsigned long )dev_priv;
#line 178
  __cil_tmp61 = __cil_tmp60 + 2888;
#line 178
  __cil_tmp62 = (wait_queue_head_t *)__cil_tmp61;
#line 178
  __cil_tmp63 = (void *)0;
#line 178
  __wake_up(__cil_tmp62, 3U, 0, __cil_tmp63);
  }
#line 179
  if (fifo_idle) {
    {
#line 180
    __cil_tmp64 = (unsigned long )fifo_state;
#line 180
    __cil_tmp65 = __cil_tmp64 + 112;
#line 180
    __cil_tmp66 = (struct rw_semaphore *)__cil_tmp65;
#line 180
    up_read(__cil_tmp66);
    }
  } else {

  }
#line 182
  return (ret);
}
}
#line 185 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  {
#line 187
  __cil_tmp7 = (unsigned long )dev_priv;
#line 187
  __cil_tmp8 = __cil_tmp7 + 2184;
#line 187
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
#line 187
  mutex_lock(__cil_tmp9);
#line 188
  __cil_tmp10 = (unsigned long )dev_priv;
#line 188
  __cil_tmp11 = __cil_tmp10 + 2968;
#line 188
  tmp___8 = *((int *)__cil_tmp11);
#line 188
  __cil_tmp12 = (unsigned long )dev_priv;
#line 188
  __cil_tmp13 = __cil_tmp12 + 2968;
#line 188
  __cil_tmp14 = (unsigned long )dev_priv;
#line 188
  __cil_tmp15 = __cil_tmp14 + 2968;
#line 188
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 188
  *((int *)__cil_tmp13) = __cil_tmp16 + 1;
  }
#line 188
  if (tmp___8 == 0) {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 191
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 191
        __cil_tmp17 = (unsigned long )dev_priv;
#line 191
        __cil_tmp18 = __cil_tmp17 + 2984;
#line 191
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 191
        tmp___7 = spinlock_check(__cil_tmp19);
#line 191
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        }
#line 191
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 191
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 192
    __cil_tmp20 = (unsigned long )dev_priv;
#line 192
    __cil_tmp21 = __cil_tmp20 + 2104;
#line 192
    __cil_tmp22 = *((unsigned int *)__cil_tmp21);
#line 192
    __cil_tmp23 = __cil_tmp22 + 8U;
#line 192
    __cil_tmp24 = (int )__cil_tmp23;
#line 192
    outl(1U, __cil_tmp24);
#line 194
    __cil_tmp25 = (unsigned long )dev_priv;
#line 194
    __cil_tmp26 = __cil_tmp25 + 3016;
#line 194
    __cil_tmp27 = (unsigned long )dev_priv;
#line 194
    __cil_tmp28 = __cil_tmp27 + 3016;
#line 194
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
#line 194
    *((uint32_t *)__cil_tmp26) = __cil_tmp29 | 1U;
#line 195
    __cil_tmp30 = (unsigned long )dev_priv;
#line 195
    __cil_tmp31 = __cil_tmp30 + 3016;
#line 195
    __cil_tmp32 = *((uint32_t *)__cil_tmp31);
#line 195
    vmw_write(dev_priv, 33U, __cil_tmp32);
#line 196
    __cil_tmp33 = (unsigned long )dev_priv;
#line 196
    __cil_tmp34 = __cil_tmp33 + 2984;
#line 196
    __cil_tmp35 = (spinlock_t *)__cil_tmp34;
#line 196
    spin_unlock_irqrestore(__cil_tmp35, irq_flags);
    }
  } else {

  }
  {
#line 198
  __cil_tmp36 = (unsigned long )dev_priv;
#line 198
  __cil_tmp37 = __cil_tmp36 + 2184;
#line 198
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
#line 198
  mutex_unlock(__cil_tmp38);
  }
#line 199
  return;
}
}
#line 201 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;

  {
  {
#line 203
  __cil_tmp6 = (unsigned long )dev_priv;
#line 203
  __cil_tmp7 = __cil_tmp6 + 2184;
#line 203
  __cil_tmp8 = (struct mutex *)__cil_tmp7;
#line 203
  mutex_lock(__cil_tmp8);
#line 204
  __cil_tmp9 = (unsigned long )dev_priv;
#line 204
  __cil_tmp10 = __cil_tmp9 + 2968;
#line 204
  __cil_tmp11 = (unsigned long )dev_priv;
#line 204
  __cil_tmp12 = __cil_tmp11 + 2968;
#line 204
  __cil_tmp13 = *((int *)__cil_tmp12);
#line 204
  *((int *)__cil_tmp10) = __cil_tmp13 - 1;
  }
  {
#line 204
  __cil_tmp14 = (unsigned long )dev_priv;
#line 204
  __cil_tmp15 = __cil_tmp14 + 2968;
#line 204
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 204
  if (__cil_tmp16 == 0) {
    {
#line 207
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 207
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 207
        __cil_tmp17 = (unsigned long )dev_priv;
#line 207
        __cil_tmp18 = __cil_tmp17 + 2984;
#line 207
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 207
        tmp___7 = spinlock_check(__cil_tmp19);
#line 207
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        }
#line 207
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 207
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 208
    __cil_tmp20 = (unsigned long )dev_priv;
#line 208
    __cil_tmp21 = __cil_tmp20 + 3016;
#line 208
    __cil_tmp22 = (unsigned long )dev_priv;
#line 208
    __cil_tmp23 = __cil_tmp22 + 3016;
#line 208
    __cil_tmp24 = *((uint32_t *)__cil_tmp23);
#line 208
    *((uint32_t *)__cil_tmp21) = __cil_tmp24 & 4294967294U;
#line 209
    __cil_tmp25 = (unsigned long )dev_priv;
#line 209
    __cil_tmp26 = __cil_tmp25 + 3016;
#line 209
    __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 209
    vmw_write(dev_priv, 33U, __cil_tmp27);
#line 210
    __cil_tmp28 = (unsigned long )dev_priv;
#line 210
    __cil_tmp29 = __cil_tmp28 + 2984;
#line 210
    __cil_tmp30 = (spinlock_t *)__cil_tmp29;
#line 210
    spin_unlock_irqrestore(__cil_tmp30, irq_flags);
    }
  } else {

  }
  }
  {
#line 212
  __cil_tmp31 = (unsigned long )dev_priv;
#line 212
  __cil_tmp32 = __cil_tmp31 + 2184;
#line 212
  __cil_tmp33 = (struct mutex *)__cil_tmp32;
#line 212
  mutex_unlock(__cil_tmp33);
  }
#line 213
  return;
}
}
#line 216 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  {
#line 218
  __cil_tmp7 = (unsigned long )dev_priv;
#line 218
  __cil_tmp8 = __cil_tmp7 + 2184;
#line 218
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
#line 218
  mutex_lock(__cil_tmp9);
#line 219
  __cil_tmp10 = (unsigned long )dev_priv;
#line 219
  __cil_tmp11 = __cil_tmp10 + 2972;
#line 219
  tmp___8 = *((int *)__cil_tmp11);
#line 219
  __cil_tmp12 = (unsigned long )dev_priv;
#line 219
  __cil_tmp13 = __cil_tmp12 + 2972;
#line 219
  __cil_tmp14 = (unsigned long )dev_priv;
#line 219
  __cil_tmp15 = __cil_tmp14 + 2972;
#line 219
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 219
  *((int *)__cil_tmp13) = __cil_tmp16 + 1;
  }
#line 219
  if (tmp___8 == 0) {
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 222
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 222
        __cil_tmp17 = (unsigned long )dev_priv;
#line 222
        __cil_tmp18 = __cil_tmp17 + 2984;
#line 222
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 222
        tmp___7 = spinlock_check(__cil_tmp19);
#line 222
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        }
#line 222
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 222
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 223
    __cil_tmp20 = (unsigned long )dev_priv;
#line 223
    __cil_tmp21 = __cil_tmp20 + 2104;
#line 223
    __cil_tmp22 = *((unsigned int *)__cil_tmp21);
#line 223
    __cil_tmp23 = __cil_tmp22 + 8U;
#line 223
    __cil_tmp24 = (int )__cil_tmp23;
#line 223
    outl(4U, __cil_tmp24);
#line 225
    __cil_tmp25 = (unsigned long )dev_priv;
#line 225
    __cil_tmp26 = __cil_tmp25 + 3016;
#line 225
    __cil_tmp27 = (unsigned long )dev_priv;
#line 225
    __cil_tmp28 = __cil_tmp27 + 3016;
#line 225
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
#line 225
    *((uint32_t *)__cil_tmp26) = __cil_tmp29 | 4U;
#line 226
    __cil_tmp30 = (unsigned long )dev_priv;
#line 226
    __cil_tmp31 = __cil_tmp30 + 3016;
#line 226
    __cil_tmp32 = *((uint32_t *)__cil_tmp31);
#line 226
    vmw_write(dev_priv, 33U, __cil_tmp32);
#line 227
    __cil_tmp33 = (unsigned long )dev_priv;
#line 227
    __cil_tmp34 = __cil_tmp33 + 2984;
#line 227
    __cil_tmp35 = (spinlock_t *)__cil_tmp34;
#line 227
    spin_unlock_irqrestore(__cil_tmp35, irq_flags);
    }
  } else {

  }
  {
#line 229
  __cil_tmp36 = (unsigned long )dev_priv;
#line 229
  __cil_tmp37 = __cil_tmp36 + 2184;
#line 229
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
#line 229
  mutex_unlock(__cil_tmp38);
  }
#line 230
  return;
}
}
#line 232 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;

  {
  {
#line 234
  __cil_tmp6 = (unsigned long )dev_priv;
#line 234
  __cil_tmp7 = __cil_tmp6 + 2184;
#line 234
  __cil_tmp8 = (struct mutex *)__cil_tmp7;
#line 234
  mutex_lock(__cil_tmp8);
#line 235
  __cil_tmp9 = (unsigned long )dev_priv;
#line 235
  __cil_tmp10 = __cil_tmp9 + 2972;
#line 235
  __cil_tmp11 = (unsigned long )dev_priv;
#line 235
  __cil_tmp12 = __cil_tmp11 + 2972;
#line 235
  __cil_tmp13 = *((int *)__cil_tmp12);
#line 235
  *((int *)__cil_tmp10) = __cil_tmp13 - 1;
  }
  {
#line 235
  __cil_tmp14 = (unsigned long )dev_priv;
#line 235
  __cil_tmp15 = __cil_tmp14 + 2972;
#line 235
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 235
  if (__cil_tmp16 == 0) {
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 238
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 238
        __cil_tmp17 = (unsigned long )dev_priv;
#line 238
        __cil_tmp18 = __cil_tmp17 + 2984;
#line 238
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
#line 238
        tmp___7 = spinlock_check(__cil_tmp19);
#line 238
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        }
#line 238
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 238
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 239
    __cil_tmp20 = (unsigned long )dev_priv;
#line 239
    __cil_tmp21 = __cil_tmp20 + 3016;
#line 239
    __cil_tmp22 = (unsigned long )dev_priv;
#line 239
    __cil_tmp23 = __cil_tmp22 + 3016;
#line 239
    __cil_tmp24 = *((uint32_t *)__cil_tmp23);
#line 239
    *((uint32_t *)__cil_tmp21) = __cil_tmp24 & 4294967291U;
#line 240
    __cil_tmp25 = (unsigned long )dev_priv;
#line 240
    __cil_tmp26 = __cil_tmp25 + 3016;
#line 240
    __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 240
    vmw_write(dev_priv, 33U, __cil_tmp27);
#line 241
    __cil_tmp28 = (unsigned long )dev_priv;
#line 241
    __cil_tmp29 = __cil_tmp28 + 2984;
#line 241
    __cil_tmp30 = (spinlock_t *)__cil_tmp29;
#line 241
    spin_unlock_irqrestore(__cil_tmp30, irq_flags);
    }
  } else {

  }
  }
  {
#line 243
  __cil_tmp31 = (unsigned long )dev_priv;
#line 243
  __cil_tmp32 = __cil_tmp31 + 2184;
#line 243
  __cil_tmp33 = (struct mutex *)__cil_tmp32;
#line 243
  mutex_unlock(__cil_tmp33);
  }
#line 244
  return;
}
}
#line 246 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) 
{ long ret ;
  struct vmw_fifo_state *fifo ;
  long tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___13 ;
  bool tmp___14 ;
  struct task_struct *tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  bool __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  bool __cil_tmp51 ;
  wait_queue_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  wait_queue_head_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  wait_queue_head_t *__cil_tmp65 ;
  wait_queue_t *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  wait_queue_head_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  wait_queue_head_t *__cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  long __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  long __cil_tmp87 ;

  {
  {
#line 251
  __cil_tmp28 = (unsigned long )dev_priv;
#line 251
  __cil_tmp29 = __cil_tmp28 + 1856;
#line 251
  fifo = (struct vmw_fifo_state *)__cil_tmp29;
#line 253
  __cil_tmp30 = 1 << 24;
#line 253
  __cil_tmp31 = (uint32_t )__cil_tmp30;
#line 253
  __cil_tmp32 = (unsigned long )dev_priv;
#line 253
  __cil_tmp33 = __cil_tmp32 + 2980;
#line 253
  __cil_tmp34 = *((uint32_t *)__cil_tmp33);
#line 253
  __cil_tmp35 = __cil_tmp34 - seqno;
#line 253
  __cil_tmp36 = __cil_tmp35 < __cil_tmp31;
#line 253
  __cil_tmp37 = ! __cil_tmp36;
#line 253
  __cil_tmp38 = ! __cil_tmp37;
#line 253
  __cil_tmp39 = (long )__cil_tmp38;
#line 253
  tmp___7 = ldv__builtin_expect(__cil_tmp39, 1L);
  }
#line 253
  if (tmp___7) {
#line 254
    return (0);
  } else {

  }
  {
#line 256
  tmp___8 = vmw_seqno_passed(dev_priv, seqno);
  }
#line 256
  if (tmp___8) {
#line 256
    tmp___9 = 1;
  } else {
#line 256
    tmp___9 = 0;
  }
  {
#line 256
  __cil_tmp40 = (long )tmp___9;
#line 256
  tmp___10 = ldv__builtin_expect(__cil_tmp40, 1L);
  }
#line 256
  if (tmp___10) {
#line 257
    return (0);
  } else {

  }
  {
#line 259
  __cil_tmp41 = (uint32_t )1;
#line 259
  vmw_fifo_ping_host(dev_priv, __cil_tmp41);
  }
  {
#line 261
  __cil_tmp42 = (unsigned long )fifo;
#line 261
  __cil_tmp43 = __cil_tmp42 + 36;
#line 261
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
#line 261
  __cil_tmp45 = __cil_tmp44 & 1U;
#line 261
  if (! __cil_tmp45) {
    {
#line 262
    __cil_tmp46 = (bool )1;
#line 262
    tmp___11 = vmw_fallback_wait(dev_priv, lazy, __cil_tmp46, seqno, interruptible,
                                 timeout);
    }
#line 262
    return (tmp___11);
  } else {

  }
  }
  {
#line 265
  __cil_tmp47 = (unsigned long )dev_priv;
#line 265
  __cil_tmp48 = __cil_tmp47 + 2156;
#line 265
  __cil_tmp49 = *((uint32_t *)__cil_tmp48);
#line 265
  __cil_tmp50 = __cil_tmp49 & 262144U;
#line 265
  if (! __cil_tmp50) {
    {
#line 266
    __cil_tmp51 = (bool )0;
#line 266
    tmp___12 = vmw_fallback_wait(dev_priv, lazy, __cil_tmp51, seqno, interruptible,
                                 timeout);
    }
#line 266
    return (tmp___12);
  } else {

  }
  }
  {
#line 269
  vmw_seqno_waiter_add(dev_priv);
  }
#line 271
  if (interruptible) {
    {
#line 272
    __ret = (long )timeout;
#line 272
    tmp___17 = vmw_seqno_passed(dev_priv, seqno);
    }
#line 272
    if (tmp___17) {

    } else {
      {
#line 272
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 272
        tmp___13 = get_current();
#line 272
        __cil_tmp52 = & __wait;
#line 272
        *((unsigned int *)__cil_tmp52) = 0U;
#line 272
        __cil_tmp53 = (unsigned long )(& __wait) + 8;
#line 272
        *((void **)__cil_tmp53) = (void *)tmp___13;
#line 272
        __cil_tmp54 = (unsigned long )(& __wait) + 16;
#line 272
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp54) = & autoremove_wake_function;
#line 272
        __cil_tmp55 = (unsigned long )(& __wait) + 24;
#line 272
        __cil_tmp56 = (unsigned long )(& __wait) + 24;
#line 272
        *((struct list_head **)__cil_tmp55) = (struct list_head *)__cil_tmp56;
#line 272
        __cil_tmp57 = 24 + 8;
#line 272
        __cil_tmp58 = (unsigned long )(& __wait) + __cil_tmp57;
#line 272
        __cil_tmp59 = (unsigned long )(& __wait) + 24;
#line 272
        *((struct list_head **)__cil_tmp58) = (struct list_head *)__cil_tmp59;
        }
        {
#line 272
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 272
          __cil_tmp60 = (unsigned long )dev_priv;
#line 272
          __cil_tmp61 = __cil_tmp60 + 2888;
#line 272
          __cil_tmp62 = (wait_queue_head_t *)__cil_tmp61;
#line 272
          prepare_to_wait(__cil_tmp62, & __wait, 1);
#line 272
          tmp___14 = vmw_seqno_passed(dev_priv, seqno);
          }
#line 272
          if (tmp___14) {
#line 272
            goto while_break___0;
          } else {

          }
          {
#line 272
          tmp___15 = get_current();
#line 272
          tmp___16 = signal_pending(tmp___15);
          }
#line 272
          if (tmp___16) {

          } else {
            {
#line 272
            __ret = schedule_timeout(__ret);
            }
#line 272
            if (! __ret) {
#line 272
              goto while_break___0;
            } else {

            }
#line 272
            goto __Cont;
          }
#line 272
          __ret = -512L;
#line 272
          goto while_break___0;
          __Cont: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 272
        __cil_tmp63 = (unsigned long )dev_priv;
#line 272
        __cil_tmp64 = __cil_tmp63 + 2888;
#line 272
        __cil_tmp65 = (wait_queue_head_t *)__cil_tmp64;
#line 272
        finish_wait(__cil_tmp65, & __wait);
        }
#line 272
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 272
    ret = __ret;
  } else {
    {
#line 277
    __ret___0 = (long )timeout;
#line 277
    tmp___20 = vmw_seqno_passed(dev_priv, seqno);
    }
#line 277
    if (tmp___20) {

    } else {
      {
#line 277
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 277
        tmp___18 = get_current();
#line 277
        __cil_tmp66 = & __wait___0;
#line 277
        *((unsigned int *)__cil_tmp66) = 0U;
#line 277
        __cil_tmp67 = (unsigned long )(& __wait___0) + 8;
#line 277
        *((void **)__cil_tmp67) = (void *)tmp___18;
#line 277
        __cil_tmp68 = (unsigned long )(& __wait___0) + 16;
#line 277
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp68) = & autoremove_wake_function;
#line 277
        __cil_tmp69 = (unsigned long )(& __wait___0) + 24;
#line 277
        __cil_tmp70 = (unsigned long )(& __wait___0) + 24;
#line 277
        *((struct list_head **)__cil_tmp69) = (struct list_head *)__cil_tmp70;
#line 277
        __cil_tmp71 = 24 + 8;
#line 277
        __cil_tmp72 = (unsigned long )(& __wait___0) + __cil_tmp71;
#line 277
        __cil_tmp73 = (unsigned long )(& __wait___0) + 24;
#line 277
        *((struct list_head **)__cil_tmp72) = (struct list_head *)__cil_tmp73;
        }
        {
#line 277
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 277
          __cil_tmp74 = (unsigned long )dev_priv;
#line 277
          __cil_tmp75 = __cil_tmp74 + 2888;
#line 277
          __cil_tmp76 = (wait_queue_head_t *)__cil_tmp75;
#line 277
          prepare_to_wait(__cil_tmp76, & __wait___0, 2);
#line 277
          tmp___19 = vmw_seqno_passed(dev_priv, seqno);
          }
#line 277
          if (tmp___19) {
#line 277
            goto while_break___2;
          } else {

          }
          {
#line 277
          __ret___0 = schedule_timeout(__ret___0);
          }
#line 277
          if (! __ret___0) {
#line 277
            goto while_break___2;
          } else {

          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 277
        __cil_tmp77 = (unsigned long )dev_priv;
#line 277
        __cil_tmp78 = __cil_tmp77 + 2888;
#line 277
        __cil_tmp79 = (wait_queue_head_t *)__cil_tmp78;
#line 277
        finish_wait(__cil_tmp79, & __wait___0);
        }
#line 277
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 277
    ret = __ret___0;
  }
  {
#line 282
  vmw_seqno_waiter_remove(dev_priv);
#line 284
  __cil_tmp80 = ret == 0L;
#line 284
  __cil_tmp81 = ! __cil_tmp80;
#line 284
  __cil_tmp82 = ! __cil_tmp81;
#line 284
  __cil_tmp83 = (long )__cil_tmp82;
#line 284
  tmp___22 = ldv__builtin_expect(__cil_tmp83, 0L);
  }
#line 284
  if (tmp___22) {
#line 285
    ret = -16L;
  } else {
    {
#line 286
    __cil_tmp84 = ret > 0L;
#line 286
    __cil_tmp85 = ! __cil_tmp84;
#line 286
    __cil_tmp86 = ! __cil_tmp85;
#line 286
    __cil_tmp87 = (long )__cil_tmp86;
#line 286
    tmp___21 = ldv__builtin_expect(__cil_tmp87, 1L);
    }
#line 286
    if (tmp___21) {
#line 287
      ret = 0L;
    } else {

    }
  }
#line 289
  return ((int )ret);
}
}
#line 300 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
static struct lock_class_key __key___15  ;
#line 292 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_irq_preinstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct raw_spinlock *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 294
  tmp___7 = vmw_priv(dev);
#line 294
  dev_priv = tmp___7;
  }
  {
#line 297
  __cil_tmp5 = (unsigned long )dev_priv;
#line 297
  __cil_tmp6 = __cil_tmp5 + 2156;
#line 297
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
#line 297
  __cil_tmp8 = __cil_tmp7 & 262144U;
#line 297
  if (! __cil_tmp8) {
#line 298
    return;
  } else {

  }
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    __cil_tmp9 = (unsigned long )dev_priv;
#line 300
    __cil_tmp10 = __cil_tmp9 + 2984;
#line 300
    __cil_tmp11 = (spinlock_t *)__cil_tmp10;
#line 300
    spinlock_check(__cil_tmp11);
    }
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 300
      __cil_tmp12 = (unsigned long )dev_priv;
#line 300
      __cil_tmp13 = __cil_tmp12 + 2984;
#line 300
      __cil_tmp14 = (struct raw_spinlock *)__cil_tmp13;
#line 300
      __raw_spin_lock_init(__cil_tmp14, "&(&dev_priv->irq_lock)->rlock", & __key___15);
      }
#line 300
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  __cil_tmp15 = (unsigned long )dev_priv;
#line 301
  __cil_tmp16 = __cil_tmp15 + 2104;
#line 301
  __cil_tmp17 = *((unsigned int *)__cil_tmp16);
#line 301
  __cil_tmp18 = __cil_tmp17 + 8U;
#line 301
  __cil_tmp19 = (int )__cil_tmp18;
#line 301
  status = inl(__cil_tmp19);
#line 302
  __cil_tmp20 = (unsigned long )dev_priv;
#line 302
  __cil_tmp21 = __cil_tmp20 + 2104;
#line 302
  __cil_tmp22 = *((unsigned int *)__cil_tmp21);
#line 302
  __cil_tmp23 = __cil_tmp22 + 8U;
#line 302
  __cil_tmp24 = (int )__cil_tmp23;
#line 302
  outl(status, __cil_tmp24);
  }
#line 303
  return;
}
}
#line 305 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
int vmw_irq_postinstall(struct drm_device *dev ) 
{ 

  {
#line 307
  return (0);
}
}
#line 310 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c"
void vmw_irq_uninstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct mutex *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  {
#line 312
  tmp___7 = vmw_priv(dev);
#line 312
  dev_priv = tmp___7;
  }
  {
#line 315
  __cil_tmp5 = (unsigned long )dev_priv;
#line 315
  __cil_tmp6 = __cil_tmp5 + 2156;
#line 315
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
#line 315
  __cil_tmp8 = __cil_tmp7 & 262144U;
#line 315
  if (! __cil_tmp8) {
#line 316
    return;
  } else {

  }
  }
  {
#line 318
  __cil_tmp9 = (unsigned long )dev_priv;
#line 318
  __cil_tmp10 = __cil_tmp9 + 2184;
#line 318
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
#line 318
  mutex_lock(__cil_tmp11);
#line 319
  __cil_tmp12 = (uint32_t )0;
#line 319
  vmw_write(dev_priv, 33U, __cil_tmp12);
#line 320
  __cil_tmp13 = (unsigned long )dev_priv;
#line 320
  __cil_tmp14 = __cil_tmp13 + 2184;
#line 320
  __cil_tmp15 = (struct mutex *)__cil_tmp14;
#line 320
  mutex_unlock(__cil_tmp15);
#line 322
  __cil_tmp16 = (unsigned long )dev_priv;
#line 322
  __cil_tmp17 = __cil_tmp16 + 2104;
#line 322
  __cil_tmp18 = *((unsigned int *)__cil_tmp17);
#line 322
  __cil_tmp19 = __cil_tmp18 + 8U;
#line 322
  __cil_tmp20 = (int )__cil_tmp19;
#line 322
  status = inl(__cil_tmp20);
#line 323
  __cil_tmp21 = (unsigned long )dev_priv;
#line 323
  __cil_tmp22 = __cil_tmp21 + 2104;
#line 323
  __cil_tmp23 = *((unsigned int *)__cil_tmp22);
#line 323
  __cil_tmp24 = __cil_tmp23 + 8U;
#line 323
  __cil_tmp25 = (int )__cil_tmp24;
#line 323
  outl(status, __cil_tmp25);
  }
#line 324
  return;
}
}
#line 818 "include/drm/drm_crtc.h"
extern int drm_crtc_init(struct drm_device *dev , struct drm_crtc *crtc , struct drm_crtc_funcs    *funcs ) ;
#line 823
extern int drm_connector_init(struct drm_device *dev , struct drm_connector *connector ,
                              struct drm_connector_funcs    *funcs , int connector_type ) ;
#line 832
extern int drm_encoder_init(struct drm_device *dev , struct drm_encoder *encoder ,
                            struct drm_encoder_funcs    *funcs , int encoder_type ) ;
#line 913
extern int drm_connector_attach_property(struct drm_connector *connector , struct drm_property *property ,
                                         uint64_t init_val ) ;
#line 932
extern int drm_mode_create_dirty_info_property(struct drm_device *dev ) ;
#line 935
extern int drm_mode_connector_attach_encoder(struct drm_connector *connector , struct drm_encoder *encoder ) ;
#line 939
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc , int gamma_size ) ;
#line 1435 "include/drm/drmP.h"
extern int drm_vblank_init(struct drm_device *dev , int num_crtcs ) ;
#line 1446
extern void drm_vblank_cleanup(struct drm_device *dev ) ;
#line 57 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct list_head *__cil_tmp4 ;
  struct vmw_display_unit *__cil_tmp5 ;
  void    *__cil_tmp6 ;

  {
  {
#line 59
  __cil_tmp2 = (unsigned long )ldu;
#line 59
  __cil_tmp3 = __cil_tmp2 + 2072;
#line 59
  __cil_tmp4 = (struct list_head *)__cil_tmp3;
#line 59
  list_del_init(__cil_tmp4);
#line 60
  __cil_tmp5 = (struct vmw_display_unit *)ldu;
#line 60
  vmw_display_unit_cleanup(__cil_tmp5);
#line 61
  __cil_tmp6 = (void    *)ldu;
#line 61
  kfree(__cil_tmp6);
  }
#line 62
  return;
}
}
#line 69 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static void vmw_ldu_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc    *__mptr ;
  struct vmw_legacy_display_unit *__cil_tmp3 ;
  struct drm_crtc *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  struct vmw_legacy_display_unit *__cil_tmp8 ;

  {
  {
#line 71
  __mptr = (struct drm_crtc    *)crtc;
#line 71
  __cil_tmp3 = (struct vmw_legacy_display_unit *)0;
#line 71
  __cil_tmp4 = (struct drm_crtc *)__cil_tmp3;
#line 71
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 71
  __cil_tmp6 = (char *)__mptr;
#line 71
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
#line 71
  __cil_tmp8 = (struct vmw_legacy_display_unit *)__cil_tmp7;
#line 71
  vmw_ldu_destroy(__cil_tmp8);
  }
#line 72
  return;
}
}
#line 74 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static int vmw_ldu_commit_list(struct vmw_private *dev_priv ) 
{ struct vmw_legacy_display *lds ;
  struct vmw_legacy_display_unit *entry ;
  struct vmw_display_unit *du ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int i ;
  int ret ;
  int w ;
  int h ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int _max1 ;
  int _max2 ;
  int tmp___7 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___8 ;
  int tmp___9 ;
  struct list_head    *__mptr___1 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  struct list_head    *__mptr___2 ;
  struct list_head    *__mptr___3 ;
  long tmp___12 ;
  struct list_head    *__mptr___4 ;
  struct list_head    *__mptr___5 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  struct vmw_legacy_display_unit *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct list_head *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int *__cil_tmp51 ;
  int *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  int *__cil_tmp60 ;
  int __cil_tmp61 ;
  int *__cil_tmp62 ;
  int __cil_tmp63 ;
  int *__cil_tmp64 ;
  int *__cil_tmp65 ;
  int *__cil_tmp66 ;
  int *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  int __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int *__cil_tmp75 ;
  int __cil_tmp76 ;
  int *__cil_tmp77 ;
  int __cil_tmp78 ;
  int *__cil_tmp79 ;
  int *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  struct vmw_legacy_display_unit *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct list_head *__cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  void *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  int __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  struct list_head *__cil_tmp112 ;
  struct list_head    *__cil_tmp113 ;
  struct list_head *__cil_tmp114 ;
  struct vmw_legacy_display_unit *__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  struct list_head *__cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned int __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned int __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  int __cil_tmp139 ;
  unsigned int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  struct list_head *__cil_tmp148 ;
  struct vmw_legacy_display_unit *__cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  struct list_head *__cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  struct list_head *__cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct list_head *__cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  uint32_t __cil_tmp162 ;
  int __cil_tmp163 ;
  uint32_t __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  int __cil_tmp167 ;
  uint32_t __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  int __cil_tmp171 ;
  uint32_t __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  int __cil_tmp176 ;
  uint32_t __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  int __cil_tmp181 ;
  uint32_t __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  struct list_head *__cil_tmp185 ;
  struct vmw_legacy_display_unit *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  struct list_head *__cil_tmp189 ;
  unsigned int __cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned int __cil_tmp195 ;
  unsigned int __cil_tmp196 ;
  int __cil_tmp197 ;
  int __cil_tmp198 ;
  int __cil_tmp199 ;
  long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  struct list_head *__cil_tmp205 ;
  struct vmw_legacy_display_unit *__cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  struct list_head *__cil_tmp209 ;
  unsigned int __cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  struct list_head *__cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  struct list_head *__cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  struct vmw_dma_buffer *__cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  struct vmw_dma_buffer *__cil_tmp224 ;
  u32 __cil_tmp225 ;
  u32 __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  int __cil_tmp229 ;
  u32 __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  int __cil_tmp233 ;
  u32 __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  struct list_head *__cil_tmp237 ;
  struct vmw_legacy_display_unit *__cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  struct list_head *__cil_tmp241 ;
  unsigned int __cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;

  {
#line 76
  __cil_tmp28 = (unsigned long )dev_priv;
#line 76
  __cil_tmp29 = __cil_tmp28 + 2608;
#line 76
  lds = *((struct vmw_legacy_display **)__cil_tmp29);
#line 78
  __cil_tmp30 = (void *)0;
#line 78
  du = (struct vmw_display_unit *)__cil_tmp30;
#line 79
  __cil_tmp31 = (void *)0;
#line 79
  fb = (struct drm_framebuffer *)__cil_tmp31;
#line 80
  __cil_tmp32 = (void *)0;
#line 80
  crtc = (struct drm_crtc *)__cil_tmp32;
#line 81
  i = 0;
  {
#line 86
  __cil_tmp33 = (unsigned long )dev_priv;
#line 86
  __cil_tmp34 = __cil_tmp33 + 2156;
#line 86
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 86
  __cil_tmp36 = __cil_tmp35 & 524288U;
#line 86
  if (! __cil_tmp36) {
#line 87
    w = 0;
#line 87
    h = 0;
#line 88
    __cil_tmp37 = *((struct list_head **)lds);
#line 88
    __mptr = (struct list_head    *)__cil_tmp37;
#line 88
    __cil_tmp38 = (struct vmw_legacy_display_unit *)0;
#line 88
    __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 88
    __cil_tmp40 = __cil_tmp39 + 2072;
#line 88
    __cil_tmp41 = (struct list_head *)__cil_tmp40;
#line 88
    __cil_tmp42 = (unsigned int )__cil_tmp41;
#line 88
    __cil_tmp43 = (char *)__mptr;
#line 88
    __cil_tmp44 = __cil_tmp43 - __cil_tmp42;
#line 88
    entry = (struct vmw_legacy_display_unit *)__cil_tmp44;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 88
      __cil_tmp45 = (struct list_head *)lds;
#line 88
      __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 88
      __cil_tmp47 = (unsigned long )entry;
#line 88
      __cil_tmp48 = __cil_tmp47 + 2072;
#line 88
      __cil_tmp49 = (struct list_head *)__cil_tmp48;
#line 88
      __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 88
      if (__cil_tmp50 != __cil_tmp46) {

      } else {
#line 88
        goto while_break;
      }
      }
#line 89
      crtc = (struct drm_crtc *)entry;
#line 90
      __cil_tmp51 = & _max1;
#line 90
      *__cil_tmp51 = w;
#line 90
      __cil_tmp52 = & _max2;
#line 90
      __cil_tmp53 = 48 + 68;
#line 90
      __cil_tmp54 = (unsigned long )crtc;
#line 90
      __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
#line 90
      __cil_tmp56 = *((int *)__cil_tmp55);
#line 90
      __cil_tmp57 = (unsigned long )crtc;
#line 90
      __cil_tmp58 = __cil_tmp57 + 480;
#line 90
      __cil_tmp59 = *((int *)__cil_tmp58);
#line 90
      *__cil_tmp52 = __cil_tmp59 + __cil_tmp56;
      {
#line 90
      __cil_tmp60 = & _max2;
#line 90
      __cil_tmp61 = *__cil_tmp60;
#line 90
      __cil_tmp62 = & _max1;
#line 90
      __cil_tmp63 = *__cil_tmp62;
#line 90
      if (__cil_tmp63 > __cil_tmp61) {
#line 90
        __cil_tmp64 = & _max1;
#line 90
        tmp___7 = *__cil_tmp64;
      } else {
#line 90
        __cil_tmp65 = & _max2;
#line 90
        tmp___7 = *__cil_tmp65;
      }
      }
#line 90
      w = tmp___7;
#line 91
      __cil_tmp66 = & _max1___0;
#line 91
      *__cil_tmp66 = h;
#line 91
      __cil_tmp67 = & _max2___0;
#line 91
      __cil_tmp68 = 48 + 88;
#line 91
      __cil_tmp69 = (unsigned long )crtc;
#line 91
      __cil_tmp70 = __cil_tmp69 + __cil_tmp68;
#line 91
      __cil_tmp71 = *((int *)__cil_tmp70);
#line 91
      __cil_tmp72 = (unsigned long )crtc;
#line 91
      __cil_tmp73 = __cil_tmp72 + 484;
#line 91
      __cil_tmp74 = *((int *)__cil_tmp73);
#line 91
      *__cil_tmp67 = __cil_tmp74 + __cil_tmp71;
      {
#line 91
      __cil_tmp75 = & _max2___0;
#line 91
      __cil_tmp76 = *__cil_tmp75;
#line 91
      __cil_tmp77 = & _max1___0;
#line 91
      __cil_tmp78 = *__cil_tmp77;
#line 91
      if (__cil_tmp78 > __cil_tmp76) {
#line 91
        __cil_tmp79 = & _max1___0;
#line 91
        tmp___8 = *__cil_tmp79;
      } else {
#line 91
        __cil_tmp80 = & _max2___0;
#line 91
        tmp___8 = *__cil_tmp80;
      }
      }
#line 91
      h = tmp___8;
#line 92
      i = i + 1;
#line 88
      __cil_tmp81 = (unsigned long )entry;
#line 88
      __cil_tmp82 = __cil_tmp81 + 2072;
#line 88
      __cil_tmp83 = *((struct list_head **)__cil_tmp82);
#line 88
      __mptr___0 = (struct list_head    *)__cil_tmp83;
#line 88
      __cil_tmp84 = (struct vmw_legacy_display_unit *)0;
#line 88
      __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 88
      __cil_tmp86 = __cil_tmp85 + 2072;
#line 88
      __cil_tmp87 = (struct list_head *)__cil_tmp86;
#line 88
      __cil_tmp88 = (unsigned int )__cil_tmp87;
#line 88
      __cil_tmp89 = (char *)__mptr___0;
#line 88
      __cil_tmp90 = __cil_tmp89 - __cil_tmp88;
#line 88
      entry = (struct vmw_legacy_display_unit *)__cil_tmp90;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 95
    __cil_tmp91 = (void *)0;
#line 95
    __cil_tmp92 = (unsigned long )__cil_tmp91;
#line 95
    __cil_tmp93 = (unsigned long )crtc;
#line 95
    if (__cil_tmp93 == __cil_tmp92) {
#line 96
      return (0);
    } else {

    }
    }
    {
#line 97
    __cil_tmp94 = 0 + 32;
#line 97
    __cil_tmp95 = 0 + __cil_tmp94;
#line 97
    __cil_tmp96 = (unsigned long )entry;
#line 97
    __cil_tmp97 = __cil_tmp96 + __cil_tmp95;
#line 97
    fb = *((struct drm_framebuffer **)__cil_tmp97);
#line 99
    __cil_tmp98 = (unsigned int )w;
#line 99
    __cil_tmp99 = (unsigned int )h;
#line 99
    __cil_tmp100 = 0 * 4UL;
#line 99
    __cil_tmp101 = 40 + __cil_tmp100;
#line 99
    __cil_tmp102 = (unsigned long )fb;
#line 99
    __cil_tmp103 = __cil_tmp102 + __cil_tmp101;
#line 99
    __cil_tmp104 = *((unsigned int *)__cil_tmp103);
#line 99
    __cil_tmp105 = (unsigned long )fb;
#line 99
    __cil_tmp106 = __cil_tmp105 + 84;
#line 99
    __cil_tmp107 = *((int *)__cil_tmp106);
#line 99
    __cil_tmp108 = (unsigned int )__cil_tmp107;
#line 99
    __cil_tmp109 = (unsigned long )fb;
#line 99
    __cil_tmp110 = __cil_tmp109 + 80;
#line 99
    __cil_tmp111 = *((unsigned int *)__cil_tmp110);
#line 99
    tmp___9 = vmw_kms_write_svga(dev_priv, __cil_tmp98, __cil_tmp99, __cil_tmp104,
                                 __cil_tmp108, __cil_tmp111);
    }
#line 99
    return (tmp___9);
  } else {

  }
  }
  {
#line 103
  __cil_tmp112 = (struct list_head *)lds;
#line 103
  __cil_tmp113 = (struct list_head    *)__cil_tmp112;
#line 103
  tmp___10 = list_empty(__cil_tmp113);
  }
#line 103
  if (tmp___10) {

  } else {
    {
#line 104
    __cil_tmp114 = *((struct list_head **)lds);
#line 104
    __mptr___1 = (struct list_head    *)__cil_tmp114;
#line 104
    __cil_tmp115 = (struct vmw_legacy_display_unit *)0;
#line 104
    __cil_tmp116 = (unsigned long )__cil_tmp115;
#line 104
    __cil_tmp117 = __cil_tmp116 + 2072;
#line 104
    __cil_tmp118 = (struct list_head *)__cil_tmp117;
#line 104
    __cil_tmp119 = (unsigned int )__cil_tmp118;
#line 104
    __cil_tmp120 = (char *)__mptr___1;
#line 104
    __cil_tmp121 = __cil_tmp120 - __cil_tmp119;
#line 104
    entry = (struct vmw_legacy_display_unit *)__cil_tmp121;
#line 105
    __cil_tmp122 = 0 + 32;
#line 105
    __cil_tmp123 = 0 + __cil_tmp122;
#line 105
    __cil_tmp124 = (unsigned long )entry;
#line 105
    __cil_tmp125 = __cil_tmp124 + __cil_tmp123;
#line 105
    fb = *((struct drm_framebuffer **)__cil_tmp125);
#line 107
    __cil_tmp126 = (unsigned long )fb;
#line 107
    __cil_tmp127 = __cil_tmp126 + 72;
#line 107
    __cil_tmp128 = *((unsigned int *)__cil_tmp127);
#line 107
    __cil_tmp129 = (unsigned long )fb;
#line 107
    __cil_tmp130 = __cil_tmp129 + 76;
#line 107
    __cil_tmp131 = *((unsigned int *)__cil_tmp130);
#line 107
    __cil_tmp132 = 0 * 4UL;
#line 107
    __cil_tmp133 = 40 + __cil_tmp132;
#line 107
    __cil_tmp134 = (unsigned long )fb;
#line 107
    __cil_tmp135 = __cil_tmp134 + __cil_tmp133;
#line 107
    __cil_tmp136 = *((unsigned int *)__cil_tmp135);
#line 107
    __cil_tmp137 = (unsigned long )fb;
#line 107
    __cil_tmp138 = __cil_tmp137 + 84;
#line 107
    __cil_tmp139 = *((int *)__cil_tmp138);
#line 107
    __cil_tmp140 = (unsigned int )__cil_tmp139;
#line 107
    __cil_tmp141 = (unsigned long )fb;
#line 107
    __cil_tmp142 = __cil_tmp141 + 80;
#line 107
    __cil_tmp143 = *((unsigned int *)__cil_tmp142);
#line 107
    vmw_kms_write_svga(dev_priv, __cil_tmp128, __cil_tmp131, __cil_tmp136, __cil_tmp140,
                       __cil_tmp143);
    }
  }
  {
#line 112
  __cil_tmp144 = (unsigned long )lds;
#line 112
  __cil_tmp145 = __cil_tmp144 + 16;
#line 112
  if (*((unsigned int *)__cil_tmp145)) {
#line 112
    __cil_tmp146 = (unsigned long )lds;
#line 112
    __cil_tmp147 = __cil_tmp146 + 16;
#line 112
    tmp___11 = *((unsigned int *)__cil_tmp147);
  } else {
#line 112
    tmp___11 = 1U;
  }
  }
  {
#line 112
  vmw_write(dev_priv, 34U, tmp___11);
#line 115
  i = 0;
#line 116
  __cil_tmp148 = *((struct list_head **)lds);
#line 116
  __mptr___2 = (struct list_head    *)__cil_tmp148;
#line 116
  __cil_tmp149 = (struct vmw_legacy_display_unit *)0;
#line 116
  __cil_tmp150 = (unsigned long )__cil_tmp149;
#line 116
  __cil_tmp151 = __cil_tmp150 + 2072;
#line 116
  __cil_tmp152 = (struct list_head *)__cil_tmp151;
#line 116
  __cil_tmp153 = (unsigned int )__cil_tmp152;
#line 116
  __cil_tmp154 = (char *)__mptr___2;
#line 116
  __cil_tmp155 = __cil_tmp154 - __cil_tmp153;
#line 116
  entry = (struct vmw_legacy_display_unit *)__cil_tmp155;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 116
    __cil_tmp156 = (struct list_head *)lds;
#line 116
    __cil_tmp157 = (unsigned long )__cil_tmp156;
#line 116
    __cil_tmp158 = (unsigned long )entry;
#line 116
    __cil_tmp159 = __cil_tmp158 + 2072;
#line 116
    __cil_tmp160 = (struct list_head *)__cil_tmp159;
#line 116
    __cil_tmp161 = (unsigned long )__cil_tmp160;
#line 116
    if (__cil_tmp161 != __cil_tmp157) {

    } else {
#line 116
      goto while_break___0;
    }
    }
    {
#line 117
    crtc = (struct drm_crtc *)entry;
#line 119
    __cil_tmp162 = (uint32_t )i;
#line 119
    vmw_write(dev_priv, 35U, __cil_tmp162);
#line 120
    __cil_tmp163 = ! i;
#line 120
    __cil_tmp164 = (uint32_t )__cil_tmp163;
#line 120
    vmw_write(dev_priv, 36U, __cil_tmp164);
#line 121
    __cil_tmp165 = (unsigned long )crtc;
#line 121
    __cil_tmp166 = __cil_tmp165 + 480;
#line 121
    __cil_tmp167 = *((int *)__cil_tmp166);
#line 121
    __cil_tmp168 = (uint32_t )__cil_tmp167;
#line 121
    vmw_write(dev_priv, 37U, __cil_tmp168);
#line 122
    __cil_tmp169 = (unsigned long )crtc;
#line 122
    __cil_tmp170 = __cil_tmp169 + 484;
#line 122
    __cil_tmp171 = *((int *)__cil_tmp170);
#line 122
    __cil_tmp172 = (uint32_t )__cil_tmp171;
#line 122
    vmw_write(dev_priv, 38U, __cil_tmp172);
#line 123
    __cil_tmp173 = 48 + 68;
#line 123
    __cil_tmp174 = (unsigned long )crtc;
#line 123
    __cil_tmp175 = __cil_tmp174 + __cil_tmp173;
#line 123
    __cil_tmp176 = *((int *)__cil_tmp175);
#line 123
    __cil_tmp177 = (uint32_t )__cil_tmp176;
#line 123
    vmw_write(dev_priv, 39U, __cil_tmp177);
#line 124
    __cil_tmp178 = 48 + 88;
#line 124
    __cil_tmp179 = (unsigned long )crtc;
#line 124
    __cil_tmp180 = __cil_tmp179 + __cil_tmp178;
#line 124
    __cil_tmp181 = *((int *)__cil_tmp180);
#line 124
    __cil_tmp182 = (uint32_t )__cil_tmp181;
#line 124
    vmw_write(dev_priv, 40U, __cil_tmp182);
#line 125
    vmw_write(dev_priv, 35U, 4294967295U);
#line 127
    i = i + 1;
#line 116
    __cil_tmp183 = (unsigned long )entry;
#line 116
    __cil_tmp184 = __cil_tmp183 + 2072;
#line 116
    __cil_tmp185 = *((struct list_head **)__cil_tmp184);
#line 116
    __mptr___3 = (struct list_head    *)__cil_tmp185;
#line 116
    __cil_tmp186 = (struct vmw_legacy_display_unit *)0;
#line 116
    __cil_tmp187 = (unsigned long )__cil_tmp186;
#line 116
    __cil_tmp188 = __cil_tmp187 + 2072;
#line 116
    __cil_tmp189 = (struct list_head *)__cil_tmp188;
#line 116
    __cil_tmp190 = (unsigned int )__cil_tmp189;
#line 116
    __cil_tmp191 = (char *)__mptr___3;
#line 116
    __cil_tmp192 = __cil_tmp191 - __cil_tmp190;
#line 116
    entry = (struct vmw_legacy_display_unit *)__cil_tmp192;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 130
    __cil_tmp193 = (unsigned long )lds;
#line 130
    __cil_tmp194 = __cil_tmp193 + 16;
#line 130
    __cil_tmp195 = *((unsigned int *)__cil_tmp194);
#line 130
    __cil_tmp196 = (unsigned int )i;
#line 130
    __cil_tmp197 = __cil_tmp196 != __cil_tmp195;
#line 130
    __cil_tmp198 = ! __cil_tmp197;
#line 130
    __cil_tmp199 = ! __cil_tmp198;
#line 130
    __cil_tmp200 = (long )__cil_tmp199;
#line 130
    tmp___12 = ldv__builtin_expect(__cil_tmp200, 0L);
    }
#line 130
    if (tmp___12) {
      {
#line 130
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 130
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (130), "i" (12UL));
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 130
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {

    }
#line 130
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 132
  __cil_tmp201 = (unsigned long )lds;
#line 132
  __cil_tmp202 = __cil_tmp201 + 20;
#line 132
  __cil_tmp203 = (unsigned long )lds;
#line 132
  __cil_tmp204 = __cil_tmp203 + 16;
#line 132
  *((unsigned int *)__cil_tmp202) = *((unsigned int *)__cil_tmp204);
#line 136
  __cil_tmp205 = *((struct list_head **)lds);
#line 136
  __mptr___4 = (struct list_head    *)__cil_tmp205;
#line 136
  __cil_tmp206 = (struct vmw_legacy_display_unit *)0;
#line 136
  __cil_tmp207 = (unsigned long )__cil_tmp206;
#line 136
  __cil_tmp208 = __cil_tmp207 + 2072;
#line 136
  __cil_tmp209 = (struct list_head *)__cil_tmp208;
#line 136
  __cil_tmp210 = (unsigned int )__cil_tmp209;
#line 136
  __cil_tmp211 = (char *)__mptr___4;
#line 136
  __cil_tmp212 = __cil_tmp211 - __cil_tmp210;
#line 136
  entry = (struct vmw_legacy_display_unit *)__cil_tmp212;
  {
#line 136
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 136
    __cil_tmp213 = (struct list_head *)lds;
#line 136
    __cil_tmp214 = (unsigned long )__cil_tmp213;
#line 136
    __cil_tmp215 = (unsigned long )entry;
#line 136
    __cil_tmp216 = __cil_tmp215 + 2072;
#line 136
    __cil_tmp217 = (struct list_head *)__cil_tmp216;
#line 136
    __cil_tmp218 = (unsigned long )__cil_tmp217;
#line 136
    if (__cil_tmp218 != __cil_tmp214) {

    } else {
#line 136
      goto while_break___4;
    }
    }
#line 137
    du = (struct vmw_display_unit *)entry;
    {
#line 139
    __cil_tmp219 = (unsigned long )du;
#line 139
    __cil_tmp220 = __cil_tmp219 + 2000;
#line 139
    __cil_tmp221 = *((struct vmw_dma_buffer **)__cil_tmp220);
#line 139
    if (! __cil_tmp221) {
#line 140
      goto __Cont;
    } else {

    }
    }
    {
#line 142
    __cil_tmp222 = (unsigned long )du;
#line 142
    __cil_tmp223 = __cil_tmp222 + 2000;
#line 142
    __cil_tmp224 = *((struct vmw_dma_buffer **)__cil_tmp223);
#line 142
    __cil_tmp225 = (u32 )64;
#line 142
    __cil_tmp226 = (u32 )64;
#line 142
    __cil_tmp227 = (unsigned long )du;
#line 142
    __cil_tmp228 = __cil_tmp227 + 2024;
#line 142
    __cil_tmp229 = *((int *)__cil_tmp228);
#line 142
    __cil_tmp230 = (u32 )__cil_tmp229;
#line 142
    __cil_tmp231 = (unsigned long )du;
#line 142
    __cil_tmp232 = __cil_tmp231 + 2028;
#line 142
    __cil_tmp233 = *((int *)__cil_tmp232);
#line 142
    __cil_tmp234 = (u32 )__cil_tmp233;
#line 142
    ret = vmw_cursor_update_dmabuf(dev_priv, __cil_tmp224, __cil_tmp225, __cil_tmp226,
                                   __cil_tmp230, __cil_tmp234);
    }
#line 147
    if (ret == 0) {
#line 148
      goto while_break___4;
    } else {

    }
    {
#line 150
    drm_err("vmw_ldu_commit_list", "Could not update cursor image\n");
    }
    __Cont: /* CIL Label */ 
#line 136
    __cil_tmp235 = (unsigned long )entry;
#line 136
    __cil_tmp236 = __cil_tmp235 + 2072;
#line 136
    __cil_tmp237 = *((struct list_head **)__cil_tmp236);
#line 136
    __mptr___5 = (struct list_head    *)__cil_tmp237;
#line 136
    __cil_tmp238 = (struct vmw_legacy_display_unit *)0;
#line 136
    __cil_tmp239 = (unsigned long )__cil_tmp238;
#line 136
    __cil_tmp240 = __cil_tmp239 + 2072;
#line 136
    __cil_tmp241 = (struct list_head *)__cil_tmp240;
#line 136
    __cil_tmp242 = (unsigned int )__cil_tmp241;
#line 136
    __cil_tmp243 = (char *)__mptr___5;
#line 136
    __cil_tmp244 = __cil_tmp243 - __cil_tmp242;
#line 136
    entry = (struct vmw_legacy_display_unit *)__cil_tmp244;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 156 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static int vmw_ldu_del_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ) 
{ struct vmw_legacy_display *ld ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct list_head    *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_framebuffer *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_framebuffer *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_framebuffer *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int (*__cil_tmp40)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_framebuffer *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void *__cil_tmp46 ;

  {
  {
#line 159
  __cil_tmp6 = (unsigned long )vmw_priv___0;
#line 159
  __cil_tmp7 = __cil_tmp6 + 2608;
#line 159
  ld = *((struct vmw_legacy_display **)__cil_tmp7);
#line 160
  __cil_tmp8 = (unsigned long )ldu;
#line 160
  __cil_tmp9 = __cil_tmp8 + 2072;
#line 160
  __cil_tmp10 = (struct list_head *)__cil_tmp9;
#line 160
  __cil_tmp11 = (struct list_head    *)__cil_tmp10;
#line 160
  tmp___7 = list_empty(__cil_tmp11);
  }
#line 160
  if (tmp___7) {
#line 161
    return (0);
  } else {

  }
  {
#line 164
  __cil_tmp12 = (unsigned long )ldu;
#line 164
  __cil_tmp13 = __cil_tmp12 + 2072;
#line 164
  __cil_tmp14 = (struct list_head *)__cil_tmp13;
#line 164
  list_del_init(__cil_tmp14);
#line 165
  __cil_tmp15 = (unsigned long )ld;
#line 165
  __cil_tmp16 = __cil_tmp15 + 16;
#line 165
  __cil_tmp17 = (unsigned long )ld;
#line 165
  __cil_tmp18 = __cil_tmp17 + 16;
#line 165
  __cil_tmp19 = *((unsigned int *)__cil_tmp18);
#line 165
  *((unsigned int *)__cil_tmp16) = __cil_tmp19 - 1U;
  }
  {
#line 165
  __cil_tmp20 = (unsigned long )ld;
#line 165
  __cil_tmp21 = __cil_tmp20 + 16;
#line 165
  __cil_tmp22 = *((unsigned int *)__cil_tmp21);
#line 165
  if (__cil_tmp22 == 0U) {
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 166
      __cil_tmp23 = (unsigned long )ld;
#line 166
      __cil_tmp24 = __cil_tmp23 + 24;
#line 166
      __cil_tmp25 = *((struct vmw_framebuffer **)__cil_tmp24);
#line 166
      __cil_tmp26 = ! __cil_tmp25;
#line 166
      __cil_tmp27 = ! __cil_tmp26;
#line 166
      __cil_tmp28 = ! __cil_tmp27;
#line 166
      __cil_tmp29 = (long )__cil_tmp28;
#line 166
      tmp___8 = ldv__builtin_expect(__cil_tmp29, 0L);
      }
#line 166
      if (tmp___8) {
        {
#line 166
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 166
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                               "i" (166), "i" (12UL));
          {
#line 166
          while (1) {
            while_continue___1: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 166
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {

      }
#line 166
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 167
    __cil_tmp30 = (unsigned long )ld;
#line 167
    __cil_tmp31 = __cil_tmp30 + 24;
#line 167
    __cil_tmp32 = *((struct vmw_framebuffer **)__cil_tmp31);
#line 167
    __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 167
    __cil_tmp34 = __cil_tmp33 + 128;
#line 167
    if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp34)) {
      {
#line 168
      __cil_tmp35 = (unsigned long )ld;
#line 168
      __cil_tmp36 = __cil_tmp35 + 24;
#line 168
      __cil_tmp37 = *((struct vmw_framebuffer **)__cil_tmp36);
#line 168
      __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 168
      __cil_tmp39 = __cil_tmp38 + 128;
#line 168
      __cil_tmp40 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp39);
#line 168
      __cil_tmp41 = (unsigned long )ld;
#line 168
      __cil_tmp42 = __cil_tmp41 + 24;
#line 168
      __cil_tmp43 = *((struct vmw_framebuffer **)__cil_tmp42);
#line 168
      (*__cil_tmp40)(__cil_tmp43);
      }
    } else {

    }
    }
#line 169
    __cil_tmp44 = (unsigned long )ld;
#line 169
    __cil_tmp45 = __cil_tmp44 + 24;
#line 169
    __cil_tmp46 = (void *)0;
#line 169
    *((struct vmw_framebuffer **)__cil_tmp45) = (struct vmw_framebuffer *)__cil_tmp46;
  } else {

  }
  }
#line 172
  return (0);
}
}
#line 175 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static int vmw_ldu_add_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ,
                              struct vmw_framebuffer *vfb ) 
{ struct vmw_legacy_display *ld ;
  struct vmw_legacy_display_unit *entry ;
  struct list_head *at ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_framebuffer *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_framebuffer *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct vmw_framebuffer *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int (*__cil_tmp37)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct vmw_framebuffer *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int (*__cil_tmp45)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  struct list_head    *__cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  struct vmw_legacy_display_unit *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct list_head *__cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  struct vmw_legacy_display_unit *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct list_head *__cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct list_head *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned int __cil_tmp93 ;

  {
#line 179
  __cil_tmp12 = (unsigned long )vmw_priv___0;
#line 179
  __cil_tmp13 = __cil_tmp12 + 2608;
#line 179
  ld = *((struct vmw_legacy_display **)__cil_tmp13);
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    __cil_tmp14 = (unsigned long )ld;
#line 183
    __cil_tmp15 = __cil_tmp14 + 16;
#line 183
    __cil_tmp16 = *((unsigned int *)__cil_tmp15);
#line 183
    if (! __cil_tmp16) {
      {
#line 183
      __cil_tmp17 = (unsigned long )ld;
#line 183
      __cil_tmp18 = __cil_tmp17 + 24;
#line 183
      if (*((struct vmw_framebuffer **)__cil_tmp18)) {
#line 183
        tmp___7 = 1;
      } else {
#line 183
        tmp___7 = 0;
      }
      }
    } else {
#line 183
      tmp___7 = 0;
    }
    }
    {
#line 183
    __cil_tmp19 = (long )tmp___7;
#line 183
    tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
    }
#line 183
    if (tmp___8) {
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (183), "i" (12UL));
        {
#line 183
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 183
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  __cil_tmp20 = (unsigned long )ld;
#line 184
  __cil_tmp21 = __cil_tmp20 + 24;
#line 184
  __cil_tmp22 = *((struct vmw_framebuffer **)__cil_tmp21);
#line 184
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 184
  __cil_tmp24 = (unsigned long )vfb;
#line 184
  if (__cil_tmp24 != __cil_tmp23) {
    {
#line 185
    __cil_tmp25 = (unsigned long )ld;
#line 185
    __cil_tmp26 = __cil_tmp25 + 24;
#line 185
    if (*((struct vmw_framebuffer **)__cil_tmp26)) {
      {
#line 185
      __cil_tmp27 = (unsigned long )ld;
#line 185
      __cil_tmp28 = __cil_tmp27 + 24;
#line 185
      __cil_tmp29 = *((struct vmw_framebuffer **)__cil_tmp28);
#line 185
      __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 185
      __cil_tmp31 = __cil_tmp30 + 128;
#line 185
      if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp31)) {
        {
#line 186
        __cil_tmp32 = (unsigned long )ld;
#line 186
        __cil_tmp33 = __cil_tmp32 + 24;
#line 186
        __cil_tmp34 = *((struct vmw_framebuffer **)__cil_tmp33);
#line 186
        __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 186
        __cil_tmp36 = __cil_tmp35 + 128;
#line 186
        __cil_tmp37 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp36);
#line 186
        __cil_tmp38 = (unsigned long )ld;
#line 186
        __cil_tmp39 = __cil_tmp38 + 24;
#line 186
        __cil_tmp40 = *((struct vmw_framebuffer **)__cil_tmp39);
#line 186
        (*__cil_tmp37)(__cil_tmp40);
        }
      } else {

      }
      }
    } else {

    }
    }
    {
#line 187
    __cil_tmp41 = (unsigned long )vfb;
#line 187
    __cil_tmp42 = __cil_tmp41 + 120;
#line 187
    if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp42)) {
      {
#line 188
      __cil_tmp43 = (unsigned long )vfb;
#line 188
      __cil_tmp44 = __cil_tmp43 + 120;
#line 188
      __cil_tmp45 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp44);
#line 188
      (*__cil_tmp45)(vfb);
      }
    } else {

    }
    }
#line 189
    __cil_tmp46 = (unsigned long )ld;
#line 189
    __cil_tmp47 = __cil_tmp46 + 24;
#line 189
    *((struct vmw_framebuffer **)__cil_tmp47) = vfb;
  } else {

  }
  }
  {
#line 192
  __cil_tmp48 = (unsigned long )ldu;
#line 192
  __cil_tmp49 = __cil_tmp48 + 2072;
#line 192
  __cil_tmp50 = (struct list_head *)__cil_tmp49;
#line 192
  __cil_tmp51 = (struct list_head    *)__cil_tmp50;
#line 192
  tmp___9 = list_empty(__cil_tmp51);
  }
#line 192
  if (tmp___9) {

  } else {
#line 193
    return (0);
  }
#line 195
  at = (struct list_head *)ld;
#line 196
  __cil_tmp52 = *((struct list_head **)ld);
#line 196
  __mptr = (struct list_head    *)__cil_tmp52;
#line 196
  __cil_tmp53 = (struct vmw_legacy_display_unit *)0;
#line 196
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 196
  __cil_tmp55 = __cil_tmp54 + 2072;
#line 196
  __cil_tmp56 = (struct list_head *)__cil_tmp55;
#line 196
  __cil_tmp57 = (unsigned int )__cil_tmp56;
#line 196
  __cil_tmp58 = (char *)__mptr;
#line 196
  __cil_tmp59 = __cil_tmp58 - __cil_tmp57;
#line 196
  entry = (struct vmw_legacy_display_unit *)__cil_tmp59;
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 196
    __cil_tmp60 = (struct list_head *)ld;
#line 196
    __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 196
    __cil_tmp62 = (unsigned long )entry;
#line 196
    __cil_tmp63 = __cil_tmp62 + 2072;
#line 196
    __cil_tmp64 = (struct list_head *)__cil_tmp63;
#line 196
    __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 196
    if (__cil_tmp65 != __cil_tmp61) {

    } else {
#line 196
      goto while_break___2;
    }
    }
    {
#line 197
    __cil_tmp66 = 0 + 2032;
#line 197
    __cil_tmp67 = (unsigned long )ldu;
#line 197
    __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
#line 197
    __cil_tmp69 = *((unsigned int *)__cil_tmp68);
#line 197
    __cil_tmp70 = 0 + 2032;
#line 197
    __cil_tmp71 = (unsigned long )entry;
#line 197
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 197
    __cil_tmp73 = *((unsigned int *)__cil_tmp72);
#line 197
    if (__cil_tmp73 > __cil_tmp69) {
#line 198
      goto while_break___2;
    } else {

    }
    }
#line 200
    __cil_tmp74 = (unsigned long )entry;
#line 200
    __cil_tmp75 = __cil_tmp74 + 2072;
#line 200
    at = (struct list_head *)__cil_tmp75;
#line 196
    __cil_tmp76 = (unsigned long )entry;
#line 196
    __cil_tmp77 = __cil_tmp76 + 2072;
#line 196
    __cil_tmp78 = *((struct list_head **)__cil_tmp77);
#line 196
    __mptr___0 = (struct list_head    *)__cil_tmp78;
#line 196
    __cil_tmp79 = (struct vmw_legacy_display_unit *)0;
#line 196
    __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 196
    __cil_tmp81 = __cil_tmp80 + 2072;
#line 196
    __cil_tmp82 = (struct list_head *)__cil_tmp81;
#line 196
    __cil_tmp83 = (unsigned int )__cil_tmp82;
#line 196
    __cil_tmp84 = (char *)__mptr___0;
#line 196
    __cil_tmp85 = __cil_tmp84 - __cil_tmp83;
#line 196
    entry = (struct vmw_legacy_display_unit *)__cil_tmp85;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 203
  __cil_tmp86 = (unsigned long )ldu;
#line 203
  __cil_tmp87 = __cil_tmp86 + 2072;
#line 203
  __cil_tmp88 = (struct list_head *)__cil_tmp87;
#line 203
  list_add(__cil_tmp88, at);
#line 205
  __cil_tmp89 = (unsigned long )ld;
#line 205
  __cil_tmp90 = __cil_tmp89 + 16;
#line 205
  __cil_tmp91 = (unsigned long )ld;
#line 205
  __cil_tmp92 = __cil_tmp91 + 16;
#line 205
  __cil_tmp93 = *((unsigned int *)__cil_tmp92);
#line 205
  *((unsigned int *)__cil_tmp90) = __cil_tmp93 + 1U;
  }
#line 207
  return (0);
}
}
#line 210 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static int vmw_ldu_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_legacy_display_unit *ldu ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  struct drm_crtc    *__mptr ;
  struct drm_framebuffer    *__mptr___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct drm_crtc *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_legacy_display_unit *__cil_tmp20 ;
  struct drm_crtc *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_framebuffer *__cil_tmp29 ;
  struct vmw_framebuffer *__cil_tmp30 ;
  struct drm_framebuffer *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  void *__cil_tmp35 ;
  struct drm_device *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  size_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  size_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct drm_connector *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct drm_connector **__cil_tmp50 ;
  struct drm_connector **__cil_tmp51 ;
  struct drm_connector *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct drm_connector **__cil_tmp56 ;
  struct drm_connector **__cil_tmp57 ;
  struct drm_connector *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct drm_connector *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct vmw_legacy_display *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct vmw_legacy_display *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  struct list_head    *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct vmw_legacy_display *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct vmw_framebuffer *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  size_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct drm_display_mode *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct drm_framebuffer *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  void *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  void *__cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned int __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  int __cil_tmp119 ;
  uint32_t __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  uint32_t __cil_tmp123 ;
  uint32_t __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned int __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  int __cil_tmp130 ;
  uint32_t __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  uint32_t __cil_tmp134 ;
  uint32_t __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  uint32_t __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;

  {
#line 221
  if (! set) {
#line 222
    return (-22);
  } else {

  }
  {
#line 224
  __cil_tmp15 = (unsigned long )set;
#line 224
  __cil_tmp16 = __cil_tmp15 + 24;
#line 224
  __cil_tmp17 = *((struct drm_crtc **)__cil_tmp16);
#line 224
  if (! __cil_tmp17) {
#line 225
    return (-22);
  } else {

  }
  }
#line 228
  __cil_tmp18 = (unsigned long )set;
#line 228
  __cil_tmp19 = __cil_tmp18 + 24;
#line 228
  crtc = *((struct drm_crtc **)__cil_tmp19);
#line 229
  __mptr = (struct drm_crtc    *)crtc;
#line 229
  __cil_tmp20 = (struct vmw_legacy_display_unit *)0;
#line 229
  __cil_tmp21 = (struct drm_crtc *)__cil_tmp20;
#line 229
  __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 229
  __cil_tmp23 = (char *)__mptr;
#line 229
  __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 229
  ldu = (struct vmw_legacy_display_unit *)__cil_tmp24;
  {
#line 230
  __cil_tmp25 = (unsigned long )set;
#line 230
  __cil_tmp26 = __cil_tmp25 + 16;
#line 230
  if (*((struct drm_framebuffer **)__cil_tmp26)) {
#line 230
    __cil_tmp27 = (unsigned long )set;
#line 230
    __cil_tmp28 = __cil_tmp27 + 16;
#line 230
    __cil_tmp29 = *((struct drm_framebuffer **)__cil_tmp28);
#line 230
    __mptr___0 = (struct drm_framebuffer    *)__cil_tmp29;
#line 230
    __cil_tmp30 = (struct vmw_framebuffer *)0;
#line 230
    __cil_tmp31 = (struct drm_framebuffer *)__cil_tmp30;
#line 230
    __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 230
    __cil_tmp33 = (char *)__mptr___0;
#line 230
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
#line 230
    vfb = (struct vmw_framebuffer *)__cil_tmp34;
  } else {
#line 230
    __cil_tmp35 = (void *)0;
#line 230
    vfb = (struct vmw_framebuffer *)__cil_tmp35;
  }
  }
  {
#line 231
  __cil_tmp36 = *((struct drm_device **)crtc);
#line 231
  dev_priv = vmw_priv(__cil_tmp36);
  }
  {
#line 233
  __cil_tmp37 = (unsigned long )set;
#line 233
  __cil_tmp38 = __cil_tmp37 + 56;
#line 233
  __cil_tmp39 = *((size_t *)__cil_tmp38);
#line 233
  if (__cil_tmp39 > 1UL) {
    {
#line 234
    drm_err("vmw_ldu_crtc_set_config", "to many connectors\n");
    }
#line 235
    return (-22);
  } else {

  }
  }
  {
#line 238
  __cil_tmp40 = (unsigned long )set;
#line 238
  __cil_tmp41 = __cil_tmp40 + 56;
#line 238
  __cil_tmp42 = *((size_t *)__cil_tmp41);
#line 238
  if (__cil_tmp42 == 1UL) {
    {
#line 238
    __cil_tmp43 = 0 + 616;
#line 238
    __cil_tmp44 = (unsigned long )ldu;
#line 238
    __cil_tmp45 = __cil_tmp44 + __cil_tmp43;
#line 238
    __cil_tmp46 = (struct drm_connector *)__cil_tmp45;
#line 238
    __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 238
    __cil_tmp48 = (unsigned long )set;
#line 238
    __cil_tmp49 = __cil_tmp48 + 48;
#line 238
    __cil_tmp50 = *((struct drm_connector ***)__cil_tmp49);
#line 238
    __cil_tmp51 = __cil_tmp50 + 0;
#line 238
    __cil_tmp52 = *__cil_tmp51;
#line 238
    __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 238
    if (__cil_tmp53 != __cil_tmp47) {
      {
#line 240
      __cil_tmp54 = (unsigned long )set;
#line 240
      __cil_tmp55 = __cil_tmp54 + 48;
#line 240
      __cil_tmp56 = *((struct drm_connector ***)__cil_tmp55);
#line 240
      __cil_tmp57 = __cil_tmp56 + 0;
#line 240
      __cil_tmp58 = *__cil_tmp57;
#line 240
      __cil_tmp59 = 0 + 616;
#line 240
      __cil_tmp60 = (unsigned long )ldu;
#line 240
      __cil_tmp61 = __cil_tmp60 + __cil_tmp59;
#line 240
      __cil_tmp62 = (struct drm_connector *)__cil_tmp61;
#line 240
      drm_err("vmw_ldu_crtc_set_config", "connector doesn\'t match %p %p\n", __cil_tmp58,
              __cil_tmp62);
      }
#line 242
      return (-22);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 246
  __cil_tmp63 = (unsigned long )dev_priv;
#line 246
  __cil_tmp64 = __cil_tmp63 + 2608;
#line 246
  __cil_tmp65 = *((struct vmw_legacy_display **)__cil_tmp64);
#line 246
  __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 246
  __cil_tmp67 = __cil_tmp66 + 24;
#line 246
  if (*((struct vmw_framebuffer **)__cil_tmp67)) {
#line 246
    if (vfb) {
      {
#line 246
      __cil_tmp68 = (unsigned long )dev_priv;
#line 246
      __cil_tmp69 = __cil_tmp68 + 2608;
#line 246
      __cil_tmp70 = *((struct vmw_legacy_display **)__cil_tmp69);
#line 246
      __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 246
      __cil_tmp72 = __cil_tmp71 + 16;
#line 246
      __cil_tmp73 = *((unsigned int *)__cil_tmp72);
#line 246
      if (__cil_tmp73 == 1U) {
        {
#line 246
        __cil_tmp74 = (unsigned long )ldu;
#line 246
        __cil_tmp75 = __cil_tmp74 + 2072;
#line 246
        __cil_tmp76 = (struct list_head *)__cil_tmp75;
#line 246
        __cil_tmp77 = (struct list_head    *)__cil_tmp76;
#line 246
        tmp___7 = list_empty(__cil_tmp77);
        }
#line 246
        if (tmp___7) {
#line 246
          goto _L;
        } else {

        }
      } else {
        _L: /* CIL Label */ 
        {
#line 246
        __cil_tmp78 = (unsigned long )vfb;
#line 246
        __cil_tmp79 = (unsigned long )dev_priv;
#line 246
        __cil_tmp80 = __cil_tmp79 + 2608;
#line 246
        __cil_tmp81 = *((struct vmw_legacy_display **)__cil_tmp80);
#line 246
        __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 246
        __cil_tmp83 = __cil_tmp82 + 24;
#line 246
        __cil_tmp84 = *((struct vmw_framebuffer **)__cil_tmp83);
#line 246
        __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 246
        if (__cil_tmp85 != __cil_tmp78) {
          {
#line 250
          drm_err("vmw_ldu_crtc_set_config", "Multiple framebuffers not supported\n");
          }
#line 251
          return (-22);
        } else {

        }
        }
      }
      }
    } else {

    }
  } else {

  }
  }
#line 255
  __cil_tmp86 = 0 + 616;
#line 255
  __cil_tmp87 = (unsigned long )ldu;
#line 255
  __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
#line 255
  connector = (struct drm_connector *)__cil_tmp88;
#line 256
  __cil_tmp89 = 0 + 544;
#line 256
  __cil_tmp90 = (unsigned long )ldu;
#line 256
  __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
#line 256
  encoder = (struct drm_encoder *)__cil_tmp91;
  {
#line 259
  __cil_tmp92 = (unsigned long )set;
#line 259
  __cil_tmp93 = __cil_tmp92 + 56;
#line 259
  __cil_tmp94 = *((size_t *)__cil_tmp93);
#line 259
  if (__cil_tmp94 == 0UL) {
#line 259
    goto _L___0;
  } else {
    {
#line 259
    __cil_tmp95 = (unsigned long )set;
#line 259
    __cil_tmp96 = __cil_tmp95 + 32;
#line 259
    __cil_tmp97 = *((struct drm_display_mode **)__cil_tmp96);
#line 259
    if (! __cil_tmp97) {
#line 259
      goto _L___0;
    } else {
      {
#line 259
      __cil_tmp98 = (unsigned long )set;
#line 259
      __cil_tmp99 = __cil_tmp98 + 16;
#line 259
      __cil_tmp100 = *((struct drm_framebuffer **)__cil_tmp99);
#line 259
      if (! __cil_tmp100) {
        _L___0: /* CIL Label */ 
        {
#line 261
        __cil_tmp101 = (unsigned long )connector;
#line 261
        __cil_tmp102 = __cil_tmp101 + 1208;
#line 261
        __cil_tmp103 = (void *)0;
#line 261
        *((struct drm_encoder **)__cil_tmp102) = (struct drm_encoder *)__cil_tmp103;
#line 262
        __cil_tmp104 = (unsigned long )encoder;
#line 262
        __cil_tmp105 = __cil_tmp104 + 48;
#line 262
        __cil_tmp106 = (void *)0;
#line 262
        *((struct drm_crtc **)__cil_tmp105) = (struct drm_crtc *)__cil_tmp106;
#line 263
        __cil_tmp107 = (unsigned long )crtc;
#line 263
        __cil_tmp108 = __cil_tmp107 + 32;
#line 263
        __cil_tmp109 = (void *)0;
#line 263
        *((struct drm_framebuffer **)__cil_tmp108) = (struct drm_framebuffer *)__cil_tmp109;
#line 265
        vmw_ldu_del_active(dev_priv, ldu);
#line 267
        tmp___8 = vmw_ldu_commit_list(dev_priv);
        }
#line 267
        return (tmp___8);
      } else {

      }
      }
    }
    }
  }
  }
#line 272
  __cil_tmp110 = (unsigned long )set;
#line 272
  __cil_tmp111 = __cil_tmp110 + 32;
#line 272
  mode = *((struct drm_display_mode **)__cil_tmp111);
#line 273
  __cil_tmp112 = (unsigned long )set;
#line 273
  __cil_tmp113 = __cil_tmp112 + 16;
#line 273
  fb = *((struct drm_framebuffer **)__cil_tmp113);
  {
#line 275
  __cil_tmp114 = (unsigned long )fb;
#line 275
  __cil_tmp115 = __cil_tmp114 + 72;
#line 275
  __cil_tmp116 = *((unsigned int *)__cil_tmp115);
#line 275
  __cil_tmp117 = (unsigned long )mode;
#line 275
  __cil_tmp118 = __cil_tmp117 + 68;
#line 275
  __cil_tmp119 = *((int *)__cil_tmp118);
#line 275
  __cil_tmp120 = (uint32_t )__cil_tmp119;
#line 275
  __cil_tmp121 = (unsigned long )set;
#line 275
  __cil_tmp122 = __cil_tmp121 + 40;
#line 275
  __cil_tmp123 = *((uint32_t *)__cil_tmp122);
#line 275
  __cil_tmp124 = __cil_tmp123 + __cil_tmp120;
#line 275
  if (__cil_tmp124 > __cil_tmp116) {
    {
#line 277
    drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
    }
#line 278
    return (-22);
  } else {
    {
#line 275
    __cil_tmp125 = (unsigned long )fb;
#line 275
    __cil_tmp126 = __cil_tmp125 + 76;
#line 275
    __cil_tmp127 = *((unsigned int *)__cil_tmp126);
#line 275
    __cil_tmp128 = (unsigned long )mode;
#line 275
    __cil_tmp129 = __cil_tmp128 + 88;
#line 275
    __cil_tmp130 = *((int *)__cil_tmp129);
#line 275
    __cil_tmp131 = (uint32_t )__cil_tmp130;
#line 275
    __cil_tmp132 = (unsigned long )set;
#line 275
    __cil_tmp133 = __cil_tmp132 + 44;
#line 275
    __cil_tmp134 = *((uint32_t *)__cil_tmp133);
#line 275
    __cil_tmp135 = __cil_tmp134 + __cil_tmp131;
#line 275
    if (__cil_tmp135 > __cil_tmp127) {
      {
#line 277
      drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
      }
#line 278
      return (-22);
    } else {

    }
    }
  }
  }
  {
#line 281
  vmw_fb_off(dev_priv);
#line 283
  __cil_tmp136 = (unsigned long )crtc;
#line 283
  __cil_tmp137 = __cil_tmp136 + 32;
#line 283
  *((struct drm_framebuffer **)__cil_tmp137) = fb;
#line 284
  __cil_tmp138 = (unsigned long )encoder;
#line 284
  __cil_tmp139 = __cil_tmp138 + 48;
#line 284
  *((struct drm_crtc **)__cil_tmp139) = crtc;
#line 285
  __cil_tmp140 = (unsigned long )connector;
#line 285
  __cil_tmp141 = __cil_tmp140 + 1208;
#line 285
  *((struct drm_encoder **)__cil_tmp141) = encoder;
#line 286
  __cil_tmp142 = (unsigned long )crtc;
#line 286
  __cil_tmp143 = __cil_tmp142 + 480;
#line 286
  __cil_tmp144 = (unsigned long )set;
#line 286
  __cil_tmp145 = __cil_tmp144 + 40;
#line 286
  __cil_tmp146 = *((uint32_t *)__cil_tmp145);
#line 286
  *((int *)__cil_tmp143) = (int )__cil_tmp146;
#line 287
  __cil_tmp147 = (unsigned long )crtc;
#line 287
  __cil_tmp148 = __cil_tmp147 + 484;
#line 287
  __cil_tmp149 = (unsigned long )set;
#line 287
  __cil_tmp150 = __cil_tmp149 + 44;
#line 287
  __cil_tmp151 = *((uint32_t *)__cil_tmp150);
#line 287
  *((int *)__cil_tmp148) = (int )__cil_tmp151;
#line 288
  __cil_tmp152 = (unsigned long )crtc;
#line 288
  __cil_tmp153 = __cil_tmp152 + 48;
#line 288
  *((struct drm_display_mode *)__cil_tmp153) = *mode;
#line 290
  vmw_ldu_add_active(dev_priv, ldu, vfb);
#line 292
  tmp___9 = vmw_ldu_commit_list(dev_priv);
  }
#line 292
  return (tmp___9);
}
}
#line 295 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static struct drm_crtc_funcs vmw_legacy_crtc_funcs  = 
#line 295
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, (void (*)(struct drm_crtc *crtc ))0,
    & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move, & vmw_du_crtc_gamma_set,
    & vmw_ldu_crtc_destroy, & vmw_ldu_crtc_set_config, (int (*)(struct drm_crtc *crtc ,
                                                                struct drm_framebuffer *fb ,
                                                                struct drm_pending_vblank_event *event ))0};
#line 310 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static void vmw_ldu_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder    *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_legacy_display_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_encoder *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_legacy_display_unit *__cil_tmp11 ;

  {
  {
#line 312
  __mptr = (struct drm_encoder    *)encoder;
#line 312
  __cil_tmp3 = 0 + 544;
#line 312
  __cil_tmp4 = (struct vmw_legacy_display_unit *)0;
#line 312
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 312
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
#line 312
  __cil_tmp7 = (struct drm_encoder *)__cil_tmp6;
#line 312
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 312
  __cil_tmp9 = (char *)__mptr;
#line 312
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 312
  __cil_tmp11 = (struct vmw_legacy_display_unit *)__cil_tmp10;
#line 312
  vmw_ldu_destroy(__cil_tmp11);
  }
#line 313
  return;
}
}
#line 315 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static struct drm_encoder_funcs vmw_legacy_encoder_funcs  =    {(void (*)(struct drm_encoder *encoder ))0, & vmw_ldu_encoder_destroy};
#line 323 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static void vmw_ldu_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector    *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_legacy_display_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_connector *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_legacy_display_unit *__cil_tmp11 ;

  {
  {
#line 325
  __mptr = (struct drm_connector    *)connector;
#line 325
  __cil_tmp3 = 0 + 616;
#line 325
  __cil_tmp4 = (struct vmw_legacy_display_unit *)0;
#line 325
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 325
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
#line 325
  __cil_tmp7 = (struct drm_connector *)__cil_tmp6;
#line 325
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 325
  __cil_tmp9 = (char *)__mptr;
#line 325
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 325
  __cil_tmp11 = (struct vmw_legacy_display_unit *)__cil_tmp10;
#line 325
  vmw_ldu_destroy(__cil_tmp11);
  }
#line 326
  return;
}
}
#line 328 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static struct drm_connector_funcs vmw_legacy_connector_funcs  = 
#line 328
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    (void (*)(struct drm_connector *connector ))0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes,
    & vmw_du_connector_set_property, & vmw_ldu_connector_destroy, (void (*)(struct drm_connector *connector ))0};
#line 338 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
static int vmw_ldu_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ struct vmw_legacy_display_unit *ldu ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct drm_connector_funcs    *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  struct drm_encoder_funcs    *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_crtc_funcs    *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct drm_property *__cil_tmp58 ;
  uint64_t __cil_tmp59 ;

  {
  {
#line 341
  __cil_tmp9 = (unsigned long )dev_priv;
#line 341
  __cil_tmp10 = __cil_tmp9 + 2088;
#line 341
  dev = *((struct drm_device **)__cil_tmp10);
#line 346
  tmp___7 = kzalloc(2088UL, 208U);
#line 346
  ldu = (struct vmw_legacy_display_unit *)tmp___7;
  }
#line 347
  if (! ldu) {
#line 348
    return (-12);
  } else {

  }
  {
#line 350
  __cil_tmp11 = 0 + 2032;
#line 350
  __cil_tmp12 = (unsigned long )ldu;
#line 350
  __cil_tmp13 = __cil_tmp12 + __cil_tmp11;
#line 350
  *((unsigned int *)__cil_tmp13) = unit;
#line 351
  crtc = (struct drm_crtc *)ldu;
#line 352
  __cil_tmp14 = 0 + 544;
#line 352
  __cil_tmp15 = (unsigned long )ldu;
#line 352
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
#line 352
  encoder = (struct drm_encoder *)__cil_tmp16;
#line 353
  __cil_tmp17 = 0 + 616;
#line 353
  __cil_tmp18 = (unsigned long )ldu;
#line 353
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 353
  connector = (struct drm_connector *)__cil_tmp19;
#line 355
  __cil_tmp20 = (unsigned long )ldu;
#line 355
  __cil_tmp21 = __cil_tmp20 + 2072;
#line 355
  __cil_tmp22 = (struct list_head *)__cil_tmp21;
#line 355
  INIT_LIST_HEAD(__cil_tmp22);
#line 357
  __cil_tmp23 = 0 + 2044;
#line 357
  __cil_tmp24 = (unsigned long )ldu;
#line 357
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
#line 357
  __cil_tmp26 = unit == 0U;
#line 357
  *((bool *)__cil_tmp25) = (bool )__cil_tmp26;
#line 358
  __cil_tmp27 = 0 + 2036;
#line 358
  __cil_tmp28 = (unsigned long )ldu;
#line 358
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
#line 358
  __cil_tmp30 = (unsigned long )dev_priv;
#line 358
  __cil_tmp31 = __cil_tmp30 + 2132;
#line 358
  *((unsigned int *)__cil_tmp29) = *((uint32_t *)__cil_tmp31);
#line 359
  __cil_tmp32 = 0 + 2040;
#line 359
  __cil_tmp33 = (unsigned long )ldu;
#line 359
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 359
  __cil_tmp35 = (unsigned long )dev_priv;
#line 359
  __cil_tmp36 = __cil_tmp35 + 2136;
#line 359
  *((unsigned int *)__cil_tmp34) = *((uint32_t *)__cil_tmp36);
#line 360
  __cil_tmp37 = 0 + 2048;
#line 360
  __cil_tmp38 = (unsigned long )ldu;
#line 360
  __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
#line 360
  __cil_tmp40 = (void *)0;
#line 360
  *((struct drm_display_mode **)__cil_tmp39) = (struct drm_display_mode *)__cil_tmp40;
#line 361
  __cil_tmp41 = 0 + 2064;
#line 361
  __cil_tmp42 = (unsigned long )ldu;
#line 361
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
#line 361
  *((bool *)__cil_tmp43) = (bool )1;
#line 363
  __cil_tmp44 = (struct drm_connector_funcs    *)(& vmw_legacy_connector_funcs);
#line 363
  drm_connector_init(dev, connector, __cil_tmp44, 15);
#line 365
  __cil_tmp45 = (unsigned long )connector;
#line 365
  __cil_tmp46 = __cil_tmp45 + 840;
#line 365
  __cil_tmp47 = (bool )1;
#line 365
  *((enum drm_connector_status *)__cil_tmp46) = vmw_du_connector_detect(connector,
                                                                        __cil_tmp47);
#line 367
  __cil_tmp48 = (struct drm_encoder_funcs    *)(& vmw_legacy_encoder_funcs);
#line 367
  drm_encoder_init(dev, encoder, __cil_tmp48, 5);
#line 369
  drm_mode_connector_attach_encoder(connector, encoder);
#line 370
  __cil_tmp49 = (unsigned long )encoder;
#line 370
  __cil_tmp50 = __cil_tmp49 + 36;
#line 370
  __cil_tmp51 = 1 << unit;
#line 370
  *((uint32_t *)__cil_tmp50) = (uint32_t )__cil_tmp51;
#line 371
  __cil_tmp52 = (unsigned long )encoder;
#line 371
  __cil_tmp53 = __cil_tmp52 + 40;
#line 371
  *((uint32_t *)__cil_tmp53) = (uint32_t )0;
#line 373
  __cil_tmp54 = (struct drm_crtc_funcs    *)(& vmw_legacy_crtc_funcs);
#line 373
  drm_crtc_init(dev, crtc, __cil_tmp54);
#line 375
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 377
  __cil_tmp55 = 1152 + 648;
#line 377
  __cil_tmp56 = (unsigned long )dev;
#line 377
  __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
#line 377
  __cil_tmp58 = *((struct drm_property **)__cil_tmp57);
#line 377
  __cil_tmp59 = (uint64_t )1;
#line 377
  drm_connector_attach_property(connector, __cil_tmp58, __cil_tmp59);
  }
#line 381
  return (0);
}
}
#line 384 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_legacy_display *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_legacy_display *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_legacy_display *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_legacy_display *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_legacy_display *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_legacy_display *__cil_tmp44 ;
  void    *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;

  {
#line 386
  __cil_tmp6 = (unsigned long )dev_priv;
#line 386
  __cil_tmp7 = __cil_tmp6 + 2088;
#line 386
  dev = *((struct drm_device **)__cil_tmp7);
  {
#line 389
  __cil_tmp8 = (unsigned long )dev_priv;
#line 389
  __cil_tmp9 = __cil_tmp8 + 2608;
#line 389
  if (*((struct vmw_legacy_display **)__cil_tmp9)) {
    {
#line 390
    printk("<6>[drm] ldu system already on\n");
    }
#line 391
    return (-22);
  } else {

  }
  }
  {
#line 394
  tmp___7 = kmalloc(32UL, 208U);
#line 394
  __cil_tmp10 = (unsigned long )dev_priv;
#line 394
  __cil_tmp11 = __cil_tmp10 + 2608;
#line 394
  *((struct vmw_legacy_display **)__cil_tmp11) = (struct vmw_legacy_display *)tmp___7;
  }
  {
#line 395
  __cil_tmp12 = (unsigned long )dev_priv;
#line 395
  __cil_tmp13 = __cil_tmp12 + 2608;
#line 395
  __cil_tmp14 = *((struct vmw_legacy_display **)__cil_tmp13);
#line 395
  if (! __cil_tmp14) {
#line 396
    return (-12);
  } else {

  }
  }
  {
#line 398
  __cil_tmp15 = (unsigned long )dev_priv;
#line 398
  __cil_tmp16 = __cil_tmp15 + 2608;
#line 398
  __cil_tmp17 = *((struct vmw_legacy_display **)__cil_tmp16);
#line 398
  __cil_tmp18 = (struct list_head *)__cil_tmp17;
#line 398
  INIT_LIST_HEAD(__cil_tmp18);
#line 399
  __cil_tmp19 = (unsigned long )dev_priv;
#line 399
  __cil_tmp20 = __cil_tmp19 + 2608;
#line 399
  __cil_tmp21 = *((struct vmw_legacy_display **)__cil_tmp20);
#line 399
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 399
  __cil_tmp23 = __cil_tmp22 + 16;
#line 399
  *((unsigned int *)__cil_tmp23) = 0U;
#line 400
  __cil_tmp24 = (unsigned long )dev_priv;
#line 400
  __cil_tmp25 = __cil_tmp24 + 2608;
#line 400
  __cil_tmp26 = *((struct vmw_legacy_display **)__cil_tmp25);
#line 400
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 400
  __cil_tmp28 = __cil_tmp27 + 20;
#line 400
  *((unsigned int *)__cil_tmp28) = 0U;
#line 401
  __cil_tmp29 = (unsigned long )dev_priv;
#line 401
  __cil_tmp30 = __cil_tmp29 + 2608;
#line 401
  __cil_tmp31 = *((struct vmw_legacy_display **)__cil_tmp30);
#line 401
  __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 401
  __cil_tmp33 = __cil_tmp32 + 24;
#line 401
  __cil_tmp34 = (void *)0;
#line 401
  *((struct vmw_framebuffer **)__cil_tmp33) = (struct vmw_framebuffer *)__cil_tmp34;
  }
  {
#line 404
  __cil_tmp35 = (unsigned long )dev_priv;
#line 404
  __cil_tmp36 = __cil_tmp35 + 2156;
#line 404
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 404
  if (__cil_tmp37 & 65536U) {
    {
#line 405
    ret = drm_vblank_init(dev, 8);
    }
  } else {
    {
#line 407
    ret = drm_vblank_init(dev, 1);
    }
  }
  }
#line 408
  if (ret != 0) {
#line 409
    goto err_free;
  } else {

  }
  {
#line 411
  ret = drm_mode_create_dirty_info_property(dev);
  }
#line 412
  if (ret != 0) {
#line 413
    goto err_vblank_cleanup;
  } else {

  }
  {
#line 415
  __cil_tmp38 = (unsigned long )dev_priv;
#line 415
  __cil_tmp39 = __cil_tmp38 + 2156;
#line 415
  __cil_tmp40 = *((uint32_t *)__cil_tmp39);
#line 415
  if (__cil_tmp40 & 65536U) {
#line 416
    i = 0;
    {
#line 416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 416
      if (i < 8) {

      } else {
#line 416
        goto while_break;
      }
      {
#line 417
      __cil_tmp41 = (unsigned int )i;
#line 417
      vmw_ldu_init(dev_priv, __cil_tmp41);
#line 416
      i = i + 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 419
    vmw_ldu_init(dev_priv, 0U);
    }
  }
  }
#line 421
  return (0);
  err_vblank_cleanup: 
  {
#line 424
  drm_vblank_cleanup(dev);
  }
  err_free: 
  {
#line 426
  __cil_tmp42 = (unsigned long )dev_priv;
#line 426
  __cil_tmp43 = __cil_tmp42 + 2608;
#line 426
  __cil_tmp44 = *((struct vmw_legacy_display **)__cil_tmp43);
#line 426
  __cil_tmp45 = (void    *)__cil_tmp44;
#line 426
  kfree(__cil_tmp45);
#line 427
  __cil_tmp46 = (unsigned long )dev_priv;
#line 427
  __cil_tmp47 = __cil_tmp46 + 2608;
#line 427
  __cil_tmp48 = (void *)0;
#line 427
  *((struct vmw_legacy_display **)__cil_tmp47) = (struct vmw_legacy_display *)__cil_tmp48;
  }
#line 428
  return (ret);
}
}
#line 431 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_legacy_display *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct vmw_legacy_display *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct list_head    *__cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_legacy_display *__cil_tmp19 ;
  void    *__cil_tmp20 ;

  {
#line 433
  __cil_tmp6 = (unsigned long )dev_priv;
#line 433
  __cil_tmp7 = __cil_tmp6 + 2088;
#line 433
  dev = *((struct drm_device **)__cil_tmp7);
  {
#line 435
  __cil_tmp8 = (unsigned long )dev_priv;
#line 435
  __cil_tmp9 = __cil_tmp8 + 2608;
#line 435
  __cil_tmp10 = *((struct vmw_legacy_display **)__cil_tmp9);
#line 435
  if (! __cil_tmp10) {
#line 436
    return (-38);
  } else {

  }
  }
  {
#line 438
  drm_vblank_cleanup(dev);
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    __cil_tmp11 = (unsigned long )dev_priv;
#line 440
    __cil_tmp12 = __cil_tmp11 + 2608;
#line 440
    __cil_tmp13 = *((struct vmw_legacy_display **)__cil_tmp12);
#line 440
    __cil_tmp14 = (struct list_head *)__cil_tmp13;
#line 440
    __cil_tmp15 = (struct list_head    *)__cil_tmp14;
#line 440
    tmp___7 = list_empty(__cil_tmp15);
    }
#line 440
    if (tmp___7) {
#line 440
      tmp___8 = 0;
    } else {
#line 440
      tmp___8 = 1;
    }
    {
#line 440
    __cil_tmp16 = (long )tmp___8;
#line 440
    tmp___9 = ldv__builtin_expect(__cil_tmp16, 0L);
    }
#line 440
    if (tmp___9) {
      {
#line 440
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 440
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (440), "i" (12UL));
        {
#line 440
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 440
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 440
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  __cil_tmp17 = (unsigned long )dev_priv;
#line 442
  __cil_tmp18 = __cil_tmp17 + 2608;
#line 442
  __cil_tmp19 = *((struct vmw_legacy_display **)__cil_tmp18);
#line 442
  __cil_tmp20 = (void    *)__cil_tmp19;
#line 442
  kfree(__cil_tmp20);
  }
#line 444
  return (0);
}
}
#line 478 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"
void ldv_main10_sequence_infinite_withcheck_stateful(void) 
{ struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 540
  LDV_IN_INTERRUPT = 1;
#line 549
  ldv_initialize();
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 557
    if (tmp___8) {

    } else {
#line 557
      goto while_break;
    }
    {
#line 560
    tmp___7 = __VERIFIER_nondet_int();
    }
#line 562
    if (tmp___7 == 0) {
#line 562
      goto case_0;
    } else
#line 585
    if (tmp___7 == 1) {
#line 585
      goto case_1;
    } else
#line 608
    if (tmp___7 == 2) {
#line 608
      goto case_2;
    } else
#line 631
    if (tmp___7 == 3) {
#line 631
      goto case_3;
    } else {
      {
#line 654
      goto switch_default;
#line 560
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 577
        vmw_ldu_crtc_destroy(var_group1);
        }
#line 584
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 600
        vmw_ldu_crtc_set_config(var_group2);
        }
#line 607
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 623
        vmw_ldu_encoder_destroy(var_group3);
        }
#line 630
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 646
        vmw_ldu_connector_destroy(var_group4);
        }
#line 653
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 654
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  ldv_check_final_state();
  }
#line 666
  return;
}
}
#line 50 "include/drm/drm_global.h"
extern int drm_global_item_ref(struct drm_global_reference *ref ) ;
#line 51
extern void drm_global_item_unref(struct drm_global_reference *ref ) ;
#line 702 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_mmap(struct file *filp , struct vm_area_struct *vma , struct ttm_bo_device *bdev ) ;
#line 148 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_init(struct ttm_mem_global *glob ) ;
#line 149
extern void ttm_mem_global_release(struct ttm_mem_global *glob ) ;
#line 747 "include/drm/ttm/ttm_bo_driver.h"
extern void ttm_bo_global_release(struct drm_global_reference *ref ) ;
#line 748
extern int ttm_bo_global_init(struct drm_global_reference *ref ) ;
#line 31 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c"
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  long tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct drm_minor *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_device *__cil_tmp22 ;
  struct ttm_bo_device *__cil_tmp23 ;

  {
  {
#line 36
  __cil_tmp7 = (unsigned long )vma;
#line 36
  __cil_tmp8 = __cil_tmp7 + 144;
#line 36
  __cil_tmp9 = *((unsigned long *)__cil_tmp8);
#line 36
  __cil_tmp10 = __cil_tmp9 < 1048576UL;
#line 36
  __cil_tmp11 = ! __cil_tmp10;
#line 36
  __cil_tmp12 = ! __cil_tmp11;
#line 36
  __cil_tmp13 = (long )__cil_tmp12;
#line 36
  tmp___7 = ldv__builtin_expect(__cil_tmp13, 0L);
  }
#line 36
  if (tmp___7) {
    {
#line 37
    drm_err("vmw_mmap", "Illegal attempt to mmap old fifo space.\n");
    }
#line 38
    return (-22);
  } else {

  }
  {
#line 41
  __cil_tmp14 = (unsigned long )filp;
#line 41
  __cil_tmp15 = __cil_tmp14 + 200;
#line 41
  __cil_tmp16 = *((void **)__cil_tmp15);
#line 41
  file_priv = (struct drm_file *)__cil_tmp16;
#line 42
  __cil_tmp17 = (unsigned long )file_priv;
#line 42
  __cil_tmp18 = __cil_tmp17 + 40;
#line 42
  __cil_tmp19 = *((struct drm_minor **)__cil_tmp18);
#line 42
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 42
  __cil_tmp21 = __cil_tmp20 + 784;
#line 42
  __cil_tmp22 = *((struct drm_device **)__cil_tmp21);
#line 42
  dev_priv = vmw_priv(__cil_tmp22);
#line 43
  __cil_tmp23 = (struct ttm_bo_device *)dev_priv;
#line 43
  tmp___8 = ttm_bo_mmap(filp, vma, __cil_tmp23);
  }
#line 43
  return (tmp___8);
}
}
#line 46 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c"
static int vmw_ttm_mem_global_init(struct drm_global_reference *ref ) 
{ int tmp___7 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct ttm_mem_global *__cil_tmp6 ;

  {
  {
#line 48
  printk("<6>[drm] global init.\n");
#line 49
  __cil_tmp3 = (unsigned long )ref;
#line 49
  __cil_tmp4 = __cil_tmp3 + 16;
#line 49
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 49
  __cil_tmp6 = (struct ttm_mem_global *)__cil_tmp5;
#line 49
  tmp___7 = ttm_mem_global_init(__cil_tmp6);
  }
#line 49
  return (tmp___7);
}
}
#line 52 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c"
static void vmw_ttm_mem_global_release(struct drm_global_reference *ref ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;
  struct ttm_mem_global *__cil_tmp5 ;

  {
  {
#line 54
  __cil_tmp2 = (unsigned long )ref;
#line 54
  __cil_tmp3 = __cil_tmp2 + 16;
#line 54
  __cil_tmp4 = *((void **)__cil_tmp3);
#line 54
  __cil_tmp5 = (struct ttm_mem_global *)__cil_tmp4;
#line 54
  ttm_mem_global_release(__cil_tmp5);
  }
#line 55
  return;
}
}
#line 57 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c"
int vmw_ttm_global_init(struct vmw_private *dev_priv ) 
{ struct drm_global_reference *global_ref ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct drm_global_reference *__cil_tmp39 ;

  {
  {
#line 62
  __cil_tmp6 = (unsigned long )dev_priv;
#line 62
  __cil_tmp7 = __cil_tmp6 + 1816;
#line 62
  global_ref = (struct drm_global_reference *)__cil_tmp7;
#line 63
  *((enum drm_global_types *)global_ref) = (enum drm_global_types )0;
#line 64
  __cil_tmp8 = (unsigned long )global_ref;
#line 64
  __cil_tmp9 = __cil_tmp8 + 8;
#line 64
  *((size_t *)__cil_tmp9) = 216UL;
#line 65
  __cil_tmp10 = (unsigned long )global_ref;
#line 65
  __cil_tmp11 = __cil_tmp10 + 24;
#line 65
  *((int (**)(struct drm_global_reference * ))__cil_tmp11) = & vmw_ttm_mem_global_init;
#line 66
  __cil_tmp12 = (unsigned long )global_ref;
#line 66
  __cil_tmp13 = __cil_tmp12 + 32;
#line 66
  *((void (**)(struct drm_global_reference * ))__cil_tmp13) = & vmw_ttm_mem_global_release;
#line 68
  ret = drm_global_item_ref(global_ref);
#line 69
  __cil_tmp14 = ret != 0;
#line 69
  __cil_tmp15 = ! __cil_tmp14;
#line 69
  __cil_tmp16 = ! __cil_tmp15;
#line 69
  __cil_tmp17 = (long )__cil_tmp16;
#line 69
  tmp___7 = ldv__builtin_expect(__cil_tmp17, 0L);
  }
#line 69
  if (tmp___7) {
    {
#line 70
    drm_err("vmw_ttm_global_init", "Failed setting up TTM memory accounting.\n");
    }
#line 71
    return (ret);
  } else {

  }
  {
#line 74
  __cil_tmp18 = 1768 + 40;
#line 74
  __cil_tmp19 = (unsigned long )dev_priv;
#line 74
  __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
#line 74
  __cil_tmp21 = 1816 + 16;
#line 74
  __cil_tmp22 = (unsigned long )dev_priv;
#line 74
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 74
  __cil_tmp24 = *((void **)__cil_tmp23);
#line 74
  *((struct ttm_mem_global **)__cil_tmp20) = (struct ttm_mem_global *)__cil_tmp24;
#line 76
  __cil_tmp25 = (unsigned long )dev_priv;
#line 76
  __cil_tmp26 = __cil_tmp25 + 1768;
#line 76
  global_ref = (struct drm_global_reference *)__cil_tmp26;
#line 77
  *((enum drm_global_types *)global_ref) = (enum drm_global_types )1;
#line 78
  __cil_tmp27 = (unsigned long )global_ref;
#line 78
  __cil_tmp28 = __cil_tmp27 + 8;
#line 78
  *((size_t *)__cil_tmp28) = 224UL;
#line 79
  __cil_tmp29 = (unsigned long )global_ref;
#line 79
  __cil_tmp30 = __cil_tmp29 + 24;
#line 79
  *((int (**)(struct drm_global_reference * ))__cil_tmp30) = & ttm_bo_global_init;
#line 80
  __cil_tmp31 = (unsigned long )global_ref;
#line 80
  __cil_tmp32 = __cil_tmp31 + 32;
#line 80
  *((void (**)(struct drm_global_reference * ))__cil_tmp32) = & ttm_bo_global_release;
#line 81
  ret = drm_global_item_ref(global_ref);
#line 83
  __cil_tmp33 = ret != 0;
#line 83
  __cil_tmp34 = ! __cil_tmp33;
#line 83
  __cil_tmp35 = ! __cil_tmp34;
#line 83
  __cil_tmp36 = (long )__cil_tmp35;
#line 83
  tmp___8 = ldv__builtin_expect(__cil_tmp36, 0L);
  }
#line 83
  if (tmp___8) {
    {
#line 84
    drm_err("vmw_ttm_global_init", "Failed setting up TTM buffer objects.\n");
    }
#line 85
    goto out_no_bo;
  } else {

  }
#line 88
  return (0);
  out_no_bo: 
  {
#line 90
  __cil_tmp37 = (unsigned long )dev_priv;
#line 90
  __cil_tmp38 = __cil_tmp37 + 1816;
#line 90
  __cil_tmp39 = (struct drm_global_reference *)__cil_tmp38;
#line 90
  drm_global_item_unref(__cil_tmp39);
  }
#line 91
  return (ret);
}
}
#line 94 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c"
void vmw_ttm_global_release(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct drm_global_reference *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_global_reference *__cil_tmp7 ;

  {
  {
#line 96
  __cil_tmp2 = (unsigned long )dev_priv;
#line 96
  __cil_tmp3 = __cil_tmp2 + 1768;
#line 96
  __cil_tmp4 = (struct drm_global_reference *)__cil_tmp3;
#line 96
  drm_global_item_unref(__cil_tmp4);
#line 97
  __cil_tmp5 = (unsigned long )dev_priv;
#line 97
  __cil_tmp6 = __cil_tmp5 + 1816;
#line 97
  __cil_tmp7 = (struct drm_global_reference *)__cil_tmp6;
#line 97
  drm_global_item_unref(__cil_tmp7);
  }
#line 98
  return;
}
}
#line 452 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) ;
#line 455
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) ;
#line 73 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
__inline static void fill_escape(struct vmw_escape_header *header , uint32_t size )  __attribute__((__no_instrument_function__)) ;
#line 73 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
__inline static void fill_escape(struct vmw_escape_header *header , uint32_t size ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
#line 76
  *((uint32_t *)header) = (uint32_t )33;
#line 77
  __cil_tmp3 = (unsigned long )header;
#line 77
  __cil_tmp4 = __cil_tmp3 + 4;
#line 77
  *((uint32 *)__cil_tmp4) = (uint32 )0;
#line 78
  __cil_tmp5 = 4 + 4;
#line 78
  __cil_tmp6 = (unsigned long )header;
#line 78
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
#line 78
  *((uint32 *)__cil_tmp7) = size;
#line 79
  return;
}
}
#line 81
__inline static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id )  __attribute__((__no_instrument_function__)) ;
#line 81 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
__inline static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id ) 
{ struct vmw_escape_header *__cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
  {
#line 84
  __cil_tmp3 = (struct vmw_escape_header *)cmd;
#line 84
  __cil_tmp4 = (uint32_t )8UL;
#line 84
  fill_escape(__cil_tmp3, __cil_tmp4);
#line 85
  __cil_tmp5 = (unsigned long )cmd;
#line 85
  __cil_tmp6 = __cil_tmp5 + 12;
#line 85
  *((uint32 *)__cil_tmp6) = (uint32 )131074;
#line 86
  __cil_tmp7 = 12 + 4;
#line 86
  __cil_tmp8 = (unsigned long )cmd;
#line 86
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
#line 86
  *((uint32 *)__cil_tmp9) = stream_id;
  }
#line 87
  return;
}
}
#line 95 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static int vmw_overlay_send_put(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_escape_video_flush *flush ;
  size_t fifo_size ;
  bool have_so ;
  int tmp___7 ;
  int i ;
  int num_items ;
  SVGAGuestPtr ptr ;
  struct __anonstruct_cmds_440 *cmds ;
  struct __anonstruct_items_442 *items ;
  void *tmp___8 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  struct __anonstruct_cmds_440 *__cil_tmp21 ;
  struct __anonstruct_items_442 *__cil_tmp22 ;
  struct vmw_escape_header *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct __anonstruct_items_442 *__cil_tmp33 ;
  struct ttm_buffer_object *__cil_tmp34 ;
  struct ttm_buffer_object    *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32 __cil_tmp41 ;
  struct __anonstruct_items_442 *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct __anonstruct_items_442 *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct __anonstruct_items_442 *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct __anonstruct_items_442 *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int32_t __cil_tmp59 ;
  struct __anonstruct_items_442 *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct __anonstruct_items_442 *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct __anonstruct_items_442 *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct __anonstruct_items_442 *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct __anonstruct_items_442 *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  int32_t __cil_tmp85 ;
  struct __anonstruct_items_442 *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  int32_t __cil_tmp92 ;
  struct __anonstruct_items_442 *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct __anonstruct_items_442 *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  struct __anonstruct_items_442 *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  int32_t __cil_tmp110 ;
  struct __anonstruct_items_442 *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  int32_t __cil_tmp117 ;
  struct __anonstruct_items_442 *__cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  struct __anonstruct_items_442 *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  struct __anonstruct_items_442 *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  struct __anonstruct_items_442 *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  struct __anonstruct_items_442 *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  struct __anonstruct_items_442 *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  SVGAGuestPtr *__cil_tmp154 ;
  struct __anonstruct_items_442 *__cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  uint32_t __cil_tmp159 ;

  {
  {
#line 102
  __cil_tmp15 = (unsigned long )dev_priv;
#line 102
  __cil_tmp16 = __cil_tmp15 + 2616;
#line 102
  if (*((struct vmw_screen_object_display **)__cil_tmp16)) {
#line 102
    tmp___7 = 1;
  } else {
#line 102
    tmp___7 = 0;
  }
  }
#line 102
  have_so = (bool )tmp___7;
#line 119
  if (have_so) {
#line 120
    num_items = 21;
  } else {
#line 122
    num_items = 19;
  }
  {
#line 124
  __cil_tmp17 = (unsigned long )num_items;
#line 124
  __cil_tmp18 = 8UL * __cil_tmp17;
#line 124
  __cil_tmp19 = 20UL + 20UL;
#line 124
  fifo_size = __cil_tmp19 + __cil_tmp18;
#line 126
  __cil_tmp20 = (uint32_t )fifo_size;
#line 126
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp20);
#line 126
  cmds = (struct __anonstruct_cmds_440 *)tmp___8;
  }
#line 128
  if (! cmds) {
#line 129
    return (-12);
  } else {

  }
  {
#line 131
  __cil_tmp21 = cmds + 1;
#line 131
  items = (struct __anonstruct_items_442 *)__cil_tmp21;
#line 132
  __cil_tmp22 = items + num_items;
#line 132
  flush = (struct vmw_escape_video_flush *)__cil_tmp22;
#line 135
  __cil_tmp23 = (struct vmw_escape_header *)cmds;
#line 135
  __cil_tmp24 = num_items + 1;
#line 135
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 135
  __cil_tmp26 = 8UL * __cil_tmp25;
#line 135
  __cil_tmp27 = (uint32_t )__cil_tmp26;
#line 135
  fill_escape(__cil_tmp23, __cil_tmp27);
#line 137
  __cil_tmp28 = (unsigned long )cmds;
#line 137
  __cil_tmp29 = __cil_tmp28 + 12;
#line 137
  *((uint32_t *)__cil_tmp29) = (uint32_t )131073;
#line 138
  __cil_tmp30 = 12 + 4;
#line 138
  __cil_tmp31 = (unsigned long )cmds;
#line 138
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
#line 138
  *((uint32_t *)__cil_tmp32) = *((uint32_t *)arg);
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (i < num_items) {

    } else {
#line 141
      goto while_break;
    }
#line 142
    __cil_tmp33 = items + i;
#line 142
    *((uint32_t *)__cil_tmp33) = (uint32_t )i;
#line 141
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  __cil_tmp34 = (struct ttm_buffer_object *)buf;
#line 144
  __cil_tmp35 = (struct ttm_buffer_object    *)__cil_tmp34;
#line 144
  vmw_bo_get_guest_ptr(__cil_tmp35, & ptr);
#line 145
  __cil_tmp36 = (unsigned long )(& ptr) + 4;
#line 145
  __cil_tmp37 = (unsigned long )arg;
#line 145
  __cil_tmp38 = __cil_tmp37 + 20;
#line 145
  __cil_tmp39 = *((uint32_t *)__cil_tmp38);
#line 145
  __cil_tmp40 = (unsigned long )(& ptr) + 4;
#line 145
  __cil_tmp41 = *((uint32 *)__cil_tmp40);
#line 145
  *((uint32 *)__cil_tmp36) = __cil_tmp41 + __cil_tmp39;
#line 147
  __cil_tmp42 = items + 0;
#line 147
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 147
  __cil_tmp44 = __cil_tmp43 + 4;
#line 147
  *((uint32_t *)__cil_tmp44) = (uint32_t )1;
#line 148
  __cil_tmp45 = items + 1;
#line 148
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 148
  __cil_tmp47 = __cil_tmp46 + 4;
#line 148
  __cil_tmp48 = (unsigned long )arg;
#line 148
  __cil_tmp49 = __cil_tmp48 + 8;
#line 148
  *((uint32_t *)__cil_tmp47) = *((uint32_t *)__cil_tmp49);
#line 149
  __cil_tmp50 = items + 2;
#line 149
  __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 149
  __cil_tmp52 = __cil_tmp51 + 4;
#line 149
  __cil_tmp53 = (unsigned long )(& ptr) + 4;
#line 149
  *((uint32_t *)__cil_tmp52) = *((uint32 *)__cil_tmp53);
#line 150
  __cil_tmp54 = items + 3;
#line 150
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 150
  __cil_tmp56 = __cil_tmp55 + 4;
#line 150
  __cil_tmp57 = (unsigned long )arg;
#line 150
  __cil_tmp58 = __cil_tmp57 + 24;
#line 150
  __cil_tmp59 = *((int32_t *)__cil_tmp58);
#line 150
  *((uint32_t *)__cil_tmp56) = (uint32_t )__cil_tmp59;
#line 151
  __cil_tmp60 = items + 4;
#line 151
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 151
  __cil_tmp62 = __cil_tmp61 + 4;
#line 151
  __cil_tmp63 = (unsigned long )arg;
#line 151
  __cil_tmp64 = __cil_tmp63 + 12;
#line 151
  *((uint32_t *)__cil_tmp62) = *((uint32_t *)__cil_tmp64);
#line 152
  __cil_tmp65 = items + 5;
#line 152
  __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 152
  __cil_tmp67 = __cil_tmp66 + 4;
#line 152
  __cil_tmp68 = (unsigned long )arg;
#line 152
  __cil_tmp69 = __cil_tmp68 + 28;
#line 152
  *((uint32_t *)__cil_tmp67) = *((uint32_t *)__cil_tmp69);
#line 153
  __cil_tmp70 = items + 6;
#line 153
  __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 153
  __cil_tmp72 = __cil_tmp71 + 4;
#line 153
  __cil_tmp73 = (unsigned long )arg;
#line 153
  __cil_tmp74 = __cil_tmp73 + 32;
#line 153
  *((uint32_t *)__cil_tmp72) = *((uint32_t *)__cil_tmp74);
#line 154
  __cil_tmp75 = items + 7;
#line 154
  __cil_tmp76 = (unsigned long )__cil_tmp75;
#line 154
  __cil_tmp77 = __cil_tmp76 + 4;
#line 154
  __cil_tmp78 = (unsigned long )arg;
#line 154
  __cil_tmp79 = __cil_tmp78 + 36;
#line 154
  *((uint32_t *)__cil_tmp77) = *((uint32_t *)__cil_tmp79);
#line 155
  __cil_tmp80 = items + 8;
#line 155
  __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 155
  __cil_tmp82 = __cil_tmp81 + 4;
#line 155
  __cil_tmp83 = (unsigned long )arg;
#line 155
  __cil_tmp84 = __cil_tmp83 + 56;
#line 155
  __cil_tmp85 = *((int32_t *)__cil_tmp84);
#line 155
  *((uint32_t *)__cil_tmp82) = (uint32_t )__cil_tmp85;
#line 156
  __cil_tmp86 = items + 9;
#line 156
  __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 156
  __cil_tmp88 = __cil_tmp87 + 4;
#line 156
  __cil_tmp89 = 56 + 4;
#line 156
  __cil_tmp90 = (unsigned long )arg;
#line 156
  __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
#line 156
  __cil_tmp92 = *((int32_t *)__cil_tmp91);
#line 156
  *((uint32_t *)__cil_tmp88) = (uint32_t )__cil_tmp92;
#line 157
  __cil_tmp93 = items + 10;
#line 157
  __cil_tmp94 = (unsigned long )__cil_tmp93;
#line 157
  __cil_tmp95 = __cil_tmp94 + 4;
#line 157
  __cil_tmp96 = 56 + 8;
#line 157
  __cil_tmp97 = (unsigned long )arg;
#line 157
  __cil_tmp98 = __cil_tmp97 + __cil_tmp96;
#line 157
  *((uint32_t *)__cil_tmp95) = *((uint32_t *)__cil_tmp98);
#line 158
  __cil_tmp99 = items + 11;
#line 158
  __cil_tmp100 = (unsigned long )__cil_tmp99;
#line 158
  __cil_tmp101 = __cil_tmp100 + 4;
#line 158
  __cil_tmp102 = 56 + 12;
#line 158
  __cil_tmp103 = (unsigned long )arg;
#line 158
  __cil_tmp104 = __cil_tmp103 + __cil_tmp102;
#line 158
  *((uint32_t *)__cil_tmp101) = *((uint32_t *)__cil_tmp104);
#line 159
  __cil_tmp105 = items + 12;
#line 159
  __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 159
  __cil_tmp107 = __cil_tmp106 + 4;
#line 159
  __cil_tmp108 = (unsigned long )arg;
#line 159
  __cil_tmp109 = __cil_tmp108 + 72;
#line 159
  __cil_tmp110 = *((int32_t *)__cil_tmp109);
#line 159
  *((uint32_t *)__cil_tmp107) = (uint32_t )__cil_tmp110;
#line 160
  __cil_tmp111 = items + 13;
#line 160
  __cil_tmp112 = (unsigned long )__cil_tmp111;
#line 160
  __cil_tmp113 = __cil_tmp112 + 4;
#line 160
  __cil_tmp114 = 72 + 4;
#line 160
  __cil_tmp115 = (unsigned long )arg;
#line 160
  __cil_tmp116 = __cil_tmp115 + __cil_tmp114;
#line 160
  __cil_tmp117 = *((int32_t *)__cil_tmp116);
#line 160
  *((uint32_t *)__cil_tmp113) = (uint32_t )__cil_tmp117;
#line 161
  __cil_tmp118 = items + 14;
#line 161
  __cil_tmp119 = (unsigned long )__cil_tmp118;
#line 161
  __cil_tmp120 = __cil_tmp119 + 4;
#line 161
  __cil_tmp121 = 72 + 8;
#line 161
  __cil_tmp122 = (unsigned long )arg;
#line 161
  __cil_tmp123 = __cil_tmp122 + __cil_tmp121;
#line 161
  *((uint32_t *)__cil_tmp120) = *((uint32_t *)__cil_tmp123);
#line 162
  __cil_tmp124 = items + 15;
#line 162
  __cil_tmp125 = (unsigned long )__cil_tmp124;
#line 162
  __cil_tmp126 = __cil_tmp125 + 4;
#line 162
  __cil_tmp127 = 72 + 12;
#line 162
  __cil_tmp128 = (unsigned long )arg;
#line 162
  __cil_tmp129 = __cil_tmp128 + __cil_tmp127;
#line 162
  *((uint32_t *)__cil_tmp126) = *((uint32_t *)__cil_tmp129);
#line 163
  __cil_tmp130 = items + 16;
#line 163
  __cil_tmp131 = (unsigned long )__cil_tmp130;
#line 163
  __cil_tmp132 = __cil_tmp131 + 4;
#line 163
  __cil_tmp133 = 0 * 4UL;
#line 163
  __cil_tmp134 = 40 + __cil_tmp133;
#line 163
  __cil_tmp135 = (unsigned long )arg;
#line 163
  __cil_tmp136 = __cil_tmp135 + __cil_tmp134;
#line 163
  *((uint32_t *)__cil_tmp132) = *((uint32_t *)__cil_tmp136);
#line 164
  __cil_tmp137 = items + 17;
#line 164
  __cil_tmp138 = (unsigned long )__cil_tmp137;
#line 164
  __cil_tmp139 = __cil_tmp138 + 4;
#line 164
  __cil_tmp140 = 1 * 4UL;
#line 164
  __cil_tmp141 = 40 + __cil_tmp140;
#line 164
  __cil_tmp142 = (unsigned long )arg;
#line 164
  __cil_tmp143 = __cil_tmp142 + __cil_tmp141;
#line 164
  *((uint32_t *)__cil_tmp139) = *((uint32_t *)__cil_tmp143);
#line 165
  __cil_tmp144 = items + 18;
#line 165
  __cil_tmp145 = (unsigned long )__cil_tmp144;
#line 165
  __cil_tmp146 = __cil_tmp145 + 4;
#line 165
  __cil_tmp147 = 2 * 4UL;
#line 165
  __cil_tmp148 = 40 + __cil_tmp147;
#line 165
  __cil_tmp149 = (unsigned long )arg;
#line 165
  __cil_tmp150 = __cil_tmp149 + __cil_tmp148;
#line 165
  *((uint32_t *)__cil_tmp146) = *((uint32_t *)__cil_tmp150);
  }
#line 166
  if (have_so) {
#line 167
    __cil_tmp151 = items + 19;
#line 167
    __cil_tmp152 = (unsigned long )__cil_tmp151;
#line 167
    __cil_tmp153 = __cil_tmp152 + 4;
#line 167
    __cil_tmp154 = & ptr;
#line 167
    *((uint32_t *)__cil_tmp153) = *((uint32 *)__cil_tmp154);
#line 168
    __cil_tmp155 = items + 20;
#line 168
    __cil_tmp156 = (unsigned long )__cil_tmp155;
#line 168
    __cil_tmp157 = __cil_tmp156 + 4;
#line 168
    *((uint32_t *)__cil_tmp157) = 4294967295U;
  } else {

  }
  {
#line 171
  __cil_tmp158 = *((uint32_t *)arg);
#line 171
  fill_flush(flush, __cil_tmp158);
#line 173
  __cil_tmp159 = (uint32_t )fifo_size;
#line 173
  vmw_fifo_commit(dev_priv, __cil_tmp159);
  }
#line 175
  return (0);
}
}
#line 184 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static int vmw_overlay_send_stop(struct vmw_private *dev_priv , uint32_t stream_id ,
                                 bool interruptible ) 
{ struct __anonstruct_cmds_443 *cmds ;
  int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t __cil_tmp8 ;
  bool __cil_tmp9 ;
  bool __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  struct vmw_escape_header *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_escape_video_flush *__cil_tmp37 ;
  uint32_t __cil_tmp38 ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    __cil_tmp8 = (uint32_t )48UL;
#line 196
    tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp8);
#line 196
    cmds = (struct __anonstruct_cmds_443 *)tmp___7;
    }
#line 197
    if (cmds) {
#line 198
      goto while_break;
    } else {

    }
    {
#line 200
    __cil_tmp9 = (bool )0;
#line 200
    __cil_tmp10 = (bool )1;
#line 200
    __cil_tmp11 = (uint32_t )0;
#line 200
    ret = vmw_fallback_wait(dev_priv, __cil_tmp9, __cil_tmp10, __cil_tmp11, interruptible,
                            750UL);
    }
#line 202
    if (interruptible) {
#line 202
      if (ret == -512) {
#line 203
        return (ret);
      } else {
#line 202
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 205
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 205
        __cil_tmp12 = ret != 0;
#line 205
        __cil_tmp13 = ! __cil_tmp12;
#line 205
        __cil_tmp14 = ! __cil_tmp13;
#line 205
        __cil_tmp15 = (long )__cil_tmp14;
#line 205
        tmp___8 = ldv__builtin_expect(__cil_tmp15, 0L);
        }
#line 205
        if (tmp___8) {
          {
#line 205
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 205
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                 "i" (205), "i" (12UL));
            {
#line 205
            while (1) {
              while_continue___2: /* CIL Label */ ;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 205
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {

        }
#line 205
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  __cil_tmp16 = (struct vmw_escape_header *)cmds;
#line 208
  __cil_tmp17 = (uint32_t )16UL;
#line 208
  fill_escape(__cil_tmp16, __cil_tmp17);
#line 209
  __cil_tmp18 = (unsigned long )cmds;
#line 209
  __cil_tmp19 = __cil_tmp18 + 12;
#line 209
  *((uint32 *)__cil_tmp19) = (uint32 )131073;
#line 210
  __cil_tmp20 = 0 + 4;
#line 210
  __cil_tmp21 = 12 + __cil_tmp20;
#line 210
  __cil_tmp22 = (unsigned long )cmds;
#line 210
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 210
  *((uint32 *)__cil_tmp23) = stream_id;
#line 211
  __cil_tmp24 = 0 * 8UL;
#line 211
  __cil_tmp25 = 8 + __cil_tmp24;
#line 211
  __cil_tmp26 = 12 + __cil_tmp25;
#line 211
  __cil_tmp27 = (unsigned long )cmds;
#line 211
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
#line 211
  *((uint32 *)__cil_tmp28) = (uint32 )0;
#line 212
  __cil_tmp29 = 0 * 8UL;
#line 212
  __cil_tmp30 = __cil_tmp29 + 4;
#line 212
  __cil_tmp31 = 8 + __cil_tmp30;
#line 212
  __cil_tmp32 = 12 + __cil_tmp31;
#line 212
  __cil_tmp33 = (unsigned long )cmds;
#line 212
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 212
  *((uint32 *)__cil_tmp34) = (uint32 )0;
#line 213
  __cil_tmp35 = (unsigned long )cmds;
#line 213
  __cil_tmp36 = __cil_tmp35 + 28;
#line 213
  __cil_tmp37 = (struct vmw_escape_video_flush *)__cil_tmp36;
#line 213
  fill_flush(__cil_tmp37, stream_id);
#line 215
  __cil_tmp38 = (uint32_t )48UL;
#line 215
  vmw_fifo_commit(dev_priv, __cil_tmp38);
  }
#line 217
  return (0);
}
}
#line 226 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static int vmw_overlay_move_buffer(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                   bool pin , bool inter ) 
{ int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_screen_object_display *__cil_tmp10 ;
  bool __cil_tmp11 ;
  bool __cil_tmp12 ;

  {
#line 230
  if (! pin) {
    {
#line 231
    tmp___7 = vmw_dmabuf_unpin(dev_priv, buf, inter);
    }
#line 231
    return (tmp___7);
  } else {

  }
  {
#line 233
  __cil_tmp8 = (unsigned long )dev_priv;
#line 233
  __cil_tmp9 = __cil_tmp8 + 2616;
#line 233
  __cil_tmp10 = *((struct vmw_screen_object_display **)__cil_tmp9);
#line 233
  if (! __cil_tmp10) {
    {
#line 234
    __cil_tmp11 = (bool )1;
#line 234
    tmp___8 = vmw_dmabuf_to_vram(dev_priv, buf, __cil_tmp11, inter);
    }
#line 234
    return (tmp___8);
  } else {

  }
  }
  {
#line 236
  __cil_tmp12 = (bool )1;
#line 236
  tmp___9 = vmw_dmabuf_to_vram_or_gmr(dev_priv, buf, __cil_tmp12, inter);
  }
#line 236
  return (tmp___9);
}
}
#line 251 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static int vmw_overlay_stop(struct vmw_private *dev_priv , uint32_t stream_id , bool pause ,
                            bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_dma_buffer *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  struct vmw_dma_buffer *__cil_tmp19 ;
  bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;

  {
#line 255
  __cil_tmp9 = (unsigned long )dev_priv;
#line 255
  __cil_tmp10 = __cil_tmp9 + 2624;
#line 255
  overlay = *((struct vmw_overlay **)__cil_tmp10);
#line 256
  __cil_tmp11 = stream_id * 104UL;
#line 256
  __cil_tmp12 = 72 + __cil_tmp11;
#line 256
  __cil_tmp13 = (unsigned long )overlay;
#line 256
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 256
  stream = (struct vmw_stream___0 *)__cil_tmp14;
  {
#line 260
  __cil_tmp15 = *((struct vmw_dma_buffer **)stream);
#line 260
  if (! __cil_tmp15) {
#line 261
    return (0);
  } else {

  }
  }
  {
#line 264
  __cil_tmp16 = (unsigned long )stream;
#line 264
  __cil_tmp17 = __cil_tmp16 + 9;
#line 264
  __cil_tmp18 = *((bool *)__cil_tmp17);
#line 264
  if (! __cil_tmp18) {
    {
#line 265
    ret = vmw_overlay_send_stop(dev_priv, stream_id, interruptible);
    }
#line 267
    if (ret) {
#line 268
      return (ret);
    } else {

    }
    {
#line 271
    __cil_tmp19 = *((struct vmw_dma_buffer **)stream);
#line 271
    __cil_tmp20 = (bool )0;
#line 271
    ret = vmw_overlay_move_buffer(dev_priv, __cil_tmp19, __cil_tmp20, interruptible);
    }
#line 273
    if (interruptible) {
#line 273
      if (ret == -512) {
#line 274
        return (ret);
      } else {
#line 273
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 276
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 276
        __cil_tmp21 = ret != 0;
#line 276
        __cil_tmp22 = ! __cil_tmp21;
#line 276
        __cil_tmp23 = ! __cil_tmp22;
#line 276
        __cil_tmp24 = (long )__cil_tmp23;
#line 276
        tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
        }
#line 276
        if (tmp___7) {
          {
#line 276
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 276
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                 "i" (276), "i" (12UL));
            {
#line 276
            while (1) {
              while_continue___1: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 276
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {

        }
#line 276
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {

  }
  }
#line 279
  if (! pause) {
    {
#line 280
    __cil_tmp25 = (struct vmw_dma_buffer **)stream;
#line 280
    vmw_dmabuf_unreference(__cil_tmp25);
#line 281
    __cil_tmp26 = (unsigned long )stream;
#line 281
    __cil_tmp27 = __cil_tmp26 + 9;
#line 281
    *((bool *)__cil_tmp27) = (bool )0;
    }
  } else {
#line 283
    __cil_tmp28 = (unsigned long )stream;
#line 283
    __cil_tmp29 = __cil_tmp28 + 9;
#line 283
    *((bool *)__cil_tmp29) = (bool )1;
  }
#line 286
  return (0);
}
}
#line 298 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static int vmw_overlay_update_stream(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                     struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  char    *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_dma_buffer *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_dma_buffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  bool __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  bool __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  bool __cil_tmp37 ;
  bool __cil_tmp38 ;
  bool __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_dma_buffer *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;

  {
#line 303
  __cil_tmp13 = (unsigned long )dev_priv;
#line 303
  __cil_tmp14 = __cil_tmp13 + 2624;
#line 303
  overlay = *((struct vmw_overlay **)__cil_tmp14);
#line 304
  __cil_tmp15 = *((uint32_t *)arg);
#line 304
  __cil_tmp16 = __cil_tmp15 * 104UL;
#line 304
  __cil_tmp17 = 72 + __cil_tmp16;
#line 304
  __cil_tmp18 = (unsigned long )overlay;
#line 304
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 304
  stream = (struct vmw_stream___0 *)__cil_tmp19;
#line 305
  ret = 0;
#line 307
  if (! buf) {
#line 308
    return (-22);
  } else {

  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    __cil_tmp20 = (unsigned long )stream;
#line 310
    __cil_tmp21 = __cil_tmp20 + 9;
#line 310
    if (*((bool *)__cil_tmp21)) {
#line 310
      tmp___7 = "";
    } else {
#line 310
      tmp___7 = "not ";
    }
    }
    {
#line 310
    __cil_tmp22 = *((struct vmw_dma_buffer **)stream);
#line 310
    drm_ut_debug_printk(1U, "drm", "vmw_overlay_update_stream", "   %s: old %p, new %p, %spaused\n",
                        "vmw_overlay_update_stream", __cil_tmp22, buf, tmp___7);
    }
#line 310
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  __cil_tmp23 = (unsigned long )buf;
#line 313
  __cil_tmp24 = *((struct vmw_dma_buffer **)stream);
#line 313
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 313
  if (__cil_tmp25 != __cil_tmp23) {
    {
#line 314
    __cil_tmp26 = *((uint32_t *)arg);
#line 314
    __cil_tmp27 = (bool )0;
#line 314
    ret = vmw_overlay_stop(dev_priv, __cil_tmp26, __cil_tmp27, interruptible);
    }
#line 316
    if (ret) {
#line 317
      return (ret);
    } else {

    }
  } else {
    {
#line 318
    __cil_tmp28 = (unsigned long )stream;
#line 318
    __cil_tmp29 = __cil_tmp28 + 9;
#line 318
    __cil_tmp30 = *((bool *)__cil_tmp29);
#line 318
    if (! __cil_tmp30) {
      {
#line 322
      ret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);
      }
#line 323
      if (ret == 0) {
#line 324
        __cil_tmp31 = (unsigned long )stream;
#line 324
        __cil_tmp32 = __cil_tmp31 + 12;
#line 324
        *((struct drm_vmw_control_stream_arg *)__cil_tmp32) = *arg;
      } else {
        {
#line 326
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 326
          __cil_tmp33 = ! interruptible;
#line 326
          __cil_tmp34 = ! __cil_tmp33;
#line 326
          __cil_tmp35 = ! __cil_tmp34;
#line 326
          __cil_tmp36 = (long )__cil_tmp35;
#line 326
          tmp___8 = ldv__builtin_expect(__cil_tmp36, 0L);
          }
#line 326
          if (tmp___8) {
            {
#line 326
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 326
              __asm__  volatile   ("1:\tud2\n"
                                   ".pushsection __bug_table,\"a\"\n"
                                   "2:\t.long 1b - 2b, %c0 - 2b\n"
                                   "\t.word %c1, 0\n"
                                   "\t.org 2b+%c2\n"
                                   ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                   "i" (326), "i" (12UL));
              {
#line 326
              while (1) {
                while_continue___2: /* CIL Label */ ;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 326
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {

          }
#line 326
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 328
      return (ret);
    } else {

    }
    }
  }
  }
  {
#line 334
  __cil_tmp37 = (bool )1;
#line 334
  ret = vmw_overlay_move_buffer(dev_priv, buf, __cil_tmp37, interruptible);
  }
#line 335
  if (ret) {
#line 336
    return (ret);
  } else {

  }
  {
#line 338
  ret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);
  }
#line 339
  if (ret) {
    {
#line 343
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 343
      __cil_tmp38 = (bool )0;
#line 343
      __cil_tmp39 = (bool )0;
#line 343
      tmp___9 = vmw_overlay_move_buffer(dev_priv, buf, __cil_tmp38, __cil_tmp39);
      }
#line 343
      if (tmp___9 != 0) {
#line 343
        tmp___10 = 1;
      } else {
#line 343
        tmp___10 = 0;
      }
      {
#line 343
      __cil_tmp40 = (long )tmp___10;
#line 343
      tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
      }
#line 343
      if (tmp___11) {
        {
#line 343
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 343
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                               "i" (344), "i" (12UL));
          {
#line 343
          while (1) {
            while_continue___5: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 343
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {

      }
#line 343
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 345
    return (ret);
  } else {

  }
  {
#line 348
  __cil_tmp41 = (unsigned long )buf;
#line 348
  __cil_tmp42 = *((struct vmw_dma_buffer **)stream);
#line 348
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 348
  if (__cil_tmp43 != __cil_tmp41) {
    {
#line 349
    *((struct vmw_dma_buffer **)stream) = vmw_dmabuf_reference(buf);
    }
  } else {

  }
  }
#line 350
  __cil_tmp44 = (unsigned long )stream;
#line 350
  __cil_tmp45 = __cil_tmp44 + 12;
#line 350
  *((struct drm_vmw_control_stream_arg *)__cil_tmp45) = *arg;
#line 352
  __cil_tmp46 = (unsigned long )stream;
#line 352
  __cil_tmp47 = __cil_tmp46 + 9;
#line 352
  *((bool *)__cil_tmp47) = (bool )0;
#line 354
  return (0);
}
}
#line 364 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_dma_buffer *__cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  bool __cil_tmp17 ;
  bool __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  int    __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  struct mutex *__cil_tmp28 ;

  {
#line 366
  __cil_tmp8 = (unsigned long )dev_priv;
#line 366
  __cil_tmp9 = __cil_tmp8 + 2624;
#line 366
  overlay = *((struct vmw_overlay **)__cil_tmp9);
#line 369
  if (! overlay) {
#line 370
    return (0);
  } else {

  }
  {
#line 372
  __cil_tmp10 = (struct mutex *)overlay;
#line 372
  mutex_lock(__cil_tmp10);
#line 374
  i = 0;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (i < 1) {

    } else {
#line 374
      goto while_break;
    }
#line 375
    __cil_tmp11 = i * 104UL;
#line 375
    __cil_tmp12 = 72 + __cil_tmp11;
#line 375
    __cil_tmp13 = (unsigned long )overlay;
#line 375
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 375
    stream = (struct vmw_stream___0 *)__cil_tmp14;
    {
#line 376
    __cil_tmp15 = *((struct vmw_dma_buffer **)stream);
#line 376
    if (! __cil_tmp15) {
#line 377
      goto __Cont;
    } else {

    }
    }
    {
#line 379
    __cil_tmp16 = (uint32_t )i;
#line 379
    __cil_tmp17 = (bool )0;
#line 379
    __cil_tmp18 = (bool )0;
#line 379
    ret = vmw_overlay_stop(dev_priv, __cil_tmp16, __cil_tmp17, __cil_tmp18);
#line 380
    __cil_tmp19 = ret != 0;
#line 380
    __cil_tmp20 = ! __cil_tmp19;
#line 380
    __ret_warn_on = ! __cil_tmp20;
#line 380
    __cil_tmp21 = ! __ret_warn_on;
#line 380
    __cil_tmp22 = ! __cil_tmp21;
#line 380
    __cil_tmp23 = (long )__cil_tmp22;
#line 380
    tmp___7 = ldv__builtin_expect(__cil_tmp23, 0L);
    }
#line 380
    if (tmp___7) {
      {
#line 380
      __cil_tmp24 = (int    )380;
#line 380
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                         __cil_tmp24);
      }
    } else {

    }
    {
#line 380
    __cil_tmp25 = ! __ret_warn_on;
#line 380
    __cil_tmp26 = ! __cil_tmp25;
#line 380
    __cil_tmp27 = (long )__cil_tmp26;
#line 380
    ldv__builtin_expect(__cil_tmp27, 0L);
    }
    __Cont: /* CIL Label */ 
#line 374
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  __cil_tmp28 = (struct mutex *)overlay;
#line 383
  mutex_unlock(__cil_tmp28);
  }
#line 385
  return (0);
}
}
#line 395 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  struct vmw_dma_buffer *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct drm_vmw_control_stream_arg *__cil_tmp19 ;
  bool __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;

  {
#line 397
  __cil_tmp6 = (unsigned long )dev_priv;
#line 397
  __cil_tmp7 = __cil_tmp6 + 2624;
#line 397
  overlay = *((struct vmw_overlay **)__cil_tmp7);
#line 400
  if (! overlay) {
#line 401
    return (0);
  } else {

  }
  {
#line 403
  __cil_tmp8 = (struct mutex *)overlay;
#line 403
  mutex_lock(__cil_tmp8);
#line 405
  i = 0;
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (i < 1) {

    } else {
#line 405
      goto while_break;
    }
#line 406
    __cil_tmp9 = i * 104UL;
#line 406
    __cil_tmp10 = 72 + __cil_tmp9;
#line 406
    __cil_tmp11 = (unsigned long )overlay;
#line 406
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 406
    stream = (struct vmw_stream___0 *)__cil_tmp12;
    {
#line 407
    __cil_tmp13 = (unsigned long )stream;
#line 407
    __cil_tmp14 = __cil_tmp13 + 9;
#line 407
    __cil_tmp15 = *((bool *)__cil_tmp14);
#line 407
    if (! __cil_tmp15) {
#line 408
      goto __Cont;
    } else {

    }
    }
    {
#line 410
    __cil_tmp16 = *((struct vmw_dma_buffer **)stream);
#line 410
    __cil_tmp17 = (unsigned long )stream;
#line 410
    __cil_tmp18 = __cil_tmp17 + 12;
#line 410
    __cil_tmp19 = (struct drm_vmw_control_stream_arg *)__cil_tmp18;
#line 410
    __cil_tmp20 = (bool )0;
#line 410
    ret = vmw_overlay_update_stream(dev_priv, __cil_tmp16, __cil_tmp19, __cil_tmp20);
    }
#line 412
    if (ret != 0) {
      {
#line 413
      printk("<6>[drm] %s: *warning* failed to resume stream %i\n", "vmw_overlay_resume_all",
             i);
      }
    } else {

    }
    __Cont: /* CIL Label */ 
#line 405
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 417
  __cil_tmp21 = (struct mutex *)overlay;
#line 417
  mutex_unlock(__cil_tmp21);
  }
#line 419
  return (0);
}
}
#line 429 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  bool __cil_tmp16 ;
  bool __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  int    __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  struct mutex *__cil_tmp27 ;

  {
#line 431
  __cil_tmp7 = (unsigned long )dev_priv;
#line 431
  __cil_tmp8 = __cil_tmp7 + 2624;
#line 431
  overlay = *((struct vmw_overlay **)__cil_tmp8);
#line 434
  if (! overlay) {
#line 435
    return (0);
  } else {

  }
  {
#line 437
  __cil_tmp9 = (struct mutex *)overlay;
#line 437
  mutex_lock(__cil_tmp9);
#line 439
  i = 0;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (i < 1) {

    } else {
#line 439
      goto while_break;
    }
    {
#line 440
    __cil_tmp10 = i * 104UL;
#line 440
    __cil_tmp11 = __cil_tmp10 + 9;
#line 440
    __cil_tmp12 = 72 + __cil_tmp11;
#line 440
    __cil_tmp13 = (unsigned long )overlay;
#line 440
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 440
    if (*((bool *)__cil_tmp14)) {
      {
#line 441
      printk("<6>[drm] %s: *warning* stream %i already paused\n", "vmw_overlay_pause_all",
             i);
      }
    } else {

    }
    }
    {
#line 443
    __cil_tmp15 = (uint32_t )i;
#line 443
    __cil_tmp16 = (bool )1;
#line 443
    __cil_tmp17 = (bool )0;
#line 443
    ret = vmw_overlay_stop(dev_priv, __cil_tmp15, __cil_tmp16, __cil_tmp17);
#line 444
    __cil_tmp18 = ret != 0;
#line 444
    __cil_tmp19 = ! __cil_tmp18;
#line 444
    __ret_warn_on = ! __cil_tmp19;
#line 444
    __cil_tmp20 = ! __ret_warn_on;
#line 444
    __cil_tmp21 = ! __cil_tmp20;
#line 444
    __cil_tmp22 = (long )__cil_tmp21;
#line 444
    tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
    }
#line 444
    if (tmp___7) {
      {
#line 444
      __cil_tmp23 = (int    )444;
#line 444
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                         __cil_tmp23);
      }
    } else {

    }
    {
#line 444
    __cil_tmp24 = ! __ret_warn_on;
#line 444
    __cil_tmp25 = ! __cil_tmp24;
#line 444
    __cil_tmp26 = (long )__cil_tmp25;
#line 444
    ldv__builtin_expect(__cil_tmp26, 0L);
#line 439
    i = i + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  __cil_tmp27 = (struct mutex *)overlay;
#line 447
  mutex_unlock(__cil_tmp27);
  }
#line 449
  return (0);
}
}
#line 452 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct vmw_overlay *overlay ;
  struct drm_vmw_control_stream_arg *arg ;
  struct vmw_dma_buffer *buf ;
  struct vmw_resource *res ;
  int ret ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t *__cil_tmp17 ;
  struct mutex *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  struct vmw_dma_buffer **__cil_tmp28 ;
  struct vmw_dma_buffer *__cil_tmp29 ;
  bool __cil_tmp30 ;
  struct mutex *__cil_tmp31 ;

  {
  {
#line 455
  tmp___7 = vmw_fpriv(file_priv);
#line 455
  __cil_tmp13 = (unsigned long )tmp___7;
#line 455
  __cil_tmp14 = __cil_tmp13 + 8;
#line 455
  tfile = *((struct ttm_object_file **)__cil_tmp14);
#line 456
  tmp___8 = vmw_priv(dev);
#line 456
  dev_priv = tmp___8;
#line 457
  __cil_tmp15 = (unsigned long )dev_priv;
#line 457
  __cil_tmp16 = __cil_tmp15 + 2624;
#line 457
  overlay = *((struct vmw_overlay **)__cil_tmp16);
#line 458
  arg = (struct drm_vmw_control_stream_arg *)data;
  }
#line 464
  if (! overlay) {
#line 465
    return (-38);
  } else {

  }
  {
#line 467
  __cil_tmp17 = (uint32_t *)arg;
#line 467
  ret = vmw_user_stream_lookup(dev_priv, tfile, __cil_tmp17, & res);
  }
#line 468
  if (ret) {
#line 469
    return (ret);
  } else {

  }
  {
#line 471
  __cil_tmp18 = (struct mutex *)overlay;
#line 471
  mutex_lock(__cil_tmp18);
  }
  {
#line 473
  __cil_tmp19 = (unsigned long )arg;
#line 473
  __cil_tmp20 = __cil_tmp19 + 4;
#line 473
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
#line 473
  if (! __cil_tmp21) {
    {
#line 474
    __cil_tmp22 = *((uint32_t *)arg);
#line 474
    __cil_tmp23 = (bool )0;
#line 474
    __cil_tmp24 = (bool )1;
#line 474
    ret = vmw_overlay_stop(dev_priv, __cil_tmp22, __cil_tmp23, __cil_tmp24);
    }
#line 475
    goto out_unlock;
  } else {

  }
  }
  {
#line 478
  __cil_tmp25 = (unsigned long )arg;
#line 478
  __cil_tmp26 = __cil_tmp25 + 16;
#line 478
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
#line 478
  ret = vmw_user_dmabuf_lookup(tfile, __cil_tmp27, & buf);
  }
#line 479
  if (ret) {
#line 480
    goto out_unlock;
  } else {

  }
  {
#line 482
  __cil_tmp28 = & buf;
#line 482
  __cil_tmp29 = *__cil_tmp28;
#line 482
  __cil_tmp30 = (bool )1;
#line 482
  ret = vmw_overlay_update_stream(dev_priv, __cil_tmp29, arg, __cil_tmp30);
#line 484
  vmw_dmabuf_unreference(& buf);
  }
  out_unlock: 
  {
#line 487
  __cil_tmp31 = (struct mutex *)overlay;
#line 487
  mutex_unlock(__cil_tmp31);
#line 488
  vmw_resource_unreference(& res);
  }
#line 490
  return (ret);
}
}
#line 493 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct vmw_overlay *__cil_tmp4 ;

  {
  {
#line 495
  __cil_tmp2 = (unsigned long )dev_priv;
#line 495
  __cil_tmp3 = __cil_tmp2 + 2624;
#line 495
  __cil_tmp4 = *((struct vmw_overlay **)__cil_tmp3);
#line 495
  if (! __cil_tmp4) {
#line 496
    return (0);
  } else {

  }
  }
#line 498
  return (1);
}
}
#line 501 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int k ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct mutex *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;

  {
#line 503
  __cil_tmp5 = (unsigned long )dev_priv;
#line 503
  __cil_tmp6 = __cil_tmp5 + 2624;
#line 503
  overlay = *((struct vmw_overlay **)__cil_tmp6);
#line 506
  if (! overlay) {
#line 507
    return (0);
  } else {

  }
  {
#line 509
  __cil_tmp7 = (struct mutex *)overlay;
#line 509
  mutex_lock(__cil_tmp7);
#line 511
  i = 0;
#line 511
  k = 0;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (i < 1) {

    } else {
#line 511
      goto while_break;
    }
    {
#line 512
    __cil_tmp8 = i * 104UL;
#line 512
    __cil_tmp9 = __cil_tmp8 + 8;
#line 512
    __cil_tmp10 = 72 + __cil_tmp9;
#line 512
    __cil_tmp11 = (unsigned long )overlay;
#line 512
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 512
    __cil_tmp13 = *((bool *)__cil_tmp12);
#line 512
    if (! __cil_tmp13) {
#line 513
      k = k + 1;
    } else {

    }
    }
#line 511
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 515
  __cil_tmp14 = (struct mutex *)overlay;
#line 515
  mutex_unlock(__cil_tmp14);
  }
#line 517
  return (k);
}
}
#line 520 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) 
{ struct vmw_overlay *overlay ;
  int i ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct mutex *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct mutex *__cil_tmp18 ;
  struct mutex *__cil_tmp19 ;

  {
#line 522
  __cil_tmp5 = (unsigned long )dev_priv;
#line 522
  __cil_tmp6 = __cil_tmp5 + 2624;
#line 522
  overlay = *((struct vmw_overlay **)__cil_tmp6);
#line 525
  if (! overlay) {
#line 526
    return (-38);
  } else {

  }
  {
#line 528
  __cil_tmp7 = (struct mutex *)overlay;
#line 528
  mutex_lock(__cil_tmp7);
#line 530
  i = 0;
  }
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (i < 1) {

    } else {
#line 530
      goto while_break;
    }
    {
#line 532
    __cil_tmp8 = i * 104UL;
#line 532
    __cil_tmp9 = __cil_tmp8 + 8;
#line 532
    __cil_tmp10 = 72 + __cil_tmp9;
#line 532
    __cil_tmp11 = (unsigned long )overlay;
#line 532
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 532
    if (*((bool *)__cil_tmp12)) {
#line 533
      goto __Cont;
    } else {

    }
    }
    {
#line 535
    __cil_tmp13 = i * 104UL;
#line 535
    __cil_tmp14 = __cil_tmp13 + 8;
#line 535
    __cil_tmp15 = 72 + __cil_tmp14;
#line 535
    __cil_tmp16 = (unsigned long )overlay;
#line 535
    __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 535
    *((bool *)__cil_tmp17) = (bool )1;
#line 536
    *out = (uint32_t )i;
#line 537
    __cil_tmp18 = (struct mutex *)overlay;
#line 537
    mutex_unlock(__cil_tmp18);
    }
#line 538
    return (0);
    __Cont: /* CIL Label */ 
#line 530
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  __cil_tmp19 = (struct mutex *)overlay;
#line 541
  mutex_unlock(__cil_tmp19);
  }
#line 542
  return (-3);
}
}
#line 545 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) 
{ struct vmw_overlay *overlay ;
  long tmp___7 ;
  int __ret_warn_on ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  bool __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  int    __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  bool __cil_tmp29 ;
  bool __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;

  {
#line 547
  __cil_tmp7 = (unsigned long )dev_priv;
#line 547
  __cil_tmp8 = __cil_tmp7 + 2624;
#line 547
  overlay = *((struct vmw_overlay **)__cil_tmp8);
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    __cil_tmp9 = stream_id >= 1U;
#line 549
    __cil_tmp10 = ! __cil_tmp9;
#line 549
    __cil_tmp11 = ! __cil_tmp10;
#line 549
    __cil_tmp12 = (long )__cil_tmp11;
#line 549
    tmp___7 = ldv__builtin_expect(__cil_tmp12, 0L);
    }
#line 549
    if (tmp___7) {
      {
#line 549
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 549
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                             "i" (549), "i" (12UL));
        {
#line 549
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 549
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 549
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  if (! overlay) {
#line 552
    return (-38);
  } else {

  }
  {
#line 554
  __cil_tmp13 = (struct mutex *)overlay;
#line 554
  mutex_lock(__cil_tmp13);
#line 556
  __cil_tmp14 = stream_id * 104UL;
#line 556
  __cil_tmp15 = __cil_tmp14 + 8;
#line 556
  __cil_tmp16 = 72 + __cil_tmp15;
#line 556
  __cil_tmp17 = (unsigned long )overlay;
#line 556
  __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 556
  __cil_tmp19 = *((bool *)__cil_tmp18);
#line 556
  __cil_tmp20 = ! __cil_tmp19;
#line 556
  __cil_tmp21 = ! __cil_tmp20;
#line 556
  __ret_warn_on = ! __cil_tmp21;
#line 556
  __cil_tmp22 = ! __ret_warn_on;
#line 556
  __cil_tmp23 = ! __cil_tmp22;
#line 556
  __cil_tmp24 = (long )__cil_tmp23;
#line 556
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 556
  if (tmp___8) {
    {
#line 556
    __cil_tmp25 = (int    )556;
#line 556
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                       __cil_tmp25);
    }
  } else {

  }
  {
#line 556
  __cil_tmp26 = ! __ret_warn_on;
#line 556
  __cil_tmp27 = ! __cil_tmp26;
#line 556
  __cil_tmp28 = (long )__cil_tmp27;
#line 556
  ldv__builtin_expect(__cil_tmp28, 0L);
#line 557
  __cil_tmp29 = (bool )0;
#line 557
  __cil_tmp30 = (bool )0;
#line 557
  vmw_overlay_stop(dev_priv, stream_id, __cil_tmp29, __cil_tmp30);
#line 558
  __cil_tmp31 = stream_id * 104UL;
#line 558
  __cil_tmp32 = __cil_tmp31 + 8;
#line 558
  __cil_tmp33 = 72 + __cil_tmp32;
#line 558
  __cil_tmp34 = (unsigned long )overlay;
#line 558
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 558
  *((bool *)__cil_tmp35) = (bool )0;
#line 560
  __cil_tmp36 = (struct mutex *)overlay;
#line 560
  mutex_unlock(__cil_tmp36);
  }
#line 561
  return (0);
}
}
#line 582 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
static struct lock_class_key __key___16  ;
#line 564 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_init(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  void *tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  struct mutex *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  {
#line 569
  __cil_tmp5 = (unsigned long )dev_priv;
#line 569
  __cil_tmp6 = __cil_tmp5 + 2624;
#line 569
  if (*((struct vmw_overlay **)__cil_tmp6)) {
#line 570
    return (-22);
  } else {

  }
  }
  {
#line 572
  __cil_tmp7 = 1 << 3;
#line 572
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 572
  __cil_tmp9 = 1856 + 36;
#line 572
  __cil_tmp10 = (unsigned long )dev_priv;
#line 572
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
#line 572
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
#line 572
  __cil_tmp13 = __cil_tmp12 & __cil_tmp8;
#line 572
  if (! __cil_tmp13) {
    {
#line 572
    __cil_tmp14 = 1 << 5;
#line 572
    __cil_tmp15 = (unsigned int )__cil_tmp14;
#line 572
    __cil_tmp16 = 1856 + 36;
#line 572
    __cil_tmp17 = (unsigned long )dev_priv;
#line 572
    __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 572
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
#line 572
    if (__cil_tmp19 & __cil_tmp15) {
      {
#line 574
      printk("<6>[drm] hardware doesn\'t support overlays\n");
      }
#line 575
      return (-38);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 578
  tmp___7 = kzalloc(176UL, 208U);
#line 578
  overlay = (struct vmw_overlay *)tmp___7;
  }
#line 579
  if (! overlay) {
#line 580
    return (-12);
  } else {

  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 582
    __cil_tmp20 = (struct mutex *)overlay;
#line 582
    __mutex_init(__cil_tmp20, "&overlay->mutex", & __key___16);
    }
#line 582
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (i < 1) {

    } else {
#line 583
      goto while_break___0;
    }
#line 584
    __cil_tmp21 = i * 104UL;
#line 584
    __cil_tmp22 = 72 + __cil_tmp21;
#line 584
    __cil_tmp23 = (unsigned long )overlay;
#line 584
    __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 584
    __cil_tmp25 = (void *)0;
#line 584
    *((struct vmw_dma_buffer **)__cil_tmp24) = (struct vmw_dma_buffer *)__cil_tmp25;
#line 585
    __cil_tmp26 = i * 104UL;
#line 585
    __cil_tmp27 = __cil_tmp26 + 9;
#line 585
    __cil_tmp28 = 72 + __cil_tmp27;
#line 585
    __cil_tmp29 = (unsigned long )overlay;
#line 585
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 585
    *((bool *)__cil_tmp30) = (bool )0;
#line 586
    __cil_tmp31 = i * 104UL;
#line 586
    __cil_tmp32 = __cil_tmp31 + 8;
#line 586
    __cil_tmp33 = 72 + __cil_tmp32;
#line 586
    __cil_tmp34 = (unsigned long )overlay;
#line 586
    __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 586
    *((bool *)__cil_tmp35) = (bool )0;
#line 583
    i = i + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 589
  __cil_tmp36 = (unsigned long )dev_priv;
#line 589
  __cil_tmp37 = __cil_tmp36 + 2624;
#line 589
  *((struct vmw_overlay **)__cil_tmp37) = overlay;
#line 591
  return (0);
}
}
#line 594 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"
int vmw_overlay_close(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  bool forgotten_buffer ;
  int i ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  bool __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  int    __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void *__cil_tmp26 ;
  void    *__cil_tmp27 ;

  {
#line 596
  __cil_tmp7 = (unsigned long )dev_priv;
#line 596
  __cil_tmp8 = __cil_tmp7 + 2624;
#line 596
  overlay = *((struct vmw_overlay **)__cil_tmp8);
#line 597
  forgotten_buffer = (bool )0;
#line 600
  if (! overlay) {
#line 601
    return (-38);
  } else {

  }
#line 603
  i = 0;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (i < 1) {

    } else {
#line 603
      goto while_break;
    }
    {
#line 604
    __cil_tmp9 = i * 104UL;
#line 604
    __cil_tmp10 = 72 + __cil_tmp9;
#line 604
    __cil_tmp11 = (unsigned long )overlay;
#line 604
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 604
    if (*((struct vmw_dma_buffer **)__cil_tmp12)) {
      {
#line 605
      forgotten_buffer = (bool )1;
#line 606
      __cil_tmp13 = (uint32_t )i;
#line 606
      __cil_tmp14 = (bool )0;
#line 606
      __cil_tmp15 = (bool )0;
#line 606
      vmw_overlay_stop(dev_priv, __cil_tmp13, __cil_tmp14, __cil_tmp15);
      }
    } else {

    }
    }
#line 603
    i = i + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 610
  __cil_tmp16 = ! forgotten_buffer;
#line 610
  __ret_warn_on = ! __cil_tmp16;
#line 610
  __cil_tmp17 = ! __ret_warn_on;
#line 610
  __cil_tmp18 = ! __cil_tmp17;
#line 610
  __cil_tmp19 = (long )__cil_tmp18;
#line 610
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  }
#line 610
  if (tmp___7) {
    {
#line 610
    __cil_tmp20 = (int    )610;
#line 610
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                       __cil_tmp20);
    }
  } else {

  }
  {
#line 610
  __cil_tmp21 = ! __ret_warn_on;
#line 610
  __cil_tmp22 = ! __cil_tmp21;
#line 610
  __cil_tmp23 = (long )__cil_tmp22;
#line 610
  ldv__builtin_expect(__cil_tmp23, 0L);
#line 612
  __cil_tmp24 = (unsigned long )dev_priv;
#line 612
  __cil_tmp25 = __cil_tmp24 + 2624;
#line 612
  __cil_tmp26 = (void *)0;
#line 612
  *((struct vmw_overlay **)__cil_tmp25) = (struct vmw_overlay *)__cil_tmp26;
#line 613
  __cil_tmp27 = (void    *)overlay;
#line 613
  kfree(__cil_tmp27);
  }
#line 615
  return (0);
}
}
#line 56 "include/linux/time.h"
__inline static int timespec_compare(struct timespec    *lhs , struct timespec    *rhs )  __attribute__((__no_instrument_function__)) ;
#line 56 "include/linux/time.h"
__inline static int timespec_compare(struct timespec    *lhs , struct timespec    *rhs ) 
{ __kernel_time_t    __cil_tmp3 ;
  __kernel_time_t    __cil_tmp4 ;
  __kernel_time_t    __cil_tmp5 ;
  __kernel_time_t    __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  long    __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  long    __cil_tmp12 ;
  long    __cil_tmp13 ;

  {
  {
#line 58
  __cil_tmp3 = *((__kernel_time_t    *)rhs);
#line 58
  __cil_tmp4 = *((__kernel_time_t    *)lhs);
#line 58
  if (__cil_tmp4 < __cil_tmp3) {
#line 59
    return (-1);
  } else {

  }
  }
  {
#line 60
  __cil_tmp5 = *((__kernel_time_t    *)rhs);
#line 60
  __cil_tmp6 = *((__kernel_time_t    *)lhs);
#line 60
  if (__cil_tmp6 > __cil_tmp5) {
#line 61
    return (1);
  } else {

  }
  }
  {
#line 62
  __cil_tmp7 = (unsigned long )rhs;
#line 62
  __cil_tmp8 = __cil_tmp7 + 8;
#line 62
  __cil_tmp9 = *((long    *)__cil_tmp8);
#line 62
  __cil_tmp10 = (unsigned long )lhs;
#line 62
  __cil_tmp11 = __cil_tmp10 + 8;
#line 62
  __cil_tmp12 = *((long    *)__cil_tmp11);
#line 62
  __cil_tmp13 = __cil_tmp12 - __cil_tmp9;
#line 62
  return ((int )__cil_tmp13);
  }
}
}
#line 78
extern void set_normalized_timespec(struct timespec *ts , time_t sec , s64 nsec ) ;
#line 101
__inline static struct timespec timespec_sub(__kernel_time_t lhs_tv_sec11 , long lhs_tv_nsec10 ,
                                             __kernel_time_t rhs_tv_sec9 , long rhs_tv_nsec8 )  __attribute__((__no_instrument_function__)) ;
#line 101 "include/linux/time.h"
__inline static struct timespec timespec_sub(__kernel_time_t lhs_tv_sec11 , long lhs_tv_nsec10 ,
                                             __kernel_time_t rhs_tv_sec9 , long rhs_tv_nsec8 ) 
{ struct timespec ts_delta ;
  __kernel_time_t __cil_tmp4 ;
  long __cil_tmp5 ;
  s64 __cil_tmp6 ;
  struct timespec *__cil_tmp7 ;

  {
  {
#line 105
  __cil_tmp4 = lhs_tv_sec11 - rhs_tv_sec9;
#line 105
  __cil_tmp5 = lhs_tv_nsec10 - rhs_tv_nsec8;
#line 105
  __cil_tmp6 = (s64 )__cil_tmp5;
#line 105
  set_normalized_timespec(& ts_delta, __cil_tmp4, __cil_tmp6);
  }
  {
#line 107
  __cil_tmp7 = & ts_delta;
#line 107
  return (*__cil_tmp7);
  }
}
}
#line 160
extern void getrawmonotonic(struct timespec *ts ) ;
#line 235
extern struct timespec ns_to_timespec(s64    nsec ) ;
#line 42 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
static struct lock_class_key __key___17  ;
#line 37 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) 
{ struct list_head *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  s64    __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct timespec *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct raw_spinlock *__cil_tmp14 ;

  {
  {
#line 39
  __cil_tmp2 = (struct list_head *)queue;
#line 39
  INIT_LIST_HEAD(__cil_tmp2);
#line 40
  __cil_tmp3 = (unsigned long )queue;
#line 40
  __cil_tmp4 = __cil_tmp3 + 16;
#line 40
  __cil_tmp5 = (s64    )0;
#line 40
  *((struct timespec *)__cil_tmp4) = ns_to_timespec(__cil_tmp5);
#line 41
  __cil_tmp6 = (unsigned long )queue;
#line 41
  __cil_tmp7 = __cil_tmp6 + 32;
#line 41
  __cil_tmp8 = (struct timespec *)__cil_tmp7;
#line 41
  getrawmonotonic(__cil_tmp8);
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    __cil_tmp9 = (unsigned long )queue;
#line 42
    __cil_tmp10 = __cil_tmp9 + 48;
#line 42
    __cil_tmp11 = (spinlock_t *)__cil_tmp10;
#line 42
    spinlock_check(__cil_tmp11);
    }
    {
#line 42
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 42
      __cil_tmp12 = (unsigned long )queue;
#line 42
      __cil_tmp13 = __cil_tmp12 + 48;
#line 42
      __cil_tmp14 = (struct raw_spinlock *)__cil_tmp13;
#line 42
      __raw_spin_lock_init(__cil_tmp14, "&(&queue->lock)->rlock", & __key___17);
      }
#line 42
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 42
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 45 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  spinlock_t *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct vmw_marker *__cil_tmp11 ;
  struct list_head *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  struct vmw_marker *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void    *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct vmw_marker *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;

  {
  {
#line 49
  __cil_tmp7 = (unsigned long )queue;
#line 49
  __cil_tmp8 = __cil_tmp7 + 48;
#line 49
  __cil_tmp9 = (spinlock_t *)__cil_tmp8;
#line 49
  spin_lock(__cil_tmp9);
#line 50
  __cil_tmp10 = *((struct list_head **)queue);
#line 50
  __mptr = (struct list_head    *)__cil_tmp10;
#line 50
  __cil_tmp11 = (struct vmw_marker *)0;
#line 50
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
#line 50
  __cil_tmp13 = (unsigned int )__cil_tmp12;
#line 50
  __cil_tmp14 = (char *)__mptr;
#line 50
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
#line 50
  marker = (struct vmw_marker *)__cil_tmp15;
#line 50
  __cil_tmp16 = *((struct list_head **)marker);
#line 50
  __mptr___0 = (struct list_head    *)__cil_tmp16;
#line 50
  __cil_tmp17 = (struct vmw_marker *)0;
#line 50
  __cil_tmp18 = (struct list_head *)__cil_tmp17;
#line 50
  __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 50
  __cil_tmp20 = (char *)__mptr___0;
#line 50
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
#line 50
  next = (struct vmw_marker *)__cil_tmp21;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    __cil_tmp22 = (struct list_head *)queue;
#line 50
    __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 50
    __cil_tmp24 = (struct list_head *)marker;
#line 50
    __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 50
    if (__cil_tmp25 != __cil_tmp23) {

    } else {
#line 50
      goto while_break;
    }
    }
    {
#line 51
    __cil_tmp26 = (void    *)marker;
#line 51
    kfree(__cil_tmp26);
#line 50
    marker = next;
#line 50
    __cil_tmp27 = *((struct list_head **)next);
#line 50
    __mptr___1 = (struct list_head    *)__cil_tmp27;
#line 50
    __cil_tmp28 = (struct vmw_marker *)0;
#line 50
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 50
    __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 50
    __cil_tmp31 = (char *)__mptr___1;
#line 50
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 50
    next = (struct vmw_marker *)__cil_tmp32;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  __cil_tmp33 = (unsigned long )queue;
#line 53
  __cil_tmp34 = __cil_tmp33 + 48;
#line 53
  __cil_tmp35 = (spinlock_t *)__cil_tmp34;
#line 53
  spin_unlock(__cil_tmp35);
  }
#line 54
  return;
}
}
#line 56 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) 
{ struct vmw_marker *marker ;
  void *tmp___7 ;
  long tmp___8 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct timespec *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;

  {
  {
#line 59
  tmp___7 = kmalloc(40UL, 208U);
#line 59
  marker = (struct vmw_marker *)tmp___7;
#line 61
  __cil_tmp6 = ! marker;
#line 61
  __cil_tmp7 = ! __cil_tmp6;
#line 61
  __cil_tmp8 = ! __cil_tmp7;
#line 61
  __cil_tmp9 = (long )__cil_tmp8;
#line 61
  tmp___8 = ldv__builtin_expect(__cil_tmp9, 0L);
  }
#line 61
  if (tmp___8) {
#line 62
    return (-12);
  } else {

  }
  {
#line 64
  __cil_tmp10 = (unsigned long )marker;
#line 64
  __cil_tmp11 = __cil_tmp10 + 16;
#line 64
  *((uint32_t *)__cil_tmp11) = seqno;
#line 65
  __cil_tmp12 = (unsigned long )marker;
#line 65
  __cil_tmp13 = __cil_tmp12 + 24;
#line 65
  __cil_tmp14 = (struct timespec *)__cil_tmp13;
#line 65
  getrawmonotonic(__cil_tmp14);
#line 66
  __cil_tmp15 = (unsigned long )queue;
#line 66
  __cil_tmp16 = __cil_tmp15 + 48;
#line 66
  __cil_tmp17 = (spinlock_t *)__cil_tmp16;
#line 66
  spin_lock(__cil_tmp17);
#line 67
  __cil_tmp18 = (struct list_head *)marker;
#line 67
  __cil_tmp19 = (struct list_head *)queue;
#line 67
  list_add_tail(__cil_tmp18, __cil_tmp19);
#line 68
  __cil_tmp20 = (unsigned long )queue;
#line 68
  __cil_tmp21 = __cil_tmp20 + 48;
#line 68
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
#line 68
  spin_unlock(__cil_tmp22);
  }
#line 70
  return (0);
}
}
#line 73 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct timespec now ;
  bool updated ;
  int tmp___7 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  int tmp___8 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  spinlock_t *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct list_head    *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  s64    __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct timespec *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct vmw_marker *__cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  struct vmw_marker *__cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct timespec *__cil_tmp47 ;
  struct timespec __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct timespec __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct timespec *__cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  void    *__cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  struct vmw_marker *__cil_tmp58 ;
  struct list_head *__cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  spinlock_t *__cil_tmp65 ;
  long __cil_tmp48_tv_nsec66 ;
  __kernel_time_t __cil_tmp48_tv_sec67 ;
  long __cil_tmp51_tv_nsec68 ;
  __kernel_time_t __cil_tmp51_tv_sec69 ;
  __kernel_time_t __cil_tmp70 ;
  long __cil_tmp71 ;
  __kernel_time_t __cil_tmp72 ;
  long __cil_tmp73 ;

  {
  {
#line 78
  updated = (bool )0;
#line 80
  __cil_tmp12 = (unsigned long )queue;
#line 80
  __cil_tmp13 = __cil_tmp12 + 48;
#line 80
  __cil_tmp14 = (spinlock_t *)__cil_tmp13;
#line 80
  spin_lock(__cil_tmp14);
#line 81
  getrawmonotonic(& now);
#line 83
  __cil_tmp15 = (struct list_head *)queue;
#line 83
  __cil_tmp16 = (struct list_head    *)__cil_tmp15;
#line 83
  tmp___7 = list_empty(__cil_tmp16);
  }
#line 83
  if (tmp___7) {
    {
#line 84
    __cil_tmp17 = (unsigned long )queue;
#line 84
    __cil_tmp18 = __cil_tmp17 + 16;
#line 84
    __cil_tmp19 = (s64    )0;
#line 84
    *((struct timespec *)__cil_tmp18) = ns_to_timespec(__cil_tmp19);
#line 85
    __cil_tmp20 = (unsigned long )queue;
#line 85
    __cil_tmp21 = __cil_tmp20 + 32;
#line 85
    __cil_tmp22 = & now;
#line 85
    *((struct timespec *)__cil_tmp21) = *__cil_tmp22;
#line 86
    updated = (bool )1;
    }
#line 87
    goto out_unlock;
  } else {

  }
#line 90
  __cil_tmp23 = *((struct list_head **)queue);
#line 90
  __mptr = (struct list_head    *)__cil_tmp23;
#line 90
  __cil_tmp24 = (struct vmw_marker *)0;
#line 90
  __cil_tmp25 = (struct list_head *)__cil_tmp24;
#line 90
  __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 90
  __cil_tmp27 = (char *)__mptr;
#line 90
  __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 90
  marker = (struct vmw_marker *)__cil_tmp28;
#line 90
  __cil_tmp29 = *((struct list_head **)marker);
#line 90
  __mptr___0 = (struct list_head    *)__cil_tmp29;
#line 90
  __cil_tmp30 = (struct vmw_marker *)0;
#line 90
  __cil_tmp31 = (struct list_head *)__cil_tmp30;
#line 90
  __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 90
  __cil_tmp33 = (char *)__mptr___0;
#line 90
  __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
#line 90
  next = (struct vmw_marker *)__cil_tmp34;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    __cil_tmp35 = (struct list_head *)queue;
#line 90
    __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 90
    __cil_tmp37 = (struct list_head *)marker;
#line 90
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 90
    if (__cil_tmp38 != __cil_tmp36) {

    } else {
#line 90
      goto while_break;
    }
    }
    {
#line 91
    __cil_tmp39 = 1 << 30;
#line 91
    __cil_tmp40 = (uint32_t )__cil_tmp39;
#line 91
    __cil_tmp41 = (unsigned long )marker;
#line 91
    __cil_tmp42 = __cil_tmp41 + 16;
#line 91
    __cil_tmp43 = *((uint32_t *)__cil_tmp42);
#line 91
    __cil_tmp44 = signaled_seqno - __cil_tmp43;
#line 91
    if (__cil_tmp44 > __cil_tmp40) {
#line 92
      goto __Cont;
    } else {

    }
    }
    {
#line 94
    __cil_tmp45 = (unsigned long )queue;
#line 94
    __cil_tmp46 = __cil_tmp45 + 16;
#line 94
    __cil_tmp47 = & now;
#line 94
    __cil_tmp70 = __cil_tmp47->tv_sec;
#line 94
    __cil_tmp71 = __cil_tmp47->tv_nsec;
#line 94
    __cil_tmp48_tv_sec67 = __cil_tmp70;
#line 94
    __cil_tmp48_tv_nsec66 = __cil_tmp71;
#line 94
    __cil_tmp49 = (unsigned long )marker;
#line 94
    __cil_tmp50 = __cil_tmp49 + 24;
#line 94
    __cil_tmp72 = ((struct timespec *)__cil_tmp50)->tv_sec;
#line 94
    __cil_tmp73 = ((struct timespec *)__cil_tmp50)->tv_nsec;
#line 94
    __cil_tmp51_tv_sec69 = __cil_tmp72;
#line 94
    __cil_tmp51_tv_nsec68 = __cil_tmp73;
#line 94
    *((struct timespec *)__cil_tmp46) = timespec_sub(__cil_tmp48_tv_sec67, __cil_tmp48_tv_nsec66,
                                                     __cil_tmp51_tv_sec69, __cil_tmp51_tv_nsec68);
#line 95
    __cil_tmp52 = (unsigned long )queue;
#line 95
    __cil_tmp53 = __cil_tmp52 + 32;
#line 95
    __cil_tmp54 = & now;
#line 95
    *((struct timespec *)__cil_tmp53) = *__cil_tmp54;
#line 96
    updated = (bool )1;
#line 97
    __cil_tmp55 = (struct list_head *)marker;
#line 97
    list_del(__cil_tmp55);
#line 98
    __cil_tmp56 = (void    *)marker;
#line 98
    kfree(__cil_tmp56);
    }
    __Cont: /* CIL Label */ 
#line 90
    marker = next;
#line 90
    __cil_tmp57 = *((struct list_head **)next);
#line 90
    __mptr___1 = (struct list_head    *)__cil_tmp57;
#line 90
    __cil_tmp58 = (struct vmw_marker *)0;
#line 90
    __cil_tmp59 = (struct list_head *)__cil_tmp58;
#line 90
    __cil_tmp60 = (unsigned int )__cil_tmp59;
#line 90
    __cil_tmp61 = (char *)__mptr___1;
#line 90
    __cil_tmp62 = __cil_tmp61 - __cil_tmp60;
#line 90
    next = (struct vmw_marker *)__cil_tmp62;
  }
  while_break: /* CIL Label */ ;
  }
  out_unlock: 
  {
#line 102
  __cil_tmp63 = (unsigned long )queue;
#line 102
  __cil_tmp64 = __cil_tmp63 + 48;
#line 102
  __cil_tmp65 = (spinlock_t *)__cil_tmp64;
#line 102
  spin_unlock(__cil_tmp65);
  }
#line 104
  if (updated) {
#line 104
    tmp___8 = 0;
  } else {
#line 104
    tmp___8 = -16;
  }
#line 104
  return (tmp___8);
}
}
#line 107 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
static struct timespec vmw_timespec_add(__kernel_time_t t1_tv_sec6 , long t1_tv_nsec5 ,
                                        __kernel_time_t t2_tv_sec4 , long t2_tv_nsec3 ) 
{ 

	struct timespec t1;
  {
#line 110
  t1_tv_sec6 = t1_tv_sec6 + t2_tv_sec4;
#line 111
  t1_tv_nsec5 = t1_tv_nsec5 + t2_tv_nsec3;
#line 112
  if (t1_tv_nsec5 >= 1000000000L) {
#line 113
    t1_tv_sec6 = t1_tv_sec6 + 1L;
#line 114
    t1_tv_nsec5 = t1_tv_nsec5 - 1000000000L;
  } else {

  }
#line 117
  return (t1);
}
}
#line 120 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
static struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue ) 
{ struct timespec now ;
  struct timespec tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  spinlock_t *__cil_tmp6 ;
  struct timespec *__cil_tmp7 ;
  struct timespec __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct timespec __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct timespec __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct timespec *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  long __cil_tmp8_tv_nsec25 ;
  __kernel_time_t __cil_tmp8_tv_sec26 ;
  long __cil_tmp11_tv_nsec27 ;
  __kernel_time_t __cil_tmp11_tv_sec28 ;
  long __cil_tmp16_tv_nsec29 ;
  __kernel_time_t __cil_tmp16_tv_sec30 ;
  __kernel_time_t __cil_tmp31 ;
  long __cil_tmp32 ;
  __kernel_time_t __cil_tmp33 ;
  long __cil_tmp34 ;
  __kernel_time_t __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  {
#line 124
  __cil_tmp4 = (unsigned long )queue;
#line 124
  __cil_tmp5 = __cil_tmp4 + 48;
#line 124
  __cil_tmp6 = (spinlock_t *)__cil_tmp5;
#line 124
  spin_lock(__cil_tmp6);
#line 125
  getrawmonotonic(& now);
#line 126
  __cil_tmp7 = & now;
#line 126
  __cil_tmp31 = __cil_tmp7->tv_sec;
#line 126
  __cil_tmp32 = __cil_tmp7->tv_nsec;
#line 126
  __cil_tmp8_tv_sec26 = __cil_tmp31;
#line 126
  __cil_tmp8_tv_nsec25 = __cil_tmp32;
#line 126
  __cil_tmp9 = (unsigned long )queue;
#line 126
  __cil_tmp10 = __cil_tmp9 + 32;
#line 126
  __cil_tmp33 = ((struct timespec *)__cil_tmp10)->tv_sec;
#line 126
  __cil_tmp34 = ((struct timespec *)__cil_tmp10)->tv_nsec;
#line 126
  __cil_tmp11_tv_sec28 = __cil_tmp33;
#line 126
  __cil_tmp11_tv_nsec27 = __cil_tmp34;
#line 126
  tmp___7 = timespec_sub(__cil_tmp8_tv_sec26, __cil_tmp8_tv_nsec25, __cil_tmp11_tv_sec28,
                         __cil_tmp11_tv_nsec27);
#line 126
  __cil_tmp12 = (unsigned long )queue;
#line 126
  __cil_tmp13 = __cil_tmp12 + 16;
#line 126
  __cil_tmp14 = (unsigned long )queue;
#line 126
  __cil_tmp15 = __cil_tmp14 + 16;
#line 126
  __cil_tmp35 = ((struct timespec *)__cil_tmp15)->tv_sec;
#line 126
  __cil_tmp36 = ((struct timespec *)__cil_tmp15)->tv_nsec;
#line 126
  __cil_tmp16_tv_sec30 = __cil_tmp35;
#line 126
  __cil_tmp16_tv_nsec29 = __cil_tmp36;
#line 126
  *((struct timespec *)__cil_tmp13) = vmw_timespec_add(__cil_tmp16_tv_sec30, __cil_tmp16_tv_nsec29,
                                                       tmp___7.tv_sec, tmp___7.tv_nsec);
#line 128
  __cil_tmp17 = (unsigned long )queue;
#line 128
  __cil_tmp18 = __cil_tmp17 + 32;
#line 128
  __cil_tmp19 = & now;
#line 128
  *((struct timespec *)__cil_tmp18) = *__cil_tmp19;
#line 129
  __cil_tmp20 = (unsigned long )queue;
#line 129
  __cil_tmp21 = __cil_tmp20 + 48;
#line 129
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
#line 129
  spin_unlock(__cil_tmp22);
  }
  {
#line 130
  __cil_tmp23 = (unsigned long )queue;
#line 130
  __cil_tmp24 = __cil_tmp23 + 16;
#line 130
  return (*((struct timespec *)__cil_tmp24));
  }
}
}
#line 134 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
static bool vmw_lag_lt(struct vmw_marker_queue *queue , uint32_t us ) 
{ struct timespec lag ;
  struct timespec cond ;
  int tmp___7 ;
  struct timespec *__cil_tmp6 ;
  s64 __cil_tmp7 ;
  s64 __cil_tmp8 ;
  s64    __cil_tmp9 ;
  struct timespec *__cil_tmp10 ;
  struct timespec    *__cil_tmp11 ;
  struct timespec    *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 139
  __cil_tmp6 = & cond;
#line 139
  __cil_tmp7 = (s64 )us;
#line 139
  __cil_tmp8 = __cil_tmp7 * 1000LL;
#line 139
  __cil_tmp9 = (s64    )__cil_tmp8;
#line 139
  *__cil_tmp6 = ns_to_timespec(__cil_tmp9);
#line 140
  __cil_tmp10 = & lag;
#line 140
  *__cil_tmp10 = vmw_fifo_lag(queue);
#line 141
  __cil_tmp11 = (struct timespec    *)(& lag);
#line 141
  __cil_tmp12 = (struct timespec    *)(& cond);
#line 141
  tmp___7 = timespec_compare(__cil_tmp11, __cil_tmp12);
  }
  {
#line 141
  __cil_tmp13 = tmp___7 < 1;
#line 141
  return ((bool )__cil_tmp13);
  }
}
}
#line 144 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c"
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) 
{ struct vmw_marker *marker ;
  uint32_t seqno ;
  int ret ;
  int tmp___7 ;
  struct list_head    *__mptr ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  spinlock_t *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct list_head    *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  atomic_t *__cil_tmp19 ;
  atomic_t    *__cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct vmw_marker *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  spinlock_t *__cil_tmp31 ;
  bool __cil_tmp32 ;
  bool __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;

  {
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    tmp___10 = vmw_lag_lt(queue, us);
    }
#line 151
    if (tmp___10) {
#line 151
      goto while_break;
    } else {

    }
    {
#line 152
    __cil_tmp12 = (unsigned long )queue;
#line 152
    __cil_tmp13 = __cil_tmp12 + 48;
#line 152
    __cil_tmp14 = (spinlock_t *)__cil_tmp13;
#line 152
    spin_lock(__cil_tmp14);
#line 153
    __cil_tmp15 = (struct list_head *)queue;
#line 153
    __cil_tmp16 = (struct list_head    *)__cil_tmp15;
#line 153
    tmp___8 = list_empty(__cil_tmp16);
    }
#line 153
    if (tmp___8) {
      {
#line 154
      __cil_tmp17 = (unsigned long )dev_priv;
#line 154
      __cil_tmp18 = __cil_tmp17 + 2880;
#line 154
      __cil_tmp19 = (atomic_t *)__cil_tmp18;
#line 154
      __cil_tmp20 = (atomic_t    *)__cil_tmp19;
#line 154
      tmp___7 = atomic_read(__cil_tmp20);
#line 154
      seqno = (uint32_t )tmp___7;
      }
    } else {
#line 156
      __cil_tmp21 = *((struct list_head **)queue);
#line 156
      __mptr = (struct list_head    *)__cil_tmp21;
#line 156
      __cil_tmp22 = (struct vmw_marker *)0;
#line 156
      __cil_tmp23 = (struct list_head *)__cil_tmp22;
#line 156
      __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 156
      __cil_tmp25 = (char *)__mptr;
#line 156
      __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 156
      marker = (struct vmw_marker *)__cil_tmp26;
#line 158
      __cil_tmp27 = (unsigned long )marker;
#line 158
      __cil_tmp28 = __cil_tmp27 + 16;
#line 158
      seqno = *((uint32_t *)__cil_tmp28);
    }
    {
#line 160
    __cil_tmp29 = (unsigned long )queue;
#line 160
    __cil_tmp30 = __cil_tmp29 + 48;
#line 160
    __cil_tmp31 = (spinlock_t *)__cil_tmp30;
#line 160
    spin_unlock(__cil_tmp31);
#line 162
    __cil_tmp32 = (bool )0;
#line 162
    __cil_tmp33 = (bool )1;
#line 162
    ret = vmw_wait_seqno(dev_priv, __cil_tmp32, seqno, __cil_tmp33, 750UL);
#line 165
    __cil_tmp34 = ret != 0;
#line 165
    __cil_tmp35 = ! __cil_tmp34;
#line 165
    __cil_tmp36 = ! __cil_tmp35;
#line 165
    __cil_tmp37 = (long )__cil_tmp36;
#line 165
    tmp___9 = ldv__builtin_expect(__cil_tmp37, 0L);
    }
#line 165
    if (tmp___9) {
#line 166
      return (ret);
    } else {

    }
    {
#line 168
    vmw_marker_pull(queue, seqno);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (0);
}
}
#line 142 "include/linux/idr.h"
extern int ida_pre_get(struct ida *ida , gfp_t gfp_mask ) ;
#line 144
extern int ida_get_new(struct ida *ida , int *p_id ) ;
#line 145
extern void ida_remove(struct ida *ida , int id ) ;
#line 146
extern void ida_destroy(struct ida *ida ) ;
#line 147
extern void ida_init(struct ida *ida ) ;
#line 47 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                                  struct ttm_placement *placement , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;
  int ret ;
  int id ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  spinlock_t *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  spinlock_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct ida *__cil_tmp45 ;
  long __cil_tmp46 ;
  spinlock_t *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ida *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  int *__cil_tmp54 ;
  int __cil_tmp55 ;
  uint32_t __cil_tmp56 ;
  long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct ida *__cil_tmp60 ;
  int *__cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  int *__cil_tmp69 ;
  int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  spinlock_t *__cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  spinlock_t *__cil_tmp87 ;

  {
  {
#line 52
  __cil_tmp15 = (unsigned long )man;
#line 52
  __cil_tmp16 = __cil_tmp15 + 48;
#line 52
  __cil_tmp17 = *((void **)__cil_tmp16);
#line 52
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp17;
#line 54
  ret = 0;
#line 57
  *((void **)mem) = (void *)0;
#line 59
  __cil_tmp18 = (spinlock_t *)gman;
#line 59
  spin_lock(__cil_tmp18);
  }
  {
#line 61
  __cil_tmp19 = (unsigned long )gman;
#line 61
  __cil_tmp20 = __cil_tmp19 + 84;
#line 61
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
#line 61
  if (__cil_tmp21 > 0U) {
    {
#line 62
    __cil_tmp22 = (unsigned long )gman;
#line 62
    __cil_tmp23 = __cil_tmp22 + 88;
#line 62
    __cil_tmp24 = (unsigned long )bo;
#line 62
    __cil_tmp25 = __cil_tmp24 + 40;
#line 62
    __cil_tmp26 = *((unsigned long *)__cil_tmp25);
#line 62
    __cil_tmp27 = (unsigned long )gman;
#line 62
    __cil_tmp28 = __cil_tmp27 + 88;
#line 62
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
#line 62
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 62
    __cil_tmp31 = __cil_tmp30 + __cil_tmp26;
#line 62
    *((uint32_t *)__cil_tmp23) = (uint32_t )__cil_tmp31;
#line 63
    __cil_tmp32 = (unsigned long )gman;
#line 63
    __cil_tmp33 = __cil_tmp32 + 84;
#line 63
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
#line 63
    __cil_tmp35 = (unsigned long )gman;
#line 63
    __cil_tmp36 = __cil_tmp35 + 88;
#line 63
    __cil_tmp37 = *((uint32_t *)__cil_tmp36);
#line 63
    __cil_tmp38 = __cil_tmp37 > __cil_tmp34;
#line 63
    __cil_tmp39 = ! __cil_tmp38;
#line 63
    __cil_tmp40 = ! __cil_tmp39;
#line 63
    __cil_tmp41 = (long )__cil_tmp40;
#line 63
    tmp___7 = ldv__builtin_expect(__cil_tmp41, 0L);
    }
#line 63
    if (tmp___7) {
#line 64
      goto out_err_locked;
    } else {

    }
  } else {

  }
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    __cil_tmp42 = (spinlock_t *)gman;
#line 68
    spin_unlock(__cil_tmp42);
#line 69
    __cil_tmp43 = (unsigned long )gman;
#line 69
    __cil_tmp44 = __cil_tmp43 + 24;
#line 69
    __cil_tmp45 = (struct ida *)__cil_tmp44;
#line 69
    tmp___8 = ida_pre_get(__cil_tmp45, 208U);
    }
#line 69
    if (tmp___8 == 0) {
#line 69
      tmp___9 = 1;
    } else {
#line 69
      tmp___9 = 0;
    }
    {
#line 69
    __cil_tmp46 = (long )tmp___9;
#line 69
    tmp___10 = ldv__builtin_expect(__cil_tmp46, 0L);
    }
#line 69
    if (tmp___10) {
#line 70
      ret = -12;
#line 71
      goto out_err;
    } else {

    }
    {
#line 73
    __cil_tmp47 = (spinlock_t *)gman;
#line 73
    spin_lock(__cil_tmp47);
#line 75
    __cil_tmp48 = (unsigned long )gman;
#line 75
    __cil_tmp49 = __cil_tmp48 + 24;
#line 75
    __cil_tmp50 = (struct ida *)__cil_tmp49;
#line 75
    ret = ida_get_new(__cil_tmp50, & id);
    }
#line 76
    if (ret == 0) {
      {
#line 76
      __cil_tmp51 = (unsigned long )gman;
#line 76
      __cil_tmp52 = __cil_tmp51 + 80;
#line 76
      __cil_tmp53 = *((uint32_t *)__cil_tmp52);
#line 76
      __cil_tmp54 = & id;
#line 76
      __cil_tmp55 = *__cil_tmp54;
#line 76
      __cil_tmp56 = (uint32_t )__cil_tmp55;
#line 76
      if (__cil_tmp56 >= __cil_tmp53) {
#line 76
        tmp___11 = 1;
      } else {
#line 76
        tmp___11 = 0;
      }
      }
    } else {
#line 76
      tmp___11 = 0;
    }
    {
#line 76
    __cil_tmp57 = (long )tmp___11;
#line 76
    tmp___12 = ldv__builtin_expect(__cil_tmp57, 0L);
    }
#line 76
    if (tmp___12) {
      {
#line 77
      __cil_tmp58 = (unsigned long )gman;
#line 77
      __cil_tmp59 = __cil_tmp58 + 24;
#line 77
      __cil_tmp60 = (struct ida *)__cil_tmp59;
#line 77
      __cil_tmp61 = & id;
#line 77
      __cil_tmp62 = *__cil_tmp61;
#line 77
      ida_remove(__cil_tmp60, __cil_tmp62);
#line 78
      ret = 0;
      }
#line 79
      goto out_err_locked;
    } else {

    }
#line 67
    if (ret == -11) {

    } else {
#line 67
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  __cil_tmp63 = ret == 0;
#line 83
  __cil_tmp64 = ! __cil_tmp63;
#line 83
  __cil_tmp65 = ! __cil_tmp64;
#line 83
  __cil_tmp66 = (long )__cil_tmp65;
#line 83
  tmp___13 = ldv__builtin_expect(__cil_tmp66, 1L);
  }
#line 83
  if (tmp___13) {
#line 84
    *((void **)mem) = (void *)gman;
#line 85
    __cil_tmp67 = (unsigned long )mem;
#line 85
    __cil_tmp68 = __cil_tmp67 + 8;
#line 85
    __cil_tmp69 = & id;
#line 85
    __cil_tmp70 = *__cil_tmp69;
#line 85
    *((unsigned long *)__cil_tmp68) = (unsigned long )__cil_tmp70;
#line 86
    __cil_tmp71 = (unsigned long )mem;
#line 86
    __cil_tmp72 = __cil_tmp71 + 24;
#line 86
    __cil_tmp73 = (unsigned long )bo;
#line 86
    __cil_tmp74 = __cil_tmp73 + 40;
#line 86
    *((unsigned long *)__cil_tmp72) = *((unsigned long *)__cil_tmp74);
  } else {
#line 88
    goto out_err_locked;
  }
  {
#line 90
  __cil_tmp75 = (spinlock_t *)gman;
#line 90
  spin_unlock(__cil_tmp75);
  }
#line 91
  return (0);
  out_err: 
  {
#line 94
  __cil_tmp76 = (spinlock_t *)gman;
#line 94
  spin_lock(__cil_tmp76);
  }
  out_err_locked: 
  {
#line 96
  __cil_tmp77 = (unsigned long )gman;
#line 96
  __cil_tmp78 = __cil_tmp77 + 88;
#line 96
  __cil_tmp79 = (unsigned long )bo;
#line 96
  __cil_tmp80 = __cil_tmp79 + 40;
#line 96
  __cil_tmp81 = *((unsigned long *)__cil_tmp80);
#line 96
  __cil_tmp82 = (unsigned long )gman;
#line 96
  __cil_tmp83 = __cil_tmp82 + 88;
#line 96
  __cil_tmp84 = *((uint32_t *)__cil_tmp83);
#line 96
  __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 96
  __cil_tmp86 = __cil_tmp85 - __cil_tmp81;
#line 96
  *((uint32_t *)__cil_tmp78) = (uint32_t )__cil_tmp86;
#line 97
  __cil_tmp87 = (spinlock_t *)gman;
#line 97
  spin_unlock(__cil_tmp87);
  }
#line 98
  return (ret);
}
}
#line 101 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  spinlock_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct ida *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;

  {
#line 104
  __cil_tmp4 = (unsigned long )man;
#line 104
  __cil_tmp5 = __cil_tmp4 + 48;
#line 104
  __cil_tmp6 = *((void **)__cil_tmp5);
#line 104
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp6;
#line 107
  if (*((void **)mem)) {
    {
#line 108
    __cil_tmp7 = (spinlock_t *)gman;
#line 108
    spin_lock(__cil_tmp7);
#line 109
    __cil_tmp8 = (unsigned long )gman;
#line 109
    __cil_tmp9 = __cil_tmp8 + 24;
#line 109
    __cil_tmp10 = (struct ida *)__cil_tmp9;
#line 109
    __cil_tmp11 = (unsigned long )mem;
#line 109
    __cil_tmp12 = __cil_tmp11 + 8;
#line 109
    __cil_tmp13 = *((unsigned long *)__cil_tmp12);
#line 109
    __cil_tmp14 = (int )__cil_tmp13;
#line 109
    ida_remove(__cil_tmp10, __cil_tmp14);
#line 110
    __cil_tmp15 = (unsigned long )gman;
#line 110
    __cil_tmp16 = __cil_tmp15 + 88;
#line 110
    __cil_tmp17 = (unsigned long )mem;
#line 110
    __cil_tmp18 = __cil_tmp17 + 24;
#line 110
    __cil_tmp19 = *((unsigned long *)__cil_tmp18);
#line 110
    __cil_tmp20 = (unsigned long )gman;
#line 110
    __cil_tmp21 = __cil_tmp20 + 88;
#line 110
    __cil_tmp22 = *((uint32_t *)__cil_tmp21);
#line 110
    __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 110
    __cil_tmp24 = __cil_tmp23 - __cil_tmp19;
#line 110
    *((uint32_t *)__cil_tmp16) = (uint32_t )__cil_tmp24;
#line 111
    __cil_tmp25 = (spinlock_t *)gman;
#line 111
    spin_unlock(__cil_tmp25);
#line 112
    *((void **)mem) = (void *)0;
    }
  } else {

  }
#line 114
  return;
}
}
#line 127 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static struct lock_class_key __key___18  ;
#line 116 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static int vmw_gmrid_man_init(struct ttm_mem_type_manager *man , unsigned long p_size ) 
{ struct vmw_private *dev_priv ;
  struct ttm_bo_device    *__mptr ;
  struct vmwgfx_gmrid_man *gman ;
  void *tmp___7 ;
  long tmp___8 ;
  struct ttm_bo_device *__cil_tmp8 ;
  struct vmw_private *__cil_tmp9 ;
  struct ttm_bo_device *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  struct raw_spinlock *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct ida *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;

  {
  {
#line 120
  __cil_tmp8 = *((struct ttm_bo_device **)man);
#line 120
  __mptr = (struct ttm_bo_device    *)__cil_tmp8;
#line 120
  __cil_tmp9 = (struct vmw_private *)0;
#line 120
  __cil_tmp10 = (struct ttm_bo_device *)__cil_tmp9;
#line 120
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 120
  __cil_tmp12 = (char *)__mptr;
#line 120
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 120
  dev_priv = (struct vmw_private *)__cil_tmp13;
#line 121
  tmp___7 = kzalloc(96UL, 208U);
#line 121
  gman = (struct vmwgfx_gmrid_man *)tmp___7;
#line 124
  __cil_tmp14 = (void *)0;
#line 124
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 124
  __cil_tmp16 = (unsigned long )gman;
#line 124
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
#line 124
  __cil_tmp18 = ! __cil_tmp17;
#line 124
  __cil_tmp19 = ! __cil_tmp18;
#line 124
  __cil_tmp20 = (long )__cil_tmp19;
#line 124
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  }
#line 124
  if (tmp___8) {
#line 125
    return (-12);
  } else {

  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    __cil_tmp21 = (spinlock_t *)gman;
#line 127
    spinlock_check(__cil_tmp21);
    }
    {
#line 127
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 127
      __cil_tmp22 = (struct raw_spinlock *)gman;
#line 127
      __raw_spin_lock_init(__cil_tmp22, "&(&gman->lock)->rlock", & __key___18);
      }
#line 127
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  __cil_tmp23 = (unsigned long )gman;
#line 128
  __cil_tmp24 = __cil_tmp23 + 84;
#line 128
  __cil_tmp25 = (unsigned long )dev_priv;
#line 128
  __cil_tmp26 = __cil_tmp25 + 2168;
#line 128
  *((uint32_t *)__cil_tmp24) = *((uint32_t *)__cil_tmp26);
#line 129
  __cil_tmp27 = (unsigned long )gman;
#line 129
  __cil_tmp28 = __cil_tmp27 + 88;
#line 129
  *((uint32_t *)__cil_tmp28) = (uint32_t )0;
#line 130
  __cil_tmp29 = (unsigned long )gman;
#line 130
  __cil_tmp30 = __cil_tmp29 + 24;
#line 130
  __cil_tmp31 = (struct ida *)__cil_tmp30;
#line 130
  ida_init(__cil_tmp31);
#line 131
  __cil_tmp32 = (unsigned long )gman;
#line 131
  __cil_tmp33 = __cil_tmp32 + 80;
#line 131
  *((uint32_t *)__cil_tmp33) = (uint32_t )p_size;
#line 132
  __cil_tmp34 = (unsigned long )man;
#line 132
  __cil_tmp35 = __cil_tmp34 + 48;
#line 132
  *((void **)__cil_tmp35) = (void *)gman;
  }
#line 133
  return (0);
}
}
#line 136 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man ) 
{ struct vmwgfx_gmrid_man *gman ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ida *__cil_tmp8 ;
  void    *__cil_tmp9 ;

  {
#line 138
  __cil_tmp3 = (unsigned long )man;
#line 138
  __cil_tmp4 = __cil_tmp3 + 48;
#line 138
  __cil_tmp5 = *((void **)__cil_tmp4);
#line 138
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp5;
#line 141
  if (gman) {
    {
#line 142
    __cil_tmp6 = (unsigned long )gman;
#line 142
    __cil_tmp7 = __cil_tmp6 + 24;
#line 142
    __cil_tmp8 = (struct ida *)__cil_tmp7;
#line 142
    ida_destroy(__cil_tmp8);
#line 143
    __cil_tmp9 = (void    *)gman;
#line 143
    kfree(__cil_tmp9);
    }
  } else {

  }
#line 145
  return (0);
}
}
#line 148 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
static void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man , char    *prefix ) 
{ 

  {
  {
#line 151
  printk("<6>%s: No debug info available for the GMR id manager.\n", prefix);
  }
#line 153
  return;
}
}
#line 155 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c"
struct ttm_mem_type_manager_func    vmw_gmrid_manager_func  =    {& vmw_gmrid_man_init, & vmw_gmrid_man_takedown, & vmw_gmrid_man_get_node, & vmw_gmrid_man_put_node,
    & vmw_gmrid_man_debug};
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head    *list , struct list_head *prev ,
                                   struct list_head *next )  __attribute__((__no_instrument_function__)) ;
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head    *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *   __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct list_head *   __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;

  {
#line 277
  __cil_tmp6 = *((struct list_head *   *)list);
#line 277
  first = (struct list_head *)__cil_tmp6;
#line 278
  __cil_tmp7 = (unsigned long )list;
#line 278
  __cil_tmp8 = __cil_tmp7 + 8;
#line 278
  __cil_tmp9 = *((struct list_head *   *)__cil_tmp8);
#line 278
  last = (struct list_head *)__cil_tmp9;
#line 280
  __cil_tmp10 = (unsigned long )first;
#line 280
  __cil_tmp11 = __cil_tmp10 + 8;
#line 280
  *((struct list_head **)__cil_tmp11) = prev;
#line 281
  *((struct list_head **)prev) = first;
#line 283
  *((struct list_head **)last) = next;
#line 284
  __cil_tmp12 = (unsigned long )next;
#line 284
  __cil_tmp13 = __cil_tmp12 + 8;
#line 284
  *((struct list_head **)__cil_tmp13) = last;
#line 285
  return;
}
}
#line 318
__inline static void list_splice_init(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;
  struct list_head    *__cil_tmp4 ;
  struct list_head    *__cil_tmp5 ;
  struct list_head *__cil_tmp6 ;

  {
  {
#line 321
  __cil_tmp4 = (struct list_head    *)list;
#line 321
  tmp = list_empty(__cil_tmp4);
  }
#line 321
  if (tmp) {

  } else {
    {
#line 322
    __cil_tmp5 = (struct list_head    *)list;
#line 322
    __cil_tmp6 = *((struct list_head **)head);
#line 322
    __list_splice(__cil_tmp5, head, __cil_tmp6);
#line 323
    INIT_LIST_HEAD(list);
    }
  }
#line 325
  return;
}
}
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 310
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 310
  _raw_spin_lock_irq(__cil_tmp2);
  }
#line 311
  return;
}
}
#line 333
__inline static void spin_unlock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 335
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 335
  _raw_spin_unlock_irq(__cil_tmp2);
  }
#line 336
  return;
}
}
#line 148 "include/linux/time.h"
extern void do_gettimeofday(struct timeval *tv ) ;
#line 156 "include/linux/workqueue.h"
extern void __init_work(struct work_struct *work , int onstack ) ;
#line 380
extern int schedule_work(struct work_struct *work ) ;
#line 392
extern bool cancel_work_sync(struct work_struct *work ) ;
#line 105 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_fence_obj_destroy_locked(struct kref *kref ) 
{ struct vmw_fence_obj *fence ;
  struct kref    *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned int num_fences ;
  struct vmw_fence_obj *__cil_tmp6 ;
  struct kref *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  spinlock_t *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void (*__cil_tmp25)(struct vmw_fence_obj *fence ) ;
  void    *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  spinlock_t *__cil_tmp29 ;

  {
  {
#line 108
  __mptr = (struct kref    *)kref;
#line 108
  __cil_tmp6 = (struct vmw_fence_obj *)0;
#line 108
  __cil_tmp7 = (struct kref *)__cil_tmp6;
#line 108
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 108
  __cil_tmp9 = (char *)__mptr;
#line 108
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 108
  fence = (struct vmw_fence_obj *)__cil_tmp10;
#line 110
  __cil_tmp11 = (unsigned long )fence;
#line 110
  __cil_tmp12 = __cil_tmp11 + 8;
#line 110
  fman = *((struct vmw_fence_manager **)__cil_tmp12);
#line 113
  __cil_tmp13 = (unsigned long )fence;
#line 113
  __cil_tmp14 = __cil_tmp13 + 16;
#line 113
  __cil_tmp15 = (struct list_head *)__cil_tmp14;
#line 113
  list_del_init(__cil_tmp15);
#line 114
  __cil_tmp16 = *((int *)fman);
#line 114
  *((int *)fman) = __cil_tmp16 - 1;
#line 114
  __cil_tmp17 = *((int *)fman);
#line 114
  num_fences = (unsigned int )__cil_tmp17;
#line 115
  __cil_tmp18 = (unsigned long )fman;
#line 115
  __cil_tmp19 = __cil_tmp18 + 16;
#line 115
  __cil_tmp20 = (spinlock_t *)__cil_tmp19;
#line 115
  spin_unlock_irq(__cil_tmp20);
  }
  {
#line 116
  __cil_tmp21 = (unsigned long )fence;
#line 116
  __cil_tmp22 = __cil_tmp21 + 56;
#line 116
  if (*((void (**)(struct vmw_fence_obj *fence ))__cil_tmp22)) {
    {
#line 117
    __cil_tmp23 = (unsigned long )fence;
#line 117
    __cil_tmp24 = __cil_tmp23 + 56;
#line 117
    __cil_tmp25 = *((void (**)(struct vmw_fence_obj *fence ))__cil_tmp24);
#line 117
    (*__cil_tmp25)(fence);
    }
  } else {
    {
#line 119
    __cil_tmp26 = (void    *)fence;
#line 119
    kfree(__cil_tmp26);
    }
  }
  }
  {
#line 121
  __cil_tmp27 = (unsigned long )fman;
#line 121
  __cil_tmp28 = __cil_tmp27 + 16;
#line 121
  __cil_tmp29 = (spinlock_t *)__cil_tmp28;
#line 121
  spin_lock_irq(__cil_tmp29);
  }
#line 122
  return;
}
}
#line 131 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_fence_work_func(struct work_struct *work ) 
{ struct vmw_fence_manager *fman ;
  struct work_struct    *__mptr ;
  struct list_head list ;
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  bool seqno_valid ;
  int tmp___7 ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  struct list_head    *__mptr___2 ;
  struct vmw_fence_manager *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct work_struct *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  spinlock_t *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  spinlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_private *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct mutex *__cil_tmp42 ;
  struct list_head    *__cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  struct vmw_fence_action *__cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  struct vmw_fence_action *__cil_tmp52 ;
  struct list_head *__cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  void (*__cil_tmp65)(struct vmw_fence_action *action ) ;
  struct list_head *__cil_tmp66 ;
  struct vmw_fence_action *__cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
#line 134
  __mptr = (struct work_struct    *)work;
#line 134
  __cil_tmp12 = (struct vmw_fence_manager *)0;
#line 134
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 134
  __cil_tmp14 = __cil_tmp13 + 56;
#line 134
  __cil_tmp15 = (struct work_struct *)__cil_tmp14;
#line 134
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 134
  __cil_tmp17 = (char *)__mptr;
#line 134
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 134
  fman = (struct vmw_fence_manager *)__cil_tmp18;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    INIT_LIST_HEAD(& list);
#line 141
    __cil_tmp19 = (unsigned long )fman;
#line 141
    __cil_tmp20 = __cil_tmp19 + 128;
#line 141
    __cil_tmp21 = (struct mutex *)__cil_tmp20;
#line 141
    mutex_lock(__cil_tmp21);
#line 143
    __cil_tmp22 = (unsigned long )fman;
#line 143
    __cil_tmp23 = __cil_tmp22 + 16;
#line 143
    __cil_tmp24 = (spinlock_t *)__cil_tmp23;
#line 143
    spin_lock_irq(__cil_tmp24);
#line 144
    __cil_tmp25 = (unsigned long )fman;
#line 144
    __cil_tmp26 = __cil_tmp25 + 104;
#line 144
    __cil_tmp27 = (struct list_head *)__cil_tmp26;
#line 144
    list_splice_init(__cil_tmp27, & list);
#line 145
    __cil_tmp28 = (unsigned long )fman;
#line 145
    __cil_tmp29 = __cil_tmp28 + 201;
#line 145
    seqno_valid = *((bool *)__cil_tmp29);
#line 146
    __cil_tmp30 = (unsigned long )fman;
#line 146
    __cil_tmp31 = __cil_tmp30 + 16;
#line 146
    __cil_tmp32 = (spinlock_t *)__cil_tmp31;
#line 146
    spin_unlock_irq(__cil_tmp32);
    }
#line 148
    if (! seqno_valid) {
      {
#line 148
      __cil_tmp33 = (unsigned long )fman;
#line 148
      __cil_tmp34 = __cil_tmp33 + 200;
#line 148
      if (*((bool *)__cil_tmp34)) {
        {
#line 149
        __cil_tmp35 = (unsigned long )fman;
#line 149
        __cil_tmp36 = __cil_tmp35 + 200;
#line 149
        *((bool *)__cil_tmp36) = (bool )0;
#line 150
        __cil_tmp37 = (unsigned long )fman;
#line 150
        __cil_tmp38 = __cil_tmp37 + 8;
#line 150
        __cil_tmp39 = *((struct vmw_private **)__cil_tmp38);
#line 150
        vmw_goal_waiter_remove(__cil_tmp39);
        }
      } else {

      }
      }
    } else {

    }
    {
#line 152
    __cil_tmp40 = (unsigned long )fman;
#line 152
    __cil_tmp41 = __cil_tmp40 + 128;
#line 152
    __cil_tmp42 = (struct mutex *)__cil_tmp41;
#line 152
    mutex_unlock(__cil_tmp42);
#line 154
    __cil_tmp43 = (struct list_head    *)(& list);
#line 154
    tmp___7 = list_empty(__cil_tmp43);
    }
#line 154
    if (tmp___7) {
#line 155
      return;
    } else {

    }
#line 163
    __cil_tmp44 = & list;
#line 163
    __cil_tmp45 = *((struct list_head **)__cil_tmp44);
#line 163
    __mptr___0 = (struct list_head    *)__cil_tmp45;
#line 163
    __cil_tmp46 = (struct vmw_fence_action *)0;
#line 163
    __cil_tmp47 = (struct list_head *)__cil_tmp46;
#line 163
    __cil_tmp48 = (unsigned int )__cil_tmp47;
#line 163
    __cil_tmp49 = (char *)__mptr___0;
#line 163
    __cil_tmp50 = __cil_tmp49 - __cil_tmp48;
#line 163
    action = (struct vmw_fence_action *)__cil_tmp50;
#line 163
    __cil_tmp51 = *((struct list_head **)action);
#line 163
    __mptr___1 = (struct list_head    *)__cil_tmp51;
#line 163
    __cil_tmp52 = (struct vmw_fence_action *)0;
#line 163
    __cil_tmp53 = (struct list_head *)__cil_tmp52;
#line 163
    __cil_tmp54 = (unsigned int )__cil_tmp53;
#line 163
    __cil_tmp55 = (char *)__mptr___1;
#line 163
    __cil_tmp56 = __cil_tmp55 - __cil_tmp54;
#line 163
    next_action = (struct vmw_fence_action *)__cil_tmp56;
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 163
      __cil_tmp57 = (unsigned long )(& list);
#line 163
      __cil_tmp58 = (struct list_head *)action;
#line 163
      __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 163
      if (__cil_tmp59 != __cil_tmp57) {

      } else {
#line 163
        goto while_break___0;
      }
      }
      {
#line 164
      __cil_tmp60 = (struct list_head *)action;
#line 164
      list_del_init(__cil_tmp60);
      }
      {
#line 165
      __cil_tmp61 = (unsigned long )action;
#line 165
      __cil_tmp62 = __cil_tmp61 + 32;
#line 165
      if (*((void (**)(struct vmw_fence_action *action ))__cil_tmp62)) {
        {
#line 166
        __cil_tmp63 = (unsigned long )action;
#line 166
        __cil_tmp64 = __cil_tmp63 + 32;
#line 166
        __cil_tmp65 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp64);
#line 166
        (*__cil_tmp65)(action);
        }
      } else {

      }
      }
#line 163
      action = next_action;
#line 163
      __cil_tmp66 = *((struct list_head **)next_action);
#line 163
      __mptr___2 = (struct list_head    *)__cil_tmp66;
#line 163
      __cil_tmp67 = (struct vmw_fence_action *)0;
#line 163
      __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 163
      __cil_tmp69 = (unsigned int )__cil_tmp68;
#line 163
      __cil_tmp70 = (char *)__mptr___2;
#line 163
      __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
#line 163
      next_action = (struct vmw_fence_action *)__cil_tmp71;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 179 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static struct lock_class_key __key___19  ;
#line 188 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static struct lock_class_key __key___20  ;
#line 171 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) 
{ struct vmw_fence_manager *fman ;
  void *tmp___7 ;
  long tmp___8 ;
  atomic_long_t __r_expr_0 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct raw_spinlock *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct work_struct *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct mutex *__cil_tmp53 ;
  long __r_expr_0_counter54 ;

  {
  {
#line 173
  tmp___7 = kzalloc(208UL, 208U);
#line 173
  fman = (struct vmw_fence_manager *)tmp___7;
#line 175
  __cil_tmp9 = (void *)0;
#line 175
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 175
  __cil_tmp11 = (unsigned long )fman;
#line 175
  __cil_tmp12 = __cil_tmp11 == __cil_tmp10;
#line 175
  __cil_tmp13 = ! __cil_tmp12;
#line 175
  __cil_tmp14 = ! __cil_tmp13;
#line 175
  __cil_tmp15 = (long )__cil_tmp14;
#line 175
  tmp___8 = ldv__builtin_expect(__cil_tmp15, 0L);
  }
#line 175
  if (tmp___8) {
    {
#line 176
    __cil_tmp16 = (void *)0;
#line 176
    return ((struct vmw_fence_manager *)__cil_tmp16);
    }
  } else {

  }
#line 178
  __cil_tmp17 = (unsigned long )fman;
#line 178
  __cil_tmp18 = __cil_tmp17 + 8;
#line 178
  *((struct vmw_private **)__cil_tmp18) = dev_priv;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    __cil_tmp19 = (unsigned long )fman;
#line 179
    __cil_tmp20 = __cil_tmp19 + 16;
#line 179
    __cil_tmp21 = (spinlock_t *)__cil_tmp20;
#line 179
    spinlock_check(__cil_tmp21);
    }
    {
#line 179
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 179
      __cil_tmp22 = (unsigned long )fman;
#line 179
      __cil_tmp23 = __cil_tmp22 + 16;
#line 179
      __cil_tmp24 = (struct raw_spinlock *)__cil_tmp23;
#line 179
      __raw_spin_lock_init(__cil_tmp24, "&(&fman->lock)->rlock", & __key___19);
      }
#line 179
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  __cil_tmp25 = (unsigned long )fman;
#line 180
  __cil_tmp26 = __cil_tmp25 + 40;
#line 180
  __cil_tmp27 = (struct list_head *)__cil_tmp26;
#line 180
  INIT_LIST_HEAD(__cil_tmp27);
#line 181
  __cil_tmp28 = (unsigned long )fman;
#line 181
  __cil_tmp29 = __cil_tmp28 + 104;
#line 181
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
#line 181
  INIT_LIST_HEAD(__cil_tmp30);
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 182
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 182
      __cil_tmp31 = (unsigned long )fman;
#line 182
      __cil_tmp32 = __cil_tmp31 + 56;
#line 182
      __cil_tmp33 = (struct work_struct *)__cil_tmp32;
#line 182
      __init_work(__cil_tmp33, 0);
#line 182
      __r_expr_0_counter54 = 2097664L;
#line 182
      __cil_tmp34 = (unsigned long )fman;
#line 182
      __cil_tmp35 = __cil_tmp34 + 56;
#line 182
      ((atomic_long_t *)__cil_tmp35)->counter = __r_expr_0_counter54;
#line 182
      __cil_tmp36 = 56 + 8;
#line 182
      __cil_tmp37 = (unsigned long )fman;
#line 182
      __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 182
      __cil_tmp39 = (struct list_head *)__cil_tmp38;
#line 182
      INIT_LIST_HEAD(__cil_tmp39);
      }
      {
#line 182
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 182
        __cil_tmp40 = 56 + 24;
#line 182
        __cil_tmp41 = (unsigned long )fman;
#line 182
        __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 182
        *((void (**)(struct work_struct *work ))__cil_tmp42) = & vmw_fence_work_func;
#line 182
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 182
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 183
  __cil_tmp43 = (unsigned long )fman;
#line 183
  __cil_tmp44 = __cil_tmp43 + 100;
#line 183
  *((bool *)__cil_tmp44) = (bool )1;
#line 184
  tmp___9 = ttm_round_pot(168UL);
#line 184
  __cil_tmp45 = (unsigned long )fman;
#line 184
  __cil_tmp46 = __cil_tmp45 + 88;
#line 184
  *((u32 *)__cil_tmp46) = (u32 )tmp___9;
#line 185
  tmp___10 = ttm_round_pot(104UL);
#line 185
  __cil_tmp47 = (unsigned long )fman;
#line 185
  __cil_tmp48 = __cil_tmp47 + 92;
#line 185
  *((u32 *)__cil_tmp48) = (u32 )tmp___10;
#line 186
  tmp___11 = ttm_round_pot(96UL);
#line 186
  __cil_tmp49 = (unsigned long )fman;
#line 186
  __cil_tmp50 = __cil_tmp49 + 96;
#line 186
  *((u32 *)__cil_tmp50) = (u32 )tmp___11;
  }
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 188
    __cil_tmp51 = (unsigned long )fman;
#line 188
    __cil_tmp52 = __cil_tmp51 + 128;
#line 188
    __cil_tmp53 = (struct mutex *)__cil_tmp52;
#line 188
    __mutex_init(__cil_tmp53, "&fman->goal_irq_mutex", & __key___20);
    }
#line 188
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 190
  return (fman);
}
}
#line 193 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  bool lists_empty ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct work_struct *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  spinlock_t *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  struct list_head    *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct list_head    *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  void    *__cil_tmp32 ;

  {
  {
#line 198
  __cil_tmp11 = (unsigned long )fman;
#line 198
  __cil_tmp12 = __cil_tmp11 + 56;
#line 198
  __cil_tmp13 = (struct work_struct *)__cil_tmp12;
#line 198
  cancel_work_sync(__cil_tmp13);
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 200
      __cil_tmp14 = (unsigned long )fman;
#line 200
      __cil_tmp15 = __cil_tmp14 + 16;
#line 200
      __cil_tmp16 = (spinlock_t *)__cil_tmp15;
#line 200
      tmp___7 = spinlock_check(__cil_tmp16);
#line 200
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 200
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  __cil_tmp17 = (unsigned long )fman;
#line 201
  __cil_tmp18 = __cil_tmp17 + 40;
#line 201
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
#line 201
  __cil_tmp20 = (struct list_head    *)__cil_tmp19;
#line 201
  tmp___8 = list_empty(__cil_tmp20);
  }
#line 201
  if (tmp___8) {
    {
#line 201
    __cil_tmp21 = (unsigned long )fman;
#line 201
    __cil_tmp22 = __cil_tmp21 + 104;
#line 201
    __cil_tmp23 = (struct list_head *)__cil_tmp22;
#line 201
    __cil_tmp24 = (struct list_head    *)__cil_tmp23;
#line 201
    tmp___9 = list_empty(__cil_tmp24);
    }
#line 201
    if (tmp___9) {
#line 201
      tmp___10 = 1;
    } else {
#line 201
      tmp___10 = 0;
    }
  } else {
#line 201
    tmp___10 = 0;
  }
  {
#line 201
  lists_empty = (bool )tmp___10;
#line 203
  __cil_tmp25 = (unsigned long )fman;
#line 203
  __cil_tmp26 = __cil_tmp25 + 16;
#line 203
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
#line 203
  spin_unlock_irqrestore(__cil_tmp27, irq_flags);
  }
  {
#line 205
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 205
    __cil_tmp28 = ! lists_empty;
#line 205
    __cil_tmp29 = ! __cil_tmp28;
#line 205
    __cil_tmp30 = ! __cil_tmp29;
#line 205
    __cil_tmp31 = (long )__cil_tmp30;
#line 205
    tmp___11 = ldv__builtin_expect(__cil_tmp31, 0L);
    }
#line 205
    if (tmp___11) {
      {
#line 205
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 205
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (205), "i" (12UL));
        {
#line 205
        while (1) {
          while_continue___3: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 205
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {

    }
#line 205
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 206
  __cil_tmp32 = (void    *)fman;
#line 206
  kfree(__cil_tmp32);
  }
#line 207
  return;
}
}
#line 226 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static struct lock_class_key __key___21  ;
#line 209 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static int vmw_fence_obj_init(struct vmw_fence_manager *fman , struct vmw_fence_obj *fence ,
                              u32 seqno , uint32_t mask , void (*destroy)(struct vmw_fence_obj *fence ) ) 
{ unsigned long irq_flags ;
  unsigned int num_fences ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct kref *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  wait_queue_head_t *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  spinlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  bool __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  spinlock_t *__cil_tmp49 ;

  {
  {
#line 217
  ret = 0;
#line 219
  __cil_tmp13 = (unsigned long )fence;
#line 219
  __cil_tmp14 = __cil_tmp13 + 4;
#line 219
  *((u32 *)__cil_tmp14) = seqno;
#line 220
  __cil_tmp15 = (unsigned long )fence;
#line 220
  __cil_tmp16 = __cil_tmp15 + 40;
#line 220
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
#line 220
  INIT_LIST_HEAD(__cil_tmp17);
#line 221
  __cil_tmp18 = (unsigned long )fence;
#line 221
  __cil_tmp19 = __cil_tmp18 + 8;
#line 221
  *((struct vmw_fence_manager **)__cil_tmp19) = fman;
#line 222
  __cil_tmp20 = (unsigned long )fence;
#line 222
  __cil_tmp21 = __cil_tmp20 + 32;
#line 222
  *((uint32_t *)__cil_tmp21) = (uint32_t )0;
#line 223
  __cil_tmp22 = (unsigned long )fence;
#line 223
  __cil_tmp23 = __cil_tmp22 + 36;
#line 223
  *((uint32_t *)__cil_tmp23) = mask;
#line 224
  __cil_tmp24 = (struct kref *)fence;
#line 224
  kref_init(__cil_tmp24);
#line 225
  __cil_tmp25 = (unsigned long )fence;
#line 225
  __cil_tmp26 = __cil_tmp25 + 56;
#line 225
  *((void (**)(struct vmw_fence_obj *fence ))__cil_tmp26) = destroy;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    __cil_tmp27 = (unsigned long )fence;
#line 226
    __cil_tmp28 = __cil_tmp27 + 64;
#line 226
    __cil_tmp29 = (wait_queue_head_t *)__cil_tmp28;
#line 226
    __init_waitqueue_head(__cil_tmp29, "&fence->queue", & __key___21);
    }
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 228
      __cil_tmp30 = (unsigned long )fman;
#line 228
      __cil_tmp31 = __cil_tmp30 + 16;
#line 228
      __cil_tmp32 = (spinlock_t *)__cil_tmp31;
#line 228
      tmp___7 = spinlock_check(__cil_tmp32);
#line 228
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 228
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 229
  __cil_tmp33 = (unsigned long )fman;
#line 229
  __cil_tmp34 = __cil_tmp33 + 100;
#line 229
  __cil_tmp35 = *((bool *)__cil_tmp34);
#line 229
  __cil_tmp36 = ! __cil_tmp35;
#line 229
  __cil_tmp37 = ! __cil_tmp36;
#line 229
  __cil_tmp38 = (long )__cil_tmp37;
#line 229
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 0L);
  }
#line 229
  if (tmp___8) {
#line 230
    ret = -16;
#line 231
    goto out_unlock;
  } else {

  }
  {
#line 233
  __cil_tmp39 = (unsigned long )fence;
#line 233
  __cil_tmp40 = __cil_tmp39 + 16;
#line 233
  __cil_tmp41 = (struct list_head *)__cil_tmp40;
#line 233
  __cil_tmp42 = (unsigned long )fman;
#line 233
  __cil_tmp43 = __cil_tmp42 + 40;
#line 233
  __cil_tmp44 = (struct list_head *)__cil_tmp43;
#line 233
  list_add_tail(__cil_tmp41, __cil_tmp44);
#line 234
  __cil_tmp45 = *((int *)fman);
#line 234
  *((int *)fman) = __cil_tmp45 + 1;
#line 234
  __cil_tmp46 = *((int *)fman);
#line 234
  num_fences = (unsigned int )__cil_tmp46;
  }
  out_unlock: 
  {
#line 237
  __cil_tmp47 = (unsigned long )fman;
#line 237
  __cil_tmp48 = __cil_tmp47 + 16;
#line 237
  __cil_tmp49 = (spinlock_t *)__cil_tmp48;
#line 237
  spin_unlock_irqrestore(__cil_tmp49, irq_flags);
  }
#line 238
  return (ret);
}
}
#line 242 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) 
{ long tmp___7 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  long __cil_tmp9 ;
  void *__cil_tmp10 ;
  struct kref *__cil_tmp11 ;

  {
  {
#line 244
  __cil_tmp3 = (void *)0;
#line 244
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 244
  __cil_tmp5 = (unsigned long )fence;
#line 244
  __cil_tmp6 = __cil_tmp5 == __cil_tmp4;
#line 244
  __cil_tmp7 = ! __cil_tmp6;
#line 244
  __cil_tmp8 = ! __cil_tmp7;
#line 244
  __cil_tmp9 = (long )__cil_tmp8;
#line 244
  tmp___7 = ldv__builtin_expect(__cil_tmp9, 0L);
  }
#line 244
  if (tmp___7) {
    {
#line 245
    __cil_tmp10 = (void *)0;
#line 245
    return ((struct vmw_fence_obj *)__cil_tmp10);
    }
  } else {

  }
  {
#line 247
  __cil_tmp11 = (struct kref *)fence;
#line 247
  kref_get(__cil_tmp11);
  }
#line 248
  return (fence);
}
}
#line 258 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) 
{ struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  spinlock_t *__cil_tmp20 ;
  atomic_t *__cil_tmp21 ;
  atomic_t    *__cil_tmp22 ;
  long __cil_tmp23 ;
  struct kref *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;

  {
  {
#line 260
  fence = *fence_p;
#line 263
  __cil_tmp8 = (void *)0;
#line 263
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 263
  __cil_tmp10 = (unsigned long )fence;
#line 263
  __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
#line 263
  __cil_tmp12 = ! __cil_tmp11;
#line 263
  __cil_tmp13 = ! __cil_tmp12;
#line 263
  __cil_tmp14 = (long )__cil_tmp13;
#line 263
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 263
  if (tmp___7) {
#line 264
    return;
  } else {

  }
  {
#line 266
  __cil_tmp15 = (unsigned long )fence;
#line 266
  __cil_tmp16 = __cil_tmp15 + 8;
#line 266
  fman = *((struct vmw_fence_manager **)__cil_tmp16);
#line 267
  __cil_tmp17 = (void *)0;
#line 267
  *fence_p = (struct vmw_fence_obj *)__cil_tmp17;
#line 268
  __cil_tmp18 = (unsigned long )fman;
#line 268
  __cil_tmp19 = __cil_tmp18 + 16;
#line 268
  __cil_tmp20 = (spinlock_t *)__cil_tmp19;
#line 268
  spin_lock_irq(__cil_tmp20);
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    __cil_tmp21 = (atomic_t *)fence;
#line 269
    __cil_tmp22 = (atomic_t    *)__cil_tmp21;
#line 269
    tmp___8 = atomic_read(__cil_tmp22);
    }
#line 269
    if (tmp___8 == 0) {
#line 269
      tmp___9 = 1;
    } else {
#line 269
      tmp___9 = 0;
    }
    {
#line 269
    __cil_tmp23 = (long )tmp___9;
#line 269
    tmp___10 = ldv__builtin_expect(__cil_tmp23, 0L);
    }
#line 269
    if (tmp___10) {
      {
#line 269
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 269
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (269), "i" (12UL));
        {
#line 269
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 269
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 269
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  __cil_tmp24 = (struct kref *)fence;
#line 270
  kref_put(__cil_tmp24, & vmw_fence_obj_destroy_locked);
#line 271
  __cil_tmp25 = (unsigned long )fman;
#line 271
  __cil_tmp26 = __cil_tmp25 + 16;
#line 271
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
#line 271
  spin_unlock_irq(__cil_tmp27);
  }
#line 272
  return;
}
}
#line 274 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fences_perform_actions(struct vmw_fence_manager *fman , struct list_head *list ) 
{ struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  struct list_head *__cil_tmp8 ;
  struct vmw_fence_action *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct vmw_fence_action *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  enum vmw_action_type __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  enum vmw_action_type __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  void (*__cil_tmp43)(struct vmw_fence_action *action ) ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  void (*__cil_tmp47)(struct vmw_fence_action *action ) ;
  struct list_head *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  struct vmw_fence_action *__cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 279
  __cil_tmp8 = *((struct list_head **)list);
#line 279
  __mptr = (struct list_head    *)__cil_tmp8;
#line 279
  __cil_tmp9 = (struct vmw_fence_action *)0;
#line 279
  __cil_tmp10 = (struct list_head *)__cil_tmp9;
#line 279
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 279
  __cil_tmp12 = (char *)__mptr;
#line 279
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 279
  action = (struct vmw_fence_action *)__cil_tmp13;
#line 279
  __cil_tmp14 = *((struct list_head **)action);
#line 279
  __mptr___0 = (struct list_head    *)__cil_tmp14;
#line 279
  __cil_tmp15 = (struct vmw_fence_action *)0;
#line 279
  __cil_tmp16 = (struct list_head *)__cil_tmp15;
#line 279
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 279
  __cil_tmp18 = (char *)__mptr___0;
#line 279
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 279
  next_action = (struct vmw_fence_action *)__cil_tmp19;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    __cil_tmp20 = (unsigned long )list;
#line 279
    __cil_tmp21 = (struct list_head *)action;
#line 279
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 279
    if (__cil_tmp22 != __cil_tmp20) {

    } else {
#line 279
      goto while_break;
    }
    }
    {
#line 280
    __cil_tmp23 = (struct list_head *)action;
#line 280
    list_del_init(__cil_tmp23);
#line 281
    __cil_tmp24 = (unsigned long )action;
#line 281
    __cil_tmp25 = __cil_tmp24 + 16;
#line 281
    __cil_tmp26 = *((enum vmw_action_type *)__cil_tmp25);
#line 281
    __cil_tmp27 = __cil_tmp26 * 4UL;
#line 281
    __cil_tmp28 = 120 + __cil_tmp27;
#line 281
    __cil_tmp29 = (unsigned long )fman;
#line 281
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 281
    __cil_tmp31 = (unsigned long )action;
#line 281
    __cil_tmp32 = __cil_tmp31 + 16;
#line 281
    __cil_tmp33 = *((enum vmw_action_type *)__cil_tmp32);
#line 281
    __cil_tmp34 = __cil_tmp33 * 4UL;
#line 281
    __cil_tmp35 = 120 + __cil_tmp34;
#line 281
    __cil_tmp36 = (unsigned long )fman;
#line 281
    __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
#line 281
    __cil_tmp38 = *((uint32_t *)__cil_tmp37);
#line 281
    *((uint32_t *)__cil_tmp30) = __cil_tmp38 - 1U;
    }
    {
#line 282
    __cil_tmp39 = (void *)0;
#line 282
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 282
    __cil_tmp41 = (unsigned long )action;
#line 282
    __cil_tmp42 = __cil_tmp41 + 24;
#line 282
    __cil_tmp43 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp42);
#line 282
    __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 282
    if (__cil_tmp44 != __cil_tmp40) {
      {
#line 283
      __cil_tmp45 = (unsigned long )action;
#line 283
      __cil_tmp46 = __cil_tmp45 + 24;
#line 283
      __cil_tmp47 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp46);
#line 283
      (*__cil_tmp47)(action);
      }
    } else {

    }
    }
    {
#line 290
    __cil_tmp48 = (struct list_head *)action;
#line 290
    __cil_tmp49 = (unsigned long )fman;
#line 290
    __cil_tmp50 = __cil_tmp49 + 104;
#line 290
    __cil_tmp51 = (struct list_head *)__cil_tmp50;
#line 290
    list_add_tail(__cil_tmp48, __cil_tmp51);
#line 279
    action = next_action;
#line 279
    __cil_tmp52 = *((struct list_head **)next_action);
#line 279
    __mptr___1 = (struct list_head    *)__cil_tmp52;
#line 279
    __cil_tmp53 = (struct vmw_fence_action *)0;
#line 279
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
#line 279
    __cil_tmp55 = (unsigned int )__cil_tmp54;
#line 279
    __cil_tmp56 = (char *)__mptr___1;
#line 279
    __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
#line 279
    next_action = (struct vmw_fence_action *)__cil_tmp57;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 310 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static bool vmw_fence_goal_new_locked(struct vmw_fence_manager *fman , u32 passed_seqno ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  struct vmw_fence_obj *fence ;
  long tmp___7 ;
  long tmp___8 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  int tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_private *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  u32 __cil_tmp26 ;
  u32 __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  struct vmw_fence_obj *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct list_head *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  struct list_head    *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  u32 __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  struct vmw_fence_obj *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct list_head *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
  {
#line 317
  __cil_tmp11 = (unsigned long )fman;
#line 317
  __cil_tmp12 = __cil_tmp11 + 201;
#line 317
  __cil_tmp13 = *((bool *)__cil_tmp12);
#line 317
  __cil_tmp14 = ! __cil_tmp13;
#line 317
  __cil_tmp15 = ! __cil_tmp14;
#line 317
  __cil_tmp16 = ! __cil_tmp15;
#line 317
  __cil_tmp17 = (long )__cil_tmp16;
#line 317
  tmp___7 = ldv__builtin_expect(__cil_tmp17, 1L);
  }
#line 317
  if (tmp___7) {
#line 318
    return ((bool )0);
  } else {

  }
  {
#line 320
  __cil_tmp18 = (unsigned long )fman;
#line 320
  __cil_tmp19 = __cil_tmp18 + 8;
#line 320
  __cil_tmp20 = *((struct vmw_private **)__cil_tmp19);
#line 320
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 320
  __cil_tmp22 = __cil_tmp21 + 2144;
#line 320
  fifo_mem = *((__le32 **)__cil_tmp22);
#line 321
  __cil_tmp23 = fifo_mem + 289;
#line 321
  __cil_tmp24 = (void *)__cil_tmp23;
#line 321
  goal_seqno = ioread32(__cil_tmp24);
#line 322
  __cil_tmp25 = 1 << 31;
#line 322
  __cil_tmp26 = (u32 )__cil_tmp25;
#line 322
  __cil_tmp27 = passed_seqno - goal_seqno;
#line 322
  __cil_tmp28 = __cil_tmp27 >= __cil_tmp26;
#line 322
  __cil_tmp29 = ! __cil_tmp28;
#line 322
  __cil_tmp30 = ! __cil_tmp29;
#line 322
  __cil_tmp31 = (long )__cil_tmp30;
#line 322
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 1L);
  }
#line 322
  if (tmp___8) {
#line 323
    return ((bool )0);
  } else {

  }
#line 325
  __cil_tmp32 = (unsigned long )fman;
#line 325
  __cil_tmp33 = __cil_tmp32 + 201;
#line 325
  *((bool *)__cil_tmp33) = (bool )0;
#line 326
  __cil_tmp34 = (unsigned long )fman;
#line 326
  __cil_tmp35 = __cil_tmp34 + 40;
#line 326
  __cil_tmp36 = *((struct list_head **)__cil_tmp35);
#line 326
  __mptr = (struct list_head    *)__cil_tmp36;
#line 326
  __cil_tmp37 = (struct vmw_fence_obj *)0;
#line 326
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 326
  __cil_tmp39 = __cil_tmp38 + 16;
#line 326
  __cil_tmp40 = (struct list_head *)__cil_tmp39;
#line 326
  __cil_tmp41 = (unsigned int )__cil_tmp40;
#line 326
  __cil_tmp42 = (char *)__mptr;
#line 326
  __cil_tmp43 = __cil_tmp42 - __cil_tmp41;
#line 326
  fence = (struct vmw_fence_obj *)__cil_tmp43;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    __cil_tmp44 = (unsigned long )fman;
#line 326
    __cil_tmp45 = __cil_tmp44 + 40;
#line 326
    __cil_tmp46 = (struct list_head *)__cil_tmp45;
#line 326
    __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 326
    __cil_tmp48 = (unsigned long )fence;
#line 326
    __cil_tmp49 = __cil_tmp48 + 16;
#line 326
    __cil_tmp50 = (struct list_head *)__cil_tmp49;
#line 326
    __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 326
    if (__cil_tmp51 != __cil_tmp47) {

    } else {
#line 326
      goto while_break;
    }
    }
    {
#line 327
    __cil_tmp52 = (unsigned long )fence;
#line 327
    __cil_tmp53 = __cil_tmp52 + 40;
#line 327
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
#line 327
    __cil_tmp55 = (struct list_head    *)__cil_tmp54;
#line 327
    tmp___9 = list_empty(__cil_tmp55);
    }
#line 327
    if (tmp___9) {

    } else {
      {
#line 328
      __cil_tmp56 = (unsigned long )fman;
#line 328
      __cil_tmp57 = __cil_tmp56 + 201;
#line 328
      *((bool *)__cil_tmp57) = (bool )1;
#line 329
      __cil_tmp58 = (unsigned long )fence;
#line 329
      __cil_tmp59 = __cil_tmp58 + 4;
#line 329
      __cil_tmp60 = *((u32 *)__cil_tmp59);
#line 329
      __cil_tmp61 = fifo_mem + 289;
#line 329
      __cil_tmp62 = (void *)__cil_tmp61;
#line 329
      iowrite32(__cil_tmp60, __cil_tmp62);
      }
#line 331
      goto while_break;
    }
#line 326
    __cil_tmp63 = (unsigned long )fence;
#line 326
    __cil_tmp64 = __cil_tmp63 + 16;
#line 326
    __cil_tmp65 = *((struct list_head **)__cil_tmp64);
#line 326
    __mptr___0 = (struct list_head    *)__cil_tmp65;
#line 326
    __cil_tmp66 = (struct vmw_fence_obj *)0;
#line 326
    __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 326
    __cil_tmp68 = __cil_tmp67 + 16;
#line 326
    __cil_tmp69 = (struct list_head *)__cil_tmp68;
#line 326
    __cil_tmp70 = (unsigned int )__cil_tmp69;
#line 326
    __cil_tmp71 = (char *)__mptr___0;
#line 326
    __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
#line 326
    fence = (struct vmw_fence_obj *)__cil_tmp72;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return ((bool )1);
}
}
#line 354 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static bool vmw_fence_goal_check_locked(struct vmw_fence_obj *fence ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_fence_manager *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_private *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  __le32 *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fence_manager *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  u32 __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  u32 __cil_tmp28 ;
  u32 __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  u32 __cil_tmp33 ;
  __le32 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_fence_manager *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;

  {
  {
#line 359
  __cil_tmp6 = (unsigned long )fence;
#line 359
  __cil_tmp7 = __cil_tmp6 + 32;
#line 359
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
#line 359
  if (__cil_tmp8 & 1U) {
#line 360
    return ((bool )0);
  } else {

  }
  }
  {
#line 362
  __cil_tmp9 = (unsigned long )fence;
#line 362
  __cil_tmp10 = __cil_tmp9 + 8;
#line 362
  __cil_tmp11 = *((struct vmw_fence_manager **)__cil_tmp10);
#line 362
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 362
  __cil_tmp13 = __cil_tmp12 + 8;
#line 362
  __cil_tmp14 = *((struct vmw_private **)__cil_tmp13);
#line 362
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 362
  __cil_tmp16 = __cil_tmp15 + 2144;
#line 362
  fifo_mem = *((__le32 **)__cil_tmp16);
#line 363
  __cil_tmp17 = fifo_mem + 289;
#line 363
  __cil_tmp18 = (void *)__cil_tmp17;
#line 363
  goal_seqno = ioread32(__cil_tmp18);
  }
  {
#line 364
  __cil_tmp19 = (unsigned long )fence;
#line 364
  __cil_tmp20 = __cil_tmp19 + 8;
#line 364
  __cil_tmp21 = *((struct vmw_fence_manager **)__cil_tmp20);
#line 364
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 364
  __cil_tmp23 = __cil_tmp22 + 201;
#line 364
  if (*((bool *)__cil_tmp23)) {
    {
#line 364
    __cil_tmp24 = 1 << 31;
#line 364
    __cil_tmp25 = (u32 )__cil_tmp24;
#line 364
    __cil_tmp26 = (unsigned long )fence;
#line 364
    __cil_tmp27 = __cil_tmp26 + 4;
#line 364
    __cil_tmp28 = *((u32 *)__cil_tmp27);
#line 364
    __cil_tmp29 = goal_seqno - __cil_tmp28;
#line 364
    if (__cil_tmp29 < __cil_tmp25) {
#line 364
      tmp___7 = 1;
    } else {
#line 364
      tmp___7 = 0;
    }
    }
  } else {
#line 364
    tmp___7 = 0;
  }
  }
  {
#line 364
  __cil_tmp30 = (long )tmp___7;
#line 364
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 1L);
  }
#line 364
  if (tmp___8) {
#line 366
    return ((bool )0);
  } else {

  }
  {
#line 368
  __cil_tmp31 = (unsigned long )fence;
#line 368
  __cil_tmp32 = __cil_tmp31 + 4;
#line 368
  __cil_tmp33 = *((u32 *)__cil_tmp32);
#line 368
  __cil_tmp34 = fifo_mem + 289;
#line 368
  __cil_tmp35 = (void *)__cil_tmp34;
#line 368
  iowrite32(__cil_tmp33, __cil_tmp35);
#line 369
  __cil_tmp36 = (unsigned long )fence;
#line 369
  __cil_tmp37 = __cil_tmp36 + 8;
#line 369
  __cil_tmp38 = *((struct vmw_fence_manager **)__cil_tmp37);
#line 369
  __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 369
  __cil_tmp40 = __cil_tmp39 + 201;
#line 369
  *((bool *)__cil_tmp40) = (bool )1;
  }
#line 371
  return ((bool )1);
}
}
#line 374 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fences_update(struct vmw_fence_manager *fman ) 
{ unsigned long flags ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_obj *next_fence ;
  struct list_head action_list ;
  bool needs_rerun ;
  uint32_t seqno ;
  uint32_t new_seqno ;
  __le32 *fifo_mem ;
  raw_spinlock_t *tmp___7 ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  struct list_head    *__mptr___1 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_private *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  struct vmw_fence_obj *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  struct vmw_fence_obj *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  u32 __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct list_head *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  wait_queue_head_t *__cil_tmp75 ;
  void *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  struct vmw_fence_obj *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct list_head *__cil_tmp89 ;
  struct list_head    *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct work_struct *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  spinlock_t *__cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  long __cil_tmp99 ;
  __le32 *__cil_tmp100 ;
  void *__cil_tmp101 ;

  {
  {
#line 381
  __cil_tmp18 = (unsigned long )fman;
#line 381
  __cil_tmp19 = __cil_tmp18 + 8;
#line 381
  __cil_tmp20 = *((struct vmw_private **)__cil_tmp19);
#line 381
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 381
  __cil_tmp22 = __cil_tmp21 + 2144;
#line 381
  fifo_mem = *((__le32 **)__cil_tmp22);
#line 383
  __cil_tmp23 = fifo_mem + 6;
#line 383
  __cil_tmp24 = (void *)__cil_tmp23;
#line 383
  seqno = ioread32(__cil_tmp24);
  }
  rerun: 
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 385
      __cil_tmp25 = (unsigned long )fman;
#line 385
      __cil_tmp26 = __cil_tmp25 + 16;
#line 385
      __cil_tmp27 = (spinlock_t *)__cil_tmp26;
#line 385
      tmp___7 = spinlock_check(__cil_tmp27);
#line 385
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 385
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 385
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  __cil_tmp28 = (unsigned long )fman;
#line 386
  __cil_tmp29 = __cil_tmp28 + 40;
#line 386
  __cil_tmp30 = *((struct list_head **)__cil_tmp29);
#line 386
  __mptr = (struct list_head    *)__cil_tmp30;
#line 386
  __cil_tmp31 = (struct vmw_fence_obj *)0;
#line 386
  __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 386
  __cil_tmp33 = __cil_tmp32 + 16;
#line 386
  __cil_tmp34 = (struct list_head *)__cil_tmp33;
#line 386
  __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 386
  __cil_tmp36 = (char *)__mptr;
#line 386
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
#line 386
  fence = (struct vmw_fence_obj *)__cil_tmp37;
#line 386
  __cil_tmp38 = (unsigned long )fence;
#line 386
  __cil_tmp39 = __cil_tmp38 + 16;
#line 386
  __cil_tmp40 = *((struct list_head **)__cil_tmp39);
#line 386
  __mptr___0 = (struct list_head    *)__cil_tmp40;
#line 386
  __cil_tmp41 = (struct vmw_fence_obj *)0;
#line 386
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 386
  __cil_tmp43 = __cil_tmp42 + 16;
#line 386
  __cil_tmp44 = (struct list_head *)__cil_tmp43;
#line 386
  __cil_tmp45 = (unsigned int )__cil_tmp44;
#line 386
  __cil_tmp46 = (char *)__mptr___0;
#line 386
  __cil_tmp47 = __cil_tmp46 - __cil_tmp45;
#line 386
  next_fence = (struct vmw_fence_obj *)__cil_tmp47;
  {
#line 386
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 386
    __cil_tmp48 = (unsigned long )fman;
#line 386
    __cil_tmp49 = __cil_tmp48 + 40;
#line 386
    __cil_tmp50 = (struct list_head *)__cil_tmp49;
#line 386
    __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 386
    __cil_tmp52 = (unsigned long )fence;
#line 386
    __cil_tmp53 = __cil_tmp52 + 16;
#line 386
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
#line 386
    __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 386
    if (__cil_tmp55 != __cil_tmp51) {

    } else {
#line 386
      goto while_break___1;
    }
    }
    {
#line 387
    __cil_tmp56 = 1 << 31;
#line 387
    __cil_tmp57 = (uint32_t )__cil_tmp56;
#line 387
    __cil_tmp58 = (unsigned long )fence;
#line 387
    __cil_tmp59 = __cil_tmp58 + 4;
#line 387
    __cil_tmp60 = *((u32 *)__cil_tmp59);
#line 387
    __cil_tmp61 = seqno - __cil_tmp60;
#line 387
    if (__cil_tmp61 < __cil_tmp57) {
      {
#line 388
      __cil_tmp62 = (unsigned long )fence;
#line 388
      __cil_tmp63 = __cil_tmp62 + 16;
#line 388
      __cil_tmp64 = (struct list_head *)__cil_tmp63;
#line 388
      list_del_init(__cil_tmp64);
#line 389
      __cil_tmp65 = (unsigned long )fence;
#line 389
      __cil_tmp66 = __cil_tmp65 + 32;
#line 389
      __cil_tmp67 = (unsigned long )fence;
#line 389
      __cil_tmp68 = __cil_tmp67 + 32;
#line 389
      __cil_tmp69 = *((uint32_t *)__cil_tmp68);
#line 389
      *((uint32_t *)__cil_tmp66) = __cil_tmp69 | 1U;
#line 390
      INIT_LIST_HEAD(& action_list);
#line 391
      __cil_tmp70 = (unsigned long )fence;
#line 391
      __cil_tmp71 = __cil_tmp70 + 40;
#line 391
      __cil_tmp72 = (struct list_head *)__cil_tmp71;
#line 391
      list_splice_init(__cil_tmp72, & action_list);
#line 393
      vmw_fences_perform_actions(fman, & action_list);
#line 394
      __cil_tmp73 = (unsigned long )fence;
#line 394
      __cil_tmp74 = __cil_tmp73 + 64;
#line 394
      __cil_tmp75 = (wait_queue_head_t *)__cil_tmp74;
#line 394
      __cil_tmp76 = (void *)0;
#line 394
      __wake_up(__cil_tmp75, 3U, 0, __cil_tmp76);
      }
    } else {
#line 396
      goto while_break___1;
    }
    }
#line 386
    fence = next_fence;
#line 386
    __cil_tmp77 = (unsigned long )next_fence;
#line 386
    __cil_tmp78 = __cil_tmp77 + 16;
#line 386
    __cil_tmp79 = *((struct list_head **)__cil_tmp78);
#line 386
    __mptr___1 = (struct list_head    *)__cil_tmp79;
#line 386
    __cil_tmp80 = (struct vmw_fence_obj *)0;
#line 386
    __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 386
    __cil_tmp82 = __cil_tmp81 + 16;
#line 386
    __cil_tmp83 = (struct list_head *)__cil_tmp82;
#line 386
    __cil_tmp84 = (unsigned int )__cil_tmp83;
#line 386
    __cil_tmp85 = (char *)__mptr___1;
#line 386
    __cil_tmp86 = __cil_tmp85 - __cil_tmp84;
#line 386
    next_fence = (struct vmw_fence_obj *)__cil_tmp86;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 399
  needs_rerun = vmw_fence_goal_new_locked(fman, seqno);
#line 401
  __cil_tmp87 = (unsigned long )fman;
#line 401
  __cil_tmp88 = __cil_tmp87 + 104;
#line 401
  __cil_tmp89 = (struct list_head *)__cil_tmp88;
#line 401
  __cil_tmp90 = (struct list_head    *)__cil_tmp89;
#line 401
  tmp___8 = list_empty(__cil_tmp90);
  }
#line 401
  if (tmp___8) {

  } else {
    {
#line 402
    __cil_tmp91 = (unsigned long )fman;
#line 402
    __cil_tmp92 = __cil_tmp91 + 56;
#line 402
    __cil_tmp93 = (struct work_struct *)__cil_tmp92;
#line 402
    schedule_work(__cil_tmp93);
    }
  }
  {
#line 403
  __cil_tmp94 = (unsigned long )fman;
#line 403
  __cil_tmp95 = __cil_tmp94 + 16;
#line 403
  __cil_tmp96 = (spinlock_t *)__cil_tmp95;
#line 403
  spin_unlock_irqrestore(__cil_tmp96, flags);
#line 411
  __cil_tmp97 = ! needs_rerun;
#line 411
  __cil_tmp98 = ! __cil_tmp97;
#line 411
  __cil_tmp99 = (long )__cil_tmp98;
#line 411
  tmp___9 = ldv__builtin_expect(__cil_tmp99, 0L);
  }
#line 411
  if (tmp___9) {
    {
#line 412
    __cil_tmp100 = fifo_mem + 6;
#line 412
    __cil_tmp101 = (void *)__cil_tmp100;
#line 412
    new_seqno = ioread32(__cil_tmp101);
    }
#line 413
    if (new_seqno != seqno) {
#line 414
      seqno = new_seqno;
#line 415
      goto rerun;
    } else {

    }
  } else {

  }
#line 418
  return;
}
}
#line 420 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  uint32_t signaled ;
  raw_spinlock_t *tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  spinlock_t *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  spinlock_t *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  spinlock_t *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 423
  __cil_tmp12 = (unsigned long )fence;
#line 423
  __cil_tmp13 = __cil_tmp12 + 8;
#line 423
  fman = *((struct vmw_fence_manager **)__cil_tmp13);
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 427
      __cil_tmp14 = (unsigned long )fman;
#line 427
      __cil_tmp15 = __cil_tmp14 + 16;
#line 427
      __cil_tmp16 = (spinlock_t *)__cil_tmp15;
#line 427
      tmp___7 = spinlock_check(__cil_tmp16);
#line 427
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 427
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  __cil_tmp17 = (unsigned long )fence;
#line 428
  __cil_tmp18 = __cil_tmp17 + 32;
#line 428
  signaled = *((uint32_t *)__cil_tmp18);
#line 429
  __cil_tmp19 = (unsigned long )fman;
#line 429
  __cil_tmp20 = __cil_tmp19 + 16;
#line 429
  __cil_tmp21 = (spinlock_t *)__cil_tmp20;
#line 429
  spin_unlock_irqrestore(__cil_tmp21, irq_flags);
#line 431
  __cil_tmp22 = (unsigned long )fence;
#line 431
  __cil_tmp23 = __cil_tmp22 + 36;
#line 431
  __cil_tmp24 = *((uint32_t *)__cil_tmp23);
#line 431
  flags = flags & __cil_tmp24;
  }
  {
#line 432
  __cil_tmp25 = signaled & flags;
#line 432
  if (__cil_tmp25 == flags) {
#line 433
    return ((bool )1);
  } else {

  }
  }
  {
#line 435
  __cil_tmp26 = signaled & 1U;
#line 435
  if (__cil_tmp26 == 0U) {
    {
#line 436
    vmw_fences_update(fman);
    }
  } else {

  }
  }
  {
#line 438
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 438
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 438
      __cil_tmp27 = (unsigned long )fman;
#line 438
      __cil_tmp28 = __cil_tmp27 + 16;
#line 438
      __cil_tmp29 = (spinlock_t *)__cil_tmp28;
#line 438
      tmp___8 = spinlock_check(__cil_tmp29);
#line 438
      irq_flags = _raw_spin_lock_irqsave(tmp___8);
      }
#line 438
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 438
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 439
  __cil_tmp30 = (unsigned long )fence;
#line 439
  __cil_tmp31 = __cil_tmp30 + 32;
#line 439
  signaled = *((uint32_t *)__cil_tmp31);
#line 440
  __cil_tmp32 = (unsigned long )fman;
#line 440
  __cil_tmp33 = __cil_tmp32 + 16;
#line 440
  __cil_tmp34 = (spinlock_t *)__cil_tmp33;
#line 440
  spin_unlock_irqrestore(__cil_tmp34, irq_flags);
  }
  {
#line 442
  __cil_tmp35 = signaled & flags;
#line 442
  __cil_tmp36 = __cil_tmp35 == flags;
#line 442
  return ((bool )__cil_tmp36);
  }
}
}
#line 445 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) 
{ struct vmw_private *dev_priv ;
  long ret ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___10 ;
  bool tmp___11 ;
  struct task_struct *tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_fence_manager *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  wait_queue_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  wait_queue_head_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  wait_queue_head_t *__cil_tmp45 ;
  wait_queue_t *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  wait_queue_head_t *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  wait_queue_head_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  long __cil_tmp67 ;

  {
  {
#line 449
  __cil_tmp25 = (unsigned long )fence;
#line 449
  __cil_tmp26 = __cil_tmp25 + 8;
#line 449
  __cil_tmp27 = *((struct vmw_fence_manager **)__cil_tmp26);
#line 449
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 449
  __cil_tmp29 = __cil_tmp28 + 8;
#line 449
  dev_priv = *((struct vmw_private **)__cil_tmp29);
#line 452
  tmp___7 = vmw_fence_obj_signaled(fence, flags);
  }
#line 452
  if (tmp___7) {
#line 452
    tmp___8 = 1;
  } else {
#line 452
    tmp___8 = 0;
  }
  {
#line 452
  __cil_tmp30 = (long )tmp___8;
#line 452
  tmp___9 = ldv__builtin_expect(__cil_tmp30, 1L);
  }
#line 452
  if (tmp___9) {
#line 453
    return (0);
  } else {

  }
  {
#line 455
  __cil_tmp31 = (uint32_t )1;
#line 455
  vmw_fifo_ping_host(dev_priv, __cil_tmp31);
#line 456
  vmw_seqno_waiter_add(dev_priv);
  }
#line 458
  if (interruptible) {
    {
#line 459
    __ret = (long )timeout;
#line 459
    tmp___14 = vmw_fence_obj_signaled(fence, flags);
    }
#line 459
    if (tmp___14) {

    } else {
      {
#line 459
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 459
        tmp___10 = get_current();
#line 459
        __cil_tmp32 = & __wait;
#line 459
        *((unsigned int *)__cil_tmp32) = 0U;
#line 459
        __cil_tmp33 = (unsigned long )(& __wait) + 8;
#line 459
        *((void **)__cil_tmp33) = (void *)tmp___10;
#line 459
        __cil_tmp34 = (unsigned long )(& __wait) + 16;
#line 459
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp34) = & autoremove_wake_function;
#line 459
        __cil_tmp35 = (unsigned long )(& __wait) + 24;
#line 459
        __cil_tmp36 = (unsigned long )(& __wait) + 24;
#line 459
        *((struct list_head **)__cil_tmp35) = (struct list_head *)__cil_tmp36;
#line 459
        __cil_tmp37 = 24 + 8;
#line 459
        __cil_tmp38 = (unsigned long )(& __wait) + __cil_tmp37;
#line 459
        __cil_tmp39 = (unsigned long )(& __wait) + 24;
#line 459
        *((struct list_head **)__cil_tmp38) = (struct list_head *)__cil_tmp39;
        }
        {
#line 459
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 459
          __cil_tmp40 = (unsigned long )fence;
#line 459
          __cil_tmp41 = __cil_tmp40 + 64;
#line 459
          __cil_tmp42 = (wait_queue_head_t *)__cil_tmp41;
#line 459
          prepare_to_wait(__cil_tmp42, & __wait, 1);
#line 459
          tmp___11 = vmw_fence_obj_signaled(fence, flags);
          }
#line 459
          if (tmp___11) {
#line 459
            goto while_break___0;
          } else {

          }
          {
#line 459
          tmp___12 = get_current();
#line 459
          tmp___13 = signal_pending(tmp___12);
          }
#line 459
          if (tmp___13) {

          } else {
            {
#line 459
            __ret = schedule_timeout(__ret);
            }
#line 459
            if (! __ret) {
#line 459
              goto while_break___0;
            } else {

            }
#line 459
            goto __Cont;
          }
#line 459
          __ret = -512L;
#line 459
          goto while_break___0;
          __Cont: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 459
        __cil_tmp43 = (unsigned long )fence;
#line 459
        __cil_tmp44 = __cil_tmp43 + 64;
#line 459
        __cil_tmp45 = (wait_queue_head_t *)__cil_tmp44;
#line 459
        finish_wait(__cil_tmp45, & __wait);
        }
#line 459
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 459
    ret = __ret;
  } else {
    {
#line 464
    __ret___0 = (long )timeout;
#line 464
    tmp___17 = vmw_fence_obj_signaled(fence, flags);
    }
#line 464
    if (tmp___17) {

    } else {
      {
#line 464
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 464
        tmp___15 = get_current();
#line 464
        __cil_tmp46 = & __wait___0;
#line 464
        *((unsigned int *)__cil_tmp46) = 0U;
#line 464
        __cil_tmp47 = (unsigned long )(& __wait___0) + 8;
#line 464
        *((void **)__cil_tmp47) = (void *)tmp___15;
#line 464
        __cil_tmp48 = (unsigned long )(& __wait___0) + 16;
#line 464
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp48) = & autoremove_wake_function;
#line 464
        __cil_tmp49 = (unsigned long )(& __wait___0) + 24;
#line 464
        __cil_tmp50 = (unsigned long )(& __wait___0) + 24;
#line 464
        *((struct list_head **)__cil_tmp49) = (struct list_head *)__cil_tmp50;
#line 464
        __cil_tmp51 = 24 + 8;
#line 464
        __cil_tmp52 = (unsigned long )(& __wait___0) + __cil_tmp51;
#line 464
        __cil_tmp53 = (unsigned long )(& __wait___0) + 24;
#line 464
        *((struct list_head **)__cil_tmp52) = (struct list_head *)__cil_tmp53;
        }
        {
#line 464
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 464
          __cil_tmp54 = (unsigned long )fence;
#line 464
          __cil_tmp55 = __cil_tmp54 + 64;
#line 464
          __cil_tmp56 = (wait_queue_head_t *)__cil_tmp55;
#line 464
          prepare_to_wait(__cil_tmp56, & __wait___0, 2);
#line 464
          tmp___16 = vmw_fence_obj_signaled(fence, flags);
          }
#line 464
          if (tmp___16) {
#line 464
            goto while_break___2;
          } else {

          }
          {
#line 464
          __ret___0 = schedule_timeout(__ret___0);
          }
#line 464
          if (! __ret___0) {
#line 464
            goto while_break___2;
          } else {

          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 464
        __cil_tmp57 = (unsigned long )fence;
#line 464
        __cil_tmp58 = __cil_tmp57 + 64;
#line 464
        __cil_tmp59 = (wait_queue_head_t *)__cil_tmp58;
#line 464
        finish_wait(__cil_tmp59, & __wait___0);
        }
#line 464
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 464
    ret = __ret___0;
  }
  {
#line 469
  vmw_seqno_waiter_remove(dev_priv);
#line 471
  __cil_tmp60 = ret == 0L;
#line 471
  __cil_tmp61 = ! __cil_tmp60;
#line 471
  __cil_tmp62 = ! __cil_tmp61;
#line 471
  __cil_tmp63 = (long )__cil_tmp62;
#line 471
  tmp___19 = ldv__builtin_expect(__cil_tmp63, 0L);
  }
#line 471
  if (tmp___19) {
#line 472
    ret = -16L;
  } else {
    {
#line 473
    __cil_tmp64 = ret > 0L;
#line 473
    __cil_tmp65 = ! __cil_tmp64;
#line 473
    __cil_tmp66 = ! __cil_tmp65;
#line 473
    __cil_tmp67 = (long )__cil_tmp66;
#line 473
    tmp___18 = ldv__builtin_expect(__cil_tmp67, 1L);
    }
#line 473
    if (tmp___18) {
#line 474
      ret = 0L;
    } else {

    }
  }
#line 476
  return ((int )ret);
}
}
#line 479 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct vmw_fence_manager *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  {
#line 481
  __cil_tmp3 = (unsigned long )fence;
#line 481
  __cil_tmp4 = __cil_tmp3 + 8;
#line 481
  __cil_tmp5 = *((struct vmw_fence_manager **)__cil_tmp4);
#line 481
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 481
  __cil_tmp7 = __cil_tmp6 + 8;
#line 481
  dev_priv = *((struct vmw_private **)__cil_tmp7);
#line 483
  __cil_tmp8 = (uint32_t )1;
#line 483
  vmw_fifo_ping_host(dev_priv, __cil_tmp8);
  }
#line 484
  return;
}
}
#line 486 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void    *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_private *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  u32 __cil_tmp12 ;
  uint64_t __cil_tmp13 ;

  {
  {
#line 488
  __cil_tmp4 = (unsigned long )fence;
#line 488
  __cil_tmp5 = __cil_tmp4 + 8;
#line 488
  fman = *((struct vmw_fence_manager **)__cil_tmp5);
#line 490
  __cil_tmp6 = (void    *)fence;
#line 490
  kfree(__cil_tmp6);
#line 494
  __cil_tmp7 = (unsigned long )fman;
#line 494
  __cil_tmp8 = __cil_tmp7 + 8;
#line 494
  __cil_tmp9 = *((struct vmw_private **)__cil_tmp8);
#line 494
  tmp___7 = vmw_mem_glob(__cil_tmp9);
#line 494
  __cil_tmp10 = (unsigned long )fman;
#line 494
  __cil_tmp11 = __cil_tmp10 + 92;
#line 494
  __cil_tmp12 = *((u32 *)__cil_tmp11);
#line 494
  __cil_tmp13 = (uint64_t )__cil_tmp12;
#line 494
  ttm_mem_global_free(tmp___7, __cil_tmp13);
  }
#line 496
  return;
}
}
#line 498 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) 
{ struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_fence_obj *fence ;
  int ret ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_private *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  u32 __cil_tmp18 ;
  uint64_t __cil_tmp19 ;
  bool __cil_tmp20 ;
  bool __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  void    *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  u32 __cil_tmp40 ;
  uint64_t __cil_tmp41 ;

  {
  {
#line 503
  __cil_tmp13 = (unsigned long )fman;
#line 503
  __cil_tmp14 = __cil_tmp13 + 8;
#line 503
  __cil_tmp15 = *((struct vmw_private **)__cil_tmp14);
#line 503
  tmp___7 = vmw_mem_glob(__cil_tmp15);
#line 503
  mem_glob = tmp___7;
#line 507
  __cil_tmp16 = (unsigned long )fman;
#line 507
  __cil_tmp17 = __cil_tmp16 + 92;
#line 507
  __cil_tmp18 = *((u32 *)__cil_tmp17);
#line 507
  __cil_tmp19 = (uint64_t )__cil_tmp18;
#line 507
  __cil_tmp20 = (bool )0;
#line 507
  __cil_tmp21 = (bool )0;
#line 507
  ret = ttm_mem_global_alloc(mem_glob, __cil_tmp19, __cil_tmp20, __cil_tmp21);
#line 509
  __cil_tmp22 = ret != 0;
#line 509
  __cil_tmp23 = ! __cil_tmp22;
#line 509
  __cil_tmp24 = ! __cil_tmp23;
#line 509
  __cil_tmp25 = (long )__cil_tmp24;
#line 509
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 0L);
  }
#line 509
  if (tmp___8) {
#line 510
    return (ret);
  } else {

  }
  {
#line 512
  tmp___9 = kzalloc(104UL, 208U);
#line 512
  fence = (struct vmw_fence_obj *)tmp___9;
#line 513
  __cil_tmp26 = (void *)0;
#line 513
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 513
  __cil_tmp28 = (unsigned long )fence;
#line 513
  __cil_tmp29 = __cil_tmp28 == __cil_tmp27;
#line 513
  __cil_tmp30 = ! __cil_tmp29;
#line 513
  __cil_tmp31 = ! __cil_tmp30;
#line 513
  __cil_tmp32 = (long )__cil_tmp31;
#line 513
  tmp___10 = ldv__builtin_expect(__cil_tmp32, 0L);
  }
#line 513
  if (tmp___10) {
#line 514
    ret = -12;
#line 515
    goto out_no_object;
  } else {

  }
  {
#line 518
  ret = vmw_fence_obj_init(fman, fence, seqno, mask, & vmw_fence_destroy);
#line 520
  __cil_tmp33 = ret != 0;
#line 520
  __cil_tmp34 = ! __cil_tmp33;
#line 520
  __cil_tmp35 = ! __cil_tmp34;
#line 520
  __cil_tmp36 = (long )__cil_tmp35;
#line 520
  tmp___11 = ldv__builtin_expect(__cil_tmp36, 0L);
  }
#line 520
  if (tmp___11) {
#line 521
    goto out_err_init;
  } else {

  }
#line 523
  *p_fence = fence;
#line 524
  return (0);
  out_err_init: 
  {
#line 527
  __cil_tmp37 = (void    *)fence;
#line 527
  kfree(__cil_tmp37);
  }
  out_no_object: 
  {
#line 529
  __cil_tmp38 = (unsigned long )fman;
#line 529
  __cil_tmp39 = __cil_tmp38 + 92;
#line 529
  __cil_tmp40 = *((u32 *)__cil_tmp39);
#line 529
  __cil_tmp41 = (uint64_t )__cil_tmp40;
#line 529
  ttm_mem_global_free(mem_glob, __cil_tmp41);
  }
#line 530
  return (ret);
}
}
#line 534 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_user_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_user_fence *ufence ;
  struct vmw_fence_obj    *__mptr ;
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_fence *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_fence_obj *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void    *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_private *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  u32 __cil_tmp21 ;
  uint64_t __cil_tmp22 ;

  {
  {
#line 537
  __mptr = (struct vmw_fence_obj    *)fence;
#line 537
  __cil_tmp6 = (struct vmw_user_fence *)0;
#line 537
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 537
  __cil_tmp8 = __cil_tmp7 + 64;
#line 537
  __cil_tmp9 = (struct vmw_fence_obj *)__cil_tmp8;
#line 537
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 537
  __cil_tmp11 = (char *)__mptr;
#line 537
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 537
  ufence = (struct vmw_user_fence *)__cil_tmp12;
#line 538
  __cil_tmp13 = (unsigned long )fence;
#line 538
  __cil_tmp14 = __cil_tmp13 + 8;
#line 538
  fman = *((struct vmw_fence_manager **)__cil_tmp14);
#line 540
  __cil_tmp15 = (void    *)ufence;
#line 540
  kfree(__cil_tmp15);
#line 544
  __cil_tmp16 = (unsigned long )fman;
#line 544
  __cil_tmp17 = __cil_tmp16 + 8;
#line 544
  __cil_tmp18 = *((struct vmw_private **)__cil_tmp17);
#line 544
  tmp___7 = vmw_mem_glob(__cil_tmp18);
#line 544
  __cil_tmp19 = (unsigned long )fman;
#line 544
  __cil_tmp20 = __cil_tmp19 + 88;
#line 544
  __cil_tmp21 = *((u32 *)__cil_tmp20);
#line 544
  __cil_tmp22 = (uint64_t )__cil_tmp21;
#line 544
  ttm_mem_global_free(tmp___7, __cil_tmp22);
  }
#line 546
  return;
}
}
#line 548 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_user_fence_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_fence *ufence ;
  struct ttm_base_object    *__mptr ;
  struct vmw_fence_obj *fence ;
  struct vmw_user_fence *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_fence_obj **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 550
  base = *p_base;
#line 552
  __mptr = (struct ttm_base_object    *)base;
#line 552
  __cil_tmp6 = (struct vmw_user_fence *)0;
#line 552
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
#line 552
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 552
  __cil_tmp9 = (char *)__mptr;
#line 552
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 552
  ufence = (struct vmw_user_fence *)__cil_tmp10;
#line 553
  __cil_tmp11 = & fence;
#line 553
  __cil_tmp12 = (unsigned long )ufence;
#line 553
  __cil_tmp13 = __cil_tmp12 + 64;
#line 553
  *__cil_tmp11 = (struct vmw_fence_obj *)__cil_tmp13;
#line 555
  __cil_tmp14 = (void *)0;
#line 555
  *p_base = (struct ttm_base_object *)__cil_tmp14;
#line 556
  vmw_fence_obj_unreference(& fence);
  }
#line 557
  return;
}
}
#line 559 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *tmp___8 ;
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___9 ;
  int ret ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_private *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  u32 __cil_tmp26 ;
  uint64_t __cil_tmp27 ;
  bool __cil_tmp28 ;
  bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_fence_obj *__cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  void    *__cil_tmp48 ;
  struct vmw_fence_obj **__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct vmw_fence_obj *__cil_tmp52 ;
  struct ttm_base_object *__cil_tmp53 ;
  bool __cil_tmp54 ;
  enum ttm_object_type __cil_tmp55 ;
  void *__cil_tmp56 ;
  void (*__cil_tmp57)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct vmw_fence_obj **__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  u32 __cil_tmp74 ;
  uint64_t __cil_tmp75 ;

  {
  {
#line 566
  tmp___7 = vmw_fpriv(file_priv);
#line 566
  __cil_tmp19 = (unsigned long )tmp___7;
#line 566
  __cil_tmp20 = __cil_tmp19 + 8;
#line 566
  tfile = *((struct ttm_object_file **)__cil_tmp20);
#line 569
  __cil_tmp21 = (unsigned long )fman;
#line 569
  __cil_tmp22 = __cil_tmp21 + 8;
#line 569
  __cil_tmp23 = *((struct vmw_private **)__cil_tmp22);
#line 569
  tmp___9 = vmw_mem_glob(__cil_tmp23);
#line 569
  mem_glob = tmp___9;
#line 577
  __cil_tmp24 = (unsigned long )fman;
#line 577
  __cil_tmp25 = __cil_tmp24 + 88;
#line 577
  __cil_tmp26 = *((u32 *)__cil_tmp25);
#line 577
  __cil_tmp27 = (uint64_t )__cil_tmp26;
#line 577
  __cil_tmp28 = (bool )0;
#line 577
  __cil_tmp29 = (bool )0;
#line 577
  ret = ttm_mem_global_alloc(mem_glob, __cil_tmp27, __cil_tmp28, __cil_tmp29);
#line 579
  __cil_tmp30 = ret != 0;
#line 579
  __cil_tmp31 = ! __cil_tmp30;
#line 579
  __cil_tmp32 = ! __cil_tmp31;
#line 579
  __cil_tmp33 = (long )__cil_tmp32;
#line 579
  tmp___10 = ldv__builtin_expect(__cil_tmp33, 0L);
  }
#line 579
  if (tmp___10) {
#line 580
    return (ret);
  } else {

  }
  {
#line 582
  tmp___11 = kzalloc(168UL, 208U);
#line 582
  ufence = (struct vmw_user_fence *)tmp___11;
#line 583
  __cil_tmp34 = (void *)0;
#line 583
  __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 583
  __cil_tmp36 = (unsigned long )ufence;
#line 583
  __cil_tmp37 = __cil_tmp36 == __cil_tmp35;
#line 583
  __cil_tmp38 = ! __cil_tmp37;
#line 583
  __cil_tmp39 = ! __cil_tmp38;
#line 583
  __cil_tmp40 = (long )__cil_tmp39;
#line 583
  tmp___12 = ldv__builtin_expect(__cil_tmp40, 0L);
  }
#line 583
  if (tmp___12) {
#line 584
    ret = -12;
#line 585
    goto out_no_object;
  } else {

  }
  {
#line 588
  __cil_tmp41 = (unsigned long )ufence;
#line 588
  __cil_tmp42 = __cil_tmp41 + 64;
#line 588
  __cil_tmp43 = (struct vmw_fence_obj *)__cil_tmp42;
#line 588
  ret = vmw_fence_obj_init(fman, __cil_tmp43, seqno, mask, & vmw_user_fence_destroy);
#line 590
  __cil_tmp44 = ret != 0;
#line 590
  __cil_tmp45 = ! __cil_tmp44;
#line 590
  __cil_tmp46 = ! __cil_tmp45;
#line 590
  __cil_tmp47 = (long )__cil_tmp46;
#line 590
  tmp___13 = ldv__builtin_expect(__cil_tmp47, 0L);
  }
#line 590
  if (tmp___13) {
    {
#line 591
    __cil_tmp48 = (void    *)ufence;
#line 591
    kfree(__cil_tmp48);
    }
#line 592
    goto out_no_object;
  } else {

  }
  {
#line 599
  __cil_tmp49 = & tmp___8;
#line 599
  __cil_tmp50 = (unsigned long )ufence;
#line 599
  __cil_tmp51 = __cil_tmp50 + 64;
#line 599
  __cil_tmp52 = (struct vmw_fence_obj *)__cil_tmp51;
#line 599
  *__cil_tmp49 = vmw_fence_obj_reference(__cil_tmp52);
#line 600
  __cil_tmp53 = (struct ttm_base_object *)ufence;
#line 600
  __cil_tmp54 = (bool )0;
#line 600
  __cil_tmp55 = (enum ttm_object_type )259;
#line 600
  __cil_tmp56 = (void *)0;
#line 600
  __cil_tmp57 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp56;
#line 600
  ret = ttm_base_object_init(tfile, __cil_tmp53, __cil_tmp54, __cil_tmp55, & vmw_user_fence_base_release,
                             __cil_tmp57);
#line 605
  __cil_tmp58 = ret != 0;
#line 605
  __cil_tmp59 = ! __cil_tmp58;
#line 605
  __cil_tmp60 = ! __cil_tmp59;
#line 605
  __cil_tmp61 = (long )__cil_tmp60;
#line 605
  tmp___14 = ldv__builtin_expect(__cil_tmp61, 0L);
  }
#line 605
  if (tmp___14) {
    {
#line 609
    vmw_fence_obj_unreference(& tmp___8);
    }
#line 610
    goto out_err;
  } else {

  }
#line 613
  __cil_tmp62 = (unsigned long )ufence;
#line 613
  __cil_tmp63 = __cil_tmp62 + 64;
#line 613
  *p_fence = (struct vmw_fence_obj *)__cil_tmp63;
#line 614
  __cil_tmp64 = 0 + 16;
#line 614
  __cil_tmp65 = 0 + __cil_tmp64;
#line 614
  __cil_tmp66 = (unsigned long )ufence;
#line 614
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
#line 614
  __cil_tmp68 = *((unsigned long *)__cil_tmp67);
#line 614
  *p_handle = (uint32_t )__cil_tmp68;
#line 616
  return (0);
  out_err: 
  {
#line 618
  __cil_tmp69 = & tmp___8;
#line 618
  __cil_tmp70 = (unsigned long )ufence;
#line 618
  __cil_tmp71 = __cil_tmp70 + 64;
#line 618
  *__cil_tmp69 = (struct vmw_fence_obj *)__cil_tmp71;
#line 619
  vmw_fence_obj_unreference(& tmp___8);
  }
  out_no_object: 
  {
#line 621
  __cil_tmp72 = (unsigned long )fman;
#line 621
  __cil_tmp73 = __cil_tmp72 + 88;
#line 621
  __cil_tmp74 = *((u32 *)__cil_tmp73);
#line 621
  __cil_tmp75 = (uint64_t )__cil_tmp74;
#line 621
  ttm_mem_global_free(mem_glob, __cil_tmp75);
  }
#line 622
  return (ret);
}
}
#line 630 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  struct list_head action_list ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_fence_obj *fence ;
  struct list_head    *__mptr ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  struct list_head    *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct vmw_fence_obj *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  struct kref *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  spinlock_t *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  bool __cil_tmp42 ;
  bool __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  wait_queue_head_t *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  spinlock_t *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  struct list_head    *__cil_tmp69 ;
  long __cil_tmp70 ;
  struct kref *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  spinlock_t *__cil_tmp74 ;

  {
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 641
      __cil_tmp15 = (unsigned long )fman;
#line 641
      __cil_tmp16 = __cil_tmp15 + 16;
#line 641
      __cil_tmp17 = (spinlock_t *)__cil_tmp16;
#line 641
      tmp___7 = spinlock_check(__cil_tmp17);
#line 641
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 641
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 641
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  __cil_tmp18 = (unsigned long )fman;
#line 642
  __cil_tmp19 = __cil_tmp18 + 100;
#line 642
  *((bool *)__cil_tmp19) = (bool )1;
  {
#line 643
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 643
    __cil_tmp20 = (unsigned long )fman;
#line 643
    __cil_tmp21 = __cil_tmp20 + 40;
#line 643
    __cil_tmp22 = (struct list_head *)__cil_tmp21;
#line 643
    __cil_tmp23 = (struct list_head    *)__cil_tmp22;
#line 643
    tmp___12 = list_empty(__cil_tmp23);
    }
#line 643
    if (tmp___12) {
#line 643
      goto while_break___1;
    } else {

    }
    {
#line 645
    __cil_tmp24 = 40 + 8;
#line 645
    __cil_tmp25 = (unsigned long )fman;
#line 645
    __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
#line 645
    __cil_tmp27 = *((struct list_head **)__cil_tmp26);
#line 645
    __mptr = (struct list_head    *)__cil_tmp27;
#line 645
    __cil_tmp28 = (struct vmw_fence_obj *)0;
#line 645
    __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 645
    __cil_tmp30 = __cil_tmp29 + 16;
#line 645
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
#line 645
    __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 645
    __cil_tmp33 = (char *)__mptr;
#line 645
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
#line 645
    fence = (struct vmw_fence_obj *)__cil_tmp34;
#line 647
    __cil_tmp35 = (struct kref *)fence;
#line 647
    kref_get(__cil_tmp35);
#line 648
    __cil_tmp36 = (unsigned long )fman;
#line 648
    __cil_tmp37 = __cil_tmp36 + 16;
#line 648
    __cil_tmp38 = (spinlock_t *)__cil_tmp37;
#line 648
    spin_unlock_irq(__cil_tmp38);
#line 650
    __cil_tmp39 = (unsigned long )fence;
#line 650
    __cil_tmp40 = __cil_tmp39 + 36;
#line 650
    __cil_tmp41 = *((uint32_t *)__cil_tmp40);
#line 650
    __cil_tmp42 = (bool )0;
#line 650
    __cil_tmp43 = (bool )0;
#line 650
    ret = vmw_fence_obj_wait(fence, __cil_tmp41, __cil_tmp42, __cil_tmp43, 1250UL);
#line 654
    __cil_tmp44 = ret != 0;
#line 654
    __cil_tmp45 = ! __cil_tmp44;
#line 654
    __cil_tmp46 = ! __cil_tmp45;
#line 654
    __cil_tmp47 = (long )__cil_tmp46;
#line 654
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 0L);
    }
#line 654
    if (tmp___8) {
      {
#line 655
      __cil_tmp48 = (unsigned long )fence;
#line 655
      __cil_tmp49 = __cil_tmp48 + 16;
#line 655
      __cil_tmp50 = (struct list_head *)__cil_tmp49;
#line 655
      list_del_init(__cil_tmp50);
#line 656
      __cil_tmp51 = (unsigned long )fence;
#line 656
      __cil_tmp52 = __cil_tmp51 + 32;
#line 656
      __cil_tmp53 = (unsigned long )fence;
#line 656
      __cil_tmp54 = __cil_tmp53 + 32;
#line 656
      __cil_tmp55 = *((uint32_t *)__cil_tmp54);
#line 656
      *((uint32_t *)__cil_tmp52) = __cil_tmp55 | 1U;
#line 657
      INIT_LIST_HEAD(& action_list);
#line 658
      __cil_tmp56 = (unsigned long )fence;
#line 658
      __cil_tmp57 = __cil_tmp56 + 40;
#line 658
      __cil_tmp58 = (struct list_head *)__cil_tmp57;
#line 658
      list_splice_init(__cil_tmp58, & action_list);
#line 660
      vmw_fences_perform_actions(fman, & action_list);
#line 661
      __cil_tmp59 = (unsigned long )fence;
#line 661
      __cil_tmp60 = __cil_tmp59 + 64;
#line 661
      __cil_tmp61 = (wait_queue_head_t *)__cil_tmp60;
#line 661
      __cil_tmp62 = (void *)0;
#line 661
      __wake_up(__cil_tmp61, 3U, 0, __cil_tmp62);
      }
    } else {

    }
    {
#line 664
    __cil_tmp63 = (unsigned long )fman;
#line 664
    __cil_tmp64 = __cil_tmp63 + 16;
#line 664
    __cil_tmp65 = (spinlock_t *)__cil_tmp64;
#line 664
    spin_lock_irq(__cil_tmp65);
    }
    {
#line 666
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 666
      __cil_tmp66 = (unsigned long )fence;
#line 666
      __cil_tmp67 = __cil_tmp66 + 16;
#line 666
      __cil_tmp68 = (struct list_head *)__cil_tmp67;
#line 666
      __cil_tmp69 = (struct list_head    *)__cil_tmp68;
#line 666
      tmp___9 = list_empty(__cil_tmp69);
      }
#line 666
      if (tmp___9) {
#line 666
        tmp___10 = 0;
      } else {
#line 666
        tmp___10 = 1;
      }
      {
#line 666
      __cil_tmp70 = (long )tmp___10;
#line 666
      tmp___11 = ldv__builtin_expect(__cil_tmp70, 0L);
      }
#line 666
      if (tmp___11) {
        {
#line 666
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 666
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                               "i" (666), "i" (12UL));
          {
#line 666
          while (1) {
            while_continue___4: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 666
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {

      }
#line 666
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 667
    __cil_tmp71 = (struct kref *)fence;
#line 667
    kref_put(__cil_tmp71, & vmw_fence_obj_destroy_locked);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 669
  __cil_tmp72 = (unsigned long )fman;
#line 669
  __cil_tmp73 = __cil_tmp72 + 16;
#line 669
  __cil_tmp74 = (spinlock_t *)__cil_tmp73;
#line 669
  spin_unlock_irqrestore(__cil_tmp74, irq_flags);
  }
#line 670
  return;
}
}
#line 672 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  spinlock_t *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;

  {
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 676
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 676
      __cil_tmp6 = (unsigned long )fman;
#line 676
      __cil_tmp7 = __cil_tmp6 + 16;
#line 676
      __cil_tmp8 = (spinlock_t *)__cil_tmp7;
#line 676
      tmp___7 = spinlock_check(__cil_tmp8);
#line 676
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 676
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 676
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  __cil_tmp9 = (unsigned long )fman;
#line 677
  __cil_tmp10 = __cil_tmp9 + 100;
#line 677
  *((bool *)__cil_tmp10) = (bool )0;
#line 678
  __cil_tmp11 = (unsigned long )fman;
#line 678
  __cil_tmp12 = __cil_tmp11 + 16;
#line 678
  __cil_tmp13 = (spinlock_t *)__cil_tmp12;
#line 678
  spin_unlock_irqrestore(__cil_tmp13, irq_flags);
  }
#line 679
  return;
}
}
#line 682 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_wait_arg *arg ;
  unsigned long timeout ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  int ret ;
  uint64_t wait_timeout ;
  long tmp___8 ;
  struct ttm_base_object    *__mptr ;
  bool tmp___10 ;
  int tmp___11 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint64_t __cil_tmp25 ;
  uint64_t __cil_tmp26 ;
  uint64_t __cil_tmp27 ;
  uint64_t __cil_tmp28 ;
  uint64_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint64_t __cil_tmp37 ;
  struct ttm_base_object **__cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct ttm_base_object **__cil_tmp42 ;
  struct ttm_base_object *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_base_object **__cil_tmp51 ;
  struct ttm_base_object *__cil_tmp52 ;
  struct vmw_user_fence *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  struct vmw_user_fence *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint64_t __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  long __cil_tmp65 ;
  long __cil_tmp66 ;
  long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int32_t __cil_tmp70 ;
  uint32_t __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  uint64_t __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  int32_t __cil_tmp78 ;
  uint32_t __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  int32_t __cil_tmp82 ;
  bool __cil_tmp83 ;
  bool __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int32_t __cil_tmp87 ;
  uint32_t __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  enum ttm_ref_type __cil_tmp90 ;

  {
  {
#line 685
  arg = (struct drm_vmw_fence_wait_arg *)data;
#line 690
  tmp___7 = vmw_fpriv(file_priv);
#line 690
  __cil_tmp21 = (unsigned long )tmp___7;
#line 690
  __cil_tmp22 = __cil_tmp21 + 8;
#line 690
  tfile = *((struct ttm_object_file **)__cil_tmp22);
#line 692
  __cil_tmp23 = (unsigned long )arg;
#line 692
  __cil_tmp24 = __cil_tmp23 + 16;
#line 692
  __cil_tmp25 = *((uint64_t *)__cil_tmp24);
#line 692
  wait_timeout = __cil_tmp25 * 250ULL;
#line 699
  __cil_tmp26 = wait_timeout >> 26;
#line 699
  __cil_tmp27 = wait_timeout >> 24;
#line 699
  __cil_tmp28 = wait_timeout >> 20;
#line 699
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
#line 699
  wait_timeout = __cil_tmp29 - __cil_tmp26;
  }
  {
#line 702
  __cil_tmp30 = (unsigned long )arg;
#line 702
  __cil_tmp31 = __cil_tmp30 + 4;
#line 702
  __cil_tmp32 = *((int32_t *)__cil_tmp31);
#line 702
  if (! __cil_tmp32) {
#line 703
    __cil_tmp33 = (unsigned long )arg;
#line 703
    __cil_tmp34 = __cil_tmp33 + 4;
#line 703
    *((int32_t *)__cil_tmp34) = 1;
#line 704
    __cil_tmp35 = (unsigned long )arg;
#line 704
    __cil_tmp36 = __cil_tmp35 + 8;
#line 704
    __cil_tmp37 = (uint64_t )jiffies;
#line 704
    *((uint64_t *)__cil_tmp36) = __cil_tmp37 + wait_timeout;
  } else {

  }
  }
  {
#line 707
  __cil_tmp38 = & base;
#line 707
  __cil_tmp39 = *((uint32_t *)arg);
#line 707
  *__cil_tmp38 = ttm_base_object_lookup(tfile, __cil_tmp39);
#line 708
  __cil_tmp40 = (void *)0;
#line 708
  __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 708
  __cil_tmp42 = & base;
#line 708
  __cil_tmp43 = *__cil_tmp42;
#line 708
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 708
  __cil_tmp45 = __cil_tmp44 == __cil_tmp41;
#line 708
  __cil_tmp46 = ! __cil_tmp45;
#line 708
  __cil_tmp47 = ! __cil_tmp46;
#line 708
  __cil_tmp48 = (long )__cil_tmp47;
#line 708
  tmp___8 = ldv__builtin_expect(__cil_tmp48, 0L);
  }
#line 708
  if (tmp___8) {
    {
#line 709
    __cil_tmp49 = *((uint32_t *)arg);
#line 709
    __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 709
    printk("<3>Wait invalid fence object handle 0x%08lx.\n", __cil_tmp50);
    }
#line 712
    return (-22);
  } else {

  }
#line 715
  __cil_tmp51 = & base;
#line 715
  __cil_tmp52 = *__cil_tmp51;
#line 715
  __mptr = (struct ttm_base_object    *)__cil_tmp52;
#line 715
  __cil_tmp53 = (struct vmw_user_fence *)0;
#line 715
  __cil_tmp54 = (struct ttm_base_object *)__cil_tmp53;
#line 715
  __cil_tmp55 = (unsigned int )__cil_tmp54;
#line 715
  __cil_tmp56 = (char *)__mptr;
#line 715
  __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
#line 715
  __cil_tmp58 = (struct vmw_user_fence *)__cil_tmp57;
#line 715
  __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 715
  __cil_tmp60 = __cil_tmp59 + 64;
#line 715
  fence = (struct vmw_fence_obj *)__cil_tmp60;
#line 717
  timeout = (unsigned long )jiffies;
  {
#line 718
  __cil_tmp61 = (unsigned long )arg;
#line 718
  __cil_tmp62 = __cil_tmp61 + 8;
#line 718
  __cil_tmp63 = *((uint64_t *)__cil_tmp62);
#line 718
  __cil_tmp64 = (unsigned long )__cil_tmp63;
#line 718
  __cil_tmp65 = (long )__cil_tmp64;
#line 718
  __cil_tmp66 = (long )timeout;
#line 718
  __cil_tmp67 = __cil_tmp66 - __cil_tmp65;
#line 718
  if (__cil_tmp67 >= 0L) {
    {
#line 719
    __cil_tmp68 = (unsigned long )arg;
#line 719
    __cil_tmp69 = __cil_tmp68 + 28;
#line 719
    __cil_tmp70 = *((int32_t *)__cil_tmp69);
#line 719
    __cil_tmp71 = (uint32_t )__cil_tmp70;
#line 719
    tmp___10 = vmw_fence_obj_signaled(fence, __cil_tmp71);
    }
#line 719
    if (tmp___10) {
#line 719
      ret = 0;
    } else {
#line 719
      ret = -16;
    }
#line 721
    goto out;
  } else {

  }
  }
  {
#line 724
  __cil_tmp72 = (unsigned long )arg;
#line 724
  __cil_tmp73 = __cil_tmp72 + 8;
#line 724
  __cil_tmp74 = *((uint64_t *)__cil_tmp73);
#line 724
  __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 724
  timeout = __cil_tmp75 - timeout;
#line 726
  __cil_tmp76 = (unsigned long )arg;
#line 726
  __cil_tmp77 = __cil_tmp76 + 28;
#line 726
  __cil_tmp78 = *((int32_t *)__cil_tmp77);
#line 726
  __cil_tmp79 = (uint32_t )__cil_tmp78;
#line 726
  __cil_tmp80 = (unsigned long )arg;
#line 726
  __cil_tmp81 = __cil_tmp80 + 24;
#line 726
  __cil_tmp82 = *((int32_t *)__cil_tmp81);
#line 726
  __cil_tmp83 = (bool )__cil_tmp82;
#line 726
  __cil_tmp84 = (bool )1;
#line 726
  ret = vmw_fence_obj_wait(fence, __cil_tmp79, __cil_tmp83, __cil_tmp84, timeout);
  }
  out: 
  {
#line 729
  ttm_base_object_unref(& base);
  }
#line 735
  if (ret == 0) {
    {
#line 735
    __cil_tmp85 = (unsigned long )arg;
#line 735
    __cil_tmp86 = __cil_tmp85 + 32;
#line 735
    __cil_tmp87 = *((int32_t *)__cil_tmp86);
#line 735
    if (__cil_tmp87 & 1) {
      {
#line 736
      __cil_tmp88 = *((uint32_t *)arg);
#line 736
      __cil_tmp89 = (unsigned long )__cil_tmp88;
#line 736
      __cil_tmp90 = (enum ttm_ref_type )0;
#line 736
      tmp___11 = ttm_ref_object_base_unref(tfile, __cil_tmp89, __cil_tmp90);
      }
#line 736
      return (tmp___11);
    } else {

    }
    }
  } else {

  }
#line 738
  return (ret);
}
}
#line 741 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_signaled_arg *arg ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  long tmp___9 ;
  struct ttm_base_object    *__mptr ;
  bool tmp___10 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct ttm_base_object **__cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_base_object **__cil_tmp21 ;
  struct ttm_base_object *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_base_object **__cil_tmp30 ;
  struct ttm_base_object *__cil_tmp31 ;
  struct vmw_user_fence *__cil_tmp32 ;
  struct ttm_base_object *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  struct vmw_user_fence *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  spinlock_t *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  spinlock_t *__cil_tmp60 ;

  {
  {
#line 744
  arg = (struct drm_vmw_fence_signaled_arg *)data;
#line 749
  tmp___7 = vmw_fpriv(file_priv);
#line 749
  __cil_tmp15 = (unsigned long )tmp___7;
#line 749
  __cil_tmp16 = __cil_tmp15 + 8;
#line 749
  tfile = *((struct ttm_object_file **)__cil_tmp16);
#line 750
  tmp___8 = vmw_priv(dev);
#line 750
  dev_priv = tmp___8;
#line 752
  __cil_tmp17 = & base;
#line 752
  __cil_tmp18 = *((uint32_t *)arg);
#line 752
  *__cil_tmp17 = ttm_base_object_lookup(tfile, __cil_tmp18);
#line 753
  __cil_tmp19 = (void *)0;
#line 753
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 753
  __cil_tmp21 = & base;
#line 753
  __cil_tmp22 = *__cil_tmp21;
#line 753
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 753
  __cil_tmp24 = __cil_tmp23 == __cil_tmp20;
#line 753
  __cil_tmp25 = ! __cil_tmp24;
#line 753
  __cil_tmp26 = ! __cil_tmp25;
#line 753
  __cil_tmp27 = (long )__cil_tmp26;
#line 753
  tmp___9 = ldv__builtin_expect(__cil_tmp27, 0L);
  }
#line 753
  if (tmp___9) {
    {
#line 754
    __cil_tmp28 = *((uint32_t *)arg);
#line 754
    __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 754
    printk("<3>Fence signaled invalid fence object handle 0x%08lx.\n", __cil_tmp29);
    }
#line 757
    return (-22);
  } else {

  }
  {
#line 760
  __cil_tmp30 = & base;
#line 760
  __cil_tmp31 = *__cil_tmp30;
#line 760
  __mptr = (struct ttm_base_object    *)__cil_tmp31;
#line 760
  __cil_tmp32 = (struct vmw_user_fence *)0;
#line 760
  __cil_tmp33 = (struct ttm_base_object *)__cil_tmp32;
#line 760
  __cil_tmp34 = (unsigned int )__cil_tmp33;
#line 760
  __cil_tmp35 = (char *)__mptr;
#line 760
  __cil_tmp36 = __cil_tmp35 - __cil_tmp34;
#line 760
  __cil_tmp37 = (struct vmw_user_fence *)__cil_tmp36;
#line 760
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 760
  __cil_tmp39 = __cil_tmp38 + 64;
#line 760
  fence = (struct vmw_fence_obj *)__cil_tmp39;
#line 761
  __cil_tmp40 = (unsigned long )fence;
#line 761
  __cil_tmp41 = __cil_tmp40 + 8;
#line 761
  fman = *((struct vmw_fence_manager **)__cil_tmp41);
#line 763
  __cil_tmp42 = (unsigned long )arg;
#line 763
  __cil_tmp43 = __cil_tmp42 + 4;
#line 763
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
#line 763
  tmp___10 = vmw_fence_obj_signaled(fence, __cil_tmp44);
#line 763
  __cil_tmp45 = (unsigned long )arg;
#line 763
  __cil_tmp46 = __cil_tmp45 + 8;
#line 763
  *((int32_t *)__cil_tmp46) = (int32_t )tmp___10;
#line 764
  __cil_tmp47 = (unsigned long )fman;
#line 764
  __cil_tmp48 = __cil_tmp47 + 16;
#line 764
  __cil_tmp49 = (spinlock_t *)__cil_tmp48;
#line 764
  spin_lock_irq(__cil_tmp49);
#line 766
  __cil_tmp50 = (unsigned long )arg;
#line 766
  __cil_tmp51 = __cil_tmp50 + 16;
#line 766
  __cil_tmp52 = (unsigned long )fence;
#line 766
  __cil_tmp53 = __cil_tmp52 + 32;
#line 766
  *((uint32_t *)__cil_tmp51) = *((uint32_t *)__cil_tmp53);
#line 767
  __cil_tmp54 = (unsigned long )arg;
#line 767
  __cil_tmp55 = __cil_tmp54 + 12;
#line 767
  __cil_tmp56 = (unsigned long )dev_priv;
#line 767
  __cil_tmp57 = __cil_tmp56 + 2980;
#line 767
  *((uint32_t *)__cil_tmp55) = *((uint32_t *)__cil_tmp57);
#line 768
  __cil_tmp58 = (unsigned long )fman;
#line 768
  __cil_tmp59 = __cil_tmp58 + 16;
#line 768
  __cil_tmp60 = (spinlock_t *)__cil_tmp59;
#line 768
  spin_unlock_irq(__cil_tmp60);
#line 770
  ttm_base_object_unref(& base);
  }
#line 772
  return (0);
}
}
#line 776 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_arg *arg ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct ttm_object_file *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  {
#line 779
  arg = (struct drm_vmw_fence_arg *)data;
#line 782
  tmp___7 = vmw_fpriv(file_priv);
#line 782
  __cil_tmp7 = (unsigned long )tmp___7;
#line 782
  __cil_tmp8 = __cil_tmp7 + 8;
#line 782
  __cil_tmp9 = *((struct ttm_object_file **)__cil_tmp8);
#line 782
  __cil_tmp10 = *((uint32_t *)arg);
#line 782
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 782
  __cil_tmp12 = (enum ttm_ref_type )0;
#line 782
  tmp___8 = ttm_ref_object_base_unref(__cil_tmp9, __cil_tmp11, __cil_tmp12);
  }
#line 782
  return (tmp___8);
}
}
#line 800 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) 
{ struct vmw_event_fence_action *eaction ;
  struct drm_pending_event *event ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  struct list_head    *__mptr ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;
  struct list_head    *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct vmw_event_fence_action *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  spinlock_t *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  void (*__cil_tmp36)(struct drm_pending_event *event ) ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  spinlock_t *__cil_tmp39 ;

  {
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 808
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 808
        __cil_tmp11 = (unsigned long )fman;
#line 808
        __cil_tmp12 = __cil_tmp11 + 16;
#line 808
        __cil_tmp13 = (spinlock_t *)__cil_tmp12;
#line 808
        tmp___7 = spinlock_check(__cil_tmp13);
#line 808
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        }
#line 808
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 808
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 809
    __cil_tmp14 = (struct list_head    *)event_list;
#line 809
    tmp___8 = list_empty(__cil_tmp14);
    }
#line 809
    if (tmp___8) {
#line 810
      goto out_unlock;
    } else {

    }
    {
#line 811
    __cil_tmp15 = *((struct list_head **)event_list);
#line 811
    __mptr = (struct list_head    *)__cil_tmp15;
#line 811
    __cil_tmp16 = (struct vmw_event_fence_action *)0;
#line 811
    __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 811
    __cil_tmp18 = __cil_tmp17 + 40;
#line 811
    __cil_tmp19 = (struct list_head *)__cil_tmp18;
#line 811
    __cil_tmp20 = (unsigned int )__cil_tmp19;
#line 811
    __cil_tmp21 = (char *)__mptr;
#line 811
    __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
#line 811
    eaction = (struct vmw_event_fence_action *)__cil_tmp22;
#line 814
    __cil_tmp23 = (unsigned long )eaction;
#line 814
    __cil_tmp24 = __cil_tmp23 + 40;
#line 814
    __cil_tmp25 = (struct list_head *)__cil_tmp24;
#line 814
    list_del_init(__cil_tmp25);
#line 815
    __cil_tmp26 = (unsigned long )eaction;
#line 815
    __cil_tmp27 = __cil_tmp26 + 56;
#line 815
    event = *((struct drm_pending_event **)__cil_tmp27);
#line 816
    __cil_tmp28 = (unsigned long )eaction;
#line 816
    __cil_tmp29 = __cil_tmp28 + 56;
#line 816
    __cil_tmp30 = (void *)0;
#line 816
    *((struct drm_pending_event **)__cil_tmp29) = (struct drm_pending_event *)__cil_tmp30;
#line 817
    __cil_tmp31 = (unsigned long )fman;
#line 817
    __cil_tmp32 = __cil_tmp31 + 16;
#line 817
    __cil_tmp33 = (spinlock_t *)__cil_tmp32;
#line 817
    spin_unlock_irqrestore(__cil_tmp33, irq_flags);
#line 818
    __cil_tmp34 = (unsigned long )event;
#line 818
    __cil_tmp35 = __cil_tmp34 + 40;
#line 818
    __cil_tmp36 = *((void (**)(struct drm_pending_event *event ))__cil_tmp35);
#line 818
    (*__cil_tmp36)(event);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out_unlock: 
  {
#line 821
  __cil_tmp37 = (unsigned long )fman;
#line 821
  __cil_tmp38 = __cil_tmp37 + 16;
#line 821
  __cil_tmp39 = (spinlock_t *)__cil_tmp38;
#line 821
  spin_unlock_irqrestore(__cil_tmp39, irq_flags);
  }
#line 822
  return;
}
}
#line 836 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_event_fence_action_seq_passed(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action    *__mptr ;
  struct drm_device *dev ;
  struct drm_pending_event *event ;
  struct drm_file *file_priv ;
  unsigned long irq_flags ;
  long tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  struct timeval tv ;
  long tmp___9 ;
  struct vmw_event_fence_action *__cil_tmp14 ;
  struct vmw_fence_action *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  spinlock_t *__cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t *__cil_tmp47 ;
  struct timeval *__cil_tmp48 ;
  __kernel_time_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __kernel_suseconds_t __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct drm_pending_event *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  void *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  wait_queue_head_t *__cil_tmp72 ;
  void *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;

  {
  {
#line 839
  __mptr = (struct vmw_fence_action    *)action;
#line 839
  __cil_tmp14 = (struct vmw_event_fence_action *)0;
#line 839
  __cil_tmp15 = (struct vmw_fence_action *)__cil_tmp14;
#line 839
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 839
  __cil_tmp17 = (char *)__mptr;
#line 839
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 839
  eaction = (struct vmw_event_fence_action *)__cil_tmp18;
#line 840
  __cil_tmp19 = (unsigned long )eaction;
#line 840
  __cil_tmp20 = __cil_tmp19 + 72;
#line 840
  dev = *((struct drm_device **)__cil_tmp20);
#line 841
  __cil_tmp21 = (unsigned long )eaction;
#line 841
  __cil_tmp22 = __cil_tmp21 + 56;
#line 841
  event = *((struct drm_pending_event **)__cil_tmp22);
#line 845
  __cil_tmp23 = (void *)0;
#line 845
  __cil_tmp24 = (unsigned long )__cil_tmp23;
#line 845
  __cil_tmp25 = (unsigned long )event;
#line 845
  __cil_tmp26 = __cil_tmp25 == __cil_tmp24;
#line 845
  __cil_tmp27 = ! __cil_tmp26;
#line 845
  __cil_tmp28 = ! __cil_tmp27;
#line 845
  __cil_tmp29 = (long )__cil_tmp28;
#line 845
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  }
#line 845
  if (tmp___7) {
#line 846
    return;
  } else {

  }
#line 848
  __cil_tmp30 = (unsigned long )event;
#line 848
  __cil_tmp31 = __cil_tmp30 + 24;
#line 848
  file_priv = *((struct drm_file **)__cil_tmp31);
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 849
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 849
      __cil_tmp32 = (unsigned long )dev;
#line 849
      __cil_tmp33 = __cil_tmp32 + 872;
#line 849
      __cil_tmp34 = (spinlock_t *)__cil_tmp33;
#line 849
      tmp___8 = spinlock_check(__cil_tmp34);
#line 849
      irq_flags = _raw_spin_lock_irqsave(tmp___8);
      }
#line 849
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 849
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 851
  __cil_tmp35 = (void *)0;
#line 851
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 851
  __cil_tmp37 = (unsigned long )eaction;
#line 851
  __cil_tmp38 = __cil_tmp37 + 80;
#line 851
  __cil_tmp39 = *((uint32_t **)__cil_tmp38);
#line 851
  __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 851
  __cil_tmp41 = __cil_tmp40 != __cil_tmp36;
#line 851
  __cil_tmp42 = ! __cil_tmp41;
#line 851
  __cil_tmp43 = ! __cil_tmp42;
#line 851
  __cil_tmp44 = (long )__cil_tmp43;
#line 851
  tmp___9 = ldv__builtin_expect(__cil_tmp44, 1L);
  }
#line 851
  if (tmp___9) {
    {
#line 854
    do_gettimeofday(& tv);
#line 855
    __cil_tmp45 = (unsigned long )eaction;
#line 855
    __cil_tmp46 = __cil_tmp45 + 80;
#line 855
    __cil_tmp47 = *((uint32_t **)__cil_tmp46);
#line 855
    __cil_tmp48 = & tv;
#line 855
    __cil_tmp49 = *((__kernel_time_t *)__cil_tmp48);
#line 855
    *__cil_tmp47 = (uint32_t )__cil_tmp49;
#line 856
    __cil_tmp50 = (unsigned long )eaction;
#line 856
    __cil_tmp51 = __cil_tmp50 + 88;
#line 856
    __cil_tmp52 = *((uint32_t **)__cil_tmp51);
#line 856
    __cil_tmp53 = (unsigned long )(& tv) + 8;
#line 856
    __cil_tmp54 = *((__kernel_suseconds_t *)__cil_tmp53);
#line 856
    *__cil_tmp52 = (uint32_t )__cil_tmp54;
    }
  } else {

  }
  {
#line 859
  __cil_tmp55 = (unsigned long )eaction;
#line 859
  __cil_tmp56 = __cil_tmp55 + 40;
#line 859
  __cil_tmp57 = (struct list_head *)__cil_tmp56;
#line 859
  list_del_init(__cil_tmp57);
#line 860
  __cil_tmp58 = (unsigned long )eaction;
#line 860
  __cil_tmp59 = __cil_tmp58 + 56;
#line 860
  __cil_tmp60 = *((struct drm_pending_event **)__cil_tmp59);
#line 860
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 860
  __cil_tmp62 = __cil_tmp61 + 8;
#line 860
  __cil_tmp63 = (struct list_head *)__cil_tmp62;
#line 860
  __cil_tmp64 = (unsigned long )file_priv;
#line 860
  __cil_tmp65 = __cil_tmp64 + 216;
#line 860
  __cil_tmp66 = (struct list_head *)__cil_tmp65;
#line 860
  list_add_tail(__cil_tmp63, __cil_tmp66);
#line 861
  __cil_tmp67 = (unsigned long )eaction;
#line 861
  __cil_tmp68 = __cil_tmp67 + 56;
#line 861
  __cil_tmp69 = (void *)0;
#line 861
  *((struct drm_pending_event **)__cil_tmp68) = (struct drm_pending_event *)__cil_tmp69;
#line 862
  __cil_tmp70 = (unsigned long )file_priv;
#line 862
  __cil_tmp71 = __cil_tmp70 + 176;
#line 862
  __cil_tmp72 = (wait_queue_head_t *)__cil_tmp71;
#line 862
  __cil_tmp73 = (void *)0;
#line 862
  __wake_up(__cil_tmp72, 3U, 0, __cil_tmp73);
#line 863
  __cil_tmp74 = (unsigned long )dev;
#line 863
  __cil_tmp75 = __cil_tmp74 + 872;
#line 863
  __cil_tmp76 = (spinlock_t *)__cil_tmp75;
#line 863
  spin_unlock_irqrestore(__cil_tmp76, irq_flags);
  }
#line 864
  return;
}
}
#line 875 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
static void vmw_event_fence_action_cleanup(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action    *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_event_fence_action *__cil_tmp9 ;
  struct vmw_fence_action *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_fence_obj *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_fence_obj **__cil_tmp30 ;
  void    *__cil_tmp31 ;

  {
#line 878
  __mptr = (struct vmw_fence_action    *)action;
#line 878
  __cil_tmp9 = (struct vmw_event_fence_action *)0;
#line 878
  __cil_tmp10 = (struct vmw_fence_action *)__cil_tmp9;
#line 878
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 878
  __cil_tmp12 = (char *)__mptr;
#line 878
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 878
  eaction = (struct vmw_event_fence_action *)__cil_tmp13;
#line 879
  __cil_tmp14 = (unsigned long )eaction;
#line 879
  __cil_tmp15 = __cil_tmp14 + 64;
#line 879
  __cil_tmp16 = *((struct vmw_fence_obj **)__cil_tmp15);
#line 879
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 879
  __cil_tmp18 = __cil_tmp17 + 8;
#line 879
  fman = *((struct vmw_fence_manager **)__cil_tmp18);
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 882
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 882
      __cil_tmp19 = (unsigned long )fman;
#line 882
      __cil_tmp20 = __cil_tmp19 + 16;
#line 882
      __cil_tmp21 = (spinlock_t *)__cil_tmp20;
#line 882
      tmp___7 = spinlock_check(__cil_tmp21);
#line 882
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 882
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 882
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 883
  __cil_tmp22 = (unsigned long )eaction;
#line 883
  __cil_tmp23 = __cil_tmp22 + 40;
#line 883
  __cil_tmp24 = (struct list_head *)__cil_tmp23;
#line 883
  list_del(__cil_tmp24);
#line 884
  __cil_tmp25 = (unsigned long )fman;
#line 884
  __cil_tmp26 = __cil_tmp25 + 16;
#line 884
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
#line 884
  spin_unlock_irqrestore(__cil_tmp27, irq_flags);
#line 886
  __cil_tmp28 = (unsigned long )eaction;
#line 886
  __cil_tmp29 = __cil_tmp28 + 64;
#line 886
  __cil_tmp30 = (struct vmw_fence_obj **)__cil_tmp29;
#line 886
  vmw_fence_obj_unreference(__cil_tmp30);
#line 887
  __cil_tmp31 = (void    *)eaction;
#line 887
  kfree(__cil_tmp31);
  }
#line 888
  return;
}
}
#line 900 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
void vmw_fence_obj_add_action(struct vmw_fence_obj *fence , struct vmw_fence_action *action ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  bool run_update ;
  raw_spinlock_t *tmp___7 ;
  struct list_head action_list ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  enum vmw_action_type __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  enum vmw_action_type __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  spinlock_t *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  bool __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct vmw_private *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;

  {
  {
#line 903
  __cil_tmp10 = (unsigned long )fence;
#line 903
  __cil_tmp11 = __cil_tmp10 + 8;
#line 903
  fman = *((struct vmw_fence_manager **)__cil_tmp11);
#line 905
  run_update = (bool )0;
#line 907
  __cil_tmp12 = (unsigned long )fman;
#line 907
  __cil_tmp13 = __cil_tmp12 + 128;
#line 907
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
#line 907
  mutex_lock(__cil_tmp14);
  }
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 908
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 908
      __cil_tmp15 = (unsigned long )fman;
#line 908
      __cil_tmp16 = __cil_tmp15 + 16;
#line 908
      __cil_tmp17 = (spinlock_t *)__cil_tmp16;
#line 908
      tmp___7 = spinlock_check(__cil_tmp17);
#line 908
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 908
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 908
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  __cil_tmp18 = (unsigned long )action;
#line 910
  __cil_tmp19 = __cil_tmp18 + 16;
#line 910
  __cil_tmp20 = *((enum vmw_action_type *)__cil_tmp19);
#line 910
  __cil_tmp21 = __cil_tmp20 * 4UL;
#line 910
  __cil_tmp22 = 120 + __cil_tmp21;
#line 910
  __cil_tmp23 = (unsigned long )fman;
#line 910
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 910
  __cil_tmp25 = (unsigned long )action;
#line 910
  __cil_tmp26 = __cil_tmp25 + 16;
#line 910
  __cil_tmp27 = *((enum vmw_action_type *)__cil_tmp26);
#line 910
  __cil_tmp28 = __cil_tmp27 * 4UL;
#line 910
  __cil_tmp29 = 120 + __cil_tmp28;
#line 910
  __cil_tmp30 = (unsigned long )fman;
#line 910
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 910
  __cil_tmp32 = *((uint32_t *)__cil_tmp31);
#line 910
  *((uint32_t *)__cil_tmp24) = __cil_tmp32 + 1U;
  {
#line 911
  __cil_tmp33 = (unsigned long )fence;
#line 911
  __cil_tmp34 = __cil_tmp33 + 32;
#line 911
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 911
  if (__cil_tmp35 & 1U) {
    {
#line 914
    INIT_LIST_HEAD(& action_list);
#line 915
    __cil_tmp36 = (struct list_head *)action;
#line 915
    list_add_tail(__cil_tmp36, & action_list);
#line 916
    vmw_fences_perform_actions(fman, & action_list);
    }
  } else {
    {
#line 918
    __cil_tmp37 = (struct list_head *)action;
#line 918
    __cil_tmp38 = (unsigned long )fence;
#line 918
    __cil_tmp39 = __cil_tmp38 + 40;
#line 918
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
#line 918
    list_add_tail(__cil_tmp37, __cil_tmp40);
#line 924
    run_update = vmw_fence_goal_check_locked(fence);
    }
  }
  }
  {
#line 927
  __cil_tmp41 = (unsigned long )fman;
#line 927
  __cil_tmp42 = __cil_tmp41 + 16;
#line 927
  __cil_tmp43 = (spinlock_t *)__cil_tmp42;
#line 927
  spin_unlock_irqrestore(__cil_tmp43, irq_flags);
  }
#line 929
  if (run_update) {
    {
#line 930
    __cil_tmp44 = (unsigned long )fman;
#line 930
    __cil_tmp45 = __cil_tmp44 + 200;
#line 930
    __cil_tmp46 = *((bool *)__cil_tmp45);
#line 930
    if (! __cil_tmp46) {
      {
#line 931
      __cil_tmp47 = (unsigned long )fman;
#line 931
      __cil_tmp48 = __cil_tmp47 + 200;
#line 931
      *((bool *)__cil_tmp48) = (bool )1;
#line 932
      __cil_tmp49 = (unsigned long )fman;
#line 932
      __cil_tmp50 = __cil_tmp49 + 8;
#line 932
      __cil_tmp51 = *((struct vmw_private **)__cil_tmp50);
#line 932
      vmw_goal_waiter_add(__cil_tmp51);
      }
    } else {

    }
    }
    {
#line 934
    vmw_fences_update(fman);
    }
  } else {

  }
  {
#line 936
  __cil_tmp52 = (unsigned long )fman;
#line 936
  __cil_tmp53 = __cil_tmp52 + 128;
#line 936
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
#line 936
  mutex_unlock(__cil_tmp54);
  }
#line 938
  return;
}
}
#line 955 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_manager *fman ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___7 ;
  unsigned long irq_flags ;
  void *tmp___8 ;
  long tmp___9 ;
  raw_spinlock_t *tmp___10 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_private *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  spinlock_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  spinlock_t *__cil_tmp61 ;
  struct vmw_fence_action *__cil_tmp62 ;

  {
  {
#line 963
  __cil_tmp17 = (unsigned long )fence;
#line 963
  __cil_tmp18 = __cil_tmp17 + 8;
#line 963
  fman = *((struct vmw_fence_manager **)__cil_tmp18);
#line 964
  tmp___7 = vmw_fpriv(file_priv);
#line 964
  vmw_fp = tmp___7;
#line 967
  tmp___8 = kzalloc(96UL, 208U);
#line 967
  eaction = (struct vmw_event_fence_action *)tmp___8;
#line 968
  __cil_tmp19 = (void *)0;
#line 968
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 968
  __cil_tmp21 = (unsigned long )eaction;
#line 968
  __cil_tmp22 = __cil_tmp21 == __cil_tmp20;
#line 968
  __cil_tmp23 = ! __cil_tmp22;
#line 968
  __cil_tmp24 = ! __cil_tmp23;
#line 968
  __cil_tmp25 = (long )__cil_tmp24;
#line 968
  tmp___9 = ldv__builtin_expect(__cil_tmp25, 0L);
  }
#line 968
  if (tmp___9) {
#line 969
    return (-12);
  } else {

  }
  {
#line 971
  __cil_tmp26 = (unsigned long )eaction;
#line 971
  __cil_tmp27 = __cil_tmp26 + 56;
#line 971
  *((struct drm_pending_event **)__cil_tmp27) = event;
#line 973
  __cil_tmp28 = 0 + 24;
#line 973
  __cil_tmp29 = (unsigned long )eaction;
#line 973
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 973
  *((void (**)(struct vmw_fence_action *action ))__cil_tmp30) = & vmw_event_fence_action_seq_passed;
#line 974
  __cil_tmp31 = 0 + 32;
#line 974
  __cil_tmp32 = (unsigned long )eaction;
#line 974
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 974
  *((void (**)(struct vmw_fence_action *action ))__cil_tmp33) = & vmw_event_fence_action_cleanup;
#line 975
  __cil_tmp34 = 0 + 16;
#line 975
  __cil_tmp35 = (unsigned long )eaction;
#line 975
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
#line 975
  *((enum vmw_action_type *)__cil_tmp36) = (enum vmw_action_type )0;
#line 977
  __cil_tmp37 = (unsigned long )eaction;
#line 977
  __cil_tmp38 = __cil_tmp37 + 64;
#line 977
  *((struct vmw_fence_obj **)__cil_tmp38) = vmw_fence_obj_reference(fence);
#line 978
  __cil_tmp39 = (unsigned long )eaction;
#line 978
  __cil_tmp40 = __cil_tmp39 + 72;
#line 978
  __cil_tmp41 = (unsigned long )fman;
#line 978
  __cil_tmp42 = __cil_tmp41 + 8;
#line 978
  __cil_tmp43 = *((struct vmw_private **)__cil_tmp42);
#line 978
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 978
  __cil_tmp45 = __cil_tmp44 + 2088;
#line 978
  *((struct drm_device **)__cil_tmp40) = *((struct drm_device **)__cil_tmp45);
#line 979
  __cil_tmp46 = (unsigned long )eaction;
#line 979
  __cil_tmp47 = __cil_tmp46 + 80;
#line 979
  *((uint32_t **)__cil_tmp47) = tv_sec;
#line 980
  __cil_tmp48 = (unsigned long )eaction;
#line 980
  __cil_tmp49 = __cil_tmp48 + 88;
#line 980
  *((uint32_t **)__cil_tmp49) = tv_usec;
  }
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 982
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 982
      __cil_tmp50 = (unsigned long )fman;
#line 982
      __cil_tmp51 = __cil_tmp50 + 16;
#line 982
      __cil_tmp52 = (spinlock_t *)__cil_tmp51;
#line 982
      tmp___10 = spinlock_check(__cil_tmp52);
#line 982
      irq_flags = _raw_spin_lock_irqsave(tmp___10);
      }
#line 982
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 982
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 983
  __cil_tmp53 = (unsigned long )eaction;
#line 983
  __cil_tmp54 = __cil_tmp53 + 40;
#line 983
  __cil_tmp55 = (struct list_head *)__cil_tmp54;
#line 983
  __cil_tmp56 = (unsigned long )vmw_fp;
#line 983
  __cil_tmp57 = __cil_tmp56 + 16;
#line 983
  __cil_tmp58 = (struct list_head *)__cil_tmp57;
#line 983
  list_add_tail(__cil_tmp55, __cil_tmp58);
#line 984
  __cil_tmp59 = (unsigned long )fman;
#line 984
  __cil_tmp60 = __cil_tmp59 + 16;
#line 984
  __cil_tmp61 = (spinlock_t *)__cil_tmp60;
#line 984
  spin_unlock_irqrestore(__cil_tmp61, irq_flags);
#line 986
  __cil_tmp62 = (struct vmw_fence_action *)eaction;
#line 986
  vmw_fence_obj_add_action(fence, __cil_tmp62);
  }
#line 988
  return (0);
}
}
#line 996 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_event_fence_action_create(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                  uint32_t flags , uint64_t user_data , bool interruptible ) 
{ struct vmw_event_fence_pending *event ;
  struct drm_device *dev ;
  unsigned long irq_flags ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  raw_spinlock_t *tmp___12 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_fence_manager *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_private *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  spinlock_t *__cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  long __cil_tmp52 ;
  void *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct drm_pending_event *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  uint32_t *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  uint32_t *__cil_tmp85 ;
  struct drm_pending_event *__cil_tmp86 ;
  void *__cil_tmp87 ;
  uint32_t *__cil_tmp88 ;
  void *__cil_tmp89 ;
  uint32_t *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  void (*__cil_tmp94)(struct drm_pending_event *event ) ;
  struct drm_pending_event *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  spinlock_t *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  int __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  spinlock_t *__cil_tmp108 ;

  {
#line 1003
  __cil_tmp20 = (unsigned long )fence;
#line 1003
  __cil_tmp21 = __cil_tmp20 + 8;
#line 1003
  __cil_tmp22 = *((struct vmw_fence_manager **)__cil_tmp21);
#line 1003
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1003
  __cil_tmp24 = __cil_tmp23 + 8;
#line 1003
  __cil_tmp25 = *((struct vmw_private **)__cil_tmp24);
#line 1003
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 1003
  __cil_tmp27 = __cil_tmp26 + 2088;
#line 1003
  dev = *((struct drm_device **)__cil_tmp27);
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1007
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1007
      __cil_tmp28 = (unsigned long )dev;
#line 1007
      __cil_tmp29 = __cil_tmp28 + 872;
#line 1007
      __cil_tmp30 = (spinlock_t *)__cil_tmp29;
#line 1007
      tmp___7 = spinlock_check(__cil_tmp30);
#line 1007
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 1007
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1007
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1009
  __cil_tmp31 = (unsigned long )file_priv;
#line 1009
  __cil_tmp32 = __cil_tmp31 + 232;
#line 1009
  __cil_tmp33 = *((int *)__cil_tmp32);
#line 1009
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 1009
  if (__cil_tmp34 < 24UL) {
#line 1009
    ret = -16;
  } else {
#line 1009
    ret = 0;
  }
  }
  {
#line 1010
  __cil_tmp35 = ret == 0;
#line 1010
  __cil_tmp36 = ! __cil_tmp35;
#line 1010
  __cil_tmp37 = ! __cil_tmp36;
#line 1010
  __cil_tmp38 = (long )__cil_tmp37;
#line 1010
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 1L);
  }
#line 1010
  if (tmp___8) {
#line 1011
    __cil_tmp39 = (unsigned long )file_priv;
#line 1011
    __cil_tmp40 = __cil_tmp39 + 232;
#line 1011
    __cil_tmp41 = (unsigned long )file_priv;
#line 1011
    __cil_tmp42 = __cil_tmp41 + 232;
#line 1011
    __cil_tmp43 = *((int *)__cil_tmp42);
#line 1011
    __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 1011
    __cil_tmp45 = __cil_tmp44 - 24UL;
#line 1011
    *((int *)__cil_tmp40) = (int )__cil_tmp45;
  } else {

  }
  {
#line 1013
  __cil_tmp46 = (unsigned long )dev;
#line 1013
  __cil_tmp47 = __cil_tmp46 + 872;
#line 1013
  __cil_tmp48 = (spinlock_t *)__cil_tmp47;
#line 1013
  spin_unlock_irqrestore(__cil_tmp48, irq_flags);
#line 1015
  __cil_tmp49 = ret != 0;
#line 1015
  __cil_tmp50 = ! __cil_tmp49;
#line 1015
  __cil_tmp51 = ! __cil_tmp50;
#line 1015
  __cil_tmp52 = (long )__cil_tmp51;
#line 1015
  tmp___9 = ldv__builtin_expect(__cil_tmp52, 0L);
  }
#line 1015
  if (tmp___9) {
    {
#line 1016
    drm_err("vmw_event_fence_action_create", "Failed to allocate event space for this file.\n");
    }
#line 1017
    goto out_no_space;
  } else {

  }
  {
#line 1021
  tmp___10 = kzalloc(24UL, 208U);
#line 1021
  event = (struct vmw_event_fence_pending *)tmp___10;
#line 1022
  __cil_tmp53 = (void *)0;
#line 1022
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 1022
  __cil_tmp55 = (unsigned long )event;
#line 1022
  __cil_tmp56 = __cil_tmp55 == __cil_tmp54;
#line 1022
  __cil_tmp57 = ! __cil_tmp56;
#line 1022
  __cil_tmp58 = ! __cil_tmp57;
#line 1022
  __cil_tmp59 = (long )__cil_tmp58;
#line 1022
  tmp___11 = ldv__builtin_expect(__cil_tmp59, 0L);
  }
#line 1022
  if (tmp___11) {
    {
#line 1023
    drm_err("vmw_event_fence_action_create", "Failed to allocate an event.\n");
#line 1024
    ret = -12;
    }
#line 1025
    goto out_no_event;
  } else {

  }
#line 1028
  __cil_tmp60 = (unsigned long )event;
#line 1028
  __cil_tmp61 = __cil_tmp60 + 48;
#line 1028
  *((__u32 *)__cil_tmp61) = (__u32 )(-0x7FFFFFFF-1);
#line 1029
  __cil_tmp62 = 0 + 4;
#line 1029
  __cil_tmp63 = 48 + __cil_tmp62;
#line 1029
  __cil_tmp64 = (unsigned long )event;
#line 1029
  __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
#line 1029
  *((__u32 *)__cil_tmp65) = (__u32 )72UL;
#line 1030
  __cil_tmp66 = 48 + 8;
#line 1030
  __cil_tmp67 = (unsigned long )event;
#line 1030
  __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
#line 1030
  *((uint64_t *)__cil_tmp68) = user_data;
#line 1032
  __cil_tmp69 = (unsigned long )event;
#line 1032
  __cil_tmp70 = __cil_tmp69 + 48;
#line 1032
  *((struct drm_event **)event) = (struct drm_event *)__cil_tmp70;
#line 1033
  __cil_tmp71 = 0 + 24;
#line 1033
  __cil_tmp72 = (unsigned long )event;
#line 1033
  __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
#line 1033
  *((struct drm_file **)__cil_tmp73) = file_priv;
#line 1034
  __cil_tmp74 = 0 + 40;
#line 1034
  __cil_tmp75 = (unsigned long )event;
#line 1034
  __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
#line 1034
  *((void (**)(struct drm_pending_event *event ))__cil_tmp76) = (void (*)(struct drm_pending_event * ))(& kfree);
#line 1037
  if (flags & 1U) {
    {
#line 1038
    __cil_tmp77 = (struct drm_pending_event *)event;
#line 1038
    __cil_tmp78 = 48 + 16;
#line 1038
    __cil_tmp79 = (unsigned long )event;
#line 1038
    __cil_tmp80 = __cil_tmp79 + __cil_tmp78;
#line 1038
    __cil_tmp81 = (uint32_t *)__cil_tmp80;
#line 1038
    __cil_tmp82 = 48 + 20;
#line 1038
    __cil_tmp83 = (unsigned long )event;
#line 1038
    __cil_tmp84 = __cil_tmp83 + __cil_tmp82;
#line 1038
    __cil_tmp85 = (uint32_t *)__cil_tmp84;
#line 1038
    ret = vmw_event_fence_action_queue(file_priv, fence, __cil_tmp77, __cil_tmp81,
                                       __cil_tmp85, interruptible);
    }
  } else {
    {
#line 1044
    __cil_tmp86 = (struct drm_pending_event *)event;
#line 1044
    __cil_tmp87 = (void *)0;
#line 1044
    __cil_tmp88 = (uint32_t *)__cil_tmp87;
#line 1044
    __cil_tmp89 = (void *)0;
#line 1044
    __cil_tmp90 = (uint32_t *)__cil_tmp89;
#line 1044
    ret = vmw_event_fence_action_queue(file_priv, fence, __cil_tmp86, __cil_tmp88,
                                       __cil_tmp90, interruptible);
    }
  }
#line 1049
  if (ret != 0) {
#line 1050
    goto out_no_queue;
  } else {

  }
  out_no_queue: 
  {
#line 1053
  __cil_tmp91 = 0 + 40;
#line 1053
  __cil_tmp92 = (unsigned long )event;
#line 1053
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
#line 1053
  __cil_tmp94 = *((void (**)(struct drm_pending_event *event ))__cil_tmp93);
#line 1053
  __cil_tmp95 = (struct drm_pending_event *)event;
#line 1053
  (*__cil_tmp94)(__cil_tmp95);
  }
  out_no_event: 
  {
#line 1055
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1055
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1055
      __cil_tmp96 = (unsigned long )dev;
#line 1055
      __cil_tmp97 = __cil_tmp96 + 872;
#line 1055
      __cil_tmp98 = (spinlock_t *)__cil_tmp97;
#line 1055
      tmp___12 = spinlock_check(__cil_tmp98);
#line 1055
      irq_flags = _raw_spin_lock_irqsave(tmp___12);
      }
#line 1055
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1055
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1056
  __cil_tmp99 = (unsigned long )file_priv;
#line 1056
  __cil_tmp100 = __cil_tmp99 + 232;
#line 1056
  __cil_tmp101 = (unsigned long )file_priv;
#line 1056
  __cil_tmp102 = __cil_tmp101 + 232;
#line 1056
  __cil_tmp103 = *((int *)__cil_tmp102);
#line 1056
  __cil_tmp104 = (unsigned long )__cil_tmp103;
#line 1056
  __cil_tmp105 = __cil_tmp104 + 72UL;
#line 1056
  *((int *)__cil_tmp100) = (int )__cil_tmp105;
#line 1057
  __cil_tmp106 = (unsigned long )dev;
#line 1057
  __cil_tmp107 = __cil_tmp106 + 872;
#line 1057
  __cil_tmp108 = (spinlock_t *)__cil_tmp107;
#line 1057
  spin_unlock_irqrestore(__cil_tmp108, irq_flags);
  }
  out_no_space: 
#line 1059
  return (ret);
}
}
#line 1062 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_fence_event_arg *arg ;
  struct vmw_fence_obj *fence ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  uint32_t handle ;
  int ret ;
  struct ttm_base_object *base ;
  struct ttm_base_object *tmp___9 ;
  long tmp___10 ;
  struct ttm_base_object    *__mptr ;
  bool existed ;
  long tmp___11 ;
  uint32_t *tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  struct vmw_fpriv *tmp___16 ;
  struct vmw_fence_obj **__cil_tmp24 ;
  void *__cil_tmp25 ;
  uint64_t __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_object_file *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  struct ttm_base_object **__cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_base_object **__cil_tmp39 ;
  struct ttm_base_object *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_base_object **__cil_tmp50 ;
  struct ttm_base_object *__cil_tmp51 ;
  struct vmw_fence_obj **__cil_tmp52 ;
  struct vmw_user_fence *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  struct vmw_user_fence *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct vmw_fence_obj **__cil_tmp61 ;
  struct vmw_fence_obj *__cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct ttm_object_file *__cil_tmp68 ;
  struct ttm_base_object **__cil_tmp69 ;
  struct ttm_base_object *__cil_tmp70 ;
  enum ttm_ref_type __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  long __cil_tmp75 ;
  uint32_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct ttm_base_object **__cil_tmp78 ;
  struct ttm_base_object *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct vmw_fence_obj **__cil_tmp83 ;
  struct vmw_fence_obj *__cil_tmp84 ;
  void *__cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  long __cil_tmp89 ;
  void *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct vmw_fence_obj **__cil_tmp92 ;
  struct vmw_fence_obj *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  uint32_t __cil_tmp101 ;
  struct vmw_fence_obj **__cil_tmp102 ;
  struct vmw_fence_obj *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  uint32_t __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  uint64_t __cil_tmp109 ;
  bool __cil_tmp110 ;
  struct vmw_fence_obj **__cil_tmp111 ;
  struct vmw_fence_obj *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  uint32_t __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  uint64_t __cil_tmp118 ;
  bool __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  long __cil_tmp123 ;
  struct vmw_fence_obj **__cil_tmp124 ;
  struct vmw_fence_obj *__cil_tmp125 ;
  uint32_t *__cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  struct ttm_object_file *__cil_tmp133 ;
  uint32_t *__cil_tmp134 ;
  uint32_t __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  enum ttm_ref_type __cil_tmp137 ;

  {
  {
#line 1065
  tmp___7 = vmw_priv(dev);
#line 1065
  dev_priv = tmp___7;
#line 1066
  arg = (struct drm_vmw_fence_event_arg *)data;
#line 1068
  __cil_tmp24 = & fence;
#line 1068
  __cil_tmp25 = (void *)0;
#line 1068
  *__cil_tmp24 = (struct vmw_fence_obj *)__cil_tmp25;
#line 1069
  tmp___8 = vmw_fpriv(file_priv);
#line 1069
  vmw_fp = tmp___8;
#line 1070
  __cil_tmp26 = *((uint64_t *)arg);
#line 1070
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 1070
  user_fence_rep = (struct drm_vmw_fence_rep *)__cil_tmp27;
  }
  {
#line 1081
  __cil_tmp28 = (unsigned long )arg;
#line 1081
  __cil_tmp29 = __cil_tmp28 + 16;
#line 1081
  if (*((uint32_t *)__cil_tmp29)) {
    {
#line 1082
    __cil_tmp30 = (unsigned long )vmw_fp;
#line 1082
    __cil_tmp31 = __cil_tmp30 + 8;
#line 1082
    __cil_tmp32 = *((struct ttm_object_file **)__cil_tmp31);
#line 1082
    __cil_tmp33 = (unsigned long )arg;
#line 1082
    __cil_tmp34 = __cil_tmp33 + 16;
#line 1082
    __cil_tmp35 = *((uint32_t *)__cil_tmp34);
#line 1082
    tmp___9 = ttm_base_object_lookup(__cil_tmp32, __cil_tmp35);
#line 1082
    __cil_tmp36 = & base;
#line 1082
    *__cil_tmp36 = tmp___9;
#line 1085
    __cil_tmp37 = (void *)0;
#line 1085
    __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 1085
    __cil_tmp39 = & base;
#line 1085
    __cil_tmp40 = *__cil_tmp39;
#line 1085
    __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 1085
    __cil_tmp42 = __cil_tmp41 == __cil_tmp38;
#line 1085
    __cil_tmp43 = ! __cil_tmp42;
#line 1085
    __cil_tmp44 = ! __cil_tmp43;
#line 1085
    __cil_tmp45 = (long )__cil_tmp44;
#line 1085
    tmp___10 = ldv__builtin_expect(__cil_tmp45, 0L);
    }
#line 1085
    if (tmp___10) {
      {
#line 1086
      __cil_tmp46 = (unsigned long )arg;
#line 1086
      __cil_tmp47 = __cil_tmp46 + 16;
#line 1086
      __cil_tmp48 = *((uint32_t *)__cil_tmp47);
#line 1086
      __cil_tmp49 = (unsigned long )__cil_tmp48;
#line 1086
      drm_err("vmw_fence_event_ioctl", "Fence event invalid fence object handle 0x%08lx.\n",
              __cil_tmp49);
      }
#line 1089
      return (-22);
    } else {

    }
    {
#line 1091
    __cil_tmp50 = & base;
#line 1091
    __cil_tmp51 = *__cil_tmp50;
#line 1091
    __mptr = (struct ttm_base_object    *)__cil_tmp51;
#line 1091
    __cil_tmp52 = & fence;
#line 1091
    __cil_tmp53 = (struct vmw_user_fence *)0;
#line 1091
    __cil_tmp54 = (struct ttm_base_object *)__cil_tmp53;
#line 1091
    __cil_tmp55 = (unsigned int )__cil_tmp54;
#line 1091
    __cil_tmp56 = (char *)__mptr;
#line 1091
    __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
#line 1091
    __cil_tmp58 = (struct vmw_user_fence *)__cil_tmp57;
#line 1091
    __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1091
    __cil_tmp60 = __cil_tmp59 + 64;
#line 1091
    *__cil_tmp52 = (struct vmw_fence_obj *)__cil_tmp60;
#line 1093
    __cil_tmp61 = & fence;
#line 1093
    __cil_tmp62 = *__cil_tmp61;
#line 1093
    vmw_fence_obj_reference(__cil_tmp62);
    }
    {
#line 1095
    __cil_tmp63 = (void *)0;
#line 1095
    __cil_tmp64 = (unsigned long )__cil_tmp63;
#line 1095
    __cil_tmp65 = (unsigned long )user_fence_rep;
#line 1095
    if (__cil_tmp65 != __cil_tmp64) {
      {
#line 1098
      __cil_tmp66 = (unsigned long )vmw_fp;
#line 1098
      __cil_tmp67 = __cil_tmp66 + 8;
#line 1098
      __cil_tmp68 = *((struct ttm_object_file **)__cil_tmp67);
#line 1098
      __cil_tmp69 = & base;
#line 1098
      __cil_tmp70 = *__cil_tmp69;
#line 1098
      __cil_tmp71 = (enum ttm_ref_type )0;
#line 1098
      ret = ttm_ref_object_add(__cil_tmp68, __cil_tmp70, __cil_tmp71, & existed);
#line 1100
      __cil_tmp72 = ret != 0;
#line 1100
      __cil_tmp73 = ! __cil_tmp72;
#line 1100
      __cil_tmp74 = ! __cil_tmp73;
#line 1100
      __cil_tmp75 = (long )__cil_tmp74;
#line 1100
      tmp___11 = ldv__builtin_expect(__cil_tmp75, 0L);
      }
#line 1100
      if (tmp___11) {
        {
#line 1101
        drm_err("vmw_fence_event_ioctl", "Failed to reference a fence object.\n");
        }
#line 1103
        goto out_no_ref_obj;
      } else {

      }
#line 1105
      __cil_tmp76 = & handle;
#line 1105
      __cil_tmp77 = 0 + 16;
#line 1105
      __cil_tmp78 = & base;
#line 1105
      __cil_tmp79 = *__cil_tmp78;
#line 1105
      __cil_tmp80 = (unsigned long )__cil_tmp79;
#line 1105
      __cil_tmp81 = __cil_tmp80 + __cil_tmp77;
#line 1105
      __cil_tmp82 = *((unsigned long *)__cil_tmp81);
#line 1105
      *__cil_tmp76 = (uint32_t )__cil_tmp82;
    } else {

    }
    }
    {
#line 1107
    ttm_base_object_unref(& base);
    }
  } else {

  }
  }
  {
#line 1113
  __cil_tmp83 = & fence;
#line 1113
  __cil_tmp84 = *__cil_tmp83;
#line 1113
  if (! __cil_tmp84) {
#line 1114
    if (user_fence_rep) {
#line 1114
      tmp___12 = & handle;
    } else {
#line 1114
      __cil_tmp85 = (void *)0;
#line 1114
      tmp___12 = (uint32_t *)__cil_tmp85;
    }
    {
#line 1114
    ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___12);
#line 1118
    __cil_tmp86 = ret != 0;
#line 1118
    __cil_tmp87 = ! __cil_tmp86;
#line 1118
    __cil_tmp88 = ! __cil_tmp87;
#line 1118
    __cil_tmp89 = (long )__cil_tmp88;
#line 1118
    tmp___13 = ldv__builtin_expect(__cil_tmp89, 0L);
    }
#line 1118
    if (tmp___13) {
      {
#line 1119
      drm_err("vmw_fence_event_ioctl", "Fence event failed to create fence.\n");
      }
#line 1120
      return (ret);
    } else {

    }
  } else {

  }
  }
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1124
    __cil_tmp90 = (void *)0;
#line 1124
    __cil_tmp91 = (unsigned long )__cil_tmp90;
#line 1124
    __cil_tmp92 = & fence;
#line 1124
    __cil_tmp93 = *__cil_tmp92;
#line 1124
    __cil_tmp94 = (unsigned long )__cil_tmp93;
#line 1124
    __cil_tmp95 = __cil_tmp94 == __cil_tmp91;
#line 1124
    __cil_tmp96 = ! __cil_tmp95;
#line 1124
    __cil_tmp97 = ! __cil_tmp96;
#line 1124
    __cil_tmp98 = (long )__cil_tmp97;
#line 1124
    tmp___14 = ldv__builtin_expect(__cil_tmp98, 0L);
    }
#line 1124
    if (tmp___14) {
      {
#line 1124
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1124
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (1124), "i" (12UL));
        {
#line 1124
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1124
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 1124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1126
  __cil_tmp99 = (unsigned long )arg;
#line 1126
  __cil_tmp100 = __cil_tmp99 + 20;
#line 1126
  __cil_tmp101 = *((uint32_t *)__cil_tmp100);
#line 1126
  if (__cil_tmp101 & 1U) {
    {
#line 1127
    __cil_tmp102 = & fence;
#line 1127
    __cil_tmp103 = *__cil_tmp102;
#line 1127
    __cil_tmp104 = (unsigned long )arg;
#line 1127
    __cil_tmp105 = __cil_tmp104 + 20;
#line 1127
    __cil_tmp106 = *((uint32_t *)__cil_tmp105);
#line 1127
    __cil_tmp107 = (unsigned long )arg;
#line 1127
    __cil_tmp108 = __cil_tmp107 + 8;
#line 1127
    __cil_tmp109 = *((uint64_t *)__cil_tmp108);
#line 1127
    __cil_tmp110 = (bool )1;
#line 1127
    ret = vmw_event_fence_action_create(file_priv, __cil_tmp103, __cil_tmp106, __cil_tmp109,
                                        __cil_tmp110);
    }
  } else {
    {
#line 1132
    __cil_tmp111 = & fence;
#line 1132
    __cil_tmp112 = *__cil_tmp111;
#line 1132
    __cil_tmp113 = (unsigned long )arg;
#line 1132
    __cil_tmp114 = __cil_tmp113 + 20;
#line 1132
    __cil_tmp115 = *((uint32_t *)__cil_tmp114);
#line 1132
    __cil_tmp116 = (unsigned long )arg;
#line 1132
    __cil_tmp117 = __cil_tmp116 + 8;
#line 1132
    __cil_tmp118 = *((uint64_t *)__cil_tmp117);
#line 1132
    __cil_tmp119 = (bool )1;
#line 1132
    ret = vmw_event_fence_action_create(file_priv, __cil_tmp112, __cil_tmp115, __cil_tmp118,
                                        __cil_tmp119);
    }
  }
  }
  {
#line 1137
  __cil_tmp120 = ret != 0;
#line 1137
  __cil_tmp121 = ! __cil_tmp120;
#line 1137
  __cil_tmp122 = ! __cil_tmp121;
#line 1137
  __cil_tmp123 = (long )__cil_tmp122;
#line 1137
  tmp___15 = ldv__builtin_expect(__cil_tmp123, 0L);
  }
#line 1137
  if (tmp___15) {
#line 1138
    if (ret != -512) {
      {
#line 1139
      drm_err("vmw_fence_event_ioctl", "Failed to attach event to fence.\n");
      }
    } else {

    }
#line 1140
    goto out_no_create;
  } else {

  }
  {
#line 1143
  __cil_tmp124 = & fence;
#line 1143
  __cil_tmp125 = *__cil_tmp124;
#line 1143
  __cil_tmp126 = & handle;
#line 1143
  __cil_tmp127 = *__cil_tmp126;
#line 1143
  vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, __cil_tmp125, __cil_tmp127);
#line 1145
  vmw_fence_obj_unreference(& fence);
  }
#line 1146
  return (0);
  out_no_create: 
  {
#line 1148
  __cil_tmp128 = (void *)0;
#line 1148
  __cil_tmp129 = (unsigned long )__cil_tmp128;
#line 1148
  __cil_tmp130 = (unsigned long )user_fence_rep;
#line 1148
  if (__cil_tmp130 != __cil_tmp129) {
    {
#line 1149
    tmp___16 = vmw_fpriv(file_priv);
#line 1149
    __cil_tmp131 = (unsigned long )tmp___16;
#line 1149
    __cil_tmp132 = __cil_tmp131 + 8;
#line 1149
    __cil_tmp133 = *((struct ttm_object_file **)__cil_tmp132);
#line 1149
    __cil_tmp134 = & handle;
#line 1149
    __cil_tmp135 = *__cil_tmp134;
#line 1149
    __cil_tmp136 = (unsigned long )__cil_tmp135;
#line 1149
    __cil_tmp137 = (enum ttm_ref_type )0;
#line 1149
    ttm_ref_object_base_unref(__cil_tmp133, __cil_tmp136, __cil_tmp137);
    }
  } else {

  }
  }
  out_no_ref_obj: 
  {
#line 1152
  vmw_fence_obj_unreference(& fence);
  }
#line 1153
  return (ret);
}
}
#line 448 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) ;
#line 50 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_lock *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  bool __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  bool __cil_tmp19 ;
  bool __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  bool __cil_tmp26 ;
  bool __cil_tmp27 ;
  struct ttm_lock *__cil_tmp28 ;

  {
  {
#line 55
  __cil_tmp10 = (unsigned long )dev_priv;
#line 55
  __cil_tmp11 = __cil_tmp10 + 134384;
#line 55
  vmaster = *((struct vmw_master **)__cil_tmp11);
#line 56
  bo = (struct ttm_buffer_object *)buf;
#line 59
  __cil_tmp12 = (struct ttm_lock *)vmaster;
#line 59
  ret = ttm_write_lock(__cil_tmp12, interruptible);
#line 60
  __cil_tmp13 = ret != 0;
#line 60
  __cil_tmp14 = ! __cil_tmp13;
#line 60
  __cil_tmp15 = ! __cil_tmp14;
#line 60
  __cil_tmp16 = (long )__cil_tmp15;
#line 60
  tmp___7 = ldv__builtin_expect(__cil_tmp16, 0L);
  }
#line 60
  if (tmp___7) {
#line 61
    return (ret);
  } else {

  }
  {
#line 63
  __cil_tmp17 = (bool )0;
#line 63
  __cil_tmp18 = (uint32_t )0;
#line 63
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp17, __cil_tmp18);
#line 65
  __cil_tmp19 = (bool )0;
#line 65
  __cil_tmp20 = (bool )0;
#line 65
  __cil_tmp21 = (uint32_t )0;
#line 65
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp19, __cil_tmp20, __cil_tmp21);
#line 66
  __cil_tmp22 = ret != 0;
#line 66
  __cil_tmp23 = ! __cil_tmp22;
#line 66
  __cil_tmp24 = ! __cil_tmp23;
#line 66
  __cil_tmp25 = (long )__cil_tmp24;
#line 66
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 0L);
  }
#line 66
  if (tmp___8) {
#line 67
    goto err;
  } else {

  }
  {
#line 69
  __cil_tmp26 = (bool )0;
#line 69
  __cil_tmp27 = (bool )0;
#line 69
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp26, __cil_tmp27);
#line 71
  ttm_bo_unreserve(bo);
  }
  err: 
  {
#line 74
  __cil_tmp28 = (struct ttm_lock *)vmaster;
#line 74
  ttm_write_unlock(__cil_tmp28);
  }
#line 75
  return (ret);
}
}
#line 94 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement *placement ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct ttm_lock *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  bool __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  bool __cil_tmp21 ;
  bool __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  bool __cil_tmp28 ;
  bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  bool __cil_tmp34 ;
  bool __cil_tmp35 ;
  struct ttm_lock *__cil_tmp36 ;

  {
  {
#line 98
  __cil_tmp12 = (unsigned long )dev_priv;
#line 98
  __cil_tmp13 = __cil_tmp12 + 134384;
#line 98
  vmaster = *((struct vmw_master **)__cil_tmp13);
#line 99
  bo = (struct ttm_buffer_object *)buf;
#line 103
  __cil_tmp14 = (struct ttm_lock *)vmaster;
#line 103
  ret = ttm_write_lock(__cil_tmp14, interruptible);
#line 104
  __cil_tmp15 = ret != 0;
#line 104
  __cil_tmp16 = ! __cil_tmp15;
#line 104
  __cil_tmp17 = ! __cil_tmp16;
#line 104
  __cil_tmp18 = (long )__cil_tmp17;
#line 104
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  }
#line 104
  if (tmp___7) {
#line 105
    return (ret);
  } else {

  }
#line 107
  if (pin) {
    {
#line 108
    __cil_tmp19 = (bool )0;
#line 108
    __cil_tmp20 = (uint32_t )0;
#line 108
    vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp19, __cil_tmp20);
    }
  } else {

  }
  {
#line 110
  __cil_tmp21 = (bool )0;
#line 110
  __cil_tmp22 = (bool )0;
#line 110
  __cil_tmp23 = (uint32_t )0;
#line 110
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp21, __cil_tmp22, __cil_tmp23);
#line 111
  __cil_tmp24 = ret != 0;
#line 111
  __cil_tmp25 = ! __cil_tmp24;
#line 111
  __cil_tmp26 = ! __cil_tmp25;
#line 111
  __cil_tmp27 = (long )__cil_tmp26;
#line 111
  tmp___8 = ldv__builtin_expect(__cil_tmp27, 0L);
  }
#line 111
  if (tmp___8) {
#line 112
    goto err;
  } else {

  }
#line 121
  if (pin) {
#line 122
    placement = & vmw_vram_gmr_ne_placement;
  } else {
#line 124
    placement = & vmw_vram_gmr_placement;
  }
  {
#line 126
  __cil_tmp28 = (bool )0;
#line 126
  __cil_tmp29 = (bool )0;
#line 126
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp28, __cil_tmp29);
#line 127
  __cil_tmp30 = ret == 0;
#line 127
  __cil_tmp31 = ! __cil_tmp30;
#line 127
  __cil_tmp32 = ! __cil_tmp31;
#line 127
  __cil_tmp33 = (long )__cil_tmp32;
#line 127
  tmp___9 = ldv__builtin_expect(__cil_tmp33, 1L);
  }
#line 127
  if (tmp___9) {
#line 128
    goto err_unreserve;
  } else
#line 127
  if (ret == -512) {
#line 128
    goto err_unreserve;
  } else {

  }
#line 136
  if (pin) {
#line 137
    placement = & vmw_vram_ne_placement;
  } else {
#line 139
    placement = & vmw_vram_placement;
  }
  {
#line 141
  __cil_tmp34 = (bool )0;
#line 141
  __cil_tmp35 = (bool )0;
#line 141
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp34, __cil_tmp35);
  }
  err_unreserve: 
  {
#line 144
  ttm_bo_unreserve(bo);
  }
  err: 
  {
#line 146
  __cil_tmp36 = (struct ttm_lock *)vmaster;
#line 146
  ttm_write_unlock(__cil_tmp36);
  }
#line 147
  return (ret);
}
}
#line 165 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) 
{ struct ttm_placement *placement ;
  int tmp___7 ;

  {
#line 171
  if (pin) {
#line 172
    placement = & vmw_vram_ne_placement;
  } else {
#line 174
    placement = & vmw_vram_placement;
  }
  {
#line 176
  tmp___7 = vmw_dmabuf_to_placement(dev_priv, buf, placement, interruptible);
  }
#line 176
  return (tmp___7);
}
}
#line 197 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement placement ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  int __ret_warn_on ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_placement *__cil_tmp16 ;
  struct ttm_placement *__cil_tmp17 ;
  struct ttm_placement *__cil_tmp18 ;
  struct ttm_placement *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct ttm_lock *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  bool __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  bool __cil_tmp31 ;
  bool __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  bool __cil_tmp53 ;
  bool __cil_tmp54 ;
  bool __cil_tmp55 ;
  bool __cil_tmp56 ;
  bool __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  int    __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  long __cil_tmp67 ;
  struct ttm_lock *__cil_tmp68 ;

  {
#line 201
  __cil_tmp14 = (unsigned long )dev_priv;
#line 201
  __cil_tmp15 = __cil_tmp14 + 134384;
#line 201
  vmaster = *((struct vmw_master **)__cil_tmp15);
#line 202
  bo = (struct ttm_buffer_object *)buf;
#line 204
  ret = 0;
#line 206
  if (pin) {
#line 207
    __cil_tmp16 = & placement;
#line 207
    __cil_tmp17 = & vmw_vram_ne_placement;
#line 207
    *__cil_tmp16 = *__cil_tmp17;
  } else {
#line 209
    __cil_tmp18 = & placement;
#line 209
    __cil_tmp19 = & vmw_vram_placement;
#line 209
    *__cil_tmp18 = *__cil_tmp19;
  }
  {
#line 210
  __cil_tmp20 = (unsigned long )(& placement) + 4;
#line 210
  __cil_tmp21 = (unsigned long )bo;
#line 210
  __cil_tmp22 = __cil_tmp21 + 40;
#line 210
  __cil_tmp23 = *((unsigned long *)__cil_tmp22);
#line 210
  *((unsigned int *)__cil_tmp20) = (unsigned int )__cil_tmp23;
#line 212
  __cil_tmp24 = (struct ttm_lock *)vmaster;
#line 212
  ret = ttm_write_lock(__cil_tmp24, interruptible);
#line 213
  __cil_tmp25 = ret != 0;
#line 213
  __cil_tmp26 = ! __cil_tmp25;
#line 213
  __cil_tmp27 = ! __cil_tmp26;
#line 213
  __cil_tmp28 = (long )__cil_tmp27;
#line 213
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 213
  if (tmp___7) {
#line 214
    return (ret);
  } else {

  }
#line 216
  if (pin) {
    {
#line 217
    __cil_tmp29 = (bool )0;
#line 217
    __cil_tmp30 = (uint32_t )0;
#line 217
    vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp29, __cil_tmp30);
    }
  } else {

  }
  {
#line 219
  __cil_tmp31 = (bool )0;
#line 219
  __cil_tmp32 = (bool )0;
#line 219
  __cil_tmp33 = (uint32_t )0;
#line 219
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp31, __cil_tmp32, __cil_tmp33);
#line 220
  __cil_tmp34 = ret != 0;
#line 220
  __cil_tmp35 = ! __cil_tmp34;
#line 220
  __cil_tmp36 = ! __cil_tmp35;
#line 220
  __cil_tmp37 = (long )__cil_tmp36;
#line 220
  tmp___8 = ldv__builtin_expect(__cil_tmp37, 0L);
  }
#line 220
  if (tmp___8) {
#line 221
    goto err_unlock;
  } else {

  }
  {
#line 224
  __cil_tmp38 = 112 + 36;
#line 224
  __cil_tmp39 = (unsigned long )bo;
#line 224
  __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 224
  __cil_tmp41 = *((uint32_t *)__cil_tmp40);
#line 224
  if (__cil_tmp41 == 2U) {
    {
#line 224
    __cil_tmp42 = (unsigned long )bo;
#line 224
    __cil_tmp43 = __cil_tmp42 + 40;
#line 224
    __cil_tmp44 = *((unsigned long *)__cil_tmp43);
#line 224
    __cil_tmp45 = 112 + 8;
#line 224
    __cil_tmp46 = (unsigned long )bo;
#line 224
    __cil_tmp47 = __cil_tmp46 + __cil_tmp45;
#line 224
    __cil_tmp48 = *((unsigned long *)__cil_tmp47);
#line 224
    if (__cil_tmp48 < __cil_tmp44) {
      {
#line 224
      __cil_tmp49 = 112 + 8;
#line 224
      __cil_tmp50 = (unsigned long )bo;
#line 224
      __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
#line 224
      __cil_tmp52 = *((unsigned long *)__cil_tmp51);
#line 224
      if (__cil_tmp52 > 0UL) {
        {
#line 227
        __cil_tmp53 = (bool )0;
#line 227
        __cil_tmp54 = (bool )0;
#line 227
        __cil_tmp55 = (bool )0;
#line 227
        ttm_bo_validate(bo, & vmw_sys_placement, __cil_tmp53, __cil_tmp54, __cil_tmp55);
        }
      } else {

      }
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 230
  __cil_tmp56 = (bool )0;
#line 230
  __cil_tmp57 = (bool )0;
#line 230
  ret = ttm_bo_validate(bo, & placement, interruptible, __cil_tmp56, __cil_tmp57);
  }
#line 233
  if (ret == 0) {
    {
#line 233
    __cil_tmp58 = (unsigned long )bo;
#line 233
    __cil_tmp59 = __cil_tmp58 + 368;
#line 233
    __cil_tmp60 = *((unsigned long *)__cil_tmp59);
#line 233
    if (__cil_tmp60 != 0UL) {
#line 233
      tmp___9 = 1;
    } else {
#line 233
      tmp___9 = 0;
    }
    }
  } else {
#line 233
    tmp___9 = 0;
  }
  {
#line 233
  __ret_warn_on = tmp___9;
#line 233
  __cil_tmp61 = ! __ret_warn_on;
#line 233
  __cil_tmp62 = ! __cil_tmp61;
#line 233
  __cil_tmp63 = (long )__cil_tmp62;
#line 233
  tmp___10 = ldv__builtin_expect(__cil_tmp63, 0L);
  }
#line 233
  if (tmp___10) {
    {
#line 233
    __cil_tmp64 = (int    )233;
#line 233
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c",
                       __cil_tmp64);
    }
  } else {

  }
  {
#line 233
  __cil_tmp65 = ! __ret_warn_on;
#line 233
  __cil_tmp66 = ! __cil_tmp65;
#line 233
  __cil_tmp67 = (long )__cil_tmp66;
#line 233
  ldv__builtin_expect(__cil_tmp67, 0L);
#line 235
  ttm_bo_unreserve(bo);
  }
  err_unlock: 
  {
#line 237
  __cil_tmp68 = (struct ttm_lock *)vmaster;
#line 237
  ttm_write_unlock(__cil_tmp68);
  }
#line 239
  return (ret);
}
}
#line 257 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) 
{ int tmp___7 ;

  {
  {
#line 266
  tmp___7 = vmw_dmabuf_to_placement(dev_priv, buf, & vmw_evictable_placement, interruptible);
  }
#line 266
  return (tmp___7);
}
}
#line 279 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
void vmw_bo_get_guest_ptr(struct ttm_buffer_object    *bo , SVGAGuestPtr *ptr ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t    __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long    __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long    __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  {
#line 282
  __cil_tmp3 = 112 + 36;
#line 282
  __cil_tmp4 = (unsigned long )bo;
#line 282
  __cil_tmp5 = __cil_tmp4 + __cil_tmp3;
#line 282
  __cil_tmp6 = *((uint32_t    *)__cil_tmp5);
#line 282
  if (__cil_tmp6 == 2U) {
#line 283
    *((uint32 *)ptr) = (uint32 )-2;
#line 284
    __cil_tmp7 = (unsigned long )ptr;
#line 284
    __cil_tmp8 = __cil_tmp7 + 4;
#line 284
    __cil_tmp9 = (unsigned long )bo;
#line 284
    __cil_tmp10 = __cil_tmp9 + 368;
#line 284
    __cil_tmp11 = *((unsigned long    *)__cil_tmp10);
#line 284
    *((uint32 *)__cil_tmp8) = (uint32 )__cil_tmp11;
  } else {
#line 286
    __cil_tmp12 = 112 + 8;
#line 286
    __cil_tmp13 = (unsigned long )bo;
#line 286
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 286
    __cil_tmp15 = *((unsigned long    *)__cil_tmp14);
#line 286
    *((uint32 *)ptr) = (uint32 )__cil_tmp15;
#line 287
    __cil_tmp16 = (unsigned long )ptr;
#line 287
    __cil_tmp17 = __cil_tmp16 + 4;
#line 287
    *((uint32 *)__cil_tmp17) = (uint32 )0;
  }
  }
#line 289
  return;
}
}
#line 300 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) 
{ uint32_t pl_flags ;
  struct ttm_placement placement ;
  uint32_t old_mem_type ;
  int ret ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  atomic_t *__cil_tmp19 ;
  atomic_t    *__cil_tmp20 ;
  long __cil_tmp21 ;
  int __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  long __cil_tmp24 ;
  uint32_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t *__cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  uint32_t *__cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  void *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  bool __cil_tmp39 ;
  bool __cil_tmp40 ;
  bool __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  long __cil_tmp46 ;

  {
#line 304
  __cil_tmp14 = 112 + 36;
#line 304
  __cil_tmp15 = (unsigned long )bo;
#line 304
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
#line 304
  old_mem_type = *((uint32_t *)__cil_tmp16);
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 307
    __cil_tmp17 = (unsigned long )bo;
#line 307
    __cil_tmp18 = __cil_tmp17 + 304;
#line 307
    __cil_tmp19 = (atomic_t *)__cil_tmp18;
#line 307
    __cil_tmp20 = (atomic_t    *)__cil_tmp19;
#line 307
    tmp___7 = atomic_read(__cil_tmp20);
    }
#line 307
    if (tmp___7) {
#line 307
      tmp___8 = 0;
    } else {
#line 307
      tmp___8 = 1;
    }
    {
#line 307
    __cil_tmp21 = (long )tmp___8;
#line 307
    tmp___9 = ldv__builtin_expect(__cil_tmp21, 0L);
    }
#line 307
    if (tmp___9) {
      {
#line 307
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 307
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (307), "i" (12UL));
        {
#line 307
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 307
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 307
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 308
    if (old_mem_type != 2U) {
      {
#line 308
      __cil_tmp22 = 1 << 3;
#line 308
      __cil_tmp23 = (uint32_t )__cil_tmp22;
#line 308
      if (old_mem_type != __cil_tmp23) {
#line 308
        tmp___10 = 1;
      } else {
#line 308
        tmp___10 = 0;
      }
      }
    } else {
#line 308
      tmp___10 = 0;
    }
    {
#line 308
    __cil_tmp24 = (long )tmp___10;
#line 308
    tmp___11 = ldv__builtin_expect(__cil_tmp24, 0L);
    }
#line 308
    if (tmp___11) {
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 308
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (309), "i" (12UL));
        {
#line 308
        while (1) {
          while_continue___4: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 308
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {

    }
#line 308
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 311
  __cil_tmp25 = & pl_flags;
#line 311
  __cil_tmp26 = 1 << 16;
#line 311
  __cil_tmp27 = 1 << 3;
#line 311
  __cil_tmp28 = 1 << 2;
#line 311
  __cil_tmp29 = __cil_tmp28 | __cil_tmp27;
#line 311
  __cil_tmp30 = __cil_tmp29 | __cil_tmp26;
#line 311
  *__cil_tmp25 = (uint32_t )__cil_tmp30;
#line 312
  if (pin) {
#line 313
    __cil_tmp31 = & pl_flags;
#line 313
    __cil_tmp32 = 1 << 21;
#line 313
    __cil_tmp33 = (unsigned int )__cil_tmp32;
#line 313
    __cil_tmp34 = & pl_flags;
#line 313
    __cil_tmp35 = *__cil_tmp34;
#line 313
    *__cil_tmp31 = __cil_tmp35 | __cil_tmp33;
  } else {

  }
  {
#line 315
  __cil_tmp36 = (void *)(& placement);
#line 315
  memset(__cil_tmp36, 0, 40UL);
#line 316
  __cil_tmp37 = (unsigned long )(& placement) + 8;
#line 316
  *((unsigned int *)__cil_tmp37) = 1U;
#line 317
  __cil_tmp38 = (unsigned long )(& placement) + 16;
#line 317
  *((uint32_t    **)__cil_tmp38) = (uint32_t    *)(& pl_flags);
#line 319
  __cil_tmp39 = (bool )0;
#line 319
  __cil_tmp40 = (bool )1;
#line 319
  __cil_tmp41 = (bool )1;
#line 319
  ret = ttm_bo_validate(bo, & placement, __cil_tmp39, __cil_tmp40, __cil_tmp41);
  }
  {
#line 321
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 321
    if (ret != 0) {
#line 321
      tmp___12 = 1;
    } else {
      {
#line 321
      __cil_tmp42 = 112 + 36;
#line 321
      __cil_tmp43 = (unsigned long )bo;
#line 321
      __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
#line 321
      __cil_tmp45 = *((uint32_t *)__cil_tmp44);
#line 321
      if (__cil_tmp45 != old_mem_type) {
#line 321
        tmp___12 = 1;
      } else {
#line 321
        tmp___12 = 0;
      }
      }
    }
    {
#line 321
    __cil_tmp46 = (long )tmp___12;
#line 321
    tmp___13 = ldv__builtin_expect(__cil_tmp46, 0L);
    }
#line 321
    if (tmp___13) {
      {
#line 321
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 321
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (321), "i" (12UL));
        {
#line 321
        while (1) {
          while_continue___7: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 321
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {

    }
#line 321
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 322
  return;
}
}
#line 58 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_destroy(struct vmw_screen_object_unit *sou ) 
{ struct vmw_display_unit *__cil_tmp2 ;
  void    *__cil_tmp3 ;

  {
  {
#line 60
  __cil_tmp2 = (struct vmw_display_unit *)sou;
#line 60
  vmw_display_unit_cleanup(__cil_tmp2);
#line 61
  __cil_tmp3 = (void    *)sou;
#line 61
  kfree(__cil_tmp3);
  }
#line 62
  return;
}
}
#line 69 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc    *__mptr ;
  struct vmw_screen_object_unit *__cil_tmp3 ;
  struct drm_crtc *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  struct vmw_screen_object_unit *__cil_tmp8 ;

  {
  {
#line 71
  __mptr = (struct drm_crtc    *)crtc;
#line 71
  __cil_tmp3 = (struct vmw_screen_object_unit *)0;
#line 71
  __cil_tmp4 = (struct drm_crtc *)__cil_tmp3;
#line 71
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 71
  __cil_tmp6 = (char *)__mptr;
#line 71
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
#line 71
  __cil_tmp8 = (struct vmw_screen_object_unit *)__cil_tmp7;
#line 71
  vmw_sou_destroy(__cil_tmp8);
  }
#line 72
  return;
}
}
#line 74 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_del_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ) 
{ struct vmw_screen_object_display *ld ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;

  {
#line 77
  __cil_tmp4 = (unsigned long )vmw_priv___0;
#line 77
  __cil_tmp5 = __cil_tmp4 + 2616;
#line 77
  ld = *((struct vmw_screen_object_display **)__cil_tmp5);
  {
#line 79
  __cil_tmp6 = (unsigned long )sou;
#line 79
  __cil_tmp7 = __cil_tmp6 + 2089;
#line 79
  if (*((bool *)__cil_tmp7)) {
#line 80
    __cil_tmp8 = *((unsigned int *)ld);
#line 80
    *((unsigned int *)ld) = __cil_tmp8 - 1U;
    {
#line 80
    __cil_tmp9 = *((unsigned int *)ld);
#line 80
    if (__cil_tmp9 == 0U) {
#line 81
      __cil_tmp10 = (unsigned long )ld;
#line 81
      __cil_tmp11 = __cil_tmp10 + 8;
#line 81
      __cil_tmp12 = (void *)0;
#line 81
      *((struct vmw_framebuffer **)__cil_tmp11) = (struct vmw_framebuffer *)__cil_tmp12;
    } else {

    }
    }
#line 82
    __cil_tmp13 = (unsigned long )sou;
#line 82
    __cil_tmp14 = __cil_tmp13 + 2089;
#line 82
    *((bool *)__cil_tmp14) = (bool )0;
  } else {

  }
  }
#line 84
  return;
}
}
#line 86 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_add_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ,
                               struct vmw_framebuffer *vfb ) 
{ struct vmw_screen_object_display *ld ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 90
  __cil_tmp7 = (unsigned long )vmw_priv___0;
#line 90
  __cil_tmp8 = __cil_tmp7 + 2616;
#line 90
  ld = *((struct vmw_screen_object_display **)__cil_tmp8);
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    __cil_tmp9 = *((unsigned int *)ld);
#line 92
    if (! __cil_tmp9) {
      {
#line 92
      __cil_tmp10 = (unsigned long )ld;
#line 92
      __cil_tmp11 = __cil_tmp10 + 8;
#line 92
      if (*((struct vmw_framebuffer **)__cil_tmp11)) {
#line 92
        tmp___7 = 1;
      } else {
#line 92
        tmp___7 = 0;
      }
      }
    } else {
#line 92
      tmp___7 = 0;
    }
    }
    {
#line 92
    __cil_tmp12 = (long )tmp___7;
#line 92
    tmp___8 = ldv__builtin_expect(__cil_tmp12, 0L);
    }
#line 92
    if (tmp___8) {
      {
#line 92
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 92
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (92), "i" (12UL));
        {
#line 92
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 92
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  __cil_tmp13 = (unsigned long )sou;
#line 94
  __cil_tmp14 = __cil_tmp13 + 2089;
#line 94
  __cil_tmp15 = *((bool *)__cil_tmp14);
#line 94
  if (! __cil_tmp15) {
    {
#line 94
    __cil_tmp16 = 0 + 2064;
#line 94
    __cil_tmp17 = (unsigned long )sou;
#line 94
    __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 94
    if (*((bool *)__cil_tmp18)) {
#line 95
      __cil_tmp19 = (unsigned long )ld;
#line 95
      __cil_tmp20 = __cil_tmp19 + 8;
#line 95
      *((struct vmw_framebuffer **)__cil_tmp20) = vfb;
#line 96
      __cil_tmp21 = (unsigned long )sou;
#line 96
      __cil_tmp22 = __cil_tmp21 + 2089;
#line 96
      *((bool *)__cil_tmp22) = (bool )1;
#line 97
      __cil_tmp23 = *((unsigned int *)ld);
#line 97
      *((unsigned int *)ld) = __cil_tmp23 + 1U;
    } else {

    }
    }
  } else {

  }
  }
#line 99
  return;
}
}
#line 104 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static int vmw_sou_fifo_create(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                               uint32_t x , uint32_t y , struct drm_display_mode *mode ) 
{ size_t fifo_size ;
  struct __anonstruct_cmd_429___3 *cmd ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_dma_buffer *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct vmw_dma_buffer *__cil_tmp82 ;
  struct ttm_buffer_object *__cil_tmp83 ;
  struct ttm_buffer_object    *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  SVGAGuestPtr *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    __cil_tmp12 = (unsigned long )sou;
#line 118
    __cil_tmp13 = __cil_tmp12 + 2080;
#line 118
    __cil_tmp14 = *((struct vmw_dma_buffer **)__cil_tmp13);
#line 118
    __cil_tmp15 = ! __cil_tmp14;
#line 118
    __cil_tmp16 = ! __cil_tmp15;
#line 118
    __cil_tmp17 = ! __cil_tmp16;
#line 118
    __cil_tmp18 = (long )__cil_tmp17;
#line 118
    tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
    }
#line 118
    if (tmp___7) {
      {
#line 118
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 118
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (118), "i" (12UL));
        {
#line 118
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 118
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  fifo_size = 48UL;
#line 121
  __cil_tmp19 = (uint32_t )fifo_size;
#line 121
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp19);
#line 121
  cmd = (struct __anonstruct_cmd_429___3 *)tmp___8;
#line 123
  __cil_tmp20 = (void *)0;
#line 123
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 123
  __cil_tmp22 = (unsigned long )cmd;
#line 123
  __cil_tmp23 = __cil_tmp22 == __cil_tmp21;
#line 123
  __cil_tmp24 = ! __cil_tmp23;
#line 123
  __cil_tmp25 = ! __cil_tmp24;
#line 123
  __cil_tmp26 = (long )__cil_tmp25;
#line 123
  tmp___9 = ldv__builtin_expect(__cil_tmp26, 0L);
  }
#line 123
  if (tmp___9) {
    {
#line 124
    drm_err("vmw_sou_fifo_create", "Fifo reserve failed.\n");
    }
#line 125
    return (-12);
  } else {

  }
  {
#line 128
  __cil_tmp27 = (void *)cmd;
#line 128
  memset(__cil_tmp27, 0, fifo_size);
#line 129
  *((uint32_t *)cmd) = (uint32_t )34;
#line 130
  __cil_tmp28 = (unsigned long )cmd;
#line 130
  __cil_tmp29 = __cil_tmp28 + 4;
#line 130
  *((uint32 *)__cil_tmp29) = (uint32 )44UL;
#line 131
  __cil_tmp30 = 4 + 4;
#line 131
  __cil_tmp31 = (unsigned long )cmd;
#line 131
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
#line 131
  __cil_tmp33 = 0 + 2032;
#line 131
  __cil_tmp34 = (unsigned long )sou;
#line 131
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 131
  *((uint32 *)__cil_tmp32) = *((unsigned int *)__cil_tmp35);
  }
  {
#line 132
  __cil_tmp36 = 0 + 2032;
#line 132
  __cil_tmp37 = (unsigned long )sou;
#line 132
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 132
  __cil_tmp39 = *((unsigned int *)__cil_tmp38);
#line 132
  if (__cil_tmp39 == 0U) {
#line 132
    tmp___10 = 1 << 1;
  } else {
#line 132
    tmp___10 = 0;
  }
  }
#line 132
  __cil_tmp40 = 4 + 8;
#line 132
  __cil_tmp41 = (unsigned long )cmd;
#line 132
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 132
  __cil_tmp43 = 1 | tmp___10;
#line 132
  *((uint32 *)__cil_tmp42) = (uint32 )__cil_tmp43;
#line 134
  __cil_tmp44 = 4 + 12;
#line 134
  __cil_tmp45 = (unsigned long )cmd;
#line 134
  __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
#line 134
  __cil_tmp47 = (unsigned long )mode;
#line 134
  __cil_tmp48 = __cil_tmp47 + 68;
#line 134
  __cil_tmp49 = *((int *)__cil_tmp48);
#line 134
  *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp49;
#line 135
  __cil_tmp50 = 12 + 4;
#line 135
  __cil_tmp51 = 4 + __cil_tmp50;
#line 135
  __cil_tmp52 = (unsigned long )cmd;
#line 135
  __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
#line 135
  __cil_tmp54 = (unsigned long )mode;
#line 135
  __cil_tmp55 = __cil_tmp54 + 88;
#line 135
  __cil_tmp56 = *((int *)__cil_tmp55);
#line 135
  *((uint32 *)__cil_tmp53) = (uint32 )__cil_tmp56;
  {
#line 136
  __cil_tmp57 = 0 + 2064;
#line 136
  __cil_tmp58 = (unsigned long )sou;
#line 136
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
#line 136
  if (*((bool *)__cil_tmp59)) {
#line 137
    __cil_tmp60 = 4 + 20;
#line 137
    __cil_tmp61 = (unsigned long )cmd;
#line 137
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 137
    *((int32 *)__cil_tmp62) = (int32 )x;
#line 138
    __cil_tmp63 = 20 + 4;
#line 138
    __cil_tmp64 = 4 + __cil_tmp63;
#line 138
    __cil_tmp65 = (unsigned long )cmd;
#line 138
    __cil_tmp66 = __cil_tmp65 + __cil_tmp64;
#line 138
    *((int32 *)__cil_tmp66) = (int32 )y;
  } else {
#line 140
    __cil_tmp67 = 4 + 20;
#line 140
    __cil_tmp68 = (unsigned long )cmd;
#line 140
    __cil_tmp69 = __cil_tmp68 + __cil_tmp67;
#line 140
    __cil_tmp70 = 0 + 2056;
#line 140
    __cil_tmp71 = (unsigned long )sou;
#line 140
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 140
    *((int32 *)__cil_tmp69) = *((int *)__cil_tmp72);
#line 141
    __cil_tmp73 = 20 + 4;
#line 141
    __cil_tmp74 = 4 + __cil_tmp73;
#line 141
    __cil_tmp75 = (unsigned long )cmd;
#line 141
    __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
#line 141
    __cil_tmp77 = 0 + 2060;
#line 141
    __cil_tmp78 = (unsigned long )sou;
#line 141
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 141
    *((int32 *)__cil_tmp76) = *((int *)__cil_tmp79);
  }
  }
  {
#line 145
  __cil_tmp80 = (unsigned long )sou;
#line 145
  __cil_tmp81 = __cil_tmp80 + 2080;
#line 145
  __cil_tmp82 = *((struct vmw_dma_buffer **)__cil_tmp81);
#line 145
  __cil_tmp83 = (struct ttm_buffer_object *)__cil_tmp82;
#line 145
  __cil_tmp84 = (struct ttm_buffer_object    *)__cil_tmp83;
#line 145
  __cil_tmp85 = 4 + 28;
#line 145
  __cil_tmp86 = (unsigned long )cmd;
#line 145
  __cil_tmp87 = __cil_tmp86 + __cil_tmp85;
#line 145
  __cil_tmp88 = (SVGAGuestPtr *)__cil_tmp87;
#line 145
  vmw_bo_get_guest_ptr(__cil_tmp84, __cil_tmp88);
#line 146
  __cil_tmp89 = 28 + 8;
#line 146
  __cil_tmp90 = 4 + __cil_tmp89;
#line 146
  __cil_tmp91 = (unsigned long )cmd;
#line 146
  __cil_tmp92 = __cil_tmp91 + __cil_tmp90;
#line 146
  __cil_tmp93 = (unsigned long )mode;
#line 146
  __cil_tmp94 = __cil_tmp93 + 68;
#line 146
  __cil_tmp95 = *((int *)__cil_tmp94);
#line 146
  __cil_tmp96 = __cil_tmp95 * 4;
#line 146
  *((uint32 *)__cil_tmp92) = (uint32 )__cil_tmp96;
#line 148
  __cil_tmp97 = (uint32_t )fifo_size;
#line 148
  vmw_fifo_commit(dev_priv, __cil_tmp97);
#line 150
  __cil_tmp98 = (unsigned long )sou;
#line 150
  __cil_tmp99 = __cil_tmp98 + 2088;
#line 150
  *((bool *)__cil_tmp99) = (bool )1;
  }
#line 152
  return (0);
}
}
#line 158 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static int vmw_sou_fifo_destroy(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_431___0 *cmd ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  bool __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  bool __cil_tmp32 ;
  bool __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  bool __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  {
#line 172
  __cil_tmp10 = (unsigned long )sou;
#line 172
  __cil_tmp11 = __cil_tmp10 + 2088;
#line 172
  __cil_tmp12 = *((bool *)__cil_tmp11);
#line 172
  __cil_tmp13 = ! __cil_tmp12;
#line 172
  __cil_tmp14 = ! __cil_tmp13;
#line 172
  __cil_tmp15 = ! __cil_tmp14;
#line 172
  __cil_tmp16 = (long )__cil_tmp15;
#line 172
  tmp___7 = ldv__builtin_expect(__cil_tmp16, 0L);
  }
#line 172
  if (tmp___7) {
#line 173
    return (0);
  } else {

  }
  {
#line 175
  fifo_size = 8UL;
#line 176
  __cil_tmp17 = (uint32_t )fifo_size;
#line 176
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp17);
#line 176
  cmd = (struct __anonstruct_cmd_431___0 *)tmp___8;
#line 178
  __cil_tmp18 = (void *)0;
#line 178
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 178
  __cil_tmp20 = (unsigned long )cmd;
#line 178
  __cil_tmp21 = __cil_tmp20 == __cil_tmp19;
#line 178
  __cil_tmp22 = ! __cil_tmp21;
#line 178
  __cil_tmp23 = ! __cil_tmp22;
#line 178
  __cil_tmp24 = (long )__cil_tmp23;
#line 178
  tmp___9 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 178
  if (tmp___9) {
    {
#line 179
    drm_err("vmw_sou_fifo_destroy", "Fifo reserve failed.\n");
    }
#line 180
    return (-12);
  } else {

  }
  {
#line 183
  __cil_tmp25 = (void *)cmd;
#line 183
  memset(__cil_tmp25, 0, fifo_size);
#line 184
  *((uint32_t *)cmd) = (uint32_t )35;
#line 185
  __cil_tmp26 = (unsigned long )cmd;
#line 185
  __cil_tmp27 = __cil_tmp26 + 4;
#line 185
  __cil_tmp28 = 0 + 2032;
#line 185
  __cil_tmp29 = (unsigned long )sou;
#line 185
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 185
  *((uint32 *)__cil_tmp27) = *((unsigned int *)__cil_tmp30);
#line 187
  __cil_tmp31 = (uint32_t )fifo_size;
#line 187
  vmw_fifo_commit(dev_priv, __cil_tmp31);
#line 190
  __cil_tmp32 = (bool )0;
#line 190
  __cil_tmp33 = (bool )1;
#line 190
  __cil_tmp34 = (uint32_t )0;
#line 190
  __cil_tmp35 = (bool )0;
#line 190
  ret = vmw_fallback_wait(dev_priv, __cil_tmp32, __cil_tmp33, __cil_tmp34, __cil_tmp35,
                          750UL);
#line 191
  __cil_tmp36 = ret != 0;
#line 191
  __cil_tmp37 = ! __cil_tmp36;
#line 191
  __cil_tmp38 = ! __cil_tmp37;
#line 191
  __cil_tmp39 = (long )__cil_tmp38;
#line 191
  tmp___10 = ldv__builtin_expect(__cil_tmp39, 0L);
  }
#line 191
  if (tmp___10) {
    {
#line 192
    drm_err("vmw_sou_fifo_destroy", "Failed to sync with HW");
    }
  } else {
#line 194
    __cil_tmp40 = (unsigned long )sou;
#line 194
    __cil_tmp41 = __cil_tmp40 + 2088;
#line 194
    *((bool *)__cil_tmp41) = (bool )0;
  }
#line 196
  return (ret);
}
}
#line 202 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_backing_free(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ struct ttm_buffer_object *bo ;
  long tmp___7 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_dma_buffer *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct ttm_buffer_object **__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_dma_buffer *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;

  {
  {
#line 207
  __cil_tmp5 = (void *)0;
#line 207
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 207
  __cil_tmp7 = (unsigned long )sou;
#line 207
  __cil_tmp8 = __cil_tmp7 + 2080;
#line 207
  __cil_tmp9 = *((struct vmw_dma_buffer **)__cil_tmp8);
#line 207
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 207
  __cil_tmp11 = __cil_tmp10 == __cil_tmp6;
#line 207
  __cil_tmp12 = ! __cil_tmp11;
#line 207
  __cil_tmp13 = ! __cil_tmp12;
#line 207
  __cil_tmp14 = (long )__cil_tmp13;
#line 207
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  }
#line 207
  if (tmp___7) {
#line 208
    return;
  } else {

  }
  {
#line 210
  __cil_tmp15 = & bo;
#line 210
  __cil_tmp16 = (unsigned long )sou;
#line 210
  __cil_tmp17 = __cil_tmp16 + 2080;
#line 210
  __cil_tmp18 = *((struct vmw_dma_buffer **)__cil_tmp17);
#line 210
  *__cil_tmp15 = (struct ttm_buffer_object *)__cil_tmp18;
#line 211
  ttm_bo_unref(& bo);
#line 212
  __cil_tmp19 = (unsigned long )sou;
#line 212
  __cil_tmp20 = __cil_tmp19 + 2080;
#line 212
  __cil_tmp21 = (void *)0;
#line 212
  *((struct vmw_dma_buffer **)__cil_tmp20) = (struct vmw_dma_buffer *)__cil_tmp21;
#line 213
  __cil_tmp22 = (unsigned long )sou;
#line 213
  __cil_tmp23 = __cil_tmp22 + 2072;
#line 213
  *((unsigned long *)__cil_tmp23) = 0UL;
  }
#line 214
  return;
}
}
#line 219 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static int vmw_sou_backing_alloc(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                                 unsigned long size ) 
{ int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_dma_buffer *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_dma_buffer *__cil_tmp27 ;
  bool __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  {
#line 225
  __cil_tmp8 = (unsigned long )sou;
#line 225
  __cil_tmp9 = __cil_tmp8 + 2072;
#line 225
  __cil_tmp10 = *((unsigned long *)__cil_tmp9);
#line 225
  if (__cil_tmp10 == size) {
#line 226
    return (0);
  } else {

  }
  }
  {
#line 228
  __cil_tmp11 = (unsigned long )sou;
#line 228
  __cil_tmp12 = __cil_tmp11 + 2080;
#line 228
  if (*((struct vmw_dma_buffer **)__cil_tmp12)) {
    {
#line 229
    vmw_sou_backing_free(dev_priv, sou);
    }
  } else {

  }
  }
  {
#line 231
  tmp___7 = kzalloc(416UL, 208U);
#line 231
  __cil_tmp13 = (unsigned long )sou;
#line 231
  __cil_tmp14 = __cil_tmp13 + 2080;
#line 231
  *((struct vmw_dma_buffer **)__cil_tmp14) = (struct vmw_dma_buffer *)tmp___7;
#line 232
  __cil_tmp15 = (void *)0;
#line 232
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 232
  __cil_tmp17 = (unsigned long )sou;
#line 232
  __cil_tmp18 = __cil_tmp17 + 2080;
#line 232
  __cil_tmp19 = *((struct vmw_dma_buffer **)__cil_tmp18);
#line 232
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 232
  __cil_tmp21 = __cil_tmp20 == __cil_tmp16;
#line 232
  __cil_tmp22 = ! __cil_tmp21;
#line 232
  __cil_tmp23 = ! __cil_tmp22;
#line 232
  __cil_tmp24 = (long )__cil_tmp23;
#line 232
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  }
#line 232
  if (tmp___8) {
#line 233
    return (-12);
  } else {

  }
  {
#line 238
  vmw_overlay_pause_all(dev_priv);
#line 239
  __cil_tmp25 = (unsigned long )sou;
#line 239
  __cil_tmp26 = __cil_tmp25 + 2080;
#line 239
  __cil_tmp27 = *((struct vmw_dma_buffer **)__cil_tmp26);
#line 239
  __cil_tmp28 = (bool )0;
#line 239
  ret = vmw_dmabuf_init(dev_priv, __cil_tmp27, size, & vmw_vram_ne_placement, __cil_tmp28,
                        & vmw_dmabuf_bo_free);
#line 242
  vmw_overlay_resume_all(dev_priv);
#line 244
  __cil_tmp29 = ret != 0;
#line 244
  __cil_tmp30 = ! __cil_tmp29;
#line 244
  __cil_tmp31 = ! __cil_tmp30;
#line 244
  __cil_tmp32 = (long )__cil_tmp31;
#line 244
  tmp___9 = ldv__builtin_expect(__cil_tmp32, 0L);
  }
#line 244
  if (tmp___9) {
#line 245
    __cil_tmp33 = (unsigned long )sou;
#line 245
    __cil_tmp34 = __cil_tmp33 + 2080;
#line 245
    __cil_tmp35 = (void *)0;
#line 245
    *((struct vmw_dma_buffer **)__cil_tmp34) = (struct vmw_dma_buffer *)__cil_tmp35;
  } else {
#line 247
    __cil_tmp36 = (unsigned long )sou;
#line 247
    __cil_tmp37 = __cil_tmp36 + 2072;
#line 247
    *((unsigned long *)__cil_tmp37) = size;
  }
#line 249
  return (ret);
}
}
#line 252 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static int vmw_sou_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_screen_object_unit *sou ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int ret ;
  struct drm_crtc    *__mptr ;
  struct drm_framebuffer    *__mptr___0 ;
  long tmp___7 ;
  long tmp___8 ;
  size_t size ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_crtc *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_screen_object_unit *__cil_tmp23 ;
  struct drm_crtc *__cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct drm_framebuffer *__cil_tmp32 ;
  struct vmw_framebuffer *__cil_tmp33 ;
  struct drm_framebuffer *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  struct drm_device *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  size_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  size_t __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct drm_connector *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_connector **__cil_tmp53 ;
  struct drm_connector **__cil_tmp54 ;
  struct drm_connector *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct drm_connector **__cil_tmp59 ;
  struct drm_connector **__cil_tmp60 ;
  struct drm_connector *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct drm_connector *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  struct vmw_screen_object_display *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct vmw_screen_object_display *__cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct vmw_screen_object_display *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct vmw_framebuffer *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  size_t __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct drm_display_mode *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct drm_framebuffer *__cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  void *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  void *__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned int __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  int __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  uint32_t __cil_tmp133 ;
  uint32_t __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned int __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  int __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  uint32_t __cil_tmp144 ;
  uint32_t __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  int __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  int __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  int __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  int __cil_tmp159 ;
  int __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct vmw_dma_buffer *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  int __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  int __cil_tmp172 ;
  int __cil_tmp173 ;
  int __cil_tmp174 ;
  int __cil_tmp175 ;
  int __cil_tmp176 ;
  int __cil_tmp177 ;
  long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  uint32_t __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  int __cil_tmp185 ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  void *__cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  void *__cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  void *__cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  uint32_t __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  uint32_t __cil_tmp221 ;

  {
#line 262
  ret = 0;
#line 264
  if (! set) {
#line 265
    return (-22);
  } else {

  }
  {
#line 267
  __cil_tmp18 = (unsigned long )set;
#line 267
  __cil_tmp19 = __cil_tmp18 + 24;
#line 267
  __cil_tmp20 = *((struct drm_crtc **)__cil_tmp19);
#line 267
  if (! __cil_tmp20) {
#line 268
    return (-22);
  } else {

  }
  }
#line 271
  __cil_tmp21 = (unsigned long )set;
#line 271
  __cil_tmp22 = __cil_tmp21 + 24;
#line 271
  crtc = *((struct drm_crtc **)__cil_tmp22);
#line 272
  __mptr = (struct drm_crtc    *)crtc;
#line 272
  __cil_tmp23 = (struct vmw_screen_object_unit *)0;
#line 272
  __cil_tmp24 = (struct drm_crtc *)__cil_tmp23;
#line 272
  __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 272
  __cil_tmp26 = (char *)__mptr;
#line 272
  __cil_tmp27 = __cil_tmp26 - __cil_tmp25;
#line 272
  sou = (struct vmw_screen_object_unit *)__cil_tmp27;
  {
#line 273
  __cil_tmp28 = (unsigned long )set;
#line 273
  __cil_tmp29 = __cil_tmp28 + 16;
#line 273
  if (*((struct drm_framebuffer **)__cil_tmp29)) {
#line 273
    __cil_tmp30 = (unsigned long )set;
#line 273
    __cil_tmp31 = __cil_tmp30 + 16;
#line 273
    __cil_tmp32 = *((struct drm_framebuffer **)__cil_tmp31);
#line 273
    __mptr___0 = (struct drm_framebuffer    *)__cil_tmp32;
#line 273
    __cil_tmp33 = (struct vmw_framebuffer *)0;
#line 273
    __cil_tmp34 = (struct drm_framebuffer *)__cil_tmp33;
#line 273
    __cil_tmp35 = (unsigned int )__cil_tmp34;
#line 273
    __cil_tmp36 = (char *)__mptr___0;
#line 273
    __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
#line 273
    vfb = (struct vmw_framebuffer *)__cil_tmp37;
  } else {
#line 273
    __cil_tmp38 = (void *)0;
#line 273
    vfb = (struct vmw_framebuffer *)__cil_tmp38;
  }
  }
  {
#line 274
  __cil_tmp39 = *((struct drm_device **)crtc);
#line 274
  dev_priv = vmw_priv(__cil_tmp39);
  }
  {
#line 276
  __cil_tmp40 = (unsigned long )set;
#line 276
  __cil_tmp41 = __cil_tmp40 + 56;
#line 276
  __cil_tmp42 = *((size_t *)__cil_tmp41);
#line 276
  if (__cil_tmp42 > 1UL) {
    {
#line 277
    drm_err("vmw_sou_crtc_set_config", "to many connectors\n");
    }
#line 278
    return (-22);
  } else {

  }
  }
  {
#line 281
  __cil_tmp43 = (unsigned long )set;
#line 281
  __cil_tmp44 = __cil_tmp43 + 56;
#line 281
  __cil_tmp45 = *((size_t *)__cil_tmp44);
#line 281
  if (__cil_tmp45 == 1UL) {
    {
#line 281
    __cil_tmp46 = 0 + 616;
#line 281
    __cil_tmp47 = (unsigned long )sou;
#line 281
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 281
    __cil_tmp49 = (struct drm_connector *)__cil_tmp48;
#line 281
    __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 281
    __cil_tmp51 = (unsigned long )set;
#line 281
    __cil_tmp52 = __cil_tmp51 + 48;
#line 281
    __cil_tmp53 = *((struct drm_connector ***)__cil_tmp52);
#line 281
    __cil_tmp54 = __cil_tmp53 + 0;
#line 281
    __cil_tmp55 = *__cil_tmp54;
#line 281
    __cil_tmp56 = (unsigned long )__cil_tmp55;
#line 281
    if (__cil_tmp56 != __cil_tmp50) {
      {
#line 283
      __cil_tmp57 = (unsigned long )set;
#line 283
      __cil_tmp58 = __cil_tmp57 + 48;
#line 283
      __cil_tmp59 = *((struct drm_connector ***)__cil_tmp58);
#line 283
      __cil_tmp60 = __cil_tmp59 + 0;
#line 283
      __cil_tmp61 = *__cil_tmp60;
#line 283
      __cil_tmp62 = 0 + 616;
#line 283
      __cil_tmp63 = (unsigned long )sou;
#line 283
      __cil_tmp64 = __cil_tmp63 + __cil_tmp62;
#line 283
      __cil_tmp65 = (struct drm_connector *)__cil_tmp64;
#line 283
      drm_err("vmw_sou_crtc_set_config", "connector doesn\'t match %p %p\n", __cil_tmp61,
              __cil_tmp65);
      }
#line 285
      return (-22);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 289
  __cil_tmp66 = 0 + 2064;
#line 289
  __cil_tmp67 = (unsigned long )sou;
#line 289
  __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
#line 289
  if (*((bool *)__cil_tmp68)) {
    {
#line 289
    __cil_tmp69 = (unsigned long )dev_priv;
#line 289
    __cil_tmp70 = __cil_tmp69 + 2616;
#line 289
    __cil_tmp71 = *((struct vmw_screen_object_display **)__cil_tmp70);
#line 289
    __cil_tmp72 = (unsigned long )__cil_tmp71;
#line 289
    __cil_tmp73 = __cil_tmp72 + 8;
#line 289
    if (*((struct vmw_framebuffer **)__cil_tmp73)) {
#line 289
      if (vfb) {
        {
#line 289
        __cil_tmp74 = (unsigned long )dev_priv;
#line 289
        __cil_tmp75 = __cil_tmp74 + 2616;
#line 289
        __cil_tmp76 = *((struct vmw_screen_object_display **)__cil_tmp75);
#line 289
        __cil_tmp77 = *((unsigned int *)__cil_tmp76);
#line 289
        if (__cil_tmp77 == 1U) {
          {
#line 289
          __cil_tmp78 = (unsigned long )sou;
#line 289
          __cil_tmp79 = __cil_tmp78 + 2089;
#line 289
          if (*((bool *)__cil_tmp79)) {

          } else {
#line 289
            goto _L;
          }
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 289
          __cil_tmp80 = (unsigned long )vfb;
#line 289
          __cil_tmp81 = (unsigned long )dev_priv;
#line 289
          __cil_tmp82 = __cil_tmp81 + 2616;
#line 289
          __cil_tmp83 = *((struct vmw_screen_object_display **)__cil_tmp82);
#line 289
          __cil_tmp84 = (unsigned long )__cil_tmp83;
#line 289
          __cil_tmp85 = __cil_tmp84 + 8;
#line 289
          __cil_tmp86 = *((struct vmw_framebuffer **)__cil_tmp85);
#line 289
          __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 289
          if (__cil_tmp87 != __cil_tmp80) {
            {
#line 294
            drm_err("vmw_sou_crtc_set_config", "Multiple framebuffers not supported\n");
            }
#line 295
            return (-22);
          } else {

          }
          }
        }
        }
      } else {

      }
    } else {

    }
    }
  } else {

  }
  }
#line 299
  __cil_tmp88 = 0 + 616;
#line 299
  __cil_tmp89 = (unsigned long )sou;
#line 299
  __cil_tmp90 = __cil_tmp89 + __cil_tmp88;
#line 299
  connector = (struct drm_connector *)__cil_tmp90;
#line 300
  __cil_tmp91 = 0 + 544;
#line 300
  __cil_tmp92 = (unsigned long )sou;
#line 300
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
#line 300
  encoder = (struct drm_encoder *)__cil_tmp93;
  {
#line 303
  __cil_tmp94 = (unsigned long )set;
#line 303
  __cil_tmp95 = __cil_tmp94 + 56;
#line 303
  __cil_tmp96 = *((size_t *)__cil_tmp95);
#line 303
  if (__cil_tmp96 == 0UL) {
#line 303
    goto _L___0;
  } else {
    {
#line 303
    __cil_tmp97 = (unsigned long )set;
#line 303
    __cil_tmp98 = __cil_tmp97 + 32;
#line 303
    __cil_tmp99 = *((struct drm_display_mode **)__cil_tmp98);
#line 303
    if (! __cil_tmp99) {
#line 303
      goto _L___0;
    } else {
      {
#line 303
      __cil_tmp100 = (unsigned long )set;
#line 303
      __cil_tmp101 = __cil_tmp100 + 16;
#line 303
      __cil_tmp102 = *((struct drm_framebuffer **)__cil_tmp101);
#line 303
      if (! __cil_tmp102) {
        _L___0: /* CIL Label */ 
        {
#line 304
        ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 306
        __cil_tmp103 = ret != 0;
#line 306
        __cil_tmp104 = ! __cil_tmp103;
#line 306
        __cil_tmp105 = ! __cil_tmp104;
#line 306
        __cil_tmp106 = (long )__cil_tmp105;
#line 306
        tmp___7 = ldv__builtin_expect(__cil_tmp106, 0L);
        }
#line 306
        if (tmp___7) {
#line 307
          return (ret);
        } else {

        }
        {
#line 309
        __cil_tmp107 = (unsigned long )connector;
#line 309
        __cil_tmp108 = __cil_tmp107 + 1208;
#line 309
        __cil_tmp109 = (void *)0;
#line 309
        *((struct drm_encoder **)__cil_tmp108) = (struct drm_encoder *)__cil_tmp109;
#line 310
        __cil_tmp110 = (unsigned long )encoder;
#line 310
        __cil_tmp111 = __cil_tmp110 + 48;
#line 310
        __cil_tmp112 = (void *)0;
#line 310
        *((struct drm_crtc **)__cil_tmp111) = (struct drm_crtc *)__cil_tmp112;
#line 311
        __cil_tmp113 = (unsigned long )crtc;
#line 311
        __cil_tmp114 = __cil_tmp113 + 32;
#line 311
        __cil_tmp115 = (void *)0;
#line 311
        *((struct drm_framebuffer **)__cil_tmp114) = (struct drm_framebuffer *)__cil_tmp115;
#line 312
        __cil_tmp116 = (unsigned long )crtc;
#line 312
        __cil_tmp117 = __cil_tmp116 + 480;
#line 312
        *((int *)__cil_tmp117) = 0;
#line 313
        __cil_tmp118 = (unsigned long )crtc;
#line 313
        __cil_tmp119 = __cil_tmp118 + 484;
#line 313
        *((int *)__cil_tmp119) = 0;
#line 315
        vmw_sou_del_active(dev_priv, sou);
#line 317
        vmw_sou_backing_free(dev_priv, sou);
        }
#line 319
        return (0);
      } else {

      }
      }
    }
    }
  }
  }
#line 324
  __cil_tmp120 = (unsigned long )set;
#line 324
  __cil_tmp121 = __cil_tmp120 + 32;
#line 324
  mode = *((struct drm_display_mode **)__cil_tmp121);
#line 325
  __cil_tmp122 = (unsigned long )set;
#line 325
  __cil_tmp123 = __cil_tmp122 + 16;
#line 325
  fb = *((struct drm_framebuffer **)__cil_tmp123);
  {
#line 327
  __cil_tmp124 = (unsigned long )fb;
#line 327
  __cil_tmp125 = __cil_tmp124 + 72;
#line 327
  __cil_tmp126 = *((unsigned int *)__cil_tmp125);
#line 327
  __cil_tmp127 = (unsigned long )mode;
#line 327
  __cil_tmp128 = __cil_tmp127 + 68;
#line 327
  __cil_tmp129 = *((int *)__cil_tmp128);
#line 327
  __cil_tmp130 = (uint32_t )__cil_tmp129;
#line 327
  __cil_tmp131 = (unsigned long )set;
#line 327
  __cil_tmp132 = __cil_tmp131 + 40;
#line 327
  __cil_tmp133 = *((uint32_t *)__cil_tmp132);
#line 327
  __cil_tmp134 = __cil_tmp133 + __cil_tmp130;
#line 327
  if (__cil_tmp134 > __cil_tmp126) {
    {
#line 329
    drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
    }
#line 330
    return (-22);
  } else {
    {
#line 327
    __cil_tmp135 = (unsigned long )fb;
#line 327
    __cil_tmp136 = __cil_tmp135 + 76;
#line 327
    __cil_tmp137 = *((unsigned int *)__cil_tmp136);
#line 327
    __cil_tmp138 = (unsigned long )mode;
#line 327
    __cil_tmp139 = __cil_tmp138 + 88;
#line 327
    __cil_tmp140 = *((int *)__cil_tmp139);
#line 327
    __cil_tmp141 = (uint32_t )__cil_tmp140;
#line 327
    __cil_tmp142 = (unsigned long )set;
#line 327
    __cil_tmp143 = __cil_tmp142 + 44;
#line 327
    __cil_tmp144 = *((uint32_t *)__cil_tmp143);
#line 327
    __cil_tmp145 = __cil_tmp144 + __cil_tmp141;
#line 327
    if (__cil_tmp145 > __cil_tmp137) {
      {
#line 329
      drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
      }
#line 330
      return (-22);
    } else {

    }
    }
  }
  }
  {
#line 333
  vmw_fb_off(dev_priv);
  }
  {
#line 335
  __cil_tmp146 = 48 + 68;
#line 335
  __cil_tmp147 = (unsigned long )crtc;
#line 335
  __cil_tmp148 = __cil_tmp147 + __cil_tmp146;
#line 335
  __cil_tmp149 = *((int *)__cil_tmp148);
#line 335
  __cil_tmp150 = (unsigned long )mode;
#line 335
  __cil_tmp151 = __cil_tmp150 + 68;
#line 335
  __cil_tmp152 = *((int *)__cil_tmp151);
#line 335
  if (__cil_tmp152 != __cil_tmp149) {
#line 335
    goto _L___1;
  } else {
    {
#line 335
    __cil_tmp153 = 48 + 88;
#line 335
    __cil_tmp154 = (unsigned long )crtc;
#line 335
    __cil_tmp155 = __cil_tmp154 + __cil_tmp153;
#line 335
    __cil_tmp156 = *((int *)__cil_tmp155);
#line 335
    __cil_tmp157 = (unsigned long )mode;
#line 335
    __cil_tmp158 = __cil_tmp157 + 88;
#line 335
    __cil_tmp159 = *((int *)__cil_tmp158);
#line 335
    if (__cil_tmp159 != __cil_tmp156) {
      _L___1: /* CIL Label */ 
      {
#line 341
      ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 343
      __cil_tmp160 = ret != 0;
#line 343
      __cil_tmp161 = ! __cil_tmp160;
#line 343
      __cil_tmp162 = ! __cil_tmp161;
#line 343
      __cil_tmp163 = (long )__cil_tmp162;
#line 343
      tmp___8 = ldv__builtin_expect(__cil_tmp163, 0L);
      }
#line 343
      if (tmp___8) {
#line 344
        return (ret);
      } else {

      }
      {
#line 346
      vmw_sou_backing_free(dev_priv, sou);
      }
    } else {

    }
    }
  }
  }
  {
#line 349
  __cil_tmp164 = (unsigned long )sou;
#line 349
  __cil_tmp165 = __cil_tmp164 + 2080;
#line 349
  __cil_tmp166 = *((struct vmw_dma_buffer **)__cil_tmp165);
#line 349
  if (! __cil_tmp166) {
    {
#line 351
    __cil_tmp167 = (unsigned long )mode;
#line 351
    __cil_tmp168 = __cil_tmp167 + 88;
#line 351
    __cil_tmp169 = *((int *)__cil_tmp168);
#line 351
    __cil_tmp170 = (unsigned long )mode;
#line 351
    __cil_tmp171 = __cil_tmp170 + 68;
#line 351
    __cil_tmp172 = *((int *)__cil_tmp171);
#line 351
    __cil_tmp173 = __cil_tmp172 * __cil_tmp169;
#line 351
    __cil_tmp174 = __cil_tmp173 * 4;
#line 351
    size = (size_t )__cil_tmp174;
#line 352
    ret = vmw_sou_backing_alloc(dev_priv, sou, size);
#line 353
    __cil_tmp175 = ret != 0;
#line 353
    __cil_tmp176 = ! __cil_tmp175;
#line 353
    __cil_tmp177 = ! __cil_tmp176;
#line 353
    __cil_tmp178 = (long )__cil_tmp177;
#line 353
    tmp___9 = ldv__builtin_expect(__cil_tmp178, 0L);
    }
#line 353
    if (tmp___9) {
#line 354
      return (ret);
    } else {

    }
  } else {

  }
  }
  {
#line 357
  __cil_tmp179 = (unsigned long )set;
#line 357
  __cil_tmp180 = __cil_tmp179 + 40;
#line 357
  __cil_tmp181 = *((uint32_t *)__cil_tmp180);
#line 357
  __cil_tmp182 = (unsigned long )set;
#line 357
  __cil_tmp183 = __cil_tmp182 + 44;
#line 357
  __cil_tmp184 = *((uint32_t *)__cil_tmp183);
#line 357
  ret = vmw_sou_fifo_create(dev_priv, sou, __cil_tmp181, __cil_tmp184, mode);
#line 358
  __cil_tmp185 = ret != 0;
#line 358
  __cil_tmp186 = ! __cil_tmp185;
#line 358
  __cil_tmp187 = ! __cil_tmp186;
#line 358
  __cil_tmp188 = (long )__cil_tmp187;
#line 358
  tmp___10 = ldv__builtin_expect(__cil_tmp188, 0L);
  }
#line 358
  if (tmp___10) {
    {
#line 366
    __cil_tmp189 = (unsigned long )sou;
#line 366
    __cil_tmp190 = __cil_tmp189 + 2088;
#line 366
    if (*((bool *)__cil_tmp190)) {
#line 367
      return (ret);
    } else {

    }
    }
#line 369
    __cil_tmp191 = (unsigned long )connector;
#line 369
    __cil_tmp192 = __cil_tmp191 + 1208;
#line 369
    __cil_tmp193 = (void *)0;
#line 369
    *((struct drm_encoder **)__cil_tmp192) = (struct drm_encoder *)__cil_tmp193;
#line 370
    __cil_tmp194 = (unsigned long )encoder;
#line 370
    __cil_tmp195 = __cil_tmp194 + 48;
#line 370
    __cil_tmp196 = (void *)0;
#line 370
    *((struct drm_crtc **)__cil_tmp195) = (struct drm_crtc *)__cil_tmp196;
#line 371
    __cil_tmp197 = (unsigned long )crtc;
#line 371
    __cil_tmp198 = __cil_tmp197 + 32;
#line 371
    __cil_tmp199 = (void *)0;
#line 371
    *((struct drm_framebuffer **)__cil_tmp198) = (struct drm_framebuffer *)__cil_tmp199;
#line 372
    __cil_tmp200 = (unsigned long )crtc;
#line 372
    __cil_tmp201 = __cil_tmp200 + 480;
#line 372
    *((int *)__cil_tmp201) = 0;
#line 373
    __cil_tmp202 = (unsigned long )crtc;
#line 373
    __cil_tmp203 = __cil_tmp202 + 484;
#line 373
    *((int *)__cil_tmp203) = 0;
#line 375
    return (ret);
  } else {

  }
  {
#line 378
  vmw_sou_add_active(dev_priv, sou, vfb);
#line 380
  __cil_tmp204 = (unsigned long )connector;
#line 380
  __cil_tmp205 = __cil_tmp204 + 1208;
#line 380
  *((struct drm_encoder **)__cil_tmp205) = encoder;
#line 381
  __cil_tmp206 = (unsigned long )encoder;
#line 381
  __cil_tmp207 = __cil_tmp206 + 48;
#line 381
  *((struct drm_crtc **)__cil_tmp207) = crtc;
#line 382
  __cil_tmp208 = (unsigned long )crtc;
#line 382
  __cil_tmp209 = __cil_tmp208 + 48;
#line 382
  *((struct drm_display_mode *)__cil_tmp209) = *mode;
#line 383
  __cil_tmp210 = (unsigned long )crtc;
#line 383
  __cil_tmp211 = __cil_tmp210 + 32;
#line 383
  *((struct drm_framebuffer **)__cil_tmp211) = fb;
#line 384
  __cil_tmp212 = (unsigned long )crtc;
#line 384
  __cil_tmp213 = __cil_tmp212 + 480;
#line 384
  __cil_tmp214 = (unsigned long )set;
#line 384
  __cil_tmp215 = __cil_tmp214 + 40;
#line 384
  __cil_tmp216 = *((uint32_t *)__cil_tmp215);
#line 384
  *((int *)__cil_tmp213) = (int )__cil_tmp216;
#line 385
  __cil_tmp217 = (unsigned long )crtc;
#line 385
  __cil_tmp218 = __cil_tmp217 + 484;
#line 385
  __cil_tmp219 = (unsigned long )set;
#line 385
  __cil_tmp220 = __cil_tmp219 + 44;
#line 385
  __cil_tmp221 = *((uint32_t *)__cil_tmp220);
#line 385
  *((int *)__cil_tmp218) = (int )__cil_tmp221;
  }
#line 387
  return (0);
}
}
#line 390 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static struct drm_crtc_funcs vmw_screen_object_crtc_funcs  = 
#line 390
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, (void (*)(struct drm_crtc *crtc ))0,
    & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move, & vmw_du_crtc_gamma_set,
    & vmw_sou_crtc_destroy, & vmw_sou_crtc_set_config, & vmw_du_page_flip};
#line 405 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder    *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_screen_object_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_encoder *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_screen_object_unit *__cil_tmp11 ;

  {
  {
#line 407
  __mptr = (struct drm_encoder    *)encoder;
#line 407
  __cil_tmp3 = 0 + 544;
#line 407
  __cil_tmp4 = (struct vmw_screen_object_unit *)0;
#line 407
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 407
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
#line 407
  __cil_tmp7 = (struct drm_encoder *)__cil_tmp6;
#line 407
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 407
  __cil_tmp9 = (char *)__mptr;
#line 407
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 407
  __cil_tmp11 = (struct vmw_screen_object_unit *)__cil_tmp10;
#line 407
  vmw_sou_destroy(__cil_tmp11);
  }
#line 408
  return;
}
}
#line 410 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static struct drm_encoder_funcs vmw_screen_object_encoder_funcs  =    {(void (*)(struct drm_encoder *encoder ))0, & vmw_sou_encoder_destroy};
#line 418 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static void vmw_sou_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector    *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_screen_object_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_connector *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_screen_object_unit *__cil_tmp11 ;

  {
  {
#line 420
  __mptr = (struct drm_connector    *)connector;
#line 420
  __cil_tmp3 = 0 + 616;
#line 420
  __cil_tmp4 = (struct vmw_screen_object_unit *)0;
#line 420
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 420
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
#line 420
  __cil_tmp7 = (struct drm_connector *)__cil_tmp6;
#line 420
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 420
  __cil_tmp9 = (char *)__mptr;
#line 420
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
#line 420
  __cil_tmp11 = (struct vmw_screen_object_unit *)__cil_tmp10;
#line 420
  vmw_sou_destroy(__cil_tmp11);
  }
#line 421
  return;
}
}
#line 423 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static struct drm_connector_funcs vmw_legacy_connector_funcs___0  = 
#line 423
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    (void (*)(struct drm_connector *connector ))0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes,
    & vmw_du_connector_set_property, & vmw_sou_connector_destroy, (void (*)(struct drm_connector *connector ))0};
#line 433 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
static int vmw_sou_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct drm_connector_funcs    *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  bool __cil_tmp46 ;
  struct drm_encoder_funcs    *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_crtc_funcs    *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct drm_property *__cil_tmp57 ;
  uint64_t __cil_tmp58 ;

  {
  {
#line 436
  __cil_tmp9 = (unsigned long )dev_priv;
#line 436
  __cil_tmp10 = __cil_tmp9 + 2088;
#line 436
  dev = *((struct drm_device **)__cil_tmp10);
#line 441
  tmp___7 = kzalloc(2096UL, 208U);
#line 441
  sou = (struct vmw_screen_object_unit *)tmp___7;
  }
#line 442
  if (! sou) {
#line 443
    return (-12);
  } else {

  }
  {
#line 445
  __cil_tmp11 = 0 + 2032;
#line 445
  __cil_tmp12 = (unsigned long )sou;
#line 445
  __cil_tmp13 = __cil_tmp12 + __cil_tmp11;
#line 445
  *((unsigned int *)__cil_tmp13) = unit;
#line 446
  crtc = (struct drm_crtc *)sou;
#line 447
  __cil_tmp14 = 0 + 544;
#line 447
  __cil_tmp15 = (unsigned long )sou;
#line 447
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
#line 447
  encoder = (struct drm_encoder *)__cil_tmp16;
#line 448
  __cil_tmp17 = 0 + 616;
#line 448
  __cil_tmp18 = (unsigned long )sou;
#line 448
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
#line 448
  connector = (struct drm_connector *)__cil_tmp19;
#line 450
  __cil_tmp20 = (unsigned long )sou;
#line 450
  __cil_tmp21 = __cil_tmp20 + 2089;
#line 450
  *((bool *)__cil_tmp21) = (bool )0;
#line 452
  __cil_tmp22 = 0 + 2044;
#line 452
  __cil_tmp23 = (unsigned long )sou;
#line 452
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
#line 452
  __cil_tmp25 = unit == 0U;
#line 452
  *((bool *)__cil_tmp24) = (bool )__cil_tmp25;
#line 453
  __cil_tmp26 = 0 + 2036;
#line 453
  __cil_tmp27 = (unsigned long )sou;
#line 453
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
#line 453
  __cil_tmp29 = (unsigned long )dev_priv;
#line 453
  __cil_tmp30 = __cil_tmp29 + 2132;
#line 453
  *((unsigned int *)__cil_tmp28) = *((uint32_t *)__cil_tmp30);
#line 454
  __cil_tmp31 = 0 + 2040;
#line 454
  __cil_tmp32 = (unsigned long )sou;
#line 454
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
#line 454
  __cil_tmp34 = (unsigned long )dev_priv;
#line 454
  __cil_tmp35 = __cil_tmp34 + 2136;
#line 454
  *((unsigned int *)__cil_tmp33) = *((uint32_t *)__cil_tmp35);
#line 455
  __cil_tmp36 = 0 + 2048;
#line 455
  __cil_tmp37 = (unsigned long )sou;
#line 455
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
#line 455
  __cil_tmp39 = (void *)0;
#line 455
  *((struct drm_display_mode **)__cil_tmp38) = (struct drm_display_mode *)__cil_tmp39;
#line 456
  __cil_tmp40 = 0 + 2064;
#line 456
  __cil_tmp41 = (unsigned long )sou;
#line 456
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
#line 456
  *((bool *)__cil_tmp42) = (bool )1;
#line 458
  __cil_tmp43 = (struct drm_connector_funcs    *)(& vmw_legacy_connector_funcs___0);
#line 458
  drm_connector_init(dev, connector, __cil_tmp43, 15);
#line 460
  __cil_tmp44 = (unsigned long )connector;
#line 460
  __cil_tmp45 = __cil_tmp44 + 840;
#line 460
  __cil_tmp46 = (bool )1;
#line 460
  *((enum drm_connector_status *)__cil_tmp45) = vmw_du_connector_detect(connector,
                                                                        __cil_tmp46);
#line 462
  __cil_tmp47 = (struct drm_encoder_funcs    *)(& vmw_screen_object_encoder_funcs);
#line 462
  drm_encoder_init(dev, encoder, __cil_tmp47, 5);
#line 464
  drm_mode_connector_attach_encoder(connector, encoder);
#line 465
  __cil_tmp48 = (unsigned long )encoder;
#line 465
  __cil_tmp49 = __cil_tmp48 + 36;
#line 465
  __cil_tmp50 = 1 << unit;
#line 465
  *((uint32_t *)__cil_tmp49) = (uint32_t )__cil_tmp50;
#line 466
  __cil_tmp51 = (unsigned long )encoder;
#line 466
  __cil_tmp52 = __cil_tmp51 + 40;
#line 466
  *((uint32_t *)__cil_tmp52) = (uint32_t )0;
#line 468
  __cil_tmp53 = (struct drm_crtc_funcs    *)(& vmw_screen_object_crtc_funcs);
#line 468
  drm_crtc_init(dev, crtc, __cil_tmp53);
#line 470
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 472
  __cil_tmp54 = 1152 + 648;
#line 472
  __cil_tmp55 = (unsigned long )dev;
#line 472
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 472
  __cil_tmp57 = *((struct drm_property **)__cil_tmp56);
#line 472
  __cil_tmp58 = (uint64_t )1;
#line 472
  drm_connector_attach_property(connector, __cil_tmp57, __cil_tmp58);
  }
#line 476
  return (0);
}
}
#line 479 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_screen_object_display *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_screen_object_display *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct vmw_screen_object_display *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct vmw_screen_object_display *__cil_tmp49 ;
  void    *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  void *__cil_tmp53 ;

  {
#line 481
  __cil_tmp9 = (unsigned long )dev_priv;
#line 481
  __cil_tmp10 = __cil_tmp9 + 2088;
#line 481
  dev = *((struct drm_device **)__cil_tmp10);
  {
#line 484
  __cil_tmp11 = (unsigned long )dev_priv;
#line 484
  __cil_tmp12 = __cil_tmp11 + 2616;
#line 484
  if (*((struct vmw_screen_object_display **)__cil_tmp12)) {
    {
#line 485
    printk("<6>[drm] sou system already on\n");
    }
#line 486
    return (-22);
  } else {

  }
  }
  {
#line 489
  __cil_tmp13 = 1 << 9;
#line 489
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 489
  __cil_tmp15 = 1856 + 36;
#line 489
  __cil_tmp16 = (unsigned long )dev_priv;
#line 489
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 489
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
#line 489
  __cil_tmp19 = __cil_tmp18 & __cil_tmp14;
#line 489
  if (! __cil_tmp19) {
    {
#line 490
    printk("<6>[drm] Not using screen objects, missing cap SCREEN_OBJECT_2\n");
    }
#line 492
    return (-38);
  } else {

  }
  }
  {
#line 495
  ret = -12;
#line 496
  tmp___7 = kmalloc(16UL, 208U);
#line 496
  __cil_tmp20 = (unsigned long )dev_priv;
#line 496
  __cil_tmp21 = __cil_tmp20 + 2616;
#line 496
  *((struct vmw_screen_object_display **)__cil_tmp21) = (struct vmw_screen_object_display *)tmp___7;
#line 497
  __cil_tmp22 = (unsigned long )dev_priv;
#line 497
  __cil_tmp23 = __cil_tmp22 + 2616;
#line 497
  __cil_tmp24 = *((struct vmw_screen_object_display **)__cil_tmp23);
#line 497
  __cil_tmp25 = ! __cil_tmp24;
#line 497
  __cil_tmp26 = ! __cil_tmp25;
#line 497
  __cil_tmp27 = ! __cil_tmp26;
#line 497
  __cil_tmp28 = (long )__cil_tmp27;
#line 497
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  }
#line 497
  if (tmp___8) {
#line 498
    goto err_no_mem;
  } else {

  }
  {
#line 500
  __cil_tmp29 = (unsigned long )dev_priv;
#line 500
  __cil_tmp30 = __cil_tmp29 + 2616;
#line 500
  __cil_tmp31 = *((struct vmw_screen_object_display **)__cil_tmp30);
#line 500
  *((unsigned int *)__cil_tmp31) = 0U;
#line 501
  __cil_tmp32 = (unsigned long )dev_priv;
#line 501
  __cil_tmp33 = __cil_tmp32 + 2616;
#line 501
  __cil_tmp34 = *((struct vmw_screen_object_display **)__cil_tmp33);
#line 501
  __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 501
  __cil_tmp36 = __cil_tmp35 + 8;
#line 501
  __cil_tmp37 = (void *)0;
#line 501
  *((struct vmw_framebuffer **)__cil_tmp36) = (struct vmw_framebuffer *)__cil_tmp37;
#line 503
  ret = drm_vblank_init(dev, 8);
#line 504
  __cil_tmp38 = ret != 0;
#line 504
  __cil_tmp39 = ! __cil_tmp38;
#line 504
  __cil_tmp40 = ! __cil_tmp39;
#line 504
  __cil_tmp41 = (long )__cil_tmp40;
#line 504
  tmp___9 = ldv__builtin_expect(__cil_tmp41, 0L);
  }
#line 504
  if (tmp___9) {
#line 505
    goto err_free;
  } else {

  }
  {
#line 507
  ret = drm_mode_create_dirty_info_property(dev);
#line 508
  __cil_tmp42 = ret != 0;
#line 508
  __cil_tmp43 = ! __cil_tmp42;
#line 508
  __cil_tmp44 = ! __cil_tmp43;
#line 508
  __cil_tmp45 = (long )__cil_tmp44;
#line 508
  tmp___10 = ldv__builtin_expect(__cil_tmp45, 0L);
  }
#line 508
  if (tmp___10) {
#line 509
    goto err_vblank_cleanup;
  } else {

  }
#line 511
  i = 0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (i < 8) {

    } else {
#line 511
      goto while_break;
    }
    {
#line 512
    __cil_tmp46 = (unsigned int )i;
#line 512
    vmw_sou_init(dev_priv, __cil_tmp46);
#line 511
    i = i + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  printk("<6>[drm] Screen objects system initialized\n");
  }
#line 516
  return (0);
  err_vblank_cleanup: 
  {
#line 519
  drm_vblank_cleanup(dev);
  }
  err_free: 
  {
#line 521
  __cil_tmp47 = (unsigned long )dev_priv;
#line 521
  __cil_tmp48 = __cil_tmp47 + 2616;
#line 521
  __cil_tmp49 = *((struct vmw_screen_object_display **)__cil_tmp48);
#line 521
  __cil_tmp50 = (void    *)__cil_tmp49;
#line 521
  kfree(__cil_tmp50);
#line 522
  __cil_tmp51 = (unsigned long )dev_priv;
#line 522
  __cil_tmp52 = __cil_tmp51 + 2616;
#line 522
  __cil_tmp53 = (void *)0;
#line 522
  *((struct vmw_screen_object_display **)__cil_tmp52) = (struct vmw_screen_object_display *)__cil_tmp53;
  }
  err_no_mem: 
#line 524
  return (ret);
}
}
#line 527 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct vmw_screen_object_display *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_screen_object_display *__cil_tmp10 ;
  void    *__cil_tmp11 ;

  {
#line 529
  __cil_tmp3 = (unsigned long )dev_priv;
#line 529
  __cil_tmp4 = __cil_tmp3 + 2088;
#line 529
  dev = *((struct drm_device **)__cil_tmp4);
  {
#line 531
  __cil_tmp5 = (unsigned long )dev_priv;
#line 531
  __cil_tmp6 = __cil_tmp5 + 2616;
#line 531
  __cil_tmp7 = *((struct vmw_screen_object_display **)__cil_tmp6);
#line 531
  if (! __cil_tmp7) {
#line 532
    return (-38);
  } else {

  }
  }
  {
#line 534
  drm_vblank_cleanup(dev);
#line 536
  __cil_tmp8 = (unsigned long )dev_priv;
#line 536
  __cil_tmp9 = __cil_tmp8 + 2616;
#line 536
  __cil_tmp10 = *((struct vmw_screen_object_display **)__cil_tmp9);
#line 536
  __cil_tmp11 = (void    *)__cil_tmp10;
#line 536
  kfree(__cil_tmp11);
  }
#line 538
  return (0);
}
}
#line 545 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc    *__mptr ;
  struct vmw_screen_object_unit *__cil_tmp5 ;
  struct drm_crtc *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_screen_object_display *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
#line 548
  __mptr = (struct drm_crtc    *)crtc;
#line 548
  __cil_tmp5 = (struct vmw_screen_object_unit *)0;
#line 548
  __cil_tmp6 = (struct drm_crtc *)__cil_tmp5;
#line 548
  __cil_tmp7 = (unsigned int )__cil_tmp6;
#line 548
  __cil_tmp8 = (char *)__mptr;
#line 548
  __cil_tmp9 = __cil_tmp8 - __cil_tmp7;
#line 548
  sou = (struct vmw_screen_object_unit *)__cil_tmp9;
  {
#line 550
  __cil_tmp10 = 0 + 2064;
#line 550
  __cil_tmp11 = (unsigned long )sou;
#line 550
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 550
  __cil_tmp13 = *((bool *)__cil_tmp12);
#line 550
  if (! __cil_tmp13) {
#line 551
    return ((bool )1);
  } else {

  }
  }
  {
#line 553
  __cil_tmp14 = (unsigned long )dev_priv;
#line 553
  __cil_tmp15 = __cil_tmp14 + 2616;
#line 553
  __cil_tmp16 = *((struct vmw_screen_object_display **)__cil_tmp15);
#line 553
  __cil_tmp17 = *((unsigned int *)__cil_tmp16);
#line 553
  if (__cil_tmp17 != 1U) {
#line 554
    return ((bool )0);
  } else {

  }
  }
#line 556
  return ((bool )1);
}
}
#line 563 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc    *__mptr ;
  long tmp___7 ;
  struct drm_framebuffer    *__mptr___0 ;
  struct vmw_screen_object_unit *__cil_tmp7 ;
  struct drm_crtc *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct drm_framebuffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_screen_object_display *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_framebuffer *__cil_tmp30 ;
  struct drm_framebuffer *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 566
  __mptr = (struct drm_crtc    *)crtc;
#line 566
  __cil_tmp7 = (struct vmw_screen_object_unit *)0;
#line 566
  __cil_tmp8 = (struct drm_crtc *)__cil_tmp7;
#line 566
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 566
  __cil_tmp10 = (char *)__mptr;
#line 566
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 566
  sou = (struct vmw_screen_object_unit *)__cil_tmp11;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 568
    __cil_tmp12 = 0 + 2064;
#line 568
    __cil_tmp13 = (unsigned long )sou;
#line 568
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 568
    __cil_tmp15 = *((bool *)__cil_tmp14);
#line 568
    __cil_tmp16 = ! __cil_tmp15;
#line 568
    __cil_tmp17 = ! __cil_tmp16;
#line 568
    __cil_tmp18 = ! __cil_tmp17;
#line 568
    __cil_tmp19 = (long )__cil_tmp18;
#line 568
    tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
    }
#line 568
    if (tmp___7) {
      {
#line 568
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 568
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (568), "i" (12UL));
        {
#line 568
        while (1) {
          while_continue___1: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 568
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {

    }
#line 568
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  __cil_tmp20 = 0 + 32;
#line 571
  __cil_tmp21 = 0 + __cil_tmp20;
#line 571
  __cil_tmp22 = (unsigned long )sou;
#line 571
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
#line 571
  __cil_tmp24 = *((struct drm_framebuffer **)__cil_tmp23);
#line 571
  __mptr___0 = (struct drm_framebuffer    *)__cil_tmp24;
#line 571
  __cil_tmp25 = (unsigned long )dev_priv;
#line 571
  __cil_tmp26 = __cil_tmp25 + 2616;
#line 571
  __cil_tmp27 = *((struct vmw_screen_object_display **)__cil_tmp26);
#line 571
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 571
  __cil_tmp29 = __cil_tmp28 + 8;
#line 571
  __cil_tmp30 = (struct vmw_framebuffer *)0;
#line 571
  __cil_tmp31 = (struct drm_framebuffer *)__cil_tmp30;
#line 571
  __cil_tmp32 = (unsigned int )__cil_tmp31;
#line 571
  __cil_tmp33 = (char *)__mptr___0;
#line 571
  __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
#line 571
  *((struct vmw_framebuffer **)__cil_tmp29) = (struct vmw_framebuffer *)__cil_tmp34;
#line 572
  return;
}
}
#line 605 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"
void ldv_main17_sequence_infinite_withcheck_stateful(void) 
{ struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 667
  LDV_IN_INTERRUPT = 1;
#line 676
  ldv_initialize();
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp___8 = __VERIFIER_nondet_int();
    }
#line 684
    if (tmp___8) {

    } else {
#line 684
      goto while_break;
    }
    {
#line 687
    tmp___7 = __VERIFIER_nondet_int();
    }
#line 689
    if (tmp___7 == 0) {
#line 689
      goto case_0;
    } else
#line 712
    if (tmp___7 == 1) {
#line 712
      goto case_1;
    } else
#line 735
    if (tmp___7 == 2) {
#line 735
      goto case_2;
    } else
#line 758
    if (tmp___7 == 3) {
#line 758
      goto case_3;
    } else {
      {
#line 781
      goto switch_default;
#line 687
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 704
        vmw_sou_crtc_destroy(var_group1);
        }
#line 711
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 727
        vmw_sou_crtc_set_config(var_group2);
        }
#line 734
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 750
        vmw_sou_encoder_destroy(var_group3);
        }
#line 757
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 773
        vmw_sou_connector_destroy(var_group4);
        }
#line 780
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 781
        goto switch_break;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 790
  ldv_check_final_state();
  }
#line 793
  return;
}
}
