/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 86 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 19 "include/linux/types.h"
typedef __u32 nlink_t;
#line 20 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 310 "include/linux/printk.h"
struct file_operations;
#line 325 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 13 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 325
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 358 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 195 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 127 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 166 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 298 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 443
struct kmem_cache;
#line 444
struct perf_event;
#line 445 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 133 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 752 "include/linux/mmzone.h"
struct rw_semaphore;
#line 753 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 128 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 96 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
#line 113 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 886 "include/linux/mmzone.h"
struct ctl_table;
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 135 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 67 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/xen/hypervisor.h"
struct bio_vec;
#line 18 "include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 398 "include/linux/gfp.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13202_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13204_128 {
   struct __anonstruct_ldv_13202_129 ldv_13202 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13204_128 ldv_13204 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 44 "include/linux/elf.h"
struct sock;
#line 45
struct kobject;
#line 46
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 52 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_13982_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_13982_134 ldv_13982 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 648
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 342 "include/linux/irq.h"
struct proc_dir_entry;
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 180 "include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 191 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
#line 225 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 610
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
struct hotplug_slot;
#line 69 "include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 95 "include/linux/pci.h"
typedef int pci_power_t;
#line 122 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 123
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 165 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 208
struct pcie_link_state;
#line 209
struct pci_vpd;
#line 210
struct pci_sriov;
#line 211
struct pci_ats;
#line 212
struct pci_driver;
#line 212 "include/linux/pci.h"
union __anonunion_ldv_17387_137 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 212 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_17387_137 ldv_17387 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 401
struct pci_ops;
#line 401 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 492 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 513 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 526 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 536 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 566 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1070 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 1223 "include/linux/pci.h"
struct inode;
#line 42 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112
struct address_space;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18418_139 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18428_143 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18430_142 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_18428_143 ldv_18428 ;
   int units ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18432_141 {
   union __anonunion_ldv_18430_142 ldv_18430 ;
   atomic_t _count ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18433_140 {
   unsigned long counters ;
   struct __anonstruct_ldv_18432_141 ldv_18432 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18434_138 {
   union __anonunion_ldv_18418_139 ldv_18418 ;
   union __anonunion_ldv_18433_140 ldv_18433 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18441_145 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 113
struct slab;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18445_144 {
   struct list_head lru ;
   struct __anonstruct_ldv_18441_145 ldv_18441 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18450_146 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 113 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_18434_138 ldv_18434 ;
   union __anonunion_ldv_18445_144 ldv_18445 ;
   union __anonunion_ldv_18450_146 ldv_18450 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_148 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_147 {
   struct __anonstruct_linear_148 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_147 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct file_ra_state;
#line 44
struct user_struct;
#line 45
struct writeback_control;
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 1751
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_21209_150 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_21210_149 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_21209_150 ldv_21209 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_21210_149 ldv_21210 ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 447 "include/linux/slab.h"
struct pci_sysdata {
   int domain ;
   int node ;
   void *iommu ;
};
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 273 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 440 "include/linux/rculist.h"
struct hlist_bl_node;
#line 440 "include/linux/rculist.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_22869_152 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_22871_151 {
   struct __anonstruct_ldv_22869_152 ldv_22869 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_22871_151 ldv_22871 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_153 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_153 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 411 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 387
struct pid_namespace;
#line 387 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 27 "include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 30
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 21 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 30 "include/linux/blk_types.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned int bi_phys_segments ;
   unsigned int bi_size ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   struct bio_integrity_payload *bi_integrity ;
   unsigned int bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 57
struct hd_geometry;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct pipe_inode_info;
#line 61
struct poll_table_struct;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_23875_155 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_23875_155 ldv_23875 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 340 "include/linux/fs.h"
union __anonunion_arg_157 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_156 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_157 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_156 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24309_158 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24329_159 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24345_160 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_24309_158 ldv_24309 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_24329_159 ldv_24329 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_24345_160 ldv_24345 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 726 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 734 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 757 "include/linux/fs.h"
union __anonunion_f_u_161 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 757 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_161 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 900
struct files_struct;
#line 900 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 901 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 906 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 923
struct nlm_lockowner;
#line 924 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_163 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_162 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_163 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_162 fl_u ;
};
#line 1010 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1216 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1232
struct file_system_type;
#line 1232
struct super_operations;
#line 1232
struct xattr_handler;
#line 1232
struct mtd_info;
#line 1232 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1469 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1507
struct block_device_operations;
#line 1508 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1545 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1588 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1801 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_164 {
   unsigned long sig[1U] ;
};
#line 24 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_164 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_166 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_167 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_169 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_170 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_165 {
   int _pad[28U] ;
   struct __anonstruct__kill_166 _kill ;
   struct __anonstruct__timer_167 _timer ;
   struct __anonstruct__rt_168 _rt ;
   struct __anonstruct__sigchld_169 _sigchld ;
   struct __anonstruct__sigfault_170 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_165 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27310_175 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27319_176 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_177 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_178 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_27310_175 ldv_27310 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_27319_176 ldv_27319 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_177 type_data ;
   union __anonunion_payload_178 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 44 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 38 "include/linux/uio.h"
struct kioctx;
#line 39 "include/linux/uio.h"
union __anonunion_ki_obj_179 {
   void *user ;
   struct task_struct *tsk ;
};
#line 39
struct eventfd_ctx;
#line 39 "include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_179 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 161 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 181 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1051
struct rq;
#line 1052 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 2853 "include/linux/sched.h"
union __anonunion_ldv_29213_181 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 2853 "include/linux/sched.h"
union __anonunion_ldv_29217_182 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 2853 "include/linux/sched.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_ldv_29213_181 ldv_29213 ;
   union __anonunion_ldv_29217_182 ldv_29217 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 91 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   sector_t bip_sector ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned int bip_size ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_idx ;
   struct work_struct bip_work ;
   struct bio_vec bip_vec[0U] ;
};
#line 296 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_pool ;
};
#line 415 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 50 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 52 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
#line 53 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 261 "include/linux/proc_fs.h"
struct proc_ns_operations {
   char const   *name ;
   int type ;
   void *(*get)(struct task_struct * ) ;
   void (*put)(void * ) ;
   int (*install)(struct nsproxy * , void * ) ;
   unsigned int (*inum)(void * ) ;
};
#line 278 "include/linux/proc_fs.h"
union proc_op {
   int (*proc_get_link)(struct dentry * , struct path * ) ;
   int (*proc_read)(struct task_struct * , char * ) ;
   int (*proc_show)(struct seq_file * , struct pid_namespace * , struct pid * , struct task_struct * ) ;
};
#line 284 "include/linux/proc_fs.h"
struct proc_inode {
   struct pid *pid ;
   int fd ;
   union proc_op op ;
   struct proc_dir_entry *pde ;
   struct ctl_table_header *sysctl ;
   struct ctl_table *sysctl_entry ;
   void *ns ;
   struct proc_ns_operations  const  *ns_ops ;
   struct inode vfs_inode ;
};
#line 320 "include/linux/proc_fs.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 82 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 39 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 275 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 279 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 71 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 11 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 54 "include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
};
#line 81
struct bdi_writeback;
#line 39 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   unsigned long last_active ;
   struct task_struct *task ;
   struct timer_list wakeup_timer ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 65 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 63 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 25
struct request;
#line 27
struct bsg_job;
#line 28
struct blkcg_gq;
#line 47 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 48 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 67
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 79 "include/linux/blkdev.h"
union __anonunion_ldv_32525_209 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 79 "include/linux/blkdev.h"
struct __anonstruct_elv_211 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 79 "include/linux/blkdev.h"
struct __anonstruct_flush_212 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 79 "include/linux/blkdev.h"
union __anonunion_ldv_32536_210 {
   struct __anonstruct_elv_211 elv ;
   struct __anonstruct_flush_212 flush ;
};
#line 79 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct call_single_data csd ;
   struct request_queue *q ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion_ldv_32525_209 ldv_32525 ;
   union __anonunion_ldv_32536_210 ldv_32536 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   int ref_count ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 10 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 13 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 17 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 19 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 22 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 24 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 25 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 26 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 29 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 30 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 31 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 33 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 34 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 35 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * );
#line 38 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 39 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 69 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 77 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 98 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   struct hlist_head *hash ;
   unsigned char registered : 1 ;
};
#line 217 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 218 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 219 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 220 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 221 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 229 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 231 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 232 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 233 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 234 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 235
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 242 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 248 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 257 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
};
#line 286
struct throtl_data;
#line 286 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   unsigned char flush_queue_delayed : 1 ;
   unsigned char flush_pending_idx : 1 ;
   unsigned char flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2U] ;
   struct list_head flush_data_in_flight ;
   struct request flush_rq ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct list_head all_q_node ;
   struct throtl_data *td ;
};
#line 960 "include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head cb_list ;
   unsigned int should_sort ;
};
#line 1319 "include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char const   *disk_name ;
};
#line 1351 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1352 "include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1353 "include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1354 "include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1355 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1414 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   int (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1504
struct scsi_cmnd;
#line 274 "include/scsi/sg.h"
struct scsi_device;
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_PeripDev_221 {
   __u8 Dev ;
   unsigned char Bus : 6 ;
   unsigned char Mode : 2 ;
};
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_LogDev_222 {
   __u8 DevLSB ;
   unsigned char DevMSB : 6 ;
   unsigned char Mode : 2 ;
};
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_LogUnit_223 {
   unsigned char Dev : 5 ;
   unsigned char Bus : 3 ;
   unsigned char Targ : 6 ;
   unsigned char Mode : 2 ;
};
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
union _SCSI3Addr_struct {
   struct __anonstruct_PeripDev_221 PeripDev ;
   struct __anonstruct_LogDev_222 LogDev ;
   struct __anonstruct_LogUnit_223 LogUnit ;
};
#line 73 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _SCSI3Addr_struct SCSI3Addr_struct;
#line 74 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _PhysDevAddr_struct {
   unsigned int TargetId : 24 ;
   unsigned char Bus : 6 ;
   unsigned char Mode : 2 ;
   SCSI3Addr_struct Target[2U] ;
};
#line 80 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _PhysDevAddr_struct PhysDevAddr_struct;
#line 81 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _LogDevAddr_struct {
   unsigned int VolId : 30 ;
   unsigned char Mode : 2 ;
   __u8 reserved[4U] ;
};
#line 86 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _LogDevAddr_struct LogDevAddr_struct;
#line 87 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
union _LUNAddr_struct {
   __u8 LunAddrBytes[8U] ;
   SCSI3Addr_struct SCSI3Lun[4U] ;
   PhysDevAddr_struct PhysDev ;
   LogDevAddr_struct LogDev ;
};
#line 93 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _LUNAddr_struct LUNAddr_struct;
#line 94 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Type_224 {
   unsigned char Type : 3 ;
   unsigned char Attribute : 3 ;
   unsigned char Direction : 2 ;
};
#line 94 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _RequestBlock_struct {
   __u8 CDBLen ;
   struct __anonstruct_Type_224 Type ;
   __u16 Timeout ;
   __u8 CDB[16U] ;
};
#line 104 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _RequestBlock_struct RequestBlock_struct;
#line 105 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Common_Info_225 {
   __u8 Reserved[3U] ;
   __u8 Type ;
   __u32 ErrorInfo ;
};
#line 105 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Invalid_Cmd_226 {
   __u8 Reserved[2U] ;
   __u8 offense_size ;
   __u8 offense_num ;
   __u32 offense_value ;
};
#line 105 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
union _MoreErrInfo_struct {
   struct __anonstruct_Common_Info_225 Common_Info ;
   struct __anonstruct_Invalid_Cmd_226 Invalid_Cmd ;
};
#line 118 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _MoreErrInfo_struct MoreErrInfo_struct;
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _ErrorInfo_struct {
   __u8 ScsiStatus ;
   __u8 SenseLen ;
   __u16 CommandStatus ;
   __u32 ResidualCnt ;
   MoreErrInfo_struct MoreErrInfo ;
   __u8 SenseInfo[32U] ;
};
#line 126 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _ErrorInfo_struct ErrorInfo_struct;
#line 127 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _vals32 {
   __u32 lower ;
   __u32 upper ;
};
#line 70 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _vals32 vals32;
#line 71 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
union _u64bit {
   vals32 val32 ;
   __u64 val ;
};
#line 76 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef union _u64bit u64bit;
#line 77 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _InquiryData_struct {
   __u8 data_byte[36U] ;
};
#line 92 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _InquiryData_struct InquiryData_struct;
#line 93 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReportLUNdata_struct {
   __u8 LUNListLength[4U] ;
   __u32 reserved ;
   __u8 LUN[1024U][8U] ;
};
#line 102 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReportLUNdata_struct ReportLunData_struct;
#line 103 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReadCapdata_struct {
   __u8 total_size[4U] ;
   __u8 block_size[4U] ;
};
#line 109 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReadCapdata_struct ReadCapdata_struct;
#line 110 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReadCapdata_struct_16 {
   __u8 total_size[8U] ;
   __u8 block_size[4U] ;
   unsigned char prot_en : 1 ;
   unsigned char rto_en : 1 ;
   unsigned char reserved : 6 ;
   __u8 reserved2[18U] ;
};
#line 126 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReadCapdata_struct_16 ReadCapdata_struct_16;
#line 127 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CommandListHeader_struct {
   __u8 ReplyQueue ;
   __u8 SGList ;
   __u16 SGTotal ;
   vals32 Tag ;
   LUNAddr_struct LUN ;
};
#line 163 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CommandListHeader_struct CommandListHeader_struct;
#line 164 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ErrDescriptor_struct {
   vals32 Addr ;
   __u32 Len ;
};
#line 167 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ErrDescriptor_struct ErrDescriptor_struct;
#line 168 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _SGDescriptor_struct {
   vals32 Addr ;
   __u32 Len ;
   __u32 Ext ;
};
#line 172 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _SGDescriptor_struct SGDescriptor_struct;
#line 173 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CommandList_struct {
   CommandListHeader_struct Header ;
   RequestBlock_struct Request ;
   ErrDescriptor_struct ErrDesc ;
   SGDescriptor_struct SG[32U] ;
   __u32 busaddr ;
   ErrorInfo_struct *err_info ;
   int ctlr ;
   int cmd_type ;
   long cmdindex ;
   struct list_head list ;
   struct request *rq ;
   struct completion *waiting ;
   int retry_count ;
   void *scsi_cmd ;
   char pad[4U] ;
};
#line 214 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CommandList_struct CommandList_struct;
#line 215 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _HostWrite_struct {
   __u32 TransportRequest ;
   __u32 Reserved ;
   __u32 CoalIntDelay ;
   __u32 CoalIntCount ;
};
#line 222 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _HostWrite_struct HostWrite_struct;
#line 223 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CfgTable_struct {
   __u8 Signature[4U] ;
   __u32 SpecValence ;
   __u32 TransportSupport ;
   __u32 TransportActive ;
   HostWrite_struct HostWrite ;
   __u32 CmdsOutMax ;
   __u32 BusTypes ;
   __u32 TransMethodOffset ;
   __u8 ServerName[16U] ;
   __u32 HeartBeat ;
   __u32 SCSI_Prefetch ;
   __u32 MaxSGElements ;
   __u32 MaxLogicalUnits ;
   __u32 MaxPhysicalDrives ;
   __u32 MaxPhysicalDrivesPerLogicalUnit ;
   __u32 MaxPerformantModeCommands ;
   u8 reserved[32U] ;
   u32 misc_fw_support ;
   u8 driver_version[32U] ;
};
#line 249 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CfgTable_struct CfgTable_struct;
#line 250 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct TransTable_struct {
   u32 BlockFetch0 ;
   u32 BlockFetch1 ;
   u32 BlockFetch2 ;
   u32 BlockFetch3 ;
   u32 BlockFetch4 ;
   u32 BlockFetch5 ;
   u32 BlockFetch6 ;
   u32 BlockFetch7 ;
   u32 RepQSize ;
   u32 RepQCount ;
   u32 RepQCtrAddrLow32 ;
   u32 RepQCtrAddrHigh32 ;
   u32 RepQAddr0Low32 ;
   u32 RepQAddr0High32 ;
};
#line 267
struct ctlr_info;
#line 22 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
typedef struct ctlr_info ctlr_info_t;
#line 23 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct access_method {
   void (*submit_command)(ctlr_info_t * , CommandList_struct * ) ;
   void (*set_intr_mask)(ctlr_info_t * , unsigned long  ) ;
   unsigned long (*fifo_full)(ctlr_info_t * ) ;
   bool (*intr_pending)(ctlr_info_t * ) ;
   unsigned long (*command_completed)(ctlr_info_t * ) ;
};
#line 31 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct _drive_info_struct {
   unsigned char LunID[8U] ;
   int usage_count ;
   struct request_queue *queue ;
   sector_t nr_blocks ;
   int block_size ;
   int heads ;
   int sectors ;
   int cylinders ;
   int raid_level ;
   int busy_configuring ;
   struct device dev ;
   __u8 serial_no[16U] ;
   char vendor[9U] ;
   char model[17U] ;
   char rev[5U] ;
   char device_initialized ;
};
#line 56 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
typedef struct _drive_info_struct drive_info_struct;
#line 57
struct cciss_scsi_adapter_data_t;
#line 57 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct ctlr_info {
   int ctlr ;
   char devname[8U] ;
   char *product_name ;
   char firm_ver[4U] ;
   struct pci_dev *pdev ;
   __u32 board_id ;
   void *vaddr ;
   unsigned long paddr ;
   int nr_cmds ;
   CfgTable_struct *cfgtable ;
   int interrupts_enabled ;
   int major ;
   int max_commands ;
   int commands_outstanding ;
   int max_outstanding ;
   int num_luns ;
   int highest_lun ;
   int usage_count ;
   struct scatterlist **scatter_list ;
   int maxsgentries ;
   int chainsize ;
   int max_cmd_sgentries ;
   SGDescriptor_struct **cmd_sg_list ;
   unsigned int intr[4U] ;
   unsigned int msix_vector ;
   unsigned int msi_vector ;
   int intr_mode ;
   int cciss_max_sectors ;
   __u8 cciss_read ;
   __u8 cciss_write ;
   __u8 cciss_read_capacity ;
   drive_info_struct *drv[1024U] ;
   struct access_method access ;
   struct list_head reqQ ;
   struct list_head cmpQ ;
   unsigned int Qdepth ;
   unsigned int maxQsinceinit ;
   unsigned int maxSG ;
   spinlock_t lock ;
   CommandList_struct *cmd_pool ;
   dma_addr_t cmd_pool_dhandle ;
   ErrorInfo_struct *errinfo_pool ;
   dma_addr_t errinfo_pool_dhandle ;
   unsigned long *cmd_pool_bits ;
   int nr_allocs ;
   int nr_frees ;
   int busy_configuring ;
   int busy_initializing ;
   int busy_scanning ;
   struct mutex busy_shutting_down ;
   int next_to_run ;
   struct gendisk *gendisk[1024U] ;
   struct cciss_scsi_adapter_data_t *scsi_ctlr ;
   unsigned char alive ;
   struct list_head scan_list ;
   struct completion scan_wait ;
   struct device dev ;
   u32 trans_support ;
   u32 trans_offset ;
   struct TransTable_struct *transtable ;
   unsigned long transMethod ;
   u64 *reply_pool ;
   dma_addr_t reply_pool_dhandle ;
   u64 *reply_pool_head ;
   size_t reply_pool_size ;
   unsigned char reply_pool_wraparound ;
   u32 *blockFetchTable ;
};
#line 426 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct board_type {
   __u32 board_id ;
   char *product_name ;
   struct access_method *access ;
   int nr_cmds ;
};
#line 434 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct _cciss_pci_info_struct {
   unsigned char bus ;
   unsigned char dev_fn ;
   unsigned short domain ;
   __u32 board_id ;
};
#line 17 "include/uapi/linux/cciss_ioctl.h"
typedef struct _cciss_pci_info_struct cciss_pci_info_struct;
#line 18 "include/uapi/linux/cciss_ioctl.h"
struct _cciss_coalint_struct {
   __u32 delay ;
   __u32 count ;
};
#line 23 "include/uapi/linux/cciss_ioctl.h"
typedef struct _cciss_coalint_struct cciss_coalint_struct;
#line 25 "include/uapi/linux/cciss_ioctl.h"
typedef char NodeName_type[16U];
#line 27 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 Heartbeat_type;
#line 33 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 BusTypes_type;
#line 35 "include/uapi/linux/cciss_ioctl.h"
typedef char FirmwareVer_type[4U];
#line 36 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 DriverVer_type;
#line 37 "include/uapi/linux/cciss_ioctl.h"
struct _IOCTL_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u16 buf_size ;
   __u8 *buf ;
};
#line 46 "include/uapi/linux/cciss_ioctl.h"
typedef struct _IOCTL_Command_struct IOCTL_Command_struct;
#line 47 "include/uapi/linux/cciss_ioctl.h"
struct _BIG_IOCTL_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u32 malloc_size ;
   __u32 buf_size ;
   __u8 *buf ;
};
#line 56 "include/uapi/linux/cciss_ioctl.h"
typedef struct _BIG_IOCTL_Command_struct BIG_IOCTL_Command_struct;
#line 57 "include/uapi/linux/cciss_ioctl.h"
struct _LogvolInfo_struct {
   __u32 LunID ;
   int num_opens ;
   int num_parts ;
};
#line 62 "include/uapi/linux/cciss_ioctl.h"
typedef struct _LogvolInfo_struct LogvolInfo_struct;
#line 63 "include/uapi/linux/cciss_ioctl.h"
struct _IOCTL32_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u16 buf_size ;
   __u32 buf ;
};
#line 15 "include/linux/cciss_ioctl.h"
typedef struct _IOCTL32_Command_struct IOCTL32_Command_struct;
#line 16 "include/linux/cciss_ioctl.h"
struct _BIG_IOCTL32_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u32 malloc_size ;
   __u32 buf_size ;
   __u32 buf ;
};
#line 25 "include/linux/cciss_ioctl.h"
typedef struct _BIG_IOCTL32_Command_struct BIG_IOCTL32_Command_struct;
#line 443 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct Scsi_Host;
#line 445 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 37 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 53 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   unsigned char tag ;
};
#line 311
struct scsi_sense_hdr;
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 64
struct scsi_target;
#line 64
struct scsi_dh_data;
#line 64 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   unsigned int device_busy ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int lun ;
   unsigned int channel ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned char writeable : 1 ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char ordered_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char can_power_off : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned long supported_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int device_blocked ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 187 "include/scsi/scsi_device.h"
struct scsi_dh_devlist {
   char *vendor ;
   char *model ;
};
#line 194 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   struct scsi_dh_devlist  const  *devlist ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   int (*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 210 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
   char buf[0U] ;
};
#line 217
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 223 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   unsigned int reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned int target_busy ;
   unsigned int can_queue ;
   unsigned int target_blocked ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   struct execute_work ew ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 495
struct scsi_host_cmd_pool;
#line 496
struct scsi_transport_template;
#line 504 "include/scsi/scsi_device.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*transfer_response)(struct scsi_cmnd * , void (*)(struct scsi_cmnd * ) ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  , int  ) ;
   int (*change_queue_type)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*proc_info)(struct Scsi_Host * , char * , char ** , off_t  , int  , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
};
#line 518 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 528 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   struct blk_queue_tag *bqt ;
   unsigned int host_busy ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int resetting ;
   unsigned long last_reset ;
   unsigned int max_id ;
   unsigned int max_lun ;
   unsigned int max_channel ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char use_blk_tcq : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   unsigned int host_blocked ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 19 "include/scsi/scsicam.h"
struct cciss_scsi_dev_t {
   int devtype ;
   int bus ;
   int target ;
   int lun ;
   unsigned char scsi3addr[8U] ;
   unsigned char device_id[16U] ;
   unsigned char vendor[8U] ;
   unsigned char model[16U] ;
   unsigned char revision[4U] ;
};
#line 70 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.h"
struct cciss_scsi_hba_t {
   char *name ;
   int ndevices ;
   struct cciss_scsi_dev_t dev[16U] ;
};
#line 85 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_cmd_stack_elem_t {
   CommandList_struct cmd ;
   ErrorInfo_struct Err ;
   __u32 busaddr ;
   int cmdindex ;
   u8 pad[8U] ;
};
#line 107 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_cmd_stack_t {
   struct cciss_scsi_cmd_stack_elem_t *pool ;
   struct cciss_scsi_cmd_stack_elem_t **elem ;
   dma_addr_t cmd_pool_handle ;
   int top ;
   int nelems ;
};
#line 118 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_adapter_data_t {
   struct Scsi_Host *scsi_host ;
   struct cciss_scsi_cmd_stack_t cmd_stack ;
   SGDescriptor_struct **cmd_sg_list ;
   int registered ;
   spinlock_t lock ;
};
#line 372 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct scsi2map {
   char scsi3addr[8U] ;
   int bus ;
   int target ;
   int lun ;
};
#line 4513 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_Command_237 {
   CommandListHeader_struct CommandHeader ;
   RequestBlock_struct Request ;
   ErrDescriptor_struct ErrorDescriptor ;
};
#line 4513 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef struct __anonstruct_Command_237 Command;
#line 6489 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef int ldv_func_ret_type___2;
#line 6531 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef int ldv_func_ret_type___6;
#line 6547 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef struct Scsi_Host *ldv_func_ret_type___7;
#line 6632 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef int ldv_func_ret_type___15;
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 100 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 109
  return;
}
}
#line 197 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
#line 201
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 204
  return (oldbit);
}
}
#line 45 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 7 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 14 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 159 "include/linux/init.h"
extern unsigned int reset_devices ;
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 53 "include/linux/dynamic_debug.h"
extern int __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                             , ...) ;
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 358
extern int sprintf(char * , char const   *  , ...) ;
#line 361
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 61 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 88 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 41
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 159 "include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
#line 164
  len = (int )((unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U);
#line 165
  memset((void *)dst, 0, (size_t )len);
#line 167
  return;
}
}
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 823 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 825
  __edi = __edi;
#line 825
  __esi = __esi;
#line 825
  __edx = __edx;
#line 825
  __ecx = __ecx;
#line 825
  __eax = __eax;
#line 825
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 825
  if (tmp != 0L) {
#line 825
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (825), "i" (12UL));
    ldv_4725: ;
#line 825
    goto ldv_4725;
  } else {

  }
#line 825
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 825
  __ret = __eax;
#line 825
  return (__ret);
}
}
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
#line 34
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 155 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 11 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 168
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 175
int ldv_mutex_trylock_17(struct mutex *ldv_func_arg1 ) ;
#line 177
extern void mutex_unlock(struct mutex * ) ;
#line 180
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
#line 236
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) ;
#line 7 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_30(struct mutex *ldv_func_arg1 ) ;
#line 55
void ldv_mutex_lock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) ;
#line 56
int ldv_mutex_trylock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) ;
#line 59
void ldv_mutex_unlock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) ;
#line 63
void ldv_mutex_lock_cciss_mutex(struct mutex *lock ) ;
#line 67
void ldv_mutex_unlock_cciss_mutex(struct mutex *lock ) ;
#line 71
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 79
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 83
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 87
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 88
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 91
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 95
void ldv_mutex_lock_scan_mutex(struct mutex *lock ) ;
#line 99
void ldv_mutex_unlock_scan_mutex(struct mutex *lock ) ;
#line 101 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_8  ;
#line 102 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_17  ;
#line 103 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_18  ;
#line 104 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_15  ;
#line 105 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_20  ;
#line 106 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_10  ;
#line 107 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_19  ;
#line 108 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_6  ;
#line 109 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_0  ;
#line 110 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_9  ;
#line 111 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_5  ;
#line 112 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_16  ;
#line 113 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_3  ;
#line 114 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_13  ;
#line 115 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_2  ;
#line 116 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ref_cnt  ;
#line 117 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_12  ;
#line 118
extern int __VERIFIER_nondet_int(void) ;
#line 119 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_1  ;
#line 120 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_7  ;
#line 121 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_4  ;
#line 122 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_14  ;
#line 123 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_state_variable_11  ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 32
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return (& lock->ldv_5961.rlock);
}
}
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5961.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5961.rlock);
#line 336
  return;
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
#line 341
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 79
extern void wait_for_completion(struct completion * ) ;
#line 80
extern int wait_for_completion_interruptible(struct completion * ) ;
#line 91
extern void complete(struct completion * ) ;
#line 92
extern void complete_all(struct completion * ) ;
#line 53 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
#line 53
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 53
  return (ret);
}
}
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 61 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
#line 61
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 62
  return;
}
}
#line 63 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 174
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
#line 184
  tmp = ioremap_nocache(offset, size);
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 351 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
#line 366
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 80 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
#line 82
  return ((char const   *)kobj->name);
}
}
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 49 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 53
extern unsigned long copy_in_user(void * , void const   * , unsigned int  ) ;
#line 55 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 125 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 130 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
#line 133
  tmp = request_threaded_irq(irq, handler, 0, flags, name, dev);
#line 133
  return (tmp);
}
}
#line 178
extern void free_irq(unsigned int  , void * ) ;
#line 122 "include/linux/device.h"
extern int __bus_register(struct bus_type * , struct lock_class_key * ) ;
#line 124
extern void bus_unregister(struct bus_type * ) ;
#line 731 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
#line 734
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 735
    return ((char const   *)dev->init_name);
  } else {

  }
#line 737
  tmp = kobject_name(& dev->kobj);
#line 737
  return (tmp);
}
}
#line 741
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 833
extern void device_initialize(struct device * ) ;
#line 834
extern int device_add(struct device * ) ;
#line 835
extern void device_del(struct device * ) ;
#line 845
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 846
extern int dev_set_drvdata(struct device * , void * ) ;
#line 909
extern void put_device(struct device * ) ;
#line 946
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 948
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 952
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 66 "include/linux/io.h"
extern int check_signature(void const volatile   * , unsigned char const   * , int  ) ;
#line 752 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 778
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 780
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 784
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 786
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 794 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ int tmp ;

  {
#line 796
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 796
  return (tmp);
}
}
#line 798 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ int tmp ;

  {
#line 801
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 801
  return (tmp);
}
}
#line 807 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ int tmp ;

  {
#line 809
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 809
  return (tmp);
}
}
#line 811 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ int tmp ;

  {
#line 814
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 814
  return (tmp);
}
}
#line 858
extern int pci_enable_device(struct pci_dev * ) ;
#line 875
extern void pci_disable_device(struct pci_dev * ) ;
#line 917
extern int pci_save_state(struct pci_dev * ) ;
#line 918
extern void pci_restore_state(struct pci_dev * ) ;
#line 987
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 989
extern void pci_release_regions(struct pci_dev * ) ;
#line 1023
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1032
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1134
extern int pci_enable_msi_block(struct pci_dev * , unsigned int  ) ;
#line 1136
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1138
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1141
extern void pci_disable_msix(struct pci_dev * ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 

  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 34 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ struct pci_sysdata *sd ;

  {
#line 36
  sd = (struct pci_sysdata *)bus->sysdata;
#line 37
  return (sd->domain);
}
}
#line 95 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ long tmp ;
  long tmp___0 ;

  {
#line 98
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 98
  if (tmp != 0L) {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
    ldv_21601: ;
#line 98
    goto ldv_21601;
  } else {

  }
#line 99
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 99
  if (tmp___0 != 0L) {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
    ldv_21602: ;
#line 99
    goto ldv_21602;
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 205
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 207
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 63 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 

  {
#line 65
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 70 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 

  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0) && *(dev->dma_mask) != 0ULL);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 

  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_22076: ;
#line 19
    goto ldv_22076;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, 0xffffea0000000000UL + (tmp___2 >> 12), (unsigned long )ptr & 4095UL,
                            size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, 0xffffea0000000000UL + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_22085: ;
#line 36
    goto ldv_22085;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 71 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 79
  if (tmp___2 != 0L) {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_22119: ;
#line 79
    goto ldv_22119;
  } else {

  }
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, 0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 83
  return (addr);
}
}
#line 86 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 91
  if (tmp___1 != 0L) {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_22127: ;
#line 91
    goto ldv_22127;
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, 0);
  } else {

  }
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 95
  return;
}
}
#line 60 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    if ((int )gfp & 1) {
#line 110
      dma_mask = 16777215UL;
    } else {
#line 110
      dma_mask = 4294967295UL;
    }
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return (0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return (0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h",
                       166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 91 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ int tmp ;

  {
#line 93
  tmp = dma_supported(dev, mask);
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ struct device *tmp ;
  void *tmp___0 ;

  {
#line 19
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 19
    tmp = & hwdev->dev;
  } else {
#line 19
    tmp = 0;
  }
#line 19
  tmp___0 = dma_alloc_attrs(tmp, size, dma_handle, 32U, 0);
#line 19
  return (tmp___0);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
#line 26
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 26
    tmp = & hwdev->dev;
  } else {
#line 26
    tmp = 0;
  }
#line 26
  dma_free_attrs(tmp, size, vaddr, dma_handle, 0);
#line 27
  return;
}
}
#line 30 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 32
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 32
    tmp = & hwdev->dev;
  } else {
#line 32
    tmp = 0;
  }
#line 32
  tmp___0 = dma_map_single_attrs(tmp, ptr, size, (enum dma_data_direction )direction,
                                 0);
#line 32
  return (tmp___0);
}
}
#line 36 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 39
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 39
    tmp = & hwdev->dev;
  } else {
#line 39
    tmp = 0;
  }
#line 39
  dma_unmap_single_attrs(tmp, dma_addr, size, (enum dma_data_direction )direction,
                         0);
#line 40
  return;
}
}
#line 43 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 46
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 46
    tmp = & hwdev->dev;
  } else {
#line 46
    tmp = 0;
  }
#line 46
  tmp___0 = dma_map_page(tmp, page, offset, size, (enum dma_data_direction )direction);
#line 46
  return (tmp___0);
}
}
#line 50 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 53
  if ((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0)) {
#line 53
    tmp = & hwdev->dev;
  } else {
#line 53
    tmp = 0;
  }
#line 53
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
#line 54
  return;
}
}
#line 105 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;

  {
#line 107
  tmp = dma_set_mask(& dev->dev, mask);
#line 107
  return (tmp);
}
}
#line 110 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;

  {
#line 112
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 112
  return (tmp);
}
}
#line 1445 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
#line 1447
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1447
  return (tmp);
}
}
#line 1450 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
#line 1452
  dev_set_drvdata(& pdev->dev, data);
#line 1453
  return;
}
}
#line 1458 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ char const   *tmp ;

  {
#line 1460
  tmp = dev_name(& pdev->dev);
#line 1460
  return (tmp);
}
}
#line 30 "include/linux/pci-aspm.h"
extern void pci_disable_link_state(struct pci_dev * , int  ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 48
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 210 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 2043 "include/linux/fs.h"
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 2044
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 333 "include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long  ) ;
#line 334
extern void schedule(void) ;
#line 2209
extern int wake_up_process(struct task_struct * ) ;
#line 115 "include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 119
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 152
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 302 "include/linux/proc_fs.h"
__inline static struct proc_inode *PROC_I(struct inode  const  *inode ) 
{ struct inode  const  *__mptr ;

  {
#line 304
  __mptr = inode;
#line 304
  return ((struct proc_inode *)__mptr + 0xffffffffffffffc0UL);
}
}
#line 307 "include/linux/proc_fs.h"
__inline static struct proc_dir_entry *PDE(struct inode  const  *inode ) 
{ struct proc_inode *tmp ;

  {
#line 309
  tmp = PROC_I(inode);
#line 309
  return (tmp->pde);
}
}
#line 83 "include/linux/seq_file.h"
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
#line 84
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 85
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 86
extern int seq_release(struct inode * , struct file * ) ;
#line 92
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 286 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
__inline static void *compat_ptr(compat_uptr_t uptr ) 
{ 

  {
#line 288
  return ((void *)((unsigned long )uptr));
}
}
#line 632 "include/linux/compat.h"
extern void *compat_alloc_user_space(unsigned long  ) ;
#line 413 "include/linux/genhd.h"
extern void add_disk(struct gendisk * ) ;
#line 414
extern void del_gendisk(struct gendisk * ) ;
#line 443 "include/linux/genhd.h"
__inline static void set_capacity(struct gendisk *disk , sector_t size ) 
{ 

  {
#line 445
  disk->part0.nr_sects = size;
#line 446
  return;
}
}
#line 613
extern struct gendisk *alloc_disk(int  ) ;
#line 615
extern void put_disk(struct gendisk * ) ;
#line 747 "include/linux/blkdev.h"
extern int scsi_cmd_blk_ioctl(struct block_device * , fmode_t  , unsigned int  , void * ) ;
#line 775
extern void blk_start_queue(struct request_queue * ) ;
#line 776
extern void blk_stop_queue(struct request_queue * ) ;
#line 808 "include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 

  {
#line 810
  return ((sector_t )rq->__sector);
}
}
#line 813 "include/linux/blkdev.h"
__inline static unsigned int blk_rq_bytes(struct request  const  *rq ) 
{ 

  {
#line 815
  return ((unsigned int )rq->__data_len);
}
}
#line 825 "include/linux/blkdev.h"
__inline static unsigned int blk_rq_sectors(struct request  const  *rq ) 
{ unsigned int tmp ;

  {
#line 827
  tmp = blk_rq_bytes(rq);
#line 827
  return (tmp >> 9);
}
}
#line 860
extern struct request *blk_peek_request(struct request_queue * ) ;
#line 861
extern void blk_start_request(struct request * ) ;
#line 881
extern void blk_end_request_all(struct request * , int  ) ;
#line 890
extern void blk_complete_request(struct request * ) ;
#line 900
extern struct request_queue *blk_init_queue(request_fn_proc * , spinlock_t * ) ;
#line 903
extern void blk_cleanup_queue(struct request_queue * ) ;
#line 905
extern void blk_queue_bounce_limit(struct request_queue * , u64  ) ;
#line 907
extern void blk_queue_max_hw_sectors(struct request_queue * , unsigned int  ) ;
#line 908
extern void blk_queue_max_segments(struct request_queue * , unsigned short  ) ;
#line 914
extern void blk_queue_logical_block_size(struct request_queue * , unsigned short  ) ;
#line 943
extern void blk_queue_softirq_done(struct request_queue * , softirq_done_fn * ) ;
#line 950
extern int blk_rq_map_sg(struct request_queue * , struct request * , struct scatterlist * ) ;
#line 345 "include/scsi/scsi.h"
extern char const   *scsi_device_type(unsigned int  ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 149 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_tape_cmds  =    6;
#line 153 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_simple_mode  ;
#line 158 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct mutex cciss_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "cciss_mutex.wait_lock",
                                                                     0, 0UL}}}}, {& cciss_mutex.wait_list,
                                                                                  & cciss_mutex.wait_list},
    0, 0, (void *)(& cciss_mutex), {0, {0, 0}, "cciss_mutex", 0, 0UL}};
#line 159 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct proc_dir_entry *proc_cciss  ;
#line 220 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_submit_command(ctlr_info_t *h , CommandList_struct *c ) 
{ 

  {
#line 226
  writel(c->busaddr, (void volatile   *)h->vaddr + 64U);
#line 227
  readl((void const volatile   *)h->vaddr + 176U);
#line 228
  h->commands_outstanding = h->commands_outstanding + 1;
#line 229
  if (h->commands_outstanding > h->max_outstanding) {
#line 230
    h->max_outstanding = h->commands_outstanding;
  } else {

  }
#line 231
  return;
}
}
#line 238 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 

  {
#line 240
  if (val != 0UL) {
#line 242
    h->interrupts_enabled = 1;
#line 243
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 244
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 247
    h->interrupts_enabled = 0;
#line 248
    writel(8U, (void volatile   *)h->vaddr + 52U);
#line 250
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 252
  return;
}
}
#line 258 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5B_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 

  {
#line 260
  if (val != 0UL) {
#line 262
    h->interrupts_enabled = 1;
#line 263
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 264
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 267
    h->interrupts_enabled = 0;
#line 268
    writel(4U, (void volatile   *)h->vaddr + 52U);
#line 270
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 272
  return;
}
}
#line 275 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_performant_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 

  {
#line 277
  if (val != 0UL) {
#line 278
    h->interrupts_enabled = 1;
#line 279
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 280
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 282
    h->interrupts_enabled = 0;
#line 283
    writel(5U, (void volatile   *)h->vaddr + 52U);
#line 285
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 287
  return;
}
}
#line 293 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_fifo_full(ctlr_info_t *h ) 
{ 

  {
#line 295
  if (h->commands_outstanding >= h->max_commands) {
#line 296
    return (1UL);
  } else {
#line 298
    return (0UL);
  }
}
}
#line 305 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_completed(ctlr_info_t *h ) 
{ unsigned long register_value ;
  unsigned int tmp ;

  {
#line 307
  tmp = readl((void const volatile   *)h->vaddr + 68U);
#line 307
  register_value = (unsigned long )tmp;
#line 309
  if (register_value != 4294967295UL) {
#line 311
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {

  }
#line 322
  return (register_value);
}
}
#line 327 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_performant_completed(ctlr_info_t *h ) 
{ unsigned long register_value ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 329
  register_value = 4294967295UL;
#line 334
  tmp = readl((void const volatile   *)h->vaddr + 156U);
#line 334
  register_value = (unsigned long )tmp;
#line 336
  if (h->msi_vector == 0U && h->msix_vector == 0U) {
#line 337
    writel(1U, (void volatile   *)h->vaddr + 160U);
#line 341
    tmp___0 = readl((void const volatile   *)h->vaddr + 156U);
#line 341
    register_value = (unsigned long )tmp___0;
  } else {

  }
#line 344
  if ((*(h->reply_pool_head) & 1ULL) == (u64 )h->reply_pool_wraparound) {
#line 345
    register_value = (unsigned long )*(h->reply_pool_head);
#line 346
    h->reply_pool_head = h->reply_pool_head + 1;
#line 347
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {
#line 349
    register_value = 4294967295UL;
  }
#line 352
  if ((unsigned long )h->reply_pool_head == (unsigned long )(h->reply_pool + (unsigned long )h->max_commands)) {
#line 353
    h->reply_pool_head = h->reply_pool;
#line 354
    h->reply_pool_wraparound = (unsigned int )h->reply_pool_wraparound ^ 1U;
  } else {

  }
#line 357
  return (register_value);
}
}
#line 362 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5_intr_pending(ctlr_info_t *h ) 
{ unsigned long register_value ;
  unsigned int tmp ;

  {
#line 364
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 364
  register_value = (unsigned long )tmp;
#line 369
  if ((register_value & 8UL) != 0UL) {
#line 370
    return (1);
  } else {

  }
#line 371
  return (0);
}
}
#line 377 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5B_intr_pending(ctlr_info_t *h ) 
{ unsigned long register_value ;
  unsigned int tmp ;

  {
#line 379
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 379
  register_value = (unsigned long )tmp;
#line 384
  if ((register_value & 4UL) != 0UL) {
#line 385
    return (1);
  } else {

  }
#line 386
  return (0);
}
}
#line 389 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5_performant_intr_pending(ctlr_info_t *h ) 
{ unsigned long register_value ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 391
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 391
  register_value = (unsigned long )tmp;
#line 393
  if (register_value == 0UL) {
#line 394
    return (0);
  } else {

  }
#line 396
  if (h->msi_vector != 0U || h->msix_vector != 0U) {
#line 397
    return (1);
  } else {

  }
#line 400
  tmp___0 = readl((void const volatile   *)h->vaddr + 156U);
#line 400
  register_value = (unsigned long )tmp___0;
#line 401
  return ((register_value & 1UL) != 0UL);
}
}
#line 404 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5_access  =    {& SA5_submit_command, & SA5_intr_mask, & SA5_fifo_full, & SA5_intr_pending, & SA5_completed};
#line 412 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5B_access  =    {& SA5_submit_command, & SA5B_intr_mask, & SA5_fifo_full, & SA5B_intr_pending,
    & SA5_completed};
#line 420 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5_performant_access  =    {& SA5_submit_command, & SA5_performant_intr_mask, & SA5_fifo_full, & SA5_performant_intr_pending,
    & SA5_performant_completed};
#line 166 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct pci_device_id  const  cciss_pci_device_id[21U]  = 
#line 166 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
  {      {3601U, 45152U, 3601U, 16496U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16512U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16514U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16515U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16529U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16538U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16539U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16540U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16541U, 0U, 0U, 0UL}, 
        {4156U, 12832U, 4156U, 12837U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12835U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12852U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12853U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12817U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12818U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12819U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12820U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12821U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12855U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12861U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 190 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 196 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct board_type products[22U]  = 
#line 196
  {      {1081085457U, (char *)"Smart Array 5300", & SA5_access, 0}, 
        {1082134033U, (char *)"Smart Array 5i", & SA5B_access, 0}, 
        {1082265105U, (char *)"Smart Array 532", & SA5B_access, 0}, 
        {1082330641U, (char *)"Smart Array 5312", & SA5B_access, 0}, 
        {1083837969U, (char *)"Smart Array 641", & SA5_access, 0}, 
        {1083903505U, (char *)"Smart Array 642", & SA5_access, 0}, 
        {1083969041U, (char *)"Smart Array 6400", & SA5_access, 0}, 
        {1084034577U, (char *)"Smart Array 6400 EM", & SA5_access, 0}, 
        {1083248145U, (char *)"Smart Array 6i", & SA5_access, 0}, 
        {841289788U, (char *)"Smart Array P600", & SA5_access, 0}, 
        {841158716U, (char *)"Smart Array P800", & SA5_access, 0}, 
        {842272828U, (char *)"Smart Array P400", & SA5_access, 0}, 
        {842338364U, (char *)"Smart Array P400i", & SA5_access, 0}, 
        {839979068U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840044604U, (char *)"Smart Array E200", & SA5_access, 0}, 
        {840110140U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840175676U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840241212U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {842469436U, (char *)"Smart Array E500", & SA5_access, 0}, 
        {841158716U, (char *)"Smart Array P800", & SA5_access, 0}, 
        {842272828U, (char *)"Smart Array P400", & SA5_access, 0}, 
        {842862652U, (char *)"Smart Array P700m", & SA5_access, 0}};
#line 233 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ctlr_info_t *hba[32U]  ;
#line 235 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct task_struct *cciss_scan_thread  ;
#line 236 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct mutex scan_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "scan_mutex.wait_lock",
                                                                     0, 0UL}}}}, {& scan_mutex.wait_list,
                                                                                  & scan_mutex.wait_list},
    0, 0, (void *)(& scan_mutex), {0, {0, 0}, "scan_mutex", 0, 0UL}};
#line 237 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct list_head scan_q  =    {& scan_q, & scan_q};
#line 239
static void do_cciss_request(struct request_queue *q ) ;
#line 240
static irqreturn_t do_cciss_intx(int irq , void *dev_id ) ;
#line 241
static irqreturn_t do_cciss_msix_intr(int irq , void *dev_id ) ;
#line 242
static int cciss_open(struct block_device *bdev , fmode_t mode ) ;
#line 243
static int cciss_unlocked_open(struct block_device *bdev , fmode_t mode ) ;
#line 244
static int cciss_release(struct gendisk *disk , fmode_t mode ) ;
#line 245
static int do_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                    unsigned long arg ) ;
#line 247
static int cciss_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                       unsigned long arg ) ;
#line 249
static int cciss_getgeo(struct block_device *bdev , struct hd_geometry *geo ) ;
#line 251
static int cciss_revalidate(struct gendisk *disk ) ;
#line 252
static int rebuild_lun_table(ctlr_info_t *h , int first_time , int via_ioctl ) ;
#line 253
static int deregister_disk(ctlr_info_t *h , int drv_index , int clear_all , int via_ioctl ) ;
#line 256
static void cciss_read_capacity(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                unsigned int *block_size___0 ) ;
#line 258
static void cciss_read_capacity_16(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                   unsigned int *block_size___0 ) ;
#line 260
static void cciss_geometry_inquiry(ctlr_info_t *h , int logvol , sector_t total_size ,
                                   unsigned int block_size___0 , InquiryData_struct *inq_buff ,
                                   drive_info_struct *drv ) ;
#line 264
static void cciss_interrupt_mode(ctlr_info_t *h ) ;
#line 265
static int cciss_enter_simple_mode(struct ctlr_info *h ) ;
#line 266
static void start_io(ctlr_info_t *h ) ;
#line 267
static int sendcmd_withirq(ctlr_info_t *h , __u8 cmd , void *buff , size_t size ,
                           __u8 page_code , unsigned char *scsi3addr , int cmd_type ) ;
#line 270
static int sendcmd_withirq_core(ctlr_info_t *h , CommandList_struct *c , int attempt_retry ) ;
#line 272
static int process_sendcmd_error(ctlr_info_t *h , CommandList_struct *c ) ;
#line 274
static int add_to_scan_list(struct ctlr_info *h ) ;
#line 275
static int scan_thread(void *data ) ;
#line 276
static int check_for_unit_attention(ctlr_info_t *h , CommandList_struct *c ) ;
#line 277
static void cciss_hba_release(struct device *dev ) ;
#line 278
static void cciss_device_release(struct device *dev ) ;
#line 279
static void cciss_free_gendisk(ctlr_info_t *h , int drv_index ) ;
#line 280
static void cciss_free_drive_info(ctlr_info_t *h , int drv_index ) ;
#line 281
__inline static u32 next_command(ctlr_info_t *h ) ;
#line 282
static int cciss_find_cfg_addrs(struct pci_dev *pdev , void *vaddr , u32 *cfg_base_addr ,
                                u64 *cfg_base_addr_index , u64 *cfg_offset ) ;
#line 285
static int cciss_pci_find_memory_BAR(struct pci_dev *pdev , unsigned long *memory_bar ) ;
#line 287
__inline static u32 cciss_tag_discard_error_bits(ctlr_info_t *h , u32 tag ) ;
#line 288
static int write_driver_ver_to_cfgtable(CfgTable_struct *cfgtable ) ;
#line 292
static void calc_bucket_map(int *bucket , int num_buckets , int nsgs , int *bucket_map ) ;
#line 294
static void cciss_put_controller_into_performant_mode(ctlr_info_t *h ) ;
#line 297
static void cciss_procinit(ctlr_info_t *h ) ;
#line 305
static int cciss_compat_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                              unsigned long arg ) ;
#line 309 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct block_device_operations  const  cciss_fops  = 
#line 309
     {& cciss_unlocked_open, & cciss_release, & do_ioctl, & cciss_compat_ioctl, 0, 0,
    0, 0, & cciss_revalidate, & cciss_getgeo, 0, & __this_module};
#line 325 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void set_performant_mode(ctlr_info_t *h , CommandList_struct *c ) 
{ long tmp ;

  {
#line 327
  tmp = ldv__builtin_expect((h->transMethod & 4UL) != 0UL, 1L);
#line 327
  if (tmp != 0L) {
#line 328
    c->busaddr = (c->busaddr | (*(h->blockFetchTable + (unsigned long )c->Header.SGList) << 1)) | 1U;
  } else {

  }
#line 329
  return;
}
}
#line 334 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void addQ(struct list_head *list , CommandList_struct *c ) 
{ 

  {
#line 336
  list_add_tail(& c->list, list);
#line 337
  return;
}
}
#line 339 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void removeQ(CommandList_struct *c ) 
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 349
  tmp = list_empty((struct list_head  const  *)(& c->list));
#line 349
  __ret_warn_on = tmp != 0;
#line 349
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 349
  if (tmp___0 != 0L) {
#line 349
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared",
                       349);
  } else {

  }
#line 349
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 349
  if (tmp___1 != 0L) {
#line 350
    c->cmd_type = 255;
#line 351
    return;
  } else {

  }
#line 354
  list_del_init(& c->list);
#line 355
  return;
}
}
#line 357 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void enqueue_cmd_and_start_io(ctlr_info_t *h , CommandList_struct *c ) 
{ unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 361
  set_performant_mode(h, c);
#line 362
  tmp = spinlock_check(& h->lock);
#line 362
  flags = _raw_spin_lock_irqsave(tmp);
#line 363
  addQ(& h->reqQ, c);
#line 364
  h->Qdepth = h->Qdepth + 1U;
#line 365
  if (h->Qdepth > h->maxQsinceinit) {
#line 366
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 367
  start_io(h);
#line 368
  spin_unlock_irqrestore(& h->lock, flags);
#line 369
  return;
}
}
#line 371 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_sg_chain_blocks(SGDescriptor_struct **cmd_sg_list , int nr_cmds ) 
{ int i ;

  {
#line 376
  if ((unsigned long )cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0)) {
#line 377
    return;
  } else {

  }
#line 378
  i = 0;
#line 378
  goto ldv_34961;
  ldv_34960: 
#line 379
  kfree((void const   *)*(cmd_sg_list + (unsigned long )i));
#line 380
  *(cmd_sg_list + (unsigned long )i) = 0;
#line 378
  i = i + 1;
  ldv_34961: ;
#line 378
  if (i < nr_cmds) {
#line 379
    goto ldv_34960;
  } else {
#line 381
    goto ldv_34962;
  }
  ldv_34962: 
#line 382
  kfree((void const   *)cmd_sg_list);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static SGDescriptor_struct **cciss_allocate_sg_chain_blocks(ctlr_info_t *h , int chainsize ,
                                                            int nr_cmds ) 
{ int j ;
  SGDescriptor_struct **cmd_sg_list ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 391
  if (chainsize <= 0) {
#line 392
    return (0);
  } else {

  }
#line 394
  tmp = kmalloc((unsigned long )nr_cmds * 8UL, 208U);
#line 394
  cmd_sg_list = (SGDescriptor_struct **)tmp;
#line 395
  if ((unsigned long )cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0)) {
#line 396
    return (0);
  } else {

  }
#line 399
  j = 0;
#line 399
  goto ldv_34972;
  ldv_34971: 
#line 401
  tmp___0 = kmalloc((unsigned long )chainsize * 16UL, 208U);
#line 401
  *(cmd_sg_list + (unsigned long )j) = (SGDescriptor_struct *)tmp___0;
#line 403
  if ((unsigned long )*(cmd_sg_list + (unsigned long )j) == (unsigned long )((SGDescriptor_struct *)0)) {
#line 404
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Cannot get memory for s/g chains.\n");
#line 406
    goto clean;
  } else {

  }
#line 399
  j = j + 1;
  ldv_34972: ;
#line 399
  if (j < nr_cmds) {
#line 400
    goto ldv_34971;
  } else {
#line 402
    goto ldv_34973;
  }
  ldv_34973: ;
#line 409
  return (cmd_sg_list);
  clean: 
#line 411
  cciss_free_sg_chain_blocks(cmd_sg_list, nr_cmds);
#line 412
  return (0);
}
}
#line 415 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_unmap_sg_chain_block(ctlr_info_t *h , CommandList_struct *c ) 
{ SGDescriptor_struct *chain_sg ;
  u64bit temp64 ;

  {
#line 420
  if ((int )c->Header.SGTotal <= h->max_cmd_sgentries) {
#line 421
    return;
  } else {

  }
#line 423
  chain_sg = (SGDescriptor_struct *)(& c->SG) + ((unsigned long )h->max_cmd_sgentries + 0xffffffffffffffffUL);
#line 424
  temp64.val32.lower = chain_sg->Addr.lower;
#line 425
  temp64.val32.upper = chain_sg->Addr.upper;
#line 426
  pci_unmap_single(h->pdev, temp64.val, (size_t )chain_sg->Len, 1);
#line 427
  return;
}
}
#line 429 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_map_sg_chain_block(ctlr_info_t *h , CommandList_struct *c , SGDescriptor_struct *chain_block ,
                                     int len ) 
{ SGDescriptor_struct *chain_sg ;
  u64bit temp64 ;

  {
#line 435
  chain_sg = (SGDescriptor_struct *)(& c->SG) + ((unsigned long )h->max_cmd_sgentries + 0xffffffffffffffffUL);
#line 436
  chain_sg->Ext = 2147483648U;
#line 437
  chain_sg->Len = (__u32 )len;
#line 438
  temp64.val = pci_map_single(h->pdev, (void *)chain_block, (size_t )len, 1);
#line 440
  chain_sg->Addr.lower = temp64.val32.lower;
#line 441
  chain_sg->Addr.upper = temp64.val32.upper;
#line 442
  return;
}
}
#line 155 "include/scsi/scsi_cmnd.h"
extern int scsi_dma_map(struct scsi_cmnd * ) ;
#line 156
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 161 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 

  {
#line 163
  return (cmd->sdb.table.nents);
}
}
#line 166 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 

  {
#line 168
  return (cmd->sdb.table.sgl);
}
}
#line 176 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 

  {
#line 178
  cmd->sdb.resid = resid;
#line 179
  return;
}
}
#line 294 "include/scsi/scsi_device.h"
extern int scsi_add_device(struct Scsi_Host * , uint  , uint  , uint  ) ;
#line 297
extern void scsi_remove_device(struct scsi_device * ) ;
#line 301
extern void scsi_device_put(struct scsi_device * ) ;
#line 302
extern struct scsi_device *scsi_device_lookup(struct Scsi_Host * , uint  , uint  ,
                                              uint  ) ;
#line 778 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 781
struct Scsi_Host *ldv_scsi_host_alloc_9(struct scsi_host_template *sht , int privsize ) ;
#line 783
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 788
int ldv_scsi_add_host_with_dma_8(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 790
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 792
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 795
void ldv_scsi_remove_host_10(struct Scsi_Host *shost ) ;
#line 798
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 801
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 805 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ int tmp ;

  {
#line 808
  tmp = ldv_scsi_add_host_with_dma_8(host, dev, dev);
#line 808
  return (tmp);
}
}
#line 47 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int fill_cmd(ctlr_info_t *h , CommandList_struct *c , __u8 cmd , void *buff ,
                    size_t size , __u8 page_code , unsigned char *scsi3addr , int cmd_type ) ;
#line 52
static CommandList_struct *cmd_alloc(ctlr_info_t *h ) ;
#line 53
static CommandList_struct *cmd_special_alloc(ctlr_info_t *h ) ;
#line 54
static void cmd_free(ctlr_info_t *h , CommandList_struct *c ) ;
#line 55
static void cmd_special_free(ctlr_info_t *h , CommandList_struct *c ) ;
#line 57
static int cciss_scsi_proc_info(struct Scsi_Host *sh , char *buffer , char **start ,
                                off_t offset , int length , int func ) ;
#line 65
static int cciss_scsi_queue_command(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) ;
#line 67
static int cciss_eh_device_reset_handler(struct scsi_cmnd *scsicmd ) ;
#line 68
static int cciss_eh_abort_handler(struct scsi_cmnd *scsicmd ) ;
#line 70 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static struct cciss_scsi_hba_t ccissscsi[32U]  = 
#line 70
  {      {(char *)"cciss0", 0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss1",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss2",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss3",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss4",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss5",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss6",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss7",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}};
#line 81 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static struct scsi_host_template cciss_driver_template  = 
#line 81
     {& __this_module, "cciss", 0, 0, 0, 0, 0, & cciss_scsi_queue_command, 0, & cciss_eh_abort_handler,
    & cciss_eh_device_reset_handler, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cciss_scsi_proc_info,
    0, 0, "cciss", 0, 0, 7, (unsigned short)0, (unsigned short)0, (unsigned short)0,
    0UL, 1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, 0U, 0, 0, {0, 0}, 0ULL};
#line 134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static CommandList_struct *scsi_cmd_alloc(ctlr_info_t *h ) 
{ struct cciss_scsi_cmd_stack_elem_t *c ;
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  u64bit temp64 ;

  {
#line 147
  sa = h->scsi_ctlr;
#line 148
  stk = & sa->cmd_stack;
#line 150
  if (stk->top < 0) {
#line 151
    return (0);
  } else {

  }
#line 152
  c = *(stk->elem + (unsigned long )stk->top);
#line 154
  memset((void *)(& c->cmd), 0, 640UL);
#line 155
  memset((void *)(& c->Err), 0, 48UL);
#line 157
  c->cmd.busaddr = c->busaddr;
#line 158
  c->cmd.cmdindex = (long )c->cmdindex;
#line 162
  temp64.val = (unsigned long long )((unsigned long )c->busaddr + 640UL);
#line 166
  stk->top = stk->top - 1;
#line 167
  c->cmd.ErrDesc.Addr.lower = temp64.val32.lower;
#line 168
  c->cmd.ErrDesc.Addr.upper = temp64.val32.upper;
#line 169
  c->cmd.ErrDesc.Len = 48U;
#line 171
  c->cmd.ctlr = h->ctlr;
#line 172
  c->cmd.err_info = & c->Err;
#line 174
  return ((CommandList_struct *)c);
}
}
#line 178 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void scsi_cmd_free(ctlr_info_t *h , CommandList_struct *c ) 
{ struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;

  {
#line 187
  sa = h->scsi_ctlr;
#line 188
  stk = & sa->cmd_stack;
#line 189
  stk->top = stk->top + 1;
#line 190
  if (stk->top >= stk->nelems) {
#line 191
    dev_err((struct device  const  *)(& (h->pdev)->dev), "scsi_cmd_free called too many times.\n");
#line 193
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (193), "i" (12UL));
    ldv_35950: ;
#line 193
    goto ldv_35950;
  } else {

  }
#line 195
  *(stk->elem + (unsigned long )stk->top) = (struct cciss_scsi_cmd_stack_elem_t *)c;
#line 196
  return;
}
}
#line 199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int scsi_cmd_stack_setup(ctlr_info_t *h , struct cciss_scsi_adapter_data_t *sa ) 
{ int i ;
  struct cciss_scsi_cmd_stack_t *stk ;
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 205
  stk = & sa->cmd_stack;
#line 206
  stk->nelems = cciss_tape_cmds + 2;
#line 207
  sa->cmd_sg_list = cciss_allocate_sg_chain_blocks(h, h->chainsize, stk->nelems);
#line 209
  if ((unsigned long )sa->cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0) && h->chainsize > 0) {
#line 210
    return (-12);
  } else {

  }
#line 212
  size = (unsigned long )stk->nelems * 704UL;
#line 217
  tmp = pci_alloc_consistent(h->pdev, size, & stk->cmd_pool_handle);
#line 217
  stk->pool = (struct cciss_scsi_cmd_stack_elem_t *)tmp;
#line 220
  if ((unsigned long )stk->pool == (unsigned long )((struct cciss_scsi_cmd_stack_elem_t *)0)) {
#line 221
    cciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);
#line 222
    sa->cmd_sg_list = 0;
#line 223
    return (-12);
  } else {

  }
#line 225
  tmp___0 = kmalloc((unsigned long )stk->nelems * 8UL, 208U);
#line 225
  stk->elem = (struct cciss_scsi_cmd_stack_elem_t **)tmp___0;
#line 226
  if ((unsigned long )stk->elem == (unsigned long )((struct cciss_scsi_cmd_stack_elem_t **)0)) {
#line 227
    pci_free_consistent(h->pdev, size, (void *)stk->pool, stk->cmd_pool_handle);
#line 229
    return (-1);
  } else {

  }
#line 231
  i = 0;
#line 231
  goto ldv_35959;
  ldv_35958: 
#line 232
  *(stk->elem + (unsigned long )i) = stk->pool + (unsigned long )i;
#line 233
  (*(stk->elem + (unsigned long )i))->busaddr = (unsigned int )stk->cmd_pool_handle + (unsigned int )((unsigned long )i) * 704U;
#line 235
  (*(stk->elem + (unsigned long )i))->cmdindex = i;
#line 231
  i = i + 1;
  ldv_35959: ;
#line 231
  if (stk->nelems > i) {
#line 232
    goto ldv_35958;
  } else {
#line 234
    goto ldv_35960;
  }
  ldv_35960: 
#line 237
  stk->top = stk->nelems + -1;
#line 238
  return (0);
}
}
#line 242 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void scsi_cmd_stack_free(ctlr_info_t *h ) 
{ struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  size_t size ;

  {
#line 248
  sa = h->scsi_ctlr;
#line 249
  stk = & sa->cmd_stack;
#line 250
  if (stk->top != stk->nelems + -1) {
#line 251
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bug: %d scsi commands are still outstanding.\n",
             stk->nelems - stk->top);
  } else {

  }
#line 255
  size = (unsigned long )stk->nelems * 704UL;
#line 257
  pci_free_consistent(h->pdev, size, (void *)stk->pool, stk->cmd_pool_handle);
#line 258
  stk->pool = 0;
#line 259
  cciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);
#line 260
  kfree((void const   *)stk->elem);
#line 261
  stk->elem = 0;
#line 262
  return;
}
}
#line 351 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int find_bus_target_lun(ctlr_info_t *h , int *bus , int *target , int *lun ) 
{ int i ;
  int found ;
  unsigned char target_taken[16U] ;

  {
#line 355
  found = 0;
#line 358
  memset((void *)(& target_taken), 0, 16UL);
#line 360
  target_taken[15] = 1U;
#line 361
  i = 0;
#line 361
  goto ldv_35977;
  ldv_35976: 
#line 362
  target_taken[ccissscsi[h->ctlr].dev[i].target] = 1U;
#line 361
  i = i + 1;
  ldv_35977: ;
#line 361
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 362
    goto ldv_35976;
  } else {
#line 364
    goto ldv_35978;
  }
  ldv_35978: 
#line 364
  i = 0;
#line 364
  goto ldv_35981;
  ldv_35980: ;
#line 365
  if ((unsigned int )target_taken[i] == 0U) {
#line 366
    *bus = 0;
#line 366
    *target = i;
#line 366
    *lun = 0;
#line 366
    found = 1;
#line 367
    goto ldv_35979;
  } else {

  }
#line 364
  i = i + 1;
  ldv_35981: ;
#line 364
  if (i <= 15) {
#line 365
    goto ldv_35980;
  } else {
#line 367
    goto ldv_35979;
  }
  ldv_35979: ;
#line 370
  return (found == 0);
}
}
#line 378 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_add_entry(ctlr_info_t *h , int hostno , struct cciss_scsi_dev_t *device ,
                                struct scsi2map *added , int *nadded ) 
{ int n ;
  struct cciss_scsi_dev_t *sd ;
  int i ;
  int bus ;
  int target ;
  int lun ;
  unsigned char addr1[8U] ;
  unsigned char addr2[8U] ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;
  int tmp___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  char const   *tmp___1 ;

  {
#line 383
  n = ccissscsi[h->ctlr].ndevices;
#line 388
  if (n > 15) {
#line 389
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Too many devices, some will be inaccessible.\n");
#line 391
    return (-1);
  } else {

  }
#line 394
  target = -1;
#line 394
  bus = target;
#line 395
  lun = 0;
#line 398
  if ((unsigned int )device->scsi3addr[4] != 0U) {
#line 403
    __len = 8UL;
#line 403
    if (__len > 63UL) {
#line 403
      __ret = __memcpy((void *)(& addr1), (void const   *)(& device->scsi3addr), __len);
    } else {
#line 403
      __ret = __builtin_memcpy((void *)(& addr1), (void const   *)(& device->scsi3addr),
                               __len);
    }
#line 404
    addr1[4] = 0U;
#line 405
    i = 0;
#line 405
    goto ldv_36010;
    ldv_36009: 
#line 406
    sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 407
    __len___0 = 8UL;
#line 407
    if (__len___0 > 63UL) {
#line 407
      __ret___0 = __memcpy((void *)(& addr2), (void const   *)(& sd->scsi3addr), __len___0);
    } else {
#line 407
      __ret___0 = __builtin_memcpy((void *)(& addr2), (void const   *)(& sd->scsi3addr),
                                   __len___0);
    }
#line 408
    addr2[4] = 0U;
#line 410
    tmp = memcmp((void const   *)(& addr1), (void const   *)(& addr2), 8UL);
#line 410
    if (tmp == 0) {
#line 411
      bus = sd->bus;
#line 412
      target = sd->target;
#line 413
      lun = (int )device->scsi3addr[4];
#line 414
      goto ldv_36008;
    } else {

    }
#line 405
    i = i + 1;
    ldv_36010: ;
#line 405
    if (i < n) {
#line 406
      goto ldv_36009;
    } else {
#line 408
      goto ldv_36008;
    }
    ldv_36008: ;
  } else {

  }
#line 419
  sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )n;
#line 420
  if (lun == 0) {
#line 421
    tmp___0 = find_bus_target_lun(h, & sd->bus, & sd->target, & sd->lun);
#line 421
    if (tmp___0 != 0) {
#line 423
      return (-1);
    } else {
#line 425
      sd->bus = bus;
#line 426
      sd->target = target;
#line 427
      sd->lun = lun;
    }
  } else {

  }
#line 429
  (added + (unsigned long )*nadded)->bus = sd->bus;
#line 430
  (added + (unsigned long )*nadded)->target = sd->target;
#line 431
  (added + (unsigned long )*nadded)->lun = sd->lun;
#line 432
  *nadded = *nadded + 1;
#line 434
  __len___1 = 8UL;
#line 434
  if (__len___1 > 63UL) {
#line 434
    __ret___1 = __memcpy((void *)(& sd->scsi3addr), (void const   *)(& device->scsi3addr),
                         __len___1);
  } else {
#line 434
    __ret___1 = __builtin_memcpy((void *)(& sd->scsi3addr), (void const   *)(& device->scsi3addr),
                                 __len___1);
  }
#line 435
  __len___2 = 8UL;
#line 435
  if (__len___2 > 63UL) {
#line 435
    __ret___2 = __memcpy((void *)(& sd->vendor), (void const   *)(& device->vendor),
                         __len___2);
  } else {
#line 435
    __ret___2 = __builtin_memcpy((void *)(& sd->vendor), (void const   *)(& device->vendor),
                                 __len___2);
  }
#line 436
  __len___3 = 4UL;
#line 436
  if (__len___3 > 63UL) {
#line 436
    __ret___3 = __memcpy((void *)(& sd->revision), (void const   *)(& device->revision),
                         __len___3);
  } else {
#line 436
    __ret___3 = __builtin_memcpy((void *)(& sd->revision), (void const   *)(& device->revision),
                                 __len___3);
  }
#line 437
  __len___4 = 16UL;
#line 437
  if (__len___4 > 63UL) {
#line 437
    __ret___4 = __memcpy((void *)(& sd->device_id), (void const   *)(& device->device_id),
                         __len___4);
  } else {
#line 437
    __ret___4 = __builtin_memcpy((void *)(& sd->device_id), (void const   *)(& device->device_id),
                                 __len___4);
  }
#line 438
  sd->devtype = device->devtype;
#line 440
  ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices + 1;
#line 445
  if (hostno != -1) {
#line 446
    tmp___1 = scsi_device_type((unsigned int )sd->devtype);
#line 446
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s device c%db%dt%dl%d added.\n",
              tmp___1, hostno, sd->bus, sd->target, sd->lun);
  } else {

  }
#line 449
  return (0);
}
}
#line 453 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_remove_entry(ctlr_info_t *h , int hostno , int entry , struct scsi2map *removed ,
                                    int *nremoved ) 
{ int i ;
  struct cciss_scsi_dev_t sd ;
  char const   *tmp ;

  {
#line 460
  if (entry < 0 || entry > 15) {
#line 460
    return;
  } else {

  }
#line 461
  sd = ccissscsi[h->ctlr].dev[entry];
#line 462
  (removed + (unsigned long )*nremoved)->bus = sd.bus;
#line 463
  (removed + (unsigned long )*nremoved)->target = sd.target;
#line 464
  (removed + (unsigned long )*nremoved)->lun = sd.lun;
#line 465
  *nremoved = *nremoved + 1;
#line 466
  i = entry;
#line 466
  goto ldv_36033;
  ldv_36032: 
#line 467
  ccissscsi[h->ctlr].dev[i] = ccissscsi[h->ctlr].dev[i + 1];
#line 466
  i = i + 1;
  ldv_36033: ;
#line 466
  if (ccissscsi[h->ctlr].ndevices + -1 > i) {
#line 467
    goto ldv_36032;
  } else {
#line 469
    goto ldv_36034;
  }
  ldv_36034: 
#line 468
  ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices - 1;
#line 469
  tmp = scsi_device_type((unsigned int )sd.devtype);
#line 469
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s device c%db%dt%dl%d removed.\n",
            tmp, hostno, sd.bus, sd.target, sd.lun);
#line 470
  return;
}
}
#line 485 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void fixup_botched_add(ctlr_info_t *h , char *scsi3addr ) 
{ unsigned long flags ;
  int i ;
  int j ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 491
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 491
  flags = _raw_spin_lock_irqsave(tmp);
#line 492
  i = 0;
#line 492
  goto ldv_36050;
  ldv_36049: 
#line 493
  tmp___0 = memcmp((void const   *)scsi3addr, (void const   *)(& ccissscsi[h->ctlr].dev[i].scsi3addr),
                   8UL);
#line 493
  if (tmp___0 == 0) {
#line 495
    j = i;
#line 495
    goto ldv_36046;
    ldv_36045: 
#line 496
    ccissscsi[h->ctlr].dev[j] = ccissscsi[h->ctlr].dev[j + 1];
#line 495
    j = j + 1;
    ldv_36046: ;
#line 495
    if (ccissscsi[h->ctlr].ndevices + -1 > j) {
#line 496
      goto ldv_36045;
    } else {
#line 498
      goto ldv_36047;
    }
    ldv_36047: 
#line 498
    ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices - 1;
#line 499
    goto ldv_36048;
  } else {

  }
#line 492
  i = i + 1;
  ldv_36050: ;
#line 492
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 493
    goto ldv_36049;
  } else {
#line 495
    goto ldv_36048;
  }
  ldv_36048: 
#line 502
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 503
  return;
}
}
#line 505 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int device_is_the_same(struct cciss_scsi_dev_t *dev1 , struct cciss_scsi_dev_t *dev2 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 508
  if (dev1->devtype == dev2->devtype) {
#line 508
    tmp = memcmp((void const   *)(& dev1->scsi3addr), (void const   *)(& dev2->scsi3addr),
                 8UL);
#line 508
    if (tmp == 0) {
#line 508
      tmp___0 = memcmp((void const   *)(& dev1->device_id), (void const   *)(& dev2->device_id),
                       16UL);
#line 508
      if (tmp___0 == 0) {
#line 508
        tmp___1 = memcmp((void const   *)(& dev1->vendor), (void const   *)(& dev2->vendor),
                         8UL);
#line 508
        if (tmp___1 == 0) {
#line 508
          tmp___2 = memcmp((void const   *)(& dev1->model), (void const   *)(& dev2->model),
                           16UL);
#line 508
          if (tmp___2 == 0) {
#line 508
            tmp___3 = memcmp((void const   *)(& dev1->revision), (void const   *)(& dev2->revision),
                             4UL);
#line 508
            if (tmp___3 == 0) {
#line 508
              tmp___4 = 1;
            } else {
#line 508
              tmp___4 = 0;
            }
          } else {
#line 508
            tmp___4 = 0;
          }
        } else {
#line 508
          tmp___4 = 0;
        }
      } else {
#line 508
        tmp___4 = 0;
      }
    } else {
#line 508
      tmp___4 = 0;
    }
  } else {
#line 508
    tmp___4 = 0;
  }
#line 508
  return (tmp___4);
}
}
#line 522 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int adjust_cciss_scsi_table(ctlr_info_t *h , int hostno , struct cciss_scsi_dev_t *sd ,
                                   int nsds ) 
{ int i ;
  int j ;
  int found ;
  int changes ;
  struct cciss_scsi_dev_t *csd ;
  unsigned long flags ;
  struct scsi2map *added ;
  struct scsi2map *removed ;
  int nadded ;
  int nremoved ;
  struct Scsi_Host *sh ;
  void *tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___4 ;
  int tmp___5 ;
  struct scsi_device *sdev ;
  struct scsi_device *tmp___6 ;
  int rc ;

  {
#line 530
  changes = 0;
#line 535
  sh = 0;
#line 537
  tmp = kzalloc(320UL, 208U);
#line 537
  added = (struct scsi2map *)tmp;
#line 539
  tmp___0 = kzalloc(320UL, 208U);
#line 539
  removed = (struct scsi2map *)tmp___0;
#line 542
  if ((unsigned long )added == (unsigned long )((struct scsi2map *)0) || (unsigned long )removed == (unsigned long )((struct scsi2map *)0)) {
#line 543
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Out of memory in adjust_cciss_scsi_table\n");
#line 545
    goto free_and_out;
  } else {

  }
#line 548
  tmp___1 = spinlock_check(& (h->scsi_ctlr)->lock);
#line 548
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 550
  if (hostno != -1) {
#line 551
    sh = (h->scsi_ctlr)->scsi_host;
  } else {

  }
#line 556
  i = 0;
#line 557
  nremoved = 0;
#line 558
  nadded = 0;
#line 559
  goto ldv_36093;
  ldv_36092: 
#line 560
  csd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 561
  found = 0;
#line 562
  j = 0;
#line 562
  goto ldv_36078;
  ldv_36077: ;
#line 563
  if ((((((((int )(sd + (unsigned long )j)->scsi3addr[7] == (int )csd->scsi3addr[7] && (int )(sd + (unsigned long )j)->scsi3addr[6] == (int )csd->scsi3addr[6]) && (int )(sd + (unsigned long )j)->scsi3addr[5] == (int )csd->scsi3addr[5]) && (int )(sd + (unsigned long )j)->scsi3addr[4] == (int )csd->scsi3addr[4]) && (int )(sd + (unsigned long )j)->scsi3addr[3] == (int )csd->scsi3addr[3]) && (int )(sd + (unsigned long )j)->scsi3addr[2] == (int )csd->scsi3addr[2]) && (int )(sd + (unsigned long )j)->scsi3addr[1] == (int )csd->scsi3addr[1]) && (int )(sd + (unsigned long )j)->scsi3addr[0] == (int )csd->scsi3addr[0]) {
#line 565
    tmp___2 = device_is_the_same(sd + (unsigned long )j, csd);
#line 565
    if (tmp___2 != 0) {
#line 566
      found = 2;
    } else {
#line 568
      found = 1;
    }
#line 569
    goto ldv_36076;
  } else {

  }
#line 562
  j = j + 1;
  ldv_36078: ;
#line 562
  if (j < nsds) {
#line 563
    goto ldv_36077;
  } else {
#line 565
    goto ldv_36076;
  }
  ldv_36076: ;
#line 573
  if (found == 0) {
#line 574
    changes = changes + 1;
#line 575
    cciss_scsi_remove_entry(h, hostno, i, removed, & nremoved);
  } else
#line 578
  if (found == 1) {
#line 579
    changes = changes + 1;
#line 580
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "device c%db%dt%dl%d has changed.\n",
              hostno, csd->bus, csd->target, csd->lun);
#line 583
    cciss_scsi_remove_entry(h, hostno, i, removed, & nremoved);
#line 586
    tmp___3 = cciss_scsi_add_entry(h, hostno, sd + (unsigned long )j, added, & nadded);
#line 586
    if (tmp___3 != 0) {
#line 589
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                           "i" (589), "i" (12UL));
      ldv_36079: ;
#line 589
      goto ldv_36079;
    } else {

    }
#line 590
    csd->devtype = (sd + (unsigned long )j)->devtype;
#line 591
    __len = 16UL;
#line 591
    if (__len > 63UL) {
#line 591
      __ret = __memcpy((void *)(& csd->device_id), (void const   *)(& (sd + (unsigned long )j)->device_id),
                       __len);
    } else {
#line 591
      __ret = __builtin_memcpy((void *)(& csd->device_id), (void const   *)(& (sd + (unsigned long )j)->device_id),
                               __len);
    }
#line 593
    __len___0 = 8UL;
#line 593
    if (__len___0 > 63UL) {
#line 593
      __ret___0 = __memcpy((void *)(& csd->vendor), (void const   *)(& (sd + (unsigned long )j)->vendor),
                           __len___0);
    } else {
#line 593
      __ret___0 = __builtin_memcpy((void *)(& csd->vendor), (void const   *)(& (sd + (unsigned long )j)->vendor),
                                   __len___0);
    }
#line 595
    __len___1 = 16UL;
#line 595
    if (__len___1 > 63UL) {
#line 595
      __ret___1 = __memcpy((void *)(& csd->model), (void const   *)(& (sd + (unsigned long )j)->model),
                           __len___1);
    } else {
#line 595
      __ret___1 = __builtin_memcpy((void *)(& csd->model), (void const   *)(& (sd + (unsigned long )j)->model),
                                   __len___1);
    }
#line 597
    __len___2 = 4UL;
#line 597
    if (__len___2 > 63UL) {
#line 597
      __ret___2 = __memcpy((void *)(& csd->revision), (void const   *)(& (sd + (unsigned long )j)->revision),
                           __len___2);
    } else {
#line 597
      __ret___2 = __builtin_memcpy((void *)(& csd->revision), (void const   *)(& (sd + (unsigned long )j)->revision),
                                   __len___2);
    }
  } else {
#line 600
    i = i + 1;
  }
  ldv_36093: ;
#line 559
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 560
    goto ldv_36092;
  } else {
#line 562
    goto ldv_36094;
  }
  ldv_36094: 
#line 606
  i = 0;
#line 606
  goto ldv_36100;
  ldv_36099: 
#line 607
  found = 0;
#line 608
  j = 0;
#line 608
  goto ldv_36097;
  ldv_36096: 
#line 609
  csd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )j;
#line 610
  if ((((((((int )(sd + (unsigned long )i)->scsi3addr[7] == (int )csd->scsi3addr[7] && (int )(sd + (unsigned long )i)->scsi3addr[6] == (int )csd->scsi3addr[6]) && (int )(sd + (unsigned long )i)->scsi3addr[5] == (int )csd->scsi3addr[5]) && (int )(sd + (unsigned long )i)->scsi3addr[4] == (int )csd->scsi3addr[4]) && (int )(sd + (unsigned long )i)->scsi3addr[3] == (int )csd->scsi3addr[3]) && (int )(sd + (unsigned long )i)->scsi3addr[2] == (int )csd->scsi3addr[2]) && (int )(sd + (unsigned long )i)->scsi3addr[1] == (int )csd->scsi3addr[1]) && (int )(sd + (unsigned long )i)->scsi3addr[0] == (int )csd->scsi3addr[0]) {
#line 612
    tmp___4 = device_is_the_same(sd + (unsigned long )i, csd);
#line 612
    if (tmp___4 != 0) {
#line 613
      found = 2;
    } else {
#line 615
      found = 1;
    }
#line 616
    goto ldv_36095;
  } else {

  }
#line 608
  j = j + 1;
  ldv_36097: ;
#line 608
  if (ccissscsi[h->ctlr].ndevices > j) {
#line 609
    goto ldv_36096;
  } else {
#line 611
    goto ldv_36095;
  }
  ldv_36095: ;
#line 619
  if (found == 0) {
#line 620
    changes = changes + 1;
#line 621
    tmp___5 = cciss_scsi_add_entry(h, hostno, sd + (unsigned long )i, added, & nadded);
#line 621
    if (tmp___5 != 0) {
#line 623
      goto ldv_36098;
    } else {

    }
  } else
#line 624
  if (found == 1) {
#line 626
    changes = changes + 1;
#line 627
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "device unexpectedly changed\n");
  } else {

  }
#line 606
  i = i + 1;
  ldv_36100: ;
#line 606
  if (i < nsds) {
#line 607
    goto ldv_36099;
  } else {
#line 609
    goto ldv_36098;
  }
  ldv_36098: 
#line 632
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 637
  if (hostno == -1 || changes == 0) {
#line 638
    goto free_and_out;
  } else {

  }
#line 641
  i = 0;
#line 641
  goto ldv_36103;
  ldv_36102: 
#line 642
  tmp___6 = scsi_device_lookup(sh, (uint )(removed + (unsigned long )i)->bus, (uint )(removed + (unsigned long )i)->target,
                               (uint )(removed + (unsigned long )i)->lun);
#line 642
  sdev = tmp___6;
#line 645
  if ((unsigned long )sdev != (unsigned long )((struct scsi_device *)0)) {
#line 646
    scsi_remove_device(sdev);
#line 647
    scsi_device_put(sdev);
  } else {
#line 652
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "didn\'t find c%db%dt%dl%d\n for removal.",
             hostno, (removed + (unsigned long )i)->bus, (removed + (unsigned long )i)->target,
             (removed + (unsigned long )i)->lun);
  }
#line 641
  i = i + 1;
  ldv_36103: ;
#line 641
  if (i < nremoved) {
#line 642
    goto ldv_36102;
  } else {
#line 644
    goto ldv_36104;
  }
  ldv_36104: 
#line 660
  i = 0;
#line 660
  goto ldv_36108;
  ldv_36107: 
#line 662
  rc = scsi_add_device(sh, (uint )(added + (unsigned long )i)->bus, (uint )(added + (unsigned long )i)->target,
                       (uint )(added + (unsigned long )i)->lun);
#line 664
  if (rc == 0) {
#line 665
    goto ldv_36106;
  } else {

  }
#line 666
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "scsi_add_device c%db%dt%dl%d failed, device not added.\n",
           hostno, (added + (unsigned long )i)->bus, (added + (unsigned long )i)->target,
           (added + (unsigned long )i)->lun);
#line 671
  fixup_botched_add(h, (char *)(& (added + (unsigned long )i)->scsi3addr));
  ldv_36106: 
#line 660
  i = i + 1;
  ldv_36108: ;
#line 660
  if (i < nadded) {
#line 661
    goto ldv_36107;
  } else {
#line 663
    goto ldv_36109;
  }
  ldv_36109: ;
  free_and_out: 
#line 675
  kfree((void const   *)added);
#line 676
  kfree((void const   *)removed);
#line 677
  return (0);
}
}
#line 681 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int lookup_scsi3addr(ctlr_info_t *h , int bus , int target , int lun , char *scsi3addr ) 
{ int i ;
  struct cciss_scsi_dev_t *sd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 687
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 687
  flags = _raw_spin_lock_irqsave(tmp);
#line 688
  i = 0;
#line 688
  goto ldv_36127;
  ldv_36126: 
#line 689
  sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 690
  if ((sd->bus == bus && sd->target == target) && sd->lun == lun) {
#line 693
    __len = 8UL;
#line 693
    if (__len > 63UL) {
#line 693
      __ret = __memcpy((void *)scsi3addr, (void const   *)(& sd->scsi3addr), __len);
    } else {
#line 693
      __ret = __builtin_memcpy((void *)scsi3addr, (void const   *)(& sd->scsi3addr),
                               __len);
    }
#line 694
    spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 695
    return (0);
  } else {

  }
#line 688
  i = i + 1;
  ldv_36127: ;
#line 688
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 689
    goto ldv_36126;
  } else {
#line 691
    goto ldv_36128;
  }
  ldv_36128: 
#line 698
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 699
  return (-1);
}
}
#line 703 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_setup(ctlr_info_t *h ) 
{ struct cciss_scsi_adapter_data_t *shba ;
  void *tmp ;
  struct lock_class_key __key ;
  int tmp___0 ;

  {
#line 707
  ccissscsi[h->ctlr].ndevices = 0;
#line 708
  tmp = kmalloc(128UL, 208U);
#line 708
  shba = (struct cciss_scsi_adapter_data_t *)tmp;
#line 710
  if ((unsigned long )shba == (unsigned long )((struct cciss_scsi_adapter_data_t *)0)) {
#line 711
    return;
  } else {

  }
#line 712
  shba->scsi_host = 0;
#line 713
  spinlock_check(& shba->lock);
#line 713
  __raw_spin_lock_init(& shba->lock.ldv_5961.rlock, "&(&shba->lock)->rlock", & __key);
#line 714
  shba->registered = 0;
#line 715
  tmp___0 = scsi_cmd_stack_setup(h, shba);
#line 715
  if (tmp___0 != 0) {
#line 716
    kfree((void const   *)shba);
#line 717
    shba = 0;
  } else {

  }
#line 719
  h->scsi_ctlr = shba;
#line 720
  return;
}
}
#line 723 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void complete_scsi_command(CommandList_struct *c , int timeout , __u32 tag ) 
{ struct scsi_cmnd *cmd ;
  ctlr_info_t *h ;
  ErrorInfo_struct *ei ;
  size_t __len ;
  size_t tmp ;
  void *__ret ;

  {
#line 730
  ei = c->err_info;
#line 733
  if ((unsigned int )*((unsigned char *)c + 21UL) == 1U) {
#line 734
    c->cmd_type = 4;
#line 735
    return;
  } else {

  }
#line 738
  cmd = (struct scsi_cmnd *)c->scsi_cmd;
#line 739
  h = hba[c->ctlr];
#line 741
  scsi_dma_unmap(cmd);
#line 742
  if ((int )c->Header.SGTotal > h->max_cmd_sgentries) {
#line 743
    cciss_unmap_sg_chain_block(h, c);
  } else {

  }
#line 745
  cmd->result = 0;
#line 746
  cmd->result = cmd->result;
#line 749
  cmd->result = cmd->result | (int )ei->ScsiStatus;
#line 754
  if ((unsigned int )ei->SenseLen <= 96U) {
#line 754
    tmp = (size_t )ei->SenseLen;
  } else {
#line 754
    tmp = 96UL;
  }
#line 754
  __len = tmp;
#line 754
  __ret = __builtin_memcpy((void *)cmd->sense_buffer, (void const   *)(& ei->SenseInfo),
                           __len);
#line 758
  scsi_set_resid(cmd, (int )ei->ResidualCnt);
#line 760
  if ((unsigned int )ei->CommandStatus != 0U) {
#line 762
    switch ((int )ei->CommandStatus) {
    case 1: ;
#line 766
    if ((unsigned int )ei->ScsiStatus == 0U) {
#line 776
      cmd->result = 65536;
    } else {

    }
#line 778
    goto ldv_36146;
    case 2: ;
#line 780
    goto ldv_36146;
    case 3: 
#line 782
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has completed with data overrun reported\n",
             c);
#line 785
    goto ldv_36146;
    case 4: 
#line 794
    cmd->result = 65536;
#line 796
    goto ldv_36146;
    case 5: 
#line 798
    cmd->result = 458752;
#line 799
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has protocol error\n",
             c);
#line 801
    goto ldv_36146;
    case 6: 
#line 803
    cmd->result = 458752;
#line 804
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had hardware error\n",
             c);
#line 806
    goto ldv_36146;
    case 7: 
#line 808
    cmd->result = 458752;
#line 809
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had connection lost\n",
             c);
#line 811
    goto ldv_36146;
    case 8: 
#line 813
    cmd->result = 327680;
#line 814
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p was aborted\n", c);
#line 815
    goto ldv_36146;
    case 9: 
#line 817
    cmd->result = 458752;
#line 818
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p reports abort failed\n",
             c);
#line 820
    goto ldv_36146;
    case 10: 
#line 822
    cmd->result = 327680;
#line 823
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p aborted due to an unsolicited abort\n",
             c);
#line 825
    goto ldv_36146;
    case 11: 
#line 827
    cmd->result = 196608;
#line 828
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p timedout\n", c);
#line 829
    goto ldv_36146;
    case 12: 
#line 831
    cmd->result = 458752;
#line 832
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "c %p command unabortable\n",
             c);
#line 834
    goto ldv_36146;
    default: 
#line 836
    cmd->result = 458752;
#line 837
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p returned unknown status %x\n",
             c, (int )ei->CommandStatus);
    }
    ldv_36146: ;
  } else {

  }
#line 842
  (*(cmd->scsi_done))(cmd);
#line 843
  scsi_cmd_free(h, c);
#line 844
  return;
}
}
#line 847 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_detect(ctlr_info_t *h ) 
{ struct Scsi_Host *sh ;
  int error ;

  {
#line 852
  sh = ldv_scsi_host_alloc_9(& cciss_driver_template, 8);
#line 853
  if ((unsigned long )sh == (unsigned long )((struct Scsi_Host *)0)) {
#line 854
    goto fail;
  } else {

  }
#line 855
  sh->io_port = 0UL;
#line 856
  sh->n_io_port = 0U;
#line 857
  sh->this_id = 15;
#line 858
  sh->can_queue = cciss_tape_cmds;
#line 859
  sh->sg_tablesize = (unsigned short )h->maxsgentries;
#line 860
  sh->max_cmd_len = 16U;
#line 861
  sh->max_sectors = (unsigned short )h->cciss_max_sectors;
#line 864
  (h->scsi_ctlr)->scsi_host = sh;
#line 865
  sh->hostdata[0] = (unsigned long )h;
#line 866
  sh->irq = h->intr[2];
#line 867
  sh->unique_id = sh->irq;
#line 868
  error = scsi_add_host(sh, & (h->pdev)->dev);
#line 869
  if (error != 0) {
#line 870
    goto fail_host_put;
  } else {

  }
#line 871
  scsi_scan_host(sh);
#line 872
  return (1);
  fail_host_put: 
#line 875
  scsi_host_put(sh);
  fail: ;
#line 877
  return (0);
}
}
#line 881 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_unmap_one(struct pci_dev *pdev , CommandList_struct *c , size_t buflen ,
                            int data_direction ) 
{ u64bit addr64 ;

  {
#line 888
  addr64.val32.lower = c->SG[0].Addr.lower;
#line 889
  addr64.val32.upper = c->SG[0].Addr.upper;
#line 890
  pci_unmap_single(pdev, addr64.val, buflen, data_direction);
#line 891
  return;
}
}
#line 894 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_map_one(struct pci_dev *pdev , CommandList_struct *c , unsigned char *buf ,
                          size_t buflen , int data_direction ) 
{ __u64 addr64 ;

  {
#line 902
  addr64 = pci_map_single(pdev, (void *)buf, buflen, data_direction);
#line 903
  c->SG[0].Addr.lower = (unsigned int )addr64;
#line 905
  c->SG[0].Addr.upper = (unsigned int )(addr64 >> 32);
#line 907
  c->SG[0].Len = (__u32 )buflen;
#line 908
  c->Header.SGList = 1U;
#line 909
  c->Header.SGTotal = 1U;
#line 910
  return;
}
}
#line 913 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_simple_cmd(ctlr_info_t *h , CommandList_struct *c , unsigned char *scsi3addr ,
                                    unsigned char *cdb , unsigned char cdblen , unsigned char *buf ,
                                    int bufsize , int direction ) 
{ struct completion wait ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 921
  init_completion(& wait);
#line 921
  wait = wait;
#line 923
  c->cmd_type = 1;
#line 924
  c->scsi_cmd = 0;
#line 925
  c->Header.ReplyQueue = 0U;
#line 926
  __len = 8UL;
#line 926
  if (__len > 63UL) {
#line 926
    __ret = __memcpy((void *)(& c->Header.LUN), (void const   *)scsi3addr, __len);
  } else {
#line 926
    __ret = __builtin_memcpy((void *)(& c->Header.LUN), (void const   *)scsi3addr,
                             __len);
  }
#line 927
  c->Header.Tag.lower = c->busaddr;
#line 934
  memset((void *)(& c->Request.CDB), 0, 16UL);
#line 935
  __len___0 = (size_t )cdblen;
#line 935
  __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)cdb, __len___0);
#line 936
  c->Request.Timeout = 0U;
#line 937
  c->Request.CDBLen = cdblen;
#line 938
  c->Request.Type.Type = 0U;
#line 939
  c->Request.Type.Attribute = 4U;
#line 940
  c->Request.Type.Direction = (unsigned char )direction;
#line 943
  cciss_map_one(h->pdev, c, buf, (size_t )bufsize, 2);
#line 946
  c->waiting = & wait;
#line 947
  enqueue_cmd_and_start_io(h, c);
#line 948
  wait_for_completion(& wait);
#line 951
  cciss_unmap_one(h->pdev, c, (size_t )bufsize, 2);
#line 952
  return (0);
}
}
#line 956 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_interpret_error(ctlr_info_t *h , CommandList_struct *c ) 
{ ErrorInfo_struct *ei ;

  {
#line 960
  ei = c->err_info;
#line 961
  switch ((int )ei->CommandStatus) {
  case 1: 
#line 964
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has completed with errors\n",
           c);
#line 966
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has SCSI Status = %x\n",
           c, (int )ei->ScsiStatus);
#line 969
  if ((unsigned int )ei->ScsiStatus == 0U) {
#line 970
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "SCSI status is abnormally zero.  (probably indicates selection timeout reported incorrectly due to a known firmware bug, circa July, 2001.)\n");
  } else {

  }
#line 975
  goto ldv_36205;
  case 2: 
#line 977
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "UNDERRUN\n");
#line 978
  goto ldv_36205;
  case 3: 
#line 980
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has completed with data overrun reported\n",
           c);
#line 983
  goto ldv_36205;
  case 4: 
#line 987
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p is reported invalid (probably means target device no longer present)\n",
           c);
#line 993
  goto ldv_36205;
  case 5: 
#line 995
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has protocol error\n",
           c);
#line 996
  goto ldv_36205;
  case 6: 
#line 999
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had hardware error\n",
           c);
#line 1000
  goto ldv_36205;
  case 7: 
#line 1002
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had connection lost\n",
           c);
#line 1003
  goto ldv_36205;
  case 8: 
#line 1005
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p was aborted\n", c);
#line 1006
  goto ldv_36205;
  case 9: 
#line 1008
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p reports abort failed\n",
           c);
#line 1010
  goto ldv_36205;
  case 10: 
#line 1012
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p aborted due to an unsolicited abort\n",
           c);
#line 1014
  goto ldv_36205;
  case 11: 
#line 1016
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p timedout\n", c);
#line 1017
  goto ldv_36205;
  case 12: 
#line 1019
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p unabortable\n", c);
#line 1021
  goto ldv_36205;
  default: 
#line 1023
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p returned unknown status %x\n",
           c, (int )ei->CommandStatus);
  }
  ldv_36205: ;
#line 1028
  return;
}
}
#line 1030 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_inquiry(ctlr_info_t *h , unsigned char *scsi3addr , unsigned char page ,
                                 unsigned char *buf , unsigned char bufsize ) 
{ int rc ;
  CommandList_struct *c ;
  char cdb[6U] ;
  ErrorInfo_struct *ei ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1040
  tmp = spinlock_check(& h->lock);
#line 1040
  flags = _raw_spin_lock_irqsave(tmp);
#line 1041
  c = scsi_cmd_alloc(h);
#line 1042
  spin_unlock_irqrestore(& h->lock, flags);
#line 1044
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1045
    printk("cmd_alloc returned NULL!\n");
#line 1046
    return (-1);
  } else {

  }
#line 1049
  ei = c->err_info;
#line 1051
  cdb[0] = 18;
#line 1052
  cdb[1] = (unsigned int )page != 0U;
#line 1053
  cdb[2] = (char )page;
#line 1054
  cdb[3] = 0;
#line 1055
  cdb[4] = (char )bufsize;
#line 1056
  cdb[5] = 0;
#line 1057
  rc = cciss_scsi_do_simple_cmd(h, c, scsi3addr, (unsigned char *)(& cdb), 6, buf,
                                (int )bufsize, 2);
#line 1060
  if (rc != 0) {
#line 1060
    return (rc);
  } else {

  }
#line 1062
  if ((unsigned int )ei->CommandStatus != 0U && (unsigned int )ei->CommandStatus != 2U) {
#line 1064
    cciss_scsi_interpret_error(h, c);
#line 1065
    rc = -1;
  } else {

  }
#line 1067
  tmp___0 = spinlock_check(& h->lock);
#line 1067
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1068
  scsi_cmd_free(h, c);
#line 1069
  spin_unlock_irqrestore(& h->lock, flags);
#line 1070
  return (rc);
}
}
#line 1074 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_get_device_id(ctlr_info_t *h , unsigned char *scsi3addr , unsigned char *device_id ,
                                    int buflen ) 
{ int rc ;
  unsigned char *buf ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1080
  if (buflen > 16) {
#line 1081
    buflen = 16;
  } else {

  }
#line 1082
  tmp = kzalloc(64UL, 208U);
#line 1082
  buf = (unsigned char *)tmp;
#line 1083
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0)) {
#line 1084
    return (-1);
  } else {

  }
#line 1085
  rc = cciss_scsi_do_inquiry(h, scsi3addr, 131, buf, 64);
#line 1086
  if (rc == 0) {
#line 1087
    __len = (size_t )buflen;
#line 1087
    __ret = __builtin_memcpy((void *)device_id, (void const   *)buf + 8U, __len);
  } else {

  }
#line 1088
  kfree((void const   *)buf);
#line 1089
  return (rc != 0);
}
}
#line 1093 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_report_phys_luns(ctlr_info_t *h , ReportLunData_struct *buf ,
                                          int bufsize ) 
{ int rc ;
  CommandList_struct *c ;
  unsigned char cdb[12U] ;
  unsigned char scsi3addr[8U] ;
  ErrorInfo_struct *ei ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1103
  tmp = spinlock_check(& h->lock);
#line 1103
  flags = _raw_spin_lock_irqsave(tmp);
#line 1104
  c = scsi_cmd_alloc(h);
#line 1105
  spin_unlock_irqrestore(& h->lock, flags);
#line 1106
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1107
    printk("cmd_alloc returned NULL!\n");
#line 1108
    return (-1);
  } else {

  }
#line 1111
  memset((void *)(& scsi3addr), 0, 8UL);
#line 1112
  cdb[0] = 195U;
#line 1113
  cdb[1] = 0U;
#line 1114
  cdb[2] = 0U;
#line 1115
  cdb[3] = 0U;
#line 1116
  cdb[4] = 0U;
#line 1117
  cdb[5] = 0U;
#line 1118
  cdb[6] = (unsigned char )((unsigned int )bufsize >> 24);
#line 1119
  cdb[7] = (unsigned char )(bufsize >> 16);
#line 1120
  cdb[8] = (unsigned char )(bufsize >> 8);
#line 1121
  cdb[9] = (unsigned char )bufsize;
#line 1122
  cdb[10] = 0U;
#line 1123
  cdb[11] = 0U;
#line 1125
  rc = cciss_scsi_do_simple_cmd(h, c, (unsigned char *)(& scsi3addr), (unsigned char *)(& cdb),
                                12, (unsigned char *)buf, bufsize, 2);
#line 1130
  if (rc != 0) {
#line 1130
    return (rc);
  } else {

  }
#line 1132
  ei = c->err_info;
#line 1133
  if ((unsigned int )ei->CommandStatus != 0U && (unsigned int )ei->CommandStatus != 2U) {
#line 1135
    cciss_scsi_interpret_error(h, c);
#line 1136
    rc = -1;
  } else {

  }
#line 1138
  tmp___0 = spinlock_check(& h->lock);
#line 1138
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1139
  scsi_cmd_free(h, c);
#line 1140
  spin_unlock_irqrestore(& h->lock, flags);
#line 1141
  return (rc);
}
}
#line 1145 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_update_non_disk_devices(ctlr_info_t *h , int hostno ) 
{ ReportLunData_struct *ld_buff ;
  unsigned char *inq_buff ;
  unsigned char scsi3addr[8U] ;
  __u32 num_luns ;
  unsigned char *ch ;
  struct cciss_scsi_dev_t *currentsd ;
  struct cciss_scsi_dev_t *this_device ;
  int ncurrent ;
  int reportlunsize ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  int tmp___3 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  char obdr_sig[7U] ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1178
  num_luns = 0U;
#line 1181
  ncurrent = 0;
#line 1182
  reportlunsize = 16392;
#line 1185
  tmp = kzalloc((size_t )reportlunsize, 208U);
#line 1185
  ld_buff = (ReportLunData_struct *)tmp;
#line 1186
  tmp___0 = kmalloc(49UL, 208U);
#line 1186
  inq_buff = (unsigned char *)tmp___0;
#line 1187
  tmp___1 = kzalloc(1156UL, 208U);
#line 1187
  currentsd = (struct cciss_scsi_dev_t *)tmp___1;
#line 1189
  if (((unsigned long )ld_buff == (unsigned long )((ReportLunData_struct *)0) || (unsigned long )inq_buff == (unsigned long )((unsigned char *)0)) || (unsigned long )currentsd == (unsigned long )((struct cciss_scsi_dev_t *)0)) {
#line 1190
    printk("\vcciss: out of memory\n");
#line 1191
    goto out;
  } else {

  }
#line 1193
  this_device = currentsd + 16UL;
#line 1194
  tmp___2 = cciss_scsi_do_report_phys_luns(h, ld_buff, reportlunsize);
#line 1194
  if (tmp___2 == 0) {
#line 1195
    ch = (unsigned char *)(& ld_buff->LUNListLength);
#line 1196
    num_luns = (__u32 )((((((int )*ch << 24) | ((int )*(ch + 1UL) << 16)) | ((int )*(ch + 2UL) << 8)) | (int )*(ch + 3UL)) / 8);
#line 1197
    if (num_luns > 1024U) {
#line 1198
      printk("\fcciss: Maximum physical LUNs (%d) exceeded.  %d LUNs ignored.\n",
             1024, num_luns - 1024U);
#line 1202
      num_luns = 1024U;
    } else {

    }
  } else {
#line 1206
    printk("\vcciss: Report physical LUNs failed.\n");
#line 1207
    goto out;
  }
#line 1212
  i = 0;
#line 1212
  goto ldv_36302;
  ldv_36301: ;
#line 1214
  if (((int )ld_buff->LUN[i][3] & 192) != 0) {
#line 1214
    goto ldv_36279;
  } else {

  }
#line 1215
  memset((void *)inq_buff, 0, 49UL);
#line 1216
  __len = 8UL;
#line 1216
  if (__len > 63UL) {
#line 1216
    __ret = __memcpy((void *)(& scsi3addr), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                     __len);
  } else {
#line 1216
    __ret = __builtin_memcpy((void *)(& scsi3addr), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                             __len);
  }
#line 1218
  tmp___3 = cciss_scsi_do_inquiry(h, (unsigned char *)(& scsi3addr), 0, inq_buff,
                                  49);
#line 1218
  if (tmp___3 != 0) {
#line 1221
    goto ldv_36279;
  } else {

  }
#line 1223
  this_device->devtype = (int )*inq_buff & 31;
#line 1224
  this_device->bus = -1;
#line 1225
  this_device->target = -1;
#line 1226
  this_device->lun = -1;
#line 1227
  __len___0 = 8UL;
#line 1227
  if (__len___0 > 63UL) {
#line 1227
    __ret___0 = __memcpy((void *)(& this_device->scsi3addr), (void const   *)(& scsi3addr),
                         __len___0);
  } else {
#line 1227
    __ret___0 = __builtin_memcpy((void *)(& this_device->scsi3addr), (void const   *)(& scsi3addr),
                                 __len___0);
  }
#line 1228
  __len___1 = 8UL;
#line 1228
  if (__len___1 > 63UL) {
#line 1228
    __ret___1 = __memcpy((void *)(& this_device->vendor), (void const   *)inq_buff + 8U,
                         __len___1);
  } else {
#line 1228
    __ret___1 = __builtin_memcpy((void *)(& this_device->vendor), (void const   *)inq_buff + 8U,
                                 __len___1);
  }
#line 1230
  __len___2 = 16UL;
#line 1230
  if (__len___2 > 63UL) {
#line 1230
    __ret___2 = __memcpy((void *)(& this_device->model), (void const   *)inq_buff + 16U,
                         __len___2);
  } else {
#line 1230
    __ret___2 = __builtin_memcpy((void *)(& this_device->model), (void const   *)inq_buff + 16U,
                                 __len___2);
  }
#line 1232
  __len___3 = 4UL;
#line 1232
  if (__len___3 > 63UL) {
#line 1232
    __ret___3 = __memcpy((void *)(& this_device->revision), (void const   *)inq_buff + 32U,
                         __len___3);
  } else {
#line 1232
    __ret___3 = __builtin_memcpy((void *)(& this_device->revision), (void const   *)inq_buff + 32U,
                                 __len___3);
  }
#line 1234
  memset((void *)(& this_device->device_id), 0, 16UL);
#line 1236
  cciss_scsi_get_device_id(h, (unsigned char *)(& scsi3addr), (unsigned char *)(& this_device->device_id),
                           16);
#line 1239
  switch (this_device->devtype) {
  case 5: 
#line 1252
  strncpy((char *)(& obdr_sig), (char const   *)inq_buff + 43U, 6UL);
#line 1253
  obdr_sig[6] = 0;
#line 1254
  tmp___4 = strncmp((char const   *)(& obdr_sig), "$DR-10", 6UL);
#line 1254
  if (tmp___4 != 0) {
#line 1256
    goto ldv_36297;
  } else {

  }
  case 1: ;
  case 8: ;
#line 1261
  if (ncurrent > 15) {
#line 1262
    tmp___5 = scsi_device_type((unsigned int )this_device->devtype);
#line 1262
    printk("\016cciss%d: %s ignored, too many devices.\n", h->ctlr, tmp___5);
#line 1265
    goto ldv_36297;
  } else {

  }
#line 1267
  *(currentsd + (unsigned long )ncurrent) = *this_device;
#line 1268
  ncurrent = ncurrent + 1;
#line 1269
  goto ldv_36297;
  default: ;
#line 1271
  goto ldv_36297;
  }
  ldv_36297: ;
  ldv_36279: 
#line 1212
  i = i + 1;
  ldv_36302: ;
#line 1212
  if ((__u32 )i < num_luns) {
#line 1213
    goto ldv_36301;
  } else {
#line 1215
    goto ldv_36303;
  }
  ldv_36303: 
#line 1275
  adjust_cciss_scsi_table(h, hostno, currentsd, ncurrent);
  out: 
#line 1277
  kfree((void const   *)inq_buff);
#line 1278
  kfree((void const   *)ld_buff);
#line 1279
  kfree((void const   *)currentsd);
#line 1280
  return;
}
}
#line 1284 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int is_keyword(char *ptr , int len , char *verb ) 
{ int verb_len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1286
  tmp = strlen((char const   *)verb);
#line 1286
  verb_len = (int )tmp;
#line 1287
  if (len >= verb_len) {
#line 1287
    tmp___0 = memcmp((void const   *)verb, (void const   *)ptr, (size_t )verb_len);
#line 1287
    if (tmp___0 == 0) {
#line 1288
      return (verb_len);
    } else {
#line 1290
      return (0);
    }
  } else {
#line 1290
    return (0);
  }
}
}
#line 1294 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_user_command(ctlr_info_t *h , int hostno , char *buffer , int length ) 
{ int arg_len ;

  {
#line 1298
  arg_len = is_keyword(buffer, length, (char *)"rescan");
#line 1298
  if (arg_len != 0) {
#line 1299
    cciss_update_non_disk_devices(h, hostno);
  } else {
#line 1301
    return (-22);
  }
#line 1302
  return (length);
}
}
#line 1307 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_proc_info(struct Scsi_Host *sh , char *buffer , char **start ,
                                off_t offset , int length , int func ) 
{ int buflen ;
  int datalen ;
  ctlr_info_t *h ;
  int i ;
  struct cciss_scsi_dev_t *sd ;
  int tmp ;
  int tmp___0 ;

  {
#line 1319
  h = (ctlr_info_t *)sh->hostdata[0];
#line 1320
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1321
    return (-22);
  } else {

  }
#line 1323
  if (func == 0) {
#line 1324
    buflen = sprintf(buffer, "cciss%d: SCSI host: %d\n", h->ctlr, sh->host_no);
#line 1335
    i = 0;
#line 1335
    goto ldv_36331;
    ldv_36330: 
#line 1336
    sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 1338
    tmp = sprintf(buffer + (unsigned long )buflen, "c%db%dt%dl%d %02d 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
                  sh->host_no, sd->bus, sd->target, sd->lun, sd->devtype, (int )sd->scsi3addr[0],
                  (int )sd->scsi3addr[1], (int )sd->scsi3addr[2], (int )sd->scsi3addr[3],
                  (int )sd->scsi3addr[4], (int )sd->scsi3addr[5], (int )sd->scsi3addr[6],
                  (int )sd->scsi3addr[7]);
#line 1338
    buflen = tmp + buflen;
#line 1335
    i = i + 1;
    ldv_36331: ;
#line 1335
    if (ccissscsi[h->ctlr].ndevices > i) {
#line 1336
      goto ldv_36330;
    } else {
#line 1338
      goto ldv_36332;
    }
    ldv_36332: 
#line 1347
    datalen = (int )((unsigned int )buflen - (unsigned int )offset);
#line 1348
    if (datalen < 0) {
#line 1349
      datalen = 0;
#line 1350
      *start = buffer + (unsigned long )buflen;
    } else {
#line 1352
      *start = buffer + (unsigned long )offset;
    }
#line 1353
    return (datalen);
  } else {
#line 1355
    tmp___0 = cciss_scsi_user_command(h, (int )sh->host_no, buffer, length);
#line 1355
    return (tmp___0);
  }
}
}
#line 1363 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scatter_gather(ctlr_info_t *h , CommandList_struct *c , struct scsi_cmnd *cmd ) 
{ unsigned int len ;
  struct scatterlist *sg ;
  __u64 addr64 ;
  int request_nsgs ;
  int i ;
  int chained ;
  int sg_index ;
  struct cciss_scsi_adapter_data_t *sa ;
  SGDescriptor_struct *curr_sg ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 1370
  sa = h->scsi_ctlr;
#line 1373
  tmp = scsi_sg_count(cmd);
#line 1373
  tmp___0 = ldv__builtin_expect(tmp > (unsigned int )h->maxsgentries, 0L);
#line 1373
  if (tmp___0 != 0L) {
#line 1373
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (1373), "i" (12UL));
    ldv_36347: ;
#line 1373
    goto ldv_36347;
  } else {

  }
#line 1375
  chained = 0;
#line 1376
  sg_index = 0;
#line 1377
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 1378
  request_nsgs = scsi_dma_map(cmd);
#line 1379
  if (request_nsgs != 0) {
#line 1380
    i = 0;
#line 1380
    sg = scsi_sglist(cmd);
#line 1380
    goto ldv_36349;
    ldv_36348: ;
#line 1381
    if ((sg_index + 1 == h->max_cmd_sgentries && chained == 0) && request_nsgs - i > 1) {
#line 1383
      chained = 1;
#line 1384
      sg_index = 0;
#line 1385
      curr_sg = *(sa->cmd_sg_list + (unsigned long )c->cmdindex);
    } else {

    }
#line 1387
    addr64 = sg->dma_address;
#line 1388
    len = sg->dma_length;
#line 1389
    (curr_sg + (unsigned long )sg_index)->Addr.lower = (unsigned int )addr64;
#line 1391
    (curr_sg + (unsigned long )sg_index)->Addr.upper = (unsigned int )(addr64 >> 32);
#line 1393
    (curr_sg + (unsigned long )sg_index)->Len = len;
#line 1394
    (curr_sg + (unsigned long )sg_index)->Ext = 0U;
#line 1395
    sg_index = sg_index + 1;
#line 1380
    i = i + 1;
#line 1380
    sg = sg_next(sg);
    ldv_36349: ;
#line 1380
    if (i < request_nsgs) {
#line 1381
      goto ldv_36348;
    } else {
#line 1383
      goto ldv_36350;
    }
    ldv_36350: ;
#line 1397
    if (chained != 0) {
#line 1398
      cciss_map_sg_chain_block(h, c, *(sa->cmd_sg_list + (unsigned long )c->cmdindex),
                               (int )((unsigned int )((1 - h->max_cmd_sgentries) + request_nsgs) * 16U));
    } else {

    }
  } else {

  }
#line 1404
  if ((unsigned int )request_nsgs > h->maxSG) {
#line 1405
    h->maxSG = (unsigned int )request_nsgs;
  } else {

  }
#line 1406
  c->Header.SGTotal = (int )((__u16 )request_nsgs) + (int )((__u16 )chained);
#line 1407
  if (h->max_cmd_sgentries < request_nsgs) {
#line 1408
    c->Header.SGList = (__u8 )h->max_cmd_sgentries;
  } else {
#line 1410
    c->Header.SGList = (__u8 )c->Header.SGTotal;
  }
#line 1411
  return;
}
}
#line 1416 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd , void (*done)(struct scsi_cmnd * ) ) 
{ ctlr_info_t *h ;
  int rc ;
  unsigned char scsi3addr[8U] ;
  CommandList_struct *c ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  long tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1426
  h = (ctlr_info_t *)((cmd->device)->host)->hostdata[0];
#line 1428
  rc = lookup_scsi3addr(h, (int )(cmd->device)->channel, (int )(cmd->device)->id,
                        (int )(cmd->device)->lun, (char *)(& scsi3addr));
#line 1430
  if (rc != 0) {
#line 1433
    cmd->result = 65536;
#line 1434
    (*done)(cmd);
#line 1437
    return (0);
  } else {

  }
#line 1443
  tmp = spinlock_check(& h->lock);
#line 1443
  flags = _raw_spin_lock_irqsave(tmp);
#line 1444
  c = scsi_cmd_alloc(h);
#line 1445
  spin_unlock_irqrestore(& h->lock, flags);
#line 1446
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1447
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "scsi_cmd_alloc returned NULL!\n");
#line 1449
    cmd->result = 65536;
#line 1450
    (*done)(cmd);
#line 1451
    return (0);
  } else {

  }
#line 1456
  cmd->scsi_done = done;
#line 1459
  cmd->host_scribble = (unsigned char *)c;
#line 1461
  c->cmd_type = 3;
#line 1462
  c->scsi_cmd = (void *)cmd;
#line 1463
  c->Header.ReplyQueue = 0U;
#line 1464
  __len = 8UL;
#line 1464
  if (__len > 63UL) {
#line 1464
    __ret = __memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)(& scsi3addr),
                     __len);
  } else {
#line 1464
    __ret = __builtin_memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)(& scsi3addr),
                             __len);
  }
#line 1465
  c->Header.Tag.lower = c->busaddr;
#line 1469
  c->Request.Timeout = 0U;
#line 1470
  memset((void *)(& c->Request.CDB), 0, 16UL);
#line 1471
  tmp___0 = ldv__builtin_expect((unsigned int )cmd->cmd_len > 16U, 0L);
#line 1471
  if (tmp___0 != 0L) {
#line 1471
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (1471), "i" (12UL));
    ldv_36367: ;
#line 1471
    goto ldv_36367;
  } else {

  }
#line 1472
  c->Request.CDBLen = (__u8 )cmd->cmd_len;
#line 1473
  __len___0 = (size_t )cmd->cmd_len;
#line 1473
  __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)cmd->cmnd,
                               __len___0);
#line 1474
  c->Request.Type.Type = 0U;
#line 1475
  c->Request.Type.Attribute = 4U;
#line 1476
  switch ((unsigned int )cmd->sc_data_direction) {
  case 1: 
#line 1479
  c->Request.Type.Direction = 1U;
#line 1480
  goto ldv_36372;
  case 2: 
#line 1482
  c->Request.Type.Direction = 2U;
#line 1483
  goto ldv_36372;
  case 3: 
#line 1485
  c->Request.Type.Direction = 0U;
#line 1486
  goto ldv_36372;
  case 0: 
#line 1492
  c->Request.Type.Direction = 3U;
#line 1500
  goto ldv_36372;
  default: 
#line 1503
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown data direction: %d\n",
           (unsigned int )cmd->sc_data_direction);
#line 1505
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                       "i" (1505), "i" (12UL));
  ldv_36377: ;
#line 1505
  goto ldv_36377;
  }
  ldv_36372: 
#line 1508
  cciss_scatter_gather(h, c, cmd);
#line 1509
  enqueue_cmd_and_start_io(h, c);
#line 1511
  return (0);
}
}
#line 1514 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_queue_command(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ unsigned long irq_flags ;
  int rc ;
  raw_spinlock_t *tmp ;

  {
#line 1514
  tmp = spinlock_check(shost->host_lock);
#line 1514
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1514
  scsi_cmd_get_serial(shost, cmd);
#line 1514
  rc = cciss_scsi_queue_command_lck(cmd, cmd->scsi_done);
#line 1514
  spin_unlock_irqrestore(shost->host_lock, irq_flags);
#line 1514
  return (rc);
}
}
#line 1516 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_unregister_scsi(ctlr_info_t *h ) 
{ struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1524
  tmp = spinlock_check(& h->lock);
#line 1524
  flags = _raw_spin_lock_irqsave(tmp);
#line 1525
  sa = h->scsi_ctlr;
#line 1526
  stk = & sa->cmd_stack;
#line 1529
  if (sa->registered != 0) {
#line 1530
    spin_unlock_irqrestore(& h->lock, flags);
#line 1531
    ldv_scsi_remove_host_10(sa->scsi_host);
#line 1532
    scsi_host_put(sa->scsi_host);
#line 1533
    tmp___0 = spinlock_check(& h->lock);
#line 1533
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1538
  sa->scsi_host = 0;
#line 1539
  spin_unlock_irqrestore(& h->lock, flags);
#line 1540
  scsi_cmd_stack_free(h);
#line 1541
  kfree((void const   *)sa);
#line 1542
  return;
}
}
#line 1544 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_engage_scsi(ctlr_info_t *h ) 
{ struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1550
  tmp = spinlock_check(& h->lock);
#line 1550
  flags = _raw_spin_lock_irqsave(tmp);
#line 1551
  sa = h->scsi_ctlr;
#line 1552
  stk = & sa->cmd_stack;
#line 1554
  if (sa->registered != 0) {
#line 1555
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "SCSI subsystem already engaged.\n");
#line 1556
    spin_unlock_irqrestore(& h->lock, flags);
#line 1557
    return (-6);
  } else {

  }
#line 1559
  sa->registered = 1;
#line 1560
  spin_unlock_irqrestore(& h->lock, flags);
#line 1561
  cciss_update_non_disk_devices(h, -1);
#line 1562
  cciss_scsi_detect(h);
#line 1563
  return (0);
}
}
#line 1567 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_seq_tape_report(struct seq_file *seq , ctlr_info_t *h ) 
{ unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1571
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 1571
  flags = _raw_spin_lock_irqsave(tmp);
#line 1572
  seq_printf(seq, "Sequential access devices: %d\n\n", ccissscsi[h->ctlr].ndevices);
#line 1575
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 1576
  return;
}
}
#line 1578 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int wait_for_device_to_become_ready(ctlr_info_t *h , unsigned char *lunaddr ) 
{ int rc ;
  int count ;
  int waittime ;
  CommandList_struct *c ;
  unsigned char asc ;

  {
#line 1582
  count = 0;
#line 1583
  waittime = 250;
#line 1586
  c = cmd_alloc(h);
#line 1587
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1588
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory in wait_for_device_to_become_ready.\n");
#line 1590
    return (1);
  } else {

  }
#line 1594
  goto ldv_36428;
  ldv_36427: 
#line 1599
  schedule_timeout_uninterruptible((long )waittime);
#line 1600
  count = count + 1;
#line 1603
  if (waittime <= 7499) {
#line 1604
    waittime = waittime * 2;
  } else {

  }
#line 1607
  rc = fill_cmd(h, c, 0, 0, 0UL, 0, lunaddr, 0);
#line 1609
  if (rc == 0) {
#line 1610
    rc = sendcmd_withirq_core(h, c, 0);
  } else {

  }
#line 1612
  process_sendcmd_error(h, c);
#line 1614
  if (rc != 0) {
#line 1615
    goto retry_tur;
  } else {

  }
#line 1617
  if ((unsigned int )(c->err_info)->CommandStatus == 0U) {
#line 1618
    goto ldv_36425;
  } else {

  }
#line 1620
  if ((unsigned int )(c->err_info)->CommandStatus == 1U && (unsigned int )(c->err_info)->ScsiStatus == 2U) {
#line 1622
    if ((unsigned int )(c->err_info)->SenseInfo[2] == 0U) {
#line 1623
      goto ldv_36425;
    } else {

    }
#line 1624
    if ((unsigned int )(c->err_info)->SenseInfo[2] == 6U) {
#line 1626
      asc = (c->err_info)->SenseInfo[12];
#line 1627
      check_for_unit_attention(h, c);
#line 1628
      if ((unsigned int )asc == 41U) {
#line 1629
        goto ldv_36425;
      } else {

      }
    } else {

    }
  } else {

  }
  retry_tur: 
#line 1633
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "Waiting %d secs for device to become ready.\n",
           waittime / 250);
#line 1636
  rc = 1;
  ldv_36428: ;
#line 1594
  if (count <= 19) {
#line 1595
    goto ldv_36427;
  } else {
#line 1597
    goto ldv_36425;
  }
  ldv_36425: ;
#line 1639
  if (rc != 0) {
#line 1640
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "giving up on device.\n");
  } else {
#line 1642
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "device is ready.\n");
  }
#line 1644
  cmd_free(h, c);
#line 1645
  return (rc);
}
}
#line 1659 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_eh_device_reset_handler(struct scsi_cmnd *scsicmd ) 
{ int rc ;
  CommandList_struct *cmd_in_trouble ;
  unsigned char lunaddr[8U] ;
  ctlr_info_t *h ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 1667
  h = (ctlr_info_t *)((scsicmd->device)->host)->hostdata[0];
#line 1668
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1669
    return (8195);
  } else {

  }
#line 1670
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "resetting tape drive or medium changer.\n");
#line 1672
  cmd_in_trouble = (CommandList_struct *)scsicmd->host_scribble;
#line 1673
  if ((unsigned long )cmd_in_trouble == (unsigned long )((CommandList_struct *)0)) {
#line 1674
    return (8195);
  } else {

  }
#line 1675
  __len = 8UL;
#line 1675
  if (__len > 63UL) {
#line 1675
    __ret = __memcpy((void *)(& lunaddr), (void const   *)(& cmd_in_trouble->Header.LUN.LunAddrBytes),
                     __len);
  } else {
#line 1675
    __ret = __builtin_memcpy((void *)(& lunaddr), (void const   *)(& cmd_in_trouble->Header.LUN.LunAddrBytes),
                             __len);
  }
#line 1677
  rc = sendcmd_withirq(h, 1, 0, 0UL, 0, (unsigned char *)(& lunaddr), 1);
#line 1679
  if (rc == 0) {
#line 1679
    tmp = wait_for_device_to_become_ready(h, (unsigned char *)(& lunaddr));
#line 1679
    if (tmp == 0) {
#line 1680
      return (8194);
    } else {

    }
  } else {

  }
#line 1681
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "resetting device failed.\n");
#line 1682
  return (8195);
}
}
#line 1685 "/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_eh_abort_handler(struct scsi_cmnd *scsicmd ) 
{ int rc ;
  CommandList_struct *cmd_to_abort ;
  unsigned char lunaddr[8U] ;
  ctlr_info_t *h ;
  size_t __len ;
  void *__ret ;

  {
#line 1693
  h = (ctlr_info_t *)((scsicmd->device)->host)->hostdata[0];
#line 1694
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1695
    return (8195);
  } else {

  }
#line 1696
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "aborting tardy SCSI cmd\n");
#line 1699
  cmd_to_abort = (CommandList_struct *)scsicmd->host_scribble;
#line 1700
  if ((unsigned long )cmd_to_abort == (unsigned long )((CommandList_struct *)0)) {
#line 1701
    return (8195);
  } else {

  }
#line 1702
  __len = 8UL;
#line 1702
  if (__len > 63UL) {
#line 1702
    __ret = __memcpy((void *)(& lunaddr), (void const   *)(& cmd_to_abort->Header.LUN.LunAddrBytes),
                     __len);
  } else {
#line 1702
    __ret = __builtin_memcpy((void *)(& lunaddr), (void const   *)(& cmd_to_abort->Header.LUN.LunAddrBytes),
                             __len);
  }
#line 1703
  rc = sendcmd_withirq(h, 0, (void *)(& cmd_to_abort->Header.Tag), 0UL, 0, (unsigned char *)(& lunaddr),
                       1);
#line 1705
  if (rc == 0) {
#line 1706
    return (8194);
  } else {

  }
#line 1707
  return (8195);
}
}
#line 446 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static char const   *raid_label[7U]  = {      "0",      "4",      "1(1+0)",      "5", 
        "5+1",      "ADG",      "UNKNOWN"};
#line 460 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_seq_show_header(struct seq_file *seq ) 
{ ctlr_info_t *h ;

  {
#line 462
  h = (ctlr_info_t *)seq->private;
#line 464
  seq_printf(seq, "%s: HP %s Controller\nBoard ID: 0x%08lx\nFirmware Version: %c%c%c%c\nIRQ: %d\nLogical drives: %d\nCurrent Q depth: %d\nCurrent # commands on controller: %d\nMax Q depth since init: %d\nMax # commands on controller since init: %d\nMax SG entries since init: %d\n",
             (char *)(& h->devname), h->product_name, (unsigned long )h->board_id,
             (int )h->firm_ver[0], (int )h->firm_ver[1], (int )h->firm_ver[2], (int )h->firm_ver[3],
             h->intr[h->intr_mode], h->num_luns, h->Qdepth, h->commands_outstanding,
             h->maxQsinceinit, h->max_outstanding, h->maxSG);
#line 484
  cciss_seq_tape_report(seq, h);
#line 485
  return;
}
}
#line 488 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *cciss_seq_start(struct seq_file *seq , loff_t *pos ) 
{ ctlr_info_t *h ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 490
  h = (ctlr_info_t *)seq->private;
#line 496
  tmp = spinlock_check(& h->lock);
#line 496
  flags = _raw_spin_lock_irqsave(tmp);
#line 497
  if (h->busy_configuring != 0) {
#line 498
    spin_unlock_irqrestore(& h->lock, flags);
#line 499
    tmp___0 = ERR_PTR(-16L);
#line 499
    return (tmp___0);
  } else {

  }
#line 501
  h->busy_configuring = 1;
#line 502
  spin_unlock_irqrestore(& h->lock, flags);
#line 504
  if (*pos == 0LL) {
#line 505
    cciss_seq_show_header(seq);
  } else {

  }
#line 507
  return ((void *)pos);
}
}
#line 510 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_seq_show(struct seq_file *seq , void *v ) 
{ sector_t vol_sz ;
  sector_t vol_sz_frac ;
  ctlr_info_t *h ;
  unsigned int ctlr ;
  loff_t *pos ;
  drive_info_struct *drv ;
  int _res ;
  int _res___0 ;

  {
#line 513
  h = (ctlr_info_t *)seq->private;
#line 514
  ctlr = (unsigned int )h->ctlr;
#line 515
  pos = (loff_t *)v;
#line 516
  drv = h->drv[*pos];
#line 518
  if (*pos > (loff_t )h->highest_lun) {
#line 519
    return (0);
  } else {

  }
#line 521
  if ((unsigned long )drv == (unsigned long )((drive_info_struct *)0)) {
#line 522
    return (0);
  } else {

  }
#line 524
  if (drv->heads == 0) {
#line 525
    return (0);
  } else {

  }
#line 527
  vol_sz = drv->nr_blocks;
#line 528
  _res = (int )(vol_sz % 1953125UL);
#line 528
  vol_sz = vol_sz / 1953125UL;
#line 528
  vol_sz_frac = (sector_t )_res;
#line 529
  vol_sz_frac = vol_sz_frac * 100UL;
#line 530
  _res___0 = (int )(vol_sz_frac % 1953125UL);
#line 530
  vol_sz_frac = vol_sz_frac / 1953125UL;
#line 532
  if (drv->raid_level < 0 || (unsigned int )drv->raid_level > 6U) {
#line 533
    drv->raid_level = 6;
  } else {

  }
#line 534
  seq_printf(seq, "cciss/c%dd%d:\t%4u.%02uGB\tRAID %s\n", ctlr, (int )*pos, (int )vol_sz,
             (int )vol_sz_frac, raid_label[drv->raid_level]);
#line 538
  return (0);
}
}
#line 541 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *cciss_seq_next(struct seq_file *seq , void *v , loff_t *pos ) 
{ ctlr_info_t *h ;

  {
#line 543
  h = (ctlr_info_t *)seq->private;
#line 545
  if (*pos > (loff_t )h->highest_lun) {
#line 546
    return (0);
  } else {

  }
#line 547
  *pos = *pos + 1LL;
#line 549
  return ((void *)pos);
}
}
#line 552 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_seq_stop(struct seq_file *seq , void *v ) 
{ ctlr_info_t *h ;
  void *tmp ;

  {
#line 554
  h = (ctlr_info_t *)seq->private;
#line 558
  tmp = ERR_PTR(-16L);
#line 558
  if ((unsigned long )tmp == (unsigned long )v) {
#line 559
    return;
  } else {

  }
#line 561
  h->busy_configuring = 0;
#line 562
  return;
}
}
#line 564 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct seq_operations  const  cciss_seq_ops  =    {& cciss_seq_start, & cciss_seq_stop, & cciss_seq_next, & cciss_seq_show};
#line 571 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_seq_open(struct inode *inode , struct file *file ) 
{ int ret ;
  int tmp ;
  struct seq_file *seq ;
  struct proc_dir_entry *tmp___0 ;

  {
#line 573
  tmp = seq_open(file, & cciss_seq_ops);
#line 573
  ret = tmp;
#line 574
  seq = (struct seq_file *)file->private_data;
#line 576
  if (ret == 0) {
#line 577
    tmp___0 = PDE((struct inode  const  *)inode);
#line 577
    seq->private = tmp___0->data;
  } else {

  }
#line 579
  return (ret);
}
}
#line 583 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_proc_write(struct file *file , char const   *buf , size_t length ,
                                loff_t *ppos ) 
{ int err ;
  char *buffer ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct seq_file *seq ;
  ctlr_info_t *h ;
  int tmp___1 ;

  {
#line 593
  if ((unsigned long )buf == (unsigned long )((char const   *)0) || length > 4095UL) {
#line 594
    return (-22L);
  } else {

  }
#line 596
  tmp = __get_free_pages(208U, 0U);
#line 596
  buffer = (char *)tmp;
#line 597
  if ((unsigned long )buffer == (unsigned long )((char *)0)) {
#line 598
    return (-12L);
  } else {

  }
#line 600
  err = -14;
#line 601
  tmp___0 = copy_from_user((void *)buffer, (void const   *)buf, length);
#line 601
  if (tmp___0 != 0UL) {
#line 602
    goto out;
  } else {

  }
#line 603
  *(buffer + length) = 0;
#line 606
  tmp___1 = strncmp("engage scsi", (char const   *)buffer, 11UL);
#line 606
  if (tmp___1 == 0) {
#line 607
    seq = (struct seq_file *)file->private_data;
#line 608
    h = (ctlr_info_t *)seq->private;
#line 610
    err = cciss_engage_scsi(h);
#line 611
    if (err == 0) {
#line 612
      err = (int )length;
    } else {

    }
  } else {
#line 615
    err = -22;
  }
  out: 
#line 620
  free_pages((unsigned long )buffer, 0U);
#line 621
  return ((ssize_t )err);
}
}
#line 624 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct file_operations  const  cciss_proc_fops  = 
#line 624
     {& __this_module, & seq_lseek, & seq_read, & cciss_proc_write, 0, 0, 0, 0, 0, 0,
    0, & cciss_seq_open, 0, & seq_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 633 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_procinit(ctlr_info_t *h ) 
{ struct proc_dir_entry *pde ;

  {
#line 637
  if ((unsigned long )proc_cciss == (unsigned long )((struct proc_dir_entry *)0)) {
#line 638
    proc_cciss = proc_mkdir("driver/cciss", 0);
  } else {

  }
#line 639
  if ((unsigned long )proc_cciss == (unsigned long )((struct proc_dir_entry *)0)) {
#line 640
    return;
  } else {

  }
#line 641
  pde = proc_create_data((char const   *)(& h->devname), 420, proc_cciss, & cciss_proc_fops,
                         (void *)h);
#line 644
  return;
}
}
#line 653 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static u32 unresettable_controller[14U]  = 
#line 653
  {      843714620U,      843780156U,      841158716U,      842272828U, 
        842338364U,      839979068U,      840044604U,      840110140U, 
        840175676U,      840241212U,      842469436U,      842862652U, 
        1083969041U,      1084034577U};
#line 671 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static u32 soft_unresettable_controller[2U]  = {      1083969041U,      1084034577U};
#line 676 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_hard_resettable(u32 board_id ) 
{ int i ;

  {
#line 680
  i = 0;
#line 680
  goto ldv_36524;
  ldv_36523: ;
#line 681
  if (unresettable_controller[i] == board_id) {
#line 682
    return (0);
  } else {

  }
#line 680
  i = i + 1;
  ldv_36524: ;
#line 680
  if ((unsigned int )i <= 13U) {
#line 681
    goto ldv_36523;
  } else {
#line 683
    goto ldv_36525;
  }
  ldv_36525: ;
#line 683
  return (1);
}
}
#line 686 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_soft_resettable(u32 board_id ) 
{ int i ;

  {
#line 690
  i = 0;
#line 690
  goto ldv_36533;
  ldv_36532: ;
#line 691
  if (soft_unresettable_controller[i] == board_id) {
#line 692
    return (0);
  } else {

  }
#line 690
  i = i + 1;
  ldv_36533: ;
#line 690
  if ((unsigned int )i <= 1U) {
#line 691
    goto ldv_36532;
  } else {
#line 693
    goto ldv_36534;
  }
  ldv_36534: ;
#line 693
  return (1);
}
}
#line 696 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_resettable(u32 board_id ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 698
  tmp = ctlr_is_hard_resettable(board_id);
#line 698
  if (tmp != 0) {
#line 698
    tmp___1 = 1;
  } else {
#line 698
    tmp___0 = ctlr_is_soft_resettable(board_id);
#line 698
    if (tmp___0 != 0) {
#line 698
      tmp___1 = 1;
    } else {
#line 698
      tmp___1 = 0;
    }
  }
#line 698
  return (tmp___1);
}
}
#line 702 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_show_resettable(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct ctlr_info *h ;
  struct device  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 706
  __mptr = (struct device  const  *)dev;
#line 706
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 708
  tmp = ctlr_is_resettable(h->board_id);
#line 708
  tmp___0 = snprintf(buf, 20UL, "%d\n", tmp);
#line 708
  return ((ssize_t )tmp___0);
}
}
#line 710 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_resettable  =    {{"resettable", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & host_show_resettable, 0};
#line 712 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_store_rescan(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ struct ctlr_info *h ;
  struct device  const  *__mptr ;

  {
#line 716
  __mptr = (struct device  const  *)dev;
#line 716
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 718
  add_to_scan_list(h);
#line 719
  wake_up_process(cciss_scan_thread);
#line 720
  wait_for_completion_interruptible(& h->scan_wait);
#line 722
  return ((ssize_t )count);
}
}
#line 724 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_rescan  =    {{"rescan", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, 0, & host_store_rescan};
#line 726 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_show_transport_mode(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ struct ctlr_info *h ;
  struct device  const  *__mptr ;
  char *tmp ;
  int tmp___0 ;

  {
#line 730
  __mptr = (struct device  const  *)dev;
#line 730
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 732
  if ((h->transMethod & 4UL) != 0UL) {
#line 732
    tmp = (char *)"performant";
  } else {
#line 732
    tmp = (char *)"simple";
  }
#line 732
  tmp___0 = snprintf(buf, 20UL, "%s\n", tmp);
#line 732
  return ((ssize_t )tmp___0);
}
}
#line 736 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_transport_mode  =    {{"transport_mode", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & host_show_transport_mode, 0};
#line 738 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_unique_id(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  __u8 sn[16U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 742
  __mptr = (struct device  const  *)dev;
#line 742
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 743
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 743
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 746
  ret = 0;
#line 748
  tmp = spinlock_check(& h->lock);
#line 748
  flags = _raw_spin_lock_irqsave(tmp);
#line 749
  if (h->busy_configuring != 0) {
#line 750
    ret = -16;
  } else {
#line 752
    __len = 16UL;
#line 752
    if (__len > 63UL) {
#line 752
      __ret = __memcpy((void *)(& sn), (void const   *)(& drv->serial_no), __len);
    } else {
#line 752
      __ret = __builtin_memcpy((void *)(& sn), (void const   *)(& drv->serial_no),
                               __len);
    }
  }
#line 753
  spin_unlock_irqrestore(& h->lock, flags);
#line 755
  if (ret != 0) {
#line 756
    return ((ssize_t )ret);
  } else {
#line 758
    tmp___0 = snprintf(buf, 34UL, "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
                       (int )sn[0], (int )sn[1], (int )sn[2], (int )sn[3], (int )sn[4],
                       (int )sn[5], (int )sn[6], (int )sn[7], (int )sn[8], (int )sn[9],
                       (int )sn[10], (int )sn[11], (int )sn[12], (int )sn[13], (int )sn[14],
                       (int )sn[15]);
#line 758
    return ((ssize_t )tmp___0);
  }
}
}
#line 766 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_unique_id  =    {{"unique_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & dev_show_unique_id, 0};
#line 768 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_vendor(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char vendor[9U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 772
  __mptr = (struct device  const  *)dev;
#line 772
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 773
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 773
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 776
  ret = 0;
#line 778
  tmp = spinlock_check(& h->lock);
#line 778
  flags = _raw_spin_lock_irqsave(tmp);
#line 779
  if (h->busy_configuring != 0) {
#line 780
    ret = -16;
  } else {
#line 782
    __len = 9UL;
#line 782
    if (__len > 63UL) {
#line 782
      __ret = __memcpy((void *)(& vendor), (void const   *)(& drv->vendor), __len);
    } else {
#line 782
      __ret = __builtin_memcpy((void *)(& vendor), (void const   *)(& drv->vendor),
                               __len);
    }
  }
#line 783
  spin_unlock_irqrestore(& h->lock, flags);
#line 785
  if (ret != 0) {
#line 786
    return ((ssize_t )ret);
  } else {
#line 788
    tmp___0 = snprintf(buf, 10UL, "%s\n", (char *)(& drv->vendor));
#line 788
    return ((ssize_t )tmp___0);
  }
}
}
#line 790 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_vendor  =    {{"vendor", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_vendor,
    0};
#line 792 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_model(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char model[17U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 796
  __mptr = (struct device  const  *)dev;
#line 796
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 797
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 797
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 800
  ret = 0;
#line 802
  tmp = spinlock_check(& h->lock);
#line 802
  flags = _raw_spin_lock_irqsave(tmp);
#line 803
  if (h->busy_configuring != 0) {
#line 804
    ret = -16;
  } else {
#line 806
    __len = 17UL;
#line 806
    if (__len > 63UL) {
#line 806
      __ret = __memcpy((void *)(& model), (void const   *)(& drv->model), __len);
    } else {
#line 806
      __ret = __builtin_memcpy((void *)(& model), (void const   *)(& drv->model),
                               __len);
    }
  }
#line 807
  spin_unlock_irqrestore(& h->lock, flags);
#line 809
  if (ret != 0) {
#line 810
    return ((ssize_t )ret);
  } else {
#line 812
    tmp___0 = snprintf(buf, 18UL, "%s\n", (char *)(& drv->model));
#line 812
    return ((ssize_t )tmp___0);
  }
}
}
#line 814 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_model  =    {{"model", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_model,
    0};
#line 816 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_rev(struct device *dev , struct device_attribute *attr , char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char rev[5U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 820
  __mptr = (struct device  const  *)dev;
#line 820
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 821
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 821
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 824
  ret = 0;
#line 826
  tmp = spinlock_check(& h->lock);
#line 826
  flags = _raw_spin_lock_irqsave(tmp);
#line 827
  if (h->busy_configuring != 0) {
#line 828
    ret = -16;
  } else {
#line 830
    __len = 5UL;
#line 830
    if (__len > 63UL) {
#line 830
      __ret = __memcpy((void *)(& rev), (void const   *)(& drv->rev), __len);
    } else {
#line 830
      __ret = __builtin_memcpy((void *)(& rev), (void const   *)(& drv->rev), __len);
    }
  }
#line 831
  spin_unlock_irqrestore(& h->lock, flags);
#line 833
  if (ret != 0) {
#line 834
    return ((ssize_t )ret);
  } else {
#line 836
    tmp___0 = snprintf(buf, 6UL, "%s\n", (char *)(& drv->rev));
#line 836
    return ((ssize_t )tmp___0);
  }
}
}
#line 838 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_rev  =    {{"rev", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_rev,
    0};
#line 840 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_lunid(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  unsigned long flags ;
  unsigned char lunid[8U] ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 843
  __mptr = (struct device  const  *)dev;
#line 843
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 844
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 844
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 848
  tmp = spinlock_check(& h->lock);
#line 848
  flags = _raw_spin_lock_irqsave(tmp);
#line 849
  if (h->busy_configuring != 0) {
#line 850
    spin_unlock_irqrestore(& h->lock, flags);
#line 851
    return (-16L);
  } else {

  }
#line 853
  if (drv->heads == 0) {
#line 854
    spin_unlock_irqrestore(& h->lock, flags);
#line 855
    return (-25L);
  } else {

  }
#line 857
  __len = 8UL;
#line 857
  if (__len > 63UL) {
#line 857
    __ret = __memcpy((void *)(& lunid), (void const   *)(& drv->LunID), __len);
  } else {
#line 857
    __ret = __builtin_memcpy((void *)(& lunid), (void const   *)(& drv->LunID), __len);
  }
#line 858
  spin_unlock_irqrestore(& h->lock, flags);
#line 859
  tmp___0 = snprintf(buf, 20UL, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n", (int )lunid[0],
                     (int )lunid[1], (int )lunid[2], (int )lunid[3], (int )lunid[4],
                     (int )lunid[5], (int )lunid[6], (int )lunid[7]);
#line 859
  return ((ssize_t )tmp___0);
}
}
#line 863 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_lunid  =    {{"lunid", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & cciss_show_lunid,
    0};
#line 865 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_raid_level(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  int raid ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 868
  __mptr = (struct device  const  *)dev;
#line 868
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 869
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 869
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 873
  tmp = spinlock_check(& h->lock);
#line 873
  flags = _raw_spin_lock_irqsave(tmp);
#line 874
  if (h->busy_configuring != 0) {
#line 875
    spin_unlock_irqrestore(& h->lock, flags);
#line 876
    return (-16L);
  } else {

  }
#line 878
  raid = drv->raid_level;
#line 879
  spin_unlock_irqrestore(& h->lock, flags);
#line 880
  if (raid < 0 || (unsigned int )raid > 6U) {
#line 881
    raid = 6;
  } else {

  }
#line 883
  tmp___0 = strlen(raid_label[raid]);
#line 883
  tmp___1 = snprintf(buf, tmp___0 + 7UL, "RAID %s\n", raid_label[raid]);
#line 883
  return ((ssize_t )tmp___1);
}
}
#line 886 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_raid_level  =    {{"raid_level", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & cciss_show_raid_level, 0};
#line 888 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_usage_count(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  unsigned long flags ;
  int count ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 891
  __mptr = (struct device  const  *)dev;
#line 891
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 892
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 892
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 896
  tmp = spinlock_check(& h->lock);
#line 896
  flags = _raw_spin_lock_irqsave(tmp);
#line 897
  if (h->busy_configuring != 0) {
#line 898
    spin_unlock_irqrestore(& h->lock, flags);
#line 899
    return (-16L);
  } else {

  }
#line 901
  count = drv->usage_count;
#line 902
  spin_unlock_irqrestore(& h->lock, flags);
#line 903
  tmp___0 = snprintf(buf, 20UL, "%d\n", count);
#line 903
  return ((ssize_t )tmp___0);
}
}
#line 905 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_usage_count  =    {{"usage_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & cciss_show_usage_count, 0};
#line 907 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute *cciss_host_attrs[4U]  = {      & dev_attr_rescan.attr,      & dev_attr_resettable.attr,      & dev_attr_transport_mode.attr,      0};
#line 914 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group cciss_host_attr_group  =    {0, 0, (struct attribute **)(& cciss_host_attrs)};
#line 918 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group  const  *cciss_host_attr_groups[2U]  = {      (struct attribute_group  const  *)(& cciss_host_attr_group),      0};
#line 923 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_type cciss_host_type  =    {"cciss_host", (struct attribute_group  const  **)(& cciss_host_attr_groups), 0,
    0, & cciss_hba_release, 0};
#line 929 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute *cciss_dev_attrs[8U]  = 
#line 929
  {      & dev_attr_unique_id.attr,      & dev_attr_model.attr,      & dev_attr_vendor.attr,      & dev_attr_rev.attr, 
        & dev_attr_lunid.attr,      & dev_attr_raid_level.attr,      & dev_attr_usage_count.attr,      0};
#line 940 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group cciss_dev_attr_group  =    {0, 0, (struct attribute **)(& cciss_dev_attrs)};
#line 944 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group  const  *cciss_dev_attr_groups[2U]  = {      (struct attribute_group  const  *)(& cciss_dev_attr_group),      0};
#line 949 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_type cciss_dev_type  =    {"cciss_device", (struct attribute_group  const  **)(& cciss_dev_attr_groups),
    0, 0, & cciss_device_release, 0};
#line 955 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct bus_type cciss_bus_type  = 
#line 955
     {"cciss", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 963 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_hba_release(struct device *dev ) 
{ 

  {
#line 965
  return;
}
}
#line 976 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_create_hba_sysfs_entry(struct ctlr_info *h ) 
{ int tmp ;

  {
#line 978
  device_initialize(& h->dev);
#line 979
  h->dev.type = (struct device_type  const  *)(& cciss_host_type);
#line 980
  h->dev.bus = & cciss_bus_type;
#line 981
  dev_set_name(& h->dev, "%s", (char *)(& h->devname));
#line 982
  h->dev.parent = & (h->pdev)->dev;
#line 984
  tmp = device_add(& h->dev);
#line 984
  return (tmp);
}
}
#line 990 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_destroy_hba_sysfs_entry(struct ctlr_info *h ) 
{ 

  {
#line 992
  device_del(& h->dev);
#line 993
  put_device(& h->dev);
#line 994
  return;
}
}
#line 999 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_device_release(struct device *dev ) 
{ drive_info_struct *drv ;
  struct device  const  *__mptr ;

  {
#line 1001
  __mptr = (struct device  const  *)dev;
#line 1001
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 1002
  kfree((void const   *)drv);
#line 1003
  return;
}
}
#line 1011 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static long cciss_create_ld_sysfs_entry(struct ctlr_info *h , int drv_index ) 
{ struct device *dev ;
  int tmp ;

  {
#line 1016
  if ((int )((signed char )(h->drv[drv_index])->device_initialized) != 0) {
#line 1017
    return (0L);
  } else {

  }
#line 1019
  dev = & (h->drv[drv_index])->dev;
#line 1020
  device_initialize(dev);
#line 1021
  dev->type = (struct device_type  const  *)(& cciss_dev_type);
#line 1022
  dev->bus = & cciss_bus_type;
#line 1023
  dev_set_name(dev, "c%dd%d", h->ctlr, drv_index);
#line 1024
  dev->parent = & h->dev;
#line 1025
  (h->drv[drv_index])->device_initialized = 1;
#line 1026
  tmp = device_add(dev);
#line 1026
  return ((long )tmp);
}
}
#line 1032 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_destroy_ld_sysfs_entry(struct ctlr_info *h , int drv_index , int ctlr_exiting ) 
{ struct device *dev ;

  {
#line 1035
  dev = & (h->drv[drv_index])->dev;
#line 1038
  if (drv_index == 0 && ctlr_exiting == 0) {
#line 1039
    return;
  } else {

  }
#line 1041
  device_del(dev);
#line 1042
  put_device(dev);
#line 1043
  h->drv[drv_index] = 0;
#line 1044
  return;
}
}
#line 1051 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static CommandList_struct *cmd_alloc(ctlr_info_t *h ) 
{ CommandList_struct *c ;
  int i ;
  u64bit temp64 ;
  dma_addr_t cmd_dma_handle ;
  dma_addr_t err_dma_handle ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  ldv_36751: 
#line 1059
  tmp = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1059
  i = (int )tmp;
#line 1060
  if (h->nr_cmds == i) {
#line 1061
    return (0);
  } else {

  }
#line 1062
  tmp___0 = test_and_set_bit(i, (unsigned long volatile   *)h->cmd_pool_bits);
#line 1062
  if (tmp___0 != 0) {
#line 1063
    goto ldv_36751;
  } else {
#line 1065
    goto ldv_36752;
  }
  ldv_36752: 
#line 1063
  c = h->cmd_pool + (unsigned long )i;
#line 1064
  memset((void *)c, 0, 640UL);
#line 1065
  cmd_dma_handle = h->cmd_pool_dhandle + (unsigned long long )((unsigned long )i * 640UL);
#line 1066
  c->err_info = h->errinfo_pool + (unsigned long )i;
#line 1067
  memset((void *)c->err_info, 0, 48UL);
#line 1068
  err_dma_handle = h->errinfo_pool_dhandle + (unsigned long long )((unsigned long )i * 48UL);
#line 1070
  h->nr_allocs = h->nr_allocs + 1;
#line 1072
  c->cmdindex = (long )i;
#line 1074
  INIT_LIST_HEAD(& c->list);
#line 1075
  c->busaddr = (unsigned int )cmd_dma_handle;
#line 1076
  temp64.val = err_dma_handle;
#line 1077
  c->ErrDesc.Addr.lower = temp64.val32.lower;
#line 1078
  c->ErrDesc.Addr.upper = temp64.val32.upper;
#line 1079
  c->ErrDesc.Len = 48U;
#line 1081
  c->ctlr = h->ctlr;
#line 1082
  return (c);
}
}
#line 1088 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static CommandList_struct *cmd_special_alloc(ctlr_info_t *h ) 
{ CommandList_struct *c ;
  u64bit temp64 ;
  dma_addr_t cmd_dma_handle ;
  dma_addr_t err_dma_handle ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1094
  tmp = pci_alloc_consistent(h->pdev, 640UL, & cmd_dma_handle);
#line 1094
  c = (CommandList_struct *)tmp;
#line 1096
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1097
    return (0);
  } else {

  }
#line 1098
  memset((void *)c, 0, 640UL);
#line 1100
  c->cmdindex = -1L;
#line 1102
  tmp___0 = pci_alloc_consistent(h->pdev, 48UL, & err_dma_handle);
#line 1102
  c->err_info = (ErrorInfo_struct *)tmp___0;
#line 1106
  if ((unsigned long )c->err_info == (unsigned long )((ErrorInfo_struct *)0)) {
#line 1107
    pci_free_consistent(h->pdev, 640UL, (void *)c, cmd_dma_handle);
#line 1109
    return (0);
  } else {

  }
#line 1111
  memset((void *)c->err_info, 0, 48UL);
#line 1113
  INIT_LIST_HEAD(& c->list);
#line 1114
  c->busaddr = (unsigned int )cmd_dma_handle;
#line 1115
  temp64.val = err_dma_handle;
#line 1116
  c->ErrDesc.Addr.lower = temp64.val32.lower;
#line 1117
  c->ErrDesc.Addr.upper = temp64.val32.upper;
#line 1118
  c->ErrDesc.Len = 48U;
#line 1120
  c->ctlr = h->ctlr;
#line 1121
  return (c);
}
}
#line 1124 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cmd_free(ctlr_info_t *h , CommandList_struct *c ) 
{ int i ;

  {
#line 1128
  i = (int )(((long )c - (long )h->cmd_pool) / 640L);
#line 1129
  clear_bit(i, (unsigned long volatile   *)h->cmd_pool_bits);
#line 1130
  h->nr_frees = h->nr_frees + 1;
#line 1131
  return;
}
}
#line 1133 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cmd_special_free(ctlr_info_t *h , CommandList_struct *c ) 
{ u64bit temp64 ;
  u32 tmp ;

  {
#line 1137
  temp64.val32.lower = c->ErrDesc.Addr.lower;
#line 1138
  temp64.val32.upper = c->ErrDesc.Addr.upper;
#line 1139
  pci_free_consistent(h->pdev, 48UL, (void *)c->err_info, temp64.val);
#line 1141
  tmp = cciss_tag_discard_error_bits(h, c->busaddr);
#line 1141
  pci_free_consistent(h->pdev, 640UL, (void *)c, (unsigned long long )tmp);
#line 1143
  return;
}
}
#line 1145 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static ctlr_info_t *get_host(struct gendisk *disk ) 
{ 

  {
#line 1147
  return ((ctlr_info_t *)(disk->queue)->queuedata);
}
}
#line 1150 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static drive_info_struct *get_drv(struct gendisk *disk ) 
{ 

  {
#line 1152
  return ((drive_info_struct *)disk->private_data);
}
}
#line 1158 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_open(struct block_device *bdev , fmode_t mode ) 
{ ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  drive_info_struct *drv ;
  drive_info_struct *tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 1160
  tmp = get_host(bdev->bd_disk);
#line 1160
  h = tmp;
#line 1161
  tmp___0 = get_drv(bdev->bd_disk);
#line 1161
  drv = tmp___0;
#line 1163
  descriptor.modname = "cciss";
#line 1163
  descriptor.function = "cciss_open";
#line 1163
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1163
  descriptor.format = "cciss_open %s\n";
#line 1163
  descriptor.lineno = 1163U;
#line 1163
  descriptor.flags = 0U;
#line 1163
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1163
  if (tmp___1 != 0L) {
#line 1163
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_open %s\n",
                      (char *)(& (bdev->bd_disk)->disk_name));
  } else {

  }
#line 1164
  if (drv->busy_configuring != 0) {
#line 1165
    return (-16);
  } else {

  }
#line 1174
  if (drv->heads == 0) {
#line 1175
    if ((bdev->bd_dev & 1048575U) != 0U) {
#line 1177
      if ((bdev->bd_dev & 15U) != 0U) {
#line 1178
        return (-6);
      } else {
#line 1180
        tmp___2 = memcmp((void const   *)(& drv->LunID), (void const   *)"", 8UL);
#line 1180
        if (tmp___2 != 0) {
#line 1182
          return (-6);
        } else {

        }
      }
    } else {

    }
#line 1185
    tmp___3 = capable(21);
#line 1185
    if (tmp___3) {
#line 1185
      tmp___4 = 0;
    } else {
#line 1185
      tmp___4 = 1;
    }
#line 1185
    if (tmp___4) {
#line 1186
      return (-1);
    } else {

    }
  } else {

  }
#line 1188
  drv->usage_count = drv->usage_count + 1;
#line 1189
  h->usage_count = h->usage_count + 1;
#line 1190
  return (0);
}
}
#line 1193 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_unlocked_open(struct block_device *bdev , fmode_t mode ) 
{ int ret ;

  {
#line 1197
  ldv_mutex_lock_11(& cciss_mutex);
#line 1198
  ret = cciss_open(bdev, mode);
#line 1199
  ldv_mutex_unlock_12(& cciss_mutex);
#line 1201
  return (ret);
}
}
#line 1207 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_release(struct gendisk *disk , fmode_t mode ) 
{ ctlr_info_t *h ;
  drive_info_struct *drv ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1212
  ldv_mutex_lock_13(& cciss_mutex);
#line 1213
  h = get_host(disk);
#line 1214
  drv = get_drv(disk);
#line 1215
  descriptor.modname = "cciss";
#line 1215
  descriptor.function = "cciss_release";
#line 1215
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1215
  descriptor.format = "cciss_release %s\n";
#line 1215
  descriptor.lineno = 1215U;
#line 1215
  descriptor.flags = 0U;
#line 1215
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1215
  if (tmp != 0L) {
#line 1215
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_release %s\n",
                      (char *)(& disk->disk_name));
  } else {

  }
#line 1216
  drv->usage_count = drv->usage_count - 1;
#line 1217
  h->usage_count = h->usage_count - 1;
#line 1218
  ldv_mutex_unlock_14(& cciss_mutex);
#line 1219
  return (0);
}
}
#line 1222 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int do_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                    unsigned long arg ) 
{ int ret ;

  {
#line 1226
  ldv_mutex_lock_15(& cciss_mutex);
#line 1227
  ret = cciss_ioctl(bdev, mode, cmd, arg);
#line 1228
  ldv_mutex_unlock_16(& cciss_mutex);
#line 1229
  return (ret);
}
}
#line 1234
static int cciss_ioctl32_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                  unsigned long arg ) ;
#line 1236
static int cciss_ioctl32_big_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                      unsigned long arg ) ;
#line 1239 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_compat_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                              unsigned long arg ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1242
  switch (cmd) {
  case -2146942463: ;
  case -2146942462: ;
  case 1074283011: ;
  case -2146418172: ;
  case 1074807301: ;
  case -2147204602: ;
  case -2147204601: ;
  case -2147204600: ;
  case -2147204599: ;
  case 16906: ;
  case 16908: ;
  case 1074020877: ;
  case 16910: ;
  case 16912: ;
  case -2146680303: 
#line 1258
  tmp = do_ioctl(bdev, mode, cmd, arg);
#line 1258
  return (tmp);
  case -1068219893: 
#line 1261
  tmp___0 = cciss_ioctl32_passthru(bdev, mode, cmd, arg);
#line 1261
  return (tmp___0);
  case -1067957742: 
#line 1263
  tmp___1 = cciss_ioctl32_big_passthru(bdev, mode, cmd, arg);
#line 1263
  return (tmp___1);
  default: ;
#line 1266
  return (-515);
  }
}
}
#line 1270 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl32_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                  unsigned long arg ) 
{ IOCTL32_Command_struct *arg32 ;
  IOCTL_Command_struct arg64 ;
  IOCTL_Command_struct *p ;
  void *tmp ;
  int err ;
  u32 cp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1273
  arg32 = (IOCTL32_Command_struct *)arg;
#line 1276
  tmp = compat_alloc_user_space(88UL);
#line 1276
  p = (IOCTL_Command_struct *)tmp;
#line 1280
  err = 0;
#line 1281
  tmp___0 = copy_from_user((void *)(& arg64.LUN_info), (void const   *)(& arg32->LUN_info),
                           8UL);
#line 1281
  err = (int )((unsigned int )tmp___0 | (unsigned int )err);
#line 1284
  tmp___1 = copy_from_user((void *)(& arg64.Request), (void const   *)(& arg32->Request),
                           20UL);
#line 1284
  err = (int )((unsigned int )tmp___1 | (unsigned int )err);
#line 1287
  tmp___2 = copy_from_user((void *)(& arg64.error_info), (void const   *)(& arg32->error_info),
                           48UL);
#line 1287
  err = (int )((unsigned int )tmp___2 | (unsigned int )err);
#line 1290
  might_fault();
#line 1290
  switch (2UL) {
  case 1: 
#line 1290
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1290
  goto ldv_36852;
  case 2: 
#line 1290
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1290
  goto ldv_36852;
  case 4: 
#line 1290
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1290
  goto ldv_36852;
  case 8: 
#line 1290
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1290
  goto ldv_36852;
  default: 
#line 1290
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1290
  goto ldv_36852;
  }
  ldv_36852: 
#line 1290
  arg64.buf_size = (unsigned short )__val_gu;
#line 1290
  err = __ret_gu | err;
#line 1291
  might_fault();
#line 1291
  switch (4UL) {
  case 1: 
#line 1291
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1291
  goto ldv_36861;
  case 2: 
#line 1291
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1291
  goto ldv_36861;
  case 4: 
#line 1291
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1291
  goto ldv_36861;
  case 8: 
#line 1291
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1291
  goto ldv_36861;
  default: 
#line 1291
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1291
  goto ldv_36861;
  }
  ldv_36861: 
#line 1291
  cp = (unsigned int )__val_gu___0;
#line 1291
  err = __ret_gu___0 | err;
#line 1292
  tmp___3 = compat_ptr(cp);
#line 1292
  arg64.buf = (__u8 *)tmp___3;
#line 1293
  tmp___4 = copy_to_user((void *)p, (void const   *)(& arg64), 88U);
#line 1293
  err = tmp___4 | err;
#line 1295
  if (err != 0) {
#line 1296
    return (-14);
  } else {

  }
#line 1298
  err = do_ioctl(bdev, mode, 3227009547U, (unsigned long )p);
#line 1299
  if (err != 0) {
#line 1300
    return (err);
  } else {

  }
#line 1301
  tmp___5 = copy_in_user((void *)(& arg32->error_info), (void const   *)(& p->error_info),
                         48U);
#line 1301
  err = (int )((unsigned int )tmp___5 | (unsigned int )err);
#line 1304
  if (err != 0) {
#line 1305
    return (-14);
  } else {

  }
#line 1306
  return (err);
}
}
#line 1309 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl32_big_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                      unsigned long arg ) 
{ BIG_IOCTL32_Command_struct *arg32 ;
  BIG_IOCTL_Command_struct arg64 ;
  BIG_IOCTL_Command_struct *p ;
  void *tmp ;
  int err ;
  u32 cp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  int __ret_gu___1 ;
  unsigned long __val_gu___1 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1312
  arg32 = (BIG_IOCTL32_Command_struct *)arg;
#line 1315
  tmp = compat_alloc_user_space(96UL);
#line 1315
  p = (BIG_IOCTL_Command_struct *)tmp;
#line 1320
  memset((void *)(& arg64), 0, 96UL);
#line 1321
  err = 0;
#line 1322
  tmp___0 = copy_from_user((void *)(& arg64.LUN_info), (void const   *)(& arg32->LUN_info),
                           8UL);
#line 1322
  err = (int )((unsigned int )tmp___0 | (unsigned int )err);
#line 1325
  tmp___1 = copy_from_user((void *)(& arg64.Request), (void const   *)(& arg32->Request),
                           20UL);
#line 1325
  err = (int )((unsigned int )tmp___1 | (unsigned int )err);
#line 1328
  tmp___2 = copy_from_user((void *)(& arg64.error_info), (void const   *)(& arg32->error_info),
                           48UL);
#line 1328
  err = (int )((unsigned int )tmp___2 | (unsigned int )err);
#line 1331
  might_fault();
#line 1331
  switch (4UL) {
  case 1: 
#line 1331
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1331
  goto ldv_36881;
  case 2: 
#line 1331
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1331
  goto ldv_36881;
  case 4: 
#line 1331
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1331
  goto ldv_36881;
  case 8: 
#line 1331
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1331
  goto ldv_36881;
  default: 
#line 1331
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1331
  goto ldv_36881;
  }
  ldv_36881: 
#line 1331
  arg64.buf_size = (unsigned int )__val_gu;
#line 1331
  err = __ret_gu | err;
#line 1332
  might_fault();
#line 1332
  switch (4UL) {
  case 1: 
#line 1332
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1332
  goto ldv_36890;
  case 2: 
#line 1332
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1332
  goto ldv_36890;
  case 4: 
#line 1332
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1332
  goto ldv_36890;
  case 8: 
#line 1332
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1332
  goto ldv_36890;
  default: 
#line 1332
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1332
  goto ldv_36890;
  }
  ldv_36890: 
#line 1332
  arg64.malloc_size = (unsigned int )__val_gu___0;
#line 1332
  err = __ret_gu___0 | err;
#line 1333
  might_fault();
#line 1333
  switch (4UL) {
  case 1: 
#line 1333
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1333
  goto ldv_36899;
  case 2: 
#line 1333
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1333
  goto ldv_36899;
  case 4: 
#line 1333
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1333
  goto ldv_36899;
  case 8: 
#line 1333
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1333
  goto ldv_36899;
  default: 
#line 1333
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1333
  goto ldv_36899;
  }
  ldv_36899: 
#line 1333
  cp = (unsigned int )__val_gu___1;
#line 1333
  err = __ret_gu___1 | err;
#line 1334
  tmp___3 = compat_ptr(cp);
#line 1334
  arg64.buf = (__u8 *)tmp___3;
#line 1335
  tmp___4 = copy_to_user((void *)p, (void const   *)(& arg64), 96U);
#line 1335
  err = tmp___4 | err;
#line 1337
  if (err != 0) {
#line 1338
    return (-14);
  } else {

  }
#line 1340
  err = do_ioctl(bdev, mode, 3227533842U, (unsigned long )p);
#line 1341
  if (err != 0) {
#line 1342
    return (err);
  } else {

  }
#line 1343
  tmp___5 = copy_in_user((void *)(& arg32->error_info), (void const   *)(& p->error_info),
                         48U);
#line 1343
  err = (int )((unsigned int )tmp___5 | (unsigned int )err);
#line 1346
  if (err != 0) {
#line 1347
    return (-14);
  } else {

  }
#line 1348
  return (err);
}
}
#line 1352 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getgeo(struct block_device *bdev , struct hd_geometry *geo ) 
{ drive_info_struct *drv ;
  drive_info_struct *tmp ;

  {
#line 1354
  tmp = get_drv(bdev->bd_disk);
#line 1354
  drv = tmp;
#line 1356
  if (drv->cylinders == 0) {
#line 1357
    return (-6);
  } else {

  }
#line 1359
  geo->heads = (unsigned char )drv->heads;
#line 1360
  geo->sectors = (unsigned char )drv->sectors;
#line 1361
  geo->cylinders = (unsigned short )drv->cylinders;
#line 1362
  return (0);
}
}
#line 1365 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void check_ioctl_unit_attention(ctlr_info_t *h , CommandList_struct *c ) 
{ 

  {
#line 1367
  if ((unsigned int )(c->err_info)->CommandStatus == 1U && (unsigned int )(c->err_info)->ScsiStatus != 2U) {
#line 1369
    check_for_unit_attention(h, c);
  } else {

  }
#line 1370
  return;
}
}
#line 1372 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getpciinfo(ctlr_info_t *h , void *argp ) 
{ cciss_pci_info_struct pciinfo ;
  int tmp ;
  int tmp___0 ;

  {
#line 1376
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1377
    return (-22);
  } else {

  }
#line 1378
  tmp = pci_domain_nr((h->pdev)->bus);
#line 1378
  pciinfo.domain = (unsigned short )tmp;
#line 1379
  pciinfo.bus = ((h->pdev)->bus)->number;
#line 1380
  pciinfo.dev_fn = (unsigned char )(h->pdev)->devfn;
#line 1381
  pciinfo.board_id = h->board_id;
#line 1382
  tmp___0 = copy_to_user(argp, (void const   *)(& pciinfo), 8U);
#line 1382
  if (tmp___0 != 0) {
#line 1383
    return (-14);
  } else {

  }
#line 1384
  return (0);
}
}
#line 1387 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getintinfo(ctlr_info_t *h , void *argp ) 
{ cciss_coalint_struct intinfo ;
  int tmp ;

  {
#line 1391
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1392
    return (-22);
  } else {

  }
#line 1393
  intinfo.delay = readl((void const volatile   *)(& (h->cfgtable)->HostWrite.CoalIntDelay));
#line 1394
  intinfo.count = readl((void const volatile   *)(& (h->cfgtable)->HostWrite.CoalIntCount));
#line 1395
  tmp = copy_to_user(argp, (void const   *)(& intinfo), 8U);
#line 1395
  if (tmp != 0) {
#line 1397
    return (-14);
  } else {

  }
#line 1398
  return (0);
}
}
#line 1401 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_setintinfo(ctlr_info_t *h , void *argp ) 
{ cciss_coalint_struct intinfo ;
  unsigned long flags ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1407
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1408
    return (-22);
  } else {

  }
#line 1409
  tmp = capable(21);
#line 1409
  if (tmp) {
#line 1409
    tmp___0 = 0;
  } else {
#line 1409
    tmp___0 = 1;
  }
#line 1409
  if (tmp___0) {
#line 1410
    return (-1);
  } else {

  }
#line 1411
  tmp___1 = copy_from_user((void *)(& intinfo), (void const   *)argp, 8UL);
#line 1411
  if (tmp___1 != 0UL) {
#line 1412
    return (-14);
  } else {

  }
#line 1413
  if (intinfo.delay == 0U && intinfo.count == 0U) {
#line 1414
    return (-22);
  } else {

  }
#line 1415
  tmp___2 = spinlock_check(& h->lock);
#line 1415
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1417
  writel(intinfo.delay, (void volatile   *)(& (h->cfgtable)->HostWrite.CoalIntDelay));
#line 1418
  writel(intinfo.count, (void volatile   *)(& (h->cfgtable)->HostWrite.CoalIntCount));
#line 1419
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 1421
  i = 0;
#line 1421
  goto ldv_36936;
  ldv_36935: 
#line 1422
  tmp___3 = readl((void const volatile   *)h->vaddr + 32U);
#line 1422
  if (((long )tmp___3 & 1L) == 0L) {
#line 1423
    goto ldv_36934;
  } else {

  }
#line 1424
  __const_udelay(4295000UL);
#line 1421
  i = i + 1;
  ldv_36936: ;
#line 1421
  if (i <= 999) {
#line 1422
    goto ldv_36935;
  } else {
#line 1424
    goto ldv_36934;
  }
  ldv_36934: 
#line 1426
  spin_unlock_irqrestore(& h->lock, flags);
#line 1427
  if (i > 999) {
#line 1428
    return (-11);
  } else {

  }
#line 1429
  return (0);
}
}
#line 1432 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getnodename(ctlr_info_t *h , void *argp ) 
{ NodeName_type NodeName ;
  int i ;
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 1437
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1438
    return (-22);
  } else {

  }
#line 1439
  i = 0;
#line 1439
  goto ldv_36944;
  ldv_36943: 
#line 1440
  tmp = readb((void const volatile   *)(& (h->cfgtable)->ServerName) + (unsigned long )i);
#line 1440
  NodeName[i] = (char )tmp;
#line 1439
  i = i + 1;
  ldv_36944: ;
#line 1439
  if (i <= 15) {
#line 1440
    goto ldv_36943;
  } else {
#line 1442
    goto ldv_36945;
  }
  ldv_36945: 
#line 1441
  tmp___0 = copy_to_user(argp, (void const   *)(& NodeName), 16U);
#line 1441
  if (tmp___0 != 0) {
#line 1442
    return (-14);
  } else {

  }
#line 1443
  return (0);
}
}
#line 1446 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_setnodename(ctlr_info_t *h , void *argp ) 
{ NodeName_type NodeName ;
  unsigned long flags ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1452
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1453
    return (-22);
  } else {

  }
#line 1454
  tmp = capable(21);
#line 1454
  if (tmp) {
#line 1454
    tmp___0 = 0;
  } else {
#line 1454
    tmp___0 = 1;
  }
#line 1454
  if (tmp___0) {
#line 1455
    return (-1);
  } else {

  }
#line 1456
  tmp___1 = copy_from_user((void *)(& NodeName), (void const   *)argp, 16UL);
#line 1456
  if (tmp___1 != 0UL) {
#line 1457
    return (-14);
  } else {

  }
#line 1458
  tmp___2 = spinlock_check(& h->lock);
#line 1458
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1460
  i = 0;
#line 1460
  goto ldv_36957;
  ldv_36956: 
#line 1461
  writeb((int )((unsigned char )NodeName[i]), (void volatile   *)(& (h->cfgtable)->ServerName) + (unsigned long )i);
#line 1460
  i = i + 1;
  ldv_36957: ;
#line 1460
  if (i <= 15) {
#line 1461
    goto ldv_36956;
  } else {
#line 1463
    goto ldv_36958;
  }
  ldv_36958: 
#line 1462
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 1463
  i = 0;
#line 1463
  goto ldv_36961;
  ldv_36960: 
#line 1464
  tmp___3 = readl((void const volatile   *)h->vaddr + 32U);
#line 1464
  if (((long )tmp___3 & 1L) == 0L) {
#line 1465
    goto ldv_36959;
  } else {

  }
#line 1466
  __const_udelay(4295000UL);
#line 1463
  i = i + 1;
  ldv_36961: ;
#line 1463
  if (i <= 999) {
#line 1464
    goto ldv_36960;
  } else {
#line 1466
    goto ldv_36959;
  }
  ldv_36959: 
#line 1468
  spin_unlock_irqrestore(& h->lock, flags);
#line 1469
  if (i > 999) {
#line 1470
    return (-11);
  } else {

  }
#line 1471
  return (0);
}
}
#line 1474 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getheartbeat(ctlr_info_t *h , void *argp ) 
{ Heartbeat_type heartbeat ;
  int tmp ;

  {
#line 1478
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1479
    return (-22);
  } else {

  }
#line 1480
  heartbeat = readl((void const volatile   *)(& (h->cfgtable)->HeartBeat));
#line 1481
  tmp = copy_to_user(argp, (void const   *)(& heartbeat), 4U);
#line 1481
  if (tmp != 0) {
#line 1482
    return (-14);
  } else {

  }
#line 1483
  return (0);
}
}
#line 1486 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getbustypes(ctlr_info_t *h , void *argp ) 
{ BusTypes_type BusTypes ;
  int tmp ;

  {
#line 1490
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1491
    return (-22);
  } else {

  }
#line 1492
  BusTypes = readl((void const volatile   *)(& (h->cfgtable)->BusTypes));
#line 1493
  tmp = copy_to_user(argp, (void const   *)(& BusTypes), 4U);
#line 1493
  if (tmp != 0) {
#line 1494
    return (-14);
  } else {

  }
#line 1495
  return (0);
}
}
#line 1498 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getfirmver(ctlr_info_t *h , void *argp ) 
{ FirmwareVer_type firmware ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 1502
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1503
    return (-22);
  } else {

  }
#line 1504
  __len = 4UL;
#line 1504
  if (__len > 63UL) {
#line 1504
    __ret = __memcpy((void *)(& firmware), (void const   *)(& h->firm_ver), __len);
  } else {
#line 1504
    __ret = __builtin_memcpy((void *)(& firmware), (void const   *)(& h->firm_ver),
                             __len);
  }
#line 1506
  tmp = copy_to_user(argp, (void const   *)(& firmware), 4U);
#line 1506
  if (tmp != 0) {
#line 1508
    return (-14);
  } else {

  }
#line 1509
  return (0);
}
}
#line 1512 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getdrivver(ctlr_info_t *h , void *argp ) 
{ DriverVer_type DriverVer ;
  int tmp ;

  {
#line 1514
  DriverVer = 198170U;
#line 1516
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1517
    return (-22);
  } else {

  }
#line 1518
  tmp = copy_to_user(argp, (void const   *)(& DriverVer), 4U);
#line 1518
  if (tmp != 0) {
#line 1519
    return (-14);
  } else {

  }
#line 1520
  return (0);
}
}
#line 1523 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getluninfo(ctlr_info_t *h , struct gendisk *disk , void *argp ) 
{ LogvolInfo_struct luninfo ;
  drive_info_struct *drv ;
  drive_info_struct *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 1527
  tmp = get_drv(disk);
#line 1527
  drv = tmp;
#line 1529
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1530
    return (-22);
  } else {

  }
#line 1531
  __len = 4UL;
#line 1531
  if (__len > 63UL) {
#line 1531
    __ret = __memcpy((void *)(& luninfo.LunID), (void const   *)(& drv->LunID), __len);
  } else {
#line 1531
    __ret = __builtin_memcpy((void *)(& luninfo.LunID), (void const   *)(& drv->LunID),
                             __len);
  }
#line 1532
  luninfo.num_opens = drv->usage_count;
#line 1533
  luninfo.num_parts = 0;
#line 1534
  tmp___0 = copy_to_user(argp, (void const   *)(& luninfo), 12U);
#line 1534
  if (tmp___0 != 0) {
#line 1535
    return (-14);
  } else {

  }
#line 1536
  return (0);
}
}
#line 1539 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_passthru(ctlr_info_t *h , void *argp ) 
{ IOCTL_Command_struct iocommand ;
  CommandList_struct *c ;
  char *buff ;
  u64bit temp64 ;
  struct completion wait ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1543
  buff = 0;
#line 1545
  init_completion(& wait);
#line 1545
  wait = wait;
#line 1547
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1548
    return (-22);
  } else {

  }
#line 1550
  tmp = capable(17);
#line 1550
  if (tmp) {
#line 1550
    tmp___0 = 0;
  } else {
#line 1550
    tmp___0 = 1;
  }
#line 1550
  if (tmp___0) {
#line 1551
    return (-1);
  } else {

  }
#line 1553
  tmp___1 = copy_from_user((void *)(& iocommand), (void const   *)argp, 88UL);
#line 1553
  if (tmp___1 != 0UL) {
#line 1555
    return (-14);
  } else {

  }
#line 1556
  if ((unsigned int )iocommand.buf_size == 0U && (unsigned int )*((unsigned char *)(& iocommand) + 9UL) != 0U) {
#line 1558
    return (-22);
  } else {

  }
#line 1560
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1561
    tmp___2 = kmalloc((size_t )iocommand.buf_size, 208U);
#line 1561
    buff = (char *)tmp___2;
#line 1562
    if ((unsigned long )buff == (unsigned long )((char *)0)) {
#line 1563
      return (-14);
    } else {

    }
  } else {

  }
#line 1565
  if ((unsigned int )*((unsigned char *)(& iocommand) + 9UL) == 64U) {
#line 1567
    tmp___3 = copy_from_user((void *)buff, (void const   *)iocommand.buf, (unsigned long )iocommand.buf_size);
#line 1567
    if (tmp___3 != 0UL) {
#line 1568
      kfree((void const   *)buff);
#line 1569
      return (-14);
    } else {
#line 1572
      memset((void *)buff, 0, (size_t )iocommand.buf_size);
    }
  } else {

  }
#line 1574
  c = cmd_special_alloc(h);
#line 1575
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1576
    kfree((void const   *)buff);
#line 1577
    return (-12);
  } else {

  }
#line 1580
  c->cmd_type = 1;
#line 1582
  c->Header.ReplyQueue = 0U;
#line 1583
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1584
    c->Header.SGList = 1U;
#line 1585
    c->Header.SGTotal = 1U;
  } else {
#line 1587
    c->Header.SGList = 0U;
#line 1588
    c->Header.SGTotal = 0U;
  }
#line 1590
  c->Header.LUN = iocommand.LUN_info;
#line 1592
  c->Header.Tag.lower = c->busaddr;
#line 1595
  c->Request = iocommand.Request;
#line 1598
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1599
    temp64.val = pci_map_single(h->pdev, (void *)buff, (size_t )iocommand.buf_size,
                                0);
#line 1601
    c->SG[0].Addr.lower = temp64.val32.lower;
#line 1602
    c->SG[0].Addr.upper = temp64.val32.upper;
#line 1603
    c->SG[0].Len = (__u32 )iocommand.buf_size;
#line 1604
    c->SG[0].Ext = 0U;
  } else {

  }
#line 1606
  c->waiting = & wait;
#line 1608
  enqueue_cmd_and_start_io(h, c);
#line 1609
  wait_for_completion(& wait);
#line 1612
  temp64.val32.lower = c->SG[0].Addr.lower;
#line 1613
  temp64.val32.upper = c->SG[0].Addr.upper;
#line 1614
  pci_unmap_single(h->pdev, temp64.val, (size_t )iocommand.buf_size, 0);
#line 1616
  check_ioctl_unit_attention(h, c);
#line 1619
  iocommand.error_info = *(c->err_info);
#line 1620
  tmp___4 = copy_to_user(argp, (void const   *)(& iocommand), 88U);
#line 1620
  if (tmp___4 != 0) {
#line 1621
    kfree((void const   *)buff);
#line 1622
    cmd_special_free(h, c);
#line 1623
    return (-14);
  } else {

  }
#line 1626
  if ((unsigned int )*((unsigned char *)(& iocommand) + 9UL) == 128U) {
#line 1628
    tmp___5 = copy_to_user((void *)iocommand.buf, (void const   *)buff, (unsigned int )iocommand.buf_size);
#line 1628
    if (tmp___5 != 0) {
#line 1629
      kfree((void const   *)buff);
#line 1630
      cmd_special_free(h, c);
#line 1631
      return (-14);
    } else {

    }
  } else {

  }
#line 1634
  kfree((void const   *)buff);
#line 1635
  cmd_special_free(h, c);
#line 1636
  return (0);
}
}
#line 1639 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_bigpassthru(ctlr_info_t *h , void *argp ) 
{ BIG_IOCTL_Command_struct *ioc ;
  CommandList_struct *c ;
  unsigned char **buff ;
  int *buff_size ;
  u64bit temp64 ;
  __u8 sg_used ;
  int status ;
  int i ;
  struct completion wait ;
  __u32 left ;
  __u32 sz ;
  __u8 *data_ptr ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  __u8 *ptr ;
  int tmp___8 ;

  {
#line 1643
  buff = 0;
#line 1644
  buff_size = 0;
#line 1646
  sg_used = 0U;
#line 1647
  status = 0;
#line 1649
  init_completion(& wait);
#line 1649
  wait = wait;
#line 1654
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1655
    return (-22);
  } else {

  }
#line 1656
  tmp = capable(17);
#line 1656
  if (tmp) {
#line 1656
    tmp___0 = 0;
  } else {
#line 1656
    tmp___0 = 1;
  }
#line 1656
  if (tmp___0) {
#line 1657
    return (-1);
  } else {

  }
#line 1658
  tmp___1 = kmalloc(96UL, 208U);
#line 1658
  ioc = (BIG_IOCTL_Command_struct *)tmp___1;
#line 1659
  if ((unsigned long )ioc == (unsigned long )((BIG_IOCTL_Command_struct *)0)) {
#line 1660
    status = -12;
#line 1661
    goto cleanup1;
  } else {

  }
#line 1663
  tmp___2 = copy_from_user((void *)ioc, (void const   *)argp, 96UL);
#line 1663
  if (tmp___2 != 0UL) {
#line 1664
    status = -14;
#line 1665
    goto cleanup1;
  } else {

  }
#line 1667
  if (ioc->buf_size == 0U && (unsigned int )*((unsigned char *)ioc + 9UL) != 0U) {
#line 1669
    status = -22;
#line 1670
    goto cleanup1;
  } else {

  }
#line 1673
  if (ioc->malloc_size > 128000U) {
#line 1674
    status = -22;
#line 1675
    goto cleanup1;
  } else {

  }
#line 1677
  if (ioc->buf_size > ioc->malloc_size * 32U) {
#line 1678
    status = -22;
#line 1679
    goto cleanup1;
  } else {

  }
#line 1681
  tmp___3 = kzalloc(256UL, 208U);
#line 1681
  buff = (unsigned char **)tmp___3;
#line 1682
  if ((unsigned long )buff == (unsigned long )((unsigned char **)0)) {
#line 1683
    status = -12;
#line 1684
    goto cleanup1;
  } else {

  }
#line 1686
  tmp___4 = kmalloc(128UL, 208U);
#line 1686
  buff_size = (int *)tmp___4;
#line 1687
  if ((unsigned long )buff_size == (unsigned long )((int *)0)) {
#line 1688
    status = -12;
#line 1689
    goto cleanup1;
  } else {

  }
#line 1691
  left = ioc->buf_size;
#line 1692
  data_ptr = ioc->buf;
#line 1693
  goto ldv_37024;
  ldv_37023: ;
#line 1694
  if (left < ioc->malloc_size) {
#line 1694
    sz = left;
  } else {
#line 1694
    sz = ioc->malloc_size;
  }
#line 1695
  *(buff_size + (unsigned long )sg_used) = (int )sz;
#line 1696
  tmp___5 = kmalloc((size_t )sz, 208U);
#line 1696
  *(buff + (unsigned long )sg_used) = (unsigned char *)tmp___5;
#line 1697
  if ((unsigned long )*(buff + (unsigned long )sg_used) == (unsigned long )((unsigned char *)0)) {
#line 1698
    status = -12;
#line 1699
    goto cleanup1;
  } else {

  }
#line 1701
  if ((unsigned int )*((unsigned char *)ioc + 9UL) == 64U) {
#line 1702
    tmp___6 = copy_from_user((void *)*(buff + (unsigned long )sg_used), (void const   *)data_ptr,
                             (unsigned long )sz);
#line 1702
    if (tmp___6 != 0UL) {
#line 1703
      status = -14;
#line 1704
      goto cleanup1;
    } else {
#line 1707
      memset((void *)*(buff + (unsigned long )sg_used), 0, (size_t )sz);
    }
  } else {

  }
#line 1709
  left = left - sz;
#line 1710
  data_ptr = data_ptr + (unsigned long )sz;
#line 1711
  sg_used = (__u8 )((int )sg_used + 1);
  ldv_37024: ;
#line 1693
  if (left != 0U) {
#line 1694
    goto ldv_37023;
  } else {
#line 1696
    goto ldv_37025;
  }
  ldv_37025: 
#line 1713
  c = cmd_special_alloc(h);
#line 1714
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1715
    status = -12;
#line 1716
    goto cleanup1;
  } else {

  }
#line 1718
  c->cmd_type = 1;
#line 1719
  c->Header.ReplyQueue = 0U;
#line 1720
  c->Header.SGList = sg_used;
#line 1721
  c->Header.SGTotal = (__u16 )sg_used;
#line 1722
  c->Header.LUN = ioc->LUN_info;
#line 1723
  c->Header.Tag.lower = c->busaddr;
#line 1725
  c->Request = ioc->Request;
#line 1726
  i = 0;
#line 1726
  goto ldv_37027;
  ldv_37026: 
#line 1727
  temp64.val = pci_map_single(h->pdev, (void *)*(buff + (unsigned long )i), (size_t )*(buff_size + (unsigned long )i),
                              0);
#line 1729
  c->SG[i].Addr.lower = temp64.val32.lower;
#line 1730
  c->SG[i].Addr.upper = temp64.val32.upper;
#line 1731
  c->SG[i].Len = (__u32 )*(buff_size + (unsigned long )i);
#line 1732
  c->SG[i].Ext = 0U;
#line 1726
  i = i + 1;
  ldv_37027: ;
#line 1726
  if ((int )sg_used > i) {
#line 1727
    goto ldv_37026;
  } else {
#line 1729
    goto ldv_37028;
  }
  ldv_37028: 
#line 1734
  c->waiting = & wait;
#line 1735
  enqueue_cmd_and_start_io(h, c);
#line 1736
  wait_for_completion(& wait);
#line 1738
  i = 0;
#line 1738
  goto ldv_37030;
  ldv_37029: 
#line 1739
  temp64.val32.lower = c->SG[i].Addr.lower;
#line 1740
  temp64.val32.upper = c->SG[i].Addr.upper;
#line 1741
  pci_unmap_single(h->pdev, temp64.val, (size_t )*(buff_size + (unsigned long )i),
                   0);
#line 1738
  i = i + 1;
  ldv_37030: ;
#line 1738
  if ((int )sg_used > i) {
#line 1739
    goto ldv_37029;
  } else {
#line 1741
    goto ldv_37031;
  }
  ldv_37031: 
#line 1745
  check_ioctl_unit_attention(h, c);
#line 1747
  ioc->error_info = *(c->err_info);
#line 1748
  tmp___7 = copy_to_user(argp, (void const   *)ioc, 96U);
#line 1748
  if (tmp___7 != 0) {
#line 1749
    cmd_special_free(h, c);
#line 1750
    status = -14;
#line 1751
    goto cleanup1;
  } else {

  }
#line 1753
  if ((unsigned int )*((unsigned char *)ioc + 9UL) == 128U) {
#line 1755
    ptr = ioc->buf;
#line 1756
    i = 0;
#line 1756
    goto ldv_37034;
    ldv_37033: 
#line 1757
    tmp___8 = copy_to_user((void *)ptr, (void const   *)*(buff + (unsigned long )i),
                           (unsigned int )*(buff_size + (unsigned long )i));
#line 1757
    if (tmp___8 != 0) {
#line 1758
      cmd_special_free(h, c);
#line 1759
      status = -14;
#line 1760
      goto cleanup1;
    } else {

    }
#line 1762
    ptr = ptr + (unsigned long )*(buff_size + (unsigned long )i);
#line 1756
    i = i + 1;
    ldv_37034: ;
#line 1756
    if ((int )sg_used > i) {
#line 1757
      goto ldv_37033;
    } else {
#line 1759
      goto ldv_37035;
    }
    ldv_37035: ;
  } else {

  }
#line 1765
  cmd_special_free(h, c);
#line 1766
  status = 0;
  cleanup1: ;
#line 1768
  if ((unsigned long )buff != (unsigned long )((unsigned char **)0)) {
#line 1769
    i = 0;
#line 1769
    goto ldv_37037;
    ldv_37036: 
#line 1770
    kfree((void const   *)*(buff + (unsigned long )i));
#line 1769
    i = i + 1;
    ldv_37037: ;
#line 1769
    if ((int )sg_used > i) {
#line 1770
      goto ldv_37036;
    } else {
#line 1772
      goto ldv_37038;
    }
    ldv_37038: 
#line 1771
    kfree((void const   *)buff);
  } else {

  }
#line 1773
  kfree((void const   *)buff_size);
#line 1774
  kfree((void const   *)ioc);
#line 1775
  return (status);
}
}
#line 1778 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                       unsigned long arg ) 
{ struct gendisk *disk ;
  ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  void *argp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1781
  disk = bdev->bd_disk;
#line 1782
  tmp = get_host(disk);
#line 1782
  h = tmp;
#line 1783
  argp = (void *)arg;
#line 1785
  descriptor.modname = "cciss";
#line 1785
  descriptor.function = "cciss_ioctl";
#line 1785
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1785
  descriptor.format = "cciss_ioctl: Called with cmd=%x %lx\n";
#line 1785
  descriptor.lineno = 1786U;
#line 1785
  descriptor.flags = 0U;
#line 1785
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1785
  if (tmp___0 != 0L) {
#line 1785
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_ioctl: Called with cmd=%x %lx\n",
                      cmd, arg);
  } else {

  }
#line 1787
  switch (cmd) {
  case -2146942463: 
#line 1789
  tmp___1 = cciss_getpciinfo(h, argp);
#line 1789
  return (tmp___1);
  case -2146942462: 
#line 1791
  tmp___2 = cciss_getintinfo(h, argp);
#line 1791
  return (tmp___2);
  case 1074283011: 
#line 1793
  tmp___3 = cciss_setintinfo(h, argp);
#line 1793
  return (tmp___3);
  case -2146418172: 
#line 1795
  tmp___4 = cciss_getnodename(h, argp);
#line 1795
  return (tmp___4);
  case 1074807301: 
#line 1797
  tmp___5 = cciss_setnodename(h, argp);
#line 1797
  return (tmp___5);
  case -2147204602: 
#line 1799
  tmp___6 = cciss_getheartbeat(h, argp);
#line 1799
  return (tmp___6);
  case -2147204601: 
#line 1801
  tmp___7 = cciss_getbustypes(h, argp);
#line 1801
  return (tmp___7);
  case -2147204600: 
#line 1803
  tmp___8 = cciss_getfirmver(h, argp);
#line 1803
  return (tmp___8);
  case -2147204599: 
#line 1805
  tmp___9 = cciss_getdrivver(h, argp);
#line 1805
  return (tmp___9);
  case 16908: ;
  case 16910: ;
  case 16906: 
#line 1809
  tmp___10 = rebuild_lun_table(h, 0, 1);
#line 1809
  return (tmp___10);
  case -2146680303: 
#line 1811
  tmp___11 = cciss_getluninfo(h, disk, argp);
#line 1811
  return (tmp___11);
  case -1067957749: 
#line 1813
  tmp___12 = cciss_passthru(h, argp);
#line 1813
  return (tmp___12);
  case -1067433454: 
#line 1815
  tmp___13 = cciss_bigpassthru(h, argp);
#line 1815
  return (tmp___13);
  case 8834: ;
  case 8705: ;
  case 8706: ;
  case 8818: ;
  case 8821: ;
  case 8707: ;
  case 8837: ;
  case 1: 
#line 1828
  tmp___14 = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);
#line 1828
  return (tmp___14);
  case 21395: ;
  case 21273: ;
  case 21257: ;
  case 21378: ;
  case 21382: ;
  default: ;
#line 1841
  return (-25);
  }
}
}
#line 1845 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_check_queues(ctlr_info_t *h ) 
{ int start_queue ;
  int i ;
  unsigned long tmp ;
  int curr_queue ;
  unsigned long tmp___0 ;

  {
#line 1847
  start_queue = h->next_to_run;
#line 1855
  tmp = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1855
  if (tmp == (unsigned long )h->nr_cmds) {
#line 1856
    return;
  } else {

  }
#line 1862
  i = 0;
#line 1862
  goto ldv_37088;
  ldv_37087: 
#line 1863
  curr_queue = (start_queue + i) % (h->highest_lun + 1);
#line 1867
  if ((unsigned long )h->drv[curr_queue] == (unsigned long )((drive_info_struct *)0)) {
#line 1868
    goto ldv_37085;
  } else {

  }
#line 1869
  if ((unsigned long )(h->drv[curr_queue])->queue == (unsigned long )((struct request_queue *)0) || (h->drv[curr_queue])->heads == 0) {
#line 1871
    goto ldv_37085;
  } else {

  }
#line 1872
  blk_start_queue((h->gendisk[curr_queue])->queue);
#line 1877
  tmp___0 = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1877
  if (tmp___0 == (unsigned long )h->nr_cmds) {
#line 1878
    if (curr_queue == start_queue) {
#line 1879
      h->next_to_run = (start_queue + 1) % (h->highest_lun + 1);
#line 1881
      goto ldv_37086;
    } else {
#line 1883
      h->next_to_run = curr_queue;
#line 1884
      goto ldv_37086;
    }
  } else {

  }
  ldv_37085: 
#line 1862
  i = i + 1;
  ldv_37088: ;
#line 1862
  if (h->highest_lun + 1 > i) {
#line 1863
    goto ldv_37087;
  } else {
#line 1865
    goto ldv_37086;
  }
  ldv_37086: ;
#line 1867
  return;
}
}
#line 1890 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_softirq_done(struct request *rq ) 
{ CommandList_struct *c ;
  ctlr_info_t *h ;
  SGDescriptor_struct *curr_sg ;
  u64bit temp64 ;
  unsigned long flags ;
  int i ;
  int ddir ;
  int sg_index ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1892
  c = (CommandList_struct *)rq->ldv_32525.completion_data;
#line 1893
  h = hba[c->ctlr];
#line 1894
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 1898
  sg_index = 0;
#line 1900
  if ((unsigned int )*((unsigned char *)c + 21UL) == 128U) {
#line 1901
    ddir = 2;
  } else {
#line 1903
    ddir = 1;
  }
#line 1907
  i = 0;
#line 1907
  goto ldv_37101;
  ldv_37100: ;
#line 1908
  if ((curr_sg + (unsigned long )sg_index)->Ext == 2147483648U) {
#line 1909
    cciss_unmap_sg_chain_block(h, c);
#line 1911
    curr_sg = *(h->cmd_sg_list + (unsigned long )c->cmdindex);
#line 1912
    sg_index = 0;
  } else {

  }
#line 1914
  temp64.val32.lower = (curr_sg + (unsigned long )sg_index)->Addr.lower;
#line 1915
  temp64.val32.upper = (curr_sg + (unsigned long )sg_index)->Addr.upper;
#line 1916
  pci_unmap_page(h->pdev, temp64.val, (size_t )(curr_sg + (unsigned long )sg_index)->Len,
                 ddir);
#line 1918
  sg_index = sg_index + 1;
#line 1907
  i = i + 1;
  ldv_37101: ;
#line 1907
  if ((int )c->Header.SGList > i) {
#line 1908
    goto ldv_37100;
  } else {
#line 1910
    goto ldv_37102;
  }
  ldv_37102: 
#line 1921
  descriptor.modname = "cciss";
#line 1921
  descriptor.function = "cciss_softirq_done";
#line 1921
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1921
  descriptor.format = "Done with %p\n";
#line 1921
  descriptor.lineno = 1921U;
#line 1921
  descriptor.flags = 0U;
#line 1921
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1921
  if (tmp != 0L) {
#line 1921
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Done with %p\n",
                      rq);
  } else {

  }
#line 1924
  if ((unsigned int )rq->cmd_type == 2U) {
#line 1925
    rq->resid_len = (c->err_info)->ResidualCnt;
  } else {

  }
#line 1927
  if (rq->errors == 0) {
#line 1927
    tmp___0 = 0;
  } else {
#line 1927
    tmp___0 = -5;
  }
#line 1927
  blk_end_request_all(rq, tmp___0);
#line 1929
  tmp___1 = spinlock_check(& h->lock);
#line 1929
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1930
  cmd_free(h, c);
#line 1931
  cciss_check_queues(h);
#line 1932
  spin_unlock_irqrestore(& h->lock, flags);
#line 1933
  return;
}
}
#line 1935 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void log_unit_to_scsi3addr(ctlr_info_t *h , unsigned char *scsi3addr ,
                                           uint32_t log_unit ) 
{ size_t __len ;
  void *__ret ;

  {
#line 1938
  __len = 8UL;
#line 1938
  if (__len > 63UL) {
#line 1938
    __ret = __memcpy((void *)scsi3addr, (void const   *)(& (h->drv[log_unit])->LunID),
                     __len);
  } else {
#line 1938
    __ret = __builtin_memcpy((void *)scsi3addr, (void const   *)(& (h->drv[log_unit])->LunID),
                             __len);
  }
#line 1940
  return;
}
}
#line 1946 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_device_descr(ctlr_info_t *h , int logvol , char *vendor , char *model ,
                                   char *rev ) 
{ int rc ;
  InquiryData_struct *inq_buf ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1953
  *vendor = 0;
#line 1954
  *model = 0;
#line 1955
  *rev = 0;
#line 1957
  tmp = kzalloc(36UL, 208U);
#line 1957
  inq_buf = (InquiryData_struct *)tmp;
#line 1958
  if ((unsigned long )inq_buf == (unsigned long )((InquiryData_struct *)0)) {
#line 1959
    return;
  } else {

  }
#line 1961
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 1962
  rc = sendcmd_withirq(h, 18, (void *)inq_buf, 36UL, 0, (unsigned char *)(& scsi3addr),
                       0);
#line 1964
  if (rc == 0) {
#line 1965
    __len = 8UL;
#line 1965
    if (__len > 63UL) {
#line 1965
      __ret = __memcpy((void *)vendor, (void const   *)(& inq_buf->data_byte) + 8U,
                       __len);
    } else {
#line 1965
      __ret = __builtin_memcpy((void *)vendor, (void const   *)(& inq_buf->data_byte) + 8U,
                               __len);
    }
#line 1966
    *(vendor + 8UL) = 0;
#line 1967
    __len___0 = 16UL;
#line 1967
    if (__len___0 > 63UL) {
#line 1967
      __ret___0 = __memcpy((void *)model, (void const   *)(& inq_buf->data_byte) + 16U,
                           __len___0);
    } else {
#line 1967
      __ret___0 = __builtin_memcpy((void *)model, (void const   *)(& inq_buf->data_byte) + 16U,
                                   __len___0);
    }
#line 1968
    *(model + 16UL) = 0;
#line 1969
    __len___1 = 4UL;
#line 1969
    if (__len___1 > 63UL) {
#line 1969
      __ret___1 = __memcpy((void *)rev, (void const   *)(& inq_buf->data_byte) + 32U,
                           __len___1);
    } else {
#line 1969
      __ret___1 = __builtin_memcpy((void *)rev, (void const   *)(& inq_buf->data_byte) + 32U,
                                   __len___1);
    }
#line 1970
    *(rev + 4UL) = 0;
  } else {

  }
#line 1973
  kfree((void const   *)inq_buf);
#line 1974
  return;
}
}
#line 1982 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_serial_no(ctlr_info_t *h , int logvol , unsigned char *serial_no ,
                                int buflen ) 
{ int rc ;
  unsigned char *buf ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1990
  if (buflen > 16) {
#line 1991
    buflen = 16;
  } else {

  }
#line 1992
  memset((void *)serial_no, 255, (size_t )buflen);
#line 1993
  tmp = kzalloc(64UL, 208U);
#line 1993
  buf = (unsigned char *)tmp;
#line 1994
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0)) {
#line 1995
    return;
  } else {

  }
#line 1996
  memset((void *)serial_no, 0, (size_t )buflen);
#line 1997
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 1998
  rc = sendcmd_withirq(h, 18, (void *)buf, 64UL, 131, (unsigned char *)(& scsi3addr),
                       0);
#line 2000
  if (rc == 0) {
#line 2001
    __len = (size_t )buflen;
#line 2001
    __ret = __builtin_memcpy((void *)serial_no, (void const   *)buf + 8U, __len);
  } else {

  }
#line 2002
  kfree((void const   *)buf);
#line 2003
  return;
}
}
#line 2009 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_add_disk(ctlr_info_t *h , struct gendisk *disk , int drv_index ) 
{ long tmp ;

  {
#line 2012
  disk->queue = blk_init_queue(& do_cciss_request, & h->lock);
#line 2013
  if ((unsigned long )disk->queue == (unsigned long )((struct request_queue *)0)) {
#line 2014
    goto init_queue_failure;
  } else {

  }
#line 2015
  sprintf((char *)(& disk->disk_name), "cciss/c%dd%d", h->ctlr, drv_index);
#line 2016
  disk->major = h->major;
#line 2017
  disk->first_minor = drv_index << 4;
#line 2018
  disk->fops = & cciss_fops;
#line 2019
  tmp = cciss_create_ld_sysfs_entry(h, drv_index);
#line 2019
  if (tmp != 0L) {
#line 2020
    goto cleanup_queue;
  } else {

  }
#line 2021
  disk->private_data = (void *)h->drv[drv_index];
#line 2022
  disk->driverfs_dev = & (h->drv[drv_index])->dev;
#line 2025
  blk_queue_bounce_limit(disk->queue, (h->pdev)->dma_mask);
#line 2028
  blk_queue_max_segments(disk->queue, (int )((unsigned short )h->maxsgentries));
#line 2030
  blk_queue_max_hw_sectors(disk->queue, (unsigned int )h->cciss_max_sectors);
#line 2032
  blk_queue_softirq_done(disk->queue, & cciss_softirq_done);
#line 2034
  (disk->queue)->queuedata = (void *)h;
#line 2036
  blk_queue_logical_block_size(disk->queue, (int )((unsigned short )(h->drv[drv_index])->block_size));
#line 2042
  __asm__  volatile   ("sfence": : : "memory");
#line 2043
  (h->drv[drv_index])->queue = disk->queue;
#line 2044
  add_disk(disk);
#line 2045
  return (0);
  cleanup_queue: 
#line 2048
  blk_cleanup_queue(disk->queue);
#line 2049
  disk->queue = 0;
  init_queue_failure: ;
#line 2051
  return (-1);
}
}
#line 2064 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_update_drive_info(ctlr_info_t *h , int drv_index , int first_time ,
                                    int via_ioctl ) 
{ struct gendisk *disk ;
  InquiryData_struct *inq_buff ;
  unsigned int block_size___0 ;
  sector_t total_size ;
  unsigned long flags ;
  int ret ;
  drive_info_struct *drvinfo ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;

  {
#line 2068
  inq_buff = 0;
#line 2071
  flags = 0UL;
#line 2072
  ret = 0;
#line 2076
  tmp = kmalloc(36UL, 208U);
#line 2076
  inq_buff = (InquiryData_struct *)tmp;
#line 2077
  tmp___0 = kzalloc(1240UL, 208U);
#line 2077
  drvinfo = (drive_info_struct *)tmp___0;
#line 2078
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0) || (unsigned long )drvinfo == (unsigned long )((drive_info_struct *)0)) {
#line 2079
    goto mem_msg;
  } else {

  }
#line 2082
  if ((unsigned int )h->cciss_read == 136U) {
#line 2083
    cciss_read_capacity_16(h, drv_index, & total_size, & block_size___0);
  } else {
#line 2087
    cciss_read_capacity(h, drv_index, & total_size, & block_size___0);
#line 2091
    if ((unsigned long long )total_size == 4294967295ULL) {
#line 2092
      cciss_read_capacity_16(h, drv_index, & total_size, & block_size___0);
#line 2094
      h->cciss_read = 136U;
#line 2095
      h->cciss_write = 138U;
    } else {
#line 2097
      h->cciss_read = 40U;
#line 2098
      h->cciss_write = 42U;
    }
  }
#line 2102
  cciss_geometry_inquiry(h, drv_index, total_size, block_size___0, inq_buff, drvinfo);
#line 2104
  drvinfo->block_size = (int )block_size___0;
#line 2105
  drvinfo->nr_blocks = total_size + 1UL;
#line 2107
  cciss_get_device_descr(h, drv_index, (char *)(& drvinfo->vendor), (char *)(& drvinfo->model),
                         (char *)(& drvinfo->rev));
#line 2109
  cciss_get_serial_no(h, drv_index, (unsigned char *)(& drvinfo->serial_no), 16);
#line 2112
  __len = 8UL;
#line 2112
  if (__len > 63UL) {
#line 2112
    __ret = __memcpy((void *)(& drvinfo->LunID), (void const   *)(& (h->drv[drv_index])->LunID),
                     __len);
  } else {
#line 2112
    __ret = __builtin_memcpy((void *)(& drvinfo->LunID), (void const   *)(& (h->drv[drv_index])->LunID),
                             __len);
  }
#line 2116
  if ((h->drv[drv_index])->raid_level != -1) {
#line 2116
    tmp___1 = memcmp((void const   *)(& drvinfo->serial_no), (void const   *)(& (h->drv[drv_index])->serial_no),
                     16UL);
#line 2116
    if (((((tmp___1 == 0 && drvinfo->block_size == (h->drv[drv_index])->block_size) && drvinfo->nr_blocks == (h->drv[drv_index])->nr_blocks) && drvinfo->heads == (h->drv[drv_index])->heads) && drvinfo->sectors == (h->drv[drv_index])->sectors) && drvinfo->cylinders == (h->drv[drv_index])->cylinders) {
#line 2125
      goto freeret;
    } else {

    }
  } else {

  }
#line 2133
  if ((h->drv[drv_index])->raid_level != -1 && drv_index != 0) {
#line 2134
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "disk %d has changed.\n",
             drv_index);
#line 2135
    tmp___2 = spinlock_check(& h->lock);
#line 2135
    flags = _raw_spin_lock_irqsave(tmp___2);
#line 2136
    (h->drv[drv_index])->busy_configuring = 1;
#line 2137
    spin_unlock_irqrestore(& h->lock, flags);
#line 2143
    ret = deregister_disk(h, drv_index, 0, via_ioctl);
  } else {

  }
#line 2147
  if (ret != 0) {
#line 2148
    goto freeret;
  } else {

  }
#line 2154
  if ((unsigned long )h->drv[drv_index] == (unsigned long )((drive_info_struct *)0)) {
#line 2155
    drvinfo->device_initialized = 0;
#line 2156
    h->drv[drv_index] = drvinfo;
#line 2157
    drvinfo = 0;
  } else {
#line 2160
    (h->drv[drv_index])->block_size = drvinfo->block_size;
#line 2161
    (h->drv[drv_index])->nr_blocks = drvinfo->nr_blocks;
#line 2162
    (h->drv[drv_index])->heads = drvinfo->heads;
#line 2163
    (h->drv[drv_index])->sectors = drvinfo->sectors;
#line 2164
    (h->drv[drv_index])->cylinders = drvinfo->cylinders;
#line 2165
    (h->drv[drv_index])->raid_level = drvinfo->raid_level;
#line 2166
    __len___0 = 16UL;
#line 2166
    if (__len___0 > 63UL) {
#line 2166
      __ret___0 = __memcpy((void *)(& (h->drv[drv_index])->serial_no), (void const   *)(& drvinfo->serial_no),
                           __len___0);
    } else {
#line 2166
      __ret___0 = __builtin_memcpy((void *)(& (h->drv[drv_index])->serial_no), (void const   *)(& drvinfo->serial_no),
                                   __len___0);
    }
#line 2167
    __len___1 = 9UL;
#line 2167
    if (__len___1 > 63UL) {
#line 2167
      __ret___1 = __memcpy((void *)(& (h->drv[drv_index])->vendor), (void const   *)(& drvinfo->vendor),
                           __len___1);
    } else {
#line 2167
      __ret___1 = __builtin_memcpy((void *)(& (h->drv[drv_index])->vendor), (void const   *)(& drvinfo->vendor),
                                   __len___1);
    }
#line 2169
    __len___2 = 17UL;
#line 2169
    if (__len___2 > 63UL) {
#line 2169
      __ret___2 = __memcpy((void *)(& (h->drv[drv_index])->model), (void const   *)(& drvinfo->model),
                           __len___2);
    } else {
#line 2169
      __ret___2 = __builtin_memcpy((void *)(& (h->drv[drv_index])->model), (void const   *)(& drvinfo->model),
                                   __len___2);
    }
#line 2170
    __len___3 = 5UL;
#line 2170
    if (__len___3 > 63UL) {
#line 2170
      __ret___3 = __memcpy((void *)(& (h->drv[drv_index])->rev), (void const   *)(& drvinfo->rev),
                           __len___3);
    } else {
#line 2170
      __ret___3 = __builtin_memcpy((void *)(& (h->drv[drv_index])->rev), (void const   *)(& drvinfo->rev),
                                   __len___3);
    }
  }
#line 2173
  h->num_luns = h->num_luns + 1;
#line 2174
  disk = h->gendisk[drv_index];
#line 2175
  set_capacity(disk, (h->drv[drv_index])->nr_blocks);
#line 2183
  if (drv_index != 0 || first_time != 0) {
#line 2184
    tmp___3 = cciss_add_disk(h, disk, drv_index);
#line 2184
    if (tmp___3 != 0) {
#line 2185
      cciss_free_gendisk(h, drv_index);
#line 2186
      cciss_free_drive_info(h, drv_index);
#line 2187
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "could not update disk %d\n",
               drv_index);
#line 2189
      h->num_luns = h->num_luns - 1;
    } else {

    }
  } else {

  }
  freeret: 
#line 2194
  kfree((void const   *)inq_buff);
#line 2195
  kfree((void const   *)drvinfo);
#line 2196
  return;
  mem_msg: 
#line 2198
  dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2199
  goto freeret;
}
}
#line 2212 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_alloc_drive_info(ctlr_info_t *h , int controller_node ) 
{ int i ;
  drive_info_struct *drv ;
  void *tmp ;

  {
#line 2218
  i = 0;
#line 2218
  goto ldv_37195;
  ldv_37194: ;
#line 2221
  if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0) && i != 0) {
#line 2222
    goto ldv_37193;
  } else {

  }
#line 2227
  if ((i == 0 && (unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) && (h->drv[i])->raid_level != -1) {
#line 2228
    goto ldv_37193;
  } else {

  }
#line 2234
  if (h->highest_lun < i && controller_node == 0) {
#line 2235
    h->highest_lun = i;
  } else {

  }
#line 2238
  if (i == 0 && (unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) {
#line 2239
    return (i);
  } else {

  }
#line 2245
  tmp = kzalloc(1240UL, 208U);
#line 2245
  drv = (drive_info_struct *)tmp;
#line 2246
  if ((unsigned long )drv == (unsigned long )((drive_info_struct *)0)) {
#line 2247
    return (-1);
  } else {

  }
#line 2248
  drv->raid_level = -1;
#line 2249
  h->drv[i] = drv;
#line 2250
  return (i);
  ldv_37193: 
#line 2218
  i = i + 1;
  ldv_37195: ;
#line 2218
  if (i <= 1023) {
#line 2219
    goto ldv_37194;
  } else {
#line 2221
    goto ldv_37196;
  }
  ldv_37196: ;
#line 2252
  return (-1);
}
}
#line 2255 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_drive_info(ctlr_info_t *h , int drv_index ) 
{ 

  {
#line 2257
  kfree((void const   *)h->drv[drv_index]);
#line 2258
  h->drv[drv_index] = 0;
#line 2259
  return;
}
}
#line 2261 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_gendisk(ctlr_info_t *h , int drv_index ) 
{ 

  {
#line 2263
  put_disk(h->gendisk[drv_index]);
#line 2264
  h->gendisk[drv_index] = 0;
#line 2265
  return;
}
}
#line 2276 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_add_gendisk(ctlr_info_t *h , unsigned char *lunid , int controller_node ) 
{ int drv_index ;
  size_t __len ;
  void *__ret ;
  long tmp ;

  {
#line 2281
  drv_index = cciss_alloc_drive_info(h, controller_node);
#line 2282
  if (drv_index == -1) {
#line 2283
    return (-1);
  } else {

  }
#line 2286
  if ((unsigned long )h->gendisk[drv_index] == (unsigned long )((struct gendisk *)0)) {
#line 2287
    h->gendisk[drv_index] = alloc_disk(16);
#line 2289
    if ((unsigned long )h->gendisk[drv_index] == (unsigned long )((struct gendisk *)0)) {
#line 2290
      dev_err((struct device  const  *)(& (h->pdev)->dev), "could not allocate a new disk %d\n",
              drv_index);
#line 2293
      goto err_free_drive_info;
    } else {

    }
  } else {

  }
#line 2296
  __len = 8UL;
#line 2296
  if (__len > 63UL) {
#line 2296
    __ret = __memcpy((void *)(& (h->drv[drv_index])->LunID), (void const   *)lunid,
                     __len);
  } else {
#line 2296
    __ret = __builtin_memcpy((void *)(& (h->drv[drv_index])->LunID), (void const   *)lunid,
                             __len);
  }
#line 2298
  tmp = cciss_create_ld_sysfs_entry(h, drv_index);
#line 2298
  if (tmp != 0L) {
#line 2299
    goto err_free_disk;
  } else {

  }
#line 2303
  (h->drv[drv_index])->busy_configuring = 0;
#line 2304
  __asm__  volatile   ("sfence": : : "memory");
#line 2305
  return (drv_index);
  err_free_disk: 
#line 2308
  cciss_free_gendisk(h, drv_index);
  err_free_drive_info: 
#line 2310
  cciss_free_drive_info(h, drv_index);
#line 2311
  return (-1);
}
}
#line 2319 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_add_controller_node(ctlr_info_t *h ) 
{ struct gendisk *disk ;
  int drv_index ;
  int tmp ;

  {
#line 2324
  if ((unsigned long )h->gendisk[0] != (unsigned long )((struct gendisk *)0)) {
#line 2325
    return;
  } else {

  }
#line 2327
  drv_index = cciss_add_gendisk(h, (unsigned char *)"", 1);
#line 2328
  if (drv_index == -1) {
#line 2329
    goto error;
  } else {

  }
#line 2330
  (h->drv[drv_index])->block_size = 512;
#line 2331
  (h->drv[drv_index])->nr_blocks = 0UL;
#line 2332
  (h->drv[drv_index])->heads = 0;
#line 2333
  (h->drv[drv_index])->sectors = 0;
#line 2334
  (h->drv[drv_index])->cylinders = 0;
#line 2335
  (h->drv[drv_index])->raid_level = -1;
#line 2336
  memset((void *)(& (h->drv[drv_index])->serial_no), 0, 16UL);
#line 2337
  disk = h->gendisk[drv_index];
#line 2338
  tmp = cciss_add_disk(h, disk, drv_index);
#line 2338
  if (tmp == 0) {
#line 2339
    return;
  } else {

  }
#line 2340
  cciss_free_gendisk(h, drv_index);
#line 2341
  cciss_free_drive_info(h, drv_index);
  error: 
#line 2343
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "could not add disk 0.\n");
#line 2344
  return;
}
}
#line 2355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int rebuild_lun_table(ctlr_info_t *h , int first_time , int via_ioctl ) 
{ int num_luns ;
  ReportLunData_struct *ld_buff ;
  int return_code ;
  int listlength ;
  int i ;
  int drv_found ;
  int drv_index ;
  unsigned char lunid[8U] ;
  unsigned long flags ;
  bool tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  void *tmp___2 ;
  __u32 tmp___3 ;
  int j ;
  size_t __len ;
  void *__ret ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;
  int j___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___6 ;

  {
#line 2359
  ld_buff = 0;
#line 2361
  listlength = 0;
#line 2364
  drv_index = 0;
#line 2365
  lunid[0] = '\000';
#line 2365
  lunid[1] = (unsigned char)0;
#line 2365
  lunid[2] = (unsigned char)0;
#line 2365
  lunid[3] = (unsigned char)0;
#line 2365
  lunid[4] = (unsigned char)0;
#line 2365
  lunid[5] = (unsigned char)0;
#line 2365
  lunid[6] = (unsigned char)0;
#line 2365
  lunid[7] = (unsigned char)0;
#line 2368
  tmp = capable(17);
#line 2368
  if (tmp) {
#line 2368
    tmp___0 = 0;
  } else {
#line 2368
    tmp___0 = 1;
  }
#line 2368
  if (tmp___0) {
#line 2369
    return (-1);
  } else {

  }
#line 2372
  tmp___1 = spinlock_check(& h->lock);
#line 2372
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 2373
  if (h->busy_configuring != 0) {
#line 2374
    spin_unlock_irqrestore(& h->lock, flags);
#line 2375
    return (-16);
  } else {

  }
#line 2377
  h->busy_configuring = 1;
#line 2378
  spin_unlock_irqrestore(& h->lock, flags);
#line 2380
  tmp___2 = kzalloc(8200UL, 208U);
#line 2380
  ld_buff = (ReportLunData_struct *)tmp___2;
#line 2381
  if ((unsigned long )ld_buff == (unsigned long )((ReportLunData_struct *)0)) {
#line 2382
    goto mem_msg;
  } else {

  }
#line 2384
  return_code = sendcmd_withirq(h, 194, (void *)ld_buff, 8200UL, 0, (unsigned char *)"",
                                0);
#line 2388
  if (return_code == 0) {
#line 2389
    tmp___3 = __fswab32(*((__be32 *)(& ld_buff->LUNListLength)));
#line 2389
    listlength = (int )tmp___3;
  } else {
#line 2391
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "report logical volume command failed\n");
#line 2393
    listlength = 0;
#line 2394
    goto freeret;
  }
#line 2397
  num_luns = listlength / 8;
#line 2398
  if (num_luns > 1024) {
#line 2399
    num_luns = 1024;
#line 2400
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "more luns configured on controller than can be handled by this driver.\n");
  } else {

  }
#line 2405
  if (num_luns == 0) {
#line 2406
    cciss_add_controller_node(h);
  } else {

  }
#line 2413
  i = 0;
#line 2413
  goto ldv_37253;
  ldv_37252: 
#line 2415
  drv_found = 0;
#line 2418
  if ((unsigned long )h->drv[i] == (unsigned long )((drive_info_struct *)0)) {
#line 2419
    goto ldv_37242;
  } else {

  }
#line 2421
  j = 0;
#line 2421
  goto ldv_37248;
  ldv_37247: 
#line 2422
  __len = 8UL;
#line 2422
  if (__len > 63UL) {
#line 2422
    __ret = __memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )j,
                     __len);
  } else {
#line 2422
    __ret = __builtin_memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )j,
                             __len);
  }
#line 2423
  tmp___4 = memcmp((void const   *)(& (h->drv[i])->LunID), (void const   *)(& lunid),
                   8UL);
#line 2423
  if (tmp___4 == 0) {
#line 2425
    drv_found = 1;
#line 2426
    goto ldv_37246;
  } else {

  }
#line 2421
  j = j + 1;
  ldv_37248: ;
#line 2421
  if (j < num_luns) {
#line 2422
    goto ldv_37247;
  } else {
#line 2424
    goto ldv_37246;
  }
  ldv_37246: ;
#line 2429
  if (drv_found == 0) {
#line 2431
    tmp___5 = spinlock_check(& h->lock);
#line 2431
    flags = _raw_spin_lock_irqsave(tmp___5);
#line 2432
    (h->drv[i])->busy_configuring = 1;
#line 2433
    spin_unlock_irqrestore(& h->lock, flags);
#line 2434
    return_code = deregister_disk(h, i, 1, via_ioctl);
#line 2435
    if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) {
#line 2436
      (h->drv[i])->busy_configuring = 0;
    } else {

    }
  } else {

  }
  ldv_37242: 
#line 2413
  i = i + 1;
  ldv_37253: ;
#line 2413
  if (h->highest_lun >= i) {
#line 2414
    goto ldv_37252;
  } else {
#line 2416
    goto ldv_37254;
  }
  ldv_37254: 
#line 2445
  i = 0;
#line 2445
  goto ldv_37263;
  ldv_37262: 
#line 2448
  drv_found = 0;
#line 2450
  __len___0 = 8UL;
#line 2450
  if (__len___0 > 63UL) {
#line 2450
    __ret___0 = __memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                         __len___0);
  } else {
#line 2450
    __ret___0 = __builtin_memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                                 __len___0);
  }
#line 2456
  j___0 = 0;
#line 2456
  goto ldv_37261;
  ldv_37260: ;
#line 2457
  if ((unsigned long )h->drv[j___0] != (unsigned long )((drive_info_struct *)0)) {
#line 2457
    tmp___6 = memcmp((void const   *)(& (h->drv[j___0])->LunID), (void const   *)(& lunid),
                     8UL);
#line 2457
    if (tmp___6 == 0) {
#line 2460
      drv_index = j___0;
#line 2461
      drv_found = 1;
#line 2462
      goto ldv_37259;
    } else {

    }
  } else {

  }
#line 2456
  j___0 = j___0 + 1;
  ldv_37261: ;
#line 2456
  if (h->highest_lun >= j___0) {
#line 2457
    goto ldv_37260;
  } else {
#line 2459
    goto ldv_37259;
  }
  ldv_37259: ;
#line 2467
  if (drv_found == 0) {
#line 2468
    drv_index = cciss_add_gendisk(h, (unsigned char *)(& lunid), 0);
#line 2469
    if (drv_index == -1) {
#line 2470
      goto freeret;
    } else {

    }
  } else {

  }
#line 2472
  cciss_update_drive_info(h, drv_index, first_time, via_ioctl);
#line 2445
  i = i + 1;
  ldv_37263: ;
#line 2445
  if (i < num_luns) {
#line 2446
    goto ldv_37262;
  } else {
#line 2448
    goto ldv_37264;
  }
  ldv_37264: ;
  freeret: 
#line 2476
  kfree((void const   *)ld_buff);
#line 2477
  h->busy_configuring = 0;
#line 2482
  return (-1);
  mem_msg: 
#line 2484
  dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2485
  h->busy_configuring = 0;
#line 2486
  goto freeret;
}
}
#line 2489 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_clear_drive_info(drive_info_struct *drive_info ) 
{ 

  {
#line 2492
  drive_info->nr_blocks = 0UL;
#line 2493
  drive_info->block_size = 0;
#line 2494
  drive_info->heads = 0;
#line 2495
  drive_info->sectors = 0;
#line 2496
  drive_info->cylinders = 0;
#line 2497
  drive_info->raid_level = -1;
#line 2498
  memset((void *)(& drive_info->serial_no), 0, 16UL);
#line 2499
  memset((void *)(& drive_info->model), 0, 17UL);
#line 2500
  memset((void *)(& drive_info->rev), 0, 5UL);
#line 2501
  memset((void *)(& drive_info->vendor), 0, 9UL);
#line 2502
  return;
}
}
#line 2529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int deregister_disk(ctlr_info_t *h , int drv_index , int clear_all , int via_ioctl ) 
{ int i ;
  struct gendisk *disk ;
  drive_info_struct *drv ;
  int recalculate_highest_lun ;
  bool tmp ;
  int tmp___0 ;
  struct request_queue *q ;
  int newhighest ;

  {
#line 2537
  tmp = capable(17);
#line 2537
  if (tmp) {
#line 2537
    tmp___0 = 0;
  } else {
#line 2537
    tmp___0 = 1;
  }
#line 2537
  if (tmp___0) {
#line 2538
    return (-1);
  } else {

  }
#line 2540
  drv = h->drv[drv_index];
#line 2541
  disk = h->gendisk[drv_index];
#line 2544
  if (clear_all != 0 || (unsigned long )h->gendisk[0] == (unsigned long )disk) {
#line 2545
    if (drv->usage_count > via_ioctl) {
#line 2546
      return (-16);
    } else
#line 2547
    if (drv->usage_count > 0) {
#line 2548
      return (-16);
    } else {

    }
  } else {

  }
#line 2550
  recalculate_highest_lun = (unsigned long )h->drv[h->highest_lun] == (unsigned long )drv;
#line 2556
  if ((unsigned long )h->gendisk[0] != (unsigned long )disk) {
#line 2557
    q = disk->queue;
#line 2558
    if ((disk->flags & 16) != 0) {
#line 2559
      cciss_destroy_ld_sysfs_entry(h, drv_index, 0);
#line 2560
      del_gendisk(disk);
    } else {

    }
#line 2562
    if ((unsigned long )q != (unsigned long )((struct request_queue *)0)) {
#line 2563
      blk_cleanup_queue(q);
    } else {

    }
#line 2570
    if (clear_all != 0) {
#line 2576
      i = 0;
#line 2576
      goto ldv_37281;
      ldv_37280: ;
#line 2577
      if ((unsigned long )h->gendisk[i] == (unsigned long )disk) {
#line 2578
        h->gendisk[i] = 0;
#line 2579
        goto ldv_37279;
      } else {

      }
#line 2576
      i = i + 1;
      ldv_37281: ;
#line 2576
      if (i <= 1023) {
#line 2577
        goto ldv_37280;
      } else {
#line 2579
        goto ldv_37279;
      }
      ldv_37279: 
#line 2582
      put_disk(disk);
    } else {

    }
  } else {
#line 2585
    set_capacity(disk, 0UL);
#line 2586
    cciss_clear_drive_info(drv);
  }
#line 2589
  h->num_luns = h->num_luns - 1;
#line 2592
  if (clear_all != 0 && recalculate_highest_lun != 0) {
#line 2593
    newhighest = -1;
#line 2594
    i = 0;
#line 2594
    goto ldv_37284;
    ldv_37283: ;
#line 2596
    if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0) && (h->drv[i])->heads != 0) {
#line 2597
      newhighest = i;
    } else {

    }
#line 2594
    i = i + 1;
    ldv_37284: ;
#line 2594
    if (h->highest_lun >= i) {
#line 2595
      goto ldv_37283;
    } else {
#line 2597
      goto ldv_37285;
    }
    ldv_37285: 
#line 2599
    h->highest_lun = newhighest;
  } else {

  }
#line 2601
  return (0);
}
}
#line 2604 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int fill_cmd(ctlr_info_t *h , CommandList_struct *c , __u8 cmd , void *buff ,
                    size_t size , __u8 page_code , unsigned char *scsi3addr , int cmd_type ) 
{ u64bit buff_dma_handle ;
  int status ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2609
  status = 0;
#line 2611
  c->cmd_type = 1;
#line 2612
  c->Header.ReplyQueue = 0U;
#line 2613
  if ((unsigned long )buff != (unsigned long )((void *)0)) {
#line 2614
    c->Header.SGList = 1U;
#line 2615
    c->Header.SGTotal = 1U;
  } else {
#line 2617
    c->Header.SGList = 0U;
#line 2618
    c->Header.SGTotal = 0U;
  }
#line 2620
  c->Header.Tag.lower = c->busaddr;
#line 2621
  __len = 8UL;
#line 2621
  if (__len > 63UL) {
#line 2621
    __ret = __memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)scsi3addr,
                     __len);
  } else {
#line 2621
    __ret = __builtin_memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)scsi3addr,
                             __len);
  }
#line 2623
  c->Request.Type.Type = (unsigned char )cmd_type;
#line 2624
  if (cmd_type == 0) {
#line 2625
    switch ((int )cmd) {
    case 18: ;
#line 2628
    if ((unsigned int )page_code != 0U) {
#line 2629
      c->Request.CDB[1] = 1U;
#line 2630
      c->Request.CDB[2] = page_code;
    } else {

    }
#line 2632
    c->Request.CDBLen = 6U;
#line 2633
    c->Request.Type.Attribute = 4U;
#line 2634
    c->Request.Type.Direction = 2U;
#line 2635
    c->Request.Timeout = 0U;
#line 2636
    c->Request.CDB[0] = 18U;
#line 2637
    c->Request.CDB[4] = (__u8 )size;
#line 2638
    goto ldv_37302;
    case 194: ;
    case 195: 
#line 2644
    c->Request.CDBLen = 12U;
#line 2645
    c->Request.Type.Attribute = 4U;
#line 2646
    c->Request.Type.Direction = 2U;
#line 2647
    c->Request.Timeout = 0U;
#line 2648
    c->Request.CDB[0] = cmd;
#line 2649
    c->Request.CDB[6] = (__u8 )(size >> 24);
#line 2650
    c->Request.CDB[7] = (__u8 )(size >> 16);
#line 2651
    c->Request.CDB[8] = (__u8 )(size >> 8);
#line 2652
    c->Request.CDB[9] = (__u8 )size;
#line 2653
    goto ldv_37302;
    case 37: 
#line 2656
    c->Request.CDBLen = 10U;
#line 2657
    c->Request.Type.Attribute = 4U;
#line 2658
    c->Request.Type.Direction = 2U;
#line 2659
    c->Request.Timeout = 0U;
#line 2660
    c->Request.CDB[0] = cmd;
#line 2661
    goto ldv_37302;
    case 158: 
#line 2663
    c->Request.CDBLen = 16U;
#line 2664
    c->Request.Type.Attribute = 4U;
#line 2665
    c->Request.Type.Direction = 2U;
#line 2666
    c->Request.Timeout = 0U;
#line 2667
    c->Request.CDB[0] = cmd;
#line 2668
    c->Request.CDB[1] = 16U;
#line 2669
    c->Request.CDB[10] = (__u8 )(size >> 24);
#line 2670
    c->Request.CDB[11] = (__u8 )(size >> 16);
#line 2671
    c->Request.CDB[12] = (__u8 )(size >> 8);
#line 2672
    c->Request.CDB[13] = (__u8 )size;
#line 2673
    c->Request.Timeout = 0U;
#line 2674
    c->Request.CDB[0] = cmd;
#line 2675
    goto ldv_37302;
    case 1: 
#line 2677
    c->Request.CDBLen = 12U;
#line 2678
    c->Request.Type.Attribute = 4U;
#line 2679
    c->Request.Type.Direction = 1U;
#line 2680
    c->Request.Timeout = 0U;
#line 2681
    c->Request.CDB[0] = 39U;
#line 2682
    c->Request.CDB[6] = 194U;
#line 2683
    c->Request.CDB[7] = (__u8 )(size >> 8);
#line 2684
    c->Request.CDB[8] = (__u8 )size;
#line 2685
    goto ldv_37302;
    case 0: 
#line 2687
    c->Request.CDBLen = 6U;
#line 2688
    c->Request.Type.Attribute = 4U;
#line 2689
    c->Request.Type.Direction = 0U;
#line 2690
    c->Request.Timeout = 0U;
#line 2691
    goto ldv_37302;
    default: 
#line 2693
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Unknown Command 0x%c\n",
             (int )cmd);
#line 2694
    return (1);
    }
    ldv_37302: ;
  } else
#line 2696
  if (cmd_type == 1) {
#line 2697
    switch ((int )cmd) {
    case 0: 
#line 2699
    c->Request.CDBLen = 12U;
#line 2700
    c->Request.Type.Attribute = 4U;
#line 2701
    c->Request.Type.Direction = 1U;
#line 2702
    c->Request.Timeout = 0U;
#line 2703
    c->Request.CDB[0] = cmd;
#line 2704
    c->Request.CDB[1] = 0U;
#line 2706
    __len___0 = 8UL;
#line 2706
    if (__len___0 > 63UL) {
#line 2706
      __ret___0 = __memcpy((void *)(& c->Request.CDB) + 4U, (void const   *)buff,
                           __len___0);
    } else {
#line 2706
      __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB) + 4U, (void const   *)buff,
                                   __len___0);
    }
#line 2707
    goto ldv_37314;
    case 1: 
#line 2709
    c->Request.CDBLen = 16U;
#line 2710
    c->Request.Type.Attribute = 4U;
#line 2711
    c->Request.Type.Direction = 0U;
#line 2712
    c->Request.Timeout = 0U;
#line 2713
    memset((void *)(& c->Request.CDB), 0, 16UL);
#line 2714
    c->Request.CDB[0] = cmd;
#line 2715
    c->Request.CDB[1] = 3U;
#line 2716
    goto ldv_37314;
    case 3: 
#line 2718
    c->Request.CDBLen = 1U;
#line 2719
    c->Request.Type.Attribute = 4U;
#line 2720
    c->Request.Type.Direction = 1U;
#line 2721
    c->Request.Timeout = 0U;
#line 2722
    c->Request.CDB[0] = cmd;
#line 2723
    goto ldv_37314;
    default: 
#line 2725
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown message type %d\n",
             (int )cmd);
#line 2727
    return (1);
    }
    ldv_37314: ;
  } else {
#line 2730
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown command type %d\n",
             cmd_type);
#line 2731
    return (1);
  }
#line 2734
  if (size != 0UL) {
#line 2735
    buff_dma_handle.val = pci_map_single(h->pdev, buff, size, 0);
#line 2738
    c->SG[0].Addr.lower = buff_dma_handle.val32.lower;
#line 2739
    c->SG[0].Addr.upper = buff_dma_handle.val32.upper;
#line 2740
    c->SG[0].Len = (__u32 )size;
#line 2741
    c->SG[0].Ext = 0U;
  } else {

  }
#line 2743
  return (status);
}
}
#line 2746 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_send_reset(ctlr_info_t *h , unsigned char *scsi3addr , u8 reset_type ) 
{ CommandList_struct *c ;
  int return_status ;

  {
#line 2752
  c = cmd_alloc(h);
#line 2753
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 2754
    return (-12);
  } else {

  }
#line 2755
  return_status = fill_cmd(h, c, 1, 0, 0UL, 0, (unsigned char *)"", 1);
#line 2757
  c->Request.CDB[1] = reset_type;
#line 2758
  if (return_status != 0) {
#line 2759
    cmd_special_free(h, c);
#line 2760
    return (return_status);
  } else {

  }
#line 2762
  c->waiting = 0;
#line 2763
  enqueue_cmd_and_start_io(h, c);
#line 2768
  return (0);
}
}
#line 2771 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int check_target_status(ctlr_info_t *h , CommandList_struct *c ) 
{ int tmp ;

  {
#line 2773
  switch ((int )(c->err_info)->ScsiStatus) {
  case 0: ;
#line 2775
  return (0);
  case 2: ;
#line 2777
  switch ((int )(c->err_info)->SenseInfo[2] & 15) {
  case 0: ;
#line 2778
  return (0);
  case 1: ;
#line 2779
  return (0);
  default: 
#line 2781
  tmp = check_for_unit_attention(h, c);
#line 2781
  if (tmp != 0) {
#line 2782
    return (3);
  } else {

  }
#line 2783
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x check condition, sense key = 0x%02x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->SenseInfo[2]);
  }
#line 2787
  goto ldv_37334;
  default: 
#line 2789
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02xscsi status = 0x%02x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->ScsiStatus);
#line 2792
  goto ldv_37334;
  }
  ldv_37334: ;
#line 2794
  return (1);
}
}
#line 2797 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int process_sendcmd_error(ctlr_info_t *h , CommandList_struct *c ) 
{ int return_status ;

  {
#line 2799
  return_status = 0;
#line 2801
  if ((unsigned int )(c->err_info)->CommandStatus == 0U) {
#line 2802
    return (0);
  } else {

  }
#line 2804
  switch ((int )(c->err_info)->CommandStatus) {
  case 1: 
#line 2806
  return_status = check_target_status(h, c);
#line 2807
  goto ldv_37342;
  case 2: ;
  case 3: ;
#line 2811
  goto ldv_37342;
  case 4: 
#line 2813
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x is reported invalid\n",
           (int )c->Request.CDB[0]);
#line 2815
  return_status = 1;
#line 2816
  goto ldv_37342;
  case 5: 
#line 2818
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x has protocol error\n",
           (int )c->Request.CDB[0]);
#line 2820
  return_status = 1;
#line 2821
  goto ldv_37342;
  case 6: 
#line 2823
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x had  hardware error\n",
           (int )c->Request.CDB[0]);
#line 2825
  return_status = 1;
#line 2826
  goto ldv_37342;
  case 7: 
#line 2828
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x had connection lost\n",
           (int )c->Request.CDB[0]);
#line 2830
  return_status = 1;
#line 2831
  goto ldv_37342;
  case 8: 
#line 2833
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x was aborted\n",
           (int )c->Request.CDB[0]);
#line 2835
  return_status = 1;
#line 2836
  goto ldv_37342;
  case 9: 
#line 2838
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x reports abort failed\n",
           (int )c->Request.CDB[0]);
#line 2840
  return_status = 1;
#line 2841
  goto ldv_37342;
  case 10: 
#line 2843
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unsolicited abort 0x%02x\n",
           (int )c->Request.CDB[0]);
#line 2845
  return_status = 3;
#line 2846
  goto ldv_37342;
  case 12: 
#line 2848
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd unabortable\n");
#line 2849
  return_status = 1;
#line 2850
  goto ldv_37342;
  default: 
#line 2852
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x returned unknown status %x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->CommandStatus);
#line 2855
  return_status = 1;
  }
  ldv_37342: ;
#line 2857
  return (return_status);
}
}
#line 2860 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int sendcmd_withirq_core(ctlr_info_t *h , CommandList_struct *c , int attempt_retry ) 
{ struct completion wait ;
  u64bit buff_dma_handle ;
  int return_status ;

  {
#line 2863
  init_completion(& wait);
#line 2863
  wait = wait;
#line 2865
  return_status = 0;
  resend_cmd2: 
#line 2868
  c->waiting = & wait;
#line 2869
  enqueue_cmd_and_start_io(h, c);
#line 2871
  wait_for_completion(& wait);
#line 2873
  if ((unsigned int )(c->err_info)->CommandStatus == 0U || attempt_retry == 0) {
#line 2874
    goto command_done;
  } else {

  }
#line 2876
  return_status = process_sendcmd_error(h, c);
#line 2878
  if (return_status == 3 && c->retry_count <= 2) {
#line 2880
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "retrying 0x%02x\n", (int )c->Request.CDB[0]);
#line 2882
    c->retry_count = c->retry_count + 1;
#line 2884
    memset((void *)c->err_info, 0, 48UL);
#line 2885
    return_status = 0;
#line 2886
    wait.done = 0U;
#line 2887
    goto resend_cmd2;
  } else {

  }
  command_done: 
#line 2892
  buff_dma_handle.val32.lower = c->SG[0].Addr.lower;
#line 2893
  buff_dma_handle.val32.upper = c->SG[0].Addr.upper;
#line 2894
  pci_unmap_single(h->pdev, buff_dma_handle.val, (size_t )c->SG[0].Len, 0);
#line 2896
  return (return_status);
}
}
#line 2899 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int sendcmd_withirq(ctlr_info_t *h , __u8 cmd , void *buff , size_t size ,
                           __u8 page_code , unsigned char *scsi3addr , int cmd_type ) 
{ CommandList_struct *c ;
  int return_status ;

  {
#line 2906
  c = cmd_special_alloc(h);
#line 2907
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 2908
    return (-12);
  } else {

  }
#line 2909
  return_status = fill_cmd(h, c, (int )cmd, buff, size, (int )page_code, scsi3addr,
                           cmd_type);
#line 2911
  if (return_status == 0) {
#line 2912
    return_status = sendcmd_withirq_core(h, c, 1);
  } else {

  }
#line 2914
  cmd_special_free(h, c);
#line 2915
  return (return_status);
}
}
#line 2918 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_geometry_inquiry(ctlr_info_t *h , int logvol , sector_t total_size ,
                                   unsigned int block_size___0 , InquiryData_struct *inq_buff ,
                                   drive_info_struct *drv ) 
{ int return_code ;
  unsigned long t ;
  unsigned char scsi3addr[8U] ;
  sector_t real_size ;
  unsigned long rem ;
  int _res ;

  {
#line 2928
  memset((void *)inq_buff, 0, 36UL);
#line 2929
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 2930
  return_code = sendcmd_withirq(h, 18, (void *)inq_buff, 36UL, 193, (unsigned char *)(& scsi3addr),
                                0);
#line 2932
  if (return_code == 0) {
#line 2933
    if ((unsigned int )inq_buff->data_byte[8] == 255U) {
#line 2934
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "reading geometry failed, volume does not support reading geometry\n");
#line 2937
      drv->heads = 255;
#line 2938
      drv->sectors = 32;
#line 2939
      drv->cylinders = (int )((unsigned int )total_size + 1U);
#line 2940
      drv->raid_level = 6;
    } else {
#line 2942
      drv->heads = (int )inq_buff->data_byte[6];
#line 2943
      drv->sectors = (int )inq_buff->data_byte[7];
#line 2944
      drv->cylinders = (int )inq_buff->data_byte[4] << 8;
#line 2945
      drv->cylinders = drv->cylinders + (int )inq_buff->data_byte[5];
#line 2946
      drv->raid_level = (int )inq_buff->data_byte[8];
    }
#line 2948
    drv->block_size = (int )block_size___0;
#line 2949
    drv->nr_blocks = total_size + 1UL;
#line 2950
    t = (unsigned long )(drv->heads * drv->sectors);
#line 2951
    if (t > 1UL) {
#line 2952
      real_size = total_size + 1UL;
#line 2953
      _res = (int )(real_size % t);
#line 2953
      real_size = real_size / t;
#line 2953
      rem = (unsigned long )_res;
#line 2954
      if (rem != 0UL) {
#line 2955
        real_size = real_size + 1UL;
      } else {

      }
#line 2956
      drv->cylinders = (int )real_size;
    } else {

    }
  } else {
#line 2959
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "reading geometry failed\n");
  }
#line 2960
  return;
}
}
#line 2964 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_read_capacity(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                unsigned int *block_size___0 ) 
{ ReadCapdata_struct *buf ;
  int return_code ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 2971
  tmp = kzalloc(8UL, 208U);
#line 2971
  buf = (ReadCapdata_struct *)tmp;
#line 2972
  if ((unsigned long )buf == (unsigned long )((ReadCapdata_struct *)0)) {
#line 2973
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2974
    return;
  } else {

  }
#line 2977
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 2978
  return_code = sendcmd_withirq(h, 37, (void *)buf, 8UL, 0, (unsigned char *)(& scsi3addr),
                                0);
#line 2980
  if (return_code == 0) {
#line 2981
    tmp___0 = __fswab32(*((__be32 *)(& buf->total_size)));
#line 2981
    *total_size = (sector_t )tmp___0;
#line 2982
    tmp___1 = __fswab32(*((__be32 *)(& buf->block_size)));
#line 2982
    *block_size___0 = tmp___1;
  } else {
#line 2984
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "read capacity failed\n");
#line 2985
    *total_size = 0UL;
#line 2986
    *block_size___0 = 1024U;
  }
#line 2988
  kfree((void const   *)buf);
#line 2989
  return;
}
}
#line 2991 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_read_capacity_16(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                   unsigned int *block_size___0 ) 
{ ReadCapdata_struct_16 *buf ;
  int return_code ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  __u64 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 2998
  tmp = kzalloc(31UL, 208U);
#line 2998
  buf = (ReadCapdata_struct_16 *)tmp;
#line 2999
  if ((unsigned long )buf == (unsigned long )((ReadCapdata_struct_16 *)0)) {
#line 3000
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 3001
    return;
  } else {

  }
#line 3004
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 3005
  return_code = sendcmd_withirq(h, 158, (void *)buf, 31UL, 0, (unsigned char *)(& scsi3addr),
                                0);
#line 3008
  if (return_code == 0) {
#line 3009
    tmp___0 = __fswab64(*((__be64 *)(& buf->total_size)));
#line 3009
    *total_size = (sector_t )tmp___0;
#line 3010
    tmp___1 = __fswab32(*((__be32 *)(& buf->block_size)));
#line 3010
    *block_size___0 = tmp___1;
  } else {
#line 3012
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "read capacity failed\n");
#line 3013
    *total_size = 0UL;
#line 3014
    *block_size___0 = 1024U;
  }
#line 3016
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "      blocks= %llu block_size= %d\n",
            (unsigned long long )*total_size + 1ULL, *block_size___0);
#line 3018
  kfree((void const   *)buf);
#line 3019
  return;
}
}
#line 3021 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_revalidate(struct gendisk *disk ) 
{ ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  drive_info_struct *drv ;
  drive_info_struct *tmp___0 ;
  int logvol ;
  int FOUND ;
  unsigned int block_size___0 ;
  sector_t total_size ;
  InquiryData_struct *inq_buff ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 3023
  tmp = get_host(disk);
#line 3023
  h = tmp;
#line 3024
  tmp___0 = get_drv(disk);
#line 3024
  drv = tmp___0;
#line 3026
  FOUND = 0;
#line 3029
  inq_buff = 0;
#line 3031
  logvol = 0;
#line 3031
  goto ldv_37424;
  ldv_37423: ;
#line 3032
  if ((unsigned long )h->drv[logvol] == (unsigned long )((drive_info_struct *)0)) {
#line 3033
    goto ldv_37421;
  } else {

  }
#line 3034
  tmp___1 = memcmp((void const   *)(& (h->drv[logvol])->LunID), (void const   *)(& drv->LunID),
                   8UL);
#line 3034
  if (tmp___1 == 0) {
#line 3036
    FOUND = 1;
#line 3037
    goto ldv_37422;
  } else {

  }
  ldv_37421: 
#line 3031
  logvol = logvol + 1;
  ldv_37424: ;
#line 3031
  if (h->highest_lun >= logvol) {
#line 3032
    goto ldv_37423;
  } else {
#line 3034
    goto ldv_37422;
  }
  ldv_37422: ;
#line 3041
  if (FOUND == 0) {
#line 3042
    return (1);
  } else {

  }
#line 3044
  tmp___2 = kmalloc(36UL, 208U);
#line 3044
  inq_buff = (InquiryData_struct *)tmp___2;
#line 3045
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0)) {
#line 3046
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 3047
    return (1);
  } else {

  }
#line 3049
  if ((unsigned int )h->cciss_read == 40U) {
#line 3050
    cciss_read_capacity(h, logvol, & total_size, & block_size___0);
  } else {
#line 3053
    cciss_read_capacity_16(h, logvol, & total_size, & block_size___0);
  }
#line 3056
  cciss_geometry_inquiry(h, logvol, total_size, block_size___0, inq_buff, drv);
#line 3059
  blk_queue_logical_block_size(drv->queue, (int )((unsigned short )drv->block_size));
#line 3060
  set_capacity(disk, drv->nr_blocks);
#line 3062
  kfree((void const   *)inq_buff);
#line 3063
  return (0);
}
}
#line 3069 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *remap_pci_mem(ulong base , ulong size ) 
{ ulong page_base ;
  ulong page_offs ;
  void *page_remapped ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3071
  page_base = base & 0xfffffffffffff000UL;
#line 3072
  page_offs = base - page_base;
#line 3073
  tmp = ioremap((resource_size_t )page_base, page_offs + size);
#line 3073
  page_remapped = tmp;
#line 3075
  if ((unsigned long )page_remapped != (unsigned long )((void *)0)) {
#line 3075
    tmp___0 = page_remapped + page_offs;
  } else {
#line 3075
    tmp___0 = 0;
  }
#line 3075
  return (tmp___0);
}
}
#line 3082 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void start_io(ctlr_info_t *h ) 
{ CommandList_struct *c ;
  struct list_head  const  *__mptr ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 3086
  goto ldv_37440;
  ldv_37439: 
#line 3087
  __mptr = (struct list_head  const  *)h->reqQ.next;
#line 3087
  c = (CommandList_struct *)__mptr + 0xfffffffffffffdb0UL;
#line 3089
  tmp = (*(h->access.fifo_full))(h);
#line 3089
  if (tmp != 0UL) {
#line 3090
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "fifo full\n");
#line 3091
    goto ldv_37438;
  } else {

  }
#line 3095
  removeQ(c);
#line 3096
  h->Qdepth = h->Qdepth - 1U;
#line 3099
  (*(h->access.submit_command))(h, c);
#line 3102
  addQ(& h->cmpQ, c);
  ldv_37440: 
#line 3086
  tmp___0 = list_empty((struct list_head  const  *)(& h->reqQ));
#line 3086
  if (tmp___0 == 0) {
#line 3087
    goto ldv_37439;
  } else {
#line 3089
    goto ldv_37438;
  }
  ldv_37438: ;
#line 3091
  return;
}
}
#line 3109 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void resend_cciss_cmd(ctlr_info_t *h , CommandList_struct *c ) 
{ 

  {
#line 3112
  memset((void *)c->err_info, 0, 48UL);
#line 3115
  addQ(& h->reqQ, c);
#line 3116
  h->Qdepth = h->Qdepth + 1U;
#line 3117
  if (h->Qdepth > h->maxQsinceinit) {
#line 3118
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 3120
  start_io(h);
#line 3121
  return;
}
}
#line 3123 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static unsigned int make_status_bytes(unsigned int scsi_status_byte , unsigned int msg_byte ,
                                               unsigned int host_byte , unsigned int driver_byte ) 
{ 

  {
#line 3128
  return ((((scsi_status_byte & 255U) | ((msg_byte << 8) & 65535U)) | ((host_byte & 255U) << 16)) | (driver_byte << 24));
}
}
#line 3134 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int evaluate_target_status(ctlr_info_t *h , CommandList_struct *cmd ,
                                           int *retry_cmd ) 
{ unsigned char sense_key ;
  unsigned char status_byte ;
  unsigned char msg_byte ;
  unsigned char host_byte ;
  unsigned char driver_byte ;
  int error_value ;
  unsigned int tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 3141
  *retry_cmd = 0;
#line 3143
  status_byte = (cmd->err_info)->ScsiStatus;
#line 3144
  driver_byte = 0U;
#line 3145
  msg_byte = (unsigned char )(cmd->err_info)->CommandStatus;
#line 3147
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3148
    host_byte = 10U;
  } else {
#line 3150
    host_byte = 0U;
  }
#line 3152
  tmp = make_status_bytes((unsigned int )status_byte, (unsigned int )msg_byte, (unsigned int )host_byte,
                          (unsigned int )driver_byte);
#line 3152
  error_value = (int )tmp;
#line 3155
  if ((unsigned int )(cmd->err_info)->ScsiStatus != 2U) {
#line 3156
    if ((unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3157
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has SCSI Status 0x%x\n",
               cmd, (int )(cmd->err_info)->ScsiStatus);
    } else {

    }
#line 3160
    return (error_value);
  } else {

  }
#line 3164
  sense_key = (unsigned int )(cmd->err_info)->SenseInfo[2] & 15U;
#line 3166
  if (((unsigned int )sense_key == 0U || (unsigned int )sense_key == 1U) && (unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3168
    error_value = 0;
  } else {

  }
#line 3170
  tmp___0 = check_for_unit_attention(h, cmd);
#line 3170
  if (tmp___0 != 0) {
#line 3171
    *retry_cmd = (unsigned int )(cmd->rq)->cmd_type != 2U;
#line 3172
    return (0);
  } else {

  }
#line 3176
  if ((unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3177
    if (error_value != 0) {
#line 3178
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has CHECK CONDITION sense key = 0x%x\n",
               cmd, (int )sense_key);
    } else {

    }
#line 3180
    return (error_value);
  } else {

  }
#line 3184
  if ((unsigned long )(cmd->rq)->sense != (unsigned long )((void *)0)) {
#line 3185
    if ((cmd->rq)->sense_len > (unsigned int )(cmd->err_info)->SenseLen) {
#line 3186
      (cmd->rq)->sense_len = (unsigned int )(cmd->err_info)->SenseLen;
    } else {

    }
#line 3187
    __len = (size_t )(cmd->rq)->sense_len;
#line 3187
    __ret = __builtin_memcpy((cmd->rq)->sense, (void const   *)(& (cmd->err_info)->SenseInfo),
                             __len);
  } else {
#line 3190
    (cmd->rq)->sense_len = 0U;
  }
#line 3192
  return (error_value);
}
}
#line 3199 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void complete_command(ctlr_info_t *h , CommandList_struct *cmd , int timeout ) 
{ int retry_cmd ;
  struct request *rq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;

  {
#line 3202
  retry_cmd = 0;
#line 3203
  rq = cmd->rq;
#line 3205
  rq->errors = 0;
#line 3207
  if (timeout != 0) {
#line 3208
    tmp = make_status_bytes(0U, 0U, 0U, 6U);
#line 3208
    rq->errors = (int )tmp;
  } else {

  }
#line 3210
  if ((unsigned int )(cmd->err_info)->CommandStatus == 0U) {
#line 3211
    goto after_error_processing;
  } else {

  }
#line 3213
  switch ((int )(cmd->err_info)->CommandStatus) {
  case 1: 
#line 3215
  rq->errors = evaluate_target_status(h, cmd, & retry_cmd);
#line 3216
  goto ldv_37474;
  case 2: ;
#line 3218
  if ((unsigned int )(cmd->rq)->cmd_type == 1U) {
#line 3219
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has completed with data underrun reported\n",
             cmd);
#line 3222
    (cmd->rq)->resid_len = (cmd->err_info)->ResidualCnt;
  } else {

  }
#line 3224
  goto ldv_37474;
  case 3: ;
#line 3226
  if ((unsigned int )(cmd->rq)->cmd_type == 1U) {
#line 3227
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p has completed with data overrun reported\n",
             cmd);
  } else {

  }
#line 3230
  goto ldv_37474;
  case 4: 
#line 3232
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p is reported invalid\n",
           cmd);
#line 3234
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3234
    tmp___0 = 10U;
  } else {
#line 3234
    tmp___0 = 7U;
  }
#line 3234
  tmp___1 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              tmp___0);
#line 3234
  rq->errors = (int )tmp___1;
#line 3238
  goto ldv_37474;
  case 5: 
#line 3240
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p has protocol error\n",
           cmd);
#line 3242
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3242
    tmp___2 = 10U;
  } else {
#line 3242
    tmp___2 = 7U;
  }
#line 3242
  tmp___3 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              tmp___2);
#line 3242
  rq->errors = (int )tmp___3;
#line 3246
  goto ldv_37474;
  case 6: 
#line 3248
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p had  hardware error\n",
           cmd);
#line 3250
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3250
    tmp___4 = 10U;
  } else {
#line 3250
    tmp___4 = 7U;
  }
#line 3250
  tmp___5 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              tmp___4);
#line 3250
  rq->errors = (int )tmp___5;
#line 3254
  goto ldv_37474;
  case 7: 
#line 3256
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p had connection lost\n",
           cmd);
#line 3258
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3258
    tmp___6 = 10U;
  } else {
#line 3258
    tmp___6 = 7U;
  }
#line 3258
  tmp___7 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              tmp___6);
#line 3258
  rq->errors = (int )tmp___7;
#line 3262
  goto ldv_37474;
  case 8: 
#line 3264
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p was aborted\n",
           cmd);
#line 3266
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3266
    tmp___8 = 10U;
  } else {
#line 3266
    tmp___8 = 5U;
  }
#line 3266
  tmp___9 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              tmp___8);
#line 3266
  rq->errors = (int )tmp___9;
#line 3270
  goto ldv_37474;
  case 9: 
#line 3272
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p reports abort failed\n",
           cmd);
#line 3274
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3274
    tmp___10 = 10U;
  } else {
#line 3274
    tmp___10 = 7U;
  }
#line 3274
  tmp___11 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus,
                               0U, tmp___10);
#line 3274
  rq->errors = (int )tmp___11;
#line 3278
  goto ldv_37474;
  case 10: 
#line 3280
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss%d: unsolicited abort %p\n",
           h->ctlr, cmd);
#line 3282
  if (cmd->retry_count <= 2) {
#line 3283
    retry_cmd = 1;
#line 3284
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "retrying %p\n", cmd);
#line 3285
    cmd->retry_count = cmd->retry_count + 1;
  } else {
#line 3287
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p retried too many times\n",
             cmd);
  }
#line 3289
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3289
    tmp___12 = 10U;
  } else {
#line 3289
    tmp___12 = 5U;
  }
#line 3289
  tmp___13 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus,
                               0U, tmp___12);
#line 3289
  rq->errors = (int )tmp___13;
#line 3293
  goto ldv_37474;
  case 11: 
#line 3295
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p timedout\n", cmd);
#line 3296
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3296
    tmp___14 = 10U;
  } else {
#line 3296
    tmp___14 = 7U;
  }
#line 3296
  tmp___15 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus,
                               0U, tmp___14);
#line 3296
  rq->errors = (int )tmp___15;
#line 3300
  goto ldv_37474;
  case 12: 
#line 3302
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p unabortable\n", cmd);
#line 3303
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3303
    tmp___16 = 10U;
  } else {
#line 3303
    tmp___16 = 7U;
  }
#line 3303
  tmp___17 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus,
                               0U, tmp___16);
#line 3303
  rq->errors = (int )tmp___17;
#line 3307
  goto ldv_37474;
  default: 
#line 3309
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p returned unknown status %x\n",
           cmd, (int )(cmd->err_info)->CommandStatus);
#line 3312
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3312
    tmp___18 = 10U;
  } else {
#line 3312
    tmp___18 = 7U;
  }
#line 3312
  tmp___19 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus,
                               0U, tmp___18);
#line 3312
  rq->errors = (int )tmp___19;
  }
  ldv_37474: ;
  after_error_processing: ;
#line 3321
  if (retry_cmd != 0) {
#line 3322
    resend_cciss_cmd(h, cmd);
#line 3323
    return;
  } else {

  }
#line 3325
  (cmd->rq)->ldv_32525.completion_data = (void *)cmd;
#line 3326
  blk_complete_request(cmd->rq);
#line 3327
  return;
}
}
#line 3329 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_contains_index(u32 tag ) 
{ 

  {
#line 3332
  return (tag & 16U);
}
}
#line 3335 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_to_index(u32 tag ) 
{ 

  {
#line 3338
  return (tag >> 5);
}
}
#line 3341 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_discard_error_bits(ctlr_info_t *h , u32 tag ) 
{ long tmp ;

  {
#line 3345
  tmp = ldv__builtin_expect((h->transMethod & 4UL) != 0UL, 1L);
#line 3345
  if (tmp != 0L) {
#line 3346
    return (tag & 4294967264U);
  } else {

  }
#line 3347
  return (tag & 4294967292U);
}
}
#line 3350 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_mark_tag_indexed(u32 *tag ) 
{ 

  {
#line 3352
  *tag = *tag | 16U;
#line 3353
  return;
}
}
#line 3355 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_set_tag_index(u32 *tag , u32 index ) 
{ 

  {
#line 3357
  *tag = *tag | (index << 5);
#line 3358
  return;
}
}
#line 3363 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void do_cciss_request(struct request_queue *q ) 
{ ctlr_info_t *h ;
  CommandList_struct *c ;
  sector_t start_blk ;
  int seg ;
  struct request *creq ;
  u64bit temp64 ;
  struct scatterlist *tmp_sg ;
  SGDescriptor_struct *curr_sg ;
  drive_info_struct *drv ;
  int i ;
  int dir ;
  int sg_index ;
  int chained ;
  long tmp ;
  size_t __len ;
  void *__ret ;
  struct _ddebug descriptor ;
  unsigned int tmp___0 ;
  sector_t tmp___1 ;
  long tmp___2 ;
  struct page *tmp___3 ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  __u8 tmp___8 ;
  __u8 tmp___9 ;
  u32 upper32 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  __u8 tmp___14 ;
  size_t __len___0 ;
  void *__ret___0 ;
  long tmp___15 ;

  {
#line 3365
  h = (ctlr_info_t *)q->queuedata;
#line 3375
  sg_index = 0;
#line 3376
  chained = 0;
  queue: 
#line 3379
  creq = blk_peek_request(q);
#line 3380
  if ((unsigned long )creq == (unsigned long )((struct request *)0)) {
#line 3381
    goto startio;
  } else {

  }
#line 3383
  tmp = ldv__builtin_expect((int )creq->nr_phys_segments > h->maxsgentries, 0L);
#line 3383
  if (tmp != 0L) {
#line 3383
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"),
                         "i" (3383), "i" (12UL));
    ldv_37522: ;
#line 3383
    goto ldv_37522;
  } else {

  }
#line 3385
  c = cmd_alloc(h);
#line 3386
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 3387
    goto full;
  } else {

  }
#line 3389
  blk_start_request(creq);
#line 3391
  tmp_sg = *(h->scatter_list + (unsigned long )c->cmdindex);
#line 3392
  spin_unlock_irq(q->queue_lock);
#line 3394
  c->cmd_type = 0;
#line 3395
  c->rq = creq;
#line 3398
  drv = (drive_info_struct *)(creq->rq_disk)->private_data;
#line 3399
  c->Header.ReplyQueue = 0U;
#line 3403
  cciss_set_tag_index(& c->Header.Tag.lower, (u32 )c->cmdindex);
#line 3404
  cciss_mark_tag_indexed(& c->Header.Tag.lower);
#line 3405
  __len = 8UL;
#line 3405
  if (__len > 63UL) {
#line 3405
    __ret = __memcpy((void *)(& c->Header.LUN), (void const   *)(& drv->LunID), __len);
  } else {
#line 3405
    __ret = __builtin_memcpy((void *)(& c->Header.LUN), (void const   *)(& drv->LunID),
                             __len);
  }
#line 3406
  c->Request.CDBLen = 10U;
#line 3407
  c->Request.Type.Type = 0U;
#line 3408
  c->Request.Type.Attribute = 4U;
#line 3409
  if ((creq->cmd_flags & 1U) == 0U) {
#line 3409
    c->Request.Type.Direction = 2U;
  } else {
#line 3409
    c->Request.Type.Direction = 1U;
  }
#line 3411
  c->Request.Timeout = 0U;
#line 3412
  if ((creq->cmd_flags & 1U) == 0U) {
#line 3412
    c->Request.CDB[0] = h->cciss_read;
  } else {
#line 3412
    c->Request.CDB[0] = h->cciss_write;
  }
#line 3414
  start_blk = blk_rq_pos((struct request  const  *)creq);
#line 3415
  descriptor.modname = "cciss";
#line 3415
  descriptor.function = "do_cciss_request";
#line 3415
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3415
  descriptor.format = "sector =%d nr_sectors=%d\n";
#line 3415
  descriptor.lineno = 3416U;
#line 3415
  descriptor.flags = 0U;
#line 3415
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3415
  if (tmp___2 != 0L) {
#line 3415
    tmp___0 = blk_rq_sectors((struct request  const  *)creq);
#line 3415
    tmp___1 = blk_rq_pos((struct request  const  *)creq);
#line 3415
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "sector =%d nr_sectors=%d\n",
                      (int )tmp___1, (int )tmp___0);
  } else {

  }
#line 3417
  sg_init_table(tmp_sg, (unsigned int )h->maxsgentries);
#line 3418
  seg = blk_rq_map_sg(q, creq, tmp_sg);
#line 3421
  if ((unsigned int )*((unsigned char *)c + 21UL) == 128U) {
#line 3422
    dir = 2;
  } else {
#line 3424
    dir = 1;
  }
#line 3426
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 3427
  sg_index = 0;
#line 3428
  chained = 0;
#line 3430
  i = 0;
#line 3430
  goto ldv_37530;
  ldv_37529: ;
#line 3431
  if ((sg_index + 1 == h->max_cmd_sgentries && chained == 0) && seg - i > 1) {
#line 3434
    curr_sg = *(h->cmd_sg_list + (unsigned long )c->cmdindex);
#line 3435
    sg_index = 0;
#line 3436
    chained = 1;
  } else {

  }
#line 3438
  (curr_sg + (unsigned long )sg_index)->Len = (tmp_sg + (unsigned long )i)->length;
#line 3439
  tmp___3 = sg_page(tmp_sg + (unsigned long )i);
#line 3439
  temp64.val = pci_map_page(h->pdev, tmp___3, (unsigned long )(tmp_sg + (unsigned long )i)->offset,
                            (size_t )(tmp_sg + (unsigned long )i)->length, dir);
#line 3442
  (curr_sg + (unsigned long )sg_index)->Addr.lower = temp64.val32.lower;
#line 3443
  (curr_sg + (unsigned long )sg_index)->Addr.upper = temp64.val32.upper;
#line 3444
  (curr_sg + (unsigned long )sg_index)->Ext = 0U;
#line 3445
  sg_index = sg_index + 1;
#line 3430
  i = i + 1;
  ldv_37530: ;
#line 3430
  if (i < seg) {
#line 3431
    goto ldv_37529;
  } else {
#line 3433
    goto ldv_37531;
  }
  ldv_37531: ;
#line 3447
  if (chained != 0) {
#line 3448
    cciss_map_sg_chain_block(h, c, *(h->cmd_sg_list + (unsigned long )c->cmdindex),
                             (int )((unsigned int )((1 - h->max_cmd_sgentries) + seg) * 16U));
  } else {

  }
#line 3453
  if ((unsigned int )seg > h->maxSG) {
#line 3454
    h->maxSG = (unsigned int )seg;
  } else {

  }
#line 3456
  descriptor___0.modname = "cciss";
#line 3456
  descriptor___0.function = "do_cciss_request";
#line 3456
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3456
  descriptor___0.format = "Submitting %u sectors in %d segments chained[%d]\n";
#line 3456
  descriptor___0.lineno = 3458U;
#line 3456
  descriptor___0.flags = 0U;
#line 3456
  tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3456
  if (tmp___5 != 0L) {
#line 3456
    tmp___4 = blk_rq_sectors((struct request  const  *)creq);
#line 3456
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "Submitting %u sectors in %d segments chained[%d]\n", tmp___4,
                      seg, chained);
  } else {

  }
#line 3460
  c->Header.SGTotal = (int )((__u16 )seg) + (int )((__u16 )chained);
#line 3461
  if (h->max_cmd_sgentries >= seg) {
#line 3462
    c->Header.SGList = (__u8 )c->Header.SGTotal;
  } else {
#line 3464
    c->Header.SGList = (__u8 )h->max_cmd_sgentries;
  }
#line 3465
  set_performant_mode(h, c);
#line 3467
  tmp___15 = ldv__builtin_expect((unsigned int )creq->cmd_type == 1U, 1L);
#line 3467
  if (tmp___15 != 0L) {
#line 3468
    if ((unsigned int )h->cciss_read == 40U) {
#line 3469
      c->Request.CDB[1] = 0U;
#line 3470
      c->Request.CDB[2] = (__u8 )(start_blk >> 24);
#line 3471
      c->Request.CDB[3] = (__u8 )(start_blk >> 16);
#line 3472
      c->Request.CDB[4] = (__u8 )(start_blk >> 8);
#line 3473
      c->Request.CDB[5] = (__u8 )start_blk;
#line 3474
      c->Request.CDB[6] = 0U;
#line 3475
      tmp___6 = blk_rq_sectors((struct request  const  *)creq);
#line 3475
      c->Request.CDB[7] = (__u8 )(tmp___6 >> 8);
#line 3476
      tmp___7 = blk_rq_sectors((struct request  const  *)creq);
#line 3476
      c->Request.CDB[8] = (__u8 )tmp___7;
#line 3477
      tmp___9 = 0U;
#line 3477
      c->Request.CDB[12] = tmp___9;
#line 3477
      tmp___8 = tmp___9;
#line 3477
      c->Request.CDB[11] = tmp___8;
#line 3477
      c->Request.CDB[9] = tmp___8;
    } else {
#line 3479
      upper32 = (unsigned int )(start_blk >> 32UL);
#line 3481
      c->Request.CDBLen = 16U;
#line 3482
      c->Request.CDB[1] = 0U;
#line 3483
      c->Request.CDB[2] = (__u8 )(upper32 >> 24);
#line 3484
      c->Request.CDB[3] = (__u8 )(upper32 >> 16);
#line 3485
      c->Request.CDB[4] = (__u8 )(upper32 >> 8);
#line 3486
      c->Request.CDB[5] = (__u8 )upper32;
#line 3487
      c->Request.CDB[6] = (__u8 )(start_blk >> 24);
#line 3488
      c->Request.CDB[7] = (__u8 )(start_blk >> 16);
#line 3489
      c->Request.CDB[8] = (__u8 )(start_blk >> 8);
#line 3490
      c->Request.CDB[9] = (__u8 )start_blk;
#line 3491
      tmp___10 = blk_rq_sectors((struct request  const  *)creq);
#line 3491
      c->Request.CDB[10] = (__u8 )(tmp___10 >> 24);
#line 3492
      tmp___11 = blk_rq_sectors((struct request  const  *)creq);
#line 3492
      c->Request.CDB[11] = (__u8 )(tmp___11 >> 16);
#line 3493
      tmp___12 = blk_rq_sectors((struct request  const  *)creq);
#line 3493
      c->Request.CDB[12] = (__u8 )(tmp___12 >> 8);
#line 3494
      tmp___13 = blk_rq_sectors((struct request  const  *)creq);
#line 3494
      c->Request.CDB[13] = (__u8 )tmp___13;
#line 3495
      tmp___14 = 0U;
#line 3495
      c->Request.CDB[15] = tmp___14;
#line 3495
      c->Request.CDB[14] = tmp___14;
    }
  } else
#line 3497
  if ((unsigned int )creq->cmd_type == 2U) {
#line 3498
    c->Request.CDBLen = (__u8 )creq->cmd_len;
#line 3499
    __len___0 = 16UL;
#line 3499
    if (__len___0 > 63UL) {
#line 3499
      __ret___0 = __memcpy((void *)(& c->Request.CDB), (void const   *)creq->cmd,
                           __len___0);
    } else {
#line 3499
      __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)creq->cmd,
                                   __len___0);
    }
  } else {
#line 3501
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bad request type %d\n",
             (unsigned int )creq->cmd_type);
#line 3503
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"),
                         "i" (3503), "i" (12UL));
    ldv_37537: ;
#line 3503
    goto ldv_37537;
  }
#line 3506
  spin_lock_irq(q->queue_lock);
#line 3508
  addQ(& h->reqQ, c);
#line 3509
  h->Qdepth = h->Qdepth + 1U;
#line 3510
  if (h->Qdepth > h->maxQsinceinit) {
#line 3511
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 3513
  goto queue;
  full: 
#line 3515
  blk_stop_queue(q);
  startio: 
#line 3520
  start_io(h);
#line 3521
  return;
}
}
#line 3523 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static unsigned long get_next_completion(ctlr_info_t *h ) 
{ unsigned long tmp ;

  {
#line 3525
  tmp = (*(h->access.command_completed))(h);
#line 3525
  return (tmp);
}
}
#line 3528 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int interrupt_pending(ctlr_info_t *h ) 
{ bool tmp ;

  {
#line 3530
  tmp = (*(h->access.intr_pending))(h);
#line 3530
  return ((int )tmp);
}
}
#line 3533 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static long interrupt_not_for_us(ctlr_info_t *h ) 
{ bool tmp ;
  int tmp___0 ;

  {
#line 3535
  tmp = (*(h->access.intr_pending))(h);
#line 3535
  if (tmp) {
#line 3535
    tmp___0 = 0;
  } else {
#line 3535
    tmp___0 = 1;
  }
#line 3535
  return ((long )(tmp___0 || h->interrupts_enabled == 0));
}
}
#line 3539 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int bad_tag(ctlr_info_t *h , u32 tag_index , u32 raw_tag ) 
{ long tmp ;

  {
#line 3542
  tmp = ldv__builtin_expect((u32 )h->nr_cmds <= tag_index, 0L);
#line 3542
  if (tmp != 0L) {
#line 3543
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bad tag 0x%08x ignored.\n",
             raw_tag);
#line 3544
    return (1);
  } else {

  }
#line 3546
  return (0);
}
}
#line 3549 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void finish_cmd(ctlr_info_t *h , CommandList_struct *c , u32 raw_tag ) 
{ long tmp ;

  {
#line 3552
  removeQ(c);
#line 3553
  tmp = ldv__builtin_expect(c->cmd_type == 0, 1L);
#line 3553
  if (tmp != 0L) {
#line 3554
    complete_command(h, c, 0);
  } else
#line 3555
  if (c->cmd_type == 1) {
#line 3556
    complete(c->waiting);
  } else
#line 3558
  if (c->cmd_type == 3) {
#line 3559
    complete_scsi_command(c, 0, raw_tag);
  } else {

  }
#line 3560
  return;
}
}
#line 3563 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 next_command(ctlr_info_t *h ) 
{ u32 a ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 3567
  tmp___0 = ldv__builtin_expect((h->transMethod & 4UL) == 0UL, 0L);
#line 3567
  if (tmp___0 != 0L) {
#line 3568
    tmp = (*(h->access.command_completed))(h);
#line 3568
    return ((u32 )tmp);
  } else {

  }
#line 3570
  if ((*(h->reply_pool_head) & 1ULL) == (u64 )h->reply_pool_wraparound) {
#line 3571
    a = (u32 )*(h->reply_pool_head);
#line 3572
    h->reply_pool_head = h->reply_pool_head + 1;
#line 3573
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {
#line 3575
    a = 4294967295U;
  }
#line 3578
  if ((unsigned long )h->reply_pool_head == (unsigned long )(h->reply_pool + (unsigned long )h->max_commands)) {
#line 3579
    h->reply_pool_head = h->reply_pool;
#line 3580
    h->reply_pool_wraparound = (unsigned int )h->reply_pool_wraparound ^ 1U;
  } else {

  }
#line 3582
  return (a);
}
}
#line 3586 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 process_indexed_cmd(ctlr_info_t *h , u32 raw_tag ) 
{ u32 tag_index ;
  CommandList_struct *c ;
  u32 tmp ;
  int tmp___0 ;
  u32 tmp___1 ;

  {
#line 3591
  tag_index = cciss_tag_to_index(raw_tag);
#line 3592
  tmp___0 = bad_tag(h, tag_index, raw_tag);
#line 3592
  if (tmp___0 != 0) {
#line 3593
    tmp = next_command(h);
#line 3593
    return (tmp);
  } else {

  }
#line 3594
  c = h->cmd_pool + (unsigned long )tag_index;
#line 3595
  finish_cmd(h, c, raw_tag);
#line 3596
  tmp___1 = next_command(h);
#line 3596
  return (tmp___1);
}
}
#line 3600 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 process_nonindexed_cmd(ctlr_info_t *h , u32 raw_tag ) 
{ CommandList_struct *c ;
  __u32 busaddr_masked ;
  __u32 tag_masked ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  struct list_head  const  *__mptr___0 ;
  u32 tmp___0 ;

  {
#line 3602
  c = 0;
#line 3605
  tag_masked = cciss_tag_discard_error_bits(h, raw_tag);
#line 3606
  __mptr = (struct list_head  const  *)h->cmpQ.next;
#line 3606
  c = (CommandList_struct *)__mptr + 0xfffffffffffffdb0UL;
#line 3606
  goto ldv_37579;
  ldv_37578: 
#line 3607
  busaddr_masked = cciss_tag_discard_error_bits(h, c->busaddr);
#line 3608
  if (busaddr_masked == tag_masked) {
#line 3609
    finish_cmd(h, c, raw_tag);
#line 3610
    tmp = next_command(h);
#line 3610
    return (tmp);
  } else {

  }
#line 3606
  __mptr___0 = (struct list_head  const  *)c->list.next;
#line 3606
  c = (CommandList_struct *)__mptr___0 + 0xfffffffffffffdb0UL;
  ldv_37579: ;
#line 3606
  if ((unsigned long )(& c->list) != (unsigned long )(& h->cmpQ)) {
#line 3607
    goto ldv_37578;
  } else {
#line 3609
    goto ldv_37580;
  }
  ldv_37580: 
#line 3613
  bad_tag(h, (u32 )(h->nr_cmds + 1), raw_tag);
#line 3614
  tmp___0 = next_command(h);
#line 3614
  return (tmp___0);
}
}
#line 3622 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ignore_bogus_interrupt(ctlr_info_t *h ) 
{ long tmp ;
  long tmp___0 ;

  {
#line 3624
  tmp = ldv__builtin_expect(reset_devices == 0U, 1L);
#line 3624
  if (tmp != 0L) {
#line 3625
    return (0);
  } else {

  }
#line 3627
  tmp___0 = ldv__builtin_expect(h->interrupts_enabled != 0, 1L);
#line 3627
  if (tmp___0 != 0L) {
#line 3628
    return (0);
  } else {

  }
#line 3630
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Received interrupt while interrupts disabled (known firmware bug.)  Ignoring.\n");
#line 3633
  return (1);
}
}
#line 3636 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t cciss_intx_discard_completions(int irq , void *dev_id ) 
{ ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 3638
  h = (ctlr_info_t *)dev_id;
#line 3642
  tmp = ignore_bogus_interrupt(h);
#line 3642
  if (tmp != 0) {
#line 3643
    return (0);
  } else {

  }
#line 3645
  tmp___0 = interrupt_not_for_us(h);
#line 3645
  if (tmp___0 != 0L) {
#line 3646
    return (0);
  } else {

  }
#line 3647
  tmp___1 = spinlock_check(& h->lock);
#line 3647
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 3648
  goto ldv_37598;
  ldv_37597: 
#line 3649
  tmp___2 = get_next_completion(h);
#line 3649
  raw_tag = (u32 )tmp___2;
#line 3650
  goto ldv_37595;
  ldv_37594: 
#line 3651
  raw_tag = next_command(h);
  ldv_37595: ;
#line 3650
  if (raw_tag != 4294967295U) {
#line 3651
    goto ldv_37594;
  } else {
#line 3653
    goto ldv_37596;
  }
  ldv_37596: ;
  ldv_37598: 
#line 3648
  tmp___3 = interrupt_pending(h);
#line 3648
  if (tmp___3 != 0) {
#line 3649
    goto ldv_37597;
  } else {
#line 3651
    goto ldv_37599;
  }
  ldv_37599: 
#line 3653
  spin_unlock_irqrestore(& h->lock, flags);
#line 3654
  return (1);
}
}
#line 3657 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t cciss_msix_discard_completions(int irq , void *dev_id ) 
{ ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 3659
  h = (ctlr_info_t *)dev_id;
#line 3663
  tmp = ignore_bogus_interrupt(h);
#line 3663
  if (tmp != 0) {
#line 3664
    return (0);
  } else {

  }
#line 3666
  tmp___0 = spinlock_check(& h->lock);
#line 3666
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3667
  tmp___1 = get_next_completion(h);
#line 3667
  raw_tag = (u32 )tmp___1;
#line 3668
  goto ldv_37611;
  ldv_37610: 
#line 3669
  raw_tag = next_command(h);
  ldv_37611: ;
#line 3668
  if (raw_tag != 4294967295U) {
#line 3669
    goto ldv_37610;
  } else {
#line 3671
    goto ldv_37612;
  }
  ldv_37612: 
#line 3670
  spin_unlock_irqrestore(& h->lock, flags);
#line 3671
  return (1);
}
}
#line 3674 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t do_cciss_intx(int irq , void *dev_id ) 
{ ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned long tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 3676
  h = (ctlr_info_t *)dev_id;
#line 3680
  tmp = interrupt_not_for_us(h);
#line 3680
  if (tmp != 0L) {
#line 3681
    return (0);
  } else {

  }
#line 3682
  tmp___0 = spinlock_check(& h->lock);
#line 3682
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3683
  goto ldv_37627;
  ldv_37626: 
#line 3684
  tmp___1 = get_next_completion(h);
#line 3684
  raw_tag = (u32 )tmp___1;
#line 3685
  goto ldv_37624;
  ldv_37623: 
#line 3686
  tmp___2 = cciss_tag_contains_index(raw_tag);
#line 3686
  if (tmp___2 != 0U) {
#line 3687
    raw_tag = process_indexed_cmd(h, raw_tag);
  } else {
#line 3689
    raw_tag = process_nonindexed_cmd(h, raw_tag);
  }
  ldv_37624: ;
#line 3685
  if (raw_tag != 4294967295U) {
#line 3686
    goto ldv_37623;
  } else {
#line 3688
    goto ldv_37625;
  }
  ldv_37625: ;
  ldv_37627: 
#line 3683
  tmp___3 = interrupt_pending(h);
#line 3683
  if (tmp___3 != 0) {
#line 3684
    goto ldv_37626;
  } else {
#line 3686
    goto ldv_37628;
  }
  ldv_37628: 
#line 3692
  spin_unlock_irqrestore(& h->lock, flags);
#line 3693
  return (1);
}
}
#line 3699 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t do_cciss_msix_intr(int irq , void *dev_id ) 
{ ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  u32 tmp___1 ;

  {
#line 3701
  h = (ctlr_info_t *)dev_id;
#line 3705
  tmp = spinlock_check(& h->lock);
#line 3705
  flags = _raw_spin_lock_irqsave(tmp);
#line 3706
  tmp___0 = get_next_completion(h);
#line 3706
  raw_tag = (u32 )tmp___0;
#line 3707
  goto ldv_37640;
  ldv_37639: 
#line 3708
  tmp___1 = cciss_tag_contains_index(raw_tag);
#line 3708
  if (tmp___1 != 0U) {
#line 3709
    raw_tag = process_indexed_cmd(h, raw_tag);
  } else {
#line 3711
    raw_tag = process_nonindexed_cmd(h, raw_tag);
  }
  ldv_37640: ;
#line 3707
  if (raw_tag != 4294967295U) {
#line 3708
    goto ldv_37639;
  } else {
#line 3710
    goto ldv_37641;
  }
  ldv_37641: 
#line 3713
  spin_unlock_irqrestore(& h->lock, flags);
#line 3714
  return (1);
}
}
#line 3727 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int add_to_scan_list(struct ctlr_info *h ) 
{ struct ctlr_info *test_h ;
  int found ;
  int ret ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3730
  found = 0;
#line 3731
  ret = 0;
#line 3733
  if (h->busy_initializing != 0) {
#line 3734
    return (0);
  } else {

  }
#line 3736
  tmp = ldv_mutex_trylock_17(& h->busy_shutting_down);
#line 3736
  if (tmp == 0) {
#line 3737
    return (0);
  } else {

  }
#line 3739
  ldv_mutex_lock_18(& scan_mutex);
#line 3740
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3740
  test_h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3740
  goto ldv_37654;
  ldv_37653: ;
#line 3741
  if ((unsigned long )test_h == (unsigned long )h) {
#line 3742
    found = 1;
#line 3743
    goto ldv_37652;
  } else {

  }
#line 3740
  __mptr___0 = (struct list_head  const  *)test_h->scan_list.next;
#line 3740
  test_h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbda8UL;
  ldv_37654: ;
#line 3740
  if ((unsigned long )(& test_h->scan_list) != (unsigned long )(& scan_q)) {
#line 3741
    goto ldv_37653;
  } else {
#line 3743
    goto ldv_37652;
  }
  ldv_37652: ;
#line 3746
  if (found == 0 && h->busy_scanning == 0) {
#line 3747
    h->scan_wait.done = 0U;
#line 3748
    list_add_tail(& h->scan_list, & scan_q);
#line 3749
    ret = 1;
  } else {

  }
#line 3751
  ldv_mutex_unlock_19(& scan_mutex);
#line 3752
  ldv_mutex_unlock_20(& h->busy_shutting_down);
#line 3754
  return (ret);
}
}
#line 3770 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void remove_from_scan_list(struct ctlr_info *h ) 
{ struct ctlr_info *test_h ;
  struct ctlr_info *tmp_h ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 3774
  ldv_mutex_lock_21(& scan_mutex);
#line 3775
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3775
  test_h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3775
  __mptr___0 = (struct list_head  const  *)test_h->scan_list.next;
#line 3775
  tmp_h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbda8UL;
#line 3775
  goto ldv_37667;
  ldv_37666: ;
#line 3776
  if ((unsigned long )test_h == (unsigned long )h) {
#line 3777
    list_del(& h->scan_list);
#line 3778
    complete_all(& h->scan_wait);
#line 3779
    ldv_mutex_unlock_22(& scan_mutex);
#line 3780
    return;
  } else {

  }
#line 3775
  test_h = tmp_h;
#line 3775
  __mptr___1 = (struct list_head  const  *)tmp_h->scan_list.next;
#line 3775
  tmp_h = (struct ctlr_info *)__mptr___1 + 0xffffffffffffbda8UL;
  ldv_37667: ;
#line 3775
  if ((unsigned long )(& test_h->scan_list) != (unsigned long )(& scan_q)) {
#line 3776
    goto ldv_37666;
  } else {
#line 3778
    goto ldv_37668;
  }
  ldv_37668: ;
#line 3783
  if (h->busy_scanning != 0) {
#line 3784
    ldv_mutex_unlock_23(& scan_mutex);
#line 3785
    wait_for_completion(& h->scan_wait);
  } else {
#line 3787
    ldv_mutex_unlock_24(& scan_mutex);
  }
#line 3788
  return;
}
}
#line 3803 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int scan_thread(void *data ) 
{ struct ctlr_info *h ;
  long volatile   __ret ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr ;

  {
  ldv_37686: 
#line 3808
  __ret = 1L;
#line 3808
  switch (8UL) {
  case 1: 
#line 3808
  tmp = get_current();
#line 3808
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp->state): : "memory",
                       "cc");
#line 3808
  goto ldv_37675;
  case 2: 
#line 3808
  tmp___0 = get_current();
#line 3808
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 3808
  goto ldv_37675;
  case 4: 
#line 3808
  tmp___1 = get_current();
#line 3808
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 3808
  goto ldv_37675;
  case 8: 
#line 3808
  tmp___2 = get_current();
#line 3808
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 3808
  goto ldv_37675;
  default: 
#line 3808
  __xchg_wrong_size();
  }
  ldv_37675: 
#line 3809
  schedule();
#line 3810
  tmp___3 = kthread_should_stop();
#line 3810
  if ((int )tmp___3) {
#line 3811
    goto ldv_37681;
  } else {

  }
  ldv_37685: 
#line 3814
  ldv_mutex_lock_25(& scan_mutex);
#line 3815
  tmp___4 = list_empty((struct list_head  const  *)(& scan_q));
#line 3815
  if (tmp___4 != 0) {
#line 3816
    ldv_mutex_unlock_26(& scan_mutex);
#line 3817
    goto ldv_37682;
  } else {

  }
#line 3820
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3820
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3823
  list_del(& h->scan_list);
#line 3824
  h->busy_scanning = 1;
#line 3825
  ldv_mutex_unlock_27(& scan_mutex);
#line 3827
  rebuild_lun_table(h, 0, 0);
#line 3828
  complete_all(& h->scan_wait);
#line 3829
  ldv_mutex_lock_28(& scan_mutex);
#line 3830
  h->busy_scanning = 0;
#line 3831
  ldv_mutex_unlock_29(& scan_mutex);
#line 3832
  goto ldv_37685;
  ldv_37682: ;
#line 3833
  goto ldv_37686;
  ldv_37681: ;
#line 3835
  return (0);
}
}
#line 3838 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int check_for_unit_attention(ctlr_info_t *h , CommandList_struct *c ) 
{ 

  {
#line 3840
  if ((unsigned int )(c->err_info)->SenseInfo[2] != 6U) {
#line 3841
    return (0);
  } else {

  }
#line 3843
  switch ((int )(c->err_info)->SenseInfo[12]) {
  case 42: 
#line 3845
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "a state change detected, command retried\n");
#line 3847
  return (1);
  case 62: 
#line 3850
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "LUN failure detected, action required\n");
#line 3852
  return (1);
  case 63: 
#line 3855
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "report LUN data changed\n");
#line 3872
  return (1);
  case 41: 
#line 3875
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "a power on or device reset detected\n");
#line 3877
  return (1);
  case 47: 
#line 3880
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unit attention cleared by another initiator\n");
#line 3882
  return (1);
  default: 
#line 3885
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown unit attention detected\n");
#line 3886
  return (1);
  }
}
}
#line 3895 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void print_cfg_table(ctlr_info_t *h ) 
{ int i ;
  char temp_name[17U] ;
  CfgTable_struct *tb ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  unsigned char tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___4 ;
  unsigned int tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___5 ;
  unsigned int tmp___9 ;
  long tmp___10 ;
  struct _ddebug descriptor___6 ;
  unsigned int tmp___11 ;
  long tmp___12 ;
  struct _ddebug descriptor___7 ;
  unsigned int tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___8 ;
  unsigned int tmp___15 ;
  long tmp___16 ;
  struct _ddebug descriptor___9 ;
  unsigned int tmp___17 ;
  long tmp___18 ;
  unsigned char tmp___19 ;
  struct _ddebug descriptor___10 ;
  long tmp___20 ;
  struct _ddebug descriptor___11 ;
  unsigned int tmp___21 ;
  long tmp___22 ;

  {
#line 3899
  tb = h->cfgtable;
#line 3901
  descriptor.modname = "cciss";
#line 3901
  descriptor.function = "print_cfg_table";
#line 3901
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3901
  descriptor.format = "Controller Configuration information\n";
#line 3901
  descriptor.lineno = 3901U;
#line 3901
  descriptor.flags = 0U;
#line 3901
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3901
  if (tmp != 0L) {
#line 3901
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Controller Configuration information\n");
  } else {

  }
#line 3902
  descriptor___0.modname = "cciss";
#line 3902
  descriptor___0.function = "print_cfg_table";
#line 3902
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3902
  descriptor___0.format = "------------------------------------\n";
#line 3902
  descriptor___0.lineno = 3902U;
#line 3902
  descriptor___0.flags = 0U;
#line 3902
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3902
  if (tmp___0 != 0L) {
#line 3902
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "------------------------------------\n");
  } else {

  }
#line 3903
  i = 0;
#line 3903
  goto ldv_37707;
  ldv_37706: 
#line 3904
  tmp___1 = readb((void const volatile   *)(& tb->Signature) + (unsigned long )i);
#line 3904
  temp_name[i] = (char )tmp___1;
#line 3903
  i = i + 1;
  ldv_37707: ;
#line 3903
  if (i <= 3) {
#line 3904
    goto ldv_37706;
  } else {
#line 3906
    goto ldv_37708;
  }
  ldv_37708: 
#line 3905
  temp_name[4] = 0;
#line 3906
  descriptor___1.modname = "cciss";
#line 3906
  descriptor___1.function = "print_cfg_table";
#line 3906
  descriptor___1.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3906
  descriptor___1.format = "   Signature = %s\n";
#line 3906
  descriptor___1.lineno = 3906U;
#line 3906
  descriptor___1.flags = 0U;
#line 3906
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 3906
  if (tmp___2 != 0L) {
#line 3906
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)(& (h->pdev)->dev),
                      "   Signature = %s\n", (char *)(& temp_name));
  } else {

  }
#line 3907
  descriptor___2.modname = "cciss";
#line 3907
  descriptor___2.function = "print_cfg_table";
#line 3907
  descriptor___2.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3907
  descriptor___2.format = "   Spec Number = %d\n";
#line 3907
  descriptor___2.lineno = 3908U;
#line 3907
  descriptor___2.flags = 0U;
#line 3907
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 3907
  if (tmp___4 != 0L) {
#line 3907
    tmp___3 = readl((void const volatile   *)(& tb->SpecValence));
#line 3907
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)(& (h->pdev)->dev),
                      "   Spec Number = %d\n", tmp___3);
  } else {

  }
#line 3909
  descriptor___3.modname = "cciss";
#line 3909
  descriptor___3.function = "print_cfg_table";
#line 3909
  descriptor___3.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3909
  descriptor___3.format = "   Transport methods supported = 0x%x\n";
#line 3909
  descriptor___3.lineno = 3910U;
#line 3909
  descriptor___3.flags = 0U;
#line 3909
  tmp___6 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 3909
  if (tmp___6 != 0L) {
#line 3909
    tmp___5 = readl((void const volatile   *)(& tb->TransportSupport));
#line 3909
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)(& (h->pdev)->dev),
                      "   Transport methods supported = 0x%x\n", tmp___5);
  } else {

  }
#line 3911
  descriptor___4.modname = "cciss";
#line 3911
  descriptor___4.function = "print_cfg_table";
#line 3911
  descriptor___4.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3911
  descriptor___4.format = "   Transport methods active = 0x%x\n";
#line 3911
  descriptor___4.lineno = 3912U;
#line 3911
  descriptor___4.flags = 0U;
#line 3911
  tmp___8 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 3911
  if (tmp___8 != 0L) {
#line 3911
    tmp___7 = readl((void const volatile   *)(& tb->TransportActive));
#line 3911
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)(& (h->pdev)->dev),
                      "   Transport methods active = 0x%x\n", tmp___7);
  } else {

  }
#line 3913
  descriptor___5.modname = "cciss";
#line 3913
  descriptor___5.function = "print_cfg_table";
#line 3913
  descriptor___5.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3913
  descriptor___5.format = "   Requested transport Method = 0x%x\n";
#line 3913
  descriptor___5.lineno = 3914U;
#line 3913
  descriptor___5.flags = 0U;
#line 3913
  tmp___10 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 3913
  if (tmp___10 != 0L) {
#line 3913
    tmp___9 = readl((void const volatile   *)(& tb->HostWrite.TransportRequest));
#line 3913
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)(& (h->pdev)->dev),
                      "   Requested transport Method = 0x%x\n", tmp___9);
  } else {

  }
#line 3915
  descriptor___6.modname = "cciss";
#line 3915
  descriptor___6.function = "print_cfg_table";
#line 3915
  descriptor___6.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3915
  descriptor___6.format = "   Coalesce Interrupt Delay = 0x%x\n";
#line 3915
  descriptor___6.lineno = 3916U;
#line 3915
  descriptor___6.flags = 0U;
#line 3915
  tmp___12 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 3915
  if (tmp___12 != 0L) {
#line 3915
    tmp___11 = readl((void const volatile   *)(& tb->HostWrite.CoalIntDelay));
#line 3915
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)(& (h->pdev)->dev),
                      "   Coalesce Interrupt Delay = 0x%x\n", tmp___11);
  } else {

  }
#line 3917
  descriptor___7.modname = "cciss";
#line 3917
  descriptor___7.function = "print_cfg_table";
#line 3917
  descriptor___7.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3917
  descriptor___7.format = "   Coalesce Interrupt Count = 0x%x\n";
#line 3917
  descriptor___7.lineno = 3918U;
#line 3917
  descriptor___7.flags = 0U;
#line 3917
  tmp___14 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 3917
  if (tmp___14 != 0L) {
#line 3917
    tmp___13 = readl((void const volatile   *)(& tb->HostWrite.CoalIntCount));
#line 3917
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)(& (h->pdev)->dev),
                      "   Coalesce Interrupt Count = 0x%x\n", tmp___13);
  } else {

  }
#line 3919
  descriptor___8.modname = "cciss";
#line 3919
  descriptor___8.function = "print_cfg_table";
#line 3919
  descriptor___8.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3919
  descriptor___8.format = "   Max outstanding commands = 0x%d\n";
#line 3919
  descriptor___8.lineno = 3920U;
#line 3919
  descriptor___8.flags = 0U;
#line 3919
  tmp___16 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
#line 3919
  if (tmp___16 != 0L) {
#line 3919
    tmp___15 = readl((void const volatile   *)(& tb->CmdsOutMax));
#line 3919
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)(& (h->pdev)->dev),
                      "   Max outstanding commands = 0x%d\n", tmp___15);
  } else {

  }
#line 3921
  descriptor___9.modname = "cciss";
#line 3921
  descriptor___9.function = "print_cfg_table";
#line 3921
  descriptor___9.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3921
  descriptor___9.format = "   Bus Types = 0x%x\n";
#line 3921
  descriptor___9.lineno = 3922U;
#line 3921
  descriptor___9.flags = 0U;
#line 3921
  tmp___18 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
#line 3921
  if (tmp___18 != 0L) {
#line 3921
    tmp___17 = readl((void const volatile   *)(& tb->BusTypes));
#line 3921
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)(& (h->pdev)->dev),
                      "   Bus Types = 0x%x\n", tmp___17);
  } else {

  }
#line 3923
  i = 0;
#line 3923
  goto ldv_37719;
  ldv_37718: 
#line 3924
  tmp___19 = readb((void const volatile   *)(& tb->ServerName) + (unsigned long )i);
#line 3924
  temp_name[i] = (char )tmp___19;
#line 3923
  i = i + 1;
  ldv_37719: ;
#line 3923
  if (i <= 15) {
#line 3924
    goto ldv_37718;
  } else {
#line 3926
    goto ldv_37720;
  }
  ldv_37720: 
#line 3925
  temp_name[16] = 0;
#line 3926
  descriptor___10.modname = "cciss";
#line 3926
  descriptor___10.function = "print_cfg_table";
#line 3926
  descriptor___10.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3926
  descriptor___10.format = "   Server Name = %s\n";
#line 3926
  descriptor___10.lineno = 3926U;
#line 3926
  descriptor___10.flags = 0U;
#line 3926
  tmp___20 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
#line 3926
  if (tmp___20 != 0L) {
#line 3926
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)(& (h->pdev)->dev),
                      "   Server Name = %s\n", (char *)(& temp_name));
  } else {

  }
#line 3927
  descriptor___11.modname = "cciss";
#line 3927
  descriptor___11.function = "print_cfg_table";
#line 3927
  descriptor___11.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3927
  descriptor___11.format = "   Heartbeat Counter = 0x%x\n\n\n";
#line 3927
  descriptor___11.lineno = 3928U;
#line 3927
  descriptor___11.flags = 0U;
#line 3927
  tmp___22 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
#line 3927
  if (tmp___22 != 0L) {
#line 3927
    tmp___21 = readl((void const volatile   *)(& tb->HeartBeat));
#line 3927
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)(& (h->pdev)->dev),
                      "   Heartbeat Counter = 0x%x\n\n\n", tmp___21);
  } else {

  }
#line 3929
  return;
}
}
#line 3931 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int find_PCI_BAR_index(struct pci_dev *pdev , unsigned long pci_bar_addr ) 
{ int i ;
  int offset ;
  int mem_type ;
  int bar_type ;

  {
#line 3934
  if (pci_bar_addr == 16UL) {
#line 3935
    return (0);
  } else {

  }
#line 3936
  offset = 0;
#line 3937
  i = 0;
#line 3937
  goto ldv_37737;
  ldv_37736: 
#line 3938
  bar_type = (int )pdev->resource[i].flags & 1;
#line 3939
  if (bar_type == 1) {
#line 3940
    offset = offset + 4;
  } else {
#line 3942
    mem_type = (int )pdev->resource[i].flags & 6;
#line 3944
    switch (mem_type) {
    case 0: ;
    case 2: 
#line 3947
    offset = offset + 4;
#line 3948
    goto ldv_37733;
    case 4: 
#line 3950
    offset = offset + 8;
#line 3951
    goto ldv_37733;
    default: 
#line 3953
    dev_warn((struct device  const  *)(& pdev->dev), "Base address is invalid\n");
#line 3955
    return (-1);
    }
    ldv_37733: ;
  }
#line 3959
  if ((unsigned long )offset == pci_bar_addr - 16UL) {
#line 3960
    return (i + 1);
  } else {

  }
#line 3937
  i = i + 1;
  ldv_37737: ;
#line 3937
  if (i <= 16) {
#line 3938
    goto ldv_37736;
  } else {
#line 3940
    goto ldv_37738;
  }
  ldv_37738: ;
#line 3962
  return (-1);
}
}
#line 3977 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void calc_bucket_map(int *bucket , int num_buckets , int nsgs , int *bucket_map ) 
{ int i ;
  int j ;
  int b ;
  int size ;

  {
#line 3986
  i = 0;
#line 3986
  goto ldv_37753;
  ldv_37752: 
#line 3988
  size = i + 4;
#line 3989
  b = num_buckets;
#line 3991
  j = 0;
#line 3991
  goto ldv_37751;
  ldv_37750: ;
#line 3992
  if (*(bucket + (unsigned long )j) >= size) {
#line 3993
    b = j;
#line 3994
    goto ldv_37749;
  } else {

  }
#line 3991
  j = j + 1;
  ldv_37751: ;
#line 3991
  if (j <= 7) {
#line 3992
    goto ldv_37750;
  } else {
#line 3994
    goto ldv_37749;
  }
  ldv_37749: 
#line 3998
  *(bucket_map + (unsigned long )i) = b;
#line 3986
  i = i + 1;
  ldv_37753: ;
#line 3986
  if (i <= nsgs) {
#line 3987
    goto ldv_37752;
  } else {
#line 3989
    goto ldv_37754;
  }
  ldv_37754: ;
#line 3991
  return;
}
}
#line 4002 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_wait_for_mode_change_ack(ctlr_info_t *h ) 
{ int i ;
  unsigned int tmp ;

  {
#line 4009
  i = 0;
#line 4009
  goto ldv_37761;
  ldv_37760: 
#line 4010
  tmp = readl((void const volatile   *)h->vaddr + 32U);
#line 4010
  if (((long )tmp & 1L) == 0L) {
#line 4011
    goto ldv_37759;
  } else {

  }
#line 4012
  usleep_range(10000UL, 20000UL);
#line 4009
  i = i + 1;
  ldv_37761: ;
#line 4009
  if (i <= 29999) {
#line 4010
    goto ldv_37760;
  } else {
#line 4012
    goto ldv_37759;
  }
  ldv_37759: ;
#line 4014
  return;
}
}
#line 4016 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_enter_performant_mode(ctlr_info_t *h , u32 use_short_tags ) 
{ __u32 trans_offset ;
  int bft[8U] ;
  unsigned long register_value ;
  unsigned int tmp ;

  {
#line 4037
  bft[0] = 5;
#line 4037
  bft[1] = 6;
#line 4037
  bft[2] = 8;
#line 4037
  bft[3] = 10;
#line 4037
  bft[4] = 12;
#line 4037
  bft[5] = 20;
#line 4037
  bft[6] = 28;
#line 4037
  bft[7] = 36;
#line 4047
  h->reply_pool_wraparound = 1U;
#line 4050
  memset((void *)h->reply_pool, 0, (unsigned long )h->max_commands * 8UL);
#line 4051
  h->reply_pool_head = h->reply_pool;
#line 4053
  trans_offset = readl((void const volatile   *)(& (h->cfgtable)->TransMethodOffset));
#line 4054
  calc_bucket_map((int *)(& bft), 8, h->maxsgentries, (int *)h->blockFetchTable);
#line 4056
  writel((unsigned int )bft[0], (void volatile   *)(& (h->transtable)->BlockFetch0));
#line 4057
  writel((unsigned int )bft[1], (void volatile   *)(& (h->transtable)->BlockFetch1));
#line 4058
  writel((unsigned int )bft[2], (void volatile   *)(& (h->transtable)->BlockFetch2));
#line 4059
  writel((unsigned int )bft[3], (void volatile   *)(& (h->transtable)->BlockFetch3));
#line 4060
  writel((unsigned int )bft[4], (void volatile   *)(& (h->transtable)->BlockFetch4));
#line 4061
  writel((unsigned int )bft[5], (void volatile   *)(& (h->transtable)->BlockFetch5));
#line 4062
  writel((unsigned int )bft[6], (void volatile   *)(& (h->transtable)->BlockFetch6));
#line 4063
  writel((unsigned int )bft[7], (void volatile   *)(& (h->transtable)->BlockFetch7));
#line 4066
  writel((unsigned int )h->max_commands, (void volatile   *)(& (h->transtable)->RepQSize));
#line 4067
  writel(1U, (void volatile   *)(& (h->transtable)->RepQCount));
#line 4068
  writel(0U, (void volatile   *)(& (h->transtable)->RepQCtrAddrLow32));
#line 4069
  writel(0U, (void volatile   *)(& (h->transtable)->RepQCtrAddrHigh32));
#line 4070
  writel((unsigned int )h->reply_pool_dhandle, (void volatile   *)(& (h->transtable)->RepQAddr0Low32));
#line 4071
  writel(0U, (void volatile   *)(& (h->transtable)->RepQAddr0High32));
#line 4072
  writel(use_short_tags | 4U, (void volatile   *)(& (h->cfgtable)->HostWrite.TransportRequest));
#line 4075
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 4076
  cciss_wait_for_mode_change_ack(h);
#line 4077
  tmp = readl((void const volatile   *)(& (h->cfgtable)->TransportActive));
#line 4077
  register_value = (unsigned long )tmp;
#line 4078
  if ((register_value & 4UL) == 0UL) {
#line 4079
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: unable to get board into performant mode\n");
  } else {

  }
#line 4080
  return;
}
}
#line 4083 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_put_controller_into_performant_mode(ctlr_info_t *h ) 
{ __u32 trans_support ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 4087
  if (cciss_simple_mode != 0) {
#line 4088
    return;
  } else {

  }
#line 4090
  descriptor.modname = "cciss";
#line 4090
  descriptor.function = "cciss_put_controller_into_performant_mode";
#line 4090
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4090
  descriptor.format = "Trying to put board into Performant mode\n";
#line 4090
  descriptor.lineno = 4090U;
#line 4090
  descriptor.flags = 0U;
#line 4090
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4090
  if (tmp != 0L) {
#line 4090
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Trying to put board into Performant mode\n");
  } else {

  }
#line 4093
  trans_support = readl((void const volatile   *)(& (h->cfgtable)->TransportSupport));
#line 4094
  if ((trans_support & 4U) == 0U) {
#line 4095
    return;
  } else {

  }
#line 4097
  descriptor___0.modname = "cciss";
#line 4097
  descriptor___0.function = "cciss_put_controller_into_performant_mode";
#line 4097
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4097
  descriptor___0.format = "Placing controller into performant mode\n";
#line 4097
  descriptor___0.lineno = 4097U;
#line 4097
  descriptor___0.flags = 0U;
#line 4097
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4097
  if (tmp___0 != 0L) {
#line 4097
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "Placing controller into performant mode\n");
  } else {

  }
#line 4111
  tmp___1 = pci_alloc_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, & h->reply_pool_dhandle);
#line 4111
  h->reply_pool = (u64 *)tmp___1;
#line 4116
  tmp___2 = kmalloc((unsigned long )(h->maxsgentries + 1) * 4UL, 208U);
#line 4116
  h->blockFetchTable = (u32 *)tmp___2;
#line 4119
  if ((unsigned long )h->reply_pool == (unsigned long )((u64 *)0) || (unsigned long )h->blockFetchTable == (unsigned long )((u32 *)0)) {
#line 4120
    goto clean_up;
  } else {

  }
#line 4122
  cciss_enter_performant_mode(h, trans_support & 536870912U);
#line 4126
  h->access = SA5_performant_access;
#line 4127
  h->transMethod = 4UL;
#line 4129
  return;
  clean_up: 
#line 4131
  kfree((void const   *)h->blockFetchTable);
#line 4132
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 4133
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 4137
  return;
}
}
#line 4145 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_interrupt_mode(ctlr_info_t *h ) 
{ int err ;
  struct msix_entry cciss_msix_entries[4U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4149
  cciss_msix_entries[0].vector = 0U;
#line 4149
  cciss_msix_entries[0].entry = 0U;
#line 4149
  cciss_msix_entries[1].vector = 0U;
#line 4149
  cciss_msix_entries[1].entry = 1U;
#line 4149
  cciss_msix_entries[2].vector = 0U;
#line 4149
  cciss_msix_entries[2].entry = 2U;
#line 4149
  cciss_msix_entries[3].vector = 0U;
#line 4149
  cciss_msix_entries[3].entry = 3U;
#line 4154
  if (((h->board_id == 1081085457U || h->board_id == 1082134033U) || h->board_id == 1082265105U) || h->board_id == 1082330641U) {
#line 4156
    goto default_int_mode;
  } else {

  }
#line 4158
  tmp = pci_find_capability(h->pdev, 17);
#line 4158
  if (tmp != 0) {
#line 4159
    err = pci_enable_msix(h->pdev, (struct msix_entry *)(& cciss_msix_entries), 4);
#line 4160
    if (err == 0) {
#line 4161
      h->intr[0] = cciss_msix_entries[0].vector;
#line 4162
      h->intr[1] = cciss_msix_entries[1].vector;
#line 4163
      h->intr[2] = cciss_msix_entries[2].vector;
#line 4164
      h->intr[3] = cciss_msix_entries[3].vector;
#line 4165
      h->msix_vector = 1U;
#line 4166
      return;
    } else {

    }
#line 4168
    if (err > 0) {
#line 4169
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "only %d MSI-X vectors available\n",
               err);
#line 4171
      goto default_int_mode;
    } else {
#line 4173
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "MSI-X init failed %d\n",
               err);
#line 4175
      goto default_int_mode;
    }
  } else {

  }
#line 4178
  tmp___1 = pci_find_capability(h->pdev, 5);
#line 4178
  if (tmp___1 != 0) {
#line 4179
    tmp___0 = pci_enable_msi_block(h->pdev, 1U);
#line 4179
    if (tmp___0 == 0) {
#line 4180
      h->msi_vector = 1U;
    } else {
#line 4182
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "MSI init failed\n");
    }
  } else {

  }
  default_int_mode: 
#line 4187
  h->intr[h->intr_mode] = (h->pdev)->irq;
#line 4188
  return;
}
}
#line 4191 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_lookup_board_id(struct pci_dev *pdev , u32 *board_id ) 
{ int i ;
  u32 subsystem_vendor_id ;
  u32 subsystem_device_id ;

  {
#line 4196
  subsystem_vendor_id = (u32 )pdev->subsystem_vendor;
#line 4197
  subsystem_device_id = (u32 )pdev->subsystem_device;
#line 4198
  *board_id = (subsystem_device_id << 16) | subsystem_vendor_id;
#line 4201
  i = 0;
#line 4201
  goto ldv_37795;
  ldv_37794: ;
#line 4202
  if (*board_id == products[i].board_id) {
#line 4203
    return (i);
  } else {

  }
#line 4201
  i = i + 1;
  ldv_37795: ;
#line 4201
  if ((unsigned int )i <= 21U) {
#line 4202
    goto ldv_37794;
  } else {
#line 4204
    goto ldv_37796;
  }
  ldv_37796: 
#line 4204
  dev_warn((struct device  const  *)(& pdev->dev), "unrecognized board ID: 0x%08x, ignoring.\n",
           *board_id);
#line 4206
  return (-19);
}
}
#line 4209 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static bool cciss_board_disabled(ctlr_info_t *h ) 
{ u16 command ;

  {
#line 4213
  pci_read_config_word((struct pci_dev  const  *)h->pdev, 4, & command);
#line 4214
  return (((int )command & 2) == 0);
}
}
#line 4217 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_pci_find_memory_BAR(struct pci_dev *pdev , unsigned long *memory_bar ) 
{ int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 4222
  i = 0;
#line 4222
  goto ldv_37809;
  ldv_37808: ;
#line 4223
  if ((pdev->resource[i].flags & 512UL) != 0UL) {
#line 4225
    *memory_bar = (unsigned long )pdev->resource[i].start;
#line 4226
    descriptor.modname = "cciss";
#line 4226
    descriptor.function = "cciss_pci_find_memory_BAR";
#line 4226
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4226
    descriptor.format = "memory BAR = %lx\n";
#line 4226
    descriptor.lineno = 4227U;
#line 4226
    descriptor.flags = 0U;
#line 4226
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4226
    if (tmp != 0L) {
#line 4226
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& pdev->dev), "memory BAR = %lx\n",
                        *memory_bar);
    } else {

    }
#line 4228
    return (0);
  } else {

  }
#line 4222
  i = i + 1;
  ldv_37809: ;
#line 4222
  if (i <= 16) {
#line 4223
    goto ldv_37808;
  } else {
#line 4225
    goto ldv_37810;
  }
  ldv_37810: 
#line 4230
  dev_warn((struct device  const  *)(& pdev->dev), "no memory BAR found\n");
#line 4231
  return (-19);
}
}
#line 4234 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_wait_for_board_state(struct pci_dev *pdev , void *vaddr , int wait_for_ready ) 
{ int i ;
  int iterations ;
  u32 scratchpad ;

  {
#line 4242
  if (wait_for_ready != 0) {
#line 4243
    iterations = 1200;
  } else {
#line 4245
    iterations = 1000;
  }
#line 4247
  i = 0;
#line 4247
  goto ldv_37820;
  ldv_37819: 
#line 4248
  scratchpad = readl((void const volatile   *)vaddr + 176U);
#line 4249
  if (wait_for_ready != 0) {
#line 4250
    if (scratchpad == 4294901760U) {
#line 4251
      return (0);
    } else
#line 4253
    if (scratchpad != 4294901760U) {
#line 4254
      return (0);
    } else {

    }
  } else {

  }
#line 4256
  msleep(100U);
#line 4247
  i = i + 1;
  ldv_37820: ;
#line 4247
  if (i < iterations) {
#line 4248
    goto ldv_37819;
  } else {
#line 4250
    goto ldv_37821;
  }
  ldv_37821: 
#line 4258
  dev_warn((struct device  const  *)(& pdev->dev), "board not ready, timed out.\n");
#line 4259
  return (-19);
}
}
#line 4262 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_find_cfg_addrs(struct pci_dev *pdev , void *vaddr , u32 *cfg_base_addr ,
                                u64 *cfg_base_addr_index , u64 *cfg_offset ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
#line 4266
  *cfg_base_addr = readl((void const volatile   *)vaddr + 180U);
#line 4267
  tmp = readl((void const volatile   *)vaddr + 184U);
#line 4267
  *cfg_offset = (u64 )tmp;
#line 4268
  *cfg_base_addr = *cfg_base_addr & 65535U;
#line 4269
  tmp___0 = find_PCI_BAR_index(pdev, (unsigned long )*cfg_base_addr);
#line 4269
  *cfg_base_addr_index = (u64 )tmp___0;
#line 4270
  if (*cfg_base_addr_index == 0xffffffffffffffffULL) {
#line 4271
    dev_warn((struct device  const  *)(& pdev->dev), "cannot find cfg_base_addr_index, *cfg_base_addr = 0x%08x\n",
             *cfg_base_addr);
#line 4273
    return (-19);
  } else {

  }
#line 4275
  return (0);
}
}
#line 4278 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_find_cfgtables(ctlr_info_t *h ) 
{ u64 cfg_offset ;
  u32 cfg_base_addr ;
  u64 cfg_base_addr_index ;
  u32 trans_offset ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 4286
  rc = cciss_find_cfg_addrs(h->pdev, h->vaddr, & cfg_base_addr, & cfg_base_addr_index,
                            & cfg_offset);
#line 4288
  if (rc != 0) {
#line 4289
    return (rc);
  } else {

  }
#line 4290
  tmp = remap_pci_mem((ulong )((h->pdev)->resource[cfg_base_addr_index].start + cfg_offset),
                      8UL);
#line 4290
  h->cfgtable = (CfgTable_struct *)tmp;
#line 4292
  if ((unsigned long )h->cfgtable == (unsigned long )((CfgTable_struct *)0)) {
#line 4293
    return (-12);
  } else {

  }
#line 4294
  rc = write_driver_ver_to_cfgtable(h->cfgtable);
#line 4295
  if (rc != 0) {
#line 4296
    return (rc);
  } else {

  }
#line 4298
  trans_offset = readl((void const volatile   *)(& (h->cfgtable)->TransMethodOffset));
#line 4299
  tmp___0 = remap_pci_mem((ulong )(((h->pdev)->resource[cfg_base_addr_index].start + cfg_offset) + (unsigned long long )trans_offset),
                          56UL);
#line 4299
  h->transtable = (struct TransTable_struct *)tmp___0;
#line 4302
  if ((unsigned long )h->transtable == (unsigned long )((struct TransTable_struct *)0)) {
#line 4303
    return (-12);
  } else {

  }
#line 4304
  return (0);
}
}
#line 4307 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_max_perf_mode_cmds(struct ctlr_info *h ) 
{ unsigned int tmp ;

  {
#line 4309
  tmp = readl((void const volatile   *)(& (h->cfgtable)->MaxPerformantModeCommands));
#line 4309
  h->max_commands = (int )tmp;
#line 4312
  if (reset_devices != 0U && h->max_commands > 32) {
#line 4313
    h->max_commands = 32;
  } else {

  }
#line 4315
  if (h->max_commands <= 15) {
#line 4316
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Controller reports max supported commands of %d, an obvious lie. Using 16.  Ensure that firmware is up to date.\n",
             h->max_commands);
#line 4320
    h->max_commands = 16;
  } else {

  }
#line 4322
  return;
}
}
#line 4328 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_find_board_params(ctlr_info_t *h ) 
{ unsigned int tmp ;

  {
#line 4330
  cciss_get_max_perf_mode_cmds(h);
#line 4331
  h->nr_cmds = (h->max_commands + -4) - cciss_tape_cmds;
#line 4332
  tmp = readl((void const volatile   *)(& (h->cfgtable)->MaxSGElements));
#line 4332
  h->maxsgentries = (int )tmp;
#line 4337
  h->max_cmd_sgentries = 31;
#line 4338
  if (h->maxsgentries > 512) {
#line 4339
    h->max_cmd_sgentries = 32;
#line 4340
    h->chainsize = (h->maxsgentries - h->max_cmd_sgentries) + 1;
#line 4341
    h->maxsgentries = h->maxsgentries - 1;
  } else {
#line 4343
    h->maxsgentries = 31;
#line 4344
    h->chainsize = 0;
  }
#line 4346
  return;
}
}
#line 4348 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static bool CISS_signature_present(ctlr_info_t *h ) 
{ int tmp ;

  {
#line 4350
  tmp = check_signature((void const volatile   *)(& (h->cfgtable)->Signature), (unsigned char const   *)"CISS",
                        4);
#line 4350
  if (tmp == 0) {
#line 4351
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "not a valid CISS config table\n");
#line 4352
    return (0);
  } else {

  }
#line 4354
  return (1);
}
}
#line 4358 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_enable_scsi_prefetch(ctlr_info_t *h ) 
{ u32 prefetch___0 ;

  {
#line 4363
  prefetch___0 = readl((void const volatile   *)(& (h->cfgtable)->SCSI_Prefetch));
#line 4364
  prefetch___0 = prefetch___0 | 256U;
#line 4365
  writel(prefetch___0, (void volatile   *)(& (h->cfgtable)->SCSI_Prefetch));
#line 4366
  return;
}
}
#line 4372 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_p600_dma_prefetch_quirk(ctlr_info_t *h ) 
{ u32 dma_prefetch ;
  __u32 dma_refetch ;

  {
#line 4377
  if (h->board_id != 841289788U) {
#line 4378
    return;
  } else {

  }
#line 4379
  dma_prefetch = readl((void const volatile   *)h->vaddr + 532U);
#line 4380
  dma_prefetch = dma_prefetch | 32768U;
#line 4381
  writel(dma_prefetch, (void volatile   *)h->vaddr + 532U);
#line 4382
  pci_read_config_dword((struct pci_dev  const  *)h->pdev, 64, & dma_refetch);
#line 4383
  dma_refetch = dma_refetch | 1U;
#line 4384
  pci_write_config_dword((struct pci_dev  const  *)h->pdev, 64, dma_refetch);
#line 4385
  return;
}
}
#line 4387 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_pci_init(ctlr_info_t *h ) 
{ int prod_index ;
  int err ;
  bool tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 4391
  prod_index = cciss_lookup_board_id(h->pdev, & h->board_id);
#line 4392
  if (prod_index < 0) {
#line 4393
    return (-19);
  } else {

  }
#line 4394
  h->product_name = products[prod_index].product_name;
#line 4395
  h->access = *(products[prod_index].access);
#line 4397
  tmp = cciss_board_disabled(h);
#line 4397
  if ((int )tmp) {
#line 4398
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "controller appears to be disabled\n");
#line 4399
    return (-19);
  } else {

  }
#line 4402
  pci_disable_link_state(h->pdev, 7);
#line 4405
  err = pci_enable_device(h->pdev);
#line 4406
  if (err != 0) {
#line 4407
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Unable to Enable PCI device\n");
#line 4408
    return (err);
  } else {

  }
#line 4411
  err = pci_request_regions(h->pdev, "cciss");
#line 4412
  if (err != 0) {
#line 4413
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Cannot obtain PCI resources, aborting\n");
#line 4415
    return (err);
  } else {

  }
#line 4418
  descriptor.modname = "cciss";
#line 4418
  descriptor.function = "cciss_pci_init";
#line 4418
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4418
  descriptor.format = "irq = %x\n";
#line 4418
  descriptor.lineno = 4418U;
#line 4418
  descriptor.flags = 0U;
#line 4418
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4418
  if (tmp___0 != 0L) {
#line 4418
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "irq = %x\n",
                      (h->pdev)->irq);
  } else {

  }
#line 4419
  descriptor___0.modname = "cciss";
#line 4419
  descriptor___0.function = "cciss_pci_init";
#line 4419
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4419
  descriptor___0.format = "board_id = %x\n";
#line 4419
  descriptor___0.lineno = 4419U;
#line 4419
  descriptor___0.flags = 0U;
#line 4419
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4419
  if (tmp___1 != 0L) {
#line 4419
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "board_id = %x\n", h->board_id);
  } else {

  }
#line 4424
  cciss_interrupt_mode(h);
#line 4425
  err = cciss_pci_find_memory_BAR(h->pdev, & h->paddr);
#line 4426
  if (err != 0) {
#line 4427
    goto err_out_free_res;
  } else {

  }
#line 4428
  h->vaddr = remap_pci_mem(h->paddr, 592UL);
#line 4429
  if ((unsigned long )h->vaddr == (unsigned long )((void *)0)) {
#line 4430
    err = -12;
#line 4431
    goto err_out_free_res;
  } else {

  }
#line 4433
  err = cciss_wait_for_board_state(h->pdev, h->vaddr, 1);
#line 4434
  if (err != 0) {
#line 4435
    goto err_out_free_res;
  } else {

  }
#line 4436
  err = cciss_find_cfgtables(h);
#line 4437
  if (err != 0) {
#line 4438
    goto err_out_free_res;
  } else {

  }
#line 4439
  print_cfg_table(h);
#line 4440
  cciss_find_board_params(h);
#line 4442
  tmp___2 = CISS_signature_present(h);
#line 4442
  if (tmp___2) {
#line 4442
    tmp___3 = 0;
  } else {
#line 4442
    tmp___3 = 1;
  }
#line 4442
  if (tmp___3) {
#line 4443
    err = -19;
#line 4444
    goto err_out_free_res;
  } else {

  }
#line 4446
  cciss_enable_scsi_prefetch(h);
#line 4447
  cciss_p600_dma_prefetch_quirk(h);
#line 4448
  err = cciss_enter_simple_mode(h);
#line 4449
  if (err != 0) {
#line 4450
    goto err_out_free_res;
  } else {

  }
#line 4451
  cciss_put_controller_into_performant_mode(h);
#line 4452
  return (0);
  err_out_free_res: ;
#line 4459
  if ((unsigned long )h->transtable != (unsigned long )((struct TransTable_struct *)0)) {
#line 4460
    iounmap((void volatile   *)h->transtable);
  } else {

  }
#line 4461
  if ((unsigned long )h->cfgtable != (unsigned long )((CfgTable_struct *)0)) {
#line 4462
    iounmap((void volatile   *)h->cfgtable);
  } else {

  }
#line 4463
  if ((unsigned long )h->vaddr != (unsigned long )((void *)0)) {
#line 4464
    iounmap((void volatile   *)h->vaddr);
  } else {

  }
#line 4465
  pci_release_regions(h->pdev);
#line 4466
  return (err);
}
}
#line 4472 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int alloc_cciss_hba(struct pci_dev *pdev ) 
{ int i ;
  ctlr_info_t *h ;
  void *tmp ;

  {
#line 4476
  i = 0;
#line 4476
  goto ldv_37871;
  ldv_37870: ;
#line 4477
  if ((unsigned long )hba[i] == (unsigned long )((ctlr_info_t *)0)) {
#line 4480
    tmp = kzalloc(18304UL, 208U);
#line 4480
    h = (ctlr_info_t *)tmp;
#line 4481
    if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 4482
      goto Enomem;
    } else {

    }
#line 4483
    hba[i] = h;
#line 4484
    return (i);
  } else {

  }
#line 4476
  i = i + 1;
  ldv_37871: ;
#line 4476
  if (i <= 31) {
#line 4477
    goto ldv_37870;
  } else {
#line 4479
    goto ldv_37872;
  }
  ldv_37872: 
#line 4487
  dev_warn((struct device  const  *)(& pdev->dev), "This driver supports a maximum of %d controllers.\n",
           32);
#line 4489
  return (-1);
  Enomem: 
#line 4491
  dev_warn((struct device  const  *)(& pdev->dev), "out of memory.\n");
#line 4492
  return (-1);
}
}
#line 4495 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void free_hba(ctlr_info_t *h ) 
{ int i ;

  {
#line 4499
  hba[h->ctlr] = 0;
#line 4500
  i = 0;
#line 4500
  goto ldv_37878;
  ldv_37877: ;
#line 4501
  if ((unsigned long )h->gendisk[i] != (unsigned long )((struct gendisk *)0)) {
#line 4502
    put_disk(h->gendisk[i]);
  } else {

  }
#line 4500
  i = i + 1;
  ldv_37878: ;
#line 4500
  if (h->highest_lun + 1 > i) {
#line 4501
    goto ldv_37877;
  } else {
#line 4503
    goto ldv_37879;
  }
  ldv_37879: 
#line 4503
  kfree((void const   *)h);
#line 4504
  return;
}
}
#line 4507 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_message(struct pci_dev *pdev , unsigned char opcode , unsigned char type ) 
{ size_t cmd_sz ;
  Command *cmd ;
  dma_addr_t paddr64 ;
  uint32_t paddr32 ;
  uint32_t tag ;
  void *vaddr ;
  int i ;
  int err ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 4514
  cmd_sz = 100UL;
#line 4521
  if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) {
#line 4521
    tmp = (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL);
  } else {
#line 4521
    tmp = 0UL;
  }
#line 4521
  vaddr = ioremap_nocache(pdev->resource[0].start, tmp);
#line 4522
  if ((unsigned long )vaddr == (unsigned long )((void *)0)) {
#line 4523
    return (-12);
  } else {

  }
#line 4528
  err = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
#line 4529
  if (err != 0) {
#line 4530
    iounmap((void volatile   *)vaddr);
#line 4531
    return (-12);
  } else {

  }
#line 4534
  tmp___0 = pci_alloc_consistent(pdev, cmd_sz, & paddr64);
#line 4534
  cmd = (Command *)tmp___0;
#line 4535
  if ((unsigned long )cmd == (unsigned long )((Command *)0)) {
#line 4536
    iounmap((void volatile   *)vaddr);
#line 4537
    return (-12);
  } else {

  }
#line 4543
  paddr32 = (uint32_t )paddr64;
#line 4545
  cmd->CommandHeader.ReplyQueue = 0U;
#line 4546
  cmd->CommandHeader.SGList = 0U;
#line 4547
  cmd->CommandHeader.SGTotal = 0U;
#line 4548
  cmd->CommandHeader.Tag.lower = paddr32;
#line 4549
  cmd->CommandHeader.Tag.upper = 0U;
#line 4550
  memset((void *)(& cmd->CommandHeader.LUN.LunAddrBytes), 0, 8UL);
#line 4552
  cmd->Request.CDBLen = 16U;
#line 4553
  cmd->Request.Type.Type = 1U;
#line 4554
  cmd->Request.Type.Attribute = 5U;
#line 4555
  cmd->Request.Type.Direction = 0U;
#line 4556
  cmd->Request.Timeout = 0U;
#line 4557
  cmd->Request.CDB[0] = opcode;
#line 4558
  cmd->Request.CDB[1] = type;
#line 4559
  memset((void *)(& cmd->Request.CDB) + 2U, 0, 14UL);
#line 4561
  cmd->ErrorDescriptor.Addr.lower = paddr32 + 52U;
#line 4562
  cmd->ErrorDescriptor.Addr.upper = 0U;
#line 4563
  cmd->ErrorDescriptor.Len = 48U;
#line 4565
  writel(paddr32, (void volatile   *)vaddr + 64U);
#line 4567
  i = 0;
#line 4567
  goto ldv_37900;
  ldv_37899: 
#line 4568
  tag = readl((void const volatile   *)vaddr + 68U);
#line 4569
  if ((tag & 4294967292U) == paddr32) {
#line 4570
    goto ldv_37898;
  } else {

  }
#line 4571
  msleep(10000U);
#line 4567
  i = i + 1;
  ldv_37900: ;
#line 4567
  if (i <= 9) {
#line 4568
    goto ldv_37899;
  } else {
#line 4570
    goto ldv_37898;
  }
  ldv_37898: 
#line 4574
  iounmap((void volatile   *)vaddr);
#line 4578
  if (i == 10) {
#line 4579
    dev_err((struct device  const  *)(& pdev->dev), "controller message %02x:%02x timed out\n",
            (int )opcode, (int )type);
#line 4582
    return (-110);
  } else {

  }
#line 4585
  pci_free_consistent(pdev, cmd_sz, (void *)cmd, paddr64);
#line 4587
  if ((tag & 2U) != 0U) {
#line 4588
    dev_err((struct device  const  *)(& pdev->dev), "controller message %02x:%02x failed\n",
            (int )opcode, (int )type);
#line 4590
    return (-5);
  } else {

  }
#line 4593
  _dev_info((struct device  const  *)(& pdev->dev), "controller message %02x:%02x succeeded\n",
            (int )opcode, (int )type);
#line 4595
  return (0);
}
}
#line 4600 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_controller_hard_reset(struct pci_dev *pdev , void *vaddr , u32 use_doorbell ) 
{ u16 pmcsr ;
  int pos ;

  {
#line 4606
  if (use_doorbell != 0U) {
#line 4611
    _dev_info((struct device  const  *)(& pdev->dev), "using doorbell to reset controller\n");
#line 4612
    writel(use_doorbell, (void volatile   *)vaddr + 32U);
  } else {
#line 4623
    pos = pci_find_capability(pdev, 1);
#line 4624
    if (pos == 0) {
#line 4625
      dev_err((struct device  const  *)(& pdev->dev), "cciss_controller_hard_reset: PCI PM not supported\n");
#line 4628
      return (-19);
    } else {

    }
#line 4630
    _dev_info((struct device  const  *)(& pdev->dev), "using PCI PM to reset controller\n");
#line 4632
    pci_read_config_word((struct pci_dev  const  *)pdev, pos + 4, & pmcsr);
#line 4633
    pmcsr = (unsigned int )pmcsr & 65532U;
#line 4634
    pmcsr = (u16 )((unsigned int )pmcsr | 3U);
#line 4635
    pci_write_config_word((struct pci_dev  const  *)pdev, pos + 4, (int )pmcsr);
#line 4637
    msleep(500U);
#line 4640
    pmcsr = (unsigned int )pmcsr & 65532U;
#line 4641
    pmcsr = pmcsr;
#line 4642
    pci_write_config_word((struct pci_dev  const  *)pdev, pos + 4, (int )pmcsr);
#line 4649
    msleep(500U);
  }
#line 4651
  return (0);
}
}
#line 4654 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void init_driver_version(char *driver_version , int len ) 
{ 

  {
#line 4656
  memset((void *)driver_version, 0, (size_t )len);
#line 4657
  strncpy(driver_version, "cciss HP CISS Driver (v 3.6.26)", (__kernel_size_t )(len + -1));
#line 4658
  return;
}
}
#line 4660 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int write_driver_ver_to_cfgtable(CfgTable_struct *cfgtable ) 
{ char *driver_version ;
  int i ;
  int size ;
  void *tmp ;

  {
#line 4664
  size = 32;
#line 4666
  tmp = kmalloc((size_t )size, 208U);
#line 4666
  driver_version = (char *)tmp;
#line 4667
  if ((unsigned long )driver_version == (unsigned long )((char *)0)) {
#line 4668
    return (-12);
  } else {

  }
#line 4670
  init_driver_version(driver_version, size);
#line 4671
  i = 0;
#line 4671
  goto ldv_37919;
  ldv_37918: 
#line 4672
  writeb((int )((unsigned char )*(driver_version + (unsigned long )i)), (void volatile   *)(& cfgtable->driver_version) + (unsigned long )i);
#line 4671
  i = i + 1;
  ldv_37919: ;
#line 4671
  if (i < size) {
#line 4672
    goto ldv_37918;
  } else {
#line 4674
    goto ldv_37920;
  }
  ldv_37920: 
#line 4673
  kfree((void const   *)driver_version);
#line 4674
  return (0);
}
}
#line 4677 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void read_driver_ver_from_cfgtable(CfgTable_struct *cfgtable , unsigned char *driver_ver ) 
{ int i ;

  {
#line 4682
  i = 0;
#line 4682
  goto ldv_37927;
  ldv_37926: 
#line 4683
  *(driver_ver + (unsigned long )i) = readb((void const volatile   *)(& cfgtable->driver_version) + (unsigned long )i);
#line 4682
  i = i + 1;
  ldv_37927: ;
#line 4682
  if ((unsigned int )i <= 31U) {
#line 4683
    goto ldv_37926;
  } else {
#line 4685
    goto ldv_37928;
  }
  ldv_37928: ;
#line 4687
  return;
}
}
#line 4686 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int controller_reset_failed(CfgTable_struct *cfgtable ) 
{ char *driver_ver ;
  char *old_driver_ver ;
  int rc ;
  int size ;
  void *tmp ;
  int tmp___0 ;

  {
#line 4691
  size = 32;
#line 4693
  tmp = kmalloc((size_t )(size * 2), 208U);
#line 4693
  old_driver_ver = (char *)tmp;
#line 4694
  if ((unsigned long )old_driver_ver == (unsigned long )((char *)0)) {
#line 4695
    return (-12);
  } else {

  }
#line 4696
  driver_ver = old_driver_ver + (unsigned long )size;
#line 4701
  init_driver_version(old_driver_ver, size);
#line 4702
  read_driver_ver_from_cfgtable(cfgtable, (unsigned char *)driver_ver);
#line 4703
  tmp___0 = memcmp((void const   *)driver_ver, (void const   *)old_driver_ver, (size_t )size);
#line 4703
  rc = tmp___0 == 0;
#line 4704
  kfree((void const   *)old_driver_ver);
#line 4705
  return (rc);
}
}
#line 4710 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_kdump_hard_reset_controller(struct pci_dev *pdev ) 
{ u64 cfg_offset ;
  u32 cfg_base_addr ;
  u64 cfg_base_addr_index ;
  void *vaddr ;
  unsigned long paddr ;
  u32 misc_fw_support ;
  int rc ;
  CfgTable_struct *cfgtable ;
  u32 use_doorbell ;
  u32 board_id ;
  u16 command_register ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 4743
  cciss_lookup_board_id(pdev, & board_id);
#line 4744
  tmp = ctlr_is_resettable(board_id);
#line 4744
  if (tmp == 0) {
#line 4745
    dev_warn((struct device  const  *)(& pdev->dev), "Cannot reset Smart Array 640x due to shared cache module.");
#line 4747
    return (-19);
  } else {

  }
#line 4751
  tmp___0 = ctlr_is_hard_resettable(board_id);
#line 4751
  if (tmp___0 == 0) {
#line 4752
    return (-524);
  } else {

  }
#line 4755
  pci_read_config_word((struct pci_dev  const  *)pdev, 4, & command_register);
#line 4759
  pci_disable_device(pdev);
#line 4760
  pci_save_state(pdev);
#line 4763
  rc = cciss_pci_find_memory_BAR(pdev, & paddr);
#line 4764
  if (rc != 0) {
#line 4765
    return (rc);
  } else {

  }
#line 4766
  vaddr = remap_pci_mem(paddr, 592UL);
#line 4767
  if ((unsigned long )vaddr == (unsigned long )((void *)0)) {
#line 4768
    return (-12);
  } else {

  }
#line 4771
  rc = cciss_find_cfg_addrs(pdev, vaddr, & cfg_base_addr, & cfg_base_addr_index, & cfg_offset);
#line 4773
  if (rc != 0) {
#line 4774
    goto unmap_vaddr;
  } else {

  }
#line 4775
  tmp___1 = remap_pci_mem((ulong )(pdev->resource[cfg_base_addr_index].start + cfg_offset),
                          156UL);
#line 4775
  cfgtable = (CfgTable_struct *)tmp___1;
#line 4777
  if ((unsigned long )cfgtable == (unsigned long )((CfgTable_struct *)0)) {
#line 4778
    rc = -12;
#line 4779
    goto unmap_vaddr;
  } else {

  }
#line 4781
  rc = write_driver_ver_to_cfgtable(cfgtable);
#line 4782
  if (rc != 0) {
#line 4783
    goto unmap_vaddr;
  } else {

  }
#line 4788
  misc_fw_support = readl((void const volatile   *)(& cfgtable->misc_fw_support));
#line 4789
  use_doorbell = misc_fw_support & 16U;
#line 4790
  if (use_doorbell != 0U) {
#line 4791
    use_doorbell = 32U;
  } else {
#line 4793
    use_doorbell = misc_fw_support & 2U;
#line 4794
    if (use_doorbell != 0U) {
#line 4795
      dev_warn((struct device  const  *)(& pdev->dev), "Controller claims that \'Bit 2 doorbell reset\' is supported, but not \'bit 5 doorbell reset\'.  Firmware update is recommended.\n");
#line 4799
      rc = -524;
#line 4800
      goto unmap_cfgtable;
    } else {

    }
  }
#line 4804
  rc = cciss_controller_hard_reset(pdev, vaddr, use_doorbell);
#line 4805
  if (rc != 0) {
#line 4806
    goto unmap_cfgtable;
  } else {

  }
#line 4807
  pci_restore_state(pdev);
#line 4808
  rc = pci_enable_device(pdev);
#line 4809
  if (rc != 0) {
#line 4810
    dev_warn((struct device  const  *)(& pdev->dev), "failed to enable device.\n");
#line 4811
    goto unmap_cfgtable;
  } else {

  }
#line 4813
  pci_write_config_word((struct pci_dev  const  *)pdev, 4, (int )command_register);
#line 4817
  msleep(3000U);
#line 4820
  _dev_info((struct device  const  *)(& pdev->dev), "Waiting for board to reset.\n");
#line 4821
  rc = cciss_wait_for_board_state(pdev, vaddr, 0);
#line 4822
  if (rc != 0) {
#line 4823
    dev_warn((struct device  const  *)(& pdev->dev), "Failed waiting for board to hard reset.  Will try soft reset.\n");
#line 4825
    rc = -524;
#line 4826
    goto unmap_cfgtable;
  } else {

  }
#line 4828
  rc = cciss_wait_for_board_state(pdev, vaddr, 1);
#line 4829
  if (rc != 0) {
#line 4830
    dev_warn((struct device  const  *)(& pdev->dev), "failed waiting for board to become ready after hard reset\n");
#line 4833
    goto unmap_cfgtable;
  } else {

  }
#line 4836
  rc = controller_reset_failed((CfgTable_struct *)vaddr);
#line 4837
  if (rc < 0) {
#line 4838
    goto unmap_cfgtable;
  } else {

  }
#line 4839
  if (rc != 0) {
#line 4840
    dev_warn((struct device  const  *)(& pdev->dev), "Unable to successfully hard reset controller. Will try soft reset.\n");
#line 4842
    rc = -524;
  } else {
#line 4844
    _dev_info((struct device  const  *)(& pdev->dev), "Board ready after hard reset.\n");
  }
  unmap_cfgtable: 
#line 4848
  iounmap((void volatile   *)cfgtable);
  unmap_vaddr: 
#line 4851
  iounmap((void volatile   *)vaddr);
#line 4852
  return (rc);
}
}
#line 4855 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init_reset_devices(struct pci_dev *pdev ) 
{ int rc ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 4859
  if (reset_devices == 0U) {
#line 4860
    return (0);
  } else {

  }
#line 4863
  rc = cciss_kdump_hard_reset_controller(pdev);
#line 4870
  if (rc == -524) {
#line 4871
    return (rc);
  } else {

  }
#line 4872
  if (rc != 0) {
#line 4873
    return (-19);
  } else {

  }
#line 4876
  dev_warn((struct device  const  *)(& pdev->dev), "Waiting for controller to respond to no-op\n");
#line 4877
  i = 0;
#line 4877
  goto ldv_37959;
  ldv_37958: 
#line 4878
  tmp___0 = cciss_message(pdev, 3, 0);
#line 4878
  if (tmp___0 == 0) {
#line 4879
    goto ldv_37957;
  } else {
#line 4881
    if (i <= 10) {
#line 4881
      tmp = (char *)"; re-trying";
    } else {
#line 4881
      tmp = (char *)"";
    }
#line 4881
    dev_warn((struct device  const  *)(& pdev->dev), "no-op failed%s\n", tmp);
  }
#line 4884
  msleep(4000U);
#line 4877
  i = i + 1;
  ldv_37959: ;
#line 4877
  if (i <= 11) {
#line 4878
    goto ldv_37958;
  } else {
#line 4880
    goto ldv_37957;
  }
  ldv_37957: ;
#line 4886
  return (0);
}
}
#line 4889 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_allocate_cmd_pool(ctlr_info_t *h ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4891
  tmp = kmalloc((((unsigned long )h->nr_cmds + 63UL) / 64UL) * 8UL, 208U);
#line 4891
  h->cmd_pool_bits = (unsigned long *)tmp;
#line 4893
  tmp___0 = pci_alloc_consistent(h->pdev, (unsigned long )h->nr_cmds * 640UL, & h->cmd_pool_dhandle);
#line 4893
  h->cmd_pool = (CommandList_struct *)tmp___0;
#line 4896
  tmp___1 = pci_alloc_consistent(h->pdev, (unsigned long )h->nr_cmds * 48UL, & h->errinfo_pool_dhandle);
#line 4896
  h->errinfo_pool = (ErrorInfo_struct *)tmp___1;
#line 4899
  if (((unsigned long )h->cmd_pool_bits == (unsigned long )((unsigned long *)0) || (unsigned long )h->cmd_pool == (unsigned long )((CommandList_struct *)0)) || (unsigned long )h->errinfo_pool == (unsigned long )((ErrorInfo_struct *)0)) {
#line 4902
    dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory");
#line 4903
    return (-12);
  } else {

  }
#line 4905
  return (0);
}
}
#line 4908 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_allocate_scatterlists(ctlr_info_t *h ) 
{ int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 4913
  tmp = kzalloc((unsigned long )h->max_commands * 8UL, 208U);
#line 4913
  h->scatter_list = (struct scatterlist **)tmp;
#line 4915
  if ((unsigned long )h->scatter_list == (unsigned long )((struct scatterlist **)0)) {
#line 4916
    return (-12);
  } else {

  }
#line 4918
  i = 0;
#line 4918
  goto ldv_37968;
  ldv_37967: 
#line 4919
  tmp___0 = kmalloc((unsigned long )h->maxsgentries * 40UL, 208U);
#line 4919
  *(h->scatter_list + (unsigned long )i) = (struct scatterlist *)tmp___0;
#line 4921
  if ((unsigned long )*(h->scatter_list + (unsigned long )i) == (unsigned long )((struct scatterlist *)0)) {
#line 4922
    dev_err((struct device  const  *)(& (h->pdev)->dev), "could not allocate s/g lists\n");
#line 4924
    return (-12);
  } else {

  }
#line 4918
  i = i + 1;
  ldv_37968: ;
#line 4918
  if (h->nr_cmds > i) {
#line 4919
    goto ldv_37967;
  } else {
#line 4921
    goto ldv_37969;
  }
  ldv_37969: ;
#line 4927
  return (0);
}
}
#line 4930 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_scatterlists(ctlr_info_t *h ) 
{ int i ;

  {
#line 4934
  if ((unsigned long )h->scatter_list != (unsigned long )((struct scatterlist **)0)) {
#line 4935
    i = 0;
#line 4935
    goto ldv_37975;
    ldv_37974: 
#line 4936
    kfree((void const   *)*(h->scatter_list + (unsigned long )i));
#line 4935
    i = i + 1;
    ldv_37975: ;
#line 4935
    if (h->nr_cmds > i) {
#line 4936
      goto ldv_37974;
    } else {
#line 4938
      goto ldv_37976;
    }
    ldv_37976: 
#line 4937
    kfree((void const   *)h->scatter_list);
  } else {

  }
#line 4939
  return;
}
}
#line 4941 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_cmd_pool(ctlr_info_t *h ) 
{ 

  {
#line 4943
  kfree((void const   *)h->cmd_pool_bits);
#line 4944
  if ((unsigned long )h->cmd_pool != (unsigned long )((CommandList_struct *)0)) {
#line 4945
    pci_free_consistent(h->pdev, (unsigned long )h->nr_cmds * 640UL, (void *)h->cmd_pool,
                        h->cmd_pool_dhandle);
  } else {

  }
#line 4948
  if ((unsigned long )h->errinfo_pool != (unsigned long )((ErrorInfo_struct *)0)) {
#line 4949
    pci_free_consistent(h->pdev, (unsigned long )h->nr_cmds * 48UL, (void *)h->errinfo_pool,
                        h->errinfo_pool_dhandle);
  } else {

  }
#line 4952
  return;
}
}
#line 4954 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_request_irq(ctlr_info_t *h , irqreturn_t (*msixhandler)(int  , void * ) ,
                             irqreturn_t (*intxhandler)(int  , void * ) ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 4958
  if (h->msix_vector != 0U || h->msi_vector != 0U) {
#line 4959
    tmp = request_irq(h->intr[h->intr_mode], msixhandler, 0UL, (char const   *)(& h->devname),
                      (void *)h);
#line 4959
    if (tmp == 0) {
#line 4961
      return (0);
    } else {

    }
#line 4962
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get msi irq %d for %s\n",
            h->intr[h->intr_mode], (char *)(& h->devname));
#line 4965
    return (-1);
  } else {

  }
#line 4968
  tmp___0 = request_irq(h->intr[h->intr_mode], intxhandler, 128UL, (char const   *)(& h->devname),
                        (void *)h);
#line 4968
  if (tmp___0 == 0) {
#line 4970
    return (0);
  } else {

  }
#line 4971
  dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get irq %d for %s\n",
          h->intr[h->intr_mode], (char *)(& h->devname));
#line 4973
  return (-1);
}
}
#line 4976 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_kdump_soft_reset(ctlr_info_t *h ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4978
  tmp = cciss_send_reset(h, (unsigned char *)"", 0);
#line 4978
  if (tmp != 0) {
#line 4979
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Resetting array controller failed.\n");
#line 4980
    return (-5);
  } else {

  }
#line 4983
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Waiting for board to soft reset.\n");
#line 4984
  tmp___0 = cciss_wait_for_board_state(h->pdev, h->vaddr, 0);
#line 4984
  if (tmp___0 != 0) {
#line 4985
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Soft reset had no effect.\n");
#line 4986
    return (-1);
  } else {

  }
#line 4989
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Board reset, awaiting READY status.\n");
#line 4990
  tmp___1 = cciss_wait_for_board_state(h->pdev, h->vaddr, 1);
#line 4990
  if (tmp___1 != 0) {
#line 4991
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Board failed to become ready after soft reset.\n");
#line 4993
    return (-1);
  } else {

  }
#line 4996
  return (0);
}
}
#line 4999 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_undo_allocations_after_kdump_soft_reset(ctlr_info_t *h ) 
{ int ctlr ;

  {
#line 5001
  ctlr = h->ctlr;
#line 5003
  free_irq(h->intr[h->intr_mode], (void *)h);
#line 5005
  if (h->msix_vector != 0U) {
#line 5006
    pci_disable_msix(h->pdev);
  } else
#line 5007
  if (h->msi_vector != 0U) {
#line 5008
    pci_disable_msi(h->pdev);
  } else {

  }
#line 5010
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 5011
  cciss_free_scatterlists(h);
#line 5012
  cciss_free_cmd_pool(h);
#line 5013
  kfree((void const   *)h->blockFetchTable);
#line 5014
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 5015
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 5017
  if ((unsigned long )h->transtable != (unsigned long )((struct TransTable_struct *)0)) {
#line 5018
    iounmap((void volatile   *)h->transtable);
  } else {

  }
#line 5019
  if ((unsigned long )h->cfgtable != (unsigned long )((CfgTable_struct *)0)) {
#line 5020
    iounmap((void volatile   *)h->cfgtable);
  } else {

  }
#line 5021
  if ((unsigned long )h->vaddr != (unsigned long )((void *)0)) {
#line 5022
    iounmap((void volatile   *)h->vaddr);
  } else {

  }
#line 5023
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5024
  cciss_destroy_hba_sysfs_entry(h);
#line 5025
  pci_release_regions(h->pdev);
#line 5026
  kfree((void const   *)h);
#line 5027
  hba[ctlr] = 0;
#line 5028
  return;
}
}
#line 5035 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init_one(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ int i ;
  int j ;
  int rc ;
  int try_soft_reset ;
  int dac ;
  int return_code ;
  InquiryData_struct *inq_buff ;
  ctlr_info_t *h ;
  unsigned long flags ;
  struct lock_class_key __key ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct lock_class_key __key___0 ;
  raw_spinlock_t *tmp___7 ;
  void *tmp___8 ;

  {
#line 5039
  j = 0;
#line 5041
  try_soft_reset = 0;
#line 5047
  rc = cciss_init_reset_devices(pdev);
#line 5048
  if (rc != 0) {
#line 5049
    if (rc != -524) {
#line 5050
      return (rc);
    } else {

    }
#line 5056
    try_soft_reset = 1;
#line 5057
    rc = 0;
  } else {

  }
  reinit_after_soft_reset: 
#line 5062
  i = alloc_cciss_hba(pdev);
#line 5063
  if (i < 0) {
#line 5064
    return (-1);
  } else {

  }
#line 5066
  h = hba[i];
#line 5067
  h->pdev = pdev;
#line 5068
  h->busy_initializing = 1;
#line 5069
  if (cciss_simple_mode != 0) {
#line 5069
    h->intr_mode = 2;
  } else {
#line 5069
    h->intr_mode = 0;
  }
#line 5070
  INIT_LIST_HEAD(& h->cmpQ);
#line 5071
  INIT_LIST_HEAD(& h->reqQ);
#line 5072
  __mutex_init(& h->busy_shutting_down, "&h->busy_shutting_down", & __key);
#line 5074
  tmp = cciss_pci_init(h);
#line 5074
  if (tmp != 0) {
#line 5075
    goto clean_no_release_regions;
  } else {

  }
#line 5077
  sprintf((char *)(& h->devname), "cciss%d", i);
#line 5078
  h->ctlr = i;
#line 5080
  if (cciss_tape_cmds <= 1) {
#line 5081
    cciss_tape_cmds = 2;
  } else {

  }
#line 5082
  if (cciss_tape_cmds > 16) {
#line 5083
    cciss_tape_cmds = 16;
  } else {

  }
#line 5085
  init_completion(& h->scan_wait);
#line 5087
  tmp___0 = cciss_create_hba_sysfs_entry(h);
#line 5087
  if (tmp___0 != 0) {
#line 5088
    goto clean0;
  } else {

  }
#line 5091
  tmp___2 = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
#line 5091
  if (tmp___2 == 0) {
#line 5092
    dac = 1;
  } else {
#line 5093
    tmp___1 = pci_set_dma_mask(pdev, 4294967295ULL);
#line 5093
    if (tmp___1 == 0) {
#line 5094
      dac = 0;
    } else {
#line 5096
      dev_err((struct device  const  *)(& (h->pdev)->dev), "no suitable DMA available\n");
#line 5097
      goto clean1;
    }
  }
#line 5105
  if (i <= 7) {
#line 5106
    h->major = i + 104;
  } else {

  }
#line 5107
  rc = register_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5108
  if (rc == -16 || rc == -22) {
#line 5109
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get major number %d for %s on hba %d\n",
            h->major, (char *)(& h->devname), i);
#line 5112
    goto clean1;
  } else
#line 5114
  if (i > 7) {
#line 5115
    h->major = rc;
  } else {

  }
#line 5119
  (*(h->access.set_intr_mask))(h, 0UL);
#line 5120
  rc = cciss_request_irq(h, & do_cciss_msix_intr, & do_cciss_intx);
#line 5121
  if (rc != 0) {
#line 5122
    goto clean2;
  } else {

  }
#line 5124
  if (dac != 0) {
#line 5124
    tmp___3 = (char *)"";
  } else {
#line 5124
    tmp___3 = (char *)" not";
  }
#line 5124
  tmp___4 = pci_name((struct pci_dev  const  *)pdev);
#line 5124
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s: <0x%x> at PCI %s IRQ %d%s using DAC\n",
            (char *)(& h->devname), (int )pdev->device, tmp___4, h->intr[h->intr_mode],
            tmp___3);
#line 5128
  tmp___5 = cciss_allocate_cmd_pool(h);
#line 5128
  if (tmp___5 != 0) {
#line 5129
    goto clean4;
  } else {

  }
#line 5131
  tmp___6 = cciss_allocate_scatterlists(h);
#line 5131
  if (tmp___6 != 0) {
#line 5132
    goto clean4;
  } else {

  }
#line 5134
  h->cmd_sg_list = cciss_allocate_sg_chain_blocks(h, h->chainsize, h->nr_cmds);
#line 5136
  if ((unsigned long )h->cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0) && h->chainsize > 0) {
#line 5137
    goto clean4;
  } else {

  }
#line 5139
  spinlock_check(& h->lock);
#line 5139
  __raw_spin_lock_init(& h->lock.ldv_5961.rlock, "&(&h->lock)->rlock", & __key___0);
#line 5143
  pci_set_drvdata(pdev, (void *)h);
#line 5146
  bitmap_zero(h->cmd_pool_bits, h->nr_cmds);
#line 5148
  h->num_luns = 0;
#line 5149
  h->highest_lun = -1;
#line 5150
  j = 0;
#line 5150
  goto ldv_38018;
  ldv_38017: 
#line 5151
  h->drv[j] = 0;
#line 5152
  h->gendisk[j] = 0;
#line 5150
  j = j + 1;
  ldv_38018: ;
#line 5150
  if (j <= 1023) {
#line 5151
    goto ldv_38017;
  } else {
#line 5153
    goto ldv_38019;
  }
  ldv_38019: ;
#line 5159
  if (try_soft_reset != 0) {
#line 5168
    tmp___7 = spinlock_check(& h->lock);
#line 5168
    flags = _raw_spin_lock_irqsave(tmp___7);
#line 5169
    (*(h->access.set_intr_mask))(h, 0UL);
#line 5170
    spin_unlock_irqrestore(& h->lock, flags);
#line 5171
    free_irq(h->intr[h->intr_mode], (void *)h);
#line 5172
    rc = cciss_request_irq(h, & cciss_msix_discard_completions, & cciss_intx_discard_completions);
#line 5174
    if (rc != 0) {
#line 5175
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "Failed to request_irq after soft reset.\n");
#line 5177
      goto clean4;
    } else {

    }
#line 5180
    rc = cciss_kdump_soft_reset(h);
#line 5181
    if (rc != 0) {
#line 5182
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "Soft reset failed.\n");
#line 5183
      goto clean4;
    } else {

    }
#line 5186
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "Board READY.\n");
#line 5187
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "Waiting for stale completions to drain.\n");
#line 5189
    (*(h->access.set_intr_mask))(h, 1UL);
#line 5190
    msleep(10000U);
#line 5191
    (*(h->access.set_intr_mask))(h, 0UL);
#line 5193
    rc = controller_reset_failed(h->cfgtable);
#line 5194
    if (rc != 0) {
#line 5195
      _dev_info((struct device  const  *)(& (h->pdev)->dev), "Soft reset appears to have failed.\n");
    } else {

    }
#line 5202
    cciss_undo_allocations_after_kdump_soft_reset(h);
#line 5203
    try_soft_reset = 0;
#line 5204
    if (rc != 0) {
#line 5206
      return (-19);
    } else {

    }
#line 5208
    goto reinit_after_soft_reset;
  } else {

  }
#line 5211
  cciss_scsi_setup(h);
#line 5214
  (*(h->access.set_intr_mask))(h, 1UL);
#line 5217
  tmp___8 = kzalloc(36UL, 208U);
#line 5217
  inq_buff = (InquiryData_struct *)tmp___8;
#line 5218
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0)) {
#line 5219
    dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 5220
    goto clean4;
  } else {

  }
#line 5223
  return_code = sendcmd_withirq(h, 18, (void *)inq_buff, 36UL, 0, (unsigned char *)"",
                                0);
#line 5225
  if (return_code == 0) {
#line 5226
    h->firm_ver[0] = (char )inq_buff->data_byte[32];
#line 5227
    h->firm_ver[1] = (char )inq_buff->data_byte[33];
#line 5228
    h->firm_ver[2] = (char )inq_buff->data_byte[34];
#line 5229
    h->firm_ver[3] = (char )inq_buff->data_byte[35];
  } else {
#line 5231
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unable to determine firmware version of controller\n");
  }
#line 5234
  kfree((void const   *)inq_buff);
#line 5236
  cciss_procinit(h);
#line 5238
  h->cciss_max_sectors = 8192;
#line 5240
  rebuild_lun_table(h, 1, 0);
#line 5241
  cciss_engage_scsi(h);
#line 5242
  h->busy_initializing = 0;
#line 5243
  return (1);
  clean4: 
#line 5246
  cciss_free_cmd_pool(h);
#line 5247
  cciss_free_scatterlists(h);
#line 5248
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 5249
  free_irq(h->intr[h->intr_mode], (void *)h);
  clean2: 
#line 5251
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
  clean1: 
#line 5253
  cciss_destroy_hba_sysfs_entry(h);
  clean0: 
#line 5255
  pci_release_regions(pdev);
  clean_no_release_regions: 
#line 5257
  h->busy_initializing = 0;
#line 5263
  pci_set_drvdata(pdev, 0);
#line 5264
  free_hba(h);
#line 5265
  return (-1);
}
}
#line 5268 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_shutdown(struct pci_dev *pdev ) 
{ ctlr_info_t *h ;
  char *flush_buf ;
  int return_code ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 5274
  tmp = pci_get_drvdata(pdev);
#line 5274
  h = (ctlr_info_t *)tmp;
#line 5275
  tmp___0 = kzalloc(4UL, 208U);
#line 5275
  flush_buf = (char *)tmp___0;
#line 5276
  if ((unsigned long )flush_buf == (unsigned long )((char *)0)) {
#line 5277
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cache not flushed, out of memory.\n");
#line 5278
    return;
  } else {

  }
#line 5281
  return_code = sendcmd_withirq(h, 1, (void *)flush_buf, 4UL, 0, (unsigned char *)"",
                                0);
#line 5283
  kfree((void const   *)flush_buf);
#line 5284
  if (return_code != 0) {
#line 5285
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Error flushing cache\n");
  } else {

  }
#line 5286
  (*(h->access.set_intr_mask))(h, 0UL);
#line 5287
  free_irq(h->intr[h->intr_mode], (void *)h);
#line 5288
  return;
}
}
#line 5290 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_enter_simple_mode(struct ctlr_info *h ) 
{ u32 trans_support ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 5294
  trans_support = readl((void const volatile   *)(& (h->cfgtable)->TransportSupport));
#line 5295
  if ((trans_support & 2U) == 0U) {
#line 5296
    return (-524);
  } else {

  }
#line 5298
  tmp = readl((void const volatile   *)(& (h->cfgtable)->CmdsOutMax));
#line 5298
  h->max_commands = (int )tmp;
#line 5299
  writel(2U, (void volatile   *)(& (h->cfgtable)->HostWrite.TransportRequest));
#line 5300
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 5301
  cciss_wait_for_mode_change_ack(h);
#line 5302
  print_cfg_table(h);
#line 5303
  tmp___0 = readl((void const volatile   *)(& (h->cfgtable)->TransportActive));
#line 5303
  if (((long )tmp___0 & 2L) == 0L) {
#line 5304
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unable to get board into simple mode\n");
#line 5305
    return (-19);
  } else {

  }
#line 5307
  h->transMethod = 2UL;
#line 5308
  return (0);
}
}
#line 5312 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_remove_one(struct pci_dev *pdev ) 
{ ctlr_info_t *h ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  struct gendisk *disk ;
  struct request_queue *q ;

  {
#line 5317
  tmp = pci_get_drvdata(pdev);
#line 5317
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 5318
    dev_err((struct device  const  *)(& pdev->dev), "Unable to remove device\n");
#line 5319
    return;
  } else {

  }
#line 5322
  tmp___0 = pci_get_drvdata(pdev);
#line 5322
  h = (ctlr_info_t *)tmp___0;
#line 5323
  i = h->ctlr;
#line 5324
  if ((unsigned long )hba[i] == (unsigned long )((ctlr_info_t *)0)) {
#line 5325
    dev_err((struct device  const  *)(& pdev->dev), "device appears to already be removed\n");
#line 5326
    return;
  } else {

  }
#line 5329
  ldv_mutex_lock_30(& h->busy_shutting_down);
#line 5331
  remove_from_scan_list(h);
#line 5332
  remove_proc_entry((char const   *)(& h->devname), proc_cciss);
#line 5333
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5336
  j = 0;
#line 5336
  goto ldv_38042;
  ldv_38041: 
#line 5337
  disk = h->gendisk[j];
#line 5338
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
#line 5339
    q = disk->queue;
#line 5341
    if ((disk->flags & 16) != 0) {
#line 5342
      cciss_destroy_ld_sysfs_entry(h, j, 1);
#line 5343
      del_gendisk(disk);
    } else {

    }
#line 5345
    if ((unsigned long )q != (unsigned long )((struct request_queue *)0)) {
#line 5346
      blk_cleanup_queue(q);
    } else {

    }
  } else {

  }
#line 5336
  j = j + 1;
  ldv_38042: ;
#line 5336
  if (j <= 1023) {
#line 5337
    goto ldv_38041;
  } else {
#line 5339
    goto ldv_38043;
  }
  ldv_38043: 
#line 5351
  cciss_unregister_scsi(h);
#line 5354
  cciss_shutdown(pdev);
#line 5357
  if (h->msix_vector != 0U) {
#line 5358
    pci_disable_msix(h->pdev);
  } else
#line 5359
  if (h->msi_vector != 0U) {
#line 5360
    pci_disable_msi(h->pdev);
  } else {

  }
#line 5363
  iounmap((void volatile   *)h->transtable);
#line 5364
  iounmap((void volatile   *)h->cfgtable);
#line 5365
  iounmap((void volatile   *)h->vaddr);
#line 5367
  cciss_free_cmd_pool(h);
#line 5369
  j = 0;
#line 5369
  goto ldv_38045;
  ldv_38044: 
#line 5370
  kfree((void const   *)*(h->scatter_list + (unsigned long )j));
#line 5369
  j = j + 1;
  ldv_38045: ;
#line 5369
  if (h->nr_cmds > j) {
#line 5370
    goto ldv_38044;
  } else {
#line 5372
    goto ldv_38046;
  }
  ldv_38046: 
#line 5371
  kfree((void const   *)h->scatter_list);
#line 5372
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 5373
  kfree((void const   *)h->blockFetchTable);
#line 5374
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 5375
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 5381
  pci_release_regions(pdev);
#line 5382
  pci_set_drvdata(pdev, 0);
#line 5383
  cciss_destroy_hba_sysfs_entry(h);
#line 5384
  ldv_mutex_unlock_31(& h->busy_shutting_down);
#line 5385
  free_hba(h);
#line 5386
  return;
}
}
#line 5388 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct pci_driver cciss_pci_driver  = 
#line 5388
     {{0, 0}, "cciss", (struct pci_device_id  const  *)(& cciss_pci_device_id), & cciss_init_one,
    & cciss_remove_one, 0, 0, 0, 0, & cciss_shutdown, 0, 0, {0, 0, 0, 0, (_Bool)0,
                                                             0, 0, 0, 0, 0, 0, 0,
                                                             0, 0, 0}, {{{{{{0U}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}}};
#line 5400 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init(void) 
{ int err ;
  struct lock_class_key __key ;
  int tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 5410
  printk("\016HP CISS Driver (v 3.6.26)\n");
#line 5412
  tmp = __bus_register(& cciss_bus_type, & __key);
#line 5412
  err = tmp;
#line 5413
  if (err != 0) {
#line 5414
    return (err);
  } else {

  }
#line 5417
  tmp___0 = kthread_create_on_node(& scan_thread, 0, -1, "cciss_scan");
#line 5417
  __k = tmp___0;
#line 5417
  tmp___1 = IS_ERR((void const   *)__k);
#line 5417
  if (tmp___1 == 0L) {
#line 5417
    wake_up_process(__k);
  } else {

  }
#line 5417
  cciss_scan_thread = __k;
#line 5418
  tmp___3 = IS_ERR((void const   *)cciss_scan_thread);
#line 5418
  if (tmp___3 != 0L) {
#line 5419
    tmp___2 = PTR_ERR((void const   *)cciss_scan_thread);
#line 5419
    err = (int )tmp___2;
#line 5420
    goto err_bus_unregister;
  } else {

  }
#line 5424
  err = __pci_register_driver(& cciss_pci_driver, & __this_module, "cciss");
#line 5425
  if (err != 0) {
#line 5426
    goto err_thread_stop;
  } else {

  }
#line 5428
  return (err);
  err_thread_stop: 
#line 5431
  kthread_stop(cciss_scan_thread);
  err_bus_unregister: 
#line 5433
  bus_unregister(& cciss_bus_type);
#line 5435
  return (err);
}
}
#line 5438 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_cleanup(void) 
{ int i ;

  {
#line 5442
  pci_unregister_driver(& cciss_pci_driver);
#line 5444
  i = 0;
#line 5444
  goto ldv_38063;
  ldv_38062: ;
#line 5445
  if ((unsigned long )hba[i] != (unsigned long )((ctlr_info_t *)0)) {
#line 5446
    dev_warn((struct device  const  *)(& ((hba[i])->pdev)->dev), "had to remove controller\n");
#line 5448
    cciss_remove_one((hba[i])->pdev);
  } else {

  }
#line 5444
  i = i + 1;
  ldv_38063: ;
#line 5444
  if (i <= 31) {
#line 5445
    goto ldv_38062;
  } else {
#line 5447
    goto ldv_38064;
  }
  ldv_38064: 
#line 5451
  kthread_stop(cciss_scan_thread);
#line 5452
  if ((unsigned long )proc_cciss != (unsigned long )((struct proc_dir_entry *)0)) {
#line 5453
    remove_proc_entry("driver/cciss", 0);
  } else {

  }
#line 5454
  bus_unregister(& cciss_bus_type);
#line 5455
  return;
}
}
#line 5459 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
loff_t ldvarg51  ;
#line 5460 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg32  ;
#line 5461 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned long ldvarg7  ;
#line 5462 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg42  ;
#line 5463 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned int ldvarg12  ;
#line 5464 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_retval_2  ;
#line 5465 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldvarg50  ;
#line 5466 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
CommandList_struct *ldvarg46  ;
#line 5467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg1  ;
#line 5468 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg58  ;
#line 5469 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_retval_0  ;
#line 5470 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
size_t ldvarg53  ;
#line 5471 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_retval_1  ;
#line 5472 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg64  ;
#line 5473 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct gendisk *cciss_fops_group0  ;
#line 5474 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned long ldvarg44  ;
#line 5475 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct block_device *cciss_fops_group1  ;
#line 5476 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg0  ;
#line 5477 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg69  ;
#line 5478 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg5  ;
#line 5479 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg33  ;
#line 5480 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct pci_device_id *ldvarg16  ;
#line 5481 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
fmode_t ldvarg6  ;
#line 5482 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg4  ;
#line 5483 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldvarg28  ;
#line 5484 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg2  ;
#line 5485 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg47  ;
#line 5486 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg31  ;
#line 5487 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
CommandList_struct *ldvarg20  ;
#line 5488 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void *ldvarg60  ;
#line 5489 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg41  ;
#line 5490 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg3  ;
#line 5491 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
loff_t *ldvarg59  ;
#line 5492 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg49  ;
#line 5493 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg79  ;
#line 5494
void ldv_initialize(void) ;
#line 5495 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
fmode_t ldvarg13  ;
#line 5496 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
loff_t *ldvarg55  ;
#line 5497 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg36  ;
#line 5498 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct hd_geometry *ldvarg10  ;
#line 5499 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg40  ;
#line 5500 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg81  ;
#line 5501 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg45  ;
#line 5502 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
loff_t *ldvarg63  ;
#line 5503 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg70  ;
#line 5504 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg68  ;
#line 5505 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg30  ;
#line 5506
extern int ldv_cciss_dev_type_probe_2(void) ;
#line 5507 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg54  ;
#line 5508 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg82  ;
#line 5509 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg76  ;
#line 5510 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg19  ;
#line 5511 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg75  ;
#line 5512 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg77  ;
#line 5513 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned long ldvarg18  ;
#line 5514 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned long ldvarg11  ;
#line 5515 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg67  ;
#line 5516 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg23  ;
#line 5517 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg43  ;
#line 5518 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned long ldvarg71  ;
#line 5519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg72  ;
#line 5520 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct file *ldvarg56  ;
#line 5521 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg37  ;
#line 5522 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg29  ;
#line 5523 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldvarg24  ;
#line 5524 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg35  ;
#line 5525 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg38  ;
#line 5526 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg48  ;
#line 5527 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
fmode_t ldvarg14  ;
#line 5528
void ldv_check_final_state(void) ;
#line 5529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg34  ;
#line 5530 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct file *cciss_proc_fops_group2  ;
#line 5531 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct seq_file *cciss_seq_ops_group0  ;
#line 5532 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct inode *cciss_proc_fops_group1  ;
#line 5533 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
size_t ldvarg39  ;
#line 5534 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg80  ;
#line 5535 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void *ldvarg62  ;
#line 5536 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg65  ;
#line 5537 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
size_t ldvarg57  ;
#line 5538 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
unsigned int ldvarg8  ;
#line 5539 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct scsi_cmnd *cciss_driver_template_group1  ;
#line 5540 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device_attribute *ldvarg66  ;
#line 5541 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
fmode_t ldvarg9  ;
#line 5542 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char **ldvarg26  ;
#line 5543 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg27  ;
#line 5544 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
CommandList_struct *ldvarg73  ;
#line 5545 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
char *ldvarg78  ;
#line 5546 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct Scsi_Host *cciss_driver_template_group0  ;
#line 5547 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct device *ldvarg15  ;
#line 5548 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg21  ;
#line 5549 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void *ldvarg61  ;
#line 5550 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg17  ;
#line 5551 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
off_t ldvarg25  ;
#line 5552 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg22  ;
#line 5553 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
ctlr_info_t *ldvarg74  ;
#line 5554 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
loff_t *ldvarg52  ;
#line 5555 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_retval_3  ;
#line 5556 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct pci_dev *cciss_pci_driver_group0  ;
#line 5557
extern int ldv_cciss_host_type_probe_3(void) ;
#line 5584 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void main(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 5585
  ldv_initialize();
#line 5587
  ldv_state_variable_11 = 0;
#line 5588
  ldv_state_variable_7 = 0;
#line 5589
  ldv_state_variable_17 = 0;
#line 5590
  ldv_state_variable_2 = 0;
#line 5591
  ldv_state_variable_1 = 0;
#line 5592
  ldv_state_variable_18 = 0;
#line 5593
  ref_cnt = 0;
#line 5594
  ldv_state_variable_0 = 1;
#line 5595
  ldv_state_variable_16 = 0;
#line 5596
  ldv_state_variable_13 = 0;
#line 5597
  ldv_state_variable_6 = 0;
#line 5598
  ldv_state_variable_3 = 0;
#line 5599
  ldv_state_variable_9 = 0;
#line 5600
  ldv_state_variable_12 = 0;
#line 5601
  ldv_state_variable_20 = 0;
#line 5602
  ldv_state_variable_14 = 0;
#line 5603
  ldv_state_variable_15 = 0;
#line 5604
  ldv_state_variable_8 = 0;
#line 5605
  ldv_state_variable_4 = 0;
#line 5606
  ldv_state_variable_19 = 0;
#line 5607
  ldv_state_variable_10 = 0;
#line 5608
  ldv_state_variable_5 = 0;
  ldv_38342: 
#line 5610
  tmp = __VERIFIER_nondet_int();
#line 5610
  switch (tmp) {
  case 0: ;
#line 5614
  if (ldv_state_variable_11 != 0) {
#line 5615
    tmp___0 = __VERIFIER_nondet_int();
#line 5615
    switch (tmp___0) {
    case 0: ;
#line 5618
    if (ldv_state_variable_11 == 1) {
#line 5620
      host_show_transport_mode(ldvarg0, ldvarg2, ldvarg1);
#line 5622
      ldv_state_variable_11 = 1;
    } else {

    }
#line 5625
    goto ldv_38225;
    default: ;
#line 5626
    goto ldv_38225;
    }
    ldv_38225: ;
  } else {

  }
#line 5630
  goto ldv_38227;
  case 1: ;
#line 5634
  if (ldv_state_variable_7 != 0) {
#line 5635
    tmp___1 = __VERIFIER_nondet_int();
#line 5635
    switch (tmp___1) {
    case 0: ;
#line 5638
    if (ldv_state_variable_7 == 1) {
#line 5640
      dev_show_rev(ldvarg3, ldvarg5, ldvarg4);
#line 5642
      ldv_state_variable_7 = 1;
    } else {

    }
#line 5645
    goto ldv_38230;
    default: ;
#line 5646
    goto ldv_38230;
    }
    ldv_38230: ;
  } else {

  }
#line 5650
  goto ldv_38227;
  case 2: ;
#line 5654
  if (ldv_state_variable_17 != 0) {
#line 5655
    tmp___2 = __VERIFIER_nondet_int();
#line 5655
    switch (tmp___2) {
    case 0: ;
#line 5658
    if (ldv_state_variable_17 == 2) {
#line 5660
      cciss_release(cciss_fops_group0, ldvarg14);
#line 5662
      ldv_state_variable_17 = 1;
#line 5663
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5666
    goto ldv_38234;
    case 1: ;
#line 5669
    if (ldv_state_variable_17 == 1) {
#line 5671
      do_ioctl(cciss_fops_group1, ldvarg13, ldvarg12, ldvarg11);
#line 5673
      ldv_state_variable_17 = 1;
    } else {

    }
#line 5676
    if (ldv_state_variable_17 == 2) {
#line 5678
      do_ioctl(cciss_fops_group1, ldvarg13, ldvarg12, ldvarg11);
#line 5680
      ldv_state_variable_17 = 2;
    } else {

    }
#line 5683
    goto ldv_38234;
    case 2: ;
#line 5686
    if (ldv_state_variable_17 == 1) {
#line 5688
      cciss_getgeo(cciss_fops_group1, ldvarg10);
#line 5690
      ldv_state_variable_17 = 1;
    } else {

    }
#line 5693
    if (ldv_state_variable_17 == 2) {
#line 5695
      cciss_getgeo(cciss_fops_group1, ldvarg10);
#line 5697
      ldv_state_variable_17 = 2;
    } else {

    }
#line 5700
    goto ldv_38234;
    case 3: ;
#line 5703
    if (ldv_state_variable_17 == 1) {
#line 5705
      cciss_revalidate(cciss_fops_group0);
#line 5707
      ldv_state_variable_17 = 1;
    } else {

    }
#line 5710
    if (ldv_state_variable_17 == 2) {
#line 5712
      cciss_revalidate(cciss_fops_group0);
#line 5714
      ldv_state_variable_17 = 2;
    } else {

    }
#line 5717
    goto ldv_38234;
    case 4: ;
#line 5720
    if (ldv_state_variable_17 == 1) {
#line 5722
      cciss_compat_ioctl(cciss_fops_group1, ldvarg9, ldvarg8, ldvarg7);
#line 5724
      ldv_state_variable_17 = 1;
    } else {

    }
#line 5727
    if (ldv_state_variable_17 == 2) {
#line 5729
      cciss_compat_ioctl(cciss_fops_group1, ldvarg9, ldvarg8, ldvarg7);
#line 5731
      ldv_state_variable_17 = 2;
    } else {

    }
#line 5734
    goto ldv_38234;
    case 5: ;
#line 5737
    if (ldv_state_variable_17 == 1) {
#line 5739
      ldv_retval_0 = cciss_unlocked_open(cciss_fops_group1, ldvarg6);
#line 5741
      if (ldv_retval_0 == 0) {
#line 5742
        ldv_state_variable_17 = 2;
#line 5743
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 5747
    goto ldv_38234;
    default: ;
#line 5748
    goto ldv_38234;
    }
    ldv_38234: ;
  } else {

  }
#line 5752
  goto ldv_38227;
  case 3: ;
#line 5756
  if (ldv_state_variable_2 != 0) {
#line 5757
    tmp___3 = __VERIFIER_nondet_int();
#line 5757
    switch (tmp___3) {
    case 0: ;
#line 5760
    if (ldv_state_variable_2 == 2) {
#line 5762
      cciss_device_release(ldvarg15);
#line 5764
      ldv_state_variable_2 = 1;
#line 5765
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5768
    goto ldv_38243;
    case 1: ;
#line 5771
    if (ldv_state_variable_2 == 1) {
#line 5773
      ldv_cciss_dev_type_probe_2();
#line 5775
      ldv_state_variable_2 = 2;
#line 5776
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 5779
    goto ldv_38243;
    default: ;
#line 5780
    goto ldv_38243;
    }
    ldv_38243: ;
  } else {

  }
#line 5784
  goto ldv_38227;
  case 4: ;
#line 5788
  if (ldv_state_variable_1 != 0) {
#line 5789
    tmp___4 = __VERIFIER_nondet_int();
#line 5789
    switch (tmp___4) {
    case 0: ;
#line 5792
    if (ldv_state_variable_1 == 1) {
#line 5794
      ldv_retval_1 = cciss_init_one(cciss_pci_driver_group0, (struct pci_device_id  const  *)ldvarg16);
#line 5796
      if (ldv_retval_1 == 0) {
#line 5797
        ldv_state_variable_1 = 2;
#line 5798
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 5802
    goto ldv_38248;
    case 1: ;
#line 5805
    if (ldv_state_variable_1 == 2) {
#line 5807
      cciss_shutdown(cciss_pci_driver_group0);
#line 5809
      ldv_state_variable_1 = 3;
    } else {

    }
#line 5812
    goto ldv_38248;
    case 2: ;
#line 5815
    if (ldv_state_variable_1 == 3) {
#line 5817
      cciss_remove_one(cciss_pci_driver_group0);
#line 5819
      ldv_state_variable_1 = 1;
#line 5820
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5823
    if (ldv_state_variable_1 == 2) {
#line 5825
      cciss_remove_one(cciss_pci_driver_group0);
#line 5827
      ldv_state_variable_1 = 1;
#line 5828
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 5831
    goto ldv_38248;
    default: ;
#line 5832
    goto ldv_38248;
    }
    ldv_38248: ;
  } else {

  }
#line 5836
  goto ldv_38227;
  case 5: ;
#line 5840
  if (ldv_state_variable_18 != 0) {
#line 5841
    tmp___5 = __VERIFIER_nondet_int();
#line 5841
    switch (tmp___5) {
    case 0: ;
#line 5844
    if (ldv_state_variable_18 == 1) {
#line 5846
      SA5_fifo_full(ldvarg23);
#line 5848
      ldv_state_variable_18 = 1;
    } else {

    }
#line 5851
    goto ldv_38254;
    case 1: ;
#line 5854
    if (ldv_state_variable_18 == 1) {
#line 5856
      SA5_performant_intr_pending(ldvarg22);
#line 5858
      ldv_state_variable_18 = 1;
    } else {

    }
#line 5861
    goto ldv_38254;
    case 2: ;
#line 5864
    if (ldv_state_variable_18 == 1) {
#line 5866
      SA5_performant_completed(ldvarg21);
#line 5868
      ldv_state_variable_18 = 1;
    } else {

    }
#line 5871
    goto ldv_38254;
    case 3: ;
#line 5874
    if (ldv_state_variable_18 == 1) {
#line 5876
      SA5_submit_command(ldvarg19, ldvarg20);
#line 5878
      ldv_state_variable_18 = 1;
    } else {

    }
#line 5881
    goto ldv_38254;
    case 4: ;
#line 5884
    if (ldv_state_variable_18 == 1) {
#line 5886
      SA5_performant_intr_mask(ldvarg17, ldvarg18);
#line 5888
      ldv_state_variable_18 = 1;
    } else {

    }
#line 5891
    goto ldv_38254;
    default: ;
#line 5892
    goto ldv_38254;
    }
    ldv_38254: ;
  } else {

  }
#line 5896
  goto ldv_38227;
  case 6: ;
#line 5900
  if (ldv_state_variable_0 != 0) {
#line 5901
    tmp___6 = __VERIFIER_nondet_int();
#line 5901
    switch (tmp___6) {
    case 0: ;
#line 5904
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 5906
      cciss_cleanup();
#line 5907
      ldv_state_variable_0 = 3;
#line 5908
      goto ldv_final;
    } else {

    }
#line 5911
    goto ldv_38263;
    case 1: ;
#line 5914
    if (ldv_state_variable_0 == 1) {
#line 5916
      ldv_retval_2 = cciss_init();
#line 5917
      if (ldv_retval_2 != 0) {
#line 5918
        ldv_state_variable_0 = 3;
#line 5919
        goto ldv_final;
      } else {

      }
#line 5922
      if (ldv_retval_2 == 0) {
#line 5923
        ldv_state_variable_0 = 2;
#line 5924
        ldv_state_variable_5 = 1;
#line 5925
        ldv_state_variable_10 = 1;
#line 5926
        ldv_state_variable_19 = 1;
#line 5927
        ldv_state_variable_4 = 1;
#line 5928
        ldv_state_variable_8 = 1;
#line 5929
        ldv_state_variable_15 = 1;
#line 5930
        ldv_state_variable_14 = 1;
#line 5931
        ldv_state_variable_20 = 1;
#line 5932
        ldv_state_variable_12 = 1;
#line 5933
        ldv_state_variable_9 = 1;
#line 5934
        ldv_state_variable_3 = 1;
#line 5935
        ldv_state_variable_6 = 1;
#line 5936
        ldv_state_variable_13 = 1;
#line 5937
        ldv_state_variable_18 = 1;
#line 5938
        ldv_state_variable_1 = 1;
#line 5939
        ldv_state_variable_2 = 1;
#line 5940
        ldv_state_variable_17 = 1;
#line 5941
        ldv_state_variable_7 = 1;
#line 5942
        ldv_state_variable_11 = 1;
      } else {

      }
    } else {

    }
#line 5946
    goto ldv_38263;
    default: ;
#line 5947
    goto ldv_38263;
    }
    ldv_38263: ;
  } else {

  }
#line 5951
  goto ldv_38227;
  case 7: ;
#line 5955
  if (ldv_state_variable_16 != 0) {
#line 5956
    tmp___7 = __VERIFIER_nondet_int();
#line 5956
    switch (tmp___7) {
    case 0: ;
#line 5959
    if (ldv_state_variable_16 == 1) {
#line 5961
      cciss_eh_abort_handler(cciss_driver_template_group1);
#line 5963
      ldv_state_variable_16 = 1;
    } else {

    }
#line 5966
    goto ldv_38268;
    case 1: ;
#line 5969
    if (ldv_state_variable_16 == 1) {
#line 5971
      cciss_scsi_queue_command(cciss_driver_template_group0, cciss_driver_template_group1);
#line 5973
      ldv_state_variable_16 = 1;
    } else {

    }
#line 5976
    goto ldv_38268;
    case 2: ;
#line 5979
    if (ldv_state_variable_16 == 1) {
#line 5981
      cciss_scsi_proc_info(cciss_driver_template_group0, ldvarg27, ldvarg26, ldvarg25,
                           ldvarg28, ldvarg24);
#line 5983
      ldv_state_variable_16 = 1;
    } else {

    }
#line 5986
    goto ldv_38268;
    case 3: ;
#line 5989
    if (ldv_state_variable_16 == 1) {
#line 5991
      cciss_eh_device_reset_handler(cciss_driver_template_group1);
#line 5993
      ldv_state_variable_16 = 1;
    } else {

    }
#line 5996
    goto ldv_38268;
    default: ;
#line 5997
    goto ldv_38268;
    }
    ldv_38268: ;
  } else {

  }
#line 6001
  goto ldv_38227;
  case 8: ;
#line 6005
  if (ldv_state_variable_13 != 0) {
#line 6006
    tmp___8 = __VERIFIER_nondet_int();
#line 6006
    switch (tmp___8) {
    case 0: ;
#line 6009
    if (ldv_state_variable_13 == 1) {
#line 6011
      host_show_resettable(ldvarg29, ldvarg31, ldvarg30);
#line 6013
      ldv_state_variable_13 = 1;
    } else {

    }
#line 6016
    goto ldv_38275;
    default: ;
#line 6017
    goto ldv_38275;
    }
    ldv_38275: ;
  } else {

  }
#line 6021
  goto ldv_38227;
  case 9: ;
#line 6025
  if (ldv_state_variable_6 != 0) {
#line 6026
    tmp___9 = __VERIFIER_nondet_int();
#line 6026
    switch (tmp___9) {
    case 0: ;
#line 6029
    if (ldv_state_variable_6 == 1) {
#line 6031
      cciss_show_lunid(ldvarg32, ldvarg34, ldvarg33);
#line 6033
      ldv_state_variable_6 = 1;
    } else {

    }
#line 6036
    goto ldv_38279;
    default: ;
#line 6037
    goto ldv_38279;
    }
    ldv_38279: ;
  } else {

  }
#line 6041
  goto ldv_38227;
  case 10: ;
#line 6045
  if (ldv_state_variable_3 != 0) {
#line 6046
    tmp___10 = __VERIFIER_nondet_int();
#line 6046
    switch (tmp___10) {
    case 0: ;
#line 6049
    if (ldv_state_variable_3 == 2) {
#line 6051
      cciss_hba_release(ldvarg35);
#line 6053
      ldv_state_variable_3 = 1;
#line 6054
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6057
    goto ldv_38283;
    case 1: ;
#line 6060
    if (ldv_state_variable_3 == 1) {
#line 6062
      ldv_cciss_host_type_probe_3();
#line 6064
      ldv_state_variable_3 = 2;
#line 6065
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 6068
    goto ldv_38283;
    default: ;
#line 6069
    goto ldv_38283;
    }
    ldv_38283: ;
  } else {

  }
#line 6073
  goto ldv_38227;
  case 11: ;
#line 6077
  if (ldv_state_variable_9 != 0) {
#line 6078
    tmp___11 = __VERIFIER_nondet_int();
#line 6078
    switch (tmp___11) {
    case 0: ;
#line 6081
    if (ldv_state_variable_9 == 1) {
#line 6083
      dev_show_vendor(ldvarg36, ldvarg38, ldvarg37);
#line 6085
      ldv_state_variable_9 = 1;
    } else {

    }
#line 6088
    goto ldv_38288;
    default: ;
#line 6089
    goto ldv_38288;
    }
    ldv_38288: ;
  } else {

  }
#line 6093
  goto ldv_38227;
  case 12: ;
#line 6097
  if (ldv_state_variable_12 != 0) {
#line 6098
    tmp___12 = __VERIFIER_nondet_int();
#line 6098
    switch (tmp___12) {
    case 0: ;
#line 6101
    if (ldv_state_variable_12 == 1) {
#line 6103
      host_store_rescan(ldvarg40, ldvarg42, (char const   *)ldvarg41, ldvarg39);
#line 6105
      ldv_state_variable_12 = 1;
    } else {

    }
#line 6108
    goto ldv_38292;
    default: ;
#line 6109
    goto ldv_38292;
    }
    ldv_38292: ;
  } else {

  }
#line 6113
  goto ldv_38227;
  case 13: ;
#line 6117
  if (ldv_state_variable_20 != 0) {
#line 6118
    tmp___13 = __VERIFIER_nondet_int();
#line 6118
    switch (tmp___13) {
    case 0: ;
#line 6121
    if (ldv_state_variable_20 == 1) {
#line 6123
      SA5_fifo_full(ldvarg49);
#line 6125
      ldv_state_variable_20 = 1;
    } else {

    }
#line 6128
    goto ldv_38296;
    case 1: ;
#line 6131
    if (ldv_state_variable_20 == 1) {
#line 6133
      SA5_intr_pending(ldvarg48);
#line 6135
      ldv_state_variable_20 = 1;
    } else {

    }
#line 6138
    goto ldv_38296;
    case 2: ;
#line 6141
    if (ldv_state_variable_20 == 1) {
#line 6143
      SA5_completed(ldvarg47);
#line 6145
      ldv_state_variable_20 = 1;
    } else {

    }
#line 6148
    goto ldv_38296;
    case 3: ;
#line 6151
    if (ldv_state_variable_20 == 1) {
#line 6153
      SA5_submit_command(ldvarg45, ldvarg46);
#line 6155
      ldv_state_variable_20 = 1;
    } else {

    }
#line 6158
    goto ldv_38296;
    case 4: ;
#line 6161
    if (ldv_state_variable_20 == 1) {
#line 6163
      SA5_intr_mask(ldvarg43, ldvarg44);
#line 6165
      ldv_state_variable_20 = 1;
    } else {

    }
#line 6168
    goto ldv_38296;
    default: ;
#line 6169
    goto ldv_38296;
    }
    ldv_38296: ;
  } else {

  }
#line 6173
  goto ldv_38227;
  case 14: ;
#line 6177
  if (ldv_state_variable_14 != 0) {
#line 6178
    tmp___14 = __VERIFIER_nondet_int();
#line 6178
    switch (tmp___14) {
    case 0: ;
#line 6181
    if (ldv_state_variable_14 == 1) {
#line 6183
      cciss_proc_write(ldvarg56, (char const   *)ldvarg58, ldvarg57, ldvarg55);
#line 6185
      ldv_state_variable_14 = 1;
    } else {

    }
#line 6188
    if (ldv_state_variable_14 == 2) {
#line 6190
      cciss_proc_write(ldvarg56, (char const   *)ldvarg58, ldvarg57, ldvarg55);
#line 6192
      ldv_state_variable_14 = 2;
    } else {

    }
#line 6195
    goto ldv_38304;
    case 1: ;
#line 6198
    if (ldv_state_variable_14 == 2) {
#line 6200
      seq_release(cciss_proc_fops_group1, cciss_proc_fops_group2);
#line 6201
      ldv_state_variable_14 = 1;
#line 6202
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6205
    goto ldv_38304;
    case 2: ;
#line 6208
    if (ldv_state_variable_14 == 2) {
#line 6210
      seq_read(cciss_proc_fops_group2, ldvarg54, ldvarg53, ldvarg52);
#line 6212
      ldv_state_variable_14 = 2;
    } else {

    }
#line 6215
    goto ldv_38304;
    case 3: ;
#line 6218
    if (ldv_state_variable_14 == 2) {
#line 6220
      seq_lseek(cciss_proc_fops_group2, ldvarg51, ldvarg50);
#line 6222
      ldv_state_variable_14 = 2;
    } else {

    }
#line 6225
    goto ldv_38304;
    case 4: ;
#line 6228
    if (ldv_state_variable_14 == 1) {
#line 6230
      ldv_retval_3 = cciss_seq_open(cciss_proc_fops_group1, cciss_proc_fops_group2);
#line 6231
      if (ldv_retval_3 == 0) {
#line 6232
        ldv_state_variable_14 = 2;
#line 6233
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 6237
    goto ldv_38304;
    default: ;
#line 6238
    goto ldv_38304;
    }
    ldv_38304: ;
  } else {

  }
#line 6242
  goto ldv_38227;
  case 15: ;
#line 6246
  if (ldv_state_variable_15 != 0) {
#line 6247
    tmp___15 = __VERIFIER_nondet_int();
#line 6247
    switch (tmp___15) {
    case 0: ;
#line 6250
    if (ldv_state_variable_15 == 1) {
#line 6252
      cciss_seq_start(cciss_seq_ops_group0, ldvarg63);
#line 6254
      ldv_state_variable_15 = 2;
#line 6255
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 6258
    goto ldv_38312;
    case 1: ;
#line 6261
    if (ldv_state_variable_15 == 2) {
#line 6263
      cciss_seq_stop(cciss_seq_ops_group0, ldvarg62);
#line 6265
      ldv_state_variable_15 = 1;
#line 6266
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 6269
    goto ldv_38312;
    case 2: ;
#line 6272
    if (ldv_state_variable_15 == 1) {
#line 6274
      cciss_seq_show(cciss_seq_ops_group0, ldvarg61);
#line 6276
      ldv_state_variable_15 = 1;
    } else {

    }
#line 6279
    if (ldv_state_variable_15 == 2) {
#line 6281
      cciss_seq_show(cciss_seq_ops_group0, ldvarg61);
#line 6283
      ldv_state_variable_15 = 2;
    } else {

    }
#line 6286
    goto ldv_38312;
    case 3: ;
#line 6289
    if (ldv_state_variable_15 == 1) {
#line 6291
      cciss_seq_next(cciss_seq_ops_group0, ldvarg60, ldvarg59);
#line 6293
      ldv_state_variable_15 = 1;
    } else {

    }
#line 6296
    if (ldv_state_variable_15 == 2) {
#line 6298
      cciss_seq_next(cciss_seq_ops_group0, ldvarg60, ldvarg59);
#line 6300
      ldv_state_variable_15 = 2;
    } else {

    }
#line 6303
    goto ldv_38312;
    default: ;
#line 6304
    goto ldv_38312;
    }
    ldv_38312: ;
  } else {

  }
#line 6308
  goto ldv_38227;
  case 16: ;
#line 6312
  if (ldv_state_variable_8 != 0) {
#line 6313
    tmp___16 = __VERIFIER_nondet_int();
#line 6313
    switch (tmp___16) {
    case 0: ;
#line 6316
    if (ldv_state_variable_8 == 1) {
#line 6318
      dev_show_model(ldvarg64, ldvarg66, ldvarg65);
#line 6320
      ldv_state_variable_8 = 1;
    } else {

    }
#line 6323
    goto ldv_38319;
    default: ;
#line 6324
    goto ldv_38319;
    }
    ldv_38319: ;
  } else {

  }
#line 6328
  goto ldv_38227;
  case 17: ;
#line 6332
  if (ldv_state_variable_4 != 0) {
#line 6333
    tmp___17 = __VERIFIER_nondet_int();
#line 6333
    switch (tmp___17) {
    case 0: ;
#line 6336
    if (ldv_state_variable_4 == 1) {
#line 6338
      cciss_show_usage_count(ldvarg67, ldvarg69, ldvarg68);
#line 6340
      ldv_state_variable_4 = 1;
    } else {

    }
#line 6343
    goto ldv_38323;
    default: ;
#line 6344
    goto ldv_38323;
    }
    ldv_38323: ;
  } else {

  }
#line 6348
  goto ldv_38227;
  case 18: ;
#line 6352
  if (ldv_state_variable_19 != 0) {
#line 6353
    tmp___18 = __VERIFIER_nondet_int();
#line 6353
    switch (tmp___18) {
    case 0: ;
#line 6356
    if (ldv_state_variable_19 == 1) {
#line 6358
      SA5_fifo_full(ldvarg76);
#line 6360
      ldv_state_variable_19 = 1;
    } else {

    }
#line 6363
    goto ldv_38327;
    case 1: ;
#line 6366
    if (ldv_state_variable_19 == 1) {
#line 6368
      SA5B_intr_pending(ldvarg75);
#line 6370
      ldv_state_variable_19 = 1;
    } else {

    }
#line 6373
    goto ldv_38327;
    case 2: ;
#line 6376
    if (ldv_state_variable_19 == 1) {
#line 6378
      SA5_completed(ldvarg74);
#line 6380
      ldv_state_variable_19 = 1;
    } else {

    }
#line 6383
    goto ldv_38327;
    case 3: ;
#line 6386
    if (ldv_state_variable_19 == 1) {
#line 6388
      SA5_submit_command(ldvarg72, ldvarg73);
#line 6390
      ldv_state_variable_19 = 1;
    } else {

    }
#line 6393
    goto ldv_38327;
    case 4: ;
#line 6396
    if (ldv_state_variable_19 == 1) {
#line 6398
      SA5B_intr_mask(ldvarg70, ldvarg71);
#line 6400
      ldv_state_variable_19 = 1;
    } else {

    }
#line 6403
    goto ldv_38327;
    default: ;
#line 6404
    goto ldv_38327;
    }
    ldv_38327: ;
  } else {

  }
#line 6408
  goto ldv_38227;
  case 19: ;
#line 6412
  if (ldv_state_variable_10 != 0) {
#line 6413
    tmp___19 = __VERIFIER_nondet_int();
#line 6413
    switch (tmp___19) {
    case 0: ;
#line 6416
    if (ldv_state_variable_10 == 1) {
#line 6418
      dev_show_unique_id(ldvarg77, ldvarg79, ldvarg78);
#line 6420
      ldv_state_variable_10 = 1;
    } else {

    }
#line 6423
    goto ldv_38335;
    default: ;
#line 6424
    goto ldv_38335;
    }
    ldv_38335: ;
  } else {

  }
#line 6428
  goto ldv_38227;
  case 20: ;
#line 6432
  if (ldv_state_variable_5 != 0) {
#line 6433
    tmp___20 = __VERIFIER_nondet_int();
#line 6433
    switch (tmp___20) {
    case 0: ;
#line 6436
    if (ldv_state_variable_5 == 1) {
#line 6438
      cciss_show_raid_level(ldvarg80, ldvarg82, ldvarg81);
#line 6440
      ldv_state_variable_5 = 1;
    } else {

    }
#line 6443
    goto ldv_38339;
    default: ;
#line 6444
    goto ldv_38339;
    }
    ldv_38339: ;
  } else {

  }
#line 6448
  goto ldv_38227;
  default: ;
#line 6449
  goto ldv_38227;
  }
  ldv_38227: ;
#line 6451
  goto ldv_38342;
  ldv_final: 
#line 6453
  ldv_check_final_state();
#line 6454
  return;
}
}
#line 6457 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6462
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 6464
  mutex_lock(ldv_func_arg1);
#line 6465
  return;
}
}
#line 6467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6472
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 6474
  mutex_unlock(ldv_func_arg1);
#line 6475
  return;
}
}
#line 6477 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6482
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 6484
  mutex_lock(ldv_func_arg1);
#line 6485
  return;
}
}
#line 6487 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 6492
  tmp = mutex_trylock(ldv_func_arg1);
#line 6492
  ldv_func_res = tmp;
#line 6494
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 6494
  return (tmp___0);
#line 6496
  return (ldv_func_res);
}
}
#line 6499 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6504
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 6506
  mutex_unlock(ldv_func_arg1);
#line 6507
  return;
}
}
#line 6509 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6514
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 6516
  mutex_lock(ldv_func_arg1);
#line 6517
  return;
}
}
#line 6519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6524
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 6526
  mutex_unlock(ldv_func_arg1);
#line 6527
  return;
}
}
#line 6529 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_scsi_add_host_with_dma_8(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 6536
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 6536
  ldv_func_res = tmp;
#line 6538
  if (ldv_func_res == 0) {
#line 6539
    ldv_state_variable_16 = 1;
  } else {

  }
#line 6542
  return (ldv_func_res);
}
}
#line 6545 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_9(struct scsi_host_template *sht , int privsize ) 
{ ldv_func_ret_type___7 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 6551
  tmp = scsi_host_alloc(sht, privsize);
#line 6551
  ldv_func_res = tmp;
#line 6553
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___7 )0)) {
#line 6554
    ldv_state_variable_16 = 1;
  } else {

  }
#line 6557
  return (ldv_func_res);
}
}
#line 6560 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_scsi_remove_host_10(struct Scsi_Host *shost ) 
{ 

  {
#line 6565
  scsi_remove_host(shost);
#line 6567
  ldv_state_variable_16 = 0;
#line 6568
  return;
}
}
#line 6570 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6575
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 6577
  mutex_lock(ldv_func_arg1);
#line 6578
  return;
}
}
#line 6580 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6585
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 6587
  mutex_unlock(ldv_func_arg1);
#line 6588
  return;
}
}
#line 6590 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6595
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 6597
  mutex_lock(ldv_func_arg1);
#line 6598
  return;
}
}
#line 6600 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6605
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 6607
  mutex_unlock(ldv_func_arg1);
#line 6608
  return;
}
}
#line 6610 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6615
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 6617
  mutex_lock(ldv_func_arg1);
#line 6618
  return;
}
}
#line 6620 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6625
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 6627
  mutex_unlock(ldv_func_arg1);
#line 6628
  return;
}
}
#line 6630 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_mutex_trylock_17(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 6635
  tmp = mutex_trylock(ldv_func_arg1);
#line 6635
  ldv_func_res = tmp;
#line 6637
  tmp___0 = ldv_mutex_trylock_busy_shutting_down_of_ctlr_info(ldv_func_arg1);
#line 6637
  return (tmp___0);
#line 6639
  return (ldv_func_res);
}
}
#line 6642 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6647
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 6649
  mutex_lock(ldv_func_arg1);
#line 6650
  return;
}
}
#line 6652 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6657
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6659
  mutex_unlock(ldv_func_arg1);
#line 6660
  return;
}
}
#line 6662 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6667
  ldv_mutex_unlock_busy_shutting_down_of_ctlr_info(ldv_func_arg1);
#line 6669
  mutex_unlock(ldv_func_arg1);
#line 6670
  return;
}
}
#line 6672 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6677
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 6679
  mutex_lock(ldv_func_arg1);
#line 6680
  return;
}
}
#line 6682 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6687
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6689
  mutex_unlock(ldv_func_arg1);
#line 6690
  return;
}
}
#line 6692 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6697
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6699
  mutex_unlock(ldv_func_arg1);
#line 6700
  return;
}
}
#line 6702 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6707
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6709
  mutex_unlock(ldv_func_arg1);
#line 6710
  return;
}
}
#line 6712 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6717
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 6719
  mutex_lock(ldv_func_arg1);
#line 6720
  return;
}
}
#line 6722 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6727
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6729
  mutex_unlock(ldv_func_arg1);
#line 6730
  return;
}
}
#line 6732 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6737
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6739
  mutex_unlock(ldv_func_arg1);
#line 6740
  return;
}
}
#line 6742 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6747
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 6749
  mutex_lock(ldv_func_arg1);
#line 6750
  return;
}
}
#line 6752 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6757
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 6759
  mutex_unlock(ldv_func_arg1);
#line 6760
  return;
}
}
#line 6762 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_30(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6767
  ldv_mutex_lock_busy_shutting_down_of_ctlr_info(ldv_func_arg1);
#line 6769
  mutex_lock(ldv_func_arg1);
#line 6770
  return;
}
}
#line 6772 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 6777
  ldv_mutex_unlock_busy_shutting_down_of_ctlr_info(ldv_func_arg1);
#line 6779
  mutex_unlock(ldv_func_arg1);
#line 6780
  return;
}
}
#line 10 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 

  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 

  {
#line 51
  return (exp);
}
}
#line 59 "/home/ldvuser/ldv_envgen2/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 

  {
#line 61
  ldv_error();
#line 62
  return;
}
}
#line 8 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_busy_shutting_down_of_ctlr_info  ;
#line 11 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 16
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_busy_shutting_down_of_ctlr_info = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 42
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_busy_shutting_down_of_ctlr_info = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ 

  {
#line 66
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_busy_shutting_down_of_ctlr_info = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_busy_shutting_down_of_ctlr_info = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_busy_shutting_down_of_ctlr_info(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_busy_shutting_down_of_ctlr_info = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 127
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_busy_shutting_down_of_ctlr_info(struct mutex *lock ) 
{ 

  {
#line 155
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_busy_shutting_down_of_ctlr_info = 1;
#line 158
  return;
}
}
#line 160 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cciss_mutex  ;
#line 163 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cciss_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 168
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cciss_mutex = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cciss_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 194
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cciss_mutex = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cciss_mutex(struct mutex *lock ) 
{ 

  {
#line 218
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cciss_mutex = 2;
#line 221
  return;
}
}
#line 224 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cciss_mutex(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cciss_mutex = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cciss_mutex(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cciss_mutex = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cciss_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 279
  if (ldv_mutex_cciss_mutex == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cciss_mutex(struct mutex *lock ) 
{ 

  {
#line 307
  if (ldv_mutex_cciss_mutex == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cciss_mutex = 1;
#line 310
  return;
}
}
#line 312 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex_of_signal_struct  ;
#line 315 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 320
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 346
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 370
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 373
  return;
}
}
#line 376 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex_of_signal_struct(atomic_t *cnt ,
                                                                    struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 431
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 459
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 462
  return;
}
}
#line 464 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 467 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 472
  if (ldv_mutex_lock == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_lock = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 498
  if (ldv_mutex_lock == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_lock = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 

  {
#line 522
  if (ldv_mutex_lock == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_lock = 2;
#line 525
  return;
}
}
#line 528 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_lock == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_lock = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_lock == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_lock = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 583
  if (ldv_mutex_lock == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 

  {
#line 611
  if (ldv_mutex_lock == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_lock = 1;
#line 614
  return;
}
}
#line 616 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  ;
#line 619 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 624
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_mutex_of_device = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 650
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_mutex_of_device = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 674
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_mutex_of_device = 2;
#line 677
  return;
}
}
#line 680 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_mutex_of_device = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_mutex_of_device = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 735
  if (ldv_mutex_mutex_of_device == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 763
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_mutex_of_device = 1;
#line 766
  return;
}
}
#line 768 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_scan_mutex  ;
#line 771 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_scan_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 776
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_scan_mutex = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_scan_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 802
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_scan_mutex = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_scan_mutex(struct mutex *lock ) 
{ 

  {
#line 826
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_scan_mutex = 2;
#line 829
  return;
}
}
#line 832 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_scan_mutex(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_scan_mutex = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_scan_mutex(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_scan_mutex = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_scan_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 887
  if (ldv_mutex_scan_mutex == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_scan_mutex(struct mutex *lock ) 
{ 

  {
#line 915
  if (ldv_mutex_scan_mutex == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_scan_mutex = 1;
#line 918
  return;
}
}
#line 922 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 

  {
#line 925
  ldv_mutex_busy_shutting_down_of_ctlr_info = 1;
#line 927
  ldv_mutex_cciss_mutex = 1;
#line 929
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 931
  ldv_mutex_lock = 1;
#line 933
  ldv_mutex_mutex_of_device = 1;
#line 935
  ldv_mutex_scan_mutex = 1;
#line 936
  return;
}
}
#line 939 "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/block/cciss.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 

  {
#line 942
  if (ldv_mutex_busy_shutting_down_of_ctlr_info == 1) {

  } else {
#line 942
    ldv_error();
  }
#line 944
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 944
    ldv_error();
  }
#line 946
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 946
    ldv_error();
  }
#line 948
  if (ldv_mutex_lock == 1) {

  } else {
#line 948
    ldv_error();
  }
#line 950
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 950
    ldv_error();
  }
#line 952
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 952
    ldv_error();
  }
#line 953
  return;
}
}
