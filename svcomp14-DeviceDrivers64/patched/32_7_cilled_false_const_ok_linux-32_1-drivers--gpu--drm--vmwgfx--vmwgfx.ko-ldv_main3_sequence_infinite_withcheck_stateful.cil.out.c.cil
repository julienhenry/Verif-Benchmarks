extern void __VERIFIER_error() __attribute__ ((__noreturn__)); /* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef __kernel_ulong_t __kernel_nlink_t;
typedef int __kernel_pid_t;
typedef __kernel_long_t __kernel_suseconds_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef __u32 __le32;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_7 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
struct __anonstruct_atomic64_t_8 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
typedef uint32_t uint32;
typedef int32_t int32;
struct SVGAGuestPtr {
   uint32 gmrId ;
   uint32 offset ;
};
typedef struct SVGAGuestPtr SVGAGuestPtr;
struct __anonstruct____missing_field_name_11 {
   uint32 bitsPerPixel : 8 ;
   uint32 colorDepth : 8 ;
   uint32 reserved : 16 ;
};
union __anonunion____missing_field_name_10 {
   struct __anonstruct____missing_field_name_11 __annonCompField4 ;
   uint32 value ;
};
struct SVGAGMRImageFormat {
   union __anonunion____missing_field_name_10 __annonCompField5 ;
};
typedef struct SVGAGMRImageFormat SVGAGMRImageFormat;
struct SVGASignedRect {
   int32 left ;
   int32 top ;
   int32 right ;
   int32 bottom ;
};
typedef struct SVGASignedRect SVGASignedRect;
struct SVGASignedPoint {
   int32 x ;
   int32 y ;
};
typedef struct SVGASignedPoint SVGASignedPoint;
struct SVGAFifoCmdUpdate {
   uint32 x ;
   uint32 y ;
   uint32 width ;
   uint32 height ;
};
typedef struct SVGAFifoCmdUpdate SVGAFifoCmdUpdate;
struct __anonstruct_SVGAFifoCmdDefineGMRFB_22 {
   SVGAGuestPtr ptr ;
   uint32 bytesPerLine ;
   SVGAGMRImageFormat format ;
};
typedef struct __anonstruct_SVGAFifoCmdDefineGMRFB_22 SVGAFifoCmdDefineGMRFB;
struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_23 {
   SVGASignedPoint srcOrigin ;
   SVGASignedRect destRect ;
   uint32 destScreenId ;
};
typedef struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_23 SVGAFifoCmdBlitGMRFBToScreen;
enum __anonenum_SVGA3dRenderTargetType_54 {
    SVGA3D_RT_DEPTH = 0,
    SVGA3D_RT_STENCIL = 1,
    SVGA3D_RT_COLOR0 = 2,
    SVGA3D_RT_COLOR1 = 3,
    SVGA3D_RT_COLOR2 = 4,
    SVGA3D_RT_COLOR3 = 5,
    SVGA3D_RT_COLOR4 = 6,
    SVGA3D_RT_COLOR5 = 7,
    SVGA3D_RT_COLOR6 = 8,
    SVGA3D_RT_COLOR7 = 9,
    SVGA3D_RT_MAX = 10,
    SVGA3D_RT_INVALID = 4294967295U
} ;
typedef enum __anonenum_SVGA3dRenderTargetType_54 SVGA3dRenderTargetType;
enum __anonenum_SVGA3dTextureStateName_59 {
    SVGA3D_TS_INVALID = 0,
    SVGA3D_TS_BIND_TEXTURE = 1,
    SVGA3D_TS_COLOROP = 2,
    SVGA3D_TS_COLORARG1 = 3,
    SVGA3D_TS_COLORARG2 = 4,
    SVGA3D_TS_ALPHAOP = 5,
    SVGA3D_TS_ALPHAARG1 = 6,
    SVGA3D_TS_ALPHAARG2 = 7,
    SVGA3D_TS_ADDRESSU = 8,
    SVGA3D_TS_ADDRESSV = 9,
    SVGA3D_TS_MIPFILTER = 10,
    SVGA3D_TS_MAGFILTER = 11,
    SVGA3D_TS_MINFILTER = 12,
    SVGA3D_TS_BORDERCOLOR = 13,
    SVGA3D_TS_TEXCOORDINDEX = 14,
    SVGA3D_TS_TEXTURETRANSFORMFLAGS = 15,
    SVGA3D_TS_TEXCOORDGEN = 16,
    SVGA3D_TS_BUMPENVMAT00 = 17,
    SVGA3D_TS_BUMPENVMAT01 = 18,
    SVGA3D_TS_BUMPENVMAT10 = 19,
    SVGA3D_TS_BUMPENVMAT11 = 20,
    SVGA3D_TS_TEXTURE_MIPMAP_LEVEL = 21,
    SVGA3D_TS_TEXTURE_LOD_BIAS = 22,
    SVGA3D_TS_TEXTURE_ANISOTROPIC_LEVEL = 23,
    SVGA3D_TS_ADDRESSW = 24,
    SVGA3D_TS_GAMMA = 25,
    SVGA3D_TS_BUMPENVLSCALE = 26,
    SVGA3D_TS_BUMPENVLOFFSET = 27,
    SVGA3D_TS_COLORARG0 = 28,
    SVGA3D_TS_ALPHAARG0 = 29,
    SVGA3D_TS_MAX = 30
} ;
typedef enum __anonenum_SVGA3dTextureStateName_59 SVGA3dTextureStateName;
enum __anonenum_SVGA3dDeclUsage_67 {
    SVGA3D_DECLUSAGE_POSITION = 0,
    SVGA3D_DECLUSAGE_BLENDWEIGHT = 1,
    SVGA3D_DECLUSAGE_BLENDINDICES = 2,
    SVGA3D_DECLUSAGE_NORMAL = 3,
    SVGA3D_DECLUSAGE_PSIZE = 4,
    SVGA3D_DECLUSAGE_TEXCOORD = 5,
    SVGA3D_DECLUSAGE_TANGENT = 6,
    SVGA3D_DECLUSAGE_BINORMAL = 7,
    SVGA3D_DECLUSAGE_TESSFACTOR = 8,
    SVGA3D_DECLUSAGE_POSITIONT = 9,
    SVGA3D_DECLUSAGE_COLOR = 10,
    SVGA3D_DECLUSAGE_FOG = 11,
    SVGA3D_DECLUSAGE_DEPTH = 12,
    SVGA3D_DECLUSAGE_SAMPLE = 13,
    SVGA3D_DECLUSAGE_MAX = 14
} ;
typedef enum __anonenum_SVGA3dDeclUsage_67 SVGA3dDeclUsage;
enum __anonenum_SVGA3dDeclMethod_68 {
    SVGA3D_DECLMETHOD_DEFAULT = 0,
    SVGA3D_DECLMETHOD_PARTIALU = 1,
    SVGA3D_DECLMETHOD_PARTIALV = 2,
    SVGA3D_DECLMETHOD_CROSSUV = 3,
    SVGA3D_DECLMETHOD_UV = 4,
    SVGA3D_DECLMETHOD_LOOKUP = 5,
    SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED = 6
} ;
typedef enum __anonenum_SVGA3dDeclMethod_68 SVGA3dDeclMethod;
enum __anonenum_SVGA3dDeclType_69 {
    SVGA3D_DECLTYPE_FLOAT1 = 0,
    SVGA3D_DECLTYPE_FLOAT2 = 1,
    SVGA3D_DECLTYPE_FLOAT3 = 2,
    SVGA3D_DECLTYPE_FLOAT4 = 3,
    SVGA3D_DECLTYPE_D3DCOLOR = 4,
    SVGA3D_DECLTYPE_UBYTE4 = 5,
    SVGA3D_DECLTYPE_SHORT2 = 6,
    SVGA3D_DECLTYPE_SHORT4 = 7,
    SVGA3D_DECLTYPE_UBYTE4N = 8,
    SVGA3D_DECLTYPE_SHORT2N = 9,
    SVGA3D_DECLTYPE_SHORT4N = 10,
    SVGA3D_DECLTYPE_USHORT2N = 11,
    SVGA3D_DECLTYPE_USHORT4N = 12,
    SVGA3D_DECLTYPE_UDEC3 = 13,
    SVGA3D_DECLTYPE_DEC3N = 14,
    SVGA3D_DECLTYPE_FLOAT16_2 = 15,
    SVGA3D_DECLTYPE_FLOAT16_4 = 16,
    SVGA3D_DECLTYPE_MAX = 17
} ;
typedef enum __anonenum_SVGA3dDeclType_69 SVGA3dDeclType;
enum __anonenum_SVGA3dPrimitiveType_72 {
    SVGA3D_PRIMITIVE_INVALID = 0,
    SVGA3D_PRIMITIVE_TRIANGLELIST = 1,
    SVGA3D_PRIMITIVE_POINTLIST = 2,
    SVGA3D_PRIMITIVE_LINELIST = 3,
    SVGA3D_PRIMITIVE_LINESTRIP = 4,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP = 5,
    SVGA3D_PRIMITIVE_TRIANGLEFAN = 6,
    SVGA3D_PRIMITIVE_MAX = 7
} ;
typedef enum __anonenum_SVGA3dPrimitiveType_72 SVGA3dPrimitiveType;
enum __anonenum_SVGA3dStretchBltMode_79 {
    SVGA3D_STRETCH_BLT_POINT = 0,
    SVGA3D_STRETCH_BLT_LINEAR = 1,
    SVGA3D_STRETCH_BLT_MAX = 2
} ;
typedef enum __anonenum_SVGA3dStretchBltMode_79 SVGA3dStretchBltMode;
enum __anonenum_SVGA3dQueryType_80 {
    SVGA3D_QUERYTYPE_OCCLUSION = 0,
    SVGA3D_QUERYTYPE_MAX = 1
} ;
typedef enum __anonenum_SVGA3dQueryType_80 SVGA3dQueryType;
enum __anonenum_SVGA3dTransferType_82 {
    SVGA3D_WRITE_HOST_VRAM = 1,
    SVGA3D_READ_HOST_VRAM = 2
} ;
typedef enum __anonenum_SVGA3dTransferType_82 SVGA3dTransferType;
struct SVGA3dSurfaceImageId {
   uint32 sid ;
   uint32 face ;
   uint32 mipmap ;
};
typedef struct SVGA3dSurfaceImageId SVGA3dSurfaceImageId;
struct SVGA3dGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
typedef struct SVGA3dGuestImage SVGA3dGuestImage;
struct __anonstruct_SVGA3dCmdHeader_86 {
   uint32 id ;
   uint32 size ;
};
typedef struct __anonstruct_SVGA3dCmdHeader_86 SVGA3dCmdHeader;
struct __anonstruct_SVGA3dBox_97 {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
};
typedef struct __anonstruct_SVGA3dBox_97 SVGA3dBox;
struct __anonstruct_SVGA3dCmdPresent_100 {
   uint32 sid ;
};
typedef struct __anonstruct_SVGA3dCmdPresent_100 SVGA3dCmdPresent;
struct __anonstruct_SVGA3dCmdSetRenderTarget_104 {
   uint32 cid ;
   SVGA3dRenderTargetType type ;
   SVGA3dSurfaceImageId target ;
};
typedef struct __anonstruct_SVGA3dCmdSetRenderTarget_104 SVGA3dCmdSetRenderTarget;
struct __anonstruct_SVGA3dCmdSurfaceCopy_105 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
};
typedef struct __anonstruct_SVGA3dCmdSurfaceCopy_105 SVGA3dCmdSurfaceCopy;
struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_106 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
   SVGA3dBox boxSrc ;
   SVGA3dBox boxDest ;
   SVGA3dStretchBltMode mode ;
};
typedef struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_106 SVGA3dCmdSurfaceStretchBlt;
struct __anonstruct_SVGA3dCmdSurfaceDMA_108 {
   SVGA3dGuestImage guest ;
   SVGA3dSurfaceImageId host ;
   SVGA3dTransferType transfer ;
};
typedef struct __anonstruct_SVGA3dCmdSurfaceDMA_108 SVGA3dCmdSurfaceDMA;
struct __anonstruct_SVGA3dArrayRangeHint_110 {
   uint32 first ;
   uint32 last ;
};
typedef struct __anonstruct_SVGA3dArrayRangeHint_110 SVGA3dArrayRangeHint;
struct __anonstruct_SVGA3dArray_111 {
   uint32 surfaceId ;
   uint32 offset ;
   uint32 stride ;
};
typedef struct __anonstruct_SVGA3dArray_111 SVGA3dArray;
struct __anonstruct_SVGA3dVertexArrayIdentity_112 {
   SVGA3dDeclType type ;
   SVGA3dDeclMethod method ;
   SVGA3dDeclUsage usage ;
   uint32 usageIndex ;
};
typedef struct __anonstruct_SVGA3dVertexArrayIdentity_112 SVGA3dVertexArrayIdentity;
struct __anonstruct_SVGA3dVertexDecl_113 {
   SVGA3dVertexArrayIdentity identity ;
   SVGA3dArray array ;
   SVGA3dArrayRangeHint rangeHint ;
};
typedef struct __anonstruct_SVGA3dVertexDecl_113 SVGA3dVertexDecl;
struct __anonstruct_SVGA3dPrimitiveRange_114 {
   SVGA3dPrimitiveType primType ;
   uint32 primitiveCount ;
   SVGA3dArray indexArray ;
   uint32 indexWidth ;
   int32 indexBias ;
};
typedef struct __anonstruct_SVGA3dPrimitiveRange_114 SVGA3dPrimitiveRange;
struct __anonstruct_SVGA3dCmdDrawPrimitives_115 {
   uint32 cid ;
   uint32 numVertexDecls ;
   uint32 numRanges ;
};
typedef struct __anonstruct_SVGA3dCmdDrawPrimitives_115 SVGA3dCmdDrawPrimitives;
union __anonunion____missing_field_name_117 {
   uint32 value ;
   float floatValue ;
};
struct __anonstruct_SVGA3dTextureState_116 {
   uint32 stage ;
   SVGA3dTextureStateName name ;
   union __anonunion____missing_field_name_117 __annonCompField16 ;
};
typedef struct __anonstruct_SVGA3dTextureState_116 SVGA3dTextureState;
struct __anonstruct_SVGA3dCmdEndQuery_134 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
typedef struct __anonstruct_SVGA3dCmdEndQuery_134 SVGA3dCmdEndQuery;
struct __anonstruct_SVGA3dCmdWaitForQuery_135 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
typedef struct __anonstruct_SVGA3dCmdWaitForQuery_135 SVGA3dCmdWaitForQuery;
struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_138 {
   SVGA3dSurfaceImageId srcImage ;
   SVGASignedRect srcRect ;
   uint32 destScreenId ;
   SVGASignedRect destRect ;
};
typedef struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_138 SVGA3dCmdBlitSurfaceToScreen;
struct module;
struct module;
struct device;
struct device;
struct completion;
struct completion;
struct pt_regs;
struct pt_regs;
struct pid;
struct pid;
struct file_operations;
struct file_operations;
struct page;
struct page;
struct block_device;
struct block_device;
struct timespec;
struct timespec;
struct task_struct;
struct task_struct;
struct mm_struct;
struct mm_struct;
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct __anonstruct____missing_field_name_148 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_149 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField19 ;
   struct __anonstruct____missing_field_name_149 __annonCompField20 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_147 __annonCompField21 ;
} __attribute__((__packed__)) ;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_153 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_153 pgd_t;
typedef struct page *pgtable_t;
struct file;
struct file;
struct seq_file;
struct seq_file;
struct thread_struct;
struct thread_struct;
struct cpumask;
struct cpumask;
struct arch_spinlock;
struct arch_spinlock;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion____missing_field_name_157 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_157 __annonCompField22 ;
};
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct cpumask {
   unsigned long bits[((4096UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct seq_operations;
struct seq_operations;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_164 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_165 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_163 {
   struct __anonstruct____missing_field_name_164 __annonCompField26 ;
   struct __anonstruct____missing_field_name_165 __annonCompField27 ;
};
union __anonunion____missing_field_name_166 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_163 __annonCompField28 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_166 __annonCompField29 ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
struct kmem_cache;
struct kmem_cache;
struct perf_event;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
typedef atomic64_t atomic_long_t;
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
union __anonunion____missing_field_name_169 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
struct arch_spinlock {
   union __anonunion____missing_field_name_169 __annonCompField31 ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct __anonstruct____missing_field_name_171 {
   u32 read ;
   s32 write ;
};
union __anonunion_arch_rwlock_t_170 {
   s64 lock ;
   struct __anonstruct____missing_field_name_171 __annonCompField32 ;
};
typedef union __anonunion_arch_rwlock_t_170 arch_rwlock_t;
struct lock_class_key {

};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
typedef struct raw_spinlock raw_spinlock_t;
union __anonunion____missing_field_name_172 {
   struct raw_spinlock rlock ;
};
struct spinlock {
   union __anonunion____missing_field_name_172 __annonCompField33 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_173 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
typedef struct __anonstruct_rwlock_t_173 rwlock_t;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct notifier_block;
struct notifier_block;
struct hlist_bl_node;
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct nameidata;
struct nameidata;
struct path;
struct path;
struct vfsmount;
struct vfsmount;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char *name ;
};
struct inode;
struct inode;
struct dentry_operations;
struct dentry_operations;
struct super_block;
struct super_block;
union __anonunion_d_u_175 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_175 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct inode * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct inode * , struct dentry  const  * , struct inode * ,
                    unsigned int  , char * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct radix_tree_node;
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct prio_tree_node;
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char *name ;
   void *magic ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct kernel_cap_struct {
   __u32 cap[2] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct user_namespace;
struct user_namespace;
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control *sc ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct export_operations;
struct export_operations;
struct iovec;
struct iovec;
struct kiocb;
struct kiocb;
struct kobject;
struct kobject;
struct pipe_inode_info;
struct pipe_inode_info;
struct poll_table_struct;
struct poll_table_struct;
struct kstatfs;
struct kstatfs;
struct vm_area_struct;
struct vm_area_struct;
struct cred;
struct cred;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct rw_semaphore;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct pci_dev;
typedef unsigned long long cycles_t;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_base;
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
struct hrtimer;
struct hrtimer;
enum hrtimer_restart;
enum hrtimer_restart;
struct workqueue_struct;
struct workqueue_struct;
struct work_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_late)(struct device *dev ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*freeze_late)(struct device *dev ) ;
   int (*thaw_early)(struct device *dev ) ;
   int (*poweroff_late)(struct device *dev ) ;
   int (*restore_early)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wakeup_source;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
struct dev_pm_qos_request;
struct dev_pm_qos_request;
struct pm_qos_raints;
struct pm_qos_raints;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool ignore_children : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   ktime_t suspend_time ;
   s64 max_time_suspended_ns ;
   struct dev_pm_qos_request *pq_req ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_raints *raints ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
struct __anonstruct_nodemask_t_247 {
   unsigned long bits[(((unsigned long )(1 << 10) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct_nodemask_t_247 nodemask_t;
struct pci_bus;
struct pci_bus;
struct __anonstruct_mm_context_t_248 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_248 mm_context_t;
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct dquot;
struct dquot;
typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct address_space;
struct address_space;
struct writeback_control;
struct writeback_control;
union __anonunion_arg_278 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_277 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_278 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_277 read_descriptor_t;
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
struct backing_dev_info;
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct request_queue;
struct request_queue;
struct hd_struct;
struct hd_struct;
struct gendisk;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct posix_acl;
struct inode_operations;
struct inode_operations;
union __anonunion____missing_field_name_279 {
   unsigned int i_nlink ;
   unsigned int __i_nlink ;
};
union __anonunion____missing_field_name_280 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
struct file_lock;
struct file_lock;
struct cdev;
struct cdev;
union __anonunion____missing_field_name_281 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   uid_t i_uid ;
   gid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_279 __annonCompField44 ;
   dev_t i_rdev ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   blkcnt_t i_blocks ;
   loff_t i_size ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_280 __annonCompField45 ;
   atomic_t i_count ;
   unsigned int i_blkbits ;
   u64 i_version ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_281 __annonCompField46 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_282 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_282 f_u ;
   struct path f_path ;
   struct file_operations *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
struct files_struct;
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
struct nlm_lockowner;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct fasync_struct;
struct __anonstruct_afs_284 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_283 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_284 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_283 fl_u ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
struct file_system_type;
struct file_system_type;
struct super_operations;
struct super_operations;
struct xattr_handler;
struct xattr_handler;
struct mtd_info;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock  __attribute__((__aligned__((1) <<  (6) ))) ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   u8 s_uuid[16] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec * , unsigned long  , loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec * , unsigned long  , loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char * , int  , loff_t  ,
                                                   u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file *file , int mode , loff_t offset , loff_t len ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char * , void * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int flags ) ;
   int (*write_inode)(struct inode * , struct writeback_control *wbc ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
struct file_system_type {
   char *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct sock;
struct sock;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void *(*netlink_ns)(struct sock *sk ) ;
   void *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
enum kobj_ns_type;
struct attribute {
   char *name ;
   umode_t mode ;
};
struct attribute_group {
   char *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char * , size_t  ) ;
   void *(*namespace)(struct kobject * , struct attribute * ) ;
};
struct sysfs_dirent;
struct sysfs_dirent;
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kset;
struct kobj_type;
struct kobj_type;
struct kobject {
   char *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj ) ;
   void *(*namespace)(struct kobject *kobj ) ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[26] ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
typedef int write_proc_t(struct file *file , char *buffer , unsigned long count ,
                         void *data );
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations *proc_iops ;
   struct file_operations *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
struct tty_driver;
struct tty_driver;
struct nsproxy;
struct nsproxy;
struct klist_node;
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct dma_map_ops;
struct dma_map_ops;
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct pdev_archdata {

};
struct device_private;
struct device_private;
struct device_driver;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct subsys_private;
struct subsys_private;
struct bus_type;
struct bus_type;
struct device_node;
struct device_node;
struct iommu_ops;
struct iommu_ops;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char *buf , size_t count ) ;
};
struct device_attribute;
struct device_attribute;
struct driver_attribute;
struct driver_attribute;
struct bus_type {
   char *name ;
   char *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
struct device_type;
struct device_type;
struct of_device_id;
struct of_device_id;
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id *of_match_table ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char *buf , size_t count ) ;
};
struct class_attribute;
struct class_attribute;
struct class {
   char *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct kobj_ns_type_operations *ns_type ;
   void *(*namespace)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , struct class_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct class *class , struct class_attribute *attr , char *buf ,
                    size_t count ) ;
   void *(*namespace)(struct class *class , struct class_attribute *attr ) ;
};
struct device_type {
   char *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct dma_coherent_mem;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char *init_name ;
   struct device_type *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct wakeup_source {
   char *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned int active : 1 ;
};
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct mfd_cell;
struct mfd_cell;
struct platform_device {
   char *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct hotplug_slot;
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pcie_link_state;
struct pcie_link_state;
struct pci_vpd;
struct pci_vpd;
struct pci_sriov;
struct pci_sriov;
struct pci_ats;
struct pci_ats;
struct pci_driver;
struct pci_driver;
union __anonunion____missing_field_name_292 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 pcie_type : 4 ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17] ;
   struct bin_attribute *res_attr_wc[17] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_292 __annonCompField47 ;
   struct pci_ats *ats ;
};
struct pci_ops;
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
union __anonunion____missing_field_name_294 {
   unsigned long index ;
   void *freelist ;
};
struct __anonstruct____missing_field_name_298 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
union __anonunion____missing_field_name_297 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_298 __annonCompField49 ;
};
struct __anonstruct____missing_field_name_296 {
   union __anonunion____missing_field_name_297 __annonCompField50 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_295 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_296 __annonCompField51 ;
};
struct __anonstruct____missing_field_name_293 {
   union __anonunion____missing_field_name_294 __annonCompField48 ;
   union __anonunion____missing_field_name_295 __annonCompField52 ;
};
struct __anonstruct____missing_field_name_300 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
union __anonunion____missing_field_name_299 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_300 __annonCompField54 ;
};
union __anonunion____missing_field_name_301 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct____missing_field_name_293 __annonCompField53 ;
   union __anonunion____missing_field_name_299 __annonCompField55 ;
   union __anonunion____missing_field_name_301 __annonCompField56 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
struct __anonstruct_vm_set_303 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_302 {
   struct __anonstruct_vm_set_303 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct anon_vma;
struct vm_operations_struct;
struct vm_operations_struct;
struct mempolicy;
struct mempolicy;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_302 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct mm_rss_stat {
   atomic_long_t count[3] ;
};
struct linux_binfmt;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
struct user_struct;
struct user_struct;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t *from , nodemask_t *to ,
                  unsigned long flags ) ;
};
struct dma_attrs {
   unsigned long flags[((4UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc)(struct device *dev , size_t size , dma_addr_t *dma_handle , gfp_t gfp ,
                  struct dma_attrs *attrs ) ;
   void (*free)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ,
                struct dma_attrs *attrs ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs *attrs ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int (*set_dma_mask)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct sem_undo_list;
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
typedef unsigned long cputime_t;
struct siginfo;
struct siginfo;
struct __anonstruct_sigset_t_319 {
   unsigned long sig[1] ;
};
typedef struct __anonstruct_sigset_t_319 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_321 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_322 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_323 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_324 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_325 {
   void *_addr ;
   short _addr_lsb ;
};
struct __anonstruct__sigpoll_326 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_320 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_321 _kill ;
   struct __anonstruct__timer_322 _timer ;
   struct __anonstruct__rt_323 _rt ;
   struct __anonstruct__sigchld_324 _sigchld ;
   struct __anonstruct__sigfault_325 _sigfault ;
   struct __anonstruct__sigpoll_326 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_320 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct __anonstruct_seccomp_t_329 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_329 seccomp_t;
struct plist_head {
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct rt_mutex_waiter;
struct rt_mutex_waiter;
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct key;
struct signal_struct;
struct signal_struct;
struct key_type;
struct key_type;
struct keyring_list;
struct keyring_list;
struct key_user;
struct key_user;
union __anonunion____missing_field_name_386 {
   time_t expiry ;
   time_t revoked_at ;
};
union __anonunion_type_data_387 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
   int reject_error ;
};
union __anonunion_payload_388 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_386 __annonCompField59 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_387 type_data ;
   union __anonunion_payload_388 payload ;
};
struct audit_context;
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
struct llist_node;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct futex_pi_state;
struct futex_pi_state;
struct robust_list_head;
struct robust_list_head;
struct bio_list;
struct bio_list;
struct fs_struct;
struct fs_struct;
struct perf_event_context;
struct perf_event_context;
struct blk_plug;
struct blk_plug;
struct cfs_rq;
struct cfs_rq;
struct kioctx;
struct kioctx;
union __anonunion_ki_obj_389 {
   void *user ;
   struct task_struct *tsk ;
};
struct eventfd_ctx;
struct eventfd_ctx;
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_389 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
struct autogroup;
struct autogroup;
struct tty_struct;
struct tty_struct;
struct taskstats;
struct taskstats;
struct tty_audit_buf;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
struct reclaim_state;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct io_context;
struct io_context;
struct rq;
struct rq;
struct sched_class {
   struct sched_class *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*yield_task)(struct rq *rq ) ;
   bool (*yield_to_task)(struct rq *rq , struct task_struct *p , bool preempt ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int flags ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sd_flag , int flags ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_waking)(struct task_struct *task ) ;
   void (*task_woken)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_fork)(struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ) ;
   unsigned int (*get_rr_interval)(struct rq *rq , struct task_struct *task ) ;
   void (*task_move_group)(struct task_struct *p , int on_rq ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
struct rt_rq;
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct css_set;
struct css_set;
struct compat_robust_list_head;
struct compat_robust_list_head;
struct mem_cgroup;
struct mem_cgroup;
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned int irq_thread : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred *real_cred ;
   struct cred *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
struct agp_version {
   u16 major ;
   u16 minor ;
};
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct *vm_ops ;
};
struct agp_bridge_data;
struct agp_bridge_data;
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
typedef unsigned int drm_magic_t;
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60] ;
};
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
enum drm_ctx_flags {
    _DRM_CONTEXT_PRESERVED = 1,
    _DRM_CONTEXT_2DONLY = 2
} ;
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4] ;
   __u32 pitches[4] ;
   __u32 offsets[4] ;
};
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
struct drm_event {
   __u32 type ;
   __u32 length ;
};
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[1 << 6] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[128UL / sizeof(long ) - 1UL] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct drm_file;
struct drm_file;
struct drm_device;
struct drm_device;
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations *op ;
   int poll_event ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
struct drm_mm;
struct drm_mm;
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned int hole_follows : 1 ;
   unsigned int scanned_block : 1 ;
   unsigned int scanned_prev_free : 1 ;
   unsigned int scanned_next_free : 1 ;
   unsigned int scanned_preceeds_hole : 1 ;
   unsigned int allocated : 1 ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned int scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
};
typedef int drm_ioctl_t(struct drm_device *dev , void *data , struct drm_file *file_priv );
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
enum __anonenum_list_409 {
    DRM_LIST_NONE = 0,
    DRM_LIST_FREE = 1,
    DRM_LIST_WAIT = 2,
    DRM_LIST_PEND = 3,
    DRM_LIST_PRIO = 4,
    DRM_LIST_RECLAIM = 5
} ;
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   wait_queue_head_t dma_wait ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   enum __anonenum_list_409 list ;
   int dev_priv_size ;
   void *dev_private ;
};
struct drm_waitlist {
   int count ;
   struct drm_buf **bufs ;
   struct drm_buf **rp ;
   struct drm_buf **wp ;
   struct drm_buf **end ;
   spinlock_t read_lock ;
   spinlock_t write_lock ;
};
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event *event ) ;
};
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
struct drm_minor;
struct drm_minor;
struct drm_master;
struct drm_master;
struct drm_file {
   int authenticated ;
   pid_t pid ;
   uid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
struct drm_queue {
   atomic_t use_count ;
   atomic_t finalization ;
   atomic_t block_count ;
   atomic_t block_read ;
   wait_queue_head_t read_queue ;
   atomic_t block_write ;
   wait_queue_head_t write_queue ;
   atomic_t total_queued ;
   atomic_t total_flushed ;
   atomic_t total_locks ;
   enum drm_ctx_flags flags ;
   struct drm_waitlist waitlist ;
   wait_queue_head_t flush_queue ;
};
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
enum __anonenum_flags_410 {
    _DRM_DMA_USE_AGP = 1,
    _DRM_DMA_USE_SG = 2,
    _DRM_DMA_USE_FB = 4,
    _DRM_DMA_USE_PCI_RO = 8
} ;
struct drm_device_dma {
   struct drm_buf_entry bufs[23] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   enum __anonenum_flags_410 flags ;
};
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
struct dma_buf;
struct dma_buf;
struct dma_buf_attachment;
struct dma_buf_attachment;
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
struct device_node {
   char *name ;
   char *type ;
   phandle phandle ;
   char *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5] ;
   __u16 x_sflag ;
};
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver *driver , struct inode *inode ,
                                int idx ) ;
   int (*install)(struct tty_driver *driver , struct tty_struct *tty ) ;
   void (*remove)(struct tty_driver *driver , struct tty_struct *tty ) ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   void (*shutdown)(struct tty_struct *tty ) ;
   void (*cleanup)(struct tty_struct *tty ) ;
   int (*write)(struct tty_struct *tty , unsigned char *buf , int count ) ;
   int (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   int (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*tiocmget)(struct tty_struct *tty ) ;
   int (*tiocmset)(struct tty_struct *tty , unsigned int set , unsigned int clear ) ;
   int (*resize)(struct tty_struct *tty , struct winsize *ws ) ;
   int (*set_termiox)(struct tty_struct *tty , struct termiox *tnew ) ;
   int (*get_icount)(struct tty_struct *tty , struct serial_icounter_struct *icount ) ;
   int (*poll_init)(struct tty_driver *driver , int line , char *options ) ;
   int (*poll_get_char)(struct tty_driver *driver , int line ) ;
   void (*poll_put_char)(struct tty_driver *driver , int line , char ch ) ;
   struct file_operations *proc_fops ;
};
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev cdev ;
   struct module *owner ;
   char *driver_name ;
   char *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations *ops ;
   struct list_head tty_drivers ;
};
struct pps_event_time {
   struct timespec ts_real ;
};
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct *tty ) ;
   ssize_t (*read)(struct tty_struct *tty , struct file *file , unsigned char *buf ,
                   size_t nr ) ;
   ssize_t (*write)(struct tty_struct *tty , struct file *file , unsigned char *buf ,
                    size_t nr ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                        unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct *tty ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char *cp , char *fp , int count ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
};
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0] ;
};
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
struct tty_port;
struct tty_port;
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port *port ) ;
   void (*dtr_rts)(struct tty_port *port , int raise ) ;
   void (*shutdown)(struct tty_port *port ) ;
   void (*drop)(struct tty_port *port ) ;
   int (*activate)(struct tty_port *port , struct tty_struct *tty ) ;
   void (*destruct)(struct tty_port *port ) ;
};
struct tty_port {
   struct tty_struct *tty ;
   struct tty_port_operations *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   struct termiox *termiox ;
   char name[64] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned char echo_overrun : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[256UL / (8UL * sizeof(unsigned long ))] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[4096UL / (8UL * sizeof(unsigned long ))] ;
   unsigned char *echo_buf ;
   unsigned int echo_pos ;
   unsigned int echo_cnt ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   struct mutex output_lock ;
   struct mutex echo_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
struct drm_mode_set;
struct drm_mode_set;
struct drm_framebuffer;
struct drm_framebuffer;
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
};
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int crtc_hadjusted ;
   int crtc_vadjusted ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
struct drm_display_info {
   char name[32] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
   char *raw_edid ;
};
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer *framebuffer ) ;
   int (*create_handle)(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                        unsigned int *handle ) ;
   int (*dirty)(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                unsigned int num_clips ) ;
};
struct drm_framebuffer {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs *funcs ;
   unsigned int pitches[4] ;
   unsigned int offsets[4] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
struct drm_crtc;
struct drm_crtc;
struct drm_connector;
struct drm_connector;
struct drm_encoder;
struct drm_encoder;
struct drm_pending_vblank_event;
struct drm_pending_vblank_event;
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc *crtc ) ;
   void (*restore)(struct drm_crtc *crtc ) ;
   void (*reset)(struct drm_crtc *crtc ) ;
   int (*cursor_set)(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                     uint32_t width , uint32_t height ) ;
   int (*cursor_move)(struct drm_crtc *crtc , int x , int y ) ;
   void (*gamma_set)(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                     uint32_t size ) ;
   void (*destroy)(struct drm_crtc *crtc ) ;
   int (*set_config)(struct drm_mode_set *set ) ;
   int (*page_flip)(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
};
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   int x ;
   int y ;
   struct drm_crtc_funcs *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
};
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector *connector , int mode ) ;
   void (*save)(struct drm_connector *connector ) ;
   void (*restore)(struct drm_connector *connector ) ;
   void (*reset)(struct drm_connector *connector ) ;
   enum drm_connector_status (*detect)(struct drm_connector *connector , bool force ) ;
   int (*fill_modes)(struct drm_connector *connector , uint32_t max_width , uint32_t max_height ) ;
   int (*set_property)(struct drm_connector *connector , struct drm_property *property ,
                       uint64_t val ) ;
   void (*destroy)(struct drm_connector *connector ) ;
   void (*force)(struct drm_connector *connector ) ;
};
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder *encoder ) ;
   void (*destroy)(struct drm_encoder *encoder ) ;
};
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs *funcs ;
   void *helper_private ;
};
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   u32 property_ids[16] ;
   uint64_t property_values[16] ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2] ;
   int video_latency[2] ;
   int audio_latency[2] ;
   int null_edid_counter ;
};
struct drm_mode_set {
   struct list_head head ;
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device *dev , struct drm_file *file_priv ,
                                        struct drm_mode_fb_cmd2 *mode_cmd ) ;
   void (*output_poll_changed)(struct drm_device *dev ) ;
};
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device *dev ) ;
   char *(*get_name)(struct drm_device *dev ) ;
   int (*set_busid)(struct drm_device *dev , struct drm_master *master ) ;
   int (*set_unique)(struct drm_device *dev , struct drm_master *master , struct drm_unique *unique ) ;
   int (*irq_by_busid)(struct drm_device *dev , struct drm_irq_busid *p ) ;
   int (*agp_init)(struct drm_device *dev ) ;
};
struct usb_driver;
struct usb_driver;
union __anonunion_kdriver_413 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long flags ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file *file_priv ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t state ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device *dev , int context ) ;
   u32 (*get_vblank_counter)(struct drm_device *dev , int crtc ) ;
   int (*enable_vblank)(struct drm_device *dev , int crtc ) ;
   void (*disable_vblank)(struct drm_device *dev , int crtc ) ;
   int (*device_is_agp)(struct drm_device *dev ) ;
   int (*get_scanout_position)(struct drm_device *dev , int crtc , int *vpos , int *hpos ) ;
   int (*get_vblank_timestamp)(struct drm_device *dev , int crtc , int *max_error ,
                               struct timeval *vblank_time , unsigned int flags ) ;
   irqreturn_t (*irq_handler)(int irq , void *arg ) ;
   void (*irq_preinstall)(struct drm_device *dev ) ;
   int (*irq_postinstall)(struct drm_device *dev ) ;
   void (*irq_uninstall)(struct drm_device *dev ) ;
   void (*reclaim_buffers)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*reclaim_buffers_locked)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*reclaim_buffers_idlelocked)(struct drm_device *dev , struct drm_file *file_priv ) ;
   void (*set_version)(struct drm_device *dev , struct drm_set_version *sv ) ;
   int (*master_create)(struct drm_device *dev , struct drm_master *master ) ;
   void (*master_destroy)(struct drm_device *dev , struct drm_master *master ) ;
   int (*master_set)(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) ;
   void (*master_drop)(struct drm_device *dev , struct drm_file *file_priv , bool from_release ) ;
   int (*debugfs_init)(struct drm_minor *minor ) ;
   void (*debugfs_cleanup)(struct drm_minor *minor ) ;
   int (*gem_init_object)(struct drm_gem_object *obj ) ;
   void (*gem_free_object)(struct drm_gem_object *obj ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device *dev , struct drm_file *file_priv ,
                             uint32_t handle , uint32_t flags , int *prime_fd ) ;
   int (*prime_fd_to_handle)(struct drm_device *dev , struct drm_file *file_priv ,
                             int prime_fd , uint32_t *handle ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device *dev , struct drm_gem_object *obj ,
                                       int flags ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device *dev , struct dma_buf *dma_buf ) ;
   void (*vgaarb_irq)(struct drm_device *dev , bool state ) ;
   int (*dumb_create)(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
   int (*dumb_map_offset)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                          uint64_t *offset ) ;
   int (*dumb_destroy)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) ;
   struct vm_operations_struct *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations *fops ;
   union __anonunion_kdriver_413 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
struct drm_info_list {
   char *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
struct usb_device;
struct usb_device;
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15] ;
   atomic_t counts[15] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   int queue_count ;
   int queue_reserved ;
   int queue_slots ;
   struct drm_queue **queuelist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
enum drm_global_types {
    DRM_GLOBAL_TTM_MEM = 0,
    DRM_GLOBAL_TTM_BO = 1,
    DRM_GLOBAL_TTM_OBJECT = 2,
    DRM_GLOBAL_NUM = 3
} ;
struct drm_global_reference {
   enum drm_global_types global_type ;
   size_t size ;
   void *object ;
   int (*init)(struct drm_global_reference * ) ;
   void (*release)(struct drm_global_reference * ) ;
};
struct drm_vmw_size {
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
   uint32_t pad64 ;
};
struct drm_vmw_execbuf_arg {
   uint64_t commands ;
   uint32_t command_size ;
   uint32_t throttle_us ;
   uint64_t fence_rep ;
   uint32_t version ;
   uint32_t flags ;
};
struct drm_vmw_fence_rep {
   uint32_t handle ;
   uint32_t mask ;
   uint32_t seqno ;
   uint32_t passed_seqno ;
   uint32_t pad64 ;
   int32_t error ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count  __attribute__((__aligned__(8))) ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32] ;
   __u8 ac_sched  __attribute__((__aligned__(8))) ;
   __u8 ac_pad[3] ;
   __u32 ac_uid  __attribute__((__aligned__(8))) ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime  __attribute__((__aligned__(8))) ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct cgroupfs_root;
struct cgroupfs_root;
struct cgroup;
struct cgroup;
struct css_id;
struct css_id;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
};
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   struct list_head sibling ;
   struct list_head children ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[8UL * sizeof(unsigned long )] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct rcu_head rcu_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[8UL * sizeof(unsigned long )] ;
   struct rcu_head rcu_head ;
};
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
struct ttm_bo_device;
struct ttm_bo_device;
struct ttm_placement {
   unsigned int fpfn ;
   unsigned int lpfn ;
   unsigned int num_placement ;
   uint32_t *placement ;
   unsigned int num_busy_placement ;
   uint32_t *busy_placement ;
};
struct ttm_bus_placement {
   void *addr ;
   unsigned long base ;
   unsigned long size ;
   unsigned long offset ;
   bool is_iomem ;
   bool io_reserved_vm ;
   uint64_t io_reserved_count ;
};
struct ttm_mem_reg {
   void *mm_node ;
   unsigned long start ;
   unsigned long size ;
   unsigned long num_pages ;
   uint32_t page_alignment ;
   uint32_t mem_type ;
   uint32_t placement ;
   struct ttm_bus_placement bus ;
};
enum ttm_bo_type {
    ttm_bo_type_device = 0,
    ttm_bo_type_kernel = 1
} ;
struct ttm_tt;
struct ttm_tt;
struct ttm_bo_global;
struct ttm_bo_global;
struct ttm_buffer_object {
   struct ttm_bo_global *glob ;
   struct ttm_bo_device *bdev ;
   unsigned long buffer_start ;
   enum ttm_bo_type type ;
   void (*destroy)(struct ttm_buffer_object * ) ;
   unsigned long num_pages ;
   uint64_t addr_space_offset ;
   size_t acc_size ;
   struct kref kref ;
   struct kref list_kref ;
   wait_queue_head_t event_queue ;
   struct ttm_mem_reg mem ;
   struct file *persistent_swap_storage ;
   struct ttm_tt *ttm ;
   bool evicted ;
   atomic_t cpu_writers ;
   struct list_head lru ;
   struct list_head ddestroy ;
   struct list_head swap ;
   struct list_head io_reserve_lru ;
   uint32_t val_seq ;
   bool seq_valid ;
   atomic_t reserved ;
   void *sync_obj_arg ;
   void *sync_obj ;
   unsigned long priv_flags ;
   struct rb_node vm_rb ;
   struct drm_mm_node *vm_node ;
   unsigned long offset ;
   uint32_t cur_placement ;
};
struct ttm_mem_shrink {
   int (*do_shrink)(struct ttm_mem_shrink * ) ;
};
struct ttm_mem_zone;
struct ttm_mem_zone;
struct ttm_mem_global {
   struct kobject kobj ;
   struct ttm_mem_shrink *shrink ;
   struct workqueue_struct *swap_queue ;
   struct work_struct work ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   struct ttm_mem_zone *zones[2] ;
   unsigned int num_zones ;
   struct ttm_mem_zone *zone_kernel ;
   struct ttm_mem_zone *zone_dma32 ;
};
struct ttm_backend;
struct ttm_backend;
struct ttm_backend_func {
   int (*bind)(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) ;
   int (*unbind)(struct ttm_tt *ttm ) ;
   void (*destroy)(struct ttm_tt *ttm ) ;
};
enum ttm_caching_state {
    tt_uncached = 0,
    tt_wc = 1,
    tt_cached = 2
} ;
enum __anonenum_state_428 {
    tt_bound = 0,
    tt_unbound = 1,
    tt_unpopulated = 2
} ;
struct ttm_tt {
   struct ttm_bo_device *bdev ;
   struct ttm_backend_func *func ;
   struct page *dummy_read_page ;
   struct page **pages ;
   uint32_t page_flags ;
   unsigned long num_pages ;
   struct ttm_bo_global *glob ;
   struct ttm_backend *be ;
   struct file *swap_storage ;
   enum ttm_caching_state caching_state ;
   enum __anonenum_state_428 state ;
};
struct ttm_mem_type_manager;
struct ttm_mem_type_manager;
struct ttm_mem_type_manager_func {
   int (*init)(struct ttm_mem_type_manager *man , unsigned long p_size ) ;
   int (*takedown)(struct ttm_mem_type_manager *man ) ;
   int (*get_node)(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                   struct ttm_placement *placement , struct ttm_mem_reg *mem ) ;
   void (*put_node)(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) ;
   void (*debug)(struct ttm_mem_type_manager *man , char *prefix ) ;
};
struct ttm_mem_type_manager {
   struct ttm_bo_device *bdev ;
   bool has_type ;
   bool use_type ;
   uint32_t flags ;
   unsigned long gpu_offset ;
   uint64_t size ;
   uint32_t available_caching ;
   uint32_t default_caching ;
   struct ttm_mem_type_manager_func *func ;
   void *priv ;
   struct mutex io_reserve_mutex ;
   bool use_io_reserve_lru ;
   bool io_reserve_fastpath ;
   struct list_head io_reserve_lru ;
   struct list_head lru ;
};
struct ttm_bo_driver {
   struct ttm_tt *(*ttm_tt_create)(struct ttm_bo_device *bdev , unsigned long size ,
                                   uint32_t page_flags , struct page *dummy_read_page ) ;
   int (*ttm_tt_populate)(struct ttm_tt *ttm ) ;
   void (*ttm_tt_unpopulate)(struct ttm_tt *ttm ) ;
   int (*invalidate_caches)(struct ttm_bo_device *bdev , uint32_t flags ) ;
   int (*init_mem_type)(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) ;
   void (*evict_flags)(struct ttm_buffer_object *bo , struct ttm_placement *placement ) ;
   int (*move)(struct ttm_buffer_object *bo , bool evict , bool interruptible , bool no_wait_reserve ,
               bool no_wait_gpu , struct ttm_mem_reg *new_mem ) ;
   int (*verify_access)(struct ttm_buffer_object *bo , struct file *filp ) ;
   bool (*sync_obj_signaled)(void *sync_obj , void *sync_arg ) ;
   int (*sync_obj_wait)(void *sync_obj , void *sync_arg , bool lazy , bool interruptible ) ;
   int (*sync_obj_flush)(void *sync_obj , void *sync_arg ) ;
   void (*sync_obj_unref)(void **sync_obj ) ;
   void *(*sync_obj_ref)(void *sync_obj ) ;
   void (*move_notify)(struct ttm_buffer_object *bo , struct ttm_mem_reg *new_mem ) ;
   int (*fault_reserve_notify)(struct ttm_buffer_object *bo ) ;
   void (*swap_notify)(struct ttm_buffer_object *bo ) ;
   int (*io_mem_reserve)(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) ;
   void (*io_mem_free)(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) ;
};
struct ttm_bo_global_ref {
   struct drm_global_reference ref ;
   struct ttm_mem_global *mem_glob ;
};
struct ttm_bo_global {
   struct kobject kobj ;
   struct ttm_mem_global *mem_glob ;
   struct page *dummy_read_page ;
   struct ttm_mem_shrink shrink ;
   struct mutex device_list_mutex ;
   spinlock_t lru_lock ;
   struct list_head device_list ;
   struct list_head swap_lru ;
   atomic_t bo_count ;
};
struct ttm_bo_device {
   struct list_head device_list ;
   struct ttm_bo_global *glob ;
   struct ttm_bo_driver *driver ;
   rwlock_t vm_lock ;
   struct ttm_mem_type_manager man[8] ;
   spinlock_t fence_lock ;
   struct rb_root addr_space_rb ;
   struct drm_mm addr_space_mm ;
   struct list_head ddestroy ;
   uint32_t val_seq ;
   bool nice_mode ;
   struct address_space *dev_mapping ;
   struct delayed_work wq ;
   bool need_dma32 ;
};
enum ttm_ref_type {
    TTM_REF_USAGE = 0,
    TTM_REF_SYNCCPU_READ = 1,
    TTM_REF_SYNCCPU_WRITE = 2,
    TTM_REF_NUM = 3
} ;
enum ttm_object_type {
    ttm_fence_type = 0,
    ttm_buffer_type = 1,
    ttm_lock_type = 2,
    ttm_driver_type0 = 256,
    ttm_driver_type1 = 257,
    ttm_driver_type2 = 258,
    ttm_driver_type3 = 259,
    ttm_driver_type4 = 260,
    ttm_driver_type5 = 261
} ;
struct ttm_object_file;
struct ttm_object_file;
struct ttm_object_device;
struct ttm_object_device;
struct ttm_base_object {
   struct drm_hash_item hash ;
   enum ttm_object_type object_type ;
   bool shareable ;
   struct ttm_object_file *tfile ;
   struct kref refcount ;
   void (*refcount_release)(struct ttm_base_object **base ) ;
   void (*ref_obj_release)(struct ttm_base_object *base , enum ttm_ref_type ref_type ) ;
};
struct ttm_lock {
   struct ttm_base_object base ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   int32_t rw ;
   uint32_t flags ;
   bool kill_takers ;
   int signal ;
   struct ttm_object_file *vt_holder ;
};
struct ttm_validate_buffer {
   struct list_head head ;
   struct ttm_buffer_object *bo ;
   void *new_sync_obj_arg ;
   bool reserved ;
   bool removed ;
   int put_count ;
   void *old_sync_obj ;
};
struct vmw_private;
struct vmw_private;
struct vmw_fence_manager;
struct vmw_fence_manager;
struct vmw_fence_obj {
   struct kref kref ;
   u32 seqno ;
   struct vmw_fence_manager *fman ;
   struct list_head head ;
   uint32_t signaled ;
   uint32_t signal_mask ;
   struct list_head seq_passed_actions ;
   void (*destroy)(struct vmw_fence_obj *fence ) ;
   wait_queue_head_t queue ;
};
struct vmw_fpriv {
   struct drm_master *locked_master ;
   struct ttm_object_file *tfile ;
   struct list_head fence_events ;
};
struct vmw_dma_buffer {
   struct ttm_buffer_object base ;
   struct list_head validate_list ;
   bool gmr_bound ;
   uint32_t cur_validate_node ;
   bool on_validate_list ;
};
struct vmw_resource {
   struct kref kref ;
   struct vmw_private *dev_priv ;
   struct idr *idr ;
   int id ;
   enum ttm_object_type res_type ;
   bool avail ;
   void (*remove_from_lists)(struct vmw_resource *res ) ;
   void (*hw_destroy)(struct vmw_resource *res ) ;
   void (*res_free)(struct vmw_resource *res ) ;
   struct list_head validate_head ;
   struct list_head query_head ;
};
struct vmw_cursor_snooper {
   struct drm_crtc *crtc ;
   size_t age ;
   uint32_t *image ;
};
struct vmw_surface_offset;
struct vmw_surface_offset;
struct vmw_surface {
   struct vmw_resource res ;
   struct list_head lru_head ;
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6] ;
   struct drm_vmw_size *sizes ;
   uint32_t num_sizes ;
   bool scanout ;
   struct vmw_cursor_snooper snooper ;
   struct ttm_buffer_object *backup ;
   struct vmw_surface_offset *offsets ;
   uint32_t backup_size ;
};
struct vmw_marker_queue {
   struct list_head head ;
   struct timespec lag ;
   struct timespec lag_time ;
   spinlock_t lock ;
};
struct vmw_fifo_state {
   unsigned long reserved_size ;
   __le32 *dynamic_buffer ;
   __le32 *static_buffer ;
   unsigned long static_buffer_size ;
   bool using_bounce_buffer ;
   uint32_t capabilities ;
   struct mutex fifo_mutex ;
   struct rw_semaphore rwsem ;
   struct vmw_marker_queue marker_queue ;
};
struct vmw_relocation {
   SVGAGuestPtr *location ;
   uint32_t index ;
};
struct vmw_sw_context {
   struct ida bo_list ;
   uint32_t last_cid ;
   bool cid_valid ;
   bool kernel ;
   struct vmw_resource *cur_ctx ;
   uint32_t last_sid ;
   uint32_t sid_translation ;
   bool sid_valid ;
   struct ttm_object_file *tfile ;
   struct list_head validate_nodes ;
   struct vmw_relocation relocs[2048] ;
   uint32_t cur_reloc ;
   struct ttm_validate_buffer val_bufs[2048] ;
   uint32_t cur_val_buf ;
   uint32_t *cmd_bounce ;
   uint32_t cmd_bounce_size ;
   struct list_head resource_list ;
   uint32_t fence_flags ;
   struct list_head query_list ;
   struct ttm_buffer_object *cur_query_bo ;
   uint32_t cur_query_cid ;
   bool query_cid_valid ;
};
struct vmw_legacy_display;
struct vmw_legacy_display;
struct vmw_overlay;
struct vmw_overlay;
struct vmw_master {
   struct ttm_lock lock ;
   struct mutex fb_surf_mutex ;
   struct list_head fb_surf ;
};
struct vmw_vga_topology_state {
   uint32_t width ;
   uint32_t height ;
   uint32_t primary ;
   uint32_t pos_x ;
   uint32_t pos_y ;
};
struct vmw_screen_object_display;
struct vmw_screen_object_display;
struct vmw_private {
   struct ttm_bo_device bdev ;
   struct ttm_bo_global_ref bo_global_ref ;
   struct drm_global_reference mem_global_ref ;
   struct vmw_fifo_state fifo ;
   struct drm_device *dev ;
   unsigned long vmw_chipset ;
   unsigned int io_start ;
   uint32_t vram_start ;
   uint32_t vram_size ;
   uint32_t mmio_start ;
   uint32_t mmio_size ;
   uint32_t fb_max_width ;
   uint32_t fb_max_height ;
   uint32_t initial_width ;
   uint32_t initial_height ;
   __le32 *mmio_virt ;
   int mmio_mtrr ;
   uint32_t capabilities ;
   uint32_t max_gmr_descriptors ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t memory_size ;
   bool has_gmr ;
   struct mutex hw_mutex ;
   struct vmw_vga_topology_state vga_save[16] ;
   uint32_t vga_width ;
   uint32_t vga_height ;
   uint32_t vga_bpp ;
   uint32_t vga_bpl ;
   uint32_t vga_pitchlock ;
   uint32_t num_displays ;
   void *fb_info ;
   struct vmw_legacy_display *ldu_priv ;
   struct vmw_screen_object_display *sou_priv ;
   struct vmw_overlay *overlay_priv ;
   rwlock_t resource_lock ;
   struct idr context_idr ;
   struct idr surface_idr ;
   struct idr stream_idr ;
   struct mutex init_mutex ;
   struct ttm_object_device *tdev ;
   atomic_t marker_seq ;
   wait_queue_head_t fence_queue ;
   wait_queue_head_t fifo_queue ;
   int fence_queue_waiters ;
   int goal_queue_waiters ;
   atomic_t fifo_queue_waiters ;
   uint32_t last_read_seqno ;
   spinlock_t irq_lock ;
   struct vmw_fence_manager *fman ;
   uint32_t irq_mask ;
   uint32_t traces_state ;
   uint32_t enable_state ;
   uint32_t config_done_state ;
   struct vmw_sw_context ctx ;
   struct mutex cmdbuf_mutex ;
   bool stealth ;
   bool is_opened ;
   bool enable_fb ;
   struct vmw_master *active_master ;
   struct vmw_master fbdev_master ;
   struct notifier_block pm_nb ;
   bool suspended ;
   struct mutex release_mutex ;
   uint32_t num_3d_resources ;
   struct ttm_buffer_object *dummy_query_bo ;
   struct ttm_buffer_object *pinned_bo ;
   uint32_t query_cid ;
   bool dummy_query_bo_pinned ;
   struct list_head surface_lru ;
   uint32_t used_memory_size ;
};
struct vmw_cid_cmd {
   SVGA3dCmdHeader header ;
   __le32 cid ;
};
struct vmw_sid_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetRenderTarget body ;
};
struct vmw_sid_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceCopy body ;
};
struct vmw_sid_cmd___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceStretchBlt body ;
};
struct vmw_sid_cmd___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
struct vmw_sid_cmd___3 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdPresent body ;
};
struct vmw_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdEndQuery q ;
};
struct vmw_query_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery q ;
};
struct vmw_dma_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA dma ;
};
struct vmw_draw_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDrawPrimitives body ;
};
struct __anonstruct_cmd_429 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
typedef int (*vmw_cmd_func)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * );
struct svga_guest_mem_descriptor {
   __le32 ppn ;
   __le32 num_pages ;
};
struct __anonstruct_SVGAFifoCmdDefineGMR2_27 {
   uint32 gmrId ;
   uint32 numPages ;
};
typedef struct __anonstruct_SVGAFifoCmdDefineGMR2_27 SVGAFifoCmdDefineGMR2;
enum __anonenum_SVGARemapGMR2Flags_28 {
    SVGA_REMAP_GMR2_PPN32 = 0,
    SVGA_REMAP_GMR2_VIA_GMR = 1,
    SVGA_REMAP_GMR2_PPN64 = 2,
    SVGA_REMAP_GMR2_SINGLE_PPN = 4
} ;
typedef enum __anonenum_SVGARemapGMR2Flags_28 SVGARemapGMR2Flags;
struct __anonstruct_SVGAFifoCmdRemapGMR2_29 {
   uint32 gmrId ;
   SVGARemapGMR2Flags flags ;
   uint32 offsetPages ;
   uint32 numPages ;
};
typedef struct __anonstruct_SVGAFifoCmdRemapGMR2_29 SVGAFifoCmdRemapGMR2;
struct compat_timespec;
struct compat_timespec;
struct __anonstruct_futex_144 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_145 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct pollfd;
struct __anonstruct_poll_146 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion____missing_field_name_143 {
   struct __anonstruct_futex_144 futex ;
   struct __anonstruct_nanosleep_145 nanosleep ;
   struct __anonstruct_poll_146 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_143 __annonCompField18 ;
};
struct exec_domain;
struct exec_domain;
struct map_segment;
struct map_segment;
struct exec_domain {
   char *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
struct __anonstruct_mm_segment_t_168 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_168 mm_segment_t;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned int sig_on_uaccess_error : 1 ;
   unsigned int uaccess_err : 1 ;
};
enum hrtimer_restart;
enum kobj_ns_type;
typedef s32 compat_time_t;
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
struct SVGAFifoCmdDefineAlphaCursor {
   uint32 id ;
   uint32 hotspotX ;
   uint32 hotspotY ;
   uint32 width ;
   uint32 height ;
};
typedef struct SVGAFifoCmdDefineAlphaCursor SVGAFifoCmdDefineAlphaCursor;
struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_296 {
   SVGASignedPoint destOrigin ;
   SVGASignedRect srcRect ;
   uint32 srcScreenId ;
};
typedef struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_296 SVGAFifoCmdBlitScreenToGMRFB;
enum SVGA3dSurfaceFormat {
    SVGA3D_FORMAT_INVALID = 0,
    SVGA3D_X8R8G8B8 = 1,
    SVGA3D_A8R8G8B8 = 2,
    SVGA3D_R5G6B5 = 3,
    SVGA3D_X1R5G5B5 = 4,
    SVGA3D_A1R5G5B5 = 5,
    SVGA3D_A4R4G4B4 = 6,
    SVGA3D_Z_D32 = 7,
    SVGA3D_Z_D16 = 8,
    SVGA3D_Z_D24S8 = 9,
    SVGA3D_Z_D15S1 = 10,
    SVGA3D_LUMINANCE8 = 11,
    SVGA3D_LUMINANCE4_ALPHA4 = 12,
    SVGA3D_LUMINANCE16 = 13,
    SVGA3D_LUMINANCE8_ALPHA8 = 14,
    SVGA3D_DXT1 = 15,
    SVGA3D_DXT2 = 16,
    SVGA3D_DXT3 = 17,
    SVGA3D_DXT4 = 18,
    SVGA3D_DXT5 = 19,
    SVGA3D_BUMPU8V8 = 20,
    SVGA3D_BUMPL6V5U5 = 21,
    SVGA3D_BUMPX8L8V8U8 = 22,
    SVGA3D_BUMPL8V8U8 = 23,
    SVGA3D_ARGB_S10E5 = 24,
    SVGA3D_ARGB_S23E8 = 25,
    SVGA3D_A2R10G10B10 = 26,
    SVGA3D_V8U8 = 27,
    SVGA3D_Q8W8V8U8 = 28,
    SVGA3D_CxV8U8 = 29,
    SVGA3D_X8L8V8U8 = 30,
    SVGA3D_A2W10V10U10 = 31,
    SVGA3D_ALPHA8 = 32,
    SVGA3D_R_S10E5 = 33,
    SVGA3D_R_S23E8 = 34,
    SVGA3D_RG_S10E5 = 35,
    SVGA3D_RG_S23E8 = 36,
    SVGA3D_BUFFER = 37,
    SVGA3D_Z_D24X8 = 38,
    SVGA3D_V16U16 = 39,
    SVGA3D_G16R16 = 40,
    SVGA3D_A16B16G16R16 = 41,
    SVGA3D_UYVY = 42,
    SVGA3D_YUY2 = 43,
    SVGA3D_NV12 = 44,
    SVGA3D_AYUV = 45,
    SVGA3D_BC4_UNORM = 108,
    SVGA3D_BC5_UNORM = 111,
    SVGA3D_Z_DF16 = 118,
    SVGA3D_Z_DF24 = 119,
    SVGA3D_Z_D24S8_INT = 120,
    SVGA3D_FORMAT_MAX = 121
} ;
struct SVGA3dCopyBox {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
   uint32 srcx ;
   uint32 srcy ;
   uint32 srcz ;
};
typedef struct SVGA3dCopyBox SVGA3dCopyBox;
struct drm_vmw_rect {
   int32_t x ;
   int32_t y ;
   uint32_t w ;
   uint32_t h ;
};
struct drm_vmw_cursor_bypass_arg {
   uint32_t flags ;
   uint32_t crtc_id ;
   int32_t xpos ;
   int32_t ypos ;
   int32_t xhot ;
   int32_t yhot ;
};
struct drm_vmw_update_layout_arg {
   uint32_t num_outputs ;
   uint32_t pad64 ;
   uint64_t rects ;
};
enum __anonenum_bo_kmap_type_427 {
    ttm_bo_map_iomap = 129,
    ttm_bo_map_vmap = 2,
    ttm_bo_map_kmap = 3,
    ttm_bo_map_premapped = 132
} ;
struct ttm_bo_kmap_obj {
   void *virtual ;
   struct page *page ;
   enum __anonenum_bo_kmap_type_427 bo_kmap_type ;
   struct ttm_buffer_object *bo ;
};
struct vmw_framebuffer;
struct vmw_framebuffer;
struct vmw_framebuffer {
   struct drm_framebuffer base ;
   int (*pin)(struct vmw_framebuffer *fb ) ;
   int (*unpin)(struct vmw_framebuffer *fb ) ;
   bool dmabuf ;
   struct ttm_base_object *user_obj ;
   uint32_t user_handle ;
};
struct vmw_display_unit {
   struct drm_crtc crtc ;
   struct drm_encoder encoder ;
   struct drm_connector connector ;
   struct vmw_surface *cursor_surface ;
   struct vmw_dma_buffer *cursor_dmabuf ;
   size_t cursor_age ;
   int cursor_x ;
   int cursor_y ;
   int hotspot_x ;
   int hotspot_y ;
   unsigned int unit ;
   unsigned int pref_width ;
   unsigned int pref_height ;
   bool pref_active ;
   struct drm_display_mode *pref_mode ;
   int gui_x ;
   int gui_y ;
   bool is_implicit ;
};
struct vmw_clip_rect {
   int x1 ;
   int x2 ;
   int y1 ;
   int y2 ;
};
struct __anonstruct_cmd_429___0 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
struct vmw_framebuffer_surface {
   struct vmw_framebuffer base ;
   struct vmw_surface *surface ;
   struct vmw_dma_buffer *buffer ;
   struct list_head head ;
   struct drm_master *master ;
};
struct __anonstruct_cmd_430 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
struct vmw_framebuffer_dmabuf {
   struct vmw_framebuffer base ;
   struct vmw_dma_buffer *buffer ;
};
struct __anonstruct_cmd_431 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
struct __anonstruct_cmd_432 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
struct __anonstruct_blits_433 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
struct __anonstruct_cmd_434 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
struct __anonstruct_cmd_435 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
struct __anonstruct_blits_436 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
typedef short s16;
typedef void (*ctor_fn_t)(void);
struct static_key;
struct static_key;
enum hrtimer_restart;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
enum kobj_ns_type;
struct kernel_param;
struct kernel_param;
struct kernel_param_ops {
   int (*set)(char *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   void (*free)(void *arg ) ;
};
struct kparam_string;
struct kparam_string;
struct kparam_array;
struct kparam_array;
union __anonunion____missing_field_name_199 {
   void *arg ;
   struct kparam_string *str ;
   struct kparam_array *arr ;
};
struct kernel_param {
   char *name ;
   struct kernel_param_ops *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion____missing_field_name_199 __annonCompField32 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops *ops ;
   void *elem ;
};
struct static_key {
   atomic_t enabled ;
};
struct tracepoint;
struct tracepoint;
struct tracepoint_func {
   void *func ;
   void *data ;
};
struct tracepoint {
   char *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
struct kernel_symbol {
   unsigned long value ;
   char *name ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char * ,
                    size_t count ) ;
   void (*setup)(struct module * , char * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
struct module_sect_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module_notes_attrs;
struct ftrace_event_call;
struct ftrace_event_call;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char *version ;
   char *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol *syms ;
   unsigned long *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol *gpl_syms ;
   unsigned long *gpl_crcs ;
   struct kernel_symbol *unused_syms ;
   unsigned long *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol *unused_gpl_syms ;
   unsigned long *unused_gpl_crcs ;
   struct kernel_symbol *gpl_future_syms ;
   unsigned long *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint **tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
};
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
enum __anonenum_SVGA3dQueryState_359 {
    SVGA3D_QUERYSTATE_PENDING = 0,
    SVGA3D_QUERYSTATE_SUCCEEDED = 1,
    SVGA3D_QUERYSTATE_FAILED = 2,
    SVGA3D_QUERYSTATE_NEW = 3
} ;
typedef enum __anonenum_SVGA3dQueryState_359 SVGA3dQueryState;
union __anonunion____missing_field_name_415 {
   uint32 result32 ;
};
struct __anonstruct_SVGA3dQueryResult_414 {
   uint32 totalSize ;
   SVGA3dQueryState state ;
   union __anonunion____missing_field_name_415 __annonCompField61 ;
};
typedef struct __anonstruct_SVGA3dQueryResult_414 SVGA3dQueryResult;
struct drm_vmw_getparam_arg {
   uint64_t value ;
   uint32_t param ;
   uint32_t pad64 ;
};
struct drm_vmw_context_arg {
   int32_t cid ;
   uint32_t pad64 ;
};
struct drm_vmw_surface_create_req {
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6] ;
   uint64_t size_addr ;
   int32_t shareable ;
   int32_t scanout ;
};
struct drm_vmw_surface_arg {
   int32_t sid ;
   uint32_t pad64 ;
};
union drm_vmw_surface_create_arg {
   struct drm_vmw_surface_arg rep ;
   struct drm_vmw_surface_create_req req ;
};
union drm_vmw_surface_reference_arg {
   struct drm_vmw_surface_create_req rep ;
   struct drm_vmw_surface_arg req ;
};
struct drm_vmw_alloc_dmabuf_req {
   uint32_t size ;
   uint32_t pad64 ;
};
struct drm_vmw_dmabuf_rep {
   uint64_t map_handle ;
   uint32_t handle ;
   uint32_t cur_gmr_id ;
   uint32_t cur_gmr_offset ;
   uint32_t pad64 ;
};
union drm_vmw_alloc_dmabuf_arg {
   struct drm_vmw_alloc_dmabuf_req req ;
   struct drm_vmw_dmabuf_rep rep ;
};
struct drm_vmw_unref_dmabuf_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
struct drm_vmw_control_stream_arg {
   uint32_t stream_id ;
   uint32_t enabled ;
   uint32_t flags ;
   uint32_t color_key ;
   uint32_t handle ;
   uint32_t offset ;
   int32_t format ;
   uint32_t size ;
   uint32_t width ;
   uint32_t height ;
   uint32_t pitch[3] ;
   uint32_t pad64 ;
   struct drm_vmw_rect src ;
   struct drm_vmw_rect dst ;
};
struct drm_vmw_stream_arg {
   uint32_t stream_id ;
   uint32_t pad64 ;
};
struct drm_vmw_get_3d_cap_arg {
   uint64_t buffer ;
   uint32_t max_size ;
   uint32_t pad64 ;
};
struct drm_vmw_fence_wait_arg {
   uint32_t handle ;
   int32_t cookie_valid ;
   uint64_t kernel_cookie ;
   uint64_t timeout_us ;
   int32_t lazy ;
   int32_t flags ;
   int32_t wait_options ;
   int32_t pad64 ;
};
struct drm_vmw_fence_signaled_arg {
   uint32_t handle ;
   uint32_t flags ;
   int32_t signaled ;
   uint32_t passed_seqno ;
   uint32_t signaled_flags ;
   uint32_t pad64 ;
};
struct drm_vmw_fence_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
struct drm_vmw_fence_event_arg {
   uint64_t fence_rep ;
   uint64_t user_data ;
   uint32_t handle ;
   uint32_t flags ;
};
struct drm_vmw_present_arg {
   uint32_t fb_id ;
   uint32_t sid ;
   int32_t dest_x ;
   int32_t dest_y ;
   uint64_t clips_ptr ;
   uint32_t num_clips ;
   uint32_t pad64 ;
};
struct drm_vmw_present_readback_arg {
   uint32_t fb_id ;
   uint32_t num_clips ;
   uint64_t clips_ptr ;
   uint64_t fence_rep ;
};
struct __anonstruct_437 {
   int  : 0 ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct fb_fix_screeninfo {
   char id[16] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2] ;
};
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4] ;
};
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char *data ;
   struct fb_cmap cmap ;
};
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
struct backlight_device;
struct backlight_device;
struct fb_info;
struct fb_info;
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
struct fb_videomode;
struct fb_videomode;
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4] ;
   __u8 monitor[14] ;
   __u8 serial_no[14] ;
   __u8 ascii[14] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   __u16 gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info *info , void *dst , void *src , unsigned int size ) ;
   void (*readio)(struct fb_info *info , void *dst , void *src , unsigned int size ) ;
};
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*deferred_io)(struct fb_info *info , struct list_head *pagelist ) ;
};
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info *info , int user ) ;
   int (*fb_release)(struct fb_info *info , int user ) ;
   ssize_t (*fb_read)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ) ;
   ssize_t (*fb_write)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ) ;
   int (*fb_check_var)(struct fb_var_screeninfo *var , struct fb_info *info ) ;
   int (*fb_set_par)(struct fb_info *info ) ;
   int (*fb_setcolreg)(unsigned int regno , unsigned int red , unsigned int green ,
                       unsigned int blue , unsigned int transp , struct fb_info *info ) ;
   int (*fb_setcmap)(struct fb_cmap *cmap , struct fb_info *info ) ;
   int (*fb_blank)(int blank , struct fb_info *info ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo *var , struct fb_info *info ) ;
   void (*fb_fillrect)(struct fb_info *info , struct fb_fillrect *rect ) ;
   void (*fb_copyarea)(struct fb_info *info , struct fb_copyarea *region ) ;
   void (*fb_imageblit)(struct fb_info *info , struct fb_image *image ) ;
   int (*fb_cursor)(struct fb_info *info , struct fb_cursor *cursor ) ;
   void (*fb_rotate)(struct fb_info *info , int angle ) ;
   int (*fb_sync)(struct fb_info *info ) ;
   int (*fb_ioctl)(struct fb_info *info , unsigned int cmd , unsigned long arg ) ;
   int (*fb_compat_ioctl)(struct fb_info *info , unsigned int cmd , unsigned long arg ) ;
   int (*fb_mmap)(struct fb_info *info , struct vm_area_struct *vma ) ;
   void (*fb_get_caps)(struct fb_info *info , struct fb_blit_caps *caps , struct fb_var_screeninfo *var ) ;
   void (*fb_destroy)(struct fb_info *info ) ;
   int (*fb_debug_enter)(struct fb_info *info ) ;
   int (*fb_debug_leave)(struct fb_info *info ) ;
};
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 *data ;
};
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info *info , struct fb_tilemap *map ) ;
   void (*fb_tilecopy)(struct fb_info *info , struct fb_tilearea *area ) ;
   void (*fb_tilefill)(struct fb_info *info , struct fb_tilerect *rect ) ;
   void (*fb_tileblit)(struct fb_info *info , struct fb_tileblit *blit ) ;
   void (*fb_tilecursor)(struct fb_info *info , struct fb_tilecursor *cursor ) ;
   int (*fb_get_tilemax)(struct fb_info *info ) ;
};
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0] ;
};
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
struct fb_videomode {
   char *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
struct __anonstruct_dirty_429 {
   spinlock_t lock ;
   bool active ;
   unsigned int x1 ;
   unsigned int y1 ;
   unsigned int x2 ;
   unsigned int y2 ;
};
struct vmw_fb_par {
   struct vmw_private *vmw_priv ;
   void *vmalloc ;
   struct vmw_dma_buffer *vmw_bo ;
   struct ttm_bo_kmap_obj map ;
   u32 pseudo_palette[17] ;
   unsigned int depth ;
   unsigned int bpp ;
   unsigned int max_width ;
   unsigned int max_height ;
   void *bo_ptr ;
   unsigned int bo_size ;
   bool bo_iowrite ;
   struct __anonstruct_dirty_429 dirty ;
};
struct __anonstruct_cmd_430___0 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
enum hrtimer_restart;
enum kobj_ns_type;
typedef enum SVGA3dSurfaceFormat SVGA3dSurfaceFormat;
struct __anonstruct_SVGA3dSize_87 {
   uint32 width ;
   uint32 height ;
   uint32 depth ;
};
typedef struct __anonstruct_SVGA3dSize_87 SVGA3dSize;
enum __anonenum_SVGA3dSurfaceFlags_88 {
    SVGA3D_SURFACE_CUBEMAP = 1,
    SVGA3D_SURFACE_HINT_STATIC = 2,
    SVGA3D_SURFACE_HINT_DYNAMIC = 4,
    SVGA3D_SURFACE_HINT_INDEXBUFFER = 8,
    SVGA3D_SURFACE_HINT_VERTEXBUFFER = 16,
    SVGA3D_SURFACE_HINT_TEXTURE = 32,
    SVGA3D_SURFACE_HINT_RENDERTARGET = 64,
    SVGA3D_SURFACE_HINT_DEPTHSTENCIL = 128,
    SVGA3D_SURFACE_HINT_WRITEONLY = 256,
    SVGA3D_SURFACE_MASKABLE_ANTIALIAS = 512,
    SVGA3D_SURFACE_AUTOGENMIPMAPS = 1024
} ;
typedef enum __anonenum_SVGA3dSurfaceFlags_88 SVGA3dSurfaceFlags;
struct __anonstruct_SVGA3dSurfaceFace_89 {
   uint32 numMipLevels ;
};
typedef struct __anonstruct_SVGA3dSurfaceFace_89 SVGA3dSurfaceFace;
struct __anonstruct_SVGA3dCmdDefineSurface_90 {
   uint32 sid ;
   SVGA3dSurfaceFlags surfaceFlags ;
   SVGA3dSurfaceFormat format ;
   SVGA3dSurfaceFace face[6] ;
};
typedef struct __anonstruct_SVGA3dCmdDefineSurface_90 SVGA3dCmdDefineSurface;
struct __anonstruct_SVGA3dCmdDestroySurface_92 {
   uint32 sid ;
};
typedef struct __anonstruct_SVGA3dCmdDestroySurface_92 SVGA3dCmdDestroySurface;
struct __anonstruct_SVGA3dCmdDefineContext_93 {
   uint32 cid ;
};
typedef struct __anonstruct_SVGA3dCmdDefineContext_93 SVGA3dCmdDefineContext;
struct __anonstruct_SVGA3dCmdDestroyContext_94 {
   uint32 cid ;
};
typedef struct __anonstruct_SVGA3dCmdDestroyContext_94 SVGA3dCmdDestroyContext;
struct __anonstruct_SVGA3dSurfaceDMAFlags_107 {
   uint32 discard : 1 ;
   uint32 unsynchronized : 1 ;
   uint32 reserved : 30 ;
};
typedef struct __anonstruct_SVGA3dSurfaceDMAFlags_107 SVGA3dSurfaceDMAFlags;
struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_109 {
   uint32 suffixSize ;
   uint32 maximumOffset ;
   SVGA3dSurfaceDMAFlags flags ;
};
typedef struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_109 SVGA3dCmdSurfaceDMASuffix;
enum hrtimer_restart;
enum kobj_ns_type;
struct vmw_user_context {
   struct ttm_base_object base ;
   struct vmw_resource res ;
};
struct vmw_user_surface {
   struct ttm_base_object base ;
   struct vmw_surface srf ;
   uint32_t size ;
};
struct vmw_user_dma_buffer {
   struct ttm_base_object base ;
   struct vmw_dma_buffer dma ;
};
struct vmw_stream {
   struct vmw_resource res ;
   uint32_t stream_id ;
};
struct vmw_user_stream {
   struct ttm_base_object base ;
   struct vmw_stream stream ;
};
struct vmw_surface_offset {
   uint32_t face ;
   uint32_t mip ;
   uint32_t bo_offset ;
};
struct __anonstruct_cmd_429___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
struct __anonstruct_cmd_430___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
struct vmw_bpp {
   uint8_t bpp ;
   uint8_t s_bpp ;
};
struct vmw_surface_dma {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA body ;
   SVGA3dCopyBox cb ;
   SVGA3dCmdSurfaceDMASuffix suffix ;
};
struct vmw_surface_define {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineSurface body ;
};
struct vmw_surface_destroy {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroySurface body ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct vmw_ttm_tt {
   struct ttm_tt ttm ;
   struct vmw_private *dev_priv ;
   int gmr_id ;
};
struct svga_fifo_cmd_fence {
   __le32 fence ;
};
struct __wait_queue;
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int flags , void *key ) ;
   struct list_head task_list ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct __anonstruct_cmd_429___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
enum hrtimer_restart;
enum kobj_ns_type;
enum hrtimer_restart;
enum kobj_ns_type;
struct vmw_legacy_display {
   struct list_head active ;
   unsigned int num_active ;
   unsigned int last_num_active ;
   struct vmw_framebuffer *fb ;
};
struct vmw_legacy_display_unit {
   struct vmw_display_unit base ;
   struct list_head active ;
};
enum hrtimer_restart;
enum kobj_ns_type;
enum hrtimer_restart;
enum kobj_ns_type;
struct SVGAFifoCmdEscape {
   uint32 nsid ;
   uint32 size ;
};
typedef struct SVGAFifoCmdEscape SVGAFifoCmdEscape;
struct __anonstruct_header_430 {
   uint32 cmdType ;
   uint32 streamId ;
};
struct __anonstruct_items_431 {
   uint32 registerId ;
   uint32 value ;
};
struct SVGAEscapeVideoSetRegs {
   struct __anonstruct_header_430 header ;
   struct __anonstruct_items_431 items[1] ;
};
typedef struct SVGAEscapeVideoSetRegs SVGAEscapeVideoSetRegs;
struct SVGAEscapeVideoFlush {
   uint32 cmdType ;
   uint32 streamId ;
};
typedef struct SVGAEscapeVideoFlush SVGAEscapeVideoFlush;
struct vmw_stream___0 {
   struct vmw_dma_buffer *buf ;
   bool claimed ;
   bool paused ;
   struct drm_vmw_control_stream_arg saved ;
};
struct vmw_overlay {
   struct mutex mutex ;
   struct vmw_stream___0 stream[1] ;
};
struct vmw_escape_header {
   uint32_t cmd ;
   SVGAFifoCmdEscape body ;
};
struct vmw_escape_video_flush {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoFlush flush ;
};
struct __anonstruct_header_441 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
struct __anonstruct_cmds_440 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_441 header ;
};
struct __anonstruct_items_442 {
   uint32_t registerId ;
   uint32_t value ;
};
struct __anonstruct_cmds_443 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct vmw_marker {
   struct list_head head ;
   uint32_t seqno ;
   struct timespec submitted ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct vmwgfx_gmrid_man {
   spinlock_t lock ;
   struct ida gmr_ida ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t used_gmr_pages ;
};
enum hrtimer_restart;
enum kobj_ns_type;
struct drm_vmw_event_fence {
   struct drm_event base ;
   uint64_t user_data ;
   uint32_t tv_sec ;
   uint32_t tv_usec ;
};
enum vmw_action_type {
    VMW_ACTION_EVENT = 0,
    VMW_ACTION_MAX = 1
} ;
struct vmw_fence_action {
   struct list_head head ;
   enum vmw_action_type type ;
   void (*seq_passed)(struct vmw_fence_action *action ) ;
   void (*cleanup)(struct vmw_fence_action *action ) ;
};
struct vmw_fence_manager {
   int num_fence_objects ;
   struct vmw_private *dev_priv ;
   spinlock_t lock ;
   struct list_head fence_list ;
   struct work_struct work ;
   u32 user_fence_size ;
   u32 fence_size ;
   u32 event_fence_action_size ;
   bool fifo_down ;
   struct list_head cleanup_list ;
   uint32_t pending_actions[1] ;
   struct mutex goal_irq_mutex ;
   bool goal_irq_on ;
   bool seqno_valid ;
};
struct vmw_user_fence {
   struct ttm_base_object base ;
   struct vmw_fence_obj fence ;
};
struct vmw_event_fence_action {
   struct vmw_fence_action action ;
   struct list_head fpriv_head ;
   struct drm_pending_event *event ;
   struct vmw_fence_obj *fence ;
   struct drm_device *dev ;
   uint32_t *tv_sec ;
   uint32_t *tv_usec ;
};
struct vmw_event_fence_pending {
   struct drm_pending_event base ;
   struct drm_vmw_event_fence event ;
};
enum hrtimer_restart;
enum kobj_ns_type;
enum hrtimer_restart;
enum kobj_ns_type;
struct SVGAGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
typedef struct SVGAGuestImage SVGAGuestImage;
struct __anonstruct_size_288 {
   uint32 width ;
   uint32 height ;
};
struct __anonstruct_root_289 {
   int32 x ;
   int32 y ;
};
struct SVGAScreenObject {
   uint32 structSize ;
   uint32 id ;
   uint32 flags ;
   struct __anonstruct_size_288 size ;
   struct __anonstruct_root_289 root ;
   SVGAGuestImage backingStore ;
   uint32 cloneCount ;
};
typedef struct SVGAScreenObject SVGAScreenObject;
struct __anonstruct_SVGAFifoCmdDestroyScreen_293 {
   uint32 screenId ;
};
typedef struct __anonstruct_SVGAFifoCmdDestroyScreen_293 SVGAFifoCmdDestroyScreen;
struct vmw_screen_object_display {
   unsigned int num_implicit ;
   struct vmw_framebuffer *implicit_fb ;
};
struct vmw_screen_object_unit {
   struct vmw_display_unit base ;
   unsigned long buffer_size ;
   struct vmw_dma_buffer *buffer ;
   bool defined ;
   bool active_implicit ;
};
struct __anonstruct_header_430___0 {
   uint32_t cmdType ;
};
struct __anonstruct_cmd_429___3 {
   struct __anonstruct_header_430___0 header ;
   SVGAScreenObject obj ;
};
struct __anonstruct_header_432 {
   uint32_t cmdType ;
};
struct __anonstruct_cmd_431___0 {
   struct __anonstruct_header_432 header ;
   SVGAFifoCmdDestroyScreen body ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
long ldv__builtin_expect(long val , long res ) ;
extern int printk(char *fmt  , ...) ;
extern void __might_sleep(char *file , int line , int preempt_offset ) ;
 static void might_fault(void)  __attribute__((__no_instrument_function__)) ;
 static void might_fault(void)  __attribute__((__no_instrument_function__)) ;
 static void might_fault(void) 
{ 

  {
  while (1) {
    __might_sleep("include/linux/kernel.h", 196, 0);
    while (1) {

      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: ;
  return;
}
}
 static void INIT_LIST_HEAD(struct list_head *list )  __attribute__((__no_instrument_function__)) ;
 static void INIT_LIST_HEAD(struct list_head *list )  __attribute__((__no_instrument_function__)) ;
 static void INIT_LIST_HEAD(struct list_head *list ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
  *((struct list_head **)list) = list;
  __cil_tmp2 = (unsigned long )list;
  __cil_tmp3 = __cil_tmp2 + 8UL;
  *((struct list_head **)__cil_tmp3) = list;
  return;
}
}
extern void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) ;
 static void list_add_tail(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_add_tail(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct list_head *__cil_tmp5 ;

  {
  __cil_tmp3 = (unsigned long )head;
  __cil_tmp4 = __cil_tmp3 + 8UL;
  __cil_tmp5 = *((struct list_head **)__cil_tmp4);
  __list_add(new, __cil_tmp5, head);
  return;
}
}
extern void __list_del_entry(struct list_head *entry ) ;
extern void list_del(struct list_head *entry ) ;
 static void list_del_init(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
 static void list_del_init(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
 static void list_del_init(struct list_head *entry ) 
{ 

  {
  __list_del_entry(entry);
  INIT_LIST_HEAD(entry);
  return;
}
}
 static int list_empty(struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static int list_empty(struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static int list_empty(struct list_head *head ) 
{ unsigned long __cil_tmp2 ;
  struct list_head *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )head;
  __cil_tmp3 = *((struct list_head **)head);
  __cil_tmp4 = (unsigned long )__cil_tmp3;
  return (__cil_tmp4 == __cil_tmp2);
}
}
extern void *memset(void *s , int c , size_t n ) ;
extern void warn_slowpath_fmt(char *file , int line , char *fmt  , ...) ;
extern void warn_slowpath_null(char *file , int line ) ;
 static int atomic_read(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_read(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_read(atomic_t *v ) 
{ int *__cil_tmp2 ;
  int volatile   *__cil_tmp3 ;
  int volatile   __cil_tmp4 ;

  {
  __cil_tmp2 = (int *)v;
  __cil_tmp3 = (int volatile   *)__cil_tmp2;
  __cil_tmp4 = *__cil_tmp3;
  return ((int )__cil_tmp4);
}
}
 static void atomic_inc(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static void atomic_inc(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static void atomic_inc(atomic_t *v ) 
{ 

  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "incl %0": "+m" (*((int *)v)));
  return;
}
}
void mutex_lock(struct mutex *lock ) ;
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) ;
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) ;
int mutex_trylock(struct mutex *lock ) ;
void mutex_unlock(struct mutex *lock ) ;
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) ;
extern bool capable(int cap ) ;
extern void *vmalloc(unsigned long size ) ;
extern void vfree(void *addr ) ;
 static void kref_get(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
 static void kref_get(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
 static void kref_get(struct kref *kref ) 
{ int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  atomic_t *__cil_tmp6 ;
  atomic_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  atomic_t *__cil_tmp15 ;

  {
  __cil_tmp6 = (atomic_t *)kref;
  __cil_tmp7 = __cil_tmp6;
  tmp = atomic_read(__cil_tmp7);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  __ret_warn_on = tmp___0;
  __cil_tmp8 = ! __ret_warn_on;
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = (long )__cil_tmp9;
  tmp___1 = ldv__builtin_expect(__cil_tmp10, 0L);
  if (tmp___1) {
    __cil_tmp11 = 41;
    warn_slowpath_null("include/linux/kref.h", __cil_tmp11);
  }
  __cil_tmp12 = ! __ret_warn_on;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  ldv__builtin_expect(__cil_tmp14, 0L);
  __cil_tmp15 = (atomic_t *)kref;
  atomic_inc(__cil_tmp15);
  return;
}
}
extern unsigned long __attribute__((__warn_unused_result__))  _copy_to_user(void *to ,
                                                                            void *from ,
                                                                            unsigned int len ) ;
extern unsigned long __attribute__((__warn_unused_result__))  _copy_from_user(void *to ,
                                                                              void *from ,
                                                                              unsigned int len ) ;
 static unsigned long __attribute__((__warn_unused_result__))  copy_from_user(void *to ,
                                                                                      void *from ,
                                                                                      unsigned long n )  __attribute__((__no_instrument_function__)) ;
 static unsigned long __attribute__((__warn_unused_result__))  copy_from_user(void *to ,
                                                                                      void *from ,
                                                                                      unsigned long n )  __attribute__((__no_instrument_function__)) ;
 static unsigned long __attribute__((__warn_unused_result__))  copy_from_user(void *to ,
                                                                                      void *from ,
                                                                                      unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  unsigned long __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long tmp___3 ;

  {
  tmp = __builtin_object_size(to, 0);
  sz = (int )tmp;
  might_fault();
  if (sz == -1) {
    tmp___1 = 1;
  } else {
    __cil_tmp10 = (unsigned long )sz;
    if (__cil_tmp10 >= n) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  __cil_tmp11 = (long )tmp___1;
  tmp___2 = ldv__builtin_expect(__cil_tmp11, 1L);
  if (tmp___2) {
    __cil_tmp12 = (unsigned int )n;
    tmp___3 = (unsigned long )_copy_from_user(to, from, __cil_tmp12);
    n = tmp___3;
  } else {
    __ret_warn_on = 1;
    __cil_tmp13 = ! __ret_warn_on;
    __cil_tmp14 = ! __cil_tmp13;
    __cil_tmp15 = (long )__cil_tmp14;
    tmp___0 = ldv__builtin_expect(__cil_tmp15, 0L);
    if (tmp___0) {
      __cil_tmp16 = 57;
      warn_slowpath_fmt("/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h",
                        __cil_tmp16, "Buffer overflow detected!\n");
    }
    __cil_tmp17 = ! __ret_warn_on;
    __cil_tmp18 = ! __cil_tmp17;
    __cil_tmp19 = (long )__cil_tmp18;
    ldv__builtin_expect(__cil_tmp19, 0L);
  }
  return (n);
}
}
 static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) copy_to_user)(void *dst ,
                                                                                                                void *src ,
                                                                                                                unsigned int size )  __attribute__((__no_instrument_function__)) ;
 static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) copy_to_user)(void *dst ,
                                                                                                                void *src ,
                                                                                                                unsigned int size )  __attribute__((__no_instrument_function__)) ;
 static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) copy_to_user)(void *dst ,
                                                                                                                void *src ,
                                                                                                                unsigned int size ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  might_fault();
  tmp___0 = (unsigned long )_copy_to_user(dst, src, size);
  tmp = tmp___0;
  return ((int )tmp);
}
}
extern int drm_err(char *func , char *format  , ...) ;
 static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct kref *__cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )bo;
  __cil_tmp3 = __cil_tmp2 + 64UL;
  __cil_tmp4 = (struct kref *)__cil_tmp3;
  kref_get(__cil_tmp4);
  return (bo);
}
}
extern int ttm_bo_validate(struct ttm_buffer_object *bo , struct ttm_placement *placement ,
                           bool interruptible , bool no_wait_reserve , bool no_wait_gpu ) ;
extern void ttm_bo_unref(struct ttm_buffer_object **bo ) ;
extern int ttm_ref_object_base_unref(struct ttm_object_file *tfile , unsigned long key ,
                                     enum ttm_ref_type ref_type ) ;
extern void ttm_read_unlock(struct ttm_lock *lock ) ;
extern int ttm_read_lock(struct ttm_lock *lock , bool interruptible ) ;
extern void ttm_eu_backoff_reservation(struct list_head *list ) ;
extern int ttm_eu_reserve_buffers(struct list_head *list ) ;
extern void ttm_eu_fence_buffer_objects(struct list_head *list , void *sync_obj ) ;
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) ;
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) ;
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) ;
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) ;
 static struct vmw_private *vmw_priv(struct drm_device *dev )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_private *vmw_priv(struct drm_device *dev )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_private *vmw_priv(struct drm_device *dev ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )dev;
  __cil_tmp3 = __cil_tmp2 + 1064UL;
  __cil_tmp4 = *((void **)__cil_tmp3);
  return ((struct vmw_private *)__cil_tmp4);
}
}
 static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )file_priv;
  __cil_tmp3 = __cil_tmp2 + 136UL;
  __cil_tmp4 = *((void **)__cil_tmp3);
  return ((struct vmw_fpriv *)__cil_tmp4);
}
}
 static struct vmw_master *vmw_master(struct drm_master *master )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_master *vmw_master(struct drm_master *master )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_master *vmw_master(struct drm_master *master ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )master;
  __cil_tmp3 = __cil_tmp2 + 192UL;
  __cil_tmp4 = *((void **)__cil_tmp3);
  return ((struct vmw_master *)__cil_tmp4);
}
}
void vmw_resource_unreference(struct vmw_resource **p_res ) ;
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) ;
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) ;
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) ;
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) ;
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) ;
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) ;
void vmw_resource_unreserve(struct list_head *list ) ;
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) ;
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) ;
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) ;
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) ;
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) ;
struct ttm_placement vmw_vram_placement ;
struct ttm_placement vmw_vram_gmr_placement ;
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) ;
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) ;
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) ;
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) ;
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) ;
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) ;
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) ;
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) ;
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) ;
 static void vmw_surface_unreference(struct vmw_surface **srf )  __attribute__((__no_instrument_function__)) ;
 static void vmw_surface_unreference(struct vmw_surface **srf )  __attribute__((__no_instrument_function__)) ;
 static void vmw_surface_unreference(struct vmw_surface **srf ) 
{ struct vmw_surface *tmp_srf ;
  struct vmw_resource *res ;
  struct vmw_resource **__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  tmp_srf = *srf;
  __cil_tmp4 = & res;
  *__cil_tmp4 = (struct vmw_resource *)tmp_srf;
  __cil_tmp5 = (void *)0;
  *srf = (struct vmw_surface *)__cil_tmp5;
  vmw_resource_unreference(& res);
  return;
}
}
 static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf )  __attribute__((__no_instrument_function__)) ;
 static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf )  __attribute__((__no_instrument_function__)) ;
 static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf ) 
{ struct vmw_dma_buffer *tmp_buf ;
  struct ttm_buffer_object *bo ;
  struct ttm_buffer_object **__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  tmp_buf = *buf;
  __cil_tmp4 = & bo;
  *__cil_tmp4 = (struct ttm_buffer_object *)tmp_buf;
  __cil_tmp5 = (void *)0;
  *buf = (struct vmw_dma_buffer *)__cil_tmp5;
  ttm_bo_unref(& bo);
  return;
}
}
static int vmw_cmd_invalid(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                           SVGA3dCmdHeader *header ) 
{ int tmp___8 ;
  bool tmp___9 ;

  {
  tmp___9 = capable(21);
  tmp___8 = (int )tmp___9;
  if (! tmp___8) {
    tmp___8 = -22;
  }
  return (tmp___8);
}
}
static int vmw_cmd_ok(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                      SVGA3dCmdHeader *header ) 
{ 

  {
  return (0);
}
}
static void vmw_resource_to_validate_list(struct vmw_sw_context *sw_context , struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  int tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct list_head *__cil_tmp7 ;
  struct list_head *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  res = *p_res;
  __cil_tmp5 = (unsigned long )res;
  __cil_tmp6 = __cil_tmp5 + 64UL;
  __cil_tmp7 = (struct list_head *)__cil_tmp6;
  __cil_tmp8 = __cil_tmp7;
  tmp___7 = list_empty(__cil_tmp8);
  if (tmp___7) {
    __cil_tmp9 = (unsigned long )res;
    __cil_tmp10 = __cil_tmp9 + 64UL;
    __cil_tmp11 = (struct list_head *)__cil_tmp10;
    __cil_tmp12 = (unsigned long )sw_context;
    __cil_tmp13 = __cil_tmp12 + 131216UL;
    __cil_tmp14 = (struct list_head *)__cil_tmp13;
    list_add_tail(__cil_tmp11, __cil_tmp14);
    __cil_tmp15 = (void *)0;
    *p_res = (struct vmw_resource *)__cil_tmp15;
  } else {
    vmw_resource_unreference(p_res);
  }
  return;
}
}
static int vmw_bo_to_validate_list(struct vmw_sw_context *sw_context , struct ttm_buffer_object *bo ,
                                   uint32_t fence_flags , uint32_t *p_val_node ) 
{ uint32_t val_node ;
  struct ttm_validate_buffer *val_buf ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t __cil_tmp52 ;

  {
  __cil_tmp9 = (unsigned long )sw_context;
  __cil_tmp10 = __cil_tmp9 + 131192UL;
  __cil_tmp11 = *((uint32_t *)__cil_tmp10);
  val_node = vmw_dmabuf_validate_node(bo, __cil_tmp11);
  __cil_tmp12 = val_node >= 2048U;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = (long )__cil_tmp14;
  tmp___7 = ldv__builtin_expect(__cil_tmp15, 0L);
  if (tmp___7) {
    drm_err("vmw_bo_to_validate_list", "Max number of DMA buffers per submission exceeded.\n");
    return (-22);
  }
  __cil_tmp16 = (unsigned long )val_node * 48UL;
  __cil_tmp17 = 32888UL + __cil_tmp16;
  __cil_tmp18 = (unsigned long )sw_context;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  val_buf = (struct ttm_validate_buffer *)__cil_tmp19;
  __cil_tmp20 = (unsigned long )sw_context;
  __cil_tmp21 = __cil_tmp20 + 131192UL;
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
  __cil_tmp23 = val_node == __cil_tmp22;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  if (tmp___8) {
    __cil_tmp27 = (unsigned long )val_buf;
    __cil_tmp28 = __cil_tmp27 + 24UL;
    *((void **)__cil_tmp28) = (void *)0;
    __cil_tmp29 = (unsigned long )val_buf;
    __cil_tmp30 = __cil_tmp29 + 16UL;
    *((struct ttm_buffer_object **)__cil_tmp30) = ttm_bo_reference(bo);
    __cil_tmp31 = (struct list_head *)val_buf;
    __cil_tmp32 = (unsigned long )sw_context;
    __cil_tmp33 = __cil_tmp32 + 96UL;
    __cil_tmp34 = (struct list_head *)__cil_tmp33;
    list_add_tail(__cil_tmp31, __cil_tmp34);
    __cil_tmp35 = (unsigned long )sw_context;
    __cil_tmp36 = __cil_tmp35 + 131192UL;
    __cil_tmp37 = (unsigned long )sw_context;
    __cil_tmp38 = __cil_tmp37 + 131192UL;
    __cil_tmp39 = *((uint32_t *)__cil_tmp38);
    *((uint32_t *)__cil_tmp36) = __cil_tmp39 + 1U;
  }
  __cil_tmp40 = (unsigned long )val_buf;
  __cil_tmp41 = __cil_tmp40 + 24UL;
  __cil_tmp42 = (unsigned long )fence_flags;
  __cil_tmp43 = (unsigned long )val_buf;
  __cil_tmp44 = __cil_tmp43 + 24UL;
  __cil_tmp45 = *((void **)__cil_tmp44);
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  __cil_tmp47 = __cil_tmp46 | __cil_tmp42;
  *((void **)__cil_tmp41) = (void *)__cil_tmp47;
  __cil_tmp48 = (unsigned long )sw_context;
  __cil_tmp49 = __cil_tmp48 + 131232UL;
  __cil_tmp50 = (unsigned long )sw_context;
  __cil_tmp51 = __cil_tmp50 + 131232UL;
  __cil_tmp52 = *((uint32_t *)__cil_tmp51);
  *((uint32_t *)__cil_tmp49) = __cil_tmp52 | fence_flags;
  if (p_val_node) {
    *p_val_node = val_node;
  }
  return (0);
}
}
static int vmw_cmd_cid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_resource *ctx ;
  struct vmw_cid_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader *__mptr ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  struct vmw_cid_cmd *__cil_tmp11 ;
  SVGA3dCmdHeader *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct ttm_object_file *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  __le32 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  __le32 __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct vmw_resource **__cil_tmp47 ;

  {
  __mptr = header;
  __cil_tmp11 = (struct vmw_cid_cmd *)0;
  __cil_tmp12 = (SVGA3dCmdHeader *)__cil_tmp11;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  __cil_tmp14 = (char *)__mptr;
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
  cmd = (struct vmw_cid_cmd *)__cil_tmp15;
  __cil_tmp16 = (unsigned long )sw_context;
  __cil_tmp17 = __cil_tmp16 + 60UL;
  if (*((bool *)__cil_tmp17)) {
    __cil_tmp18 = (unsigned long )sw_context;
    __cil_tmp19 = __cil_tmp18 + 56UL;
    __cil_tmp20 = *((uint32_t *)__cil_tmp19);
    __cil_tmp21 = (unsigned long )cmd;
    __cil_tmp22 = __cil_tmp21 + 8UL;
    __cil_tmp23 = *((__le32 *)__cil_tmp22);
    if (__cil_tmp23 == __cil_tmp20) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  __cil_tmp24 = (long )tmp___7;
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 1L);
  if (tmp___8) {
    return (0);
  }
  __cil_tmp25 = (unsigned long )sw_context;
  __cil_tmp26 = __cil_tmp25 + 88UL;
  __cil_tmp27 = *((struct ttm_object_file **)__cil_tmp26);
  __cil_tmp28 = (unsigned long )cmd;
  __cil_tmp29 = __cil_tmp28 + 8UL;
  __cil_tmp30 = *((__le32 *)__cil_tmp29);
  __cil_tmp31 = (int )__cil_tmp30;
  ret = vmw_context_check(dev_priv, __cil_tmp27, __cil_tmp31, & ctx);
  __cil_tmp32 = ret != 0;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = (long )__cil_tmp34;
  tmp___9 = ldv__builtin_expect(__cil_tmp35, 0L);
  if (tmp___9) {
    __cil_tmp36 = (unsigned long )cmd;
    __cil_tmp37 = __cil_tmp36 + 8UL;
    __cil_tmp38 = *((__le32 *)__cil_tmp37);
    drm_err("vmw_cmd_cid_check", "Could not find or use context %u\n", __cil_tmp38);
    return (ret);
  }
  __cil_tmp39 = (unsigned long )sw_context;
  __cil_tmp40 = __cil_tmp39 + 56UL;
  __cil_tmp41 = (unsigned long )cmd;
  __cil_tmp42 = __cil_tmp41 + 8UL;
  *((uint32_t *)__cil_tmp40) = *((__le32 *)__cil_tmp42);
  __cil_tmp43 = (unsigned long )sw_context;
  __cil_tmp44 = __cil_tmp43 + 60UL;
  *((bool *)__cil_tmp44) = (bool )1;
  __cil_tmp45 = (unsigned long )sw_context;
  __cil_tmp46 = __cil_tmp45 + 64UL;
  __cil_tmp47 = & ctx;
  *((struct vmw_resource **)__cil_tmp46) = *__cil_tmp47;
  vmw_resource_to_validate_list(sw_context, & ctx);
  return (0);
}
}
static int vmw_cmd_sid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             uint32_t *sid ) 
{ struct vmw_surface *srf ;
  int ret ;
  struct vmw_resource *res ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint32_t __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_object_file *__cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_surface **__cil_tmp31 ;
  struct vmw_surface *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface **__cil_tmp44 ;
  struct vmw_surface *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct vmw_resource **__cil_tmp51 ;
  struct vmw_surface **__cil_tmp52 ;
  struct vmw_surface *__cil_tmp53 ;

  {
  __cil_tmp11 = *sid;
  if (__cil_tmp11 == 4294967295U) {
    return (0);
  }
  __cil_tmp12 = (unsigned long )sw_context;
  __cil_tmp13 = __cil_tmp12 + 80UL;
  if (*((bool *)__cil_tmp13)) {
    __cil_tmp14 = (unsigned long )sw_context;
    __cil_tmp15 = __cil_tmp14 + 72UL;
    __cil_tmp16 = *((uint32_t *)__cil_tmp15);
    __cil_tmp17 = *sid;
    if (__cil_tmp17 == __cil_tmp16) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  __cil_tmp18 = (long )tmp___7;
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 1L);
  if (tmp___8) {
    __cil_tmp19 = (unsigned long )sw_context;
    __cil_tmp20 = __cil_tmp19 + 76UL;
    *sid = *((uint32_t *)__cil_tmp20);
    return (0);
  }
  __cil_tmp21 = (unsigned long )sw_context;
  __cil_tmp22 = __cil_tmp21 + 88UL;
  __cil_tmp23 = *((struct ttm_object_file **)__cil_tmp22);
  __cil_tmp24 = *sid;
  ret = vmw_user_surface_lookup_handle(dev_priv, __cil_tmp23, __cil_tmp24, & srf);
  __cil_tmp25 = ret != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___9 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___9) {
    __cil_tmp29 = *sid;
    __cil_tmp30 = (unsigned long )sid;
    drm_err("vmw_cmd_sid_check", "Could ot find or use surface 0x%08x address 0x%08lx\n",
            __cil_tmp29, __cil_tmp30);
    return (ret);
  }
  __cil_tmp31 = & srf;
  __cil_tmp32 = *__cil_tmp31;
  ret = vmw_surface_validate(dev_priv, __cil_tmp32);
  __cil_tmp33 = ret != 0;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = (long )__cil_tmp35;
  tmp___10 = ldv__builtin_expect(__cil_tmp36, 0L);
  if (tmp___10) {
    if (ret != -512) {
      drm_err("vmw_cmd_sid_check", "Could not validate surface.\n");
    }
    vmw_surface_unreference(& srf);
    return (ret);
  }
  __cil_tmp37 = (unsigned long )sw_context;
  __cil_tmp38 = __cil_tmp37 + 72UL;
  *((uint32_t *)__cil_tmp38) = *sid;
  __cil_tmp39 = (unsigned long )sw_context;
  __cil_tmp40 = __cil_tmp39 + 80UL;
  *((bool *)__cil_tmp40) = (bool )1;
  __cil_tmp41 = (unsigned long )sw_context;
  __cil_tmp42 = __cil_tmp41 + 76UL;
  __cil_tmp43 = 24;
  __cil_tmp44 = & srf;
  __cil_tmp45 = *__cil_tmp44;
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  __cil_tmp47 = __cil_tmp46 + __cil_tmp43;
  __cil_tmp48 = *((int *)__cil_tmp47);
  *((uint32_t *)__cil_tmp42) = (uint32_t )__cil_tmp48;
  __cil_tmp49 = (unsigned long )sw_context;
  __cil_tmp50 = __cil_tmp49 + 76UL;
  *sid = *((uint32_t *)__cil_tmp50);
  __cil_tmp51 = & res;
  __cil_tmp52 = & srf;
  __cil_tmp53 = *__cil_tmp52;
  *__cil_tmp51 = (struct vmw_resource *)__cil_tmp53;
  vmw_resource_to_validate_list(sw_context, & res);
  return (0);
}
}
static int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                           SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd *cmd ;
  int ret ;
  long tmp___7 ;
  SVGA3dCmdHeader *__mptr ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  struct vmw_sid_cmd *__cil_tmp12 ;
  SVGA3dCmdHeader *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32 *__cil_tmp20 ;

  {
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
  __cil_tmp8 = ret != 0;
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = ! __cil_tmp9;
  __cil_tmp11 = (long )__cil_tmp10;
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 0L);
  if (tmp___7) {
    return (ret);
  }
  __mptr = header;
  __cil_tmp12 = (struct vmw_sid_cmd *)0;
  __cil_tmp13 = (SVGA3dCmdHeader *)__cil_tmp12;
  __cil_tmp14 = (unsigned int )__cil_tmp13;
  __cil_tmp15 = (char *)__mptr;
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
  cmd = (struct vmw_sid_cmd *)__cil_tmp16;
  __cil_tmp17 = 16;
  __cil_tmp18 = (unsigned long )cmd;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  __cil_tmp20 = (uint32 *)__cil_tmp19;
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp20);
  return (ret);
}
}
static int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___0 *__cil_tmp9 ;
  SVGA3dCmdHeader *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32 *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32 *__cil_tmp24 ;

  {
  __mptr = header;
  __cil_tmp9 = (struct vmw_sid_cmd___0 *)0;
  __cil_tmp10 = (SVGA3dCmdHeader *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  cmd = (struct vmw_sid_cmd___0 *)__cil_tmp13;
  __cil_tmp14 = (unsigned long )cmd;
  __cil_tmp15 = __cil_tmp14 + 8UL;
  __cil_tmp16 = (uint32 *)__cil_tmp15;
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp16);
  __cil_tmp17 = ret != 0;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp21 = 20;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  __cil_tmp24 = (uint32 *)__cil_tmp23;
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp24);
  return (tmp___8);
}
}
static int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                     SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___1 *cmd ;
  int ret ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___1 *__cil_tmp9 ;
  SVGA3dCmdHeader *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32 *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32 *__cil_tmp24 ;

  {
  __mptr = header;
  __cil_tmp9 = (struct vmw_sid_cmd___1 *)0;
  __cil_tmp10 = (SVGA3dCmdHeader *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  cmd = (struct vmw_sid_cmd___1 *)__cil_tmp13;
  __cil_tmp14 = (unsigned long )cmd;
  __cil_tmp15 = __cil_tmp14 + 8UL;
  __cil_tmp16 = (uint32 *)__cil_tmp15;
  ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp16);
  __cil_tmp17 = ret != 0;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp21 = 20;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  __cil_tmp24 = (uint32 *)__cil_tmp23;
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp24);
  return (tmp___8);
}
}
static int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                         SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___2 *cmd ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___2 *__cil_tmp8 ;
  SVGA3dCmdHeader *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  uint32 __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32 *__cil_tmp23 ;

  {
  __mptr = header;
  __cil_tmp8 = (struct vmw_sid_cmd___2 *)0;
  __cil_tmp9 = (SVGA3dCmdHeader *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  cmd = (struct vmw_sid_cmd___2 *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )sw_context;
  __cil_tmp14 = __cil_tmp13 + 61UL;
  __cil_tmp15 = *((bool *)__cil_tmp14);
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = (long )__cil_tmp18;
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___7) {
    __cil_tmp20 = *((uint32 *)cmd);
    drm_err("vmw_cmd_blt_surf_screen_check", "Kernel only SVGA3d command: %u.\n",
            __cil_tmp20);
    return (-1);
  }
  __cil_tmp21 = (unsigned long )cmd;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  __cil_tmp23 = (uint32 *)__cil_tmp22;
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp23);
  return (tmp___8);
}
}
static int vmw_cmd_present_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                 SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___3 *cmd ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  int tmp___8 ;
  struct vmw_sid_cmd___3 *__cil_tmp8 ;
  SVGA3dCmdHeader *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  uint32 __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32 *__cil_tmp23 ;

  {
  __mptr = header;
  __cil_tmp8 = (struct vmw_sid_cmd___3 *)0;
  __cil_tmp9 = (SVGA3dCmdHeader *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  cmd = (struct vmw_sid_cmd___3 *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )sw_context;
  __cil_tmp14 = __cil_tmp13 + 61UL;
  __cil_tmp15 = *((bool *)__cil_tmp14);
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = (long )__cil_tmp18;
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___7) {
    __cil_tmp20 = *((uint32 *)cmd);
    drm_err("vmw_cmd_present_check", "Kernel only SVGA3d command: %u.\n", __cil_tmp20);
    return (-1);
  }
  __cil_tmp21 = (unsigned long )cmd;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  __cil_tmp23 = (uint32 *)__cil_tmp22;
  tmp___8 = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp23);
  return (tmp___8);
}
}
static int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv , uint32_t cid ,
                                       struct ttm_buffer_object *new_query_bo , struct vmw_sw_context *sw_context ) 
{ int ret ;
  bool add_cid ;
  uint32_t cid_to_add ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  struct vmw_resource *ctx ;
  int tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_buffer_object *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_buffer_object *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct ttm_buffer_object *__cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  void *__cil_tmp58 ;
  uint32_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct ttm_buffer_object *__cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  void *__cil_tmp70 ;
  uint32_t *__cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  uint32_t __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  struct list_head *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct list_head *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct list_head *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct ttm_buffer_object *__cil_tmp102 ;
  uint32_t __cil_tmp103 ;
  void *__cil_tmp104 ;
  uint32_t *__cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  long __cil_tmp109 ;

  {
  add_cid = (bool )0;
  __cil_tmp19 = (unsigned long )sw_context;
  __cil_tmp20 = __cil_tmp19 + 131256UL;
  __cil_tmp21 = *((struct ttm_buffer_object **)__cil_tmp20);
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = (unsigned long )new_query_bo;
  __cil_tmp24 = __cil_tmp23 != __cil_tmp22;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = (long )__cil_tmp26;
  tmp___12 = ldv__builtin_expect(__cil_tmp27, 0L);
  if (tmp___12) {
    __cil_tmp28 = (unsigned long )new_query_bo;
    __cil_tmp29 = __cil_tmp28 + 40UL;
    __cil_tmp30 = *((unsigned long *)__cil_tmp29);
    __cil_tmp31 = __cil_tmp30 > 4UL;
    __cil_tmp32 = ! __cil_tmp31;
    __cil_tmp33 = ! __cil_tmp32;
    __cil_tmp34 = (long )__cil_tmp33;
    tmp___7 = ldv__builtin_expect(__cil_tmp34, 0L);
    if (tmp___7) {
      drm_err("vmw_query_bo_switch_prepare", "Query buffer too large.\n");
      return (-22);
    }
    __cil_tmp35 = (void *)0;
    __cil_tmp36 = (unsigned long )__cil_tmp35;
    __cil_tmp37 = (unsigned long )sw_context;
    __cil_tmp38 = __cil_tmp37 + 131256UL;
    __cil_tmp39 = *((struct ttm_buffer_object **)__cil_tmp38);
    __cil_tmp40 = (unsigned long )__cil_tmp39;
    __cil_tmp41 = __cil_tmp40 != __cil_tmp36;
    __cil_tmp42 = ! __cil_tmp41;
    __cil_tmp43 = ! __cil_tmp42;
    __cil_tmp44 = (long )__cil_tmp43;
    tmp___10 = ldv__builtin_expect(__cil_tmp44, 0L);
    if (tmp___10) {
      while (1) {
        __cil_tmp45 = (unsigned long )sw_context;
        __cil_tmp46 = __cil_tmp45 + 131268UL;
        __cil_tmp47 = *((bool *)__cil_tmp46);
        __cil_tmp48 = ! __cil_tmp47;
        __cil_tmp49 = ! __cil_tmp48;
        __cil_tmp50 = ! __cil_tmp49;
        __cil_tmp51 = (long )__cil_tmp50;
        tmp___8 = ldv__builtin_expect(__cil_tmp51, 0L);
        if (tmp___8) {
          while (1) {
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                                 "i" (311), "i" (12UL));
            while (1) {

            }

            goto while_break___0;
          }
          while_break___0: ;
        }
        goto while_break;
      }
      while_break: 
      add_cid = (bool )1;
      __cil_tmp52 = (unsigned long )sw_context;
      __cil_tmp53 = __cil_tmp52 + 131264UL;
      cid_to_add = *((uint32_t *)__cil_tmp53);
      __cil_tmp54 = (unsigned long )sw_context;
      __cil_tmp55 = __cil_tmp54 + 131256UL;
      __cil_tmp56 = *((struct ttm_buffer_object **)__cil_tmp55);
      __cil_tmp57 = (uint32_t )1;
      __cil_tmp58 = (void *)0;
      __cil_tmp59 = (uint32_t *)__cil_tmp58;
      ret = vmw_bo_to_validate_list(sw_context, __cil_tmp56, __cil_tmp57, __cil_tmp59);
      __cil_tmp60 = ret != 0;
      __cil_tmp61 = ! __cil_tmp60;
      __cil_tmp62 = ! __cil_tmp61;
      __cil_tmp63 = (long )__cil_tmp62;
      tmp___9 = ldv__builtin_expect(__cil_tmp63, 0L);
      if (tmp___9) {
        return (ret);
      }
    }
    __cil_tmp64 = (unsigned long )sw_context;
    __cil_tmp65 = __cil_tmp64 + 131256UL;
    *((struct ttm_buffer_object **)__cil_tmp65) = new_query_bo;
    __cil_tmp66 = (unsigned long )dev_priv;
    __cil_tmp67 = __cil_tmp66 + 134744UL;
    __cil_tmp68 = *((struct ttm_buffer_object **)__cil_tmp67);
    __cil_tmp69 = (uint32_t )1;
    __cil_tmp70 = (void *)0;
    __cil_tmp71 = (uint32_t *)__cil_tmp70;
    ret = vmw_bo_to_validate_list(sw_context, __cil_tmp68, __cil_tmp69, __cil_tmp71);
    __cil_tmp72 = ret != 0;
    __cil_tmp73 = ! __cil_tmp72;
    __cil_tmp74 = ! __cil_tmp73;
    __cil_tmp75 = (long )__cil_tmp74;
    tmp___11 = ldv__builtin_expect(__cil_tmp75, 0L);
    if (tmp___11) {
      return (ret);
    }
  }
  __cil_tmp76 = (unsigned long )sw_context;
  __cil_tmp77 = __cil_tmp76 + 131264UL;
  __cil_tmp78 = *((uint32_t *)__cil_tmp77);
  if (cid != __cil_tmp78) {
    __cil_tmp79 = (unsigned long )sw_context;
    __cil_tmp80 = __cil_tmp79 + 131268UL;
    if (*((bool *)__cil_tmp80)) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
  } else {
    tmp___13 = 0;
  }
  __cil_tmp81 = (long )tmp___13;
  tmp___14 = ldv__builtin_expect(__cil_tmp81, 0L);
  if (tmp___14) {
    add_cid = (bool )1;
    __cil_tmp82 = (unsigned long )sw_context;
    __cil_tmp83 = __cil_tmp82 + 131264UL;
    cid_to_add = *((uint32_t *)__cil_tmp83);
  }
  __cil_tmp84 = (unsigned long )sw_context;
  __cil_tmp85 = __cil_tmp84 + 131264UL;
  *((uint32_t *)__cil_tmp85) = cid;
  __cil_tmp86 = (unsigned long )sw_context;
  __cil_tmp87 = __cil_tmp86 + 131268UL;
  *((bool *)__cil_tmp87) = (bool )1;
  if (add_cid) {
    __cil_tmp88 = (unsigned long )sw_context;
    __cil_tmp89 = __cil_tmp88 + 64UL;
    ctx = *((struct vmw_resource **)__cil_tmp89);
    __cil_tmp90 = (unsigned long )ctx;
    __cil_tmp91 = __cil_tmp90 + 80UL;
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
    __cil_tmp93 = __cil_tmp92;
    tmp___15 = list_empty(__cil_tmp93);
    if (tmp___15) {
      __cil_tmp94 = (unsigned long )ctx;
      __cil_tmp95 = __cil_tmp94 + 80UL;
      __cil_tmp96 = (struct list_head *)__cil_tmp95;
      __cil_tmp97 = (unsigned long )sw_context;
      __cil_tmp98 = __cil_tmp97 + 131240UL;
      __cil_tmp99 = (struct list_head *)__cil_tmp98;
      list_add_tail(__cil_tmp96, __cil_tmp99);
    }
    __cil_tmp100 = (unsigned long )dev_priv;
    __cil_tmp101 = __cil_tmp100 + 134744UL;
    __cil_tmp102 = *((struct ttm_buffer_object **)__cil_tmp101);
    __cil_tmp103 = (uint32_t )1;
    __cil_tmp104 = (void *)0;
    __cil_tmp105 = (uint32_t *)__cil_tmp104;
    ret = vmw_bo_to_validate_list(sw_context, __cil_tmp102, __cil_tmp103, __cil_tmp105);
    __cil_tmp106 = ret != 0;
    __cil_tmp107 = ! __cil_tmp106;
    __cil_tmp108 = ! __cil_tmp107;
    __cil_tmp109 = (long )__cil_tmp108;
    tmp___16 = ldv__builtin_expect(__cil_tmp109, 0L);
    if (tmp___16) {
      return (ret);
    }
  }
  return (0);
}
}
static void vmw_query_bo_switch_commit(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct vmw_resource *ctx ;
  struct vmw_resource *next_ctx ;
  int ret ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct vmw_resource *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  struct vmw_resource *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct list_head *__cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct list_head *__cil_tmp59 ;
  struct vmw_resource *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct ttm_buffer_object *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct ttm_buffer_object *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object *__cil_tmp79 ;
  bool __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct ttm_buffer_object **__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct ttm_buffer_object *__cil_tmp86 ;
  bool __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct ttm_buffer_object *__cil_tmp90 ;
  bool __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct ttm_buffer_object *__cil_tmp102 ;

  {
  __cil_tmp13 = (unsigned long )sw_context;
  __cil_tmp14 = __cil_tmp13 + 131240UL;
  __cil_tmp15 = *((struct list_head **)__cil_tmp14);
  __mptr = __cil_tmp15;
  __cil_tmp16 = (struct vmw_resource *)0;
  __cil_tmp17 = (unsigned long )__cil_tmp16;
  __cil_tmp18 = __cil_tmp17 + 80UL;
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
  __cil_tmp20 = (unsigned int )__cil_tmp19;
  __cil_tmp21 = (char *)__mptr;
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
  ctx = (struct vmw_resource *)__cil_tmp22;
  __cil_tmp23 = (unsigned long )ctx;
  __cil_tmp24 = __cil_tmp23 + 80UL;
  __cil_tmp25 = *((struct list_head **)__cil_tmp24);
  __mptr___0 = __cil_tmp25;
  __cil_tmp26 = (struct vmw_resource *)0;
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = __cil_tmp27 + 80UL;
  __cil_tmp29 = (struct list_head *)__cil_tmp28;
  __cil_tmp30 = (unsigned int )__cil_tmp29;
  __cil_tmp31 = (char *)__mptr___0;
  __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
  next_ctx = (struct vmw_resource *)__cil_tmp32;
  while (1) {
    __cil_tmp33 = (unsigned long )sw_context;
    __cil_tmp34 = __cil_tmp33 + 131240UL;
    __cil_tmp35 = (struct list_head *)__cil_tmp34;
    __cil_tmp36 = (unsigned long )__cil_tmp35;
    __cil_tmp37 = (unsigned long )ctx;
    __cil_tmp38 = __cil_tmp37 + 80UL;
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
    __cil_tmp40 = (unsigned long )__cil_tmp39;
    if (! (__cil_tmp40 != __cil_tmp36)) {
      goto while_break;
    }
    __cil_tmp41 = (unsigned long )ctx;
    __cil_tmp42 = __cil_tmp41 + 80UL;
    __cil_tmp43 = (struct list_head *)__cil_tmp42;
    list_del_init(__cil_tmp43);
    while (1) {
      __cil_tmp44 = (unsigned long )ctx;
      __cil_tmp45 = __cil_tmp44 + 64UL;
      __cil_tmp46 = (struct list_head *)__cil_tmp45;
      __cil_tmp47 = __cil_tmp46;
      tmp___7 = list_empty(__cil_tmp47);
      if (tmp___7) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
      __cil_tmp48 = (long )tmp___8;
      tmp___9 = ldv__builtin_expect(__cil_tmp48, 0L);
      if (tmp___9) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                               "i" (392), "i" (12UL));
          while (1) {

          }

          goto while_break___1;
        }
        while_break___1: ;
      }
      goto while_break___0;
    }
    while_break___0: 
    __cil_tmp49 = (unsigned long )ctx;
    __cil_tmp50 = __cil_tmp49 + 24UL;
    __cil_tmp51 = *((int *)__cil_tmp50);
    __cil_tmp52 = (uint32_t )__cil_tmp51;
    ret = vmw_fifo_emit_dummy_query(dev_priv, __cil_tmp52);
    __cil_tmp53 = ret != 0;
    __cil_tmp54 = ! __cil_tmp53;
    __cil_tmp55 = ! __cil_tmp54;
    __cil_tmp56 = (long )__cil_tmp55;
    tmp___10 = ldv__builtin_expect(__cil_tmp56, 0L);
    if (tmp___10) {
      drm_err("vmw_query_bo_switch_commit", "Out of fifo space for dummy query.\n");
    }
    ctx = next_ctx;
    __cil_tmp57 = (unsigned long )next_ctx;
    __cil_tmp58 = __cil_tmp57 + 80UL;
    __cil_tmp59 = *((struct list_head **)__cil_tmp58);
    __mptr___1 = __cil_tmp59;
    __cil_tmp60 = (struct vmw_resource *)0;
    __cil_tmp61 = (unsigned long )__cil_tmp60;
    __cil_tmp62 = __cil_tmp61 + 80UL;
    __cil_tmp63 = (struct list_head *)__cil_tmp62;
    __cil_tmp64 = (unsigned int )__cil_tmp63;
    __cil_tmp65 = (char *)__mptr___1;
    __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
    next_ctx = (struct vmw_resource *)__cil_tmp66;
  }
  while_break: 
  __cil_tmp67 = (unsigned long )sw_context;
  __cil_tmp68 = __cil_tmp67 + 131256UL;
  __cil_tmp69 = *((struct ttm_buffer_object **)__cil_tmp68);
  __cil_tmp70 = (unsigned long )__cil_tmp69;
  __cil_tmp71 = (unsigned long )dev_priv;
  __cil_tmp72 = __cil_tmp71 + 134752UL;
  __cil_tmp73 = *((struct ttm_buffer_object **)__cil_tmp72);
  __cil_tmp74 = (unsigned long )__cil_tmp73;
  if (__cil_tmp74 != __cil_tmp70) {
    __cil_tmp75 = (unsigned long )dev_priv;
    __cil_tmp76 = __cil_tmp75 + 134752UL;
    if (*((struct ttm_buffer_object **)__cil_tmp76)) {
      __cil_tmp77 = (unsigned long )dev_priv;
      __cil_tmp78 = __cil_tmp77 + 134752UL;
      __cil_tmp79 = *((struct ttm_buffer_object **)__cil_tmp78);
      __cil_tmp80 = (bool )0;
      vmw_bo_pin(__cil_tmp79, __cil_tmp80);
      __cil_tmp81 = (unsigned long )dev_priv;
      __cil_tmp82 = __cil_tmp81 + 134752UL;
      __cil_tmp83 = (struct ttm_buffer_object **)__cil_tmp82;
      ttm_bo_unref(__cil_tmp83);
    }
    __cil_tmp84 = (unsigned long )sw_context;
    __cil_tmp85 = __cil_tmp84 + 131256UL;
    __cil_tmp86 = *((struct ttm_buffer_object **)__cil_tmp85);
    __cil_tmp87 = (bool )1;
    vmw_bo_pin(__cil_tmp86, __cil_tmp87);
    __cil_tmp88 = (unsigned long )dev_priv;
    __cil_tmp89 = __cil_tmp88 + 134744UL;
    __cil_tmp90 = *((struct ttm_buffer_object **)__cil_tmp89);
    __cil_tmp91 = (bool )1;
    vmw_bo_pin(__cil_tmp90, __cil_tmp91);
    __cil_tmp92 = (unsigned long )dev_priv;
    __cil_tmp93 = __cil_tmp92 + 134764UL;
    *((bool *)__cil_tmp93) = (bool )1;
    __cil_tmp94 = (unsigned long )dev_priv;
    __cil_tmp95 = __cil_tmp94 + 134760UL;
    __cil_tmp96 = (unsigned long )sw_context;
    __cil_tmp97 = __cil_tmp96 + 131264UL;
    *((uint32_t *)__cil_tmp95) = *((uint32_t *)__cil_tmp97);
    __cil_tmp98 = (unsigned long )dev_priv;
    __cil_tmp99 = __cil_tmp98 + 134752UL;
    __cil_tmp100 = (unsigned long )sw_context;
    __cil_tmp101 = __cil_tmp100 + 131256UL;
    __cil_tmp102 = *((struct ttm_buffer_object **)__cil_tmp101);
    *((struct ttm_buffer_object **)__cil_tmp99) = ttm_bo_reference(__cil_tmp102);
  }
  return;
}
}
static void vmw_query_switch_backoff(struct vmw_sw_context *sw_context ) 
{ struct list_head *list ;
  struct list_head *next ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct list_head *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  __cil_tmp4 = (unsigned long )sw_context;
  __cil_tmp5 = __cil_tmp4 + 131240UL;
  list = *((struct list_head **)__cil_tmp5);
  next = *((struct list_head **)list);
  while (1) {
    __cil_tmp6 = (unsigned long )sw_context;
    __cil_tmp7 = __cil_tmp6 + 131240UL;
    __cil_tmp8 = (struct list_head *)__cil_tmp7;
    __cil_tmp9 = (unsigned long )__cil_tmp8;
    __cil_tmp10 = (unsigned long )list;
    if (! (__cil_tmp10 != __cil_tmp9)) {
      goto while_break;
    }
    list_del_init(list);
    list = next;
    next = *((struct list_head **)list);
  }
  while_break: ;
  return;
}
}
static int vmw_translate_guest_ptr(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                   SVGAGuestPtr *ptr , struct vmw_dma_buffer **vmw_bo_p ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  uint32_t handle ;
  struct vmw_relocation *reloc ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  long tmp___10 ;
  struct vmw_dma_buffer **__cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct ttm_object_file *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct vmw_dma_buffer **__cil_tmp23 ;
  struct vmw_dma_buffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  uint32_t *__cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  long __cil_tmp50 ;
  struct vmw_dma_buffer **__cil_tmp51 ;
  void *__cil_tmp52 ;

  {
  __cil_tmp14 = & vmw_bo;
  __cil_tmp15 = (void *)0;
  *__cil_tmp14 = (struct vmw_dma_buffer *)__cil_tmp15;
  handle = *((uint32 *)ptr);
  __cil_tmp16 = (unsigned long )sw_context;
  __cil_tmp17 = __cil_tmp16 + 88UL;
  __cil_tmp18 = *((struct ttm_object_file **)__cil_tmp17);
  ret = vmw_user_dmabuf_lookup(__cil_tmp18, handle, & vmw_bo);
  __cil_tmp19 = ret != 0;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    drm_err("vmw_translate_guest_ptr", "Could not find or use GMR region.\n");
    return (-22);
  }
  __cil_tmp23 = & vmw_bo;
  __cil_tmp24 = *__cil_tmp23;
  bo = (struct ttm_buffer_object *)__cil_tmp24;
  __cil_tmp25 = (unsigned long )sw_context;
  __cil_tmp26 = __cil_tmp25 + 32880UL;
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
  __cil_tmp28 = __cil_tmp27 >= 2048U;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___8) {
    drm_err("vmw_translate_guest_ptr", "Max number relocations per submission exceeded\n");
    ret = -22;
    goto out_no_reloc;
  }
  __cil_tmp32 = (unsigned long )sw_context;
  __cil_tmp33 = __cil_tmp32 + 32880UL;
  tmp___9 = *((uint32_t *)__cil_tmp33);
  __cil_tmp34 = (unsigned long )sw_context;
  __cil_tmp35 = __cil_tmp34 + 32880UL;
  __cil_tmp36 = (unsigned long )sw_context;
  __cil_tmp37 = __cil_tmp36 + 32880UL;
  __cil_tmp38 = *((uint32_t *)__cil_tmp37);
  *((uint32_t *)__cil_tmp35) = __cil_tmp38 + 1U;
  __cil_tmp39 = (unsigned long )tmp___9 * 16UL;
  __cil_tmp40 = 112UL + __cil_tmp39;
  __cil_tmp41 = (unsigned long )sw_context;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  reloc = (struct vmw_relocation *)__cil_tmp42;
  *((SVGAGuestPtr **)reloc) = ptr;
  __cil_tmp43 = (uint32_t )1;
  __cil_tmp44 = (unsigned long )reloc;
  __cil_tmp45 = __cil_tmp44 + 8UL;
  __cil_tmp46 = (uint32_t *)__cil_tmp45;
  ret = vmw_bo_to_validate_list(sw_context, bo, __cil_tmp43, __cil_tmp46);
  __cil_tmp47 = ret != 0;
  __cil_tmp48 = ! __cil_tmp47;
  __cil_tmp49 = ! __cil_tmp48;
  __cil_tmp50 = (long )__cil_tmp49;
  tmp___10 = ldv__builtin_expect(__cil_tmp50, 0L);
  if (tmp___10) {
    goto out_no_reloc;
  }
  __cil_tmp51 = & vmw_bo;
  *vmw_bo_p = *__cil_tmp51;
  return (0);
  out_no_reloc: 
  vmw_dmabuf_unreference(& vmw_bo);
  __cil_tmp52 = (void *)0;
  vmw_bo_p = (struct vmw_dma_buffer **)__cil_tmp52;
  return (ret);
}
}
static int vmw_cmd_end_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  struct vmw_query_cmd *__cil_tmp10 ;
  SVGA3dCmdHeader *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  SVGAGuestPtr *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32 __cil_tmp29 ;
  struct vmw_dma_buffer **__cil_tmp30 ;
  struct vmw_dma_buffer *__cil_tmp31 ;
  struct ttm_buffer_object *__cil_tmp32 ;

  {
  __mptr = header;
  __cil_tmp10 = (struct vmw_query_cmd *)0;
  __cil_tmp11 = (SVGA3dCmdHeader *)__cil_tmp10;
  __cil_tmp12 = (unsigned int )__cil_tmp11;
  __cil_tmp13 = (char *)__mptr;
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
  cmd = (struct vmw_query_cmd *)__cil_tmp14;
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
  __cil_tmp15 = ret != 0;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp19 = 16;
  __cil_tmp20 = (unsigned long )cmd;
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
  __cil_tmp22 = (SVGAGuestPtr *)__cil_tmp21;
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp22, & vmw_bo);
  __cil_tmp23 = ret != 0;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  if (tmp___8) {
    return (ret);
  }
  __cil_tmp27 = (unsigned long )cmd;
  __cil_tmp28 = __cil_tmp27 + 8UL;
  __cil_tmp29 = *((uint32 *)__cil_tmp28);
  __cil_tmp30 = & vmw_bo;
  __cil_tmp31 = *__cil_tmp30;
  __cil_tmp32 = (struct ttm_buffer_object *)__cil_tmp31;
  ret = vmw_query_bo_switch_prepare(dev_priv, __cil_tmp29, __cil_tmp32, sw_context);
  vmw_dmabuf_unreference(& vmw_bo);
  return (ret);
}
}
static int vmw_cmd_wait_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd___0 *cmd ;
  int ret ;
  struct vmw_resource *ctx ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct vmw_query_cmd___0 *__cil_tmp12 ;
  SVGA3dCmdHeader *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  SVGAGuestPtr *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;

  {
  __mptr = header;
  __cil_tmp12 = (struct vmw_query_cmd___0 *)0;
  __cil_tmp13 = (SVGA3dCmdHeader *)__cil_tmp12;
  __cil_tmp14 = (unsigned int )__cil_tmp13;
  __cil_tmp15 = (char *)__mptr;
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
  cmd = (struct vmw_query_cmd___0 *)__cil_tmp16;
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
  __cil_tmp17 = ret != 0;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp21 = 16;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  __cil_tmp24 = (SVGAGuestPtr *)__cil_tmp23;
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp24, & vmw_bo);
  __cil_tmp25 = ret != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___8) {
    return (ret);
  }
  vmw_dmabuf_unreference(& vmw_bo);
  __cil_tmp29 = (unsigned long )sw_context;
  __cil_tmp30 = __cil_tmp29 + 64UL;
  ctx = *((struct vmw_resource **)__cil_tmp30);
  __cil_tmp31 = (unsigned long )ctx;
  __cil_tmp32 = __cil_tmp31 + 80UL;
  __cil_tmp33 = (struct list_head *)__cil_tmp32;
  __cil_tmp34 = __cil_tmp33;
  tmp___9 = list_empty(__cil_tmp34);
  if (! tmp___9) {
    __cil_tmp35 = (unsigned long )ctx;
    __cil_tmp36 = __cil_tmp35 + 80UL;
    __cil_tmp37 = (struct list_head *)__cil_tmp36;
    list_del_init(__cil_tmp37);
  }
  return (0);
}
}
static int vmw_cmd_dma(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                       SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  struct vmw_surface *srf ;
  struct vmw_dma_cmd *cmd ;
  int ret ;
  struct vmw_resource *res ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  struct vmw_dma_buffer **__cil_tmp13 ;
  void *__cil_tmp14 ;
  struct vmw_surface **__cil_tmp15 ;
  void *__cil_tmp16 ;
  struct vmw_dma_cmd *__cil_tmp17 ;
  SVGA3dCmdHeader *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  SVGAGuestPtr *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  struct vmw_dma_buffer **__cil_tmp29 ;
  struct vmw_dma_buffer *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct ttm_object_file *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32 __cil_tmp37 ;
  struct vmw_surface **__cil_tmp38 ;
  struct vmw_surface *__cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct vmw_surface **__cil_tmp48 ;
  struct vmw_surface *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  int __cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  struct vmw_surface *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct ttm_object_file *__cil_tmp57 ;
  struct vmw_resource **__cil_tmp58 ;
  struct vmw_surface **__cil_tmp59 ;
  struct vmw_surface *__cil_tmp60 ;

  {
  __cil_tmp13 = & vmw_bo;
  __cil_tmp14 = (void *)0;
  *__cil_tmp13 = (struct vmw_dma_buffer *)__cil_tmp14;
  __cil_tmp15 = & srf;
  __cil_tmp16 = (void *)0;
  *__cil_tmp15 = (struct vmw_surface *)__cil_tmp16;
  __mptr = header;
  __cil_tmp17 = (struct vmw_dma_cmd *)0;
  __cil_tmp18 = (SVGA3dCmdHeader *)__cil_tmp17;
  __cil_tmp19 = (unsigned int )__cil_tmp18;
  __cil_tmp20 = (char *)__mptr;
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
  cmd = (struct vmw_dma_cmd *)__cil_tmp21;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 + 8UL;
  __cil_tmp24 = (SVGAGuestPtr *)__cil_tmp23;
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp24, & vmw_bo);
  __cil_tmp25 = ret != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp29 = & vmw_bo;
  __cil_tmp30 = *__cil_tmp29;
  bo = (struct ttm_buffer_object *)__cil_tmp30;
  __cil_tmp31 = (unsigned long )sw_context;
  __cil_tmp32 = __cil_tmp31 + 88UL;
  __cil_tmp33 = *((struct ttm_object_file **)__cil_tmp32);
  __cil_tmp34 = 20;
  __cil_tmp35 = (unsigned long )cmd;
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
  __cil_tmp37 = *((uint32 *)__cil_tmp36);
  ret = vmw_user_surface_lookup_handle(dev_priv, __cil_tmp33, __cil_tmp37, & srf);
  if (ret) {
    drm_err("vmw_cmd_dma", "could not find surface\n");
    goto out_no_reloc;
  }
  __cil_tmp38 = & srf;
  __cil_tmp39 = *__cil_tmp38;
  ret = vmw_surface_validate(dev_priv, __cil_tmp39);
  __cil_tmp40 = ret != 0;
  __cil_tmp41 = ! __cil_tmp40;
  __cil_tmp42 = ! __cil_tmp41;
  __cil_tmp43 = (long )__cil_tmp42;
  tmp___8 = ldv__builtin_expect(__cil_tmp43, 0L);
  if (tmp___8) {
    if (ret != -512) {
      drm_err("vmw_cmd_dma", "Culd not validate surface.\n");
    }
    goto out_no_validate;
  }
  __cil_tmp44 = 20;
  __cil_tmp45 = (unsigned long )cmd;
  __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
  __cil_tmp47 = 24;
  __cil_tmp48 = & srf;
  __cil_tmp49 = *__cil_tmp48;
  __cil_tmp50 = (unsigned long )__cil_tmp49;
  __cil_tmp51 = __cil_tmp50 + __cil_tmp47;
  __cil_tmp52 = *((int *)__cil_tmp51);
  *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp52;
  __cil_tmp53 = & srf;
  __cil_tmp54 = *__cil_tmp53;
  __cil_tmp55 = (unsigned long )sw_context;
  __cil_tmp56 = __cil_tmp55 + 88UL;
  __cil_tmp57 = *((struct ttm_object_file **)__cil_tmp56);
  vmw_kms_cursor_snoop(__cil_tmp54, __cil_tmp57, bo, header);
  vmw_dmabuf_unreference(& vmw_bo);
  __cil_tmp58 = & res;
  __cil_tmp59 = & srf;
  __cil_tmp60 = *__cil_tmp59;
  *__cil_tmp58 = (struct vmw_resource *)__cil_tmp60;
  vmw_resource_to_validate_list(sw_context, & res);
  return (0);
  out_no_validate: 
  vmw_surface_unreference(& srf);
  out_no_reloc: 
  vmw_dmabuf_unreference(& vmw_bo);
  return (ret);
}
}
static int vmw_cmd_draw(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                        SVGA3dCmdHeader *header ) 
{ struct vmw_draw_cmd *cmd ;
  SVGA3dVertexDecl *decl ;
  SVGA3dPrimitiveRange *range ;
  uint32_t i ;
  uint32_t maxnum ;
  int ret ;
  long tmp___7 ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  struct vmw_draw_cmd *__cil_tmp22 ;
  SVGA3dCmdHeader *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32 __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  uint32 __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32 __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32 *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32 __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32 __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  uint32 __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  uint32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  uint32 *__cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  long __cil_tmp83 ;

  {
  __cil_tmp16 = (unsigned long )header;
  __cil_tmp17 = __cil_tmp16 + 20UL;
  decl = (SVGA3dVertexDecl *)__cil_tmp17;
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
  __cil_tmp18 = ret != 0;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = (long )__cil_tmp20;
  tmp___7 = ldv__builtin_expect(__cil_tmp21, 0L);
  if (tmp___7) {
    return (ret);
  }
  __mptr = header;
  __cil_tmp22 = (struct vmw_draw_cmd *)0;
  __cil_tmp23 = (SVGA3dCmdHeader *)__cil_tmp22;
  __cil_tmp24 = (unsigned int )__cil_tmp23;
  __cil_tmp25 = (char *)__mptr;
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
  cmd = (struct vmw_draw_cmd *)__cil_tmp26;
  __cil_tmp27 = (unsigned long )header;
  __cil_tmp28 = __cil_tmp27 + 4UL;
  __cil_tmp29 = *((uint32 *)__cil_tmp28);
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  __cil_tmp31 = __cil_tmp30 - 12UL;
  __cil_tmp32 = __cil_tmp31 / 36UL;
  maxnum = (uint32_t )__cil_tmp32;
  __cil_tmp33 = 12;
  __cil_tmp34 = (unsigned long )cmd;
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
  __cil_tmp36 = *((uint32 *)__cil_tmp35);
  __cil_tmp37 = __cil_tmp36 > maxnum;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___8 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___8) {
    drm_err("vmw_cmd_draw", "Illegal number of vertex declarations.\n");
    return (-22);
  }
  i = (uint32_t )0;
  while (1) {
    __cil_tmp41 = 12;
    __cil_tmp42 = (unsigned long )cmd;
    __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
    __cil_tmp44 = *((uint32 *)__cil_tmp43);
    if (! (i < __cil_tmp44)) {
      goto while_break;
    }
    __cil_tmp45 = (unsigned long )decl;
    __cil_tmp46 = __cil_tmp45 + 16UL;
    __cil_tmp47 = (uint32 *)__cil_tmp46;
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp47);
    __cil_tmp48 = ret != 0;
    __cil_tmp49 = ! __cil_tmp48;
    __cil_tmp50 = ! __cil_tmp49;
    __cil_tmp51 = (long )__cil_tmp50;
    tmp___9 = ldv__builtin_expect(__cil_tmp51, 0L);
    if (tmp___9) {
      return (ret);
    }
    i ++;
    decl ++;
  }
  while_break: 
  __cil_tmp52 = 12;
  __cil_tmp53 = (unsigned long )cmd;
  __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
  __cil_tmp55 = *((uint32 *)__cil_tmp54);
  __cil_tmp56 = (unsigned long )__cil_tmp55;
  __cil_tmp57 = __cil_tmp56 * 36UL;
  __cil_tmp58 = (unsigned long )header;
  __cil_tmp59 = __cil_tmp58 + 4UL;
  __cil_tmp60 = *((uint32 *)__cil_tmp59);
  __cil_tmp61 = (unsigned long )__cil_tmp60;
  __cil_tmp62 = __cil_tmp61 - 12UL;
  __cil_tmp63 = __cil_tmp62 - __cil_tmp57;
  __cil_tmp64 = __cil_tmp63 / 28UL;
  maxnum = (uint32_t )__cil_tmp64;
  __cil_tmp65 = 16;
  __cil_tmp66 = (unsigned long )cmd;
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
  __cil_tmp68 = *((uint32 *)__cil_tmp67);
  __cil_tmp69 = __cil_tmp68 > maxnum;
  __cil_tmp70 = ! __cil_tmp69;
  __cil_tmp71 = ! __cil_tmp70;
  __cil_tmp72 = (long )__cil_tmp71;
  tmp___10 = ldv__builtin_expect(__cil_tmp72, 0L);
  if (tmp___10) {
    drm_err("vmw_cmd_draw", "Illegal number of index ranges.\n");
    return (-22);
  }
  range = (SVGA3dPrimitiveRange *)decl;
  i = (uint32_t )0;
  while (1) {
    __cil_tmp73 = 16;
    __cil_tmp74 = (unsigned long )cmd;
    __cil_tmp75 = __cil_tmp74 + __cil_tmp73;
    __cil_tmp76 = *((uint32 *)__cil_tmp75);
    if (! (i < __cil_tmp76)) {
      goto while_break___0;
    }
    __cil_tmp77 = (unsigned long )range;
    __cil_tmp78 = __cil_tmp77 + 8UL;
    __cil_tmp79 = (uint32 *)__cil_tmp78;
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp79);
    __cil_tmp80 = ret != 0;
    __cil_tmp81 = ! __cil_tmp80;
    __cil_tmp82 = ! __cil_tmp81;
    __cil_tmp83 = (long )__cil_tmp82;
    tmp___11 = ldv__builtin_expect(__cil_tmp83, 0L);
    if (tmp___11) {
      return (ret);
    }
    i ++;
    range ++;
  }
  while_break___0: ;
  return (0);
}
}
static int vmw_cmd_tex_state(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ SVGA3dTextureState *last_state ;
  SVGA3dTextureState *cur_state ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32 __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  SVGA3dTextureStateName __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 *__cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;

  {
  __cil_tmp10 = (unsigned long )header;
  __cil_tmp11 = __cil_tmp10 + 4UL;
  __cil_tmp12 = *((uint32 *)__cil_tmp11);
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = (unsigned long )header;
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
  __cil_tmp16 = __cil_tmp15 + 8UL;
  last_state = (SVGA3dTextureState *)__cil_tmp16;
  __cil_tmp17 = (unsigned long )header;
  __cil_tmp18 = __cil_tmp17 + 12UL;
  cur_state = (SVGA3dTextureState *)__cil_tmp18;
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
  __cil_tmp19 = ret != 0;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    return (ret);
  }
  while (1) {
    __cil_tmp23 = (unsigned long )last_state;
    __cil_tmp24 = (unsigned long )cur_state;
    if (! (__cil_tmp24 < __cil_tmp23)) {
      goto while_break;
    }
    __cil_tmp25 = (unsigned long )cur_state;
    __cil_tmp26 = __cil_tmp25 + 4UL;
    __cil_tmp27 = *((SVGA3dTextureStateName *)__cil_tmp26);
    __cil_tmp28 = (unsigned int )__cil_tmp27;
    __cil_tmp29 = __cil_tmp28 != 1U;
    __cil_tmp30 = ! __cil_tmp29;
    __cil_tmp31 = ! __cil_tmp30;
    __cil_tmp32 = (long )__cil_tmp31;
    tmp___8 = ldv__builtin_expect(__cil_tmp32, 1L);
    if (tmp___8) {
      goto __Cont;
    }
    __cil_tmp33 = (unsigned long )cur_state;
    __cil_tmp34 = __cil_tmp33 + 8UL;
    __cil_tmp35 = (uint32 *)__cil_tmp34;
    ret = vmw_cmd_sid_check(dev_priv, sw_context, __cil_tmp35);
    __cil_tmp36 = ret != 0;
    __cil_tmp37 = ! __cil_tmp36;
    __cil_tmp38 = ! __cil_tmp37;
    __cil_tmp39 = (long )__cil_tmp38;
    tmp___9 = ldv__builtin_expect(__cil_tmp39, 0L);
    if (tmp___9) {
      return (ret);
    }
    __Cont: 
    cur_state ++;
  }
  while_break: ;
  return (0);
}
}
static int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      void *buf ) 
{ struct vmw_dma_buffer *vmw_bo ;
  int ret ;
  struct __anonstruct_cmd_429 *cmd ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  SVGAGuestPtr *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;

  {
  cmd = (struct __anonstruct_cmd_429 *)buf;
  __cil_tmp8 = (unsigned long )cmd;
  __cil_tmp9 = __cil_tmp8 + 4UL;
  __cil_tmp10 = (SVGAGuestPtr *)__cil_tmp9;
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, __cil_tmp10, & vmw_bo);
  __cil_tmp11 = ret != 0;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp___7) {
    return (ret);
  }
  vmw_dmabuf_unreference(& vmw_bo);
  return (ret);
}
}
static int vmw_cmd_check_not_3d(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                void *buf , uint32_t *size ) 
{ uint32_t size_remaining ;
  uint32_t cmd_id ;
  long tmp___7 ;
  int tmp___8 ;
  uint32_t *__cil_tmp9 ;
  uint32_t *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;

  {
  size_remaining = *size;
  __cil_tmp9 = (uint32_t *)buf;
  __cil_tmp10 = __cil_tmp9 + 0;
  cmd_id = *__cil_tmp10;
  if ((int )cmd_id == 1) {
    goto case_1;
  } else
  if ((int )cmd_id == 36) {
    goto case_36;
  } else
  if ((int )cmd_id == 37) {
    goto case_37;
  } else
  if ((int )cmd_id == 38) {
    goto case_38;
  } else {
    goto switch_default;
    if (0) {
      case_1: 
      __cil_tmp11 = 20UL;
      *size = (uint32_t )__cil_tmp11;
      goto switch_break;
      case_36: 
      __cil_tmp12 = 20UL;
      *size = (uint32_t )__cil_tmp12;
      goto switch_break;
      case_37: 
      __cil_tmp13 = 32UL;
      *size = (uint32_t )__cil_tmp13;
      goto switch_break;
      case_38: 
      __cil_tmp14 = 32UL;
      *size = (uint32_t )__cil_tmp14;
      goto switch_break;
      switch_default: 
      drm_err("vmw_cmd_check_not_3d", "Unsupported SVGA command: %u.\n", cmd_id);
      return (-22);
    } else {
      switch_break: ;
    }
  }
  __cil_tmp15 = *size;
  if (__cil_tmp15 > size_remaining) {
    drm_err("vmw_cmd_check_not_3d", "Invalid SVGA command (size mismatch): %u.\n",
            cmd_id);
    return (-22);
  }
  __cil_tmp16 = (unsigned long )sw_context;
  __cil_tmp17 = __cil_tmp16 + 61UL;
  __cil_tmp18 = *((bool *)__cil_tmp17);
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    drm_err("vmw_cmd_check_not_3d", "Kernel only SVGA command: %u.\n", cmd_id);
    return (-1);
  }
  if (cmd_id == 36U) {
    tmp___8 = vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);
    return (tmp___8);
  }
  return (0);
}
}
static vmw_cmd_func vmw_cmd_funcs[1082]  = 
  {      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_surface_copy_check,      & vmw_cmd_stretch_blt_check, 
        & vmw_cmd_dma,      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_set_render_target_check,      & vmw_cmd_tex_state, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_present_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_draw, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_end_query,      & vmw_cmd_wait_query, 
        & vmw_cmd_ok,      & vmw_cmd_blt_surf_screen_check};
static int vmw_cmd_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                         void *buf , uint32_t *size ) 
{ uint32_t cmd_id ;
  uint32_t size_remaining ;
  SVGA3dCmdHeader *header ;
  int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  uint32_t *__cil_tmp14 ;
  uint32_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int (*__cil_tmp36)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * ) ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;

  {
  size_remaining = *size;
  header = (SVGA3dCmdHeader *)buf;
  __cil_tmp14 = (uint32_t *)buf;
  __cil_tmp15 = __cil_tmp14 + 0;
  cmd_id = *__cil_tmp15;
  __cil_tmp16 = cmd_id < 43U;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = (long )__cil_tmp18;
  tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___8) {
    tmp___7 = vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);
    return (tmp___7);
  }
  cmd_id = *((uint32 *)header);
  __cil_tmp20 = (unsigned long )header;
  __cil_tmp21 = __cil_tmp20 + 4UL;
  __cil_tmp22 = *((uint32 *)__cil_tmp21);
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = __cil_tmp23 + 8UL;
  *size = (uint32_t )__cil_tmp24;
  cmd_id -= 1040U;
  __cil_tmp25 = *size;
  __cil_tmp26 = __cil_tmp25 > size_remaining;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___9) {
    goto out_err;
  }
  __cil_tmp30 = cmd_id >= 42U;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___10 = ldv__builtin_expect(__cil_tmp33, 0L);
  if (tmp___10) {
    goto out_err;
  }
  __cil_tmp34 = (unsigned long )cmd_id * 8UL;
  __cil_tmp35 = (unsigned long )(vmw_cmd_funcs) + __cil_tmp34;
  __cil_tmp36 = *((vmw_cmd_func *)__cil_tmp35);
  ret = (*__cil_tmp36)(dev_priv, sw_context, header);
  __cil_tmp37 = ret != 0;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___11) {
    goto out_err;
  }
  return (0);
  out_err: 
  __cil_tmp41 = cmd_id + 1040U;
  drm_err("vmw_cmd_check", "Illegal / Invalid SVGA3D command: %d\n", __cil_tmp41);
  return (-22);
}
}
static int vmw_cmd_check_all(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             void *buf , uint32_t size ) 
{ int32_t cur_size ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  uint32_t *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  uint32_t *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;

  {
  __cil_tmp9 = & size;
  __cil_tmp10 = *__cil_tmp9;
  cur_size = (int32_t )__cil_tmp10;
  while (1) {

    if (! (cur_size > 0)) {
      goto while_break;
    }
    __cil_tmp11 = & size;
    *__cil_tmp11 = (uint32_t )cur_size;
    ret = vmw_cmd_check(dev_priv, sw_context, buf, & size);
    __cil_tmp12 = ret != 0;
    __cil_tmp13 = ! __cil_tmp12;
    __cil_tmp14 = ! __cil_tmp13;
    __cil_tmp15 = (long )__cil_tmp14;
    tmp___7 = ldv__builtin_expect(__cil_tmp15, 0L);
    if (tmp___7) {
      return (ret);
    }
    __cil_tmp16 = & size;
    __cil_tmp17 = *__cil_tmp16;
    __cil_tmp18 = (unsigned long )__cil_tmp17;
    __cil_tmp19 = (unsigned long )buf;
    __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
    buf = (void *)__cil_tmp20;
    __cil_tmp21 = & size;
    __cil_tmp22 = *__cil_tmp21;
    __cil_tmp23 = (uint32_t )cur_size;
    __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
    cur_size = (int32_t )__cil_tmp24;
  }
  while_break: 
  __cil_tmp25 = cur_size != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___8) {
    drm_err("vmw_cmd_check_all", "Command verifier out of sync.\n");
    return (-22);
  }
  return (0);
}
}
static void vmw_free_relocations(struct vmw_sw_context *sw_context ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
  __cil_tmp2 = (unsigned long )sw_context;
  __cil_tmp3 = __cil_tmp2 + 32880UL;
  *((uint32_t *)__cil_tmp3) = (uint32_t )0;
  return;
}
}
static void vmw_apply_relocations(struct vmw_sw_context *sw_context ) 
{ uint32_t i ;
  struct vmw_relocation *reloc ;
  struct ttm_validate_buffer *validate ;
  struct ttm_buffer_object *bo ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  SVGAGuestPtr *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  SVGAGuestPtr *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  SVGAGuestPtr *__cil_tmp38 ;
  SVGAGuestPtr *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;

  {
  i = (uint32_t )0;
  while (1) {
    __cil_tmp6 = (unsigned long )sw_context;
    __cil_tmp7 = __cil_tmp6 + 32880UL;
    __cil_tmp8 = *((uint32_t *)__cil_tmp7);
    if (! (i < __cil_tmp8)) {
      goto while_break;
    }
    __cil_tmp9 = (unsigned long )i * 16UL;
    __cil_tmp10 = 112UL + __cil_tmp9;
    __cil_tmp11 = (unsigned long )sw_context;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    reloc = (struct vmw_relocation *)__cil_tmp12;
    __cil_tmp13 = (unsigned long )reloc;
    __cil_tmp14 = __cil_tmp13 + 8UL;
    __cil_tmp15 = *((uint32_t *)__cil_tmp14);
    __cil_tmp16 = (unsigned long )__cil_tmp15 * 48UL;
    __cil_tmp17 = 32888UL + __cil_tmp16;
    __cil_tmp18 = (unsigned long )sw_context;
    __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
    validate = (struct ttm_validate_buffer *)__cil_tmp19;
    __cil_tmp20 = (unsigned long )validate;
    __cil_tmp21 = __cil_tmp20 + 16UL;
    bo = *((struct ttm_buffer_object **)__cil_tmp21);
    __cil_tmp22 = 148;
    __cil_tmp23 = (unsigned long )bo;
    __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
    __cil_tmp25 = *((uint32_t *)__cil_tmp24);
    if (__cil_tmp25 == 2U) {
      __cil_tmp26 = *((SVGAGuestPtr **)reloc);
      __cil_tmp27 = (unsigned long )__cil_tmp26;
      __cil_tmp28 = __cil_tmp27 + 4UL;
      __cil_tmp29 = (unsigned long )bo;
      __cil_tmp30 = __cil_tmp29 + 368UL;
      __cil_tmp31 = *((unsigned long *)__cil_tmp30);
      __cil_tmp32 = *((SVGAGuestPtr **)reloc);
      __cil_tmp33 = (unsigned long )__cil_tmp32;
      __cil_tmp34 = __cil_tmp33 + 4UL;
      __cil_tmp35 = *((uint32 *)__cil_tmp34);
      __cil_tmp36 = (unsigned long )__cil_tmp35;
      __cil_tmp37 = __cil_tmp36 + __cil_tmp31;
      *((uint32 *)__cil_tmp28) = (uint32 )__cil_tmp37;
      __cil_tmp38 = *((SVGAGuestPtr **)reloc);
      *((uint32 *)__cil_tmp38) = (uint32 )-2;
    } else {
      __cil_tmp39 = *((SVGAGuestPtr **)reloc);
      __cil_tmp40 = 120;
      __cil_tmp41 = (unsigned long )bo;
      __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
      __cil_tmp43 = *((unsigned long *)__cil_tmp42);
      *((uint32 *)__cil_tmp39) = (uint32 )__cil_tmp43;
    }
    i ++;
  }
  while_break: 
  vmw_free_relocations(sw_context);
  return;
}
}
static void vmw_clear_validations(struct vmw_sw_context *sw_context ) 
{ struct ttm_validate_buffer *entry ;
  struct ttm_validate_buffer *next ;
  struct vmw_resource *res ;
  struct vmw_resource *res_next ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  long tmp___7 ;
  struct list_head *__mptr___2 ;
  struct list_head *__mptr___3 ;
  struct list_head *__mptr___4 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct ttm_validate_buffer *__cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct ttm_validate_buffer *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct ttm_buffer_object *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_buffer_object **__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  struct ttm_validate_buffer *__cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  struct vmw_resource **__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  struct vmw_resource **__cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  struct vmw_resource *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct list_head *__cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct list_head *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct vmw_resource **__cil_tmp88 ;
  struct vmw_resource *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  struct vmw_resource **__cil_tmp94 ;
  struct vmw_resource *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct list_head *__cil_tmp98 ;
  struct vmw_resource **__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct list_head *__cil_tmp102 ;
  struct vmw_resource *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct list_head *__cil_tmp106 ;
  unsigned int __cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;

  {
  __cil_tmp13 = (unsigned long )sw_context;
  __cil_tmp14 = __cil_tmp13 + 96UL;
  __cil_tmp15 = *((struct list_head **)__cil_tmp14);
  __mptr = __cil_tmp15;
  __cil_tmp16 = (struct ttm_validate_buffer *)0;
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
  __cil_tmp18 = (unsigned int )__cil_tmp17;
  __cil_tmp19 = (char *)__mptr;
  __cil_tmp20 = __cil_tmp19 - __cil_tmp18;
  entry = (struct ttm_validate_buffer *)__cil_tmp20;
  __cil_tmp21 = *((struct list_head **)entry);
  __mptr___0 = __cil_tmp21;
  __cil_tmp22 = (struct ttm_validate_buffer *)0;
  __cil_tmp23 = (struct list_head *)__cil_tmp22;
  __cil_tmp24 = (unsigned int )__cil_tmp23;
  __cil_tmp25 = (char *)__mptr___0;
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
  next = (struct ttm_validate_buffer *)__cil_tmp26;
  while (1) {
    __cil_tmp27 = (unsigned long )sw_context;
    __cil_tmp28 = __cil_tmp27 + 96UL;
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
    __cil_tmp30 = (unsigned long )__cil_tmp29;
    __cil_tmp31 = (struct list_head *)entry;
    __cil_tmp32 = (unsigned long )__cil_tmp31;
    if (! (__cil_tmp32 != __cil_tmp30)) {
      goto while_break;
    }
    __cil_tmp33 = (struct list_head *)entry;
    list_del(__cil_tmp33);
    __cil_tmp34 = (unsigned long )entry;
    __cil_tmp35 = __cil_tmp34 + 16UL;
    __cil_tmp36 = *((struct ttm_buffer_object **)__cil_tmp35);
    vmw_dmabuf_validate_clear(__cil_tmp36);
    __cil_tmp37 = (unsigned long )entry;
    __cil_tmp38 = __cil_tmp37 + 16UL;
    __cil_tmp39 = (struct ttm_buffer_object **)__cil_tmp38;
    ttm_bo_unref(__cil_tmp39);
    __cil_tmp40 = (unsigned long )sw_context;
    __cil_tmp41 = __cil_tmp40 + 131192UL;
    __cil_tmp42 = (unsigned long )sw_context;
    __cil_tmp43 = __cil_tmp42 + 131192UL;
    __cil_tmp44 = *((uint32_t *)__cil_tmp43);
    *((uint32_t *)__cil_tmp41) = __cil_tmp44 - 1U;
    entry = next;
    __cil_tmp45 = *((struct list_head **)next);
    __mptr___1 = __cil_tmp45;
    __cil_tmp46 = (struct ttm_validate_buffer *)0;
    __cil_tmp47 = (struct list_head *)__cil_tmp46;
    __cil_tmp48 = (unsigned int )__cil_tmp47;
    __cil_tmp49 = (char *)__mptr___1;
    __cil_tmp50 = __cil_tmp49 - __cil_tmp48;
    next = (struct ttm_validate_buffer *)__cil_tmp50;
  }
  while_break: ;
  while (1) {
    __cil_tmp51 = (unsigned long )sw_context;
    __cil_tmp52 = __cil_tmp51 + 131192UL;
    __cil_tmp53 = *((uint32_t *)__cil_tmp52);
    __cil_tmp54 = __cil_tmp53 != 0U;
    __cil_tmp55 = ! __cil_tmp54;
    __cil_tmp56 = ! __cil_tmp55;
    __cil_tmp57 = (long )__cil_tmp56;
    tmp___7 = ldv__builtin_expect(__cil_tmp57, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                             "i" (897), "i" (12UL));
        while (1) {

        }

        goto while_break___1;
      }
      while_break___1: ;
    }
    goto while_break___0;
  }
  while_break___0: 
  __cil_tmp58 = (unsigned long )sw_context;
  __cil_tmp59 = __cil_tmp58 + 131216UL;
  __cil_tmp60 = (struct list_head *)__cil_tmp59;
  vmw_resource_unreserve(__cil_tmp60);
  __cil_tmp61 = (unsigned long )sw_context;
  __cil_tmp62 = __cil_tmp61 + 131216UL;
  __cil_tmp63 = *((struct list_head **)__cil_tmp62);
  __mptr___2 = __cil_tmp63;
  __cil_tmp64 = & res;
  __cil_tmp65 = (struct vmw_resource *)0;
  __cil_tmp66 = (unsigned long )__cil_tmp65;
  __cil_tmp67 = __cil_tmp66 + 64UL;
  __cil_tmp68 = (struct list_head *)__cil_tmp67;
  __cil_tmp69 = (unsigned int )__cil_tmp68;
  __cil_tmp70 = (char *)__mptr___2;
  __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
  *__cil_tmp64 = (struct vmw_resource *)__cil_tmp71;
  __cil_tmp72 = & res;
  __cil_tmp73 = *__cil_tmp72;
  __cil_tmp74 = (unsigned long )__cil_tmp73;
  __cil_tmp75 = __cil_tmp74 + 64UL;
  __cil_tmp76 = *((struct list_head **)__cil_tmp75);
  __mptr___3 = __cil_tmp76;
  __cil_tmp77 = (struct vmw_resource *)0;
  __cil_tmp78 = (unsigned long )__cil_tmp77;
  __cil_tmp79 = __cil_tmp78 + 64UL;
  __cil_tmp80 = (struct list_head *)__cil_tmp79;
  __cil_tmp81 = (unsigned int )__cil_tmp80;
  __cil_tmp82 = (char *)__mptr___3;
  __cil_tmp83 = __cil_tmp82 - __cil_tmp81;
  res_next = (struct vmw_resource *)__cil_tmp83;
  while (1) {
    __cil_tmp84 = (unsigned long )sw_context;
    __cil_tmp85 = __cil_tmp84 + 131216UL;
    __cil_tmp86 = (struct list_head *)__cil_tmp85;
    __cil_tmp87 = (unsigned long )__cil_tmp86;
    __cil_tmp88 = & res;
    __cil_tmp89 = *__cil_tmp88;
    __cil_tmp90 = (unsigned long )__cil_tmp89;
    __cil_tmp91 = __cil_tmp90 + 64UL;
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
    __cil_tmp93 = (unsigned long )__cil_tmp92;
    if (! (__cil_tmp93 != __cil_tmp87)) {
      goto while_break___3;
    }
    __cil_tmp94 = & res;
    __cil_tmp95 = *__cil_tmp94;
    __cil_tmp96 = (unsigned long )__cil_tmp95;
    __cil_tmp97 = __cil_tmp96 + 64UL;
    __cil_tmp98 = (struct list_head *)__cil_tmp97;
    list_del_init(__cil_tmp98);
    vmw_resource_unreference(& res);
    __cil_tmp99 = & res;
    *__cil_tmp99 = res_next;
    __cil_tmp100 = (unsigned long )res_next;
    __cil_tmp101 = __cil_tmp100 + 64UL;
    __cil_tmp102 = *((struct list_head **)__cil_tmp101);
    __mptr___4 = __cil_tmp102;
    __cil_tmp103 = (struct vmw_resource *)0;
    __cil_tmp104 = (unsigned long )__cil_tmp103;
    __cil_tmp105 = __cil_tmp104 + 64UL;
    __cil_tmp106 = (struct list_head *)__cil_tmp105;
    __cil_tmp107 = (unsigned int )__cil_tmp106;
    __cil_tmp108 = (char *)__mptr___4;
    __cil_tmp109 = __cil_tmp108 - __cil_tmp107;
    res_next = (struct vmw_resource *)__cil_tmp109;
  }
  while_break___3: ;
  return;
}
}
static int vmw_validate_single_buffer(struct vmw_private *dev_priv , struct ttm_buffer_object *bo ) 
{ int ret ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ttm_buffer_object *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct ttm_buffer_object *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  bool __cil_tmp19 ;
  bool __cil_tmp20 ;
  long __cil_tmp21 ;
  bool __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 134752UL;
  __cil_tmp8 = *((struct ttm_buffer_object **)__cil_tmp7);
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = (unsigned long )bo;
  if (__cil_tmp10 == __cil_tmp9) {
    return (0);
  } else {
    __cil_tmp11 = (unsigned long )dev_priv;
    __cil_tmp12 = __cil_tmp11 + 134744UL;
    __cil_tmp13 = *((struct ttm_buffer_object **)__cil_tmp12);
    __cil_tmp14 = (unsigned long )__cil_tmp13;
    __cil_tmp15 = (unsigned long )bo;
    if (__cil_tmp15 == __cil_tmp14) {
      __cil_tmp16 = (unsigned long )dev_priv;
      __cil_tmp17 = __cil_tmp16 + 134764UL;
      if (*((bool *)__cil_tmp17)) {
        return (0);
      }
    }
  }
  __cil_tmp18 = (bool )1;
  __cil_tmp19 = (bool )0;
  __cil_tmp20 = (bool )0;
  ret = ttm_bo_validate(bo, & vmw_vram_gmr_placement, __cil_tmp18, __cil_tmp19, __cil_tmp20);
  if (ret == 0) {
    tmp___7 = 1;
  } else
  if (ret == -512) {
    tmp___7 = 1;
  } else {
    tmp___7 = 0;
  }
  __cil_tmp21 = (long )tmp___7;
  tmp___8 = ldv__builtin_expect(__cil_tmp21, 1L);
  if (tmp___8) {
    return (ret);
  }
  printk("<6>[drm] Falling through to VRAM.\n");
  __cil_tmp22 = (bool )1;
  __cil_tmp23 = (bool )0;
  __cil_tmp24 = (bool )0;
  ret = ttm_bo_validate(bo, & vmw_vram_placement, __cil_tmp22, __cil_tmp23, __cil_tmp24);
  return (ret);
}
}
static int vmw_validate_buffers(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct ttm_validate_buffer *entry ;
  int ret ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct ttm_validate_buffer *__cil_tmp11 ;
  struct list_head *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct ttm_buffer_object *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  struct ttm_validate_buffer *__cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  __cil_tmp8 = (unsigned long )sw_context;
  __cil_tmp9 = __cil_tmp8 + 96UL;
  __cil_tmp10 = *((struct list_head **)__cil_tmp9);
  __mptr = __cil_tmp10;
  __cil_tmp11 = (struct ttm_validate_buffer *)0;
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  __cil_tmp14 = (char *)__mptr;
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
  entry = (struct ttm_validate_buffer *)__cil_tmp15;
  while (1) {
    __cil_tmp16 = (unsigned long )sw_context;
    __cil_tmp17 = __cil_tmp16 + 96UL;
    __cil_tmp18 = (struct list_head *)__cil_tmp17;
    __cil_tmp19 = (unsigned long )__cil_tmp18;
    __cil_tmp20 = (struct list_head *)entry;
    __cil_tmp21 = (unsigned long )__cil_tmp20;
    if (! (__cil_tmp21 != __cil_tmp19)) {
      goto while_break;
    }
    __cil_tmp22 = (unsigned long )entry;
    __cil_tmp23 = __cil_tmp22 + 16UL;
    __cil_tmp24 = *((struct ttm_buffer_object **)__cil_tmp23);
    ret = vmw_validate_single_buffer(dev_priv, __cil_tmp24);
    __cil_tmp25 = ret != 0;
    __cil_tmp26 = ! __cil_tmp25;
    __cil_tmp27 = ! __cil_tmp26;
    __cil_tmp28 = (long )__cil_tmp27;
    tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
    if (tmp___7) {
      return (ret);
    }
    __cil_tmp29 = *((struct list_head **)entry);
    __mptr___0 = __cil_tmp29;
    __cil_tmp30 = (struct ttm_validate_buffer *)0;
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
    __cil_tmp32 = (unsigned int )__cil_tmp31;
    __cil_tmp33 = (char *)__mptr___0;
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
    entry = (struct ttm_validate_buffer *)__cil_tmp34;
  }
  while_break: ;
  return (0);
}
}
static int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context , uint32_t size ) 
{ long tmp___7 ;
  void *tmp___8 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  uint32_t __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  uint32_t *__cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  uint32_t *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;

  {
  __cil_tmp5 = (unsigned long )sw_context;
  __cil_tmp6 = __cil_tmp5 + 131208UL;
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
  __cil_tmp8 = __cil_tmp7 >= size;
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = ! __cil_tmp9;
  __cil_tmp11 = (long )__cil_tmp10;
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 1L);
  if (tmp___7) {
    return (0);
  }
  __cil_tmp12 = (unsigned long )sw_context;
  __cil_tmp13 = __cil_tmp12 + 131208UL;
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
  if (__cil_tmp14 == 0U) {
    __cil_tmp15 = (unsigned long )sw_context;
    __cil_tmp16 = __cil_tmp15 + 131208UL;
    *((uint32_t *)__cil_tmp16) = (uint32_t )32768;
  }
  while (1) {
    __cil_tmp17 = (unsigned long )sw_context;
    __cil_tmp18 = __cil_tmp17 + 131208UL;
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
    if (! (__cil_tmp19 < size)) {
      goto while_break;
    }
    __cil_tmp20 = (unsigned long )sw_context;
    __cil_tmp21 = __cil_tmp20 + 131208UL;
    __cil_tmp22 = 1UL << 12;
    __cil_tmp23 = (uint32_t )__cil_tmp22;
    __cil_tmp24 = __cil_tmp23 - 1U;
    __cil_tmp25 = ~ __cil_tmp24;
    __cil_tmp26 = 1UL << 12;
    __cil_tmp27 = (uint32_t )__cil_tmp26;
    __cil_tmp28 = __cil_tmp27 - 1U;
    __cil_tmp29 = (unsigned long )sw_context;
    __cil_tmp30 = __cil_tmp29 + 131208UL;
    __cil_tmp31 = *((uint32_t *)__cil_tmp30);
    __cil_tmp32 = __cil_tmp31 >> 1;
    __cil_tmp33 = (unsigned long )sw_context;
    __cil_tmp34 = __cil_tmp33 + 131208UL;
    __cil_tmp35 = *((uint32_t *)__cil_tmp34);
    __cil_tmp36 = __cil_tmp35 + __cil_tmp32;
    __cil_tmp37 = __cil_tmp36 + __cil_tmp28;
    *((uint32_t *)__cil_tmp21) = __cil_tmp37 & __cil_tmp25;
  }
  while_break: 
  __cil_tmp38 = (void *)0;
  __cil_tmp39 = (unsigned long )__cil_tmp38;
  __cil_tmp40 = (unsigned long )sw_context;
  __cil_tmp41 = __cil_tmp40 + 131200UL;
  __cil_tmp42 = *((uint32_t **)__cil_tmp41);
  __cil_tmp43 = (unsigned long )__cil_tmp42;
  if (__cil_tmp43 != __cil_tmp39) {
    __cil_tmp44 = (unsigned long )sw_context;
    __cil_tmp45 = __cil_tmp44 + 131200UL;
    __cil_tmp46 = *((uint32_t **)__cil_tmp45);
    __cil_tmp47 = (void *)__cil_tmp46;
    vfree(__cil_tmp47);
  }
  __cil_tmp48 = (unsigned long )sw_context;
  __cil_tmp49 = __cil_tmp48 + 131208UL;
  __cil_tmp50 = *((uint32_t *)__cil_tmp49);
  __cil_tmp51 = (unsigned long )__cil_tmp50;
  tmp___8 = vmalloc(__cil_tmp51);
  __cil_tmp52 = (unsigned long )sw_context;
  __cil_tmp53 = __cil_tmp52 + 131200UL;
  *((uint32_t **)__cil_tmp53) = (uint32_t *)tmp___8;
  __cil_tmp54 = (void *)0;
  __cil_tmp55 = (unsigned long )__cil_tmp54;
  __cil_tmp56 = (unsigned long )sw_context;
  __cil_tmp57 = __cil_tmp56 + 131200UL;
  __cil_tmp58 = *((uint32_t **)__cil_tmp57);
  __cil_tmp59 = (unsigned long )__cil_tmp58;
  if (__cil_tmp59 == __cil_tmp55) {
    drm_err("vmw_resize_cmd_bounce", "Failed to allocate command bounce buffer.\n");
    __cil_tmp60 = (unsigned long )sw_context;
    __cil_tmp61 = __cil_tmp60 + 131208UL;
    *((uint32_t *)__cil_tmp61) = (uint32_t )0;
    return (-12);
  }
  return (0);
}
}
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) 
{ uint32_t sequence ;
  int ret ;
  bool synced ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_fence_manager *__cil_tmp29 ;
  uint32_t *__cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct vmw_fence_manager *__cil_tmp35 ;
  uint32_t *__cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  long __cil_tmp39 ;
  bool __cil_tmp40 ;
  bool __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  bool __cil_tmp44 ;
  void *__cil_tmp45 ;

  {
  synced = (bool )0;
  while (1) {
    __cil_tmp13 = (void *)0;
    __cil_tmp14 = (unsigned long )__cil_tmp13;
    __cil_tmp15 = (unsigned long )p_handle;
    if (__cil_tmp15 != __cil_tmp14) {
      __cil_tmp16 = (void *)0;
      __cil_tmp17 = (unsigned long )__cil_tmp16;
      __cil_tmp18 = (unsigned long )file_priv;
      if (__cil_tmp18 == __cil_tmp17) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    __cil_tmp19 = (long )tmp___7;
    tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                             "i" (1011), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  ret = vmw_fifo_send_fence(dev_priv, & sequence);
  __cil_tmp20 = ret != 0;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = (long )__cil_tmp22;
  tmp___9 = ldv__builtin_expect(__cil_tmp23, 0L);
  if (tmp___9) {
    drm_err("vmw_execbuf_fence_commands", "Fence submission error. Syncing.\n");
    synced = (bool )1;
  }
  __cil_tmp24 = (void *)0;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = (unsigned long )p_handle;
  if (__cil_tmp26 != __cil_tmp25) {
    __cil_tmp27 = (unsigned long )dev_priv;
    __cil_tmp28 = __cil_tmp27 + 3008UL;
    __cil_tmp29 = *((struct vmw_fence_manager **)__cil_tmp28);
    __cil_tmp30 = & sequence;
    __cil_tmp31 = *__cil_tmp30;
    __cil_tmp32 = (uint32_t )1;
    ret = vmw_user_fence_create(file_priv, __cil_tmp29, __cil_tmp31, __cil_tmp32,
                                p_fence, p_handle);
  } else {
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 3008UL;
    __cil_tmp35 = *((struct vmw_fence_manager **)__cil_tmp34);
    __cil_tmp36 = & sequence;
    __cil_tmp37 = *__cil_tmp36;
    __cil_tmp38 = (uint32_t )1;
    ret = vmw_fence_create(__cil_tmp35, __cil_tmp37, __cil_tmp38, p_fence);
  }
  if (ret != 0) {
    if (! synced) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
  } else {
    tmp___10 = 0;
  }
  __cil_tmp39 = (long )tmp___10;
  tmp___11 = ldv__builtin_expect(__cil_tmp39, 0L);
  if (tmp___11) {
    __cil_tmp40 = (bool )0;
    __cil_tmp41 = (bool )0;
    __cil_tmp42 = & sequence;
    __cil_tmp43 = *__cil_tmp42;
    __cil_tmp44 = (bool )0;
    vmw_fallback_wait(dev_priv, __cil_tmp40, __cil_tmp41, __cil_tmp43, __cil_tmp44,
                      1250UL);
    __cil_tmp45 = (void *)0;
    *p_fence = (struct vmw_fence_obj *)__cil_tmp45;
  }
  return (0);
}
}
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) 
{ struct drm_vmw_fence_rep fence_rep ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  struct drm_vmw_fence_rep *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct vmw_fifo_state *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct ttm_object_file *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  enum ttm_ref_type __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  bool __cil_tmp49 ;
  bool __cil_tmp50 ;
  int tmp ;

  {
  __cil_tmp10 = (void *)0;
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = (unsigned long )user_fence_rep;
  if (__cil_tmp12 == __cil_tmp11) {
    return;
  }
  __cil_tmp13 = (void *)(& fence_rep);
  memset(__cil_tmp13, 0, 24UL);
  __cil_tmp14 = (unsigned long )(& fence_rep) + 20UL;
  *((int32_t *)__cil_tmp14) = ret;
  if (ret == 0) {
    while (1) {
      __cil_tmp15 = (void *)0;
      __cil_tmp16 = (unsigned long )__cil_tmp15;
      __cil_tmp17 = (unsigned long )fence;
      __cil_tmp18 = __cil_tmp17 == __cil_tmp16;
      __cil_tmp19 = ! __cil_tmp18;
      __cil_tmp20 = ! __cil_tmp19;
      __cil_tmp21 = (long )__cil_tmp20;
      tmp___7 = ldv__builtin_expect(__cil_tmp21, 0L);
      if (tmp___7) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.common.c"),
                               "i" (1076), "i" (12UL));
          while (1) {

          }

          goto while_break___0;
        }
        while_break___0: ;
      }
      goto while_break;
    }
    while_break: 
    __cil_tmp22 = & fence_rep;
    *((uint32_t *)__cil_tmp22) = fence_handle;
    __cil_tmp23 = (unsigned long )(& fence_rep) + 8UL;
    __cil_tmp24 = (unsigned long )fence;
    __cil_tmp25 = __cil_tmp24 + 4UL;
    *((uint32_t *)__cil_tmp23) = *((u32 *)__cil_tmp25);
    __cil_tmp26 = (unsigned long )dev_priv;
    __cil_tmp27 = __cil_tmp26 + 1856UL;
    __cil_tmp28 = (struct vmw_fifo_state *)__cil_tmp27;
    vmw_update_seqno(dev_priv, __cil_tmp28);
    __cil_tmp29 = (unsigned long )(& fence_rep) + 12UL;
    __cil_tmp30 = (unsigned long )dev_priv;
    __cil_tmp31 = __cil_tmp30 + 2980UL;
    *((uint32_t *)__cil_tmp29) = *((uint32_t *)__cil_tmp31);
  }
  __cil_tmp32 = (void *)user_fence_rep;
  __cil_tmp33 = (void *)(& fence_rep);
  __cil_tmp34 = 24U;
  tmp = (int )copy_to_user(__cil_tmp32, __cil_tmp33, __cil_tmp34);
  ret = tmp;
  __cil_tmp35 = ret != 0;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = (long )__cil_tmp37;
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 0L);
  if (tmp___8) {
    __cil_tmp39 = (unsigned long )(& fence_rep) + 20UL;
    __cil_tmp40 = *((int32_t *)__cil_tmp39);
    if (__cil_tmp40 == 0) {
      __cil_tmp41 = (unsigned long )vmw_fp;
      __cil_tmp42 = __cil_tmp41 + 8UL;
      __cil_tmp43 = *((struct ttm_object_file **)__cil_tmp42);
      __cil_tmp44 = (unsigned long )fence_handle;
      __cil_tmp45 = (enum ttm_ref_type )0;
      ttm_ref_object_base_unref(__cil_tmp43, __cil_tmp44, __cil_tmp45);
      drm_err("vmw_execbuf_copy_fence_user", "Fence copy error. Syncing.\n");
      __cil_tmp46 = (unsigned long )fence;
      __cil_tmp47 = __cil_tmp46 + 36UL;
      __cil_tmp48 = *((uint32_t *)__cil_tmp47);
      __cil_tmp49 = (bool )0;
      __cil_tmp50 = (bool )0;
      vmw_fence_obj_wait(fence, __cil_tmp48, __cil_tmp49, __cil_tmp50, 1250UL);
    }
  }
  return;
}
}
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) 
{ struct vmw_sw_context *sw_context ;
  struct vmw_fence_obj *fence ;
  uint32_t handle ;
  void *cmd ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long tmp___9 ;
  long tmp___10 ;
  struct vmw_fpriv *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___17 ;
  struct vmw_fpriv *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_fence_obj **__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  uint32_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct list_head *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct list_head *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  void *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct ttm_buffer_object *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct list_head *__cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  long __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  struct vmw_marker_queue *__cil_tmp123 ;
  uint32_t __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  long __cil_tmp128 ;
  void *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  long __cil_tmp135 ;
  void *__cil_tmp136 ;
  void *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct list_head *__cil_tmp140 ;
  struct vmw_fence_obj **__cil_tmp141 ;
  struct vmw_fence_obj *__cil_tmp142 ;
  void *__cil_tmp143 ;
  struct vmw_fence_obj **__cil_tmp144 ;
  struct vmw_fence_obj *__cil_tmp145 ;
  uint32_t *__cil_tmp146 ;
  uint32_t __cil_tmp147 ;
  void *__cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  long __cil_tmp154 ;
  struct vmw_fence_obj **__cil_tmp155 ;
  struct vmw_fence_obj **__cil_tmp156 ;
  void *__cil_tmp157 ;
  void *__cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct vmw_fence_obj **__cil_tmp160 ;
  struct vmw_fence_obj *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  int __cil_tmp165 ;
  long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  struct mutex *__cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  struct list_head *__cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  struct mutex *__cil_tmp175 ;
  int tmp ;
  unsigned long tmp___21 ;

  {
  __cil_tmp30 = (unsigned long )dev_priv;
  __cil_tmp31 = __cil_tmp30 + 3032UL;
  sw_context = (struct vmw_sw_context *)__cil_tmp31;
  __cil_tmp32 = & fence;
  __cil_tmp33 = (void *)0;
  *__cil_tmp32 = (struct vmw_fence_obj *)__cil_tmp33;
  __cil_tmp34 = (unsigned long )dev_priv;
  __cil_tmp35 = __cil_tmp34 + 134304UL;
  __cil_tmp36 = (struct mutex *)__cil_tmp35;
  tmp = (int )mutex_lock_interruptible(__cil_tmp36);
  ret = tmp;
  __cil_tmp37 = ret != 0;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___7 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___7) {
    return (-512);
  }
  __cil_tmp41 = (void *)0;
  __cil_tmp42 = (unsigned long )__cil_tmp41;
  __cil_tmp43 = (unsigned long )kernel_commands;
  if (__cil_tmp43 == __cil_tmp42) {
    __cil_tmp44 = (unsigned long )sw_context;
    __cil_tmp45 = __cil_tmp44 + 61UL;
    *((bool *)__cil_tmp45) = (bool )0;
    ret = vmw_resize_cmd_bounce(sw_context, command_size);
    __cil_tmp46 = ret != 0;
    __cil_tmp47 = ! __cil_tmp46;
    __cil_tmp48 = ! __cil_tmp47;
    __cil_tmp49 = (long )__cil_tmp48;
    tmp___8 = ldv__builtin_expect(__cil_tmp49, 0L);
    if (tmp___8) {
      goto out_unlock;
    }
    __cil_tmp50 = (unsigned long )sw_context;
    __cil_tmp51 = __cil_tmp50 + 131200UL;
    __cil_tmp52 = *((uint32_t **)__cil_tmp51);
    __cil_tmp53 = (void *)__cil_tmp52;
    __cil_tmp54 = user_commands;
    __cil_tmp55 = (unsigned long )command_size;
    tmp___21 = (unsigned long )copy_from_user(__cil_tmp53, __cil_tmp54, __cil_tmp55);
    tmp___9 = tmp___21;
    ret = (int )tmp___9;
    __cil_tmp56 = ret != 0;
    __cil_tmp57 = ! __cil_tmp56;
    __cil_tmp58 = ! __cil_tmp57;
    __cil_tmp59 = (long )__cil_tmp58;
    tmp___10 = ldv__builtin_expect(__cil_tmp59, 0L);
    if (tmp___10) {
      ret = -14;
      drm_err("vmw_execbuf_process", "Failed copying commands.\n");
      goto out_unlock;
    }
    __cil_tmp60 = (unsigned long )sw_context;
    __cil_tmp61 = __cil_tmp60 + 131200UL;
    __cil_tmp62 = *((uint32_t **)__cil_tmp61);
    kernel_commands = (void *)__cil_tmp62;
  } else {
    __cil_tmp63 = (unsigned long )sw_context;
    __cil_tmp64 = __cil_tmp63 + 61UL;
    *((bool *)__cil_tmp64) = (bool )1;
  }
  tmp___11 = vmw_fpriv(file_priv);
  __cil_tmp65 = (unsigned long )sw_context;
  __cil_tmp66 = __cil_tmp65 + 88UL;
  __cil_tmp67 = (unsigned long )tmp___11;
  __cil_tmp68 = __cil_tmp67 + 8UL;
  *((struct ttm_object_file **)__cil_tmp66) = *((struct ttm_object_file **)__cil_tmp68);
  __cil_tmp69 = (unsigned long )sw_context;
  __cil_tmp70 = __cil_tmp69 + 60UL;
  *((bool *)__cil_tmp70) = (bool )0;
  __cil_tmp71 = (unsigned long )sw_context;
  __cil_tmp72 = __cil_tmp71 + 80UL;
  *((bool *)__cil_tmp72) = (bool )0;
  __cil_tmp73 = (unsigned long )sw_context;
  __cil_tmp74 = __cil_tmp73 + 32880UL;
  *((uint32_t *)__cil_tmp74) = (uint32_t )0;
  __cil_tmp75 = (unsigned long )sw_context;
  __cil_tmp76 = __cil_tmp75 + 131192UL;
  *((uint32_t *)__cil_tmp76) = (uint32_t )0;
  __cil_tmp77 = (unsigned long )sw_context;
  __cil_tmp78 = __cil_tmp77 + 131232UL;
  *((uint32_t *)__cil_tmp78) = (uint32_t )0;
  __cil_tmp79 = (unsigned long )sw_context;
  __cil_tmp80 = __cil_tmp79 + 131240UL;
  __cil_tmp81 = (struct list_head *)__cil_tmp80;
  INIT_LIST_HEAD(__cil_tmp81);
  __cil_tmp82 = (unsigned long )sw_context;
  __cil_tmp83 = __cil_tmp82 + 131216UL;
  __cil_tmp84 = (struct list_head *)__cil_tmp83;
  INIT_LIST_HEAD(__cil_tmp84);
  __cil_tmp85 = (unsigned long )sw_context;
  __cil_tmp86 = __cil_tmp85 + 131256UL;
  __cil_tmp87 = (unsigned long )dev_priv;
  __cil_tmp88 = __cil_tmp87 + 134752UL;
  *((struct ttm_buffer_object **)__cil_tmp86) = *((struct ttm_buffer_object **)__cil_tmp88);
  __cil_tmp89 = (unsigned long )sw_context;
  __cil_tmp90 = __cil_tmp89 + 131264UL;
  __cil_tmp91 = (unsigned long )dev_priv;
  __cil_tmp92 = __cil_tmp91 + 134760UL;
  *((uint32_t *)__cil_tmp90) = *((uint32_t *)__cil_tmp92);
  __cil_tmp93 = (unsigned long )sw_context;
  __cil_tmp94 = __cil_tmp93 + 131268UL;
  __cil_tmp95 = (void *)0;
  __cil_tmp96 = (unsigned long )__cil_tmp95;
  __cil_tmp97 = (unsigned long )dev_priv;
  __cil_tmp98 = __cil_tmp97 + 134752UL;
  __cil_tmp99 = *((struct ttm_buffer_object **)__cil_tmp98);
  __cil_tmp100 = (unsigned long )__cil_tmp99;
  __cil_tmp101 = __cil_tmp100 != __cil_tmp96;
  *((bool *)__cil_tmp94) = (bool )__cil_tmp101;
  __cil_tmp102 = (unsigned long )sw_context;
  __cil_tmp103 = __cil_tmp102 + 96UL;
  __cil_tmp104 = (struct list_head *)__cil_tmp103;
  INIT_LIST_HEAD(__cil_tmp104);
  ret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands, command_size);
  __cil_tmp105 = ret != 0;
  __cil_tmp106 = ! __cil_tmp105;
  __cil_tmp107 = ! __cil_tmp106;
  __cil_tmp108 = (long )__cil_tmp107;
  tmp___12 = ldv__builtin_expect(__cil_tmp108, 0L);
  if (tmp___12) {
    goto out_err;
  }
  __cil_tmp109 = (unsigned long )sw_context;
  __cil_tmp110 = __cil_tmp109 + 96UL;
  __cil_tmp111 = (struct list_head *)__cil_tmp110;
  ret = ttm_eu_reserve_buffers(__cil_tmp111);
  __cil_tmp112 = ret != 0;
  __cil_tmp113 = ! __cil_tmp112;
  __cil_tmp114 = ! __cil_tmp113;
  __cil_tmp115 = (long )__cil_tmp114;
  tmp___13 = ldv__builtin_expect(__cil_tmp115, 0L);
  if (tmp___13) {
    goto out_err;
  }
  ret = vmw_validate_buffers(dev_priv, sw_context);
  __cil_tmp116 = ret != 0;
  __cil_tmp117 = ! __cil_tmp116;
  __cil_tmp118 = ! __cil_tmp117;
  __cil_tmp119 = (long )__cil_tmp118;
  tmp___14 = ldv__builtin_expect(__cil_tmp119, 0L);
  if (tmp___14) {
    goto out_err;
  }
  vmw_apply_relocations(sw_context);
  if (throttle_us) {
    __cil_tmp120 = 2016;
    __cil_tmp121 = (unsigned long )dev_priv;
    __cil_tmp122 = __cil_tmp121 + __cil_tmp120;
    __cil_tmp123 = (struct vmw_marker_queue *)__cil_tmp122;
    __cil_tmp124 = (uint32_t )throttle_us;
    ret = vmw_wait_lag(dev_priv, __cil_tmp123, __cil_tmp124);
    __cil_tmp125 = ret != 0;
    __cil_tmp126 = ! __cil_tmp125;
    __cil_tmp127 = ! __cil_tmp126;
    __cil_tmp128 = (long )__cil_tmp127;
    tmp___15 = ldv__builtin_expect(__cil_tmp128, 0L);
    if (tmp___15) {
      goto out_throttle;
    }
  }
  cmd = vmw_fifo_reserve(dev_priv, command_size);
  __cil_tmp129 = (void *)0;
  __cil_tmp130 = (unsigned long )__cil_tmp129;
  __cil_tmp131 = (unsigned long )cmd;
  __cil_tmp132 = __cil_tmp131 == __cil_tmp130;
  __cil_tmp133 = ! __cil_tmp132;
  __cil_tmp134 = ! __cil_tmp133;
  __cil_tmp135 = (long )__cil_tmp134;
  tmp___16 = ldv__builtin_expect(__cil_tmp135, 0L);
  if (tmp___16) {
    drm_err("vmw_execbuf_process", "Failed reserving fifo space for commands.\n");
    ret = -12;
    goto out_throttle;
  }
  __len = (size_t )command_size;
  __cil_tmp136 = kernel_commands;
  __ret = __builtin_memcpy(cmd, __cil_tmp136, __len);
  vmw_fifo_commit(dev_priv, command_size);
  vmw_query_bo_switch_commit(dev_priv, sw_context);
  if (user_fence_rep) {
    tmp___17 = & handle;
  } else {
    __cil_tmp137 = (void *)0;
    tmp___17 = (uint32_t *)__cil_tmp137;
  }
  ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___17);
  if (ret != 0) {
    drm_err("vmw_execbuf_process", "Fence submission error. Syncing.\n");
  }
  __cil_tmp138 = (unsigned long )sw_context;
  __cil_tmp139 = __cil_tmp138 + 96UL;
  __cil_tmp140 = (struct list_head *)__cil_tmp139;
  __cil_tmp141 = & fence;
  __cil_tmp142 = *__cil_tmp141;
  __cil_tmp143 = (void *)__cil_tmp142;
  ttm_eu_fence_buffer_objects(__cil_tmp140, __cil_tmp143);
  vmw_clear_validations(sw_context);
  tmp___18 = vmw_fpriv(file_priv);
  __cil_tmp144 = & fence;
  __cil_tmp145 = *__cil_tmp144;
  __cil_tmp146 = & handle;
  __cil_tmp147 = *__cil_tmp146;
  vmw_execbuf_copy_fence_user(dev_priv, tmp___18, ret, user_fence_rep, __cil_tmp145,
                              __cil_tmp147);
  __cil_tmp148 = (void *)0;
  __cil_tmp149 = (unsigned long )__cil_tmp148;
  __cil_tmp150 = (unsigned long )out_fence;
  __cil_tmp151 = __cil_tmp150 != __cil_tmp149;
  __cil_tmp152 = ! __cil_tmp151;
  __cil_tmp153 = ! __cil_tmp152;
  __cil_tmp154 = (long )__cil_tmp153;
  tmp___20 = ldv__builtin_expect(__cil_tmp154, 0L);
  if (tmp___20) {
    __cil_tmp155 = & fence;
    *out_fence = *__cil_tmp155;
    __cil_tmp156 = & fence;
    __cil_tmp157 = (void *)0;
    *__cil_tmp156 = (struct vmw_fence_obj *)__cil_tmp157;
  } else {
    __cil_tmp158 = (void *)0;
    __cil_tmp159 = (unsigned long )__cil_tmp158;
    __cil_tmp160 = & fence;
    __cil_tmp161 = *__cil_tmp160;
    __cil_tmp162 = (unsigned long )__cil_tmp161;
    __cil_tmp163 = __cil_tmp162 != __cil_tmp159;
    __cil_tmp164 = ! __cil_tmp163;
    __cil_tmp165 = ! __cil_tmp164;
    __cil_tmp166 = (long )__cil_tmp165;
    tmp___19 = ldv__builtin_expect(__cil_tmp166, 1L);
    if (tmp___19) {
      vmw_fence_obj_unreference(& fence);
    }
  }
  __cil_tmp167 = (unsigned long )dev_priv;
  __cil_tmp168 = __cil_tmp167 + 134304UL;
  __cil_tmp169 = (struct mutex *)__cil_tmp168;
  mutex_unlock(__cil_tmp169);
  return (0);
  out_err: 
  vmw_free_relocations(sw_context);
  out_throttle: 
  vmw_query_switch_backoff(sw_context);
  __cil_tmp170 = (unsigned long )sw_context;
  __cil_tmp171 = __cil_tmp170 + 96UL;
  __cil_tmp172 = (struct list_head *)__cil_tmp171;
  ttm_eu_backoff_reservation(__cil_tmp172);
  vmw_clear_validations(sw_context);
  out_unlock: 
  __cil_tmp173 = (unsigned long )dev_priv;
  __cil_tmp174 = __cil_tmp173 + 134304UL;
  __cil_tmp175 = (struct mutex *)__cil_tmp174;
  mutex_unlock(__cil_tmp175);
  return (ret);
}
}
static void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv ) 
{ bool __cil_tmp2 ;
  bool __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  bool __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ttm_buffer_object *__cil_tmp8 ;
  bool __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_buffer_object *__cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  drm_err("vmw_execbuf_unpin_panic", "Can\'t unpin query buffer. Trying to recover.\n");
  __cil_tmp2 = (bool )0;
  __cil_tmp3 = (bool )1;
  __cil_tmp4 = (uint32_t )0;
  __cil_tmp5 = (bool )0;
  vmw_fallback_wait(dev_priv, __cil_tmp2, __cil_tmp3, __cil_tmp4, __cil_tmp5, 2500UL);
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 134752UL;
  __cil_tmp8 = *((struct ttm_buffer_object **)__cil_tmp7);
  __cil_tmp9 = (bool )0;
  vmw_bo_pin(__cil_tmp8, __cil_tmp9);
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 134744UL;
  __cil_tmp12 = *((struct ttm_buffer_object **)__cil_tmp11);
  __cil_tmp13 = (bool )0;
  vmw_bo_pin(__cil_tmp12, __cil_tmp13);
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 134764UL;
  *((bool *)__cil_tmp15) = (bool )0;
  return;
}
}
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , bool only_on_cid_match ,
                                   uint32_t cid ) 
{ int ret ;
  struct list_head validate_list ;
  struct ttm_validate_buffer pinned_val ;
  struct ttm_validate_buffer query_val ;
  struct vmw_fence_obj *fence ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct ttm_buffer_object *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct ttm_buffer_object *__cil_tmp27 ;
  struct ttm_validate_buffer *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct ttm_buffer_object *__cil_tmp35 ;
  struct ttm_validate_buffer *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_buffer_object *__cil_tmp51 ;
  bool __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_buffer_object *__cil_tmp55 ;
  bool __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  void *__cil_tmp59 ;
  struct drm_file *__cil_tmp60 ;
  void *__cil_tmp61 ;
  uint32_t *__cil_tmp62 ;
  struct vmw_fence_obj **__cil_tmp63 ;
  struct vmw_fence_obj *__cil_tmp64 ;
  void *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  struct ttm_buffer_object **__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct ttm_buffer_object **__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct ttm_buffer_object **__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct mutex *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct ttm_buffer_object **__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object **__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct ttm_buffer_object **__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct mutex *__cil_tmp85 ;

  {
  ret = 0;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 134304UL;
  __cil_tmp13 = (struct mutex *)__cil_tmp12;
  mutex_lock(__cil_tmp13);
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 134752UL;
  __cil_tmp18 = *((struct ttm_buffer_object **)__cil_tmp17);
  __cil_tmp19 = (unsigned long )__cil_tmp18;
  if (__cil_tmp19 == __cil_tmp15) {
    goto out_unlock;
  }
  if (only_on_cid_match) {
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 134760UL;
    __cil_tmp22 = *((uint32_t *)__cil_tmp21);
    if (cid != __cil_tmp22) {
      goto out_unlock;
    }
  }
  INIT_LIST_HEAD(& validate_list);
  __cil_tmp23 = (unsigned long )(& pinned_val) + 24UL;
  *((void **)__cil_tmp23) = (void *)1UL;
  __cil_tmp24 = (unsigned long )(& pinned_val) + 16UL;
  __cil_tmp25 = (unsigned long )dev_priv;
  __cil_tmp26 = __cil_tmp25 + 134752UL;
  __cil_tmp27 = *((struct ttm_buffer_object **)__cil_tmp26);
  *((struct ttm_buffer_object **)__cil_tmp24) = ttm_bo_reference(__cil_tmp27);
  __cil_tmp28 = & pinned_val;
  __cil_tmp29 = (struct list_head *)__cil_tmp28;
  list_add_tail(__cil_tmp29, & validate_list);
  __cil_tmp30 = (unsigned long )(& query_val) + 24UL;
  __cil_tmp31 = (unsigned long )(& pinned_val) + 24UL;
  *((void **)__cil_tmp30) = *((void **)__cil_tmp31);
  __cil_tmp32 = (unsigned long )(& query_val) + 16UL;
  __cil_tmp33 = (unsigned long )dev_priv;
  __cil_tmp34 = __cil_tmp33 + 134744UL;
  __cil_tmp35 = *((struct ttm_buffer_object **)__cil_tmp34);
  *((struct ttm_buffer_object **)__cil_tmp32) = ttm_bo_reference(__cil_tmp35);
  __cil_tmp36 = & query_val;
  __cil_tmp37 = (struct list_head *)__cil_tmp36;
  list_add_tail(__cil_tmp37, & validate_list);
  while (1) {
    ret = ttm_eu_reserve_buffers(& validate_list);
    if (! (ret == -512)) {
      goto while_break;
    }
  }
  while_break: 
  __cil_tmp38 = ret != 0;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = ! __cil_tmp39;
  __cil_tmp41 = (long )__cil_tmp40;
  tmp___7 = ldv__builtin_expect(__cil_tmp41, 0L);
  if (tmp___7) {
    vmw_execbuf_unpin_panic(dev_priv);
    goto out_no_reserve;
  }
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 134760UL;
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
  ret = vmw_fifo_emit_dummy_query(dev_priv, __cil_tmp44);
  __cil_tmp45 = ret != 0;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = ! __cil_tmp46;
  __cil_tmp48 = (long )__cil_tmp47;
  tmp___8 = ldv__builtin_expect(__cil_tmp48, 0L);
  if (tmp___8) {
    vmw_execbuf_unpin_panic(dev_priv);
    goto out_no_emit;
  }
  __cil_tmp49 = (unsigned long )dev_priv;
  __cil_tmp50 = __cil_tmp49 + 134752UL;
  __cil_tmp51 = *((struct ttm_buffer_object **)__cil_tmp50);
  __cil_tmp52 = (bool )0;
  vmw_bo_pin(__cil_tmp51, __cil_tmp52);
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 134744UL;
  __cil_tmp55 = *((struct ttm_buffer_object **)__cil_tmp54);
  __cil_tmp56 = (bool )0;
  vmw_bo_pin(__cil_tmp55, __cil_tmp56);
  __cil_tmp57 = (unsigned long )dev_priv;
  __cil_tmp58 = __cil_tmp57 + 134764UL;
  *((bool *)__cil_tmp58) = (bool )0;
  __cil_tmp59 = (void *)0;
  __cil_tmp60 = (struct drm_file *)__cil_tmp59;
  __cil_tmp61 = (void *)0;
  __cil_tmp62 = (uint32_t *)__cil_tmp61;
  vmw_execbuf_fence_commands(__cil_tmp60, dev_priv, & fence, __cil_tmp62);
  __cil_tmp63 = & fence;
  __cil_tmp64 = *__cil_tmp63;
  __cil_tmp65 = (void *)__cil_tmp64;
  ttm_eu_fence_buffer_objects(& validate_list, __cil_tmp65);
  __cil_tmp66 = (unsigned long )(& query_val) + 16UL;
  __cil_tmp67 = (struct ttm_buffer_object **)__cil_tmp66;
  ttm_bo_unref(__cil_tmp67);
  __cil_tmp68 = (unsigned long )(& pinned_val) + 16UL;
  __cil_tmp69 = (struct ttm_buffer_object **)__cil_tmp68;
  ttm_bo_unref(__cil_tmp69);
  __cil_tmp70 = (unsigned long )dev_priv;
  __cil_tmp71 = __cil_tmp70 + 134752UL;
  __cil_tmp72 = (struct ttm_buffer_object **)__cil_tmp71;
  ttm_bo_unref(__cil_tmp72);
  out_unlock: 
  __cil_tmp73 = (unsigned long )dev_priv;
  __cil_tmp74 = __cil_tmp73 + 134304UL;
  __cil_tmp75 = (struct mutex *)__cil_tmp74;
  mutex_unlock(__cil_tmp75);
  return;
  out_no_emit: 
  ttm_eu_backoff_reservation(& validate_list);
  out_no_reserve: 
  __cil_tmp76 = (unsigned long )(& query_val) + 16UL;
  __cil_tmp77 = (struct ttm_buffer_object **)__cil_tmp76;
  ttm_bo_unref(__cil_tmp77);
  __cil_tmp78 = (unsigned long )(& pinned_val) + 16UL;
  __cil_tmp79 = (struct ttm_buffer_object **)__cil_tmp78;
  ttm_bo_unref(__cil_tmp79);
  __cil_tmp80 = (unsigned long )dev_priv;
  __cil_tmp81 = __cil_tmp80 + 134752UL;
  __cil_tmp82 = (struct ttm_buffer_object **)__cil_tmp81;
  ttm_bo_unref(__cil_tmp82);
  __cil_tmp83 = (unsigned long )dev_priv;
  __cil_tmp84 = __cil_tmp83 + 134304UL;
  __cil_tmp85 = (struct mutex *)__cil_tmp84;
  mutex_unlock(__cil_tmp85);
  return;
}
}
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_execbuf_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  int ret ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_master *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct ttm_lock *__cil_tmp23 ;
  bool __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  uint64_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  uint64_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint64_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  void *__cil_tmp44 ;
  struct drm_vmw_fence_rep *__cil_tmp45 ;
  void *__cil_tmp46 ;
  struct vmw_fence_obj **__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  struct ttm_lock *__cil_tmp52 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_execbuf_arg *)data;
  __cil_tmp13 = (unsigned long )file_priv;
  __cil_tmp14 = __cil_tmp13 + 152UL;
  __cil_tmp15 = *((struct drm_master **)__cil_tmp14);
  tmp___8 = vmw_master(__cil_tmp15);
  vmaster = tmp___8;
  __cil_tmp16 = (unsigned long )arg;
  __cil_tmp17 = __cil_tmp16 + 24UL;
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
  __cil_tmp19 = __cil_tmp18 != 1U;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___9 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___9) {
    drm_err("vmw_execbuf_ioctl", "Incorrect execbuf version.\n");
    drm_err("vmw_execbuf_ioctl", "You\'re running outdated experimental vmwgfx user-space drivers.");
    return (-22);
  }
  __cil_tmp23 = (struct ttm_lock *)vmaster;
  __cil_tmp24 = (bool )1;
  ret = ttm_read_lock(__cil_tmp23, __cil_tmp24);
  __cil_tmp25 = ret != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___10 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___10) {
    return (ret);
  }
  __cil_tmp29 = *((uint64_t *)arg);
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  __cil_tmp31 = (void *)__cil_tmp30;
  __cil_tmp32 = (void *)0;
  __cil_tmp33 = (unsigned long )arg;
  __cil_tmp34 = __cil_tmp33 + 8UL;
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
  __cil_tmp36 = (unsigned long )arg;
  __cil_tmp37 = __cil_tmp36 + 12UL;
  __cil_tmp38 = *((uint32_t *)__cil_tmp37);
  __cil_tmp39 = (uint64_t )__cil_tmp38;
  __cil_tmp40 = (unsigned long )arg;
  __cil_tmp41 = __cil_tmp40 + 16UL;
  __cil_tmp42 = *((uint64_t *)__cil_tmp41);
  __cil_tmp43 = (unsigned long )__cil_tmp42;
  __cil_tmp44 = (void *)__cil_tmp43;
  __cil_tmp45 = (struct drm_vmw_fence_rep *)__cil_tmp44;
  __cil_tmp46 = (void *)0;
  __cil_tmp47 = (struct vmw_fence_obj **)__cil_tmp46;
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp31, __cil_tmp32, __cil_tmp35,
                            __cil_tmp39, __cil_tmp45, __cil_tmp47);
  __cil_tmp48 = ret != 0;
  __cil_tmp49 = ! __cil_tmp48;
  __cil_tmp50 = ! __cil_tmp49;
  __cil_tmp51 = (long )__cil_tmp50;
  tmp___11 = ldv__builtin_expect(__cil_tmp51, 0L);
  if (tmp___11) {
    goto out_unlock;
  }
  vmw_kms_cursor_post_execbuf(dev_priv);
  out_unlock: 
  __cil_tmp52 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp52);
  return (ret);
}
}
void ldv_blast_assert(void) 
{ 

  {
  ERROR: __VERIFIER_error(); 
  goto ERROR;
}
}
extern int __VERIFIER_nondet_int(void) ;
int ldv_mutex  =    1;
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex = 2;
    return (1);
  }
  return (0);
}
}
void mutex_lock(struct mutex *lock ) 
{ 

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  ldv_mutex = 2;
  return;
}
}
int mutex_trylock(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (1);
  } else {
    return (0);
  }
}
}
void mutex_unlock(struct mutex *lock ) 
{ 

  {
  if (! (ldv_mutex == 2)) {
    ldv_blast_assert();
  }
  ldv_mutex = 1;
  return;
}
}
void ldv_check_final_state(void) 
{ 

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  return;
}
}
long ldv__builtin_expect(long val , long res ) 
{ 

  {
  return (val);
}
}
extern void __bad_percpu_size(void) ;
extern void *__memcpy(void *to , void *from , size_t len ) ;
extern unsigned long kernel_stack  __attribute__((__section__(".data..percpu"))) ;
 static struct thread_info *current_thread_info(void)  __attribute__((__no_instrument_function__)) ;
 static struct thread_info *current_thread_info(void)  __attribute__((__no_instrument_function__)) ;
 static struct thread_info *current_thread_info(void) 
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  if (1) {
    goto case_8;
  } else {
    goto switch_default;
    if (0) {
      __asm__  ("mov"
                "b "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=q" (pfo_ret__): "p" (& kernel_stack));
      goto switch_break;
      __asm__  ("mov"
                "w "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto switch_break;
      __asm__  ("mov"
                "l "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto switch_break;
      case_8: 
      __asm__  ("mov"
                "q "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
      goto switch_break;
      switch_default: 
      __bad_percpu_size();
    } else {
      switch_break: ;
    }
  }
  __cil_tmp3 = 1UL << 12;
  __cil_tmp4 = __cil_tmp3 << 1;
  __cil_tmp5 = pfo_ret__ + 40UL;
  __cil_tmp6 = __cil_tmp5 - __cil_tmp4;
  __cil_tmp7 = (void *)__cil_tmp6;
  ti = (struct thread_info *)__cil_tmp7;
  return (ti);
}
}
 static void outl(unsigned int value , int port )  __attribute__((__no_instrument_function__)) ;
 static void outl(unsigned int value , int port )  __attribute__((__no_instrument_function__)) ;
 static void outl(unsigned int value , int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
  return;
}
}
extern struct page *alloc_pages_current(gfp_t gfp_mask , unsigned int order ) ;
 static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
 static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
 static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ struct page *tmp ;

  {
  tmp = alloc_pages_current(gfp_mask, order);
  return (tmp);
}
}
extern void __free_pages(struct page *page , unsigned int order ) ;
 static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page *page )  __attribute__((__no_instrument_function__)) ;
 static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page *page )  __attribute__((__no_instrument_function__)) ;
 static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page *page ) 
{ struct page *__cil_tmp2 ;
  struct page *__cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  phys_addr_t __cil_tmp6 ;
  phys_addr_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
  __cil_tmp2 = (struct page *)0xffffea0000000000UL;
  __cil_tmp3 = __cil_tmp2;
  __cil_tmp4 = page - __cil_tmp3;
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = (phys_addr_t )__cil_tmp5;
  __cil_tmp7 = __cil_tmp6 << 12;
  __cil_tmp8 = (unsigned long )__cil_tmp7;
  __cil_tmp9 = __cil_tmp8 + 0xffff880000000000UL;
  return ((void *)__cil_tmp9);
}
}
 static void pagefault_disable(void)  __attribute__((__no_instrument_function__)) ;
 static void pagefault_disable(void)  __attribute__((__no_instrument_function__)) ;
 static void pagefault_disable(void) 
{ struct thread_info *tmp___7 ;
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  while (1) {
    tmp___7 = current_thread_info();
    __cil_tmp2 = (unsigned long )tmp___7;
    __cil_tmp3 = __cil_tmp2 + 28UL;
    __cil_tmp4 = (unsigned long )tmp___7;
    __cil_tmp5 = __cil_tmp4 + 28UL;
    __cil_tmp6 = *((int *)__cil_tmp5);
    *((int *)__cil_tmp3) = __cil_tmp6 + 1;
    goto while_break;
  }
  while_break: 
  __asm__  volatile   ("": : : "memory");
  return;
}
}
 static void pagefault_enable(void)  __attribute__((__no_instrument_function__)) ;
 static void pagefault_enable(void)  __attribute__((__no_instrument_function__)) ;
 static void pagefault_enable(void) 
{ struct thread_info *tmp___7 ;
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  __asm__  volatile   ("": : : "memory");
  while (1) {
    tmp___7 = current_thread_info();
    __cil_tmp2 = (unsigned long )tmp___7;
    __cil_tmp3 = __cil_tmp2 + 28UL;
    __cil_tmp4 = (unsigned long )tmp___7;
    __cil_tmp5 = __cil_tmp4 + 28UL;
    __cil_tmp6 = *((int *)__cil_tmp5);
    *((int *)__cil_tmp3) = __cil_tmp6 - 1;
    goto while_break;
  }
  while_break: 
  __asm__  volatile   ("": : : "memory");
  while (1) {

    goto while_break___0;
  }
  while_break___0: ;
  return;
}
}
 static void *kmap_atomic(struct page *page )  __attribute__((__no_instrument_function__)) ;
 static void *kmap_atomic(struct page *page )  __attribute__((__no_instrument_function__)) ;
 static void *kmap_atomic(struct page *page ) 
{ void *tmp___7 ;
  struct page *__cil_tmp3 ;

  {
  pagefault_disable();
  __cil_tmp3 = page;
  tmp___7 = lowmem_page_address(__cil_tmp3);
  return (tmp___7);
}
}
 static void __kunmap_atomic(void *addr )  __attribute__((__no_instrument_function__)) ;
 static void __kunmap_atomic(void *addr )  __attribute__((__no_instrument_function__)) ;
 static void __kunmap_atomic(void *addr ) 
{ 

  {
  pagefault_enable();
  return;
}
}
 static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value )  __attribute__((__no_instrument_function__)) ;
 static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value )  __attribute__((__no_instrument_function__)) ;
 static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2104UL;
  __cil_tmp6 = *((unsigned int *)__cil_tmp5);
  __cil_tmp7 = (int )__cil_tmp6;
  outl(offset, __cil_tmp7);
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2104UL;
  __cil_tmp10 = *((unsigned int *)__cil_tmp9);
  __cil_tmp11 = __cil_tmp10 + 1U;
  __cil_tmp12 = (int )__cil_tmp11;
  outl(value, __cil_tmp12);
  return;
}
}
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) ;
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) ;
static int vmw_gmr2_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                         int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  SVGAFifoCmdRemapGMR2 remap_cmd ;
  uint32_t define_size ;
  uint32_t remap_size ;
  uint32_t *cmd ;
  uint32_t *cmd_orig ;
  uint32_t i ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t *tmp___9 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___10 ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct page **tmp___11 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  SVGAFifoCmdDefineGMR2 *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  SVGAFifoCmdRemapGMR2 *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct page *__cil_tmp52 ;
  struct page *__cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp61 ;
  uint32_t __cil_tmp62 ;

  {
  __cil_tmp22 = 12UL;
  define_size = (uint32_t )__cil_tmp22;
  __cil_tmp23 = 8UL * num_pages;
  __cil_tmp24 = __cil_tmp23 + 16UL;
  __cil_tmp25 = __cil_tmp24 + 4UL;
  remap_size = (uint32_t )__cil_tmp25;
  __cil_tmp26 = define_size + remap_size;
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp26);
  cmd = (uint32_t *)tmp___7;
  cmd_orig = cmd;
  __cil_tmp27 = (void *)0;
  __cil_tmp28 = (unsigned long )__cil_tmp27;
  __cil_tmp29 = (unsigned long )cmd;
  __cil_tmp30 = __cil_tmp29 == __cil_tmp28;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___8 = ldv__builtin_expect(__cil_tmp33, 0L);
  if (tmp___8) {
    return (-12);
  }
  __cil_tmp34 = & define_cmd;
  *((uint32 *)__cil_tmp34) = (uint32 )gmr_id;
  __cil_tmp35 = (unsigned long )(& define_cmd) + 4UL;
  *((uint32 *)__cil_tmp35) = (uint32 )num_pages;
  __cil_tmp36 = & remap_cmd;
  *((uint32 *)__cil_tmp36) = (uint32 )gmr_id;
  __cil_tmp37 = (unsigned long )(& remap_cmd) + 4UL;
  *((SVGARemapGMR2Flags *)__cil_tmp37) = (SVGARemapGMR2Flags )2;
  __cil_tmp39 = (unsigned long )(& remap_cmd) + 8UL;
  *((uint32 *)__cil_tmp39) = (uint32 )0;
  __cil_tmp40 = (unsigned long )(& remap_cmd) + 12UL;
  *((uint32 *)__cil_tmp40) = (uint32 )num_pages;
  tmp___9 = cmd;
  cmd ++;
  *tmp___9 = (uint32_t )41;
  __len = 8UL;
  if (__len >= 64UL) {
    __cil_tmp41 = (void *)cmd;
    __cil_tmp42 = (void *)(& define_cmd);
    __ret = __memcpy(__cil_tmp41, __cil_tmp42, __len);
  } else {
    __cil_tmp43 = (void *)cmd;
    __cil_tmp44 = (void *)(& define_cmd);
    __ret = __builtin_memcpy(__cil_tmp43, __cil_tmp44, __len);
  }
  __cil_tmp45 = 2UL;
  cmd += __cil_tmp45;
  tmp___10 = cmd;
  cmd ++;
  *tmp___10 = (uint32_t )42;
  __len___0 = 16UL;
  if (__len___0 >= 64UL) {
    __cil_tmp46 = (void *)cmd;
    __cil_tmp47 = (void *)(& remap_cmd);
    __ret___0 = __memcpy(__cil_tmp46, __cil_tmp47, __len___0);
  } else {
    __cil_tmp48 = (void *)cmd;
    __cil_tmp49 = (void *)(& remap_cmd);
    __ret___0 = __builtin_memcpy(__cil_tmp48, __cil_tmp49, __len___0);
  }
  __cil_tmp50 = 4UL;
  cmd += __cil_tmp50;
  i = (uint32_t )0;
  while (1) {
    __cil_tmp51 = (unsigned long )i;
    if (! (__cil_tmp51 < num_pages)) {
      goto while_break;
    }
    tmp___11 = pages;
    pages ++;
    __cil_tmp52 = (struct page *)0xffffea0000000000UL;
    __cil_tmp53 = *tmp___11;
    __cil_tmp54 = __cil_tmp53 - __cil_tmp52;
    __cil_tmp55 = (unsigned long )__cil_tmp54;
    *cmd = (uint32_t )__cil_tmp55;
    __cil_tmp61 = 2UL;
    cmd += __cil_tmp61;
    i ++;
  }
  while_break: 
  __cil_tmp62 = define_size + remap_size;
  vmw_fifo_commit(dev_priv, __cil_tmp62);
  return (0);
}
}
static void vmw_gmr2_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  uint32_t define_size ;
  uint32_t *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t *tmp___9 ;
  size_t __len ;
  void *__ret ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  SVGAFifoCmdDefineGMR2 *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  __cil_tmp11 = 12UL;
  define_size = (uint32_t )__cil_tmp11;
  tmp___7 = vmw_fifo_reserve(dev_priv, define_size);
  cmd = (uint32_t *)tmp___7;
  __cil_tmp12 = (void *)0;
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = (unsigned long )cmd;
  __cil_tmp15 = __cil_tmp14 == __cil_tmp13;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 0L);
  if (tmp___8) {
    drm_err("vmw_gmr2_unbind", "GMR2 unbind failed.\n");
    return;
  }
  __cil_tmp19 = & define_cmd;
  *((uint32 *)__cil_tmp19) = (uint32 )gmr_id;
  __cil_tmp20 = (unsigned long )(& define_cmd) + 4UL;
  *((uint32 *)__cil_tmp20) = (uint32 )0;
  tmp___9 = cmd;
  cmd ++;
  *tmp___9 = (uint32_t )41;
  __len = 8UL;
  if (__len >= 64UL) {
    __cil_tmp21 = (void *)cmd;
    __cil_tmp22 = (void *)(& define_cmd);
    __ret = __memcpy(__cil_tmp21, __cil_tmp22, __len);
  } else {
    __cil_tmp23 = (void *)cmd;
    __cil_tmp24 = (void *)(& define_cmd);
    __ret = __builtin_memcpy(__cil_tmp23, __cil_tmp24, __len);
  }
  vmw_fifo_commit(dev_priv, define_size);
  return;
}
}
static int vmw_gmr_build_descriptors(struct list_head *desc_pages , struct page **pages ,
                                     unsigned long num_pages ) 
{ struct page *page ;
  struct page *next ;
  struct svga_guest_mem_descriptor *page_virtual ;
  struct svga_guest_mem_descriptor *desc_virtual ;
  unsigned int desc_per_page ;
  unsigned long prev_pfn ;
  unsigned long pfn ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  uint32_t tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  struct page *__cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  void *__cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  long __cil_tmp55 ;
  struct page *__cil_tmp56 ;
  struct page *__cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  void *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  long __cil_tmp77 ;
  void *__cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  struct page *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct list_head *__cil_tmp89 ;
  struct page *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct list_head *__cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct list_head *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct list_head *__cil_tmp107 ;
  struct page *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct list_head *__cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;

  {
  __cil_tmp22 = (void *)0;
  page_virtual = (struct svga_guest_mem_descriptor *)__cil_tmp22;
  __cil_tmp23 = (void *)0;
  desc_virtual = (struct svga_guest_mem_descriptor *)__cil_tmp23;
  __cil_tmp24 = 1UL << 12;
  __cil_tmp25 = __cil_tmp24 / 8UL;
  __cil_tmp26 = __cil_tmp25 - 1UL;
  desc_per_page = (unsigned int )__cil_tmp26;
  while (1) {
    __cil_tmp27 = num_pages != 0UL;
    __cil_tmp28 = ! __cil_tmp27;
    __cil_tmp29 = ! __cil_tmp28;
    __cil_tmp30 = (long )__cil_tmp29;
    tmp___12 = ldv__builtin_expect(__cil_tmp30, 1L);
    if (! tmp___12) {
      goto while_break;
    }
    page = alloc_pages(2U, 0U);
    __cil_tmp31 = (void *)0;
    __cil_tmp32 = (unsigned long )__cil_tmp31;
    __cil_tmp33 = (unsigned long )page;
    __cil_tmp34 = __cil_tmp33 == __cil_tmp32;
    __cil_tmp35 = ! __cil_tmp34;
    __cil_tmp36 = ! __cil_tmp35;
    __cil_tmp37 = (long )__cil_tmp36;
    tmp___7 = ldv__builtin_expect(__cil_tmp37, 0L);
    if (tmp___7) {
      ret = -12;
      goto out_err;
    }
    __cil_tmp38 = (unsigned long )page;
    __cil_tmp39 = __cil_tmp38 + 32UL;
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
    list_add_tail(__cil_tmp40, desc_pages);
    __cil_tmp41 = (void *)0;
    __cil_tmp42 = (unsigned long )__cil_tmp41;
    __cil_tmp43 = (unsigned long )page_virtual;
    __cil_tmp44 = __cil_tmp43 != __cil_tmp42;
    __cil_tmp45 = ! __cil_tmp44;
    __cil_tmp46 = ! __cil_tmp45;
    __cil_tmp47 = (long )__cil_tmp46;
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 1L);
    if (tmp___8) {
      __cil_tmp48 = (struct page *)0xffffea0000000000UL;
      __cil_tmp49 = page - __cil_tmp48;
      __cil_tmp50 = (unsigned long )__cil_tmp49;
      *((__le32 *)desc_virtual) = (__le32 )__cil_tmp50;
      while (1) {
        __cil_tmp51 = (void *)page_virtual;
        __kunmap_atomic(__cil_tmp51);
        goto while_break___0;
      }
      while_break___0: ;
    }
    tmp___9 = kmap_atomic(page);
    page_virtual = (struct svga_guest_mem_descriptor *)tmp___9;
    desc_virtual = page_virtual - 1;
    prev_pfn = ~ 0UL;
    while (1) {
      __cil_tmp52 = num_pages != 0UL;
      __cil_tmp53 = ! __cil_tmp52;
      __cil_tmp54 = ! __cil_tmp53;
      __cil_tmp55 = (long )__cil_tmp54;
      tmp___11 = ldv__builtin_expect(__cil_tmp55, 1L);
      if (! tmp___11) {
        goto while_break___1;
      }
      __cil_tmp56 = (struct page *)0xffffea0000000000UL;
      __cil_tmp57 = *pages;
      __cil_tmp58 = __cil_tmp57 - __cil_tmp56;
      pfn = (unsigned long )__cil_tmp58;
      __cil_tmp59 = prev_pfn + 1UL;
      if (pfn != __cil_tmp59) {
        __cil_tmp60 = desc_per_page - 1U;
        __cil_tmp61 = desc_virtual - page_virtual;
        __cil_tmp62 = (unsigned int )__cil_tmp61;
        if (__cil_tmp62 == __cil_tmp60) {
          goto while_break___1;
        }
        desc_virtual ++;
        *((__le32 *)desc_virtual) = (__u32 )pfn;
        __cil_tmp63 = (unsigned long )desc_virtual;
        __cil_tmp64 = __cil_tmp63 + 4UL;
        *((__le32 *)__cil_tmp64) = (__u32 )1;
      } else {
        __cil_tmp65 = (unsigned long )desc_virtual;
        __cil_tmp66 = __cil_tmp65 + 4UL;
        tmp___10 = *((__le32 *)__cil_tmp66);
        __cil_tmp67 = (unsigned long )desc_virtual;
        __cil_tmp68 = __cil_tmp67 + 4UL;
        *((__le32 *)__cil_tmp68) = tmp___10 + 1U;
      }
      prev_pfn = pfn;
      num_pages --;
      pages ++;
    }
    while_break___1: 
    desc_virtual ++;
    *((__le32 *)desc_virtual) = (__u32 )0;
    __cil_tmp69 = (unsigned long )desc_virtual;
    __cil_tmp70 = __cil_tmp69 + 4UL;
    *((__le32 *)__cil_tmp70) = (__u32 )0;
  }
  while_break: 
  __cil_tmp71 = (void *)0;
  __cil_tmp72 = (unsigned long )__cil_tmp71;
  __cil_tmp73 = (unsigned long )page_virtual;
  __cil_tmp74 = __cil_tmp73 != __cil_tmp72;
  __cil_tmp75 = ! __cil_tmp74;
  __cil_tmp76 = ! __cil_tmp75;
  __cil_tmp77 = (long )__cil_tmp76;
  tmp___13 = ldv__builtin_expect(__cil_tmp77, 1L);
  if (tmp___13) {
    while (1) {
      __cil_tmp78 = (void *)page_virtual;
      __kunmap_atomic(__cil_tmp78);
      goto while_break___2;
    }
    while_break___2: ;
  }
  return (0);
  out_err: 
  __cil_tmp79 = *((struct list_head **)desc_pages);
  __mptr = __cil_tmp79;
  __cil_tmp80 = (struct page *)0;
  __cil_tmp81 = (unsigned long )__cil_tmp80;
  __cil_tmp82 = __cil_tmp81 + 32UL;
  __cil_tmp83 = (struct list_head *)__cil_tmp82;
  __cil_tmp84 = (unsigned int )__cil_tmp83;
  __cil_tmp85 = (char *)__mptr;
  __cil_tmp86 = __cil_tmp85 - __cil_tmp84;
  page = (struct page *)__cil_tmp86;
  __cil_tmp87 = (unsigned long )page;
  __cil_tmp88 = __cil_tmp87 + 32UL;
  __cil_tmp89 = *((struct list_head **)__cil_tmp88);
  __mptr___0 = __cil_tmp89;
  __cil_tmp90 = (struct page *)0;
  __cil_tmp91 = (unsigned long )__cil_tmp90;
  __cil_tmp92 = __cil_tmp91 + 32UL;
  __cil_tmp93 = (struct list_head *)__cil_tmp92;
  __cil_tmp94 = (unsigned int )__cil_tmp93;
  __cil_tmp95 = (char *)__mptr___0;
  __cil_tmp96 = __cil_tmp95 - __cil_tmp94;
  next = (struct page *)__cil_tmp96;
  while (1) {
    __cil_tmp97 = (unsigned long )desc_pages;
    __cil_tmp98 = (unsigned long )page;
    __cil_tmp99 = __cil_tmp98 + 32UL;
    __cil_tmp100 = (struct list_head *)__cil_tmp99;
    __cil_tmp101 = (unsigned long )__cil_tmp100;
    if (! (__cil_tmp101 != __cil_tmp97)) {
      goto while_break___3;
    }
    __cil_tmp102 = (unsigned long )page;
    __cil_tmp103 = __cil_tmp102 + 32UL;
    __cil_tmp104 = (struct list_head *)__cil_tmp103;
    list_del_init(__cil_tmp104);
    __free_pages(page, 0U);
    page = next;
    __cil_tmp105 = (unsigned long )next;
    __cil_tmp106 = __cil_tmp105 + 32UL;
    __cil_tmp107 = *((struct list_head **)__cil_tmp106);
    __mptr___1 = __cil_tmp107;
    __cil_tmp108 = (struct page *)0;
    __cil_tmp109 = (unsigned long )__cil_tmp108;
    __cil_tmp110 = __cil_tmp109 + 32UL;
    __cil_tmp111 = (struct list_head *)__cil_tmp110;
    __cil_tmp112 = (unsigned int )__cil_tmp111;
    __cil_tmp113 = (char *)__mptr___1;
    __cil_tmp114 = __cil_tmp113 - __cil_tmp112;
    next = (struct page *)__cil_tmp114;
  }
  while_break___3: ;
  return (ret);
}
}
 static void vmw_gmr_free_descriptors(struct list_head *desc_pages )  __attribute__((__no_instrument_function__)) ;
 static void vmw_gmr_free_descriptors(struct list_head *desc_pages )  __attribute__((__no_instrument_function__)) ;
 static void vmw_gmr_free_descriptors(struct list_head *desc_pages ) 
{ struct page *page ;
  struct page *next ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  struct list_head *__cil_tmp7 ;
  struct page *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  struct page *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct page *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  __cil_tmp7 = *((struct list_head **)desc_pages);
  __mptr = __cil_tmp7;
  __cil_tmp8 = (struct page *)0;
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = __cil_tmp9 + 32UL;
  __cil_tmp11 = (struct list_head *)__cil_tmp10;
  __cil_tmp12 = (unsigned int )__cil_tmp11;
  __cil_tmp13 = (char *)__mptr;
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
  page = (struct page *)__cil_tmp14;
  __cil_tmp15 = (unsigned long )page;
  __cil_tmp16 = __cil_tmp15 + 32UL;
  __cil_tmp17 = *((struct list_head **)__cil_tmp16);
  __mptr___0 = __cil_tmp17;
  __cil_tmp18 = (struct page *)0;
  __cil_tmp19 = (unsigned long )__cil_tmp18;
  __cil_tmp20 = __cil_tmp19 + 32UL;
  __cil_tmp21 = (struct list_head *)__cil_tmp20;
  __cil_tmp22 = (unsigned int )__cil_tmp21;
  __cil_tmp23 = (char *)__mptr___0;
  __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
  next = (struct page *)__cil_tmp24;
  while (1) {
    __cil_tmp25 = (unsigned long )desc_pages;
    __cil_tmp26 = (unsigned long )page;
    __cil_tmp27 = __cil_tmp26 + 32UL;
    __cil_tmp28 = (struct list_head *)__cil_tmp27;
    __cil_tmp29 = (unsigned long )__cil_tmp28;
    if (! (__cil_tmp29 != __cil_tmp25)) {
      goto while_break;
    }
    __cil_tmp30 = (unsigned long )page;
    __cil_tmp31 = __cil_tmp30 + 32UL;
    __cil_tmp32 = (struct list_head *)__cil_tmp31;
    list_del_init(__cil_tmp32);
    __free_pages(page, 0U);
    page = next;
    __cil_tmp33 = (unsigned long )next;
    __cil_tmp34 = __cil_tmp33 + 32UL;
    __cil_tmp35 = *((struct list_head **)__cil_tmp34);
    __mptr___1 = __cil_tmp35;
    __cil_tmp36 = (struct page *)0;
    __cil_tmp37 = (unsigned long )__cil_tmp36;
    __cil_tmp38 = __cil_tmp37 + 32UL;
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
    __cil_tmp40 = (unsigned int )__cil_tmp39;
    __cil_tmp41 = (char *)__mptr___1;
    __cil_tmp42 = __cil_tmp41 - __cil_tmp40;
    next = (struct page *)__cil_tmp42;
  }
  while_break: ;
  return;
}
}
static void vmw_gmr_fire_descriptors(struct vmw_private *dev_priv , int gmr_id , struct list_head *desc_pages ) 
{ struct page *page ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  struct list_head *__mptr ;
  struct list_head *__cil_tmp9 ;
  long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  struct page *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  struct page *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct mutex *__cil_tmp29 ;

  {
  __cil_tmp9 = desc_pages;
  tmp___7 = list_empty(__cil_tmp9);
  if (tmp___7) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __cil_tmp10 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp10, 0L);
  if (tmp___9) {
    return;
  }
  __cil_tmp11 = *((struct list_head **)desc_pages);
  __mptr = __cil_tmp11;
  __cil_tmp12 = (struct page *)0;
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = __cil_tmp13 + 32UL;
  __cil_tmp15 = (struct list_head *)__cil_tmp14;
  __cil_tmp16 = (unsigned int )__cil_tmp15;
  __cil_tmp17 = (char *)__mptr;
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
  page = (struct page *)__cil_tmp18;
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 2184UL;
  __cil_tmp21 = (struct mutex *)__cil_tmp20;
  mutex_lock(__cil_tmp21);
  __cil_tmp22 = (uint32_t )gmr_id;
  vmw_write(dev_priv, 41U, __cil_tmp22);
  __asm__  volatile   ("sfence": : : "memory");
  __cil_tmp23 = (struct page *)0xffffea0000000000UL;
  __cil_tmp24 = page - __cil_tmp23;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = (uint32_t )__cil_tmp25;
  vmw_write(dev_priv, 42U, __cil_tmp26);
  __asm__  volatile   ("mfence": : : "memory");
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 2184UL;
  __cil_tmp29 = (struct mutex *)__cil_tmp28;
  mutex_unlock(__cil_tmp29);
  return;
}
}
static unsigned long vmw_gmr_count_descriptors(struct page **pages , unsigned long num_pages ) 
{ unsigned long prev_pfn ;
  unsigned long pfn ;
  unsigned long descriptors ;
  struct page **tmp___7 ;
  unsigned long tmp___8 ;
  struct page *__cil_tmp8 ;
  struct page *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
  prev_pfn = ~ 0UL;
  descriptors = 0UL;
  while (1) {
    tmp___8 = num_pages;
    num_pages --;
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = pages;
    pages ++;
    __cil_tmp8 = (struct page *)0xffffea0000000000UL;
    __cil_tmp9 = *tmp___7;
    __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
    pfn = (unsigned long )__cil_tmp10;
    __cil_tmp11 = prev_pfn + 1UL;
    if (__cil_tmp11 != pfn) {
      descriptors ++;
    }
    prev_pfn = pfn;
  }
  while_break: ;
  return (descriptors);
}
}
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) 
{ struct list_head desc_pages ;
  int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;

  {
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2156UL;
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
  __cil_tmp15 = __cil_tmp14 & 4194304U;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 1L);
  if (tmp___8) {
    tmp___7 = vmw_gmr2_bind(dev_priv, pages, num_pages, gmr_id);
    return (tmp___7);
  }
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 2156UL;
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
  __cil_tmp22 = __cil_tmp21 & 1048576U;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  tmp___9 = ldv__builtin_expect(__cil_tmp26, 0L);
  if (tmp___9) {
    return (-22);
  }
  tmp___10 = vmw_gmr_count_descriptors(pages, num_pages);
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 2160UL;
  __cil_tmp29 = *((uint32_t *)__cil_tmp28);
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  if (tmp___10 > __cil_tmp30) {
    return (-22);
  }
  INIT_LIST_HEAD(& desc_pages);
  ret = vmw_gmr_build_descriptors(& desc_pages, pages, num_pages);
  __cil_tmp31 = ret != 0;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = (long )__cil_tmp33;
  tmp___11 = ldv__builtin_expect(__cil_tmp34, 0L);
  if (tmp___11) {
    return (ret);
  }
  vmw_gmr_fire_descriptors(dev_priv, gmr_id, & desc_pages);
  vmw_gmr_free_descriptors(& desc_pages);
  return (0);
}
}
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ long tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct mutex *__cil_tmp18 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2156UL;
  __cil_tmp6 = *((uint32_t *)__cil_tmp5);
  __cil_tmp7 = __cil_tmp6 & 4194304U;
  __cil_tmp8 = ! __cil_tmp7;
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = (long )__cil_tmp9;
  tmp___7 = ldv__builtin_expect(__cil_tmp10, 1L);
  if (tmp___7) {
    vmw_gmr2_unbind(dev_priv, gmr_id);
    return;
  }
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2184UL;
  __cil_tmp13 = (struct mutex *)__cil_tmp12;
  mutex_lock(__cil_tmp13);
  __cil_tmp14 = (uint32_t )gmr_id;
  vmw_write(dev_priv, 41U, __cil_tmp14);
  __asm__  volatile   ("sfence": : : "memory");
  __cil_tmp15 = (uint32_t )0;
  vmw_write(dev_priv, 42U, __cil_tmp15);
  __asm__  volatile   ("mfence": : : "memory");
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 2184UL;
  __cil_tmp18 = (struct mutex *)__cil_tmp17;
  mutex_unlock(__cil_tmp18);
  return;
}
}
 static void list_add(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_add(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_add(struct list_head *new , struct list_head *head ) 
{ struct list_head *__cil_tmp3 ;

  {
  __cil_tmp3 = *((struct list_head **)head);
  __list_add(new, head, __cil_tmp3);
  return;
}
}
 static void list_move(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_move(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  __list_del_entry(list);
  list_add(list, head);
  return;
}
}
 static void * __attribute__((__warn_unused_result__)) ERR_PTR(long error )  __attribute__((__no_instrument_function__)) ;
 static void * __attribute__((__warn_unused_result__)) ERR_PTR(long error )  __attribute__((__no_instrument_function__)) ;
 static void * __attribute__((__warn_unused_result__)) ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
extern unsigned int ioread32(void * ) ;
extern void iowrite32(u32  , void * ) ;
 static unsigned int inl(int port )  __attribute__((__no_instrument_function__)) ;
 static unsigned int inl(int port )  __attribute__((__no_instrument_function__)) ;
 static unsigned int inl(int port ) 
{ unsigned int value ;

  {
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  return (value);
}
}
extern void kfree(void * ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
 static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
 static void *kmalloc_array(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kmalloc_array(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned long __cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
  if (size != 0UL) {
    __cil_tmp5 = 0xffffffffffffffffUL / size;
    if (n > __cil_tmp5) {
      return ((void *)0);
    }
  }
  __cil_tmp6 = n * size;
  tmp = __kmalloc(__cil_tmp6, flags);
  return (tmp);
}
}
 static void *kcalloc(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kcalloc(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned int __cil_tmp5 ;

  {
  __cil_tmp5 = flags | 32768U;
  tmp = kmalloc_array(n, size, __cil_tmp5);
  return (tmp);
}
}
 static void *kzalloc(size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kzalloc(size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
 static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;
  unsigned int __cil_tmp4 ;

  {
  __cil_tmp4 = flags | 32768U;
  tmp = kmalloc(size, __cil_tmp4);
  return (tmp);
}
}
extern void drm_ut_debug_printk(unsigned int request_level , char *prefix , char *function_name ,
                                char *format  , ...) ;
extern void drm_crtc_cleanup(struct drm_crtc *crtc ) ;
extern void drm_connector_cleanup(struct drm_connector *connector ) ;
extern void drm_encoder_cleanup(struct drm_encoder *encoder ) ;
extern void drm_mode_probed_add(struct drm_connector *connector , struct drm_display_mode *mode ) ;
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev , struct drm_display_mode *mode ) ;
extern void drm_mode_config_init(struct drm_device *dev ) ;
extern void drm_mode_config_cleanup(struct drm_device *dev ) ;
extern void drm_mode_destroy(struct drm_device *dev , struct drm_display_mode *mode ) ;
extern int drm_mode_vrefresh(struct drm_display_mode *mode ) ;
extern void drm_mode_connector_list_update(struct drm_connector *connector ) ;
extern int drm_framebuffer_init(struct drm_device *dev , struct drm_framebuffer *fb ,
                                struct drm_framebuffer_funcs *funcs ) ;
extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb ) ;
extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev , uint32_t id ,
                                                    uint32_t type ) ;
extern void drm_fb_get_bpp_depth(uint32_t format , unsigned int *depth , int *bpp ) ;
extern struct drm_master *drm_master_get(struct drm_master *master ) ;
extern void drm_master_put(struct drm_master **master ) ;
 static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem )  __attribute__((__no_instrument_function__)) ;
 static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem )  __attribute__((__no_instrument_function__)) ;
 static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  enum __anonenum_bo_kmap_type_427 __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  __cil_tmp3 = (unsigned long )map;
  __cil_tmp4 = __cil_tmp3 + 16UL;
  __cil_tmp5 = *((enum __anonenum_bo_kmap_type_427 *)__cil_tmp4);
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = __cil_tmp6 & 128U;
  __cil_tmp8 = ! __cil_tmp7;
  __cil_tmp9 = ! __cil_tmp8;
  *is_iomem = (bool )__cil_tmp9;
  return (*((void **)map));
}
}
extern int ttm_bo_kmap(struct ttm_buffer_object *bo , unsigned long start_page , unsigned long num_pages ,
                       struct ttm_bo_kmap_obj *map ) ;
extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj *map ) ;
extern int ttm_bo_reserve(struct ttm_buffer_object *bo , bool interruptible , bool no_wait ,
                          bool use_sequence , uint32_t sequence ) ;
extern void ttm_bo_unreserve(struct ttm_buffer_object *bo ) ;
extern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file *tfile ,
                                                      uint32_t key ) ;
extern void ttm_base_object_unref(struct ttm_base_object **p_base ) ;
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) ;
 static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset ) 
{ uint32_t val ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2104UL;
  __cil_tmp6 = *((unsigned int *)__cil_tmp5);
  __cil_tmp7 = (int )__cil_tmp6;
  outl(offset, __cil_tmp7);
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2104UL;
  __cil_tmp10 = *((unsigned int *)__cil_tmp9);
  __cil_tmp11 = __cil_tmp10 + 1U;
  __cil_tmp12 = (int )__cil_tmp11;
  val = inl(__cil_tmp12);
  return (val);
}
}
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) ;
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) ;
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) ;
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) ;
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) ;
int vmw_kms_init(struct vmw_private *dev_priv ) ;
int vmw_kms_close(struct vmw_private *dev_priv ) ;
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) ;
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) ;
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) ;
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) ;
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) ;
int vmw_enable_vblank(struct drm_device *dev , int crtc ) ;
void vmw_disable_vblank(struct drm_device *dev , int crtc ) ;
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) ;
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) ;
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) ;
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) ;
 static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf ) 
{ struct vmw_resource *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct vmw_resource *)srf;
  vmw_resource_reference(__cil_tmp2);
  return (srf);
}
}
 static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf ) 
{ struct ttm_buffer_object *tmp___7 ;
  struct ttm_buffer_object *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  __cil_tmp3 = (struct ttm_buffer_object *)buf;
  tmp___7 = ttm_bo_reference(__cil_tmp3);
  if (tmp___7) {
    return (buf);
  }
  __cil_tmp4 = (void *)0;
  return ((struct vmw_dma_buffer *)__cil_tmp4);
}
}
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) ;
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) ;
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) ;
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) ;
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
void vmw_du_crtc_save(struct drm_crtc *crtc ) ;
void vmw_du_crtc_restore(struct drm_crtc *crtc ) ;
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) ;
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) ;
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) ;
void vmw_du_connector_save(struct drm_connector *connector ) ;
void vmw_du_connector_restore(struct drm_connector *connector ) ;
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) ;
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) ;
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) ;
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) ;
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) ;
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) ;
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) ;
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
void vmw_clip_cliprects(struct drm_clip_rect *rects , int num_rects , int clip_x151 ,
                        int clip_x250 , int clip_y149 , int clip_y248 , SVGASignedRect *out_rects ,
                        int *out_num ) 
{ int i ;
  int k ;
  int x1 ;
  int __max1 ;
  int __max2 ;
  int tmp___7 ;
  int y1 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___8 ;
  int x2 ;
  int __min1 ;
  int __min2 ;
  int tmp___9 ;
  int y2 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___10 ;
  struct drm_clip_rect *__cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  struct drm_clip_rect *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned short __cil_tmp29 ;
  struct drm_clip_rect *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned short __cil_tmp33 ;
  struct drm_clip_rect *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned short __cil_tmp37 ;
  SVGASignedRect *__cil_tmp38 ;
  SVGASignedRect *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  SVGASignedRect *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  SVGASignedRect *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;

  {
  i = 0;
  k = 0;
  while (1) {

    if (! (i < num_rects)) {
      goto while_break;
    }
    __max1 = clip_x151;
    __cil_tmp24 = rects + i;
    __cil_tmp25 = *((unsigned short *)__cil_tmp24);
    __max2 = (int )__cil_tmp25;
    if (__max1 > __max2) {
      tmp___7 = __max1;
    } else {
      tmp___7 = __max2;
    }
    x1 = tmp___7;
    __max1___0 = clip_y149;
    __cil_tmp26 = rects + i;
    __cil_tmp27 = (unsigned long )__cil_tmp26;
    __cil_tmp28 = __cil_tmp27 + 2UL;
    __cil_tmp29 = *((unsigned short *)__cil_tmp28);
    __max2___0 = (int )__cil_tmp29;
    if (__max1___0 > __max2___0) {
      tmp___8 = __max1___0;
    } else {
      tmp___8 = __max2___0;
    }
    y1 = tmp___8;
    __min1 = clip_x250;
    __cil_tmp30 = rects + i;
    __cil_tmp31 = (unsigned long )__cil_tmp30;
    __cil_tmp32 = __cil_tmp31 + 4UL;
    __cil_tmp33 = *((unsigned short *)__cil_tmp32);
    __min2 = (int )__cil_tmp33;
    if (__min1 < __min2) {
      tmp___9 = __min1;
    } else {
      tmp___9 = __min2;
    }
    x2 = tmp___9;
    __min1___0 = clip_y248;
    __cil_tmp34 = rects + i;
    __cil_tmp35 = (unsigned long )__cil_tmp34;
    __cil_tmp36 = __cil_tmp35 + 6UL;
    __cil_tmp37 = *((unsigned short *)__cil_tmp36);
    __min2___0 = (int )__cil_tmp37;
    if (__min1___0 < __min2___0) {
      tmp___10 = __min1___0;
    } else {
      tmp___10 = __min2___0;
    }
    y2 = tmp___10;
    if (x1 >= x2) {
      goto __Cont;
    }
    if (y1 >= y2) {
      goto __Cont;
    }
    __cil_tmp38 = out_rects + k;
    *((int32 *)__cil_tmp38) = x1;
    __cil_tmp39 = out_rects + k;
    __cil_tmp40 = (unsigned long )__cil_tmp39;
    __cil_tmp41 = __cil_tmp40 + 4UL;
    *((int32 *)__cil_tmp41) = y1;
    __cil_tmp42 = out_rects + k;
    __cil_tmp43 = (unsigned long )__cil_tmp42;
    __cil_tmp44 = __cil_tmp43 + 8UL;
    *((int32 *)__cil_tmp44) = x2;
    __cil_tmp45 = out_rects + k;
    __cil_tmp46 = (unsigned long )__cil_tmp45;
    __cil_tmp47 = __cil_tmp46 + 12UL;
    *((int32 *)__cil_tmp47) = y2;
    k ++;
    __Cont: 
    i ++;
  }
  while_break: 
  *out_num = k;
  return;
}
}
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct vmw_surface **__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_dma_buffer **__cil_tmp11 ;
  struct drm_crtc *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_encoder *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_connector *__cil_tmp18 ;

  {
  __cil_tmp2 = (unsigned long )du;
  __cil_tmp3 = __cil_tmp2 + 1992UL;
  if (*((struct vmw_surface **)__cil_tmp3)) {
    __cil_tmp4 = (unsigned long )du;
    __cil_tmp5 = __cil_tmp4 + 1992UL;
    __cil_tmp6 = (struct vmw_surface **)__cil_tmp5;
    vmw_surface_unreference(__cil_tmp6);
  }
  __cil_tmp7 = (unsigned long )du;
  __cil_tmp8 = __cil_tmp7 + 2000UL;
  if (*((struct vmw_dma_buffer **)__cil_tmp8)) {
    __cil_tmp9 = (unsigned long )du;
    __cil_tmp10 = __cil_tmp9 + 2000UL;
    __cil_tmp11 = (struct vmw_dma_buffer **)__cil_tmp10;
    vmw_dmabuf_unreference(__cil_tmp11);
  }
  __cil_tmp12 = (struct drm_crtc *)du;
  drm_crtc_cleanup(__cil_tmp12);
  __cil_tmp13 = (unsigned long )du;
  __cil_tmp14 = __cil_tmp13 + 544UL;
  __cil_tmp15 = (struct drm_encoder *)__cil_tmp14;
  drm_encoder_cleanup(__cil_tmp15);
  __cil_tmp16 = (unsigned long )du;
  __cil_tmp17 = __cil_tmp16 + 616UL;
  __cil_tmp18 = (struct drm_connector *)__cil_tmp17;
  drm_connector_cleanup(__cil_tmp18);
  return;
}
}
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct __anonstruct_cmd_429___0 *cmd ;
  u32 image_size ;
  u32 cmd_size ;
  void *tmp___7 ;
  long tmp___8 ;
  size_t __len ;
  void *__ret ;
  u32 __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  void *__cil_tmp24 ;
  struct __anonstruct_cmd_429___0 *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  __cil_tmp14 = width * height;
  image_size = __cil_tmp14 * 4U;
  __cil_tmp15 = (unsigned long )image_size;
  __cil_tmp16 = 24UL + __cil_tmp15;
  cmd_size = (u32 )__cil_tmp16;
  if (! image) {
    return (-22);
  }
  tmp___7 = vmw_fifo_reserve(dev_priv, cmd_size);
  cmd = (struct __anonstruct_cmd_429___0 *)tmp___7;
  __cil_tmp17 = (void *)0;
  __cil_tmp18 = (unsigned long )__cil_tmp17;
  __cil_tmp19 = (unsigned long )cmd;
  __cil_tmp20 = __cil_tmp19 == __cil_tmp18;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = (long )__cil_tmp22;
  tmp___8 = ldv__builtin_expect(__cil_tmp23, 0L);
  if (tmp___8) {
    drm_err("vmw_cursor_update_image", "Fifo reserve failed.\n");
    return (-12);
  }
  __cil_tmp24 = (void *)cmd;
  memset(__cil_tmp24, 0, 24UL);
  __len = (size_t )image_size;
  __cil_tmp25 = cmd + 1;
  __cil_tmp26 = (void *)__cil_tmp25;
  __cil_tmp27 = (void *)image;
  __ret = __builtin_memcpy(__cil_tmp26, __cil_tmp27, __len);
  *((u32 *)cmd) = (__u32 )22;
  __cil_tmp28 = (unsigned long )cmd;
  __cil_tmp29 = __cil_tmp28 + 4UL;
  *((uint32 *)__cil_tmp29) = (__u32 )0;
  __cil_tmp30 = 16;
  __cil_tmp31 = (unsigned long )cmd;
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
  *((uint32 *)__cil_tmp32) = width;
  __cil_tmp33 = 20;
  __cil_tmp34 = (unsigned long )cmd;
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
  *((uint32 *)__cil_tmp35) = height;
  __cil_tmp36 = 8;
  __cil_tmp37 = (unsigned long )cmd;
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
  *((uint32 *)__cil_tmp38) = hotspotX;
  __cil_tmp39 = 12;
  __cil_tmp40 = (unsigned long )cmd;
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
  *((uint32 *)__cil_tmp41) = hotspotY;
  vmw_fifo_commit(dev_priv, cmd_size);
  return (0);
}
}
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  void *virtual ;
  bool dummy ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp15 ;
  u32 __cil_tmp16 ;
  u32 __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_buffer_object *__cil_tmp21 ;
  bool __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct ttm_buffer_object *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  u32 *__cil_tmp35 ;
  struct ttm_buffer_object *__cil_tmp36 ;

  {
  kmap_offset = 0UL;
  __cil_tmp15 = 1UL << 12;
  __cil_tmp16 = width * height;
  __cil_tmp17 = __cil_tmp16 * 4U;
  __cil_tmp18 = (unsigned long )__cil_tmp17;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp15;
  __cil_tmp20 = __cil_tmp19 - 1UL;
  kmap_num = __cil_tmp20 >> 12;
  __cil_tmp21 = (struct ttm_buffer_object *)dmabuf;
  __cil_tmp22 = (bool )1;
  __cil_tmp23 = (bool )0;
  __cil_tmp24 = (bool )0;
  __cil_tmp25 = (uint32_t )0;
  ret = ttm_bo_reserve(__cil_tmp21, __cil_tmp22, __cil_tmp23, __cil_tmp24, __cil_tmp25);
  __cil_tmp26 = ret != 0;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___7) {
    drm_err("vmw_cursor_update_dmabuf", "reserve failed\n");
    return (-22);
  }
  __cil_tmp30 = (struct ttm_buffer_object *)dmabuf;
  ret = ttm_bo_kmap(__cil_tmp30, kmap_offset, kmap_num, & map);
  __cil_tmp31 = ret != 0;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = (long )__cil_tmp33;
  tmp___8 = ldv__builtin_expect(__cil_tmp34, 0L);
  if (tmp___8) {
    goto err_unreserve;
  }
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
  __cil_tmp35 = (u32 *)virtual;
  ret = vmw_cursor_update_image(dev_priv, __cil_tmp35, width, height, hotspotX, hotspotY);
  ttm_bo_kunmap(& map);
  err_unreserve: 
  __cil_tmp36 = (struct ttm_buffer_object *)dmabuf;
  ttm_bo_unreserve(__cil_tmp36);
  return (ret);
}
}
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) 
{ __le32 *fifo_mem ;
  uint32_t count ;
  int tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  u32 __cil_tmp10 ;
  __le32 *__cil_tmp11 ;
  void *__cil_tmp12 ;
  u32 __cil_tmp13 ;
  __le32 *__cil_tmp14 ;
  void *__cil_tmp15 ;
  u32 __cil_tmp16 ;
  __le32 *__cil_tmp17 ;
  void *__cil_tmp18 ;
  __le32 *__cil_tmp19 ;
  void *__cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp9);
  if (show) {
    tmp___7 = 1;
  } else {
    tmp___7 = 0;
  }
  __cil_tmp10 = (u32 )tmp___7;
  __cil_tmp11 = fifo_mem + 9;
  __cil_tmp12 = (void *)__cil_tmp11;
  iowrite32(__cil_tmp10, __cil_tmp12);
  __cil_tmp13 = (u32 )x;
  __cil_tmp14 = fifo_mem + 10;
  __cil_tmp15 = (void *)__cil_tmp14;
  iowrite32(__cil_tmp13, __cil_tmp15);
  __cil_tmp16 = (u32 )y;
  __cil_tmp17 = fifo_mem + 11;
  __cil_tmp18 = (void *)__cil_tmp17;
  iowrite32(__cil_tmp16, __cil_tmp18);
  __cil_tmp19 = fifo_mem + 12;
  __cil_tmp20 = (void *)__cil_tmp19;
  count = ioread32(__cil_tmp20);
  count ++;
  __cil_tmp21 = fifo_mem + 12;
  __cil_tmp22 = (void *)__cil_tmp21;
  iowrite32(count, __cil_tmp22);
  return;
}
}
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_display_unit *du ;
  struct drm_crtc *__mptr ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *dmabuf ;
  int ret ;
  struct drm_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_display_unit *__cil_tmp18 ;
  struct drm_crtc *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  struct vmw_surface **__cil_tmp23 ;
  void *__cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  void *__cil_tmp26 ;
  struct vmw_surface **__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_surface **__cil_tmp29 ;
  struct vmw_surface *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  uint32_t *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_surface *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface **__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct vmw_dma_buffer **__cil_tmp49 ;
  struct vmw_surface **__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct vmw_surface *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct vmw_surface *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct vmw_surface **__cil_tmp68 ;
  struct vmw_surface *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t *__cil_tmp72 ;
  u32 __cil_tmp73 ;
  u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  int __cil_tmp77 ;
  u32 __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  int __cil_tmp81 ;
  u32 __cil_tmp82 ;
  struct vmw_dma_buffer **__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct vmw_dma_buffer **__cil_tmp86 ;
  struct vmw_dma_buffer **__cil_tmp87 ;
  struct vmw_dma_buffer *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  int __cil_tmp91 ;
  u32 __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  u32 __cil_tmp96 ;
  bool __cil_tmp97 ;
  bool __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;

  {
  __cil_tmp15 = *((struct drm_device **)crtc);
  tmp___7 = vmw_priv(__cil_tmp15);
  dev_priv = tmp___7;
  tmp___8 = vmw_fpriv(file_priv);
  __cil_tmp16 = (unsigned long )tmp___8;
  __cil_tmp17 = __cil_tmp16 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp17);
  __mptr = crtc;
  __cil_tmp18 = (struct vmw_display_unit *)0;
  __cil_tmp19 = (struct drm_crtc *)__cil_tmp18;
  __cil_tmp20 = (unsigned int )__cil_tmp19;
  __cil_tmp21 = (char *)__mptr;
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
  du = (struct vmw_display_unit *)__cil_tmp22;
  __cil_tmp23 = & surface;
  __cil_tmp24 = (void *)0;
  *__cil_tmp23 = (struct vmw_surface *)__cil_tmp24;
  __cil_tmp25 = & dmabuf;
  __cil_tmp26 = (void *)0;
  *__cil_tmp25 = (struct vmw_dma_buffer *)__cil_tmp26;
  if (handle) {
    if (width != 64U) {
      return (-22);
    } else
    if (height != 64U) {
      return (-22);
    }
  }
  if (handle) {
    ret = vmw_user_lookup_handle(dev_priv, tfile, handle, & surface, & dmabuf);
    if (ret) {
      drm_err("vmw_du_crtc_cursor_set", "failed to find surface or dmabuf: %i\n",
              ret);
      return (-22);
    }
  }
  __cil_tmp27 = & surface;
  if (*__cil_tmp27) {
    __cil_tmp28 = 176;
    __cil_tmp29 = & surface;
    __cil_tmp30 = *__cil_tmp29;
    __cil_tmp31 = (unsigned long )__cil_tmp30;
    __cil_tmp32 = __cil_tmp31 + __cil_tmp28;
    __cil_tmp33 = *((uint32_t **)__cil_tmp32);
    if (! __cil_tmp33) {
      drm_err("vmw_du_crtc_cursor_set", "surface not suitable for cursor\n");
      vmw_surface_unreference(& surface);
      return (-22);
    }
  }
  __cil_tmp34 = (unsigned long )du;
  __cil_tmp35 = __cil_tmp34 + 1992UL;
  if (*((struct vmw_surface **)__cil_tmp35)) {
    __cil_tmp36 = (unsigned long )du;
    __cil_tmp37 = __cil_tmp36 + 1992UL;
    __cil_tmp38 = *((struct vmw_surface **)__cil_tmp37);
    __cil_tmp39 = (unsigned long )__cil_tmp38;
    __cil_tmp40 = __cil_tmp39 + 160UL;
    __cil_tmp41 = (void *)0;
    *((struct drm_crtc **)__cil_tmp40) = (struct drm_crtc *)__cil_tmp41;
    __cil_tmp42 = (unsigned long )du;
    __cil_tmp43 = __cil_tmp42 + 1992UL;
    __cil_tmp44 = (struct vmw_surface **)__cil_tmp43;
    vmw_surface_unreference(__cil_tmp44);
  }
  __cil_tmp45 = (unsigned long )du;
  __cil_tmp46 = __cil_tmp45 + 2000UL;
  if (*((struct vmw_dma_buffer **)__cil_tmp46)) {
    __cil_tmp47 = (unsigned long )du;
    __cil_tmp48 = __cil_tmp47 + 2000UL;
    __cil_tmp49 = (struct vmw_dma_buffer **)__cil_tmp48;
    vmw_dmabuf_unreference(__cil_tmp49);
  }
  __cil_tmp50 = & surface;
  if (*__cil_tmp50) {
    __cil_tmp51 = (unsigned long )du;
    __cil_tmp52 = __cil_tmp51 + 1992UL;
    __cil_tmp53 = & surface;
    *((struct vmw_surface **)__cil_tmp52) = *__cil_tmp53;
    __cil_tmp54 = (unsigned long )du;
    __cil_tmp55 = __cil_tmp54 + 1992UL;
    __cil_tmp56 = *((struct vmw_surface **)__cil_tmp55);
    __cil_tmp57 = (unsigned long )__cil_tmp56;
    __cil_tmp58 = __cil_tmp57 + 160UL;
    *((struct drm_crtc **)__cil_tmp58) = crtc;
    __cil_tmp59 = (unsigned long )du;
    __cil_tmp60 = __cil_tmp59 + 2008UL;
    __cil_tmp61 = 168;
    __cil_tmp62 = (unsigned long )du;
    __cil_tmp63 = __cil_tmp62 + 1992UL;
    __cil_tmp64 = *((struct vmw_surface **)__cil_tmp63);
    __cil_tmp65 = (unsigned long )__cil_tmp64;
    __cil_tmp66 = __cil_tmp65 + __cil_tmp61;
    *((size_t *)__cil_tmp60) = *((size_t *)__cil_tmp66);
    __cil_tmp67 = 176;
    __cil_tmp68 = & surface;
    __cil_tmp69 = *__cil_tmp68;
    __cil_tmp70 = (unsigned long )__cil_tmp69;
    __cil_tmp71 = __cil_tmp70 + __cil_tmp67;
    __cil_tmp72 = *((uint32_t **)__cil_tmp71);
    __cil_tmp73 = (u32 )64;
    __cil_tmp74 = (u32 )64;
    __cil_tmp75 = (unsigned long )du;
    __cil_tmp76 = __cil_tmp75 + 2024UL;
    __cil_tmp77 = *((int *)__cil_tmp76);
    __cil_tmp78 = (u32 )__cil_tmp77;
    __cil_tmp79 = (unsigned long )du;
    __cil_tmp80 = __cil_tmp79 + 2028UL;
    __cil_tmp81 = *((int *)__cil_tmp80);
    __cil_tmp82 = (u32 )__cil_tmp81;
    vmw_cursor_update_image(dev_priv, __cil_tmp72, __cil_tmp73, __cil_tmp74, __cil_tmp78,
                            __cil_tmp82);
  } else {
    __cil_tmp83 = & dmabuf;
    if (*__cil_tmp83) {
      __cil_tmp84 = (unsigned long )du;
      __cil_tmp85 = __cil_tmp84 + 2000UL;
      __cil_tmp86 = & dmabuf;
      *((struct vmw_dma_buffer **)__cil_tmp85) = *__cil_tmp86;
      __cil_tmp87 = & dmabuf;
      __cil_tmp88 = *__cil_tmp87;
      __cil_tmp89 = (unsigned long )du;
      __cil_tmp90 = __cil_tmp89 + 2024UL;
      __cil_tmp91 = *((int *)__cil_tmp90);
      __cil_tmp92 = (u32 )__cil_tmp91;
      __cil_tmp93 = (unsigned long )du;
      __cil_tmp94 = __cil_tmp93 + 2028UL;
      __cil_tmp95 = *((int *)__cil_tmp94);
      __cil_tmp96 = (u32 )__cil_tmp95;
      ret = vmw_cursor_update_dmabuf(dev_priv, __cil_tmp88, width, height, __cil_tmp92,
                                     __cil_tmp96);
    } else {
      __cil_tmp97 = (bool )0;
      vmw_cursor_update_position(dev_priv, __cil_tmp97, 0, 0);
      return (0);
    }
  }
  __cil_tmp98 = (bool )1;
  __cil_tmp99 = (unsigned long )du;
  __cil_tmp100 = __cil_tmp99 + 2024UL;
  __cil_tmp101 = *((int *)__cil_tmp100);
  __cil_tmp102 = (unsigned long )du;
  __cil_tmp103 = __cil_tmp102 + 2016UL;
  __cil_tmp104 = *((int *)__cil_tmp103);
  __cil_tmp105 = __cil_tmp104 + __cil_tmp101;
  __cil_tmp106 = (unsigned long )du;
  __cil_tmp107 = __cil_tmp106 + 2028UL;
  __cil_tmp108 = *((int *)__cil_tmp107);
  __cil_tmp109 = (unsigned long )du;
  __cil_tmp110 = __cil_tmp109 + 2020UL;
  __cil_tmp111 = *((int *)__cil_tmp110);
  __cil_tmp112 = __cil_tmp111 + __cil_tmp108;
  vmw_cursor_update_position(dev_priv, __cil_tmp98, __cil_tmp105, __cil_tmp112);
  return (0);
}
}
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_display_unit *du ;
  struct drm_crtc *__mptr ;
  bool shown ;
  int tmp___8 ;
  struct drm_device *__cil_tmp10 ;
  struct vmw_display_unit *__cil_tmp11 ;
  struct drm_crtc *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;

  {
  __cil_tmp10 = *((struct drm_device **)crtc);
  tmp___7 = vmw_priv(__cil_tmp10);
  dev_priv = tmp___7;
  __mptr = crtc;
  __cil_tmp11 = (struct vmw_display_unit *)0;
  __cil_tmp12 = (struct drm_crtc *)__cil_tmp11;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  __cil_tmp14 = (char *)__mptr;
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
  du = (struct vmw_display_unit *)__cil_tmp15;
  __cil_tmp16 = (unsigned long )du;
  __cil_tmp17 = __cil_tmp16 + 1992UL;
  if (*((struct vmw_surface **)__cil_tmp17)) {
    tmp___8 = 1;
  } else {
    __cil_tmp18 = (unsigned long )du;
    __cil_tmp19 = __cil_tmp18 + 2000UL;
    if (*((struct vmw_dma_buffer **)__cil_tmp19)) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
  }
  shown = (bool )tmp___8;
  __cil_tmp20 = (unsigned long )du;
  __cil_tmp21 = __cil_tmp20 + 2016UL;
  __cil_tmp22 = (unsigned long )crtc;
  __cil_tmp23 = __cil_tmp22 + 480UL;
  __cil_tmp24 = *((int *)__cil_tmp23);
  *((int *)__cil_tmp21) = x + __cil_tmp24;
  __cil_tmp25 = (unsigned long )du;
  __cil_tmp26 = __cil_tmp25 + 2020UL;
  __cil_tmp27 = (unsigned long )crtc;
  __cil_tmp28 = __cil_tmp27 + 484UL;
  __cil_tmp29 = *((int *)__cil_tmp28);
  *((int *)__cil_tmp26) = y + __cil_tmp29;
  __cil_tmp30 = (unsigned long )du;
  __cil_tmp31 = __cil_tmp30 + 2024UL;
  __cil_tmp32 = *((int *)__cil_tmp31);
  __cil_tmp33 = (unsigned long )du;
  __cil_tmp34 = __cil_tmp33 + 2016UL;
  __cil_tmp35 = *((int *)__cil_tmp34);
  __cil_tmp36 = __cil_tmp35 + __cil_tmp32;
  __cil_tmp37 = (unsigned long )du;
  __cil_tmp38 = __cil_tmp37 + 2028UL;
  __cil_tmp39 = *((int *)__cil_tmp38);
  __cil_tmp40 = (unsigned long )du;
  __cil_tmp41 = __cil_tmp40 + 2020UL;
  __cil_tmp42 = *((int *)__cil_tmp41);
  __cil_tmp43 = __cil_tmp42 + __cil_tmp39;
  vmw_cursor_update_position(dev_priv, shown, __cil_tmp36, __cil_tmp43);
  return (0);
}
}
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  SVGA3dCopyBox *box ;
  unsigned int box_count ;
  void *virtual ;
  bool dummy ;
  struct vmw_dma_cmd *cmd ;
  int i ;
  int ret ;
  SVGA3dCmdHeader *__mptr ;
  long tmp___7 ;
  long tmp___8 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct vmw_dma_cmd *__cil_tmp22 ;
  SVGA3dCmdHeader *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32 __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32 __cil_tmp44 ;
  struct vmw_dma_cmd *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  uint32 __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  uint32 __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint32 __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32 __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32 __cil_tmp69 ;
  uint32 __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  uint32 __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  uint32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  uint32 __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  uint32 __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  uint32 __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  uint32 __cil_tmp91 ;
  uint32 __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  uint32 __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  uint32 __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  uint32 __cil_tmp101 ;
  uint32 __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  uint32 __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  uint32 __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  uint32 __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  uint32 __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  uint32 __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  uint32 __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  uint32 __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  uint32 __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  uint32 __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  uint32 __cil_tmp135 ;
  uint32 __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  uint32 __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  uint32 __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  uint32 __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  uint32 __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  uint32 __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  uint32 __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  uint32 __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  uint32 __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  uint32 __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  uint32 __cil_tmp169 ;
  uint32 __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  uint32 __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  uint32 __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  uint32 __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  uint32 __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  uint32 __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  uint32 __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  uint32 __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  uint32 __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint32 __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  uint32 __cil_tmp203 ;
  uint32 __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  uint32 __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  uint32 __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  uint32 __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  uint32 __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  uint32 __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  uint32 __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  uint32 __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  uint32 __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  uint32 __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  uint32 __cil_tmp237 ;
  uint32 __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  uint32 __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  uint32 __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  uint32 __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  uint32 __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  uint32 __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  uint32 __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  uint32 __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  uint32 __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  uint32 __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  uint32 __cil_tmp271 ;
  uint32 __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  uint32 __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  uint32 __cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  uint32 __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  uint32 __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  uint32 __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  uint32 __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  uint32 __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  uint32 __cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  uint32 __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  uint32 __cil_tmp305 ;
  uint32 __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  uint32 __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  uint32 __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  unsigned long __cil_tmp314 ;
  uint32 __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  uint32 __cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  uint32 __cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;
  unsigned long __cil_tmp325 ;
  unsigned long __cil_tmp326 ;
  uint32 __cil_tmp327 ;
  unsigned long __cil_tmp328 ;
  unsigned long __cil_tmp329 ;
  uint32 __cil_tmp330 ;
  unsigned long __cil_tmp331 ;
  unsigned long __cil_tmp332 ;
  uint32 __cil_tmp333 ;
  unsigned long __cil_tmp334 ;
  unsigned long __cil_tmp335 ;
  uint32 __cil_tmp336 ;
  uint32 __cil_tmp337 ;
  unsigned long __cil_tmp338 ;
  unsigned long __cil_tmp339 ;
  uint32 __cil_tmp340 ;
  unsigned long __cil_tmp341 ;
  unsigned long __cil_tmp342 ;
  uint32 __cil_tmp343 ;
  unsigned long __cil_tmp344 ;
  unsigned long __cil_tmp345 ;
  uint32 __cil_tmp346 ;
  unsigned long __cil_tmp347 ;
  unsigned long __cil_tmp348 ;
  uint32 __cil_tmp349 ;
  unsigned long __cil_tmp350 ;
  unsigned long __cil_tmp351 ;
  uint32 __cil_tmp352 ;
  unsigned long __cil_tmp353 ;
  unsigned long __cil_tmp354 ;
  unsigned long __cil_tmp355 ;
  unsigned long __cil_tmp356 ;
  unsigned long __cil_tmp357 ;
  uint32 __cil_tmp358 ;
  unsigned long __cil_tmp359 ;
  unsigned long __cil_tmp360 ;
  unsigned long __cil_tmp361 ;
  unsigned long __cil_tmp362 ;
  unsigned long __cil_tmp363 ;
  uint32 __cil_tmp364 ;
  uint32 __cil_tmp365 ;
  int __cil_tmp366 ;
  bool __cil_tmp367 ;
  bool __cil_tmp368 ;
  bool __cil_tmp369 ;
  uint32_t __cil_tmp370 ;
  int __cil_tmp371 ;
  int __cil_tmp372 ;
  int __cil_tmp373 ;
  long __cil_tmp374 ;
  int __cil_tmp375 ;
  int __cil_tmp376 ;
  int __cil_tmp377 ;
  long __cil_tmp378 ;
  unsigned long __cil_tmp379 ;
  unsigned long __cil_tmp380 ;
  uint32 __cil_tmp381 ;
  unsigned long __cil_tmp382 ;
  unsigned long __cil_tmp383 ;
  unsigned long __cil_tmp384 ;
  unsigned long __cil_tmp385 ;
  uint32 __cil_tmp386 ;
  unsigned long __cil_tmp387 ;
  unsigned long __cil_tmp388 ;
  unsigned long __cil_tmp389 ;
  uint32_t *__cil_tmp390 ;
  void *__cil_tmp391 ;
  void *__cil_tmp392 ;
  unsigned long __cil_tmp393 ;
  unsigned long __cil_tmp394 ;
  unsigned long __cil_tmp395 ;
  uint32_t *__cil_tmp396 ;
  void *__cil_tmp397 ;
  void *__cil_tmp398 ;
  unsigned long __cil_tmp399 ;
  unsigned long __cil_tmp400 ;
  uint32 __cil_tmp401 ;
  uint32 __cil_tmp402 ;
  unsigned long __cil_tmp403 ;
  unsigned long __cil_tmp404 ;
  uint32 __cil_tmp405 ;
  uint32 __cil_tmp406 ;
  int __cil_tmp407 ;
  unsigned long __cil_tmp408 ;
  unsigned long __cil_tmp409 ;
  unsigned long __cil_tmp410 ;
  uint32_t *__cil_tmp411 ;
  uint32_t *__cil_tmp412 ;
  void *__cil_tmp413 ;
  unsigned long __cil_tmp414 ;
  unsigned long __cil_tmp415 ;
  unsigned long __cil_tmp416 ;
  unsigned long __cil_tmp417 ;
  uint32 __cil_tmp418 ;
  uint32 __cil_tmp419 ;
  uint32 __cil_tmp420 ;
  void *__cil_tmp421 ;
  void *__cil_tmp422 ;
  unsigned long __cil_tmp423 ;
  unsigned long __cil_tmp424 ;
  unsigned long __cil_tmp425 ;
  unsigned long __cil_tmp426 ;
  unsigned long __cil_tmp427 ;
  unsigned long __cil_tmp428 ;
  size_t __cil_tmp429 ;

  {
  __mptr = header;
  __cil_tmp22 = (struct vmw_dma_cmd *)0;
  __cil_tmp23 = (SVGA3dCmdHeader *)__cil_tmp22;
  __cil_tmp24 = (unsigned int )__cil_tmp23;
  __cil_tmp25 = (char *)__mptr;
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
  cmd = (struct vmw_dma_cmd *)__cil_tmp26;
  __cil_tmp27 = 176;
  __cil_tmp28 = (unsigned long )srf;
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
  __cil_tmp30 = *((uint32_t **)__cil_tmp29);
  if (! __cil_tmp30) {
    return;
  }
  __cil_tmp31 = 16;
  __cil_tmp32 = 8UL + __cil_tmp31;
  __cil_tmp33 = (unsigned long )cmd;
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
  __cil_tmp35 = *((uint32 *)__cil_tmp34);
  if (__cil_tmp35 != 0U) {
    drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
    return;
  } else {
    __cil_tmp36 = 20;
    __cil_tmp37 = 8UL + __cil_tmp36;
    __cil_tmp38 = (unsigned long )cmd;
    __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
    __cil_tmp40 = *((uint32 *)__cil_tmp39);
    if (__cil_tmp40 != 0U) {
      drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
      return;
    }
  }
  __cil_tmp41 = 4;
  __cil_tmp42 = (unsigned long )cmd;
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
  __cil_tmp44 = *((uint32 *)__cil_tmp43);
  if (__cil_tmp44 < 64U) {
    drm_err("vmw_kms_cursor_snoop", "at least one full copy box must be given\n");
    return;
  }
  __cil_tmp45 = cmd + 1;
  box = (SVGA3dCopyBox *)__cil_tmp45;
  __cil_tmp46 = 4;
  __cil_tmp47 = (unsigned long )cmd;
  __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
  __cil_tmp49 = *((uint32 *)__cil_tmp48);
  __cil_tmp50 = (unsigned long )__cil_tmp49;
  __cil_tmp51 = __cil_tmp50 - 28UL;
  __cil_tmp52 = __cil_tmp51 / 36UL;
  box_count = (unsigned int )__cil_tmp52;
  __cil_tmp53 = 1UL << 12;
  __cil_tmp54 = 4;
  __cil_tmp55 = __cil_tmp54;
  __cil_tmp56 = 8UL + __cil_tmp55;
  __cil_tmp57 = (unsigned long )cmd;
  __cil_tmp58 = __cil_tmp57 + __cil_tmp56;
  __cil_tmp59 = *((uint32 *)__cil_tmp58);
  __cil_tmp60 = (unsigned long )__cil_tmp59;
  if (__cil_tmp60 % __cil_tmp53) {
    drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
    __cil_tmp61 = (unsigned long )box;
    __cil_tmp62 = __cil_tmp61 + 24UL;
    __cil_tmp63 = *((uint32 *)__cil_tmp62);
    __cil_tmp64 = (unsigned long )box;
    __cil_tmp65 = __cil_tmp64 + 28UL;
    __cil_tmp66 = *((uint32 *)__cil_tmp65);
    __cil_tmp67 = (unsigned long )box;
    __cil_tmp68 = __cil_tmp67 + 32UL;
    __cil_tmp69 = *((uint32 *)__cil_tmp68);
    __cil_tmp70 = *((uint32 *)box);
    __cil_tmp71 = (unsigned long )box;
    __cil_tmp72 = __cil_tmp71 + 4UL;
    __cil_tmp73 = *((uint32 *)__cil_tmp72);
    __cil_tmp74 = (unsigned long )box;
    __cil_tmp75 = __cil_tmp74 + 8UL;
    __cil_tmp76 = *((uint32 *)__cil_tmp75);
    __cil_tmp77 = (unsigned long )box;
    __cil_tmp78 = __cil_tmp77 + 12UL;
    __cil_tmp79 = *((uint32 *)__cil_tmp78);
    __cil_tmp80 = (unsigned long )box;
    __cil_tmp81 = __cil_tmp80 + 16UL;
    __cil_tmp82 = *((uint32 *)__cil_tmp81);
    __cil_tmp83 = (unsigned long )box;
    __cil_tmp84 = __cil_tmp83 + 20UL;
    __cil_tmp85 = *((uint32 *)__cil_tmp84);
    __cil_tmp86 = 4;
    __cil_tmp87 = __cil_tmp86;
    __cil_tmp88 = 8UL + __cil_tmp87;
    __cil_tmp89 = (unsigned long )cmd;
    __cil_tmp90 = __cil_tmp89 + __cil_tmp88;
    __cil_tmp91 = *((uint32 *)__cil_tmp90);
    drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
            __cil_tmp63, __cil_tmp66, __cil_tmp69, __cil_tmp70, __cil_tmp73, __cil_tmp76,
            __cil_tmp79, __cil_tmp82, __cil_tmp85, box_count, __cil_tmp91);
    return;
  } else {
    __cil_tmp92 = *((uint32 *)box);
    if (__cil_tmp92 != 0U) {
      drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
      __cil_tmp93 = (unsigned long )box;
      __cil_tmp94 = __cil_tmp93 + 24UL;
      __cil_tmp95 = *((uint32 *)__cil_tmp94);
      __cil_tmp96 = (unsigned long )box;
      __cil_tmp97 = __cil_tmp96 + 28UL;
      __cil_tmp98 = *((uint32 *)__cil_tmp97);
      __cil_tmp99 = (unsigned long )box;
      __cil_tmp100 = __cil_tmp99 + 32UL;
      __cil_tmp101 = *((uint32 *)__cil_tmp100);
      __cil_tmp102 = *((uint32 *)box);
      __cil_tmp103 = (unsigned long )box;
      __cil_tmp104 = __cil_tmp103 + 4UL;
      __cil_tmp105 = *((uint32 *)__cil_tmp104);
      __cil_tmp106 = (unsigned long )box;
      __cil_tmp107 = __cil_tmp106 + 8UL;
      __cil_tmp108 = *((uint32 *)__cil_tmp107);
      __cil_tmp109 = (unsigned long )box;
      __cil_tmp110 = __cil_tmp109 + 12UL;
      __cil_tmp111 = *((uint32 *)__cil_tmp110);
      __cil_tmp112 = (unsigned long )box;
      __cil_tmp113 = __cil_tmp112 + 16UL;
      __cil_tmp114 = *((uint32 *)__cil_tmp113);
      __cil_tmp115 = (unsigned long )box;
      __cil_tmp116 = __cil_tmp115 + 20UL;
      __cil_tmp117 = *((uint32 *)__cil_tmp116);
      __cil_tmp118 = 4;
      __cil_tmp119 = __cil_tmp118;
      __cil_tmp120 = 8UL + __cil_tmp119;
      __cil_tmp121 = (unsigned long )cmd;
      __cil_tmp122 = __cil_tmp121 + __cil_tmp120;
      __cil_tmp123 = *((uint32 *)__cil_tmp122);
      drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
              __cil_tmp95, __cil_tmp98, __cil_tmp101, __cil_tmp102, __cil_tmp105,
              __cil_tmp108, __cil_tmp111, __cil_tmp114, __cil_tmp117, box_count, __cil_tmp123);
      return;
    } else {
      __cil_tmp124 = (unsigned long )box;
      __cil_tmp125 = __cil_tmp124 + 4UL;
      __cil_tmp126 = *((uint32 *)__cil_tmp125);
      if (__cil_tmp126 != 0U) {
        drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
        __cil_tmp127 = (unsigned long )box;
        __cil_tmp128 = __cil_tmp127 + 24UL;
        __cil_tmp129 = *((uint32 *)__cil_tmp128);
        __cil_tmp130 = (unsigned long )box;
        __cil_tmp131 = __cil_tmp130 + 28UL;
        __cil_tmp132 = *((uint32 *)__cil_tmp131);
        __cil_tmp133 = (unsigned long )box;
        __cil_tmp134 = __cil_tmp133 + 32UL;
        __cil_tmp135 = *((uint32 *)__cil_tmp134);
        __cil_tmp136 = *((uint32 *)box);
        __cil_tmp137 = (unsigned long )box;
        __cil_tmp138 = __cil_tmp137 + 4UL;
        __cil_tmp139 = *((uint32 *)__cil_tmp138);
        __cil_tmp140 = (unsigned long )box;
        __cil_tmp141 = __cil_tmp140 + 8UL;
        __cil_tmp142 = *((uint32 *)__cil_tmp141);
        __cil_tmp143 = (unsigned long )box;
        __cil_tmp144 = __cil_tmp143 + 12UL;
        __cil_tmp145 = *((uint32 *)__cil_tmp144);
        __cil_tmp146 = (unsigned long )box;
        __cil_tmp147 = __cil_tmp146 + 16UL;
        __cil_tmp148 = *((uint32 *)__cil_tmp147);
        __cil_tmp149 = (unsigned long )box;
        __cil_tmp150 = __cil_tmp149 + 20UL;
        __cil_tmp151 = *((uint32 *)__cil_tmp150);
        __cil_tmp152 = 4;
        __cil_tmp153 = __cil_tmp152;
        __cil_tmp154 = 8UL + __cil_tmp153;
        __cil_tmp155 = (unsigned long )cmd;
        __cil_tmp156 = __cil_tmp155 + __cil_tmp154;
        __cil_tmp157 = *((uint32 *)__cil_tmp156);
        drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                __cil_tmp129, __cil_tmp132, __cil_tmp135, __cil_tmp136, __cil_tmp139,
                __cil_tmp142, __cil_tmp145, __cil_tmp148, __cil_tmp151, box_count,
                __cil_tmp157);
        return;
      } else {
        __cil_tmp158 = (unsigned long )box;
        __cil_tmp159 = __cil_tmp158 + 8UL;
        __cil_tmp160 = *((uint32 *)__cil_tmp159);
        if (__cil_tmp160 != 0U) {
          drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
          __cil_tmp161 = (unsigned long )box;
          __cil_tmp162 = __cil_tmp161 + 24UL;
          __cil_tmp163 = *((uint32 *)__cil_tmp162);
          __cil_tmp164 = (unsigned long )box;
          __cil_tmp165 = __cil_tmp164 + 28UL;
          __cil_tmp166 = *((uint32 *)__cil_tmp165);
          __cil_tmp167 = (unsigned long )box;
          __cil_tmp168 = __cil_tmp167 + 32UL;
          __cil_tmp169 = *((uint32 *)__cil_tmp168);
          __cil_tmp170 = *((uint32 *)box);
          __cil_tmp171 = (unsigned long )box;
          __cil_tmp172 = __cil_tmp171 + 4UL;
          __cil_tmp173 = *((uint32 *)__cil_tmp172);
          __cil_tmp174 = (unsigned long )box;
          __cil_tmp175 = __cil_tmp174 + 8UL;
          __cil_tmp176 = *((uint32 *)__cil_tmp175);
          __cil_tmp177 = (unsigned long )box;
          __cil_tmp178 = __cil_tmp177 + 12UL;
          __cil_tmp179 = *((uint32 *)__cil_tmp178);
          __cil_tmp180 = (unsigned long )box;
          __cil_tmp181 = __cil_tmp180 + 16UL;
          __cil_tmp182 = *((uint32 *)__cil_tmp181);
          __cil_tmp183 = (unsigned long )box;
          __cil_tmp184 = __cil_tmp183 + 20UL;
          __cil_tmp185 = *((uint32 *)__cil_tmp184);
          __cil_tmp186 = 4;
          __cil_tmp187 = __cil_tmp186;
          __cil_tmp188 = 8UL + __cil_tmp187;
          __cil_tmp189 = (unsigned long )cmd;
          __cil_tmp190 = __cil_tmp189 + __cil_tmp188;
          __cil_tmp191 = *((uint32 *)__cil_tmp190);
          drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                  __cil_tmp163, __cil_tmp166, __cil_tmp169, __cil_tmp170, __cil_tmp173,
                  __cil_tmp176, __cil_tmp179, __cil_tmp182, __cil_tmp185, box_count,
                  __cil_tmp191);
          return;
        } else {
          __cil_tmp192 = (unsigned long )box;
          __cil_tmp193 = __cil_tmp192 + 24UL;
          __cil_tmp194 = *((uint32 *)__cil_tmp193);
          if (__cil_tmp194 != 0U) {
            drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
            __cil_tmp195 = (unsigned long )box;
            __cil_tmp196 = __cil_tmp195 + 24UL;
            __cil_tmp197 = *((uint32 *)__cil_tmp196);
            __cil_tmp198 = (unsigned long )box;
            __cil_tmp199 = __cil_tmp198 + 28UL;
            __cil_tmp200 = *((uint32 *)__cil_tmp199);
            __cil_tmp201 = (unsigned long )box;
            __cil_tmp202 = __cil_tmp201 + 32UL;
            __cil_tmp203 = *((uint32 *)__cil_tmp202);
            __cil_tmp204 = *((uint32 *)box);
            __cil_tmp205 = (unsigned long )box;
            __cil_tmp206 = __cil_tmp205 + 4UL;
            __cil_tmp207 = *((uint32 *)__cil_tmp206);
            __cil_tmp208 = (unsigned long )box;
            __cil_tmp209 = __cil_tmp208 + 8UL;
            __cil_tmp210 = *((uint32 *)__cil_tmp209);
            __cil_tmp211 = (unsigned long )box;
            __cil_tmp212 = __cil_tmp211 + 12UL;
            __cil_tmp213 = *((uint32 *)__cil_tmp212);
            __cil_tmp214 = (unsigned long )box;
            __cil_tmp215 = __cil_tmp214 + 16UL;
            __cil_tmp216 = *((uint32 *)__cil_tmp215);
            __cil_tmp217 = (unsigned long )box;
            __cil_tmp218 = __cil_tmp217 + 20UL;
            __cil_tmp219 = *((uint32 *)__cil_tmp218);
            __cil_tmp220 = 4;
            __cil_tmp221 = __cil_tmp220;
            __cil_tmp222 = 8UL + __cil_tmp221;
            __cil_tmp223 = (unsigned long )cmd;
            __cil_tmp224 = __cil_tmp223 + __cil_tmp222;
            __cil_tmp225 = *((uint32 *)__cil_tmp224);
            drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                    __cil_tmp197, __cil_tmp200, __cil_tmp203, __cil_tmp204, __cil_tmp207,
                    __cil_tmp210, __cil_tmp213, __cil_tmp216, __cil_tmp219, box_count,
                    __cil_tmp225);
            return;
          } else {
            __cil_tmp226 = (unsigned long )box;
            __cil_tmp227 = __cil_tmp226 + 28UL;
            __cil_tmp228 = *((uint32 *)__cil_tmp227);
            if (__cil_tmp228 != 0U) {
              drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
              __cil_tmp229 = (unsigned long )box;
              __cil_tmp230 = __cil_tmp229 + 24UL;
              __cil_tmp231 = *((uint32 *)__cil_tmp230);
              __cil_tmp232 = (unsigned long )box;
              __cil_tmp233 = __cil_tmp232 + 28UL;
              __cil_tmp234 = *((uint32 *)__cil_tmp233);
              __cil_tmp235 = (unsigned long )box;
              __cil_tmp236 = __cil_tmp235 + 32UL;
              __cil_tmp237 = *((uint32 *)__cil_tmp236);
              __cil_tmp238 = *((uint32 *)box);
              __cil_tmp239 = (unsigned long )box;
              __cil_tmp240 = __cil_tmp239 + 4UL;
              __cil_tmp241 = *((uint32 *)__cil_tmp240);
              __cil_tmp242 = (unsigned long )box;
              __cil_tmp243 = __cil_tmp242 + 8UL;
              __cil_tmp244 = *((uint32 *)__cil_tmp243);
              __cil_tmp245 = (unsigned long )box;
              __cil_tmp246 = __cil_tmp245 + 12UL;
              __cil_tmp247 = *((uint32 *)__cil_tmp246);
              __cil_tmp248 = (unsigned long )box;
              __cil_tmp249 = __cil_tmp248 + 16UL;
              __cil_tmp250 = *((uint32 *)__cil_tmp249);
              __cil_tmp251 = (unsigned long )box;
              __cil_tmp252 = __cil_tmp251 + 20UL;
              __cil_tmp253 = *((uint32 *)__cil_tmp252);
              __cil_tmp254 = 4;
              __cil_tmp255 = __cil_tmp254;
              __cil_tmp256 = 8UL + __cil_tmp255;
              __cil_tmp257 = (unsigned long )cmd;
              __cil_tmp258 = __cil_tmp257 + __cil_tmp256;
              __cil_tmp259 = *((uint32 *)__cil_tmp258);
              drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                      __cil_tmp231, __cil_tmp234, __cil_tmp237, __cil_tmp238, __cil_tmp241,
                      __cil_tmp244, __cil_tmp247, __cil_tmp250, __cil_tmp253, box_count,
                      __cil_tmp259);
              return;
            } else {
              __cil_tmp260 = (unsigned long )box;
              __cil_tmp261 = __cil_tmp260 + 32UL;
              __cil_tmp262 = *((uint32 *)__cil_tmp261);
              if (__cil_tmp262 != 0U) {
                drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
                __cil_tmp263 = (unsigned long )box;
                __cil_tmp264 = __cil_tmp263 + 24UL;
                __cil_tmp265 = *((uint32 *)__cil_tmp264);
                __cil_tmp266 = (unsigned long )box;
                __cil_tmp267 = __cil_tmp266 + 28UL;
                __cil_tmp268 = *((uint32 *)__cil_tmp267);
                __cil_tmp269 = (unsigned long )box;
                __cil_tmp270 = __cil_tmp269 + 32UL;
                __cil_tmp271 = *((uint32 *)__cil_tmp270);
                __cil_tmp272 = *((uint32 *)box);
                __cil_tmp273 = (unsigned long )box;
                __cil_tmp274 = __cil_tmp273 + 4UL;
                __cil_tmp275 = *((uint32 *)__cil_tmp274);
                __cil_tmp276 = (unsigned long )box;
                __cil_tmp277 = __cil_tmp276 + 8UL;
                __cil_tmp278 = *((uint32 *)__cil_tmp277);
                __cil_tmp279 = (unsigned long )box;
                __cil_tmp280 = __cil_tmp279 + 12UL;
                __cil_tmp281 = *((uint32 *)__cil_tmp280);
                __cil_tmp282 = (unsigned long )box;
                __cil_tmp283 = __cil_tmp282 + 16UL;
                __cil_tmp284 = *((uint32 *)__cil_tmp283);
                __cil_tmp285 = (unsigned long )box;
                __cil_tmp286 = __cil_tmp285 + 20UL;
                __cil_tmp287 = *((uint32 *)__cil_tmp286);
                __cil_tmp288 = 4;
                __cil_tmp289 = __cil_tmp288;
                __cil_tmp290 = 8UL + __cil_tmp289;
                __cil_tmp291 = (unsigned long )cmd;
                __cil_tmp292 = __cil_tmp291 + __cil_tmp290;
                __cil_tmp293 = *((uint32 *)__cil_tmp292);
                drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                        __cil_tmp265, __cil_tmp268, __cil_tmp271, __cil_tmp272, __cil_tmp275,
                        __cil_tmp278, __cil_tmp281, __cil_tmp284, __cil_tmp287, box_count,
                        __cil_tmp293);
                return;
              } else {
                __cil_tmp294 = (unsigned long )box;
                __cil_tmp295 = __cil_tmp294 + 20UL;
                __cil_tmp296 = *((uint32 *)__cil_tmp295);
                if (__cil_tmp296 != 1U) {
                  drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
                  __cil_tmp297 = (unsigned long )box;
                  __cil_tmp298 = __cil_tmp297 + 24UL;
                  __cil_tmp299 = *((uint32 *)__cil_tmp298);
                  __cil_tmp300 = (unsigned long )box;
                  __cil_tmp301 = __cil_tmp300 + 28UL;
                  __cil_tmp302 = *((uint32 *)__cil_tmp301);
                  __cil_tmp303 = (unsigned long )box;
                  __cil_tmp304 = __cil_tmp303 + 32UL;
                  __cil_tmp305 = *((uint32 *)__cil_tmp304);
                  __cil_tmp306 = *((uint32 *)box);
                  __cil_tmp307 = (unsigned long )box;
                  __cil_tmp308 = __cil_tmp307 + 4UL;
                  __cil_tmp309 = *((uint32 *)__cil_tmp308);
                  __cil_tmp310 = (unsigned long )box;
                  __cil_tmp311 = __cil_tmp310 + 8UL;
                  __cil_tmp312 = *((uint32 *)__cil_tmp311);
                  __cil_tmp313 = (unsigned long )box;
                  __cil_tmp314 = __cil_tmp313 + 12UL;
                  __cil_tmp315 = *((uint32 *)__cil_tmp314);
                  __cil_tmp316 = (unsigned long )box;
                  __cil_tmp317 = __cil_tmp316 + 16UL;
                  __cil_tmp318 = *((uint32 *)__cil_tmp317);
                  __cil_tmp319 = (unsigned long )box;
                  __cil_tmp320 = __cil_tmp319 + 20UL;
                  __cil_tmp321 = *((uint32 *)__cil_tmp320);
                  __cil_tmp322 = 4;
                  __cil_tmp323 = __cil_tmp322;
                  __cil_tmp324 = 8UL + __cil_tmp323;
                  __cil_tmp325 = (unsigned long )cmd;
                  __cil_tmp326 = __cil_tmp325 + __cil_tmp324;
                  __cil_tmp327 = *((uint32 *)__cil_tmp326);
                  drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                          __cil_tmp299, __cil_tmp302, __cil_tmp305, __cil_tmp306,
                          __cil_tmp309, __cil_tmp312, __cil_tmp315, __cil_tmp318,
                          __cil_tmp321, box_count, __cil_tmp327);
                  return;
                } else
                if (box_count != 1U) {
                  drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
                  __cil_tmp328 = (unsigned long )box;
                  __cil_tmp329 = __cil_tmp328 + 24UL;
                  __cil_tmp330 = *((uint32 *)__cil_tmp329);
                  __cil_tmp331 = (unsigned long )box;
                  __cil_tmp332 = __cil_tmp331 + 28UL;
                  __cil_tmp333 = *((uint32 *)__cil_tmp332);
                  __cil_tmp334 = (unsigned long )box;
                  __cil_tmp335 = __cil_tmp334 + 32UL;
                  __cil_tmp336 = *((uint32 *)__cil_tmp335);
                  __cil_tmp337 = *((uint32 *)box);
                  __cil_tmp338 = (unsigned long )box;
                  __cil_tmp339 = __cil_tmp338 + 4UL;
                  __cil_tmp340 = *((uint32 *)__cil_tmp339);
                  __cil_tmp341 = (unsigned long )box;
                  __cil_tmp342 = __cil_tmp341 + 8UL;
                  __cil_tmp343 = *((uint32 *)__cil_tmp342);
                  __cil_tmp344 = (unsigned long )box;
                  __cil_tmp345 = __cil_tmp344 + 12UL;
                  __cil_tmp346 = *((uint32 *)__cil_tmp345);
                  __cil_tmp347 = (unsigned long )box;
                  __cil_tmp348 = __cil_tmp347 + 16UL;
                  __cil_tmp349 = *((uint32 *)__cil_tmp348);
                  __cil_tmp350 = (unsigned long )box;
                  __cil_tmp351 = __cil_tmp350 + 20UL;
                  __cil_tmp352 = *((uint32 *)__cil_tmp351);
                  __cil_tmp353 = 4;
                  __cil_tmp354 = __cil_tmp353;
                  __cil_tmp355 = 8UL + __cil_tmp354;
                  __cil_tmp356 = (unsigned long )cmd;
                  __cil_tmp357 = __cil_tmp356 + __cil_tmp355;
                  __cil_tmp358 = *((uint32 *)__cil_tmp357);
                  drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
                          __cil_tmp330, __cil_tmp333, __cil_tmp336, __cil_tmp337,
                          __cil_tmp340, __cil_tmp343, __cil_tmp346, __cil_tmp349,
                          __cil_tmp352, box_count, __cil_tmp358);
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
  __cil_tmp359 = 4;
  __cil_tmp360 = __cil_tmp359;
  __cil_tmp361 = 8UL + __cil_tmp360;
  __cil_tmp362 = (unsigned long )cmd;
  __cil_tmp363 = __cil_tmp362 + __cil_tmp361;
  __cil_tmp364 = *((uint32 *)__cil_tmp363);
  __cil_tmp365 = __cil_tmp364 >> 12;
  kmap_offset = (unsigned long )__cil_tmp365;
  __cil_tmp366 = 16384 >> 12;
  kmap_num = (unsigned long )__cil_tmp366;
  __cil_tmp367 = (bool )1;
  __cil_tmp368 = (bool )0;
  __cil_tmp369 = (bool )0;
  __cil_tmp370 = (uint32_t )0;
  ret = ttm_bo_reserve(bo, __cil_tmp367, __cil_tmp368, __cil_tmp369, __cil_tmp370);
  __cil_tmp371 = ret != 0;
  __cil_tmp372 = ! __cil_tmp371;
  __cil_tmp373 = ! __cil_tmp372;
  __cil_tmp374 = (long )__cil_tmp373;
  tmp___7 = ldv__builtin_expect(__cil_tmp374, 0L);
  if (tmp___7) {
    drm_err("vmw_kms_cursor_snoop", "reserve failed\n");
    return;
  }
  ret = ttm_bo_kmap(bo, kmap_offset, kmap_num, & map);
  __cil_tmp375 = ret != 0;
  __cil_tmp376 = ! __cil_tmp375;
  __cil_tmp377 = ! __cil_tmp376;
  __cil_tmp378 = (long )__cil_tmp377;
  tmp___8 = ldv__builtin_expect(__cil_tmp378, 0L);
  if (tmp___8) {
    goto err_unreserve;
  }
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
  __cil_tmp379 = (unsigned long )box;
  __cil_tmp380 = __cil_tmp379 + 12UL;
  __cil_tmp381 = *((uint32 *)__cil_tmp380);
  if (__cil_tmp381 == 64U) {
    __cil_tmp382 = 8;
    __cil_tmp383 = 8UL + __cil_tmp382;
    __cil_tmp384 = (unsigned long )cmd;
    __cil_tmp385 = __cil_tmp384 + __cil_tmp383;
    __cil_tmp386 = *((uint32 *)__cil_tmp385);
    if (__cil_tmp386 == 256U) {
      __len = (size_t )16384;
      if (__len >= 64UL) {
        __cil_tmp387 = 176;
        __cil_tmp388 = (unsigned long )srf;
        __cil_tmp389 = __cil_tmp388 + __cil_tmp387;
        __cil_tmp390 = *((uint32_t **)__cil_tmp389);
        __cil_tmp391 = (void *)__cil_tmp390;
        __cil_tmp392 = virtual;
        __ret = __memcpy(__cil_tmp391, __cil_tmp392, __len);
      } else {
        __cil_tmp393 = 176;
        __cil_tmp394 = (unsigned long )srf;
        __cil_tmp395 = __cil_tmp394 + __cil_tmp393;
        __cil_tmp396 = *((uint32_t **)__cil_tmp395);
        __cil_tmp397 = (void *)__cil_tmp396;
        __cil_tmp398 = virtual;
        __ret = __builtin_memcpy(__cil_tmp397, __cil_tmp398, __len);
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    i = 0;
    while (1) {
      __cil_tmp399 = (unsigned long )box;
      __cil_tmp400 = __cil_tmp399 + 16UL;
      __cil_tmp401 = *((uint32 *)__cil_tmp400);
      __cil_tmp402 = (uint32 )i;
      if (! (__cil_tmp402 < __cil_tmp401)) {
        goto while_break;
      }
      __cil_tmp403 = (unsigned long )box;
      __cil_tmp404 = __cil_tmp403 + 12UL;
      __cil_tmp405 = *((uint32 *)__cil_tmp404);
      __cil_tmp406 = __cil_tmp405 * 4U;
      __len___0 = (size_t )__cil_tmp406;
      __cil_tmp407 = i * 64;
      __cil_tmp408 = 176;
      __cil_tmp409 = (unsigned long )srf;
      __cil_tmp410 = __cil_tmp409 + __cil_tmp408;
      __cil_tmp411 = *((uint32_t **)__cil_tmp410);
      __cil_tmp412 = __cil_tmp411 + __cil_tmp407;
      __cil_tmp413 = (void *)__cil_tmp412;
      __cil_tmp414 = 8;
      __cil_tmp415 = 8UL + __cil_tmp414;
      __cil_tmp416 = (unsigned long )cmd;
      __cil_tmp417 = __cil_tmp416 + __cil_tmp415;
      __cil_tmp418 = *((uint32 *)__cil_tmp417);
      __cil_tmp419 = (uint32 )i;
      __cil_tmp420 = __cil_tmp419 * __cil_tmp418;
      __cil_tmp421 = virtual + __cil_tmp420;
      __cil_tmp422 = __cil_tmp421;
      __ret___0 = __builtin_memcpy(__cil_tmp413, __cil_tmp422, __len___0);
      i ++;
    }
    while_break: ;
  }
  __cil_tmp423 = 168;
  __cil_tmp424 = (unsigned long )srf;
  __cil_tmp425 = __cil_tmp424 + __cil_tmp423;
  __cil_tmp426 = 168;
  __cil_tmp427 = (unsigned long )srf;
  __cil_tmp428 = __cil_tmp427 + __cil_tmp426;
  __cil_tmp429 = *((size_t *)__cil_tmp428);
  *((size_t *)__cil_tmp425) = __cil_tmp429 + 1UL;
  ttm_bo_kunmap(& map);
  err_unreserve: 
  ttm_bo_unreserve(bo);
  return;
}
}
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_crtc *crtc ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct drm_crtc *__mptr___1 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct mutex *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  struct drm_crtc *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_display_unit *__cil_tmp33 ;
  struct drm_crtc *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct vmw_surface *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_surface *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  size_t __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  size_t __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct vmw_surface *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct vmw_surface *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  uint32_t *__cil_tmp65 ;
  u32 __cil_tmp66 ;
  u32 __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int __cil_tmp70 ;
  u32 __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  u32 __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  struct drm_crtc *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct list_head *__cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct mutex *__cil_tmp88 ;

  {
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp9);
  __cil_tmp10 = (unsigned long )dev;
  __cil_tmp11 = __cil_tmp10 + 1152UL;
  __cil_tmp12 = (struct mutex *)__cil_tmp11;
  mutex_lock(__cil_tmp12);
  __cil_tmp13 = 1448;
  __cil_tmp14 = (unsigned long )dev;
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
  __cil_tmp16 = *((struct list_head **)__cil_tmp15);
  __mptr = __cil_tmp16;
  __cil_tmp17 = (struct drm_crtc *)0;
  __cil_tmp18 = (unsigned long )__cil_tmp17;
  __cil_tmp19 = __cil_tmp18 + 8UL;
  __cil_tmp20 = (struct list_head *)__cil_tmp19;
  __cil_tmp21 = (unsigned int )__cil_tmp20;
  __cil_tmp22 = (char *)__mptr;
  __cil_tmp23 = __cil_tmp22 - __cil_tmp21;
  crtc = (struct drm_crtc *)__cil_tmp23;
  while (1) {
    __cil_tmp24 = 1448;
    __cil_tmp25 = (unsigned long )dev;
    __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
    __cil_tmp27 = (struct list_head *)__cil_tmp26;
    __cil_tmp28 = (unsigned long )__cil_tmp27;
    __cil_tmp29 = (unsigned long )crtc;
    __cil_tmp30 = __cil_tmp29 + 8UL;
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
    __cil_tmp32 = (unsigned long )__cil_tmp31;
    if (! (__cil_tmp32 != __cil_tmp28)) {
      goto while_break;
    }
    __mptr___1 = crtc;
    __cil_tmp33 = (struct vmw_display_unit *)0;
    __cil_tmp34 = (struct drm_crtc *)__cil_tmp33;
    __cil_tmp35 = (unsigned int )__cil_tmp34;
    __cil_tmp36 = (char *)__mptr___1;
    __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
    du = (struct vmw_display_unit *)__cil_tmp37;
    __cil_tmp38 = (unsigned long )du;
    __cil_tmp39 = __cil_tmp38 + 1992UL;
    __cil_tmp40 = *((struct vmw_surface **)__cil_tmp39);
    if (! __cil_tmp40) {
      goto __Cont;
    } else {
      __cil_tmp41 = 168;
      __cil_tmp42 = (unsigned long )du;
      __cil_tmp43 = __cil_tmp42 + 1992UL;
      __cil_tmp44 = *((struct vmw_surface **)__cil_tmp43);
      __cil_tmp45 = (unsigned long )__cil_tmp44;
      __cil_tmp46 = __cil_tmp45 + __cil_tmp41;
      __cil_tmp47 = *((size_t *)__cil_tmp46);
      __cil_tmp48 = (unsigned long )du;
      __cil_tmp49 = __cil_tmp48 + 2008UL;
      __cil_tmp50 = *((size_t *)__cil_tmp49);
      if (__cil_tmp50 == __cil_tmp47) {
        goto __Cont;
      }
    }
    __cil_tmp51 = (unsigned long )du;
    __cil_tmp52 = __cil_tmp51 + 2008UL;
    __cil_tmp53 = 168;
    __cil_tmp54 = (unsigned long )du;
    __cil_tmp55 = __cil_tmp54 + 1992UL;
    __cil_tmp56 = *((struct vmw_surface **)__cil_tmp55);
    __cil_tmp57 = (unsigned long )__cil_tmp56;
    __cil_tmp58 = __cil_tmp57 + __cil_tmp53;
    *((size_t *)__cil_tmp52) = *((size_t *)__cil_tmp58);
    __cil_tmp59 = 176;
    __cil_tmp60 = (unsigned long )du;
    __cil_tmp61 = __cil_tmp60 + 1992UL;
    __cil_tmp62 = *((struct vmw_surface **)__cil_tmp61);
    __cil_tmp63 = (unsigned long )__cil_tmp62;
    __cil_tmp64 = __cil_tmp63 + __cil_tmp59;
    __cil_tmp65 = *((uint32_t **)__cil_tmp64);
    __cil_tmp66 = (u32 )64;
    __cil_tmp67 = (u32 )64;
    __cil_tmp68 = (unsigned long )du;
    __cil_tmp69 = __cil_tmp68 + 2024UL;
    __cil_tmp70 = *((int *)__cil_tmp69);
    __cil_tmp71 = (u32 )__cil_tmp70;
    __cil_tmp72 = (unsigned long )du;
    __cil_tmp73 = __cil_tmp72 + 2028UL;
    __cil_tmp74 = *((int *)__cil_tmp73);
    __cil_tmp75 = (u32 )__cil_tmp74;
    vmw_cursor_update_image(dev_priv, __cil_tmp65, __cil_tmp66, __cil_tmp67, __cil_tmp71,
                            __cil_tmp75);
    __Cont: 
    __cil_tmp76 = (unsigned long )crtc;
    __cil_tmp77 = __cil_tmp76 + 8UL;
    __cil_tmp78 = *((struct list_head **)__cil_tmp77);
    __mptr___0 = __cil_tmp78;
    __cil_tmp79 = (struct drm_crtc *)0;
    __cil_tmp80 = (unsigned long )__cil_tmp79;
    __cil_tmp81 = __cil_tmp80 + 8UL;
    __cil_tmp82 = (struct list_head *)__cil_tmp81;
    __cil_tmp83 = (unsigned int )__cil_tmp82;
    __cil_tmp84 = (char *)__mptr___0;
    __cil_tmp85 = __cil_tmp84 - __cil_tmp83;
    crtc = (struct drm_crtc *)__cil_tmp85;
  }
  while_break: 
  __cil_tmp86 = (unsigned long )dev;
  __cil_tmp87 = __cil_tmp86 + 1152UL;
  __cil_tmp88 = (struct mutex *)__cil_tmp87;
  mutex_unlock(__cil_tmp88);
  return;
}
}
int vmw_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                  unsigned int *handle ) 
{ 

  {
  if (handle) {
    *handle = 0U;
  }
  return (0);
}
}
void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  struct vmw_framebuffer_surface *__cil_tmp6 ;
  struct drm_framebuffer *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct drm_master *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct mutex *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct mutex *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct drm_master **__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct vmw_surface **__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_base_object **__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
  __mptr = framebuffer;
  __cil_tmp6 = (struct vmw_framebuffer_surface *)0;
  __cil_tmp7 = (struct drm_framebuffer *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  vfbs = (struct vmw_framebuffer_surface *)__cil_tmp10;
  __cil_tmp11 = (unsigned long )vfbs;
  __cil_tmp12 = __cil_tmp11 + 192UL;
  __cil_tmp13 = *((struct drm_master **)__cil_tmp12);
  tmp___7 = vmw_master(__cil_tmp13);
  vmaster = tmp___7;
  __cil_tmp14 = (unsigned long )vmaster;
  __cil_tmp15 = __cil_tmp14 + 152UL;
  __cil_tmp16 = (struct mutex *)__cil_tmp15;
  mutex_lock(__cil_tmp16);
  __cil_tmp17 = (unsigned long )vfbs;
  __cil_tmp18 = __cil_tmp17 + 176UL;
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
  list_del(__cil_tmp19);
  __cil_tmp20 = (unsigned long )vmaster;
  __cil_tmp21 = __cil_tmp20 + 152UL;
  __cil_tmp22 = (struct mutex *)__cil_tmp21;
  mutex_unlock(__cil_tmp22);
  __cil_tmp23 = (unsigned long )vfbs;
  __cil_tmp24 = __cil_tmp23 + 192UL;
  __cil_tmp25 = (struct drm_master **)__cil_tmp24;
  drm_master_put(__cil_tmp25);
  drm_framebuffer_cleanup(framebuffer);
  __cil_tmp26 = (unsigned long )vfbs;
  __cil_tmp27 = __cil_tmp26 + 160UL;
  __cil_tmp28 = (struct vmw_surface **)__cil_tmp27;
  vmw_surface_unreference(__cil_tmp28);
  __cil_tmp29 = 144;
  __cil_tmp30 = (unsigned long )vfbs;
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
  __cil_tmp32 = (struct ttm_base_object **)__cil_tmp31;
  ttm_base_object_unref(__cil_tmp32);
  __cil_tmp33 = (void *)vfbs;
  kfree(__cil_tmp33);
  return;
}
}
static int do_surface_dirty_sou(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                struct vmw_framebuffer *framebuffer , unsigned int flags ,
                                unsigned int color , struct drm_clip_rect *clips ,
                                unsigned int num_clips , int inc , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *clips_ptr ;
  struct drm_clip_rect *tmp___7 ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_430 *cmd ;
  SVGASignedRect *blits ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int tmp___8 ;
  struct drm_crtc *__mptr___1 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  int __min1 ;
  int __min2 ;
  int tmp___15 ;
  int __max1 ;
  int __max2 ;
  int tmp___16 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___17 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___18 ;
  struct vmw_display_unit *unit ;
  int num ;
  long tmp___19 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_device *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct list_head *__cil_tmp56 ;
  struct drm_crtc *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  struct drm_device *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct list_head *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  struct list_head *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct drm_framebuffer *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct drm_framebuffer *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct vmw_display_unit *__cil_tmp84 ;
  struct drm_crtc *__cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  struct list_head *__cil_tmp91 ;
  struct drm_crtc *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  struct list_head *__cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  void *__cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  void *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  struct __anonstruct_cmd_430 *__cil_tmp118 ;
  unsigned short __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned short __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned short __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned short __cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned short __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned short __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned short __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned short __cil_tmp139 ;
  void *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  size_t __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned int __cil_tmp160 ;
  struct drm_clip_rect *__cil_tmp161 ;
  unsigned short __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  struct drm_clip_rect *__cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned short __cil_tmp170 ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  struct drm_clip_rect *__cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned short __cil_tmp178 ;
  int __cil_tmp179 ;
  int __cil_tmp180 ;
  struct drm_clip_rect *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned short __cil_tmp186 ;
  int __cil_tmp187 ;
  int __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  int __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  int __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  int __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  int __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  int __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  int __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  int __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  int __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  int __cil_tmp251 ;
  int *__cil_tmp252 ;
  int __cil_tmp253 ;
  int *__cil_tmp254 ;
  int __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  size_t __cil_tmp261 ;
  void *__cil_tmp262 ;
  void *__cil_tmp263 ;
  uint32_t __cil_tmp264 ;
  uint64_t __cil_tmp265 ;
  void *__cil_tmp266 ;
  struct drm_vmw_fence_rep *__cil_tmp267 ;
  int __cil_tmp268 ;
  int __cil_tmp269 ;
  int __cil_tmp270 ;
  long __cil_tmp271 ;
  void *__cil_tmp272 ;
  void *__cil_tmp273 ;
  int clip_y2274 ;
  int clip_y1275 ;
  int clip_x2276 ;
  int clip_x1277 ;

  {
  ret = 0;
  num_units = 0;
  __cil_tmp50 = 1448;
  __cil_tmp51 = (unsigned long )dev_priv;
  __cil_tmp52 = __cil_tmp51 + 2088UL;
  __cil_tmp53 = *((struct drm_device **)__cil_tmp52);
  __cil_tmp54 = (unsigned long )__cil_tmp53;
  __cil_tmp55 = __cil_tmp54 + __cil_tmp50;
  __cil_tmp56 = *((struct list_head **)__cil_tmp55);
  __mptr = __cil_tmp56;
  __cil_tmp57 = (struct drm_crtc *)0;
  __cil_tmp58 = (unsigned long )__cil_tmp57;
  __cil_tmp59 = __cil_tmp58 + 8UL;
  __cil_tmp60 = (struct list_head *)__cil_tmp59;
  __cil_tmp61 = (unsigned int )__cil_tmp60;
  __cil_tmp62 = (char *)__mptr;
  __cil_tmp63 = __cil_tmp62 - __cil_tmp61;
  crtc = (struct drm_crtc *)__cil_tmp63;
  while (1) {
    __cil_tmp64 = 1448;
    __cil_tmp65 = (unsigned long )dev_priv;
    __cil_tmp66 = __cil_tmp65 + 2088UL;
    __cil_tmp67 = *((struct drm_device **)__cil_tmp66);
    __cil_tmp68 = (unsigned long )__cil_tmp67;
    __cil_tmp69 = __cil_tmp68 + __cil_tmp64;
    __cil_tmp70 = (struct list_head *)__cil_tmp69;
    __cil_tmp71 = (unsigned long )__cil_tmp70;
    __cil_tmp72 = (unsigned long )crtc;
    __cil_tmp73 = __cil_tmp72 + 8UL;
    __cil_tmp74 = (struct list_head *)__cil_tmp73;
    __cil_tmp75 = (unsigned long )__cil_tmp74;
    if (! (__cil_tmp75 != __cil_tmp71)) {
      goto while_break;
    }
    __cil_tmp76 = (struct drm_framebuffer *)framebuffer;
    __cil_tmp77 = (unsigned long )__cil_tmp76;
    __cil_tmp78 = (unsigned long )crtc;
    __cil_tmp79 = __cil_tmp78 + 32UL;
    __cil_tmp80 = *((struct drm_framebuffer **)__cil_tmp79);
    __cil_tmp81 = (unsigned long )__cil_tmp80;
    if (__cil_tmp81 != __cil_tmp77) {
      goto __Cont;
    }
    tmp___8 = num_units;
    num_units ++;
    __mptr___1 = crtc;
    __cil_tmp82 = (unsigned long )tmp___8 * 8UL;
    __cil_tmp83 = (unsigned long )(units) + __cil_tmp82;
    __cil_tmp84 = (struct vmw_display_unit *)0;
    __cil_tmp85 = (struct drm_crtc *)__cil_tmp84;
    __cil_tmp86 = (unsigned int )__cil_tmp85;
    __cil_tmp87 = (char *)__mptr___1;
    __cil_tmp88 = __cil_tmp87 - __cil_tmp86;
    *((struct vmw_display_unit **)__cil_tmp83) = (struct vmw_display_unit *)__cil_tmp88;
    __Cont: 
    __cil_tmp89 = (unsigned long )crtc;
    __cil_tmp90 = __cil_tmp89 + 8UL;
    __cil_tmp91 = *((struct list_head **)__cil_tmp90);
    __mptr___0 = __cil_tmp91;
    __cil_tmp92 = (struct drm_crtc *)0;
    __cil_tmp93 = (unsigned long )__cil_tmp92;
    __cil_tmp94 = __cil_tmp93 + 8UL;
    __cil_tmp95 = (struct list_head *)__cil_tmp94;
    __cil_tmp96 = (unsigned int )__cil_tmp95;
    __cil_tmp97 = (char *)__mptr___0;
    __cil_tmp98 = __cil_tmp97 - __cil_tmp96;
    crtc = (struct drm_crtc *)__cil_tmp98;
  }
  while_break: ;
  while (1) {

    if (! clips) {
      tmp___9 = 1;
    } else
    if (! num_clips) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    __cil_tmp99 = (long )tmp___9;
    tmp___10 = ldv__builtin_expect(__cil_tmp99, 0L);
    if (tmp___10) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (452), "i" (12UL));
        while (1) {

        }

        goto while_break___1;
      }
      while_break___1: ;
    }
    goto while_break___0;
  }
  while_break___0: 
  __cil_tmp100 = (unsigned long )num_clips;
  __cil_tmp101 = 8UL * __cil_tmp100;
  tmp___11 = kzalloc(__cil_tmp101, 208U);
  tmp___7 = (struct drm_clip_rect *)tmp___11;
  __cil_tmp102 = (void *)0;
  __cil_tmp103 = (unsigned long )__cil_tmp102;
  __cil_tmp104 = (unsigned long )tmp___7;
  __cil_tmp105 = __cil_tmp104 == __cil_tmp103;
  __cil_tmp106 = ! __cil_tmp105;
  __cil_tmp107 = ! __cil_tmp106;
  __cil_tmp108 = (long )__cil_tmp107;
  tmp___12 = ldv__builtin_expect(__cil_tmp108, 0L);
  if (tmp___12) {
    drm_err("do_surface_dirty_sou", "Temporary cliprect memory alloc failed.\n");
    return (-12);
  }
  __cil_tmp109 = (unsigned long )num_clips;
  __cil_tmp110 = 16UL * __cil_tmp109;
  fifo_size = 56UL + __cil_tmp110;
  tmp___13 = kzalloc(fifo_size, 208U);
  cmd = (struct __anonstruct_cmd_430 *)tmp___13;
  __cil_tmp111 = (void *)0;
  __cil_tmp112 = (unsigned long )__cil_tmp111;
  __cil_tmp113 = (unsigned long )cmd;
  __cil_tmp114 = __cil_tmp113 == __cil_tmp112;
  __cil_tmp115 = ! __cil_tmp114;
  __cil_tmp116 = ! __cil_tmp115;
  __cil_tmp117 = (long )__cil_tmp116;
  tmp___14 = ldv__builtin_expect(__cil_tmp117, 0L);
  if (tmp___14) {
    drm_err("do_surface_dirty_sou", "Temporary fifo memory alloc failed.\n");
    ret = -12;
    goto out_free_tmp;
  }
  __cil_tmp118 = cmd + 1;
  blits = (SVGASignedRect *)__cil_tmp118;
  __cil_tmp119 = *((unsigned short *)clips);
  left = (int )__cil_tmp119;
  __cil_tmp120 = (unsigned long )clips;
  __cil_tmp121 = __cil_tmp120 + 4UL;
  __cil_tmp122 = *((unsigned short *)__cil_tmp121);
  right = (int )__cil_tmp122;
  __cil_tmp123 = (unsigned long )clips;
  __cil_tmp124 = __cil_tmp123 + 2UL;
  __cil_tmp125 = *((unsigned short *)__cil_tmp124);
  top = (int )__cil_tmp125;
  __cil_tmp126 = (unsigned long )clips;
  __cil_tmp127 = __cil_tmp126 + 6UL;
  __cil_tmp128 = *((unsigned short *)__cil_tmp127);
  bottom = (int )__cil_tmp128;
  i = 1;
  clips_ptr = clips + inc;
  while (1) {
    __cil_tmp129 = (unsigned int )i;
    if (! (__cil_tmp129 < num_clips)) {
      goto while_break___3;
    }
    __min1 = left;
    __cil_tmp130 = *((unsigned short *)clips_ptr);
    __min2 = (int )__cil_tmp130;
    if (__min1 < __min2) {
      tmp___15 = __min1;
    } else {
      tmp___15 = __min2;
    }
    left = tmp___15;
    __max1 = right;
    __cil_tmp131 = (unsigned long )clips_ptr;
    __cil_tmp132 = __cil_tmp131 + 4UL;
    __cil_tmp133 = *((unsigned short *)__cil_tmp132);
    __max2 = (int )__cil_tmp133;
    if (__max1 > __max2) {
      tmp___16 = __max1;
    } else {
      tmp___16 = __max2;
    }
    right = tmp___16;
    __min1___0 = top;
    __cil_tmp134 = (unsigned long )clips_ptr;
    __cil_tmp135 = __cil_tmp134 + 2UL;
    __cil_tmp136 = *((unsigned short *)__cil_tmp135);
    __min2___0 = (int )__cil_tmp136;
    if (__min1___0 < __min2___0) {
      tmp___17 = __min1___0;
    } else {
      tmp___17 = __min2___0;
    }
    top = tmp___17;
    __max1___0 = bottom;
    __cil_tmp137 = (unsigned long )clips_ptr;
    __cil_tmp138 = __cil_tmp137 + 6UL;
    __cil_tmp139 = *((unsigned short *)__cil_tmp138);
    __max2___0 = (int )__cil_tmp139;
    if (__max1___0 > __max2___0) {
      tmp___18 = __max1___0;
    } else {
      tmp___18 = __max2___0;
    }
    bottom = tmp___18;
    i ++;
    clips_ptr += inc;
  }
  while_break___3: 
  __cil_tmp140 = (void *)cmd;
  memset(__cil_tmp140, 0, fifo_size);
  *((uint32 *)cmd) = (__u32 )1069;
  __cil_tmp141 = 4;
  __cil_tmp142 = (unsigned long )cmd;
  __cil_tmp143 = __cil_tmp142 + __cil_tmp141;
  __cil_tmp144 = fifo_size - 8UL;
  *((uint32 *)__cil_tmp143) = (__u32 )__cil_tmp144;
  __cil_tmp145 = 20;
  __cil_tmp146 = (unsigned long )cmd;
  __cil_tmp147 = __cil_tmp146 + __cil_tmp145;
  *((int32 *)__cil_tmp147) = left;
  __cil_tmp148 = 20;
  __cil_tmp149 = 8UL + __cil_tmp148;
  __cil_tmp150 = (unsigned long )cmd;
  __cil_tmp151 = __cil_tmp150 + __cil_tmp149;
  *((int32 *)__cil_tmp151) = right;
  __cil_tmp152 = 16;
  __cil_tmp153 = 8UL + __cil_tmp152;
  __cil_tmp154 = (unsigned long )cmd;
  __cil_tmp155 = __cil_tmp154 + __cil_tmp153;
  *((int32 *)__cil_tmp155) = top;
  __cil_tmp156 = 24;
  __cil_tmp157 = 8UL + __cil_tmp156;
  __cil_tmp158 = (unsigned long )cmd;
  __cil_tmp159 = __cil_tmp158 + __cil_tmp157;
  *((int32 *)__cil_tmp159) = bottom;
  clips_ptr = clips;
  i = 0;
  while (1) {
    __cil_tmp160 = (unsigned int )i;
    if (! (__cil_tmp160 < num_clips)) {
      goto while_break___4;
    }
    __cil_tmp161 = tmp___7 + i;
    __cil_tmp162 = *((unsigned short *)clips_ptr);
    __cil_tmp163 = (int )__cil_tmp162;
    __cil_tmp164 = __cil_tmp163 - left;
    *((unsigned short *)__cil_tmp161) = (unsigned short )__cil_tmp164;
    __cil_tmp165 = tmp___7 + i;
    __cil_tmp166 = (unsigned long )__cil_tmp165;
    __cil_tmp167 = __cil_tmp166 + 4UL;
    __cil_tmp168 = (unsigned long )clips_ptr;
    __cil_tmp169 = __cil_tmp168 + 4UL;
    __cil_tmp170 = *((unsigned short *)__cil_tmp169);
    __cil_tmp171 = (int )__cil_tmp170;
    __cil_tmp172 = __cil_tmp171 - left;
    *((unsigned short *)__cil_tmp167) = (unsigned short )__cil_tmp172;
    __cil_tmp173 = tmp___7 + i;
    __cil_tmp174 = (unsigned long )__cil_tmp173;
    __cil_tmp175 = __cil_tmp174 + 2UL;
    __cil_tmp176 = (unsigned long )clips_ptr;
    __cil_tmp177 = __cil_tmp176 + 2UL;
    __cil_tmp178 = *((unsigned short *)__cil_tmp177);
    __cil_tmp179 = (int )__cil_tmp178;
    __cil_tmp180 = __cil_tmp179 - top;
    *((unsigned short *)__cil_tmp175) = (unsigned short )__cil_tmp180;
    __cil_tmp181 = tmp___7 + i;
    __cil_tmp182 = (unsigned long )__cil_tmp181;
    __cil_tmp183 = __cil_tmp182 + 6UL;
    __cil_tmp184 = (unsigned long )clips_ptr;
    __cil_tmp185 = __cil_tmp184 + 6UL;
    __cil_tmp186 = *((unsigned short *)__cil_tmp185);
    __cil_tmp187 = (int )__cil_tmp186;
    __cil_tmp188 = __cil_tmp187 - top;
    *((unsigned short *)__cil_tmp183) = (unsigned short )__cil_tmp188;
    i ++;
    clips_ptr += inc;
  }
  while_break___4: 
  i = 0;
  while (1) {

    if (! (i < num_units)) {
      goto while_break___5;
    }
    __cil_tmp189 = (unsigned long )i * 8UL;
    __cil_tmp190 = (unsigned long )(units) + __cil_tmp189;
    unit = *((struct vmw_display_unit **)__cil_tmp190);
    __cil_tmp191 = 480;
    __cil_tmp192 = (unsigned long )unit;
    __cil_tmp193 = __cil_tmp192 + __cil_tmp191;
    __cil_tmp194 = *((int *)__cil_tmp193);
    clip_x1277 = left - __cil_tmp194;
    __cil_tmp195 = 484;
    __cil_tmp196 = (unsigned long )unit;
    __cil_tmp197 = __cil_tmp196 + __cil_tmp195;
    __cil_tmp198 = *((int *)__cil_tmp197);
    clip_y1275 = top - __cil_tmp198;
    __cil_tmp199 = 480;
    __cil_tmp200 = (unsigned long )unit;
    __cil_tmp201 = __cil_tmp200 + __cil_tmp199;
    __cil_tmp202 = *((int *)__cil_tmp201);
    clip_x2276 = right - __cil_tmp202;
    __cil_tmp203 = 484;
    __cil_tmp204 = (unsigned long )unit;
    __cil_tmp205 = __cil_tmp204 + __cil_tmp203;
    __cil_tmp206 = *((int *)__cil_tmp205);
    clip_y2274 = bottom - __cil_tmp206;
    __cil_tmp207 = 116;
    __cil_tmp208 = __cil_tmp207;
    __cil_tmp209 = (unsigned long )unit;
    __cil_tmp210 = __cil_tmp209 + __cil_tmp208;
    __cil_tmp211 = *((int *)__cil_tmp210);
    if (clip_x1277 >= __cil_tmp211) {
      goto __Cont___0;
    } else {
      __cil_tmp212 = 136;
      __cil_tmp213 = __cil_tmp212;
      __cil_tmp214 = (unsigned long )unit;
      __cil_tmp215 = __cil_tmp214 + __cil_tmp213;
      __cil_tmp216 = *((int *)__cil_tmp215);
      if (clip_y1275 >= __cil_tmp216) {
        goto __Cont___0;
      } else
      if (clip_x2276 <= 0) {
        goto __Cont___0;
      } else
      if (clip_y2274 <= 0) {
        goto __Cont___0;
      }
    }
    __cil_tmp217 = 40;
    __cil_tmp218 = (unsigned long )cmd;
    __cil_tmp219 = __cil_tmp218 + __cil_tmp217;
    *((int32 *)__cil_tmp219) = clip_x1277;
    __cil_tmp220 = 40;
    __cil_tmp221 = 8UL + __cil_tmp220;
    __cil_tmp222 = (unsigned long )cmd;
    __cil_tmp223 = __cil_tmp222 + __cil_tmp221;
    *((int32 *)__cil_tmp223) = clip_x2276;
    __cil_tmp224 = 36;
    __cil_tmp225 = 8UL + __cil_tmp224;
    __cil_tmp226 = (unsigned long )cmd;
    __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
    *((int32 *)__cil_tmp227) = clip_y1275;
    __cil_tmp228 = 44;
    __cil_tmp229 = 8UL + __cil_tmp228;
    __cil_tmp230 = (unsigned long )cmd;
    __cil_tmp231 = __cil_tmp230 + __cil_tmp229;
    *((int32 *)__cil_tmp231) = clip_y2274;
    __cil_tmp232 = 116;
    __cil_tmp233 = __cil_tmp232;
    __cil_tmp234 = (unsigned long )unit;
    __cil_tmp235 = __cil_tmp234 + __cil_tmp233;
    __cil_tmp236 = *((int *)__cil_tmp235);
    clip_x2276 = __cil_tmp236 - clip_x1277;
    __cil_tmp237 = 136;
    __cil_tmp238 = __cil_tmp237;
    __cil_tmp239 = (unsigned long )unit;
    __cil_tmp240 = __cil_tmp239 + __cil_tmp238;
    __cil_tmp241 = *((int *)__cil_tmp240);
    clip_y2274 = __cil_tmp241 - clip_y1275;
    clip_x1277 = 0 - clip_x1277;
    clip_y1275 = 0 - clip_y1275;
    __cil_tmp242 = (unsigned long )cmd;
    __cil_tmp243 = __cil_tmp242 + 8UL;
    __cil_tmp244 = (unsigned long )framebuffer;
    __cil_tmp245 = __cil_tmp244 + 152UL;
    *((uint32 *)__cil_tmp243) = *((uint32_t *)__cil_tmp245);
    __cil_tmp246 = 36;
    __cil_tmp247 = (unsigned long )cmd;
    __cil_tmp248 = __cil_tmp247 + __cil_tmp246;
    __cil_tmp249 = (unsigned long )unit;
    __cil_tmp250 = __cil_tmp249 + 2032UL;
    *((uint32 *)__cil_tmp248) = *((unsigned int *)__cil_tmp250);
    __cil_tmp251 = (int )num_clips;
    vmw_clip_cliprects(tmp___7, __cil_tmp251, clip_x1277, clip_x2276, clip_y1275,
                       clip_y2274, blits, & num);
    __cil_tmp252 = & num;
    __cil_tmp253 = *__cil_tmp252;
    if (__cil_tmp253 == 0) {
      goto __Cont___0;
    }
    if (out_fence) {
      if (*out_fence) {
        vmw_fence_obj_unreference(out_fence);
      }
    }
    __cil_tmp254 = & num;
    __cil_tmp255 = *__cil_tmp254;
    __cil_tmp256 = (unsigned long )__cil_tmp255;
    __cil_tmp257 = 16UL * __cil_tmp256;
    fifo_size = 56UL + __cil_tmp257;
    __cil_tmp258 = 4;
    __cil_tmp259 = (unsigned long )cmd;
    __cil_tmp260 = __cil_tmp259 + __cil_tmp258;
    __cil_tmp261 = fifo_size - 8UL;
    *((uint32 *)__cil_tmp260) = (__u32 )__cil_tmp261;
    __cil_tmp262 = (void *)0;
    __cil_tmp263 = (void *)cmd;
    __cil_tmp264 = (uint32_t )fifo_size;
    __cil_tmp265 = (uint64_t )0;
    __cil_tmp266 = (void *)0;
    __cil_tmp267 = (struct drm_vmw_fence_rep *)__cil_tmp266;
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp262, __cil_tmp263, __cil_tmp264,
                              __cil_tmp265, __cil_tmp267, out_fence);
    __cil_tmp268 = ret != 0;
    __cil_tmp269 = ! __cil_tmp268;
    __cil_tmp270 = ! __cil_tmp269;
    __cil_tmp271 = (long )__cil_tmp270;
    tmp___19 = ldv__builtin_expect(__cil_tmp271, 0L);
    if (tmp___19) {
      goto while_break___5;
    }
    __Cont___0: 
    i ++;
  }
  while_break___5: 
  __cil_tmp272 = (void *)cmd;
  kfree(__cil_tmp272);
  out_free_tmp: 
  __cil_tmp273 = (void *)tmp___7;
  kfree(__cil_tmp273);
  return (ret);
}
}
int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                  unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                  unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int inc ;
  long tmp___9 ;
  long tmp___10 ;
  struct drm_device *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct drm_master *__cil_tmp21 ;
  struct vmw_framebuffer_surface *__cil_tmp22 ;
  struct drm_framebuffer *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct drm_master *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct vmw_screen_object_display *__cil_tmp41 ;
  struct ttm_lock *__cil_tmp42 ;
  bool __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct drm_clip_rect *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  struct vmw_framebuffer *__cil_tmp59 ;
  void *__cil_tmp60 ;
  struct vmw_fence_obj **__cil_tmp61 ;
  struct ttm_lock *__cil_tmp62 ;

  {
  __cil_tmp18 = *((struct drm_device **)framebuffer);
  tmp___7 = vmw_priv(__cil_tmp18);
  dev_priv = tmp___7;
  __cil_tmp19 = (unsigned long )file_priv;
  __cil_tmp20 = __cil_tmp19 + 152UL;
  __cil_tmp21 = *((struct drm_master **)__cil_tmp20);
  tmp___8 = vmw_master(__cil_tmp21);
  vmaster = tmp___8;
  __mptr = framebuffer;
  __cil_tmp22 = (struct vmw_framebuffer_surface *)0;
  __cil_tmp23 = (struct drm_framebuffer *)__cil_tmp22;
  __cil_tmp24 = (unsigned int )__cil_tmp23;
  __cil_tmp25 = (char *)__mptr;
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
  vfbs = (struct vmw_framebuffer_surface *)__cil_tmp26;
  inc = 1;
  __cil_tmp27 = (unsigned long )file_priv;
  __cil_tmp28 = __cil_tmp27 + 152UL;
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  __cil_tmp31 = (unsigned long )vfbs;
  __cil_tmp32 = __cil_tmp31 + 192UL;
  __cil_tmp33 = *((struct drm_master **)__cil_tmp32);
  __cil_tmp34 = (unsigned long )__cil_tmp33;
  __cil_tmp35 = __cil_tmp34 != __cil_tmp30;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = (long )__cil_tmp37;
  tmp___9 = ldv__builtin_expect(__cil_tmp38, 0L);
  if (tmp___9) {
    return (-22);
  }
  __cil_tmp39 = (unsigned long )dev_priv;
  __cil_tmp40 = __cil_tmp39 + 2616UL;
  __cil_tmp41 = *((struct vmw_screen_object_display **)__cil_tmp40);
  if (! __cil_tmp41) {
    return (-22);
  }
  __cil_tmp42 = (struct ttm_lock *)vmaster;
  __cil_tmp43 = (bool )1;
  ret = ttm_read_lock(__cil_tmp42, __cil_tmp43);
  __cil_tmp44 = ret != 0;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = (long )__cil_tmp46;
  tmp___10 = ldv__builtin_expect(__cil_tmp47, 0L);
  if (tmp___10) {
    return (ret);
  }
  if (! num_clips) {
    num_clips = 1U;
    clips = & norect;
    __cil_tmp48 = (unsigned long )(& norect) + 2UL;
    *((unsigned short *)__cil_tmp48) = (unsigned short)0;
    __cil_tmp49 = & norect;
    __cil_tmp50 = (unsigned long )(& norect) + 2UL;
    *((unsigned short *)__cil_tmp49) = *((unsigned short *)__cil_tmp50);
    __cil_tmp51 = (unsigned long )(& norect) + 4UL;
    __cil_tmp52 = (unsigned long )framebuffer;
    __cil_tmp53 = __cil_tmp52 + 72UL;
    __cil_tmp54 = *((unsigned int *)__cil_tmp53);
    *((unsigned short *)__cil_tmp51) = (unsigned short )__cil_tmp54;
    __cil_tmp55 = (unsigned long )(& norect) + 6UL;
    __cil_tmp56 = (unsigned long )framebuffer;
    __cil_tmp57 = __cil_tmp56 + 76UL;
    __cil_tmp58 = *((unsigned int *)__cil_tmp57);
    *((unsigned short *)__cil_tmp55) = (unsigned short )__cil_tmp58;
  } else
  if (flags & 1U) {
    num_clips /= 2U;
    inc = 2;
  }
  __cil_tmp59 = (struct vmw_framebuffer *)vfbs;
  __cil_tmp60 = (void *)0;
  __cil_tmp61 = (struct vmw_fence_obj **)__cil_tmp60;
  ret = do_surface_dirty_sou(dev_priv, file_priv, __cil_tmp59, flags, color, clips,
                             num_clips, inc, __cil_tmp61);
  __cil_tmp62 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp62);
  return (0);
}
}
static struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs  =    {& vmw_framebuffer_surface_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_surface_dirty};
static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv ,
                                           struct drm_file *file_priv , struct vmw_surface *surface ,
                                           struct vmw_framebuffer **out , struct drm_mode_fb_cmd *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_surface *vfbs ;
  enum SVGA3dSurfaceFormat format ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  int ret ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  struct vmw_surface *tmp___13 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_master *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_screen_object_display *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  bool __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  __u32 __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_vmw_size *__cil_tmp47 ;
  struct drm_vmw_size *__cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  __u32 __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct drm_vmw_size *__cil_tmp56 ;
  struct drm_vmw_size *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32_t __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_vmw_size *__cil_tmp63 ;
  struct drm_vmw_size *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  uint32_t __cil_tmp67 ;
  long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  __u32 __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  __u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  uint32_t __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct drm_framebuffer *__cil_tmp83 ;
  struct drm_framebuffer_funcs *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  __u32 __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  __u32 __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  __u32 __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  __u32 __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  __u32 __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  __u32 __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  struct drm_master *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  struct mutex *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct list_head *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  struct list_head *__cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  struct mutex *__cil_tmp146 ;
  struct drm_framebuffer *__cil_tmp147 ;
  void *__cil_tmp148 ;

  {
  __cil_tmp18 = (unsigned long )dev_priv;
  __cil_tmp19 = __cil_tmp18 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp19);
  __cil_tmp20 = (unsigned long )file_priv;
  __cil_tmp21 = __cil_tmp20 + 152UL;
  __cil_tmp22 = *((struct drm_master **)__cil_tmp21);
  tmp___7 = vmw_master(__cil_tmp22);
  vmaster = tmp___7;
  __cil_tmp23 = (unsigned long )dev_priv;
  __cil_tmp24 = __cil_tmp23 + 2616UL;
  __cil_tmp25 = *((struct vmw_screen_object_display **)__cil_tmp24);
  if (! __cil_tmp25) {
    return (-38);
  }
  __cil_tmp26 = (unsigned long )surface;
  __cil_tmp27 = __cil_tmp26 + 156UL;
  __cil_tmp28 = *((bool *)__cil_tmp27);
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = (long )__cil_tmp31;
  tmp___8 = ldv__builtin_expect(__cil_tmp32, 0L);
  if (tmp___8) {
    return (-22);
  }
  __cil_tmp33 = 0UL;
  __cil_tmp34 = 120UL + __cil_tmp33;
  __cil_tmp35 = (unsigned long )surface;
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
  if (__cil_tmp37 != 1U) {
    tmp___9 = 1;
  } else {
    __cil_tmp38 = (unsigned long )surface;
    __cil_tmp39 = __cil_tmp38 + 152UL;
    __cil_tmp40 = *((uint32_t *)__cil_tmp39);
    if (__cil_tmp40 != 1U) {
      tmp___9 = 1;
    } else {
      __cil_tmp41 = (unsigned long )mode_cmd;
      __cil_tmp42 = __cil_tmp41 + 4UL;
      __cil_tmp43 = *((__u32 *)__cil_tmp42);
      __cil_tmp44 = __cil_tmp43;
      __cil_tmp45 = (unsigned long )surface;
      __cil_tmp46 = __cil_tmp45 + 144UL;
      __cil_tmp47 = *((struct drm_vmw_size **)__cil_tmp46);
      __cil_tmp48 = __cil_tmp47 + 0;
      __cil_tmp49 = *((uint32_t *)__cil_tmp48);
      if (__cil_tmp49 < __cil_tmp44) {
        tmp___9 = 1;
      } else {
        __cil_tmp50 = (unsigned long )mode_cmd;
        __cil_tmp51 = __cil_tmp50 + 8UL;
        __cil_tmp52 = *((__u32 *)__cil_tmp51);
        __cil_tmp53 = __cil_tmp52;
        __cil_tmp54 = (unsigned long )surface;
        __cil_tmp55 = __cil_tmp54 + 144UL;
        __cil_tmp56 = *((struct drm_vmw_size **)__cil_tmp55);
        __cil_tmp57 = __cil_tmp56 + 0;
        __cil_tmp58 = (unsigned long )__cil_tmp57;
        __cil_tmp59 = __cil_tmp58 + 4UL;
        __cil_tmp60 = *((uint32_t *)__cil_tmp59);
        if (__cil_tmp60 < __cil_tmp53) {
          tmp___9 = 1;
        } else {
          __cil_tmp61 = (unsigned long )surface;
          __cil_tmp62 = __cil_tmp61 + 144UL;
          __cil_tmp63 = *((struct drm_vmw_size **)__cil_tmp62);
          __cil_tmp64 = __cil_tmp63 + 0;
          __cil_tmp65 = (unsigned long )__cil_tmp64;
          __cil_tmp66 = __cil_tmp65 + 8UL;
          __cil_tmp67 = *((uint32_t *)__cil_tmp66);
          if (__cil_tmp67 != 1U) {
            tmp___9 = 1;
          } else {
            tmp___9 = 0;
          }
        }
      }
    }
  }
  __cil_tmp68 = (long )tmp___9;
  tmp___10 = ldv__builtin_expect(__cil_tmp68, 0L);
  if (tmp___10) {
    drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
    return (-22);
  }
  __cil_tmp69 = (unsigned long )mode_cmd;
  __cil_tmp70 = __cil_tmp69 + 20UL;
  __cil_tmp71 = *((__u32 *)__cil_tmp70);
  if ((int )__cil_tmp71 == 32) {
    goto case_32;
  } else
  if ((int )__cil_tmp71 == 24) {
    goto case_24;
  } else
  if ((int )__cil_tmp71 == 16) {
    goto case_16;
  } else
  if ((int )__cil_tmp71 == 15) {
    goto case_15;
  } else
  if ((int )__cil_tmp71 == 8) {
    goto case_8;
  } else {
    goto switch_default;
    if (0) {
      case_32: 
      format = (enum SVGA3dSurfaceFormat )2;
      goto switch_break;
      case_24: 
      format = (enum SVGA3dSurfaceFormat )1;
      goto switch_break;
      case_16: 
      format = (enum SVGA3dSurfaceFormat )3;
      goto switch_break;
      case_15: 
      format = (enum SVGA3dSurfaceFormat )5;
      goto switch_break;
      case_8: 
      format = (enum SVGA3dSurfaceFormat )11;
      goto switch_break;
      switch_default: 
      __cil_tmp72 = (unsigned long )mode_cmd;
      __cil_tmp73 = __cil_tmp72 + 20UL;
      __cil_tmp74 = *((__u32 *)__cil_tmp73);
      drm_err("vmw_kms_new_framebuffer_surface", "Invalid color depth: %d\n", __cil_tmp74);
      return (-22);
    } else {
      switch_break: ;
    }
  }
  __cil_tmp75 = (unsigned long )surface;
  __cil_tmp76 = __cil_tmp75 + 116UL;
  __cil_tmp77 = *((uint32_t *)__cil_tmp76);
  __cil_tmp78 = (unsigned int )format;
  __cil_tmp79 = __cil_tmp78 != __cil_tmp77;
  __cil_tmp80 = ! __cil_tmp79;
  __cil_tmp81 = ! __cil_tmp80;
  __cil_tmp82 = (long )__cil_tmp81;
  tmp___11 = ldv__builtin_expect(__cil_tmp82, 0L);
  if (tmp___11) {
    drm_err("vmw_kms_new_framebuffer_surface", "Invalid surface format for requested mode.\n");
    return (-22);
  }
  tmp___12 = kzalloc(200UL, 208U);
  vfbs = (struct vmw_framebuffer_surface *)tmp___12;
  if (! vfbs) {
    ret = -12;
    goto out_err1;
  }
  __cil_tmp83 = (struct drm_framebuffer *)vfbs;
  __cil_tmp84 = & vmw_framebuffer_surface_funcs;
  ret = drm_framebuffer_init(dev, __cil_tmp83, __cil_tmp84);
  if (ret) {
    goto out_err2;
  }
  tmp___13 = vmw_surface_reference(surface);
  if (! tmp___13) {
    drm_err("vmw_kms_new_framebuffer_surface", "failed to reference surface %p\n",
            surface);
    goto out_err3;
  }
  __cil_tmp85 = 84;
  __cil_tmp86 = __cil_tmp85;
  __cil_tmp87 = (unsigned long )vfbs;
  __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
  __cil_tmp89 = (unsigned long )mode_cmd;
  __cil_tmp90 = __cil_tmp89 + 16UL;
  __cil_tmp91 = *((__u32 *)__cil_tmp90);
  *((int *)__cil_tmp88) = (int )__cil_tmp91;
  __cil_tmp92 = 0UL;
  __cil_tmp93 = 40UL + __cil_tmp92;
  __cil_tmp94 = __cil_tmp93;
  __cil_tmp95 = __cil_tmp94;
  __cil_tmp96 = (unsigned long )vfbs;
  __cil_tmp97 = __cil_tmp96 + __cil_tmp95;
  __cil_tmp98 = (unsigned long )mode_cmd;
  __cil_tmp99 = __cil_tmp98 + 12UL;
  __cil_tmp100 = *((__u32 *)__cil_tmp99);
  *((unsigned int *)__cil_tmp97) = __cil_tmp100;
  __cil_tmp101 = 80;
  __cil_tmp102 = __cil_tmp101;
  __cil_tmp103 = (unsigned long )vfbs;
  __cil_tmp104 = __cil_tmp103 + __cil_tmp102;
  __cil_tmp105 = (unsigned long )mode_cmd;
  __cil_tmp106 = __cil_tmp105 + 20UL;
  __cil_tmp107 = *((__u32 *)__cil_tmp106);
  *((unsigned int *)__cil_tmp104) = __cil_tmp107;
  __cil_tmp108 = 72;
  __cil_tmp109 = __cil_tmp108;
  __cil_tmp110 = (unsigned long )vfbs;
  __cil_tmp111 = __cil_tmp110 + __cil_tmp109;
  __cil_tmp112 = (unsigned long )mode_cmd;
  __cil_tmp113 = __cil_tmp112 + 4UL;
  __cil_tmp114 = *((__u32 *)__cil_tmp113);
  *((unsigned int *)__cil_tmp111) = __cil_tmp114;
  __cil_tmp115 = 76;
  __cil_tmp116 = __cil_tmp115;
  __cil_tmp117 = (unsigned long )vfbs;
  __cil_tmp118 = __cil_tmp117 + __cil_tmp116;
  __cil_tmp119 = (unsigned long )mode_cmd;
  __cil_tmp120 = __cil_tmp119 + 8UL;
  __cil_tmp121 = *((__u32 *)__cil_tmp120);
  *((unsigned int *)__cil_tmp118) = __cil_tmp121;
  __cil_tmp122 = (unsigned long )vfbs;
  __cil_tmp123 = __cil_tmp122 + 160UL;
  *((struct vmw_surface **)__cil_tmp123) = surface;
  __cil_tmp124 = 152;
  __cil_tmp125 = (unsigned long )vfbs;
  __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
  __cil_tmp127 = (unsigned long )mode_cmd;
  __cil_tmp128 = __cil_tmp127 + 24UL;
  __cil_tmp129 = *((__u32 *)__cil_tmp128);
  *((uint32_t *)__cil_tmp126) = __cil_tmp129;
  __cil_tmp130 = (unsigned long )vfbs;
  __cil_tmp131 = __cil_tmp130 + 192UL;
  __cil_tmp132 = (unsigned long )file_priv;
  __cil_tmp133 = __cil_tmp132 + 152UL;
  __cil_tmp134 = *((struct drm_master **)__cil_tmp133);
  *((struct drm_master **)__cil_tmp131) = drm_master_get(__cil_tmp134);
  __cil_tmp135 = (unsigned long )vmaster;
  __cil_tmp136 = __cil_tmp135 + 152UL;
  __cil_tmp137 = (struct mutex *)__cil_tmp136;
  mutex_lock(__cil_tmp137);
  __cil_tmp138 = (unsigned long )vfbs;
  __cil_tmp139 = __cil_tmp138 + 176UL;
  __cil_tmp140 = (struct list_head *)__cil_tmp139;
  __cil_tmp141 = (unsigned long )vmaster;
  __cil_tmp142 = __cil_tmp141 + 224UL;
  __cil_tmp143 = (struct list_head *)__cil_tmp142;
  list_add_tail(__cil_tmp140, __cil_tmp143);
  __cil_tmp144 = (unsigned long )vmaster;
  __cil_tmp145 = __cil_tmp144 + 152UL;
  __cil_tmp146 = (struct mutex *)__cil_tmp145;
  mutex_unlock(__cil_tmp146);
  *out = (struct vmw_framebuffer *)vfbs;
  return (0);
  out_err3: 
  __cil_tmp147 = (struct drm_framebuffer *)vfbs;
  drm_framebuffer_cleanup(__cil_tmp147);
  out_err2: 
  __cil_tmp148 = (void *)vfbs;
  kfree(__cil_tmp148);
  out_err1: 
  return (ret);
}
}
void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer *__mptr ;
  struct vmw_framebuffer_dmabuf *__cil_tmp4 ;
  struct drm_framebuffer *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_dma_buffer **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct ttm_base_object **__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  __mptr = framebuffer;
  __cil_tmp4 = (struct vmw_framebuffer_dmabuf *)0;
  __cil_tmp5 = (struct drm_framebuffer *)__cil_tmp4;
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = (char *)__mptr;
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp8;
  drm_framebuffer_cleanup(framebuffer);
  __cil_tmp9 = (unsigned long )vfbd;
  __cil_tmp10 = __cil_tmp9 + 160UL;
  __cil_tmp11 = (struct vmw_dma_buffer **)__cil_tmp10;
  vmw_dmabuf_unreference(__cil_tmp11);
  __cil_tmp12 = 144;
  __cil_tmp13 = (unsigned long )vfbd;
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
  __cil_tmp15 = (struct ttm_base_object **)__cil_tmp14;
  ttm_base_object_unref(__cil_tmp15);
  __cil_tmp16 = (void *)vfbd;
  kfree(__cil_tmp16);
  return;
}
}
static int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv , struct vmw_framebuffer *framebuffer ,
                               unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment ) 
{ size_t fifo_size ;
  int i ;
  struct __anonstruct_cmd_431 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  struct __anonstruct_cmd_431 *__cil_tmp24 ;
  struct __anonstruct_cmd_431 *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned short __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct __anonstruct_cmd_431 *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct __anonstruct_cmd_431 *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned short __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned short __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct __anonstruct_cmd_431 *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned short __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned short __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  uint32_t __cil_tmp60 ;

  {
  __cil_tmp13 = (unsigned long )num_clips;
  fifo_size = 20UL * __cil_tmp13;
  __cil_tmp14 = (uint32_t )fifo_size;
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp14);
  cmd = (struct __anonstruct_cmd_431 *)tmp___7;
  __cil_tmp15 = (void *)0;
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  __cil_tmp17 = (unsigned long )cmd;
  __cil_tmp18 = __cil_tmp17 == __cil_tmp16;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = (long )__cil_tmp20;
  tmp___8 = ldv__builtin_expect(__cil_tmp21, 0L);
  if (tmp___8) {
    drm_err("do_dmabuf_dirty_ldu", "Fifo reserve failed.\n");
    return (-12);
  }
  __cil_tmp22 = (void *)cmd;
  memset(__cil_tmp22, 0, fifo_size);
  i = 0;
  while (1) {
    __cil_tmp23 = (unsigned int )i;
    if (! (__cil_tmp23 < num_clips)) {
      goto while_break;
    }
    __cil_tmp24 = cmd + i;
    *((uint32_t *)__cil_tmp24) = (__u32 )1;
    __cil_tmp25 = cmd + i;
    __cil_tmp26 = (unsigned long )__cil_tmp25;
    __cil_tmp27 = __cil_tmp26 + 4UL;
    __cil_tmp28 = *((unsigned short *)clips);
    *((uint32 *)__cil_tmp27) = (__u32 )__cil_tmp28;
    __cil_tmp29 = 8;
    __cil_tmp30 = cmd + i;
    __cil_tmp31 = (unsigned long )__cil_tmp30;
    __cil_tmp32 = __cil_tmp31 + __cil_tmp29;
    __cil_tmp33 = (unsigned long )clips;
    __cil_tmp34 = __cil_tmp33 + 2UL;
    __cil_tmp35 = *((unsigned short *)__cil_tmp34);
    *((uint32 *)__cil_tmp32) = (__u32 )__cil_tmp35;
    __cil_tmp36 = 12;
    __cil_tmp37 = cmd + i;
    __cil_tmp38 = (unsigned long )__cil_tmp37;
    __cil_tmp39 = __cil_tmp38 + __cil_tmp36;
    __cil_tmp40 = *((unsigned short *)clips);
    __cil_tmp41 = (int )__cil_tmp40;
    __cil_tmp42 = (unsigned long )clips;
    __cil_tmp43 = __cil_tmp42 + 4UL;
    __cil_tmp44 = *((unsigned short *)__cil_tmp43);
    __cil_tmp45 = (int )__cil_tmp44;
    __cil_tmp46 = __cil_tmp45 - __cil_tmp41;
    *((uint32 *)__cil_tmp39) = (__u32 )__cil_tmp46;
    __cil_tmp47 = 16;
    __cil_tmp48 = cmd + i;
    __cil_tmp49 = (unsigned long )__cil_tmp48;
    __cil_tmp50 = __cil_tmp49 + __cil_tmp47;
    __cil_tmp51 = (unsigned long )clips;
    __cil_tmp52 = __cil_tmp51 + 2UL;
    __cil_tmp53 = *((unsigned short *)__cil_tmp52);
    __cil_tmp54 = (int )__cil_tmp53;
    __cil_tmp55 = (unsigned long )clips;
    __cil_tmp56 = __cil_tmp55 + 6UL;
    __cil_tmp57 = *((unsigned short *)__cil_tmp56);
    __cil_tmp58 = (int )__cil_tmp57;
    __cil_tmp59 = __cil_tmp58 - __cil_tmp54;
    *((uint32 *)__cil_tmp50) = (__u32 )__cil_tmp59;
    i ++;
    clips += increment;
  }
  while_break: 
  __cil_tmp60 = (uint32_t )fifo_size;
  vmw_fifo_commit(dev_priv, __cil_tmp60);
  return (0);
}
}
static int do_dmabuf_define_gmrfb(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                                  struct vmw_framebuffer *framebuffer ) 
{ int depth ;
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_432 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  uint64_t __cil_tmp60 ;
  void *__cil_tmp61 ;
  struct drm_vmw_fence_rep *__cil_tmp62 ;
  void *__cil_tmp63 ;
  struct vmw_fence_obj **__cil_tmp64 ;
  void *__cil_tmp65 ;

  {
  __cil_tmp10 = 80;
  __cil_tmp11 = (unsigned long )framebuffer;
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
  __cil_tmp13 = *((unsigned int *)__cil_tmp12);
  depth = (int )__cil_tmp13;
  if (depth == 32) {
    depth = 24;
  }
  fifo_size = 20UL;
  tmp___7 = kmalloc(fifo_size, 208U);
  cmd = (struct __anonstruct_cmd_432 *)tmp___7;
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = (unsigned long )cmd;
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___8) {
    drm_err("do_dmabuf_define_gmrfb", "Failed to allocate temporary cmd buffer.\n");
    return (-12);
  }
  __cil_tmp21 = (void *)cmd;
  memset(__cil_tmp21, 0, fifo_size);
  *((uint32_t *)cmd) = (uint32_t )36;
  __cil_tmp22 = 16;
  __cil_tmp23 = (unsigned long )cmd;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = 84;
  __cil_tmp26 = (unsigned long )framebuffer;
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
  __cil_tmp28 = *((int *)__cil_tmp27);
  *((uint32 *)__cil_tmp24) = (uint32 )__cil_tmp28;
  __cil_tmp29 = 1;
  __cil_tmp30 = __cil_tmp29;
  __cil_tmp31 = 12UL + __cil_tmp30;
  __cil_tmp32 = 4UL + __cil_tmp31;
  __cil_tmp33 = (unsigned long )cmd;
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
  *((uint32 *)__cil_tmp34) = (uint32 )depth;
  __cil_tmp35 = 2;
  __cil_tmp36 = __cil_tmp35;
  __cil_tmp37 = 12UL + __cil_tmp36;
  __cil_tmp38 = 4UL + __cil_tmp37;
  __cil_tmp39 = (unsigned long )cmd;
  __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
  *((uint32 *)__cil_tmp40) = (uint32 )0;
  __cil_tmp41 = 12;
  __cil_tmp42 = (unsigned long )cmd;
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
  __cil_tmp44 = 0UL;
  __cil_tmp45 = 40UL + __cil_tmp44;
  __cil_tmp46 = __cil_tmp45;
  __cil_tmp47 = (unsigned long )framebuffer;
  __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
  *((uint32 *)__cil_tmp43) = *((unsigned int *)__cil_tmp48);
  __cil_tmp49 = (unsigned long )cmd;
  __cil_tmp50 = __cil_tmp49 + 4UL;
  __cil_tmp51 = (unsigned long )framebuffer;
  __cil_tmp52 = __cil_tmp51 + 152UL;
  *((uint32 *)__cil_tmp50) = *((uint32_t *)__cil_tmp52);
  __cil_tmp53 = 4;
  __cil_tmp54 = 4UL + __cil_tmp53;
  __cil_tmp55 = (unsigned long )cmd;
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
  *((uint32 *)__cil_tmp56) = (uint32 )0;
  __cil_tmp57 = (void *)0;
  __cil_tmp58 = (void *)cmd;
  __cil_tmp59 = (uint32_t )fifo_size;
  __cil_tmp60 = (uint64_t )0;
  __cil_tmp61 = (void *)0;
  __cil_tmp62 = (struct drm_vmw_fence_rep *)__cil_tmp61;
  __cil_tmp63 = (void *)0;
  __cil_tmp64 = (struct vmw_fence_obj **)__cil_tmp63;
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp57, __cil_tmp58, __cil_tmp59,
                            __cil_tmp60, __cil_tmp62, __cil_tmp64);
  __cil_tmp65 = (void *)cmd;
  kfree(__cil_tmp65);
  return (ret);
}
}
static int do_dmabuf_dirty_sou(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_framebuffer *framebuffer , unsigned int flags ,
                               unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *clips_ptr ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  struct __anonstruct_blits_433 *blits ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int tmp___10 ;
  struct drm_crtc *__mptr___1 ;
  struct vmw_display_unit *unit ;
  int hit_num ;
  int clip_x1 ;
  int clip_y1 ;
  int clip_x2 ;
  int clip_y2 ;
  int move_x ;
  int move_y ;
  int __min1 ;
  int __min2 ;
  int tmp___11 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___12 ;
  int __min1___1 ;
  int __min2___1 ;
  int tmp___13 ;
  int __min1___2 ;
  int __min2___2 ;
  int tmp___14 ;
  long tmp___15 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  void *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct drm_device *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  struct drm_crtc *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct list_head *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct drm_device *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct drm_framebuffer *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct drm_framebuffer *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct vmw_display_unit *__cil_tmp93 ;
  struct drm_crtc *__cil_tmp94 ;
  unsigned int __cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct list_head *__cil_tmp100 ;
  struct drm_crtc *__cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  struct list_head *__cil_tmp104 ;
  unsigned int __cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned short __cil_tmp115 ;
  int __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  int __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned short __cil_tmp123 ;
  int __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  int __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned short __cil_tmp131 ;
  int __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned short __cil_tmp139 ;
  int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  int __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  struct __anonstruct_blits_433 *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  struct __anonstruct_blits_433 *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct __anonstruct_blits_433 *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned short __cil_tmp169 ;
  int __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  struct __anonstruct_blits_433 *__cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned short __cil_tmp178 ;
  int __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  struct __anonstruct_blits_433 *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  struct __anonstruct_blits_433 *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  struct __anonstruct_blits_433 *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  struct __anonstruct_blits_433 *__cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  void *__cil_tmp200 ;
  void *__cil_tmp201 ;
  uint32_t __cil_tmp202 ;
  uint64_t __cil_tmp203 ;
  void *__cil_tmp204 ;
  struct drm_vmw_fence_rep *__cil_tmp205 ;
  int __cil_tmp206 ;
  int __cil_tmp207 ;
  int __cil_tmp208 ;
  long __cil_tmp209 ;
  void *__cil_tmp210 ;

  {
  ret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);
  __cil_tmp47 = ret != 0;
  __cil_tmp48 = ! __cil_tmp47;
  __cil_tmp49 = ! __cil_tmp48;
  __cil_tmp50 = (long )__cil_tmp49;
  tmp___7 = ldv__builtin_expect(__cil_tmp50, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp51 = (unsigned long )num_clips;
  fifo_size = 32UL * __cil_tmp51;
  tmp___8 = kmalloc(fifo_size, 208U);
  blits = (struct __anonstruct_blits_433 *)tmp___8;
  __cil_tmp52 = (void *)0;
  __cil_tmp53 = (unsigned long )__cil_tmp52;
  __cil_tmp54 = (unsigned long )blits;
  __cil_tmp55 = __cil_tmp54 == __cil_tmp53;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 0L);
  if (tmp___9) {
    drm_err("do_dmabuf_dirty_sou", "Failed to allocate temporary cmd buffer.\n");
    return (-12);
  }
  num_units = 0;
  __cil_tmp59 = 1448;
  __cil_tmp60 = (unsigned long )dev_priv;
  __cil_tmp61 = __cil_tmp60 + 2088UL;
  __cil_tmp62 = *((struct drm_device **)__cil_tmp61);
  __cil_tmp63 = (unsigned long )__cil_tmp62;
  __cil_tmp64 = __cil_tmp63 + __cil_tmp59;
  __cil_tmp65 = *((struct list_head **)__cil_tmp64);
  __mptr = __cil_tmp65;
  __cil_tmp66 = (struct drm_crtc *)0;
  __cil_tmp67 = (unsigned long )__cil_tmp66;
  __cil_tmp68 = __cil_tmp67 + 8UL;
  __cil_tmp69 = (struct list_head *)__cil_tmp68;
  __cil_tmp70 = (unsigned int )__cil_tmp69;
  __cil_tmp71 = (char *)__mptr;
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
  crtc = (struct drm_crtc *)__cil_tmp72;
  while (1) {
    __cil_tmp73 = 1448;
    __cil_tmp74 = (unsigned long )dev_priv;
    __cil_tmp75 = __cil_tmp74 + 2088UL;
    __cil_tmp76 = *((struct drm_device **)__cil_tmp75);
    __cil_tmp77 = (unsigned long )__cil_tmp76;
    __cil_tmp78 = __cil_tmp77 + __cil_tmp73;
    __cil_tmp79 = (struct list_head *)__cil_tmp78;
    __cil_tmp80 = (unsigned long )__cil_tmp79;
    __cil_tmp81 = (unsigned long )crtc;
    __cil_tmp82 = __cil_tmp81 + 8UL;
    __cil_tmp83 = (struct list_head *)__cil_tmp82;
    __cil_tmp84 = (unsigned long )__cil_tmp83;
    if (! (__cil_tmp84 != __cil_tmp80)) {
      goto while_break;
    }
    __cil_tmp85 = (struct drm_framebuffer *)framebuffer;
    __cil_tmp86 = (unsigned long )__cil_tmp85;
    __cil_tmp87 = (unsigned long )crtc;
    __cil_tmp88 = __cil_tmp87 + 32UL;
    __cil_tmp89 = *((struct drm_framebuffer **)__cil_tmp88);
    __cil_tmp90 = (unsigned long )__cil_tmp89;
    if (__cil_tmp90 != __cil_tmp86) {
      goto __Cont;
    }
    tmp___10 = num_units;
    num_units ++;
    __mptr___1 = crtc;
    __cil_tmp91 = (unsigned long )tmp___10 * 8UL;
    __cil_tmp92 = (unsigned long )(units) + __cil_tmp91;
    __cil_tmp93 = (struct vmw_display_unit *)0;
    __cil_tmp94 = (struct drm_crtc *)__cil_tmp93;
    __cil_tmp95 = (unsigned int )__cil_tmp94;
    __cil_tmp96 = (char *)__mptr___1;
    __cil_tmp97 = __cil_tmp96 - __cil_tmp95;
    *((struct vmw_display_unit **)__cil_tmp92) = (struct vmw_display_unit *)__cil_tmp97;
    __Cont: 
    __cil_tmp98 = (unsigned long )crtc;
    __cil_tmp99 = __cil_tmp98 + 8UL;
    __cil_tmp100 = *((struct list_head **)__cil_tmp99);
    __mptr___0 = __cil_tmp100;
    __cil_tmp101 = (struct drm_crtc *)0;
    __cil_tmp102 = (unsigned long )__cil_tmp101;
    __cil_tmp103 = __cil_tmp102 + 8UL;
    __cil_tmp104 = (struct list_head *)__cil_tmp103;
    __cil_tmp105 = (unsigned int )__cil_tmp104;
    __cil_tmp106 = (char *)__mptr___0;
    __cil_tmp107 = __cil_tmp106 - __cil_tmp105;
    crtc = (struct drm_crtc *)__cil_tmp107;
  }
  while_break: 
  k = 0;
  while (1) {

    if (! (k < num_units)) {
      goto while_break___0;
    }
    __cil_tmp108 = (unsigned long )k * 8UL;
    __cil_tmp109 = (unsigned long )(units) + __cil_tmp108;
    unit = *((struct vmw_display_unit **)__cil_tmp109);
    hit_num = 0;
    clips_ptr = clips;
    i = 0;
    while (1) {
      __cil_tmp110 = (unsigned int )i;
      if (! (__cil_tmp110 < num_clips)) {
        goto while_break___1;
      }
      __cil_tmp111 = 480;
      __cil_tmp112 = (unsigned long )unit;
      __cil_tmp113 = __cil_tmp112 + __cil_tmp111;
      __cil_tmp114 = *((int *)__cil_tmp113);
      __cil_tmp115 = *((unsigned short *)clips_ptr);
      __cil_tmp116 = (int )__cil_tmp115;
      clip_x1 = __cil_tmp116 - __cil_tmp114;
      __cil_tmp117 = 484;
      __cil_tmp118 = (unsigned long )unit;
      __cil_tmp119 = __cil_tmp118 + __cil_tmp117;
      __cil_tmp120 = *((int *)__cil_tmp119);
      __cil_tmp121 = (unsigned long )clips_ptr;
      __cil_tmp122 = __cil_tmp121 + 2UL;
      __cil_tmp123 = *((unsigned short *)__cil_tmp122);
      __cil_tmp124 = (int )__cil_tmp123;
      clip_y1 = __cil_tmp124 - __cil_tmp120;
      __cil_tmp125 = 480;
      __cil_tmp126 = (unsigned long )unit;
      __cil_tmp127 = __cil_tmp126 + __cil_tmp125;
      __cil_tmp128 = *((int *)__cil_tmp127);
      __cil_tmp129 = (unsigned long )clips_ptr;
      __cil_tmp130 = __cil_tmp129 + 4UL;
      __cil_tmp131 = *((unsigned short *)__cil_tmp130);
      __cil_tmp132 = (int )__cil_tmp131;
      clip_x2 = __cil_tmp132 - __cil_tmp128;
      __cil_tmp133 = 484;
      __cil_tmp134 = (unsigned long )unit;
      __cil_tmp135 = __cil_tmp134 + __cil_tmp133;
      __cil_tmp136 = *((int *)__cil_tmp135);
      __cil_tmp137 = (unsigned long )clips_ptr;
      __cil_tmp138 = __cil_tmp137 + 6UL;
      __cil_tmp139 = *((unsigned short *)__cil_tmp138);
      __cil_tmp140 = (int )__cil_tmp139;
      clip_y2 = __cil_tmp140 - __cil_tmp136;
      __cil_tmp141 = 116;
      __cil_tmp142 = __cil_tmp141;
      __cil_tmp143 = (unsigned long )unit;
      __cil_tmp144 = __cil_tmp143 + __cil_tmp142;
      __cil_tmp145 = *((int *)__cil_tmp144);
      if (clip_x1 >= __cil_tmp145) {
        goto __Cont___0;
      } else {
        __cil_tmp146 = 136;
        __cil_tmp147 = __cil_tmp146;
        __cil_tmp148 = (unsigned long )unit;
        __cil_tmp149 = __cil_tmp148 + __cil_tmp147;
        __cil_tmp150 = *((int *)__cil_tmp149);
        if (clip_y1 >= __cil_tmp150) {
          goto __Cont___0;
        } else
        if (clip_x2 <= 0) {
          goto __Cont___0;
        } else
        if (clip_y2 <= 0) {
          goto __Cont___0;
        }
      }
      __min1 = clip_x2;
      __cil_tmp151 = 116;
      __cil_tmp152 = __cil_tmp151;
      __cil_tmp153 = (unsigned long )unit;
      __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
      __min2 = *((int *)__cil_tmp154);
      if (__min1 < __min2) {
        tmp___11 = __min1;
      } else {
        tmp___11 = __min2;
      }
      clip_x2 = tmp___11;
      __min1___0 = clip_y2;
      __cil_tmp155 = 136;
      __cil_tmp156 = __cil_tmp155;
      __cil_tmp157 = (unsigned long )unit;
      __cil_tmp158 = __cil_tmp157 + __cil_tmp156;
      __min2___0 = *((int *)__cil_tmp158);
      if (__min1___0 < __min2___0) {
        tmp___12 = __min1___0;
      } else {
        tmp___12 = __min2___0;
      }
      clip_y2 = tmp___12;
      __min1___1 = clip_x1;
      __min2___1 = 0;
      if (__min1___1 < __min2___1) {
        tmp___13 = __min1___1;
      } else {
        tmp___13 = __min2___1;
      }
      move_x = tmp___13;
      __min1___2 = clip_y1;
      __min2___2 = 0;
      if (__min1___2 < __min2___2) {
        tmp___14 = __min1___2;
      } else {
        tmp___14 = __min2___2;
      }
      move_y = tmp___14;
      __cil_tmp159 = blits + hit_num;
      *((uint32_t *)__cil_tmp159) = (uint32_t )37;
      __cil_tmp160 = 28;
      __cil_tmp161 = blits + hit_num;
      __cil_tmp162 = (unsigned long )__cil_tmp161;
      __cil_tmp163 = __cil_tmp162 + __cil_tmp160;
      __cil_tmp164 = (unsigned long )unit;
      __cil_tmp165 = __cil_tmp164 + 2032UL;
      *((uint32 *)__cil_tmp163) = *((unsigned int *)__cil_tmp165);
      __cil_tmp166 = blits + hit_num;
      __cil_tmp167 = (unsigned long )__cil_tmp166;
      __cil_tmp168 = __cil_tmp167 + 4UL;
      __cil_tmp169 = *((unsigned short *)clips_ptr);
      __cil_tmp170 = (int )__cil_tmp169;
      *((int32 *)__cil_tmp168) = __cil_tmp170 - move_x;
      __cil_tmp171 = 4;
      __cil_tmp172 = 4UL + __cil_tmp171;
      __cil_tmp173 = blits + hit_num;
      __cil_tmp174 = (unsigned long )__cil_tmp173;
      __cil_tmp175 = __cil_tmp174 + __cil_tmp172;
      __cil_tmp176 = (unsigned long )clips_ptr;
      __cil_tmp177 = __cil_tmp176 + 2UL;
      __cil_tmp178 = *((unsigned short *)__cil_tmp177);
      __cil_tmp179 = (int )__cil_tmp178;
      *((int32 *)__cil_tmp175) = __cil_tmp179 - move_y;
      __cil_tmp180 = 12;
      __cil_tmp181 = blits + hit_num;
      __cil_tmp182 = (unsigned long )__cil_tmp181;
      __cil_tmp183 = __cil_tmp182 + __cil_tmp180;
      *((int32 *)__cil_tmp183) = clip_x1 - move_x;
      __cil_tmp184 = 12;
      __cil_tmp185 = 4UL + __cil_tmp184;
      __cil_tmp186 = blits + hit_num;
      __cil_tmp187 = (unsigned long )__cil_tmp186;
      __cil_tmp188 = __cil_tmp187 + __cil_tmp185;
      *((int32 *)__cil_tmp188) = clip_y1 - move_y;
      __cil_tmp189 = 16;
      __cil_tmp190 = 4UL + __cil_tmp189;
      __cil_tmp191 = blits + hit_num;
      __cil_tmp192 = (unsigned long )__cil_tmp191;
      __cil_tmp193 = __cil_tmp192 + __cil_tmp190;
      *((int32 *)__cil_tmp193) = clip_x2;
      __cil_tmp194 = 20;
      __cil_tmp195 = 4UL + __cil_tmp194;
      __cil_tmp196 = blits + hit_num;
      __cil_tmp197 = (unsigned long )__cil_tmp196;
      __cil_tmp198 = __cil_tmp197 + __cil_tmp195;
      *((int32 *)__cil_tmp198) = clip_y2;
      hit_num ++;
      __Cont___0: 
      i ++;
      clips_ptr += increment;
    }
    while_break___1: ;
    if (hit_num == 0) {
      goto __Cont___1;
    }
    if (out_fence) {
      if (*out_fence) {
        vmw_fence_obj_unreference(out_fence);
      }
    }
    __cil_tmp199 = (unsigned long )hit_num;
    fifo_size = 32UL * __cil_tmp199;
    __cil_tmp200 = (void *)0;
    __cil_tmp201 = (void *)blits;
    __cil_tmp202 = (uint32_t )fifo_size;
    __cil_tmp203 = (uint64_t )0;
    __cil_tmp204 = (void *)0;
    __cil_tmp205 = (struct drm_vmw_fence_rep *)__cil_tmp204;
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp200, __cil_tmp201, __cil_tmp202,
                              __cil_tmp203, __cil_tmp205, out_fence);
    __cil_tmp206 = ret != 0;
    __cil_tmp207 = ! __cil_tmp206;
    __cil_tmp208 = ! __cil_tmp207;
    __cil_tmp209 = (long )__cil_tmp208;
    tmp___15 = ldv__builtin_expect(__cil_tmp209, 0L);
    if (tmp___15) {
      goto while_break___0;
    }
    __Cont___1: 
    k ++;
  }
  while_break___0: 
  __cil_tmp210 = (void *)blits;
  kfree(__cil_tmp210);
  return (ret);
}
}
int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                 unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                 unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int increment ;
  long tmp___9 ;
  struct drm_device *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_master *__cil_tmp20 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp21 ;
  struct drm_framebuffer *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  struct ttm_lock *__cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct drm_clip_rect *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_framebuffer *__cil_tmp45 ;
  struct vmw_framebuffer *__cil_tmp46 ;
  void *__cil_tmp47 ;
  struct vmw_fence_obj **__cil_tmp48 ;
  struct ttm_lock *__cil_tmp49 ;

  {
  __cil_tmp17 = *((struct drm_device **)framebuffer);
  tmp___7 = vmw_priv(__cil_tmp17);
  dev_priv = tmp___7;
  __cil_tmp18 = (unsigned long )file_priv;
  __cil_tmp19 = __cil_tmp18 + 152UL;
  __cil_tmp20 = *((struct drm_master **)__cil_tmp19);
  tmp___8 = vmw_master(__cil_tmp20);
  vmaster = tmp___8;
  __mptr = framebuffer;
  __cil_tmp21 = (struct vmw_framebuffer_dmabuf *)0;
  __cil_tmp22 = (struct drm_framebuffer *)__cil_tmp21;
  __cil_tmp23 = (unsigned int )__cil_tmp22;
  __cil_tmp24 = (char *)__mptr;
  __cil_tmp25 = __cil_tmp24 - __cil_tmp23;
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp25;
  increment = 1;
  __cil_tmp26 = (struct ttm_lock *)vmaster;
  __cil_tmp27 = (bool )1;
  ret = ttm_read_lock(__cil_tmp26, __cil_tmp27);
  __cil_tmp28 = ret != 0;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___9 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___9) {
    return (ret);
  }
  if (! num_clips) {
    num_clips = 1U;
    clips = & norect;
    __cil_tmp32 = (unsigned long )(& norect) + 2UL;
    *((unsigned short *)__cil_tmp32) = (unsigned short)0;
    __cil_tmp33 = & norect;
    __cil_tmp34 = (unsigned long )(& norect) + 2UL;
    *((unsigned short *)__cil_tmp33) = *((unsigned short *)__cil_tmp34);
    __cil_tmp35 = (unsigned long )(& norect) + 4UL;
    __cil_tmp36 = (unsigned long )framebuffer;
    __cil_tmp37 = __cil_tmp36 + 72UL;
    __cil_tmp38 = *((unsigned int *)__cil_tmp37);
    *((unsigned short *)__cil_tmp35) = (unsigned short )__cil_tmp38;
    __cil_tmp39 = (unsigned long )(& norect) + 6UL;
    __cil_tmp40 = (unsigned long )framebuffer;
    __cil_tmp41 = __cil_tmp40 + 76UL;
    __cil_tmp42 = *((unsigned int *)__cil_tmp41);
    *((unsigned short *)__cil_tmp39) = (unsigned short )__cil_tmp42;
  } else
  if (flags & 1U) {
    num_clips /= 2U;
    increment = 2;
  }
  __cil_tmp43 = (unsigned long )dev_priv;
  __cil_tmp44 = __cil_tmp43 + 2608UL;
  if (*((struct vmw_legacy_display **)__cil_tmp44)) {
    __cil_tmp45 = (struct vmw_framebuffer *)vfbd;
    ret = do_dmabuf_dirty_ldu(dev_priv, __cil_tmp45, flags, color, clips, num_clips,
                              increment);
  } else {
    __cil_tmp46 = (struct vmw_framebuffer *)vfbd;
    __cil_tmp47 = (void *)0;
    __cil_tmp48 = (struct vmw_fence_obj **)__cil_tmp47;
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, __cil_tmp46, flags, color, clips,
                              num_clips, increment, __cil_tmp48);
  }
  __cil_tmp49 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp49);
  return (ret);
}
}
static struct drm_framebuffer_funcs vmw_framebuffer_dmabuf_funcs  =    {& vmw_framebuffer_dmabuf_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_dmabuf_dirty};
static int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer *__mptr ;
  int ret ;
  long tmp___8 ;
  int __ret_warn_on ;
  long tmp___9 ;
  struct drm_device *__cil_tmp10 ;
  struct drm_framebuffer *__cil_tmp11 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp12 ;
  struct drm_framebuffer *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_screen_object_display *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_dma_buffer *__cil_tmp25 ;
  bool __cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  __cil_tmp10 = *((struct drm_device **)vfb);
  tmp___7 = vmw_priv(__cil_tmp10);
  dev_priv = tmp___7;
  __cil_tmp11 = (struct drm_framebuffer *)vfb;
  __mptr = __cil_tmp11;
  __cil_tmp12 = (struct vmw_framebuffer_dmabuf *)0;
  __cil_tmp13 = (struct drm_framebuffer *)__cil_tmp12;
  __cil_tmp14 = (unsigned int )__cil_tmp13;
  __cil_tmp15 = (char *)__mptr;
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp16;
  while (1) {
    __cil_tmp17 = (unsigned long )dev_priv;
    __cil_tmp18 = __cil_tmp17 + 2616UL;
    __cil_tmp19 = *((struct vmw_screen_object_display **)__cil_tmp18);
    __cil_tmp20 = ! __cil_tmp19;
    __cil_tmp21 = ! __cil_tmp20;
    __cil_tmp22 = (long )__cil_tmp21;
    tmp___8 = ldv__builtin_expect(__cil_tmp22, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (979), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  vmw_overlay_pause_all(dev_priv);
  __cil_tmp23 = (unsigned long )vfbd;
  __cil_tmp24 = __cil_tmp23 + 160UL;
  __cil_tmp25 = *((struct vmw_dma_buffer **)__cil_tmp24);
  __cil_tmp26 = (bool )1;
  __cil_tmp27 = (bool )0;
  ret = vmw_dmabuf_to_start_of_vram(dev_priv, __cil_tmp25, __cil_tmp26, __cil_tmp27);
  vmw_overlay_resume_all(dev_priv);
  __cil_tmp28 = ret != 0;
  __cil_tmp29 = ! __cil_tmp28;
  __ret_warn_on = ! __cil_tmp29;
  __cil_tmp30 = ! __ret_warn_on;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = (long )__cil_tmp31;
  tmp___9 = ldv__builtin_expect(__cil_tmp32, 0L);
  if (tmp___9) {
    __cil_tmp33 = 987;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c",
                       __cil_tmp33);
  }
  __cil_tmp34 = ! __ret_warn_on;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = (long )__cil_tmp35;
  ldv__builtin_expect(__cil_tmp36, 0L);
  return (0);
}
}
static int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer *__mptr ;
  int __ret_warn_on ;
  long tmp___8 ;
  int tmp___9 ;
  struct drm_device *__cil_tmp9 ;
  struct drm_framebuffer *__cil_tmp10 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp11 ;
  struct drm_framebuffer *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_dma_buffer *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_dma_buffer *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_dma_buffer *__cil_tmp33 ;
  bool __cil_tmp34 ;

  {
  __cil_tmp9 = *((struct drm_device **)vfb);
  tmp___7 = vmw_priv(__cil_tmp9);
  dev_priv = tmp___7;
  __cil_tmp10 = (struct drm_framebuffer *)vfb;
  __mptr = __cil_tmp10;
  __cil_tmp11 = (struct vmw_framebuffer_dmabuf *)0;
  __cil_tmp12 = (struct drm_framebuffer *)__cil_tmp11;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  __cil_tmp14 = (char *)__mptr;
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp15;
  __cil_tmp16 = (unsigned long )vfbd;
  __cil_tmp17 = __cil_tmp16 + 160UL;
  __cil_tmp18 = *((struct vmw_dma_buffer **)__cil_tmp17);
  if (! __cil_tmp18) {
    __cil_tmp19 = (unsigned long )vfbd;
    __cil_tmp20 = __cil_tmp19 + 160UL;
    __cil_tmp21 = *((struct vmw_dma_buffer **)__cil_tmp20);
    __cil_tmp22 = ! __cil_tmp21;
    __cil_tmp23 = ! __cil_tmp22;
    __ret_warn_on = ! __cil_tmp23;
    __cil_tmp24 = ! __ret_warn_on;
    __cil_tmp25 = ! __cil_tmp24;
    __cil_tmp26 = (long )__cil_tmp25;
    tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
    if (tmp___8) {
      __cil_tmp27 = 999;
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c",
                         __cil_tmp27);
    }
    __cil_tmp28 = ! __ret_warn_on;
    __cil_tmp29 = ! __cil_tmp28;
    __cil_tmp30 = (long )__cil_tmp29;
    ldv__builtin_expect(__cil_tmp30, 0L);
    return (0);
  }
  __cil_tmp31 = (unsigned long )vfbd;
  __cil_tmp32 = __cil_tmp31 + 160UL;
  __cil_tmp33 = *((struct vmw_dma_buffer **)__cil_tmp32);
  __cil_tmp34 = (bool )0;
  tmp___9 = vmw_dmabuf_unpin(dev_priv, __cil_tmp33, __cil_tmp34);
  return (tmp___9);
}
}
static int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                                          struct vmw_framebuffer **out , struct drm_mode_fb_cmd *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  unsigned int requested_size ;
  int ret ;
  long tmp___7 ;
  void *tmp___8 ;
  struct vmw_dma_buffer *tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  __u32 __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  __u32 __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  __u32 __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  __u32 __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  __u32 __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32 __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  __u32 __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  __u32 __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32 __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  __u32 __cil_tmp57 ;
  struct drm_framebuffer *__cil_tmp58 ;
  struct drm_framebuffer_funcs *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  __u32 __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  __u32 __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  __u32 __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  __u32 __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  __u32 __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct vmw_screen_object_display *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  __u32 __cil_tmp116 ;
  struct drm_framebuffer *__cil_tmp117 ;
  void *__cil_tmp118 ;

  {
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp13);
  __cil_tmp14 = (unsigned long )mode_cmd;
  __cil_tmp15 = __cil_tmp14 + 12UL;
  __cil_tmp16 = *((__u32 *)__cil_tmp15);
  __cil_tmp17 = (unsigned long )mode_cmd;
  __cil_tmp18 = __cil_tmp17 + 8UL;
  __cil_tmp19 = *((__u32 *)__cil_tmp18);
  __cil_tmp20 = __cil_tmp19 * __cil_tmp16;
  requested_size = __cil_tmp20;
  __cil_tmp21 = 1UL << 12;
  __cil_tmp22 = 40;
  __cil_tmp23 = (unsigned long )dmabuf;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = *((unsigned long *)__cil_tmp24);
  __cil_tmp26 = __cil_tmp25 * __cil_tmp21;
  __cil_tmp27 = (unsigned long )requested_size;
  __cil_tmp28 = __cil_tmp27 > __cil_tmp26;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___7 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___7) {
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Screen buffer object size is too small for requested mode.\n");
    return (-22);
  }
  __cil_tmp32 = (unsigned long )dev_priv;
  __cil_tmp33 = __cil_tmp32 + 2616UL;
  if (*((struct vmw_screen_object_display **)__cil_tmp33)) {
    __cil_tmp34 = (unsigned long )mode_cmd;
    __cil_tmp35 = __cil_tmp34 + 20UL;
    __cil_tmp36 = *((__u32 *)__cil_tmp35);
    if ((int )__cil_tmp36 == 32) {
      goto case_32;
    } else
    if ((int )__cil_tmp36 == 24) {
      goto case_32;
    } else
    if ((int )__cil_tmp36 == 16) {
      goto case_16;
    } else
    if ((int )__cil_tmp36 == 15) {
      goto case_16;
    } else {
      goto switch_default;
      if (0) {
        case_32: 
        __cil_tmp37 = (unsigned long )mode_cmd;
        __cil_tmp38 = __cil_tmp37 + 16UL;
        __cil_tmp39 = *((__u32 *)__cil_tmp38);
        if (__cil_tmp39 == 32U) {
          goto switch_break;
        }
        __cil_tmp40 = (unsigned long )mode_cmd;
        __cil_tmp41 = __cil_tmp40 + 20UL;
        __cil_tmp42 = *((__u32 *)__cil_tmp41);
        __cil_tmp43 = (unsigned long )mode_cmd;
        __cil_tmp44 = __cil_tmp43 + 16UL;
        __cil_tmp45 = *((__u32 *)__cil_tmp44);
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
                __cil_tmp42, __cil_tmp45);
        return (-22);
        case_16: 
        __cil_tmp46 = (unsigned long )mode_cmd;
        __cil_tmp47 = __cil_tmp46 + 16UL;
        __cil_tmp48 = *((__u32 *)__cil_tmp47);
        if (__cil_tmp48 == 16U) {
          goto switch_break;
        }
        __cil_tmp49 = (unsigned long )mode_cmd;
        __cil_tmp50 = __cil_tmp49 + 20UL;
        __cil_tmp51 = *((__u32 *)__cil_tmp50);
        __cil_tmp52 = (unsigned long )mode_cmd;
        __cil_tmp53 = __cil_tmp52 + 16UL;
        __cil_tmp54 = *((__u32 *)__cil_tmp53);
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
                __cil_tmp51, __cil_tmp54);
        return (-22);
        switch_default: 
        __cil_tmp55 = (unsigned long )mode_cmd;
        __cil_tmp56 = __cil_tmp55 + 20UL;
        __cil_tmp57 = *((__u32 *)__cil_tmp56);
        drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth: %d\n", __cil_tmp57);
        return (-22);
      } else {
        switch_break: ;
      }
    }
  }
  tmp___8 = kzalloc(168UL, 208U);
  vfbd = (struct vmw_framebuffer_dmabuf *)tmp___8;
  if (! vfbd) {
    ret = -12;
    goto out_err1;
  }
  __cil_tmp58 = (struct drm_framebuffer *)vfbd;
  __cil_tmp59 = & vmw_framebuffer_dmabuf_funcs;
  ret = drm_framebuffer_init(dev, __cil_tmp58, __cil_tmp59);
  if (ret) {
    goto out_err2;
  }
  tmp___9 = vmw_dmabuf_reference(dmabuf);
  if (! tmp___9) {
    drm_err("vmw_kms_new_framebuffer_dmabuf", "failed to reference dmabuf %p\n", dmabuf);
    goto out_err3;
  }
  __cil_tmp60 = 84;
  __cil_tmp61 = __cil_tmp60;
  __cil_tmp62 = (unsigned long )vfbd;
  __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
  __cil_tmp64 = (unsigned long )mode_cmd;
  __cil_tmp65 = __cil_tmp64 + 16UL;
  __cil_tmp66 = *((__u32 *)__cil_tmp65);
  *((int *)__cil_tmp63) = (int )__cil_tmp66;
  __cil_tmp67 = 0UL;
  __cil_tmp68 = 40UL + __cil_tmp67;
  __cil_tmp69 = __cil_tmp68;
  __cil_tmp70 = __cil_tmp69;
  __cil_tmp71 = (unsigned long )vfbd;
  __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
  __cil_tmp73 = (unsigned long )mode_cmd;
  __cil_tmp74 = __cil_tmp73 + 12UL;
  __cil_tmp75 = *((__u32 *)__cil_tmp74);
  *((unsigned int *)__cil_tmp72) = __cil_tmp75;
  __cil_tmp76 = 80;
  __cil_tmp77 = __cil_tmp76;
  __cil_tmp78 = (unsigned long )vfbd;
  __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
  __cil_tmp80 = (unsigned long )mode_cmd;
  __cil_tmp81 = __cil_tmp80 + 20UL;
  __cil_tmp82 = *((__u32 *)__cil_tmp81);
  *((unsigned int *)__cil_tmp79) = __cil_tmp82;
  __cil_tmp83 = 72;
  __cil_tmp84 = __cil_tmp83;
  __cil_tmp85 = (unsigned long )vfbd;
  __cil_tmp86 = __cil_tmp85 + __cil_tmp84;
  __cil_tmp87 = (unsigned long )mode_cmd;
  __cil_tmp88 = __cil_tmp87 + 4UL;
  __cil_tmp89 = *((__u32 *)__cil_tmp88);
  *((unsigned int *)__cil_tmp86) = __cil_tmp89;
  __cil_tmp90 = 76;
  __cil_tmp91 = __cil_tmp90;
  __cil_tmp92 = (unsigned long )vfbd;
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
  __cil_tmp94 = (unsigned long )mode_cmd;
  __cil_tmp95 = __cil_tmp94 + 8UL;
  __cil_tmp96 = *((__u32 *)__cil_tmp95);
  *((unsigned int *)__cil_tmp93) = __cil_tmp96;
  __cil_tmp97 = (unsigned long )dev_priv;
  __cil_tmp98 = __cil_tmp97 + 2616UL;
  __cil_tmp99 = *((struct vmw_screen_object_display **)__cil_tmp98);
  if (! __cil_tmp99) {
    __cil_tmp100 = 120;
    __cil_tmp101 = (unsigned long )vfbd;
    __cil_tmp102 = __cil_tmp101 + __cil_tmp100;
    *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp102) = & vmw_framebuffer_dmabuf_pin;
    __cil_tmp103 = 128;
    __cil_tmp104 = (unsigned long )vfbd;
    __cil_tmp105 = __cil_tmp104 + __cil_tmp103;
    *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp105) = & vmw_framebuffer_dmabuf_unpin;
  }
  __cil_tmp106 = 136;
  __cil_tmp107 = (unsigned long )vfbd;
  __cil_tmp108 = __cil_tmp107 + __cil_tmp106;
  *((bool *)__cil_tmp108) = (bool )1;
  __cil_tmp109 = (unsigned long )vfbd;
  __cil_tmp110 = __cil_tmp109 + 160UL;
  *((struct vmw_dma_buffer **)__cil_tmp110) = dmabuf;
  __cil_tmp111 = 152;
  __cil_tmp112 = (unsigned long )vfbd;
  __cil_tmp113 = __cil_tmp112 + __cil_tmp111;
  __cil_tmp114 = (unsigned long )mode_cmd;
  __cil_tmp115 = __cil_tmp114 + 24UL;
  __cil_tmp116 = *((__u32 *)__cil_tmp115);
  *((uint32_t *)__cil_tmp113) = __cil_tmp116;
  *out = (struct vmw_framebuffer *)vfbd;
  return (0);
  out_err3: 
  __cil_tmp117 = (struct drm_framebuffer *)vfbd;
  drm_framebuffer_cleanup(__cil_tmp117);
  out_err2: 
  __cil_tmp118 = (void *)vfbd;
  kfree(__cil_tmp118);
  out_err1: 
  return (ret);
}
}
static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev , struct drm_file *file_priv ,
                                                 struct drm_mode_fb_cmd2 *mode_cmd2 ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_framebuffer *vfb ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *bo ;
  struct ttm_base_object *user_obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  int ret ;
  void *tmp___9 ;
  bool tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_framebuffer **__cil_tmp21 ;
  void *__cil_tmp22 ;
  struct vmw_surface **__cil_tmp23 ;
  void *__cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32 __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  __u32 *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  __u32 *__cil_tmp49 ;
  int *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  __u32 __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32 __cil_tmp54 ;
  struct ttm_base_object **__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  __u32 __cil_tmp57 ;
  void *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct ttm_base_object **__cil_tmp60 ;
  struct ttm_base_object *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  __u32 __cil_tmp68 ;
  struct vmw_dma_buffer **__cil_tmp69 ;
  struct vmw_dma_buffer **__cil_tmp70 ;
  struct vmw_dma_buffer *__cil_tmp71 ;
  struct drm_mode_fb_cmd *__cil_tmp72 ;
  struct vmw_surface **__cil_tmp73 ;
  struct vmw_surface **__cil_tmp74 ;
  struct vmw_surface *__cil_tmp75 ;
  struct drm_mode_fb_cmd *__cil_tmp76 ;
  struct vmw_dma_buffer **__cil_tmp77 ;
  struct vmw_surface **__cil_tmp78 ;
  long __cil_tmp79 ;
  struct vmw_framebuffer **__cil_tmp80 ;
  struct vmw_framebuffer *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct ttm_base_object **__cil_tmp84 ;
  struct vmw_framebuffer **__cil_tmp85 ;
  struct vmw_framebuffer *__cil_tmp86 ;
  void *tmp ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  tmp___8 = vmw_fpriv(file_priv);
  __cil_tmp19 = (unsigned long )tmp___8;
  __cil_tmp20 = __cil_tmp19 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp20);
  __cil_tmp21 = & vfb;
  __cil_tmp22 = (void *)0;
  *__cil_tmp21 = (struct vmw_framebuffer *)__cil_tmp22;
  __cil_tmp23 = & surface;
  __cil_tmp24 = (void *)0;
  *__cil_tmp23 = (struct vmw_surface *)__cil_tmp24;
  __cil_tmp25 = & bo;
  __cil_tmp26 = (void *)0;
  *__cil_tmp25 = (struct vmw_dma_buffer *)__cil_tmp26;
  __cil_tmp27 = (unsigned long )(& mode_cmd) + 4UL;
  __cil_tmp28 = (unsigned long )mode_cmd2;
  __cil_tmp29 = __cil_tmp28 + 4UL;
  *((__u32 *)__cil_tmp27) = *((__u32 *)__cil_tmp29);
  __cil_tmp30 = (unsigned long )(& mode_cmd) + 8UL;
  __cil_tmp31 = (unsigned long )mode_cmd2;
  __cil_tmp32 = __cil_tmp31 + 8UL;
  *((__u32 *)__cil_tmp30) = *((__u32 *)__cil_tmp32);
  __cil_tmp33 = (unsigned long )(& mode_cmd) + 12UL;
  __cil_tmp34 = 0UL;
  __cil_tmp35 = 36UL + __cil_tmp34;
  __cil_tmp36 = (unsigned long )mode_cmd2;
  __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
  *((__u32 *)__cil_tmp33) = *((__u32 *)__cil_tmp37);
  __cil_tmp38 = (unsigned long )(& mode_cmd) + 24UL;
  __cil_tmp39 = 0UL;
  __cil_tmp40 = 20UL + __cil_tmp39;
  __cil_tmp41 = (unsigned long )mode_cmd2;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  *((__u32 *)__cil_tmp38) = *((__u32 *)__cil_tmp42);
  __cil_tmp43 = (unsigned long )mode_cmd2;
  __cil_tmp44 = __cil_tmp43 + 12UL;
  __cil_tmp45 = *((__u32 *)__cil_tmp44);
  __cil_tmp46 = (unsigned long )(& mode_cmd) + 20UL;
  __cil_tmp47 = (__u32 *)__cil_tmp46;
  __cil_tmp48 = (unsigned long )(& mode_cmd) + 16UL;
  __cil_tmp49 = (__u32 *)__cil_tmp48;
  __cil_tmp50 = (int *)__cil_tmp49;
  drm_fb_get_bpp_depth(__cil_tmp45, __cil_tmp47, __cil_tmp50);
  __cil_tmp51 = (unsigned long )(& mode_cmd) + 12UL;
  __cil_tmp52 = *((__u32 *)__cil_tmp51);
  __cil_tmp53 = (unsigned long )(& mode_cmd) + 8UL;
  __cil_tmp54 = *((__u32 *)__cil_tmp53);
  tmp___10 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp52, __cil_tmp54);
  if (! tmp___10) {
    drm_err("vmw_kms_fb_create", "VRAM size is too small for requested mode.\n");
    tmp = (void *)ERR_PTR(-12L);
    tmp___9 = tmp;
    return ((struct drm_framebuffer *)tmp___9);
  }
  __cil_tmp55 = & user_obj;
  __cil_tmp56 = (unsigned long )(& mode_cmd) + 24UL;
  __cil_tmp57 = *((__u32 *)__cil_tmp56);
  *__cil_tmp55 = ttm_base_object_lookup(tfile, __cil_tmp57);
  __cil_tmp58 = (void *)0;
  __cil_tmp59 = (unsigned long )__cil_tmp58;
  __cil_tmp60 = & user_obj;
  __cil_tmp61 = *__cil_tmp60;
  __cil_tmp62 = (unsigned long )__cil_tmp61;
  __cil_tmp63 = __cil_tmp62 == __cil_tmp59;
  __cil_tmp64 = ! __cil_tmp63;
  __cil_tmp65 = ! __cil_tmp64;
  __cil_tmp66 = (long )__cil_tmp65;
  tmp___12 = ldv__builtin_expect(__cil_tmp66, 0L);
  if (tmp___12) {
    drm_err("vmw_kms_fb_create", "Could not locate requested kms frame buffer.\n");
    tmp___14 = (void *)ERR_PTR(-2L);
    tmp___11 = tmp___14;
    return ((struct drm_framebuffer *)tmp___11);
  }
  __cil_tmp67 = (unsigned long )(& mode_cmd) + 24UL;
  __cil_tmp68 = *((__u32 *)__cil_tmp67);
  ret = vmw_user_lookup_handle(dev_priv, tfile, __cil_tmp68, & surface, & bo);
  if (ret) {
    goto err_out;
  }
  __cil_tmp69 = & bo;
  if (*__cil_tmp69) {
    __cil_tmp70 = & bo;
    __cil_tmp71 = *__cil_tmp70;
    __cil_tmp72 = & mode_cmd;
    ret = vmw_kms_new_framebuffer_dmabuf(dev_priv, __cil_tmp71, & vfb, __cil_tmp72);
  } else {
    __cil_tmp73 = & surface;
    if (*__cil_tmp73) {
      __cil_tmp74 = & surface;
      __cil_tmp75 = *__cil_tmp74;
      __cil_tmp76 = & mode_cmd;
      ret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, __cil_tmp75, & vfb,
                                            __cil_tmp76);
    } else {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1163), "i" (12UL));
        while (1) {

        }

        goto while_break;
      }
      while_break: ;
    }
  }
  err_out: 
  __cil_tmp77 = & bo;
  if (*__cil_tmp77) {
    vmw_dmabuf_unreference(& bo);
  }
  __cil_tmp78 = & surface;
  if (*__cil_tmp78) {
    vmw_surface_unreference(& surface);
  }
  if (ret) {
    drm_err("vmw_kms_fb_create", "failed to create vmw_framebuffer: %i\n", ret);
    ttm_base_object_unref(& user_obj);
    __cil_tmp79 = (long )ret;
    tmp___15 = (void *)ERR_PTR(__cil_tmp79);
    tmp___13 = tmp___15;
    return ((struct drm_framebuffer *)tmp___13);
  } else {
    __cil_tmp80 = & vfb;
    __cil_tmp81 = *__cil_tmp80;
    __cil_tmp82 = (unsigned long )__cil_tmp81;
    __cil_tmp83 = __cil_tmp82 + 144UL;
    __cil_tmp84 = & user_obj;
    *((struct ttm_base_object **)__cil_tmp83) = *__cil_tmp84;
  }
  __cil_tmp85 = & vfb;
  __cil_tmp86 = *__cil_tmp85;
  return ((struct drm_framebuffer *)__cil_tmp86);
}
}
static struct drm_mode_config_funcs vmw_kms_funcs  =    {& vmw_kms_fb_create, (void (*)(struct drm_device *dev ))0};
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) 
{ struct vmw_display_unit *units[8] ;
  struct drm_clip_rect *tmp___7 ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_434 *cmd ;
  SVGASignedRect *blits ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int tmp___8 ;
  struct drm_crtc *__mptr___1 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  long tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  int __min1 ;
  int __min2 ;
  int tmp___16 ;
  int __max1 ;
  int __max2 ;
  int tmp___17 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___18 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___19 ;
  struct vmw_display_unit *unit ;
  int num ;
  long tmp___20 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_device *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  struct drm_crtc *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct list_head *__cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct drm_device *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  struct list_head *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct list_head *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct drm_framebuffer *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct drm_framebuffer *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct vmw_display_unit *__cil_tmp85 ;
  struct drm_crtc *__cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  struct drm_crtc *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct list_head *__cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  void *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  long __cil_tmp106 ;
  long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  void *__cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  void *__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  uint32_t __cil_tmp128 ;
  int32_t __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  uint32_t __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  uint32_t __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  int32_t __cil_tmp139 ;
  uint32_t __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  uint32_t __cil_tmp142 ;
  struct drm_vmw_rect *__cil_tmp143 ;
  struct drm_vmw_rect *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  uint32_t __cil_tmp147 ;
  struct drm_vmw_rect *__cil_tmp148 ;
  int32_t __cil_tmp149 ;
  uint32_t __cil_tmp150 ;
  uint32_t __cil_tmp151 ;
  struct drm_vmw_rect *__cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  struct drm_vmw_rect *__cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  struct drm_vmw_rect *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  int32_t __cil_tmp162 ;
  uint32_t __cil_tmp163 ;
  uint32_t __cil_tmp164 ;
  void *__cil_tmp165 ;
  struct __anonstruct_cmd_434 *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  uint32_t __cil_tmp182 ;
  struct drm_clip_rect *__cil_tmp183 ;
  struct drm_vmw_rect *__cil_tmp184 ;
  int32_t __cil_tmp185 ;
  int32_t __cil_tmp186 ;
  struct drm_clip_rect *__cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  uint32_t __cil_tmp190 ;
  struct drm_vmw_rect *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  uint32_t __cil_tmp194 ;
  struct drm_vmw_rect *__cil_tmp195 ;
  int32_t __cil_tmp196 ;
  uint32_t __cil_tmp197 ;
  uint32_t __cil_tmp198 ;
  uint32_t __cil_tmp199 ;
  struct drm_clip_rect *__cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  struct drm_vmw_rect *__cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  int32_t __cil_tmp206 ;
  int32_t __cil_tmp207 ;
  struct drm_clip_rect *__cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  uint32_t __cil_tmp211 ;
  struct drm_vmw_rect *__cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  uint32_t __cil_tmp215 ;
  struct drm_vmw_rect *__cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  int32_t __cil_tmp219 ;
  uint32_t __cil_tmp220 ;
  uint32_t __cil_tmp221 ;
  uint32_t __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  int __cil_tmp228 ;
  int __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  int __cil_tmp233 ;
  int __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  int __cil_tmp238 ;
  int __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  int __cil_tmp243 ;
  int __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  int __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  int __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  unsigned long __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  int __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  int __cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  int __cil_tmp287 ;
  int *__cil_tmp288 ;
  int __cil_tmp289 ;
  int *__cil_tmp290 ;
  int __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  size_t __cil_tmp297 ;
  void *__cil_tmp298 ;
  void *__cil_tmp299 ;
  uint32_t __cil_tmp300 ;
  uint64_t __cil_tmp301 ;
  void *__cil_tmp302 ;
  struct drm_vmw_fence_rep *__cil_tmp303 ;
  void *__cil_tmp304 ;
  struct vmw_fence_obj **__cil_tmp305 ;
  int __cil_tmp306 ;
  int __cil_tmp307 ;
  int __cil_tmp308 ;
  long __cil_tmp309 ;
  void *__cil_tmp310 ;
  void *__cil_tmp311 ;
  int clip_y2312 ;
  int clip_y1313 ;
  int clip_x2314 ;
  int clip_x1315 ;

  {
  ret = 0;
  num_units = 0;
  __cil_tmp51 = 1448;
  __cil_tmp52 = (unsigned long )dev_priv;
  __cil_tmp53 = __cil_tmp52 + 2088UL;
  __cil_tmp54 = *((struct drm_device **)__cil_tmp53);
  __cil_tmp55 = (unsigned long )__cil_tmp54;
  __cil_tmp56 = __cil_tmp55 + __cil_tmp51;
  __cil_tmp57 = *((struct list_head **)__cil_tmp56);
  __mptr = __cil_tmp57;
  __cil_tmp58 = (struct drm_crtc *)0;
  __cil_tmp59 = (unsigned long )__cil_tmp58;
  __cil_tmp60 = __cil_tmp59 + 8UL;
  __cil_tmp61 = (struct list_head *)__cil_tmp60;
  __cil_tmp62 = (unsigned int )__cil_tmp61;
  __cil_tmp63 = (char *)__mptr;
  __cil_tmp64 = __cil_tmp63 - __cil_tmp62;
  crtc = (struct drm_crtc *)__cil_tmp64;
  while (1) {
    __cil_tmp65 = 1448;
    __cil_tmp66 = (unsigned long )dev_priv;
    __cil_tmp67 = __cil_tmp66 + 2088UL;
    __cil_tmp68 = *((struct drm_device **)__cil_tmp67);
    __cil_tmp69 = (unsigned long )__cil_tmp68;
    __cil_tmp70 = __cil_tmp69 + __cil_tmp65;
    __cil_tmp71 = (struct list_head *)__cil_tmp70;
    __cil_tmp72 = (unsigned long )__cil_tmp71;
    __cil_tmp73 = (unsigned long )crtc;
    __cil_tmp74 = __cil_tmp73 + 8UL;
    __cil_tmp75 = (struct list_head *)__cil_tmp74;
    __cil_tmp76 = (unsigned long )__cil_tmp75;
    if (! (__cil_tmp76 != __cil_tmp72)) {
      goto while_break;
    }
    __cil_tmp77 = (struct drm_framebuffer *)vfb;
    __cil_tmp78 = (unsigned long )__cil_tmp77;
    __cil_tmp79 = (unsigned long )crtc;
    __cil_tmp80 = __cil_tmp79 + 32UL;
    __cil_tmp81 = *((struct drm_framebuffer **)__cil_tmp80);
    __cil_tmp82 = (unsigned long )__cil_tmp81;
    if (__cil_tmp82 != __cil_tmp78) {
      goto __Cont;
    }
    tmp___8 = num_units;
    num_units ++;
    __mptr___1 = crtc;
    __cil_tmp83 = (unsigned long )tmp___8 * 8UL;
    __cil_tmp84 = (unsigned long )(units) + __cil_tmp83;
    __cil_tmp85 = (struct vmw_display_unit *)0;
    __cil_tmp86 = (struct drm_crtc *)__cil_tmp85;
    __cil_tmp87 = (unsigned int )__cil_tmp86;
    __cil_tmp88 = (char *)__mptr___1;
    __cil_tmp89 = __cil_tmp88 - __cil_tmp87;
    *((struct vmw_display_unit **)__cil_tmp84) = (struct vmw_display_unit *)__cil_tmp89;
    __Cont: 
    __cil_tmp90 = (unsigned long )crtc;
    __cil_tmp91 = __cil_tmp90 + 8UL;
    __cil_tmp92 = *((struct list_head **)__cil_tmp91);
    __mptr___0 = __cil_tmp92;
    __cil_tmp93 = (struct drm_crtc *)0;
    __cil_tmp94 = (unsigned long )__cil_tmp93;
    __cil_tmp95 = __cil_tmp94 + 8UL;
    __cil_tmp96 = (struct list_head *)__cil_tmp95;
    __cil_tmp97 = (unsigned int )__cil_tmp96;
    __cil_tmp98 = (char *)__mptr___0;
    __cil_tmp99 = __cil_tmp98 - __cil_tmp97;
    crtc = (struct drm_crtc *)__cil_tmp99;
  }
  while_break: ;
  while (1) {
    __cil_tmp100 = (void *)0;
    __cil_tmp101 = (unsigned long )__cil_tmp100;
    __cil_tmp102 = (unsigned long )surface;
    __cil_tmp103 = __cil_tmp102 == __cil_tmp101;
    __cil_tmp104 = ! __cil_tmp103;
    __cil_tmp105 = ! __cil_tmp104;
    __cil_tmp106 = (long )__cil_tmp105;
    tmp___9 = ldv__builtin_expect(__cil_tmp106, 0L);
    if (tmp___9) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1216), "i" (12UL));
        while (1) {

        }

        goto while_break___1;
      }
      while_break___1: ;
    }
    goto while_break___0;
  }
  while_break___0: ;
  while (1) {

    if (! clips) {
      tmp___10 = 1;
    } else
    if (! num_clips) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
    __cil_tmp107 = (long )tmp___10;
    tmp___11 = ldv__builtin_expect(__cil_tmp107, 0L);
    if (tmp___11) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1217), "i" (12UL));
        while (1) {

        }

        goto while_break___4;
      }
      while_break___4: ;
    }
    goto while_break___3;
  }
  while_break___3: 
  __cil_tmp108 = (unsigned long )num_clips;
  __cil_tmp109 = 8UL * __cil_tmp108;
  tmp___12 = kzalloc(__cil_tmp109, 208U);
  tmp___7 = (struct drm_clip_rect *)tmp___12;
  __cil_tmp110 = (void *)0;
  __cil_tmp111 = (unsigned long )__cil_tmp110;
  __cil_tmp112 = (unsigned long )tmp___7;
  __cil_tmp113 = __cil_tmp112 == __cil_tmp111;
  __cil_tmp114 = ! __cil_tmp113;
  __cil_tmp115 = ! __cil_tmp114;
  __cil_tmp116 = (long )__cil_tmp115;
  tmp___13 = ldv__builtin_expect(__cil_tmp116, 0L);
  if (tmp___13) {
    drm_err("vmw_kms_present", "Temporary cliprect memory alloc failed.\n");
    return (-12);
  }
  __cil_tmp117 = (unsigned long )num_clips;
  __cil_tmp118 = 16UL * __cil_tmp117;
  fifo_size = 56UL + __cil_tmp118;
  tmp___14 = kmalloc(fifo_size, 208U);
  cmd = (struct __anonstruct_cmd_434 *)tmp___14;
  __cil_tmp119 = (void *)0;
  __cil_tmp120 = (unsigned long )__cil_tmp119;
  __cil_tmp121 = (unsigned long )cmd;
  __cil_tmp122 = __cil_tmp121 == __cil_tmp120;
  __cil_tmp123 = ! __cil_tmp122;
  __cil_tmp124 = ! __cil_tmp123;
  __cil_tmp125 = (long )__cil_tmp124;
  tmp___15 = ldv__builtin_expect(__cil_tmp125, 0L);
  if (tmp___15) {
    drm_err("vmw_kms_present", "Failed to allocate temporary fifo memory.\n");
    ret = -12;
    goto out_free_tmp;
  }
  left = *((int32_t *)clips);
  __cil_tmp126 = (unsigned long )clips;
  __cil_tmp127 = __cil_tmp126 + 8UL;
  __cil_tmp128 = *((uint32_t *)__cil_tmp127);
  __cil_tmp129 = *((int32_t *)clips);
  __cil_tmp130 = (uint32_t )__cil_tmp129;
  __cil_tmp131 = __cil_tmp130 + __cil_tmp128;
  right = (int )__cil_tmp131;
  __cil_tmp132 = (unsigned long )clips;
  __cil_tmp133 = __cil_tmp132 + 4UL;
  top = *((int32_t *)__cil_tmp133);
  __cil_tmp134 = (unsigned long )clips;
  __cil_tmp135 = __cil_tmp134 + 12UL;
  __cil_tmp136 = *((uint32_t *)__cil_tmp135);
  __cil_tmp137 = (unsigned long )clips;
  __cil_tmp138 = __cil_tmp137 + 4UL;
  __cil_tmp139 = *((int32_t *)__cil_tmp138);
  __cil_tmp140 = (uint32_t )__cil_tmp139;
  __cil_tmp141 = __cil_tmp140 + __cil_tmp136;
  bottom = (int )__cil_tmp141;
  i = 1;
  while (1) {
    __cil_tmp142 = (uint32_t )i;
    if (! (__cil_tmp142 < num_clips)) {
      goto while_break___6;
    }
    __min1 = left;
    __cil_tmp143 = clips + i;
    __min2 = *((int32_t *)__cil_tmp143);
    if (__min1 < __min2) {
      tmp___16 = __min1;
    } else {
      tmp___16 = __min2;
    }
    left = tmp___16;
    __max1 = right;
    __cil_tmp144 = clips + i;
    __cil_tmp145 = (unsigned long )__cil_tmp144;
    __cil_tmp146 = __cil_tmp145 + 8UL;
    __cil_tmp147 = *((uint32_t *)__cil_tmp146);
    __cil_tmp148 = clips + i;
    __cil_tmp149 = *((int32_t *)__cil_tmp148);
    __cil_tmp150 = (uint32_t )__cil_tmp149;
    __cil_tmp151 = __cil_tmp150 + __cil_tmp147;
    __max2 = (int )__cil_tmp151;
    if (__max1 > __max2) {
      tmp___17 = __max1;
    } else {
      tmp___17 = __max2;
    }
    right = tmp___17;
    __min1___0 = top;
    __cil_tmp152 = clips + i;
    __cil_tmp153 = (unsigned long )__cil_tmp152;
    __cil_tmp154 = __cil_tmp153 + 4UL;
    __min2___0 = *((int32_t *)__cil_tmp154);
    if (__min1___0 < __min2___0) {
      tmp___18 = __min1___0;
    } else {
      tmp___18 = __min2___0;
    }
    top = tmp___18;
    __max1___0 = bottom;
    __cil_tmp155 = clips + i;
    __cil_tmp156 = (unsigned long )__cil_tmp155;
    __cil_tmp157 = __cil_tmp156 + 12UL;
    __cil_tmp158 = *((uint32_t *)__cil_tmp157);
    __cil_tmp159 = clips + i;
    __cil_tmp160 = (unsigned long )__cil_tmp159;
    __cil_tmp161 = __cil_tmp160 + 4UL;
    __cil_tmp162 = *((int32_t *)__cil_tmp161);
    __cil_tmp163 = (uint32_t )__cil_tmp162;
    __cil_tmp164 = __cil_tmp163 + __cil_tmp158;
    __max2___0 = (int )__cil_tmp164;
    if (__max1___0 > __max2___0) {
      tmp___19 = __max1___0;
    } else {
      tmp___19 = __max2___0;
    }
    bottom = tmp___19;
    i ++;
  }
  while_break___6: 
  __cil_tmp165 = (void *)cmd;
  memset(__cil_tmp165, 0, fifo_size);
  *((uint32 *)cmd) = (__u32 )1069;
  __cil_tmp166 = cmd + 1;
  blits = (SVGASignedRect *)__cil_tmp166;
  __cil_tmp167 = 20;
  __cil_tmp168 = (unsigned long )cmd;
  __cil_tmp169 = __cil_tmp168 + __cil_tmp167;
  *((int32 *)__cil_tmp169) = left;
  __cil_tmp170 = 20;
  __cil_tmp171 = 8UL + __cil_tmp170;
  __cil_tmp172 = (unsigned long )cmd;
  __cil_tmp173 = __cil_tmp172 + __cil_tmp171;
  *((int32 *)__cil_tmp173) = right;
  __cil_tmp174 = 16;
  __cil_tmp175 = 8UL + __cil_tmp174;
  __cil_tmp176 = (unsigned long )cmd;
  __cil_tmp177 = __cil_tmp176 + __cil_tmp175;
  *((int32 *)__cil_tmp177) = top;
  __cil_tmp178 = 24;
  __cil_tmp179 = 8UL + __cil_tmp178;
  __cil_tmp180 = (unsigned long )cmd;
  __cil_tmp181 = __cil_tmp180 + __cil_tmp179;
  *((int32 *)__cil_tmp181) = bottom;
  i = 0;
  while (1) {
    __cil_tmp182 = (uint32_t )i;
    if (! (__cil_tmp182 < num_clips)) {
      goto while_break___7;
    }
    __cil_tmp183 = tmp___7 + i;
    __cil_tmp184 = clips + i;
    __cil_tmp185 = *((int32_t *)__cil_tmp184);
    __cil_tmp186 = __cil_tmp185 - left;
    *((unsigned short *)__cil_tmp183) = (unsigned short )__cil_tmp186;
    __cil_tmp187 = tmp___7 + i;
    __cil_tmp188 = (unsigned long )__cil_tmp187;
    __cil_tmp189 = __cil_tmp188 + 4UL;
    __cil_tmp190 = (uint32_t )left;
    __cil_tmp191 = clips + i;
    __cil_tmp192 = (unsigned long )__cil_tmp191;
    __cil_tmp193 = __cil_tmp192 + 8UL;
    __cil_tmp194 = *((uint32_t *)__cil_tmp193);
    __cil_tmp195 = clips + i;
    __cil_tmp196 = *((int32_t *)__cil_tmp195);
    __cil_tmp197 = (uint32_t )__cil_tmp196;
    __cil_tmp198 = __cil_tmp197 + __cil_tmp194;
    __cil_tmp199 = __cil_tmp198 - __cil_tmp190;
    *((unsigned short *)__cil_tmp189) = (unsigned short )__cil_tmp199;
    __cil_tmp200 = tmp___7 + i;
    __cil_tmp201 = (unsigned long )__cil_tmp200;
    __cil_tmp202 = __cil_tmp201 + 2UL;
    __cil_tmp203 = clips + i;
    __cil_tmp204 = (unsigned long )__cil_tmp203;
    __cil_tmp205 = __cil_tmp204 + 4UL;
    __cil_tmp206 = *((int32_t *)__cil_tmp205);
    __cil_tmp207 = __cil_tmp206 - top;
    *((unsigned short *)__cil_tmp202) = (unsigned short )__cil_tmp207;
    __cil_tmp208 = tmp___7 + i;
    __cil_tmp209 = (unsigned long )__cil_tmp208;
    __cil_tmp210 = __cil_tmp209 + 6UL;
    __cil_tmp211 = (uint32_t )top;
    __cil_tmp212 = clips + i;
    __cil_tmp213 = (unsigned long )__cil_tmp212;
    __cil_tmp214 = __cil_tmp213 + 12UL;
    __cil_tmp215 = *((uint32_t *)__cil_tmp214);
    __cil_tmp216 = clips + i;
    __cil_tmp217 = (unsigned long )__cil_tmp216;
    __cil_tmp218 = __cil_tmp217 + 4UL;
    __cil_tmp219 = *((int32_t *)__cil_tmp218);
    __cil_tmp220 = (uint32_t )__cil_tmp219;
    __cil_tmp221 = __cil_tmp220 + __cil_tmp215;
    __cil_tmp222 = __cil_tmp221 - __cil_tmp211;
    *((unsigned short *)__cil_tmp210) = (unsigned short )__cil_tmp222;
    i ++;
  }
  while_break___7: 
  k = 0;
  while (1) {

    if (! (k < num_units)) {
      goto while_break___8;
    }
    __cil_tmp223 = (unsigned long )k * 8UL;
    __cil_tmp224 = (unsigned long )(units) + __cil_tmp223;
    unit = *((struct vmw_display_unit **)__cil_tmp224);
    __cil_tmp225 = 480;
    __cil_tmp226 = (unsigned long )unit;
    __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
    __cil_tmp228 = *((int *)__cil_tmp227);
    __cil_tmp229 = left + destX;
    clip_x1315 = __cil_tmp229 - __cil_tmp228;
    __cil_tmp230 = 484;
    __cil_tmp231 = (unsigned long )unit;
    __cil_tmp232 = __cil_tmp231 + __cil_tmp230;
    __cil_tmp233 = *((int *)__cil_tmp232);
    __cil_tmp234 = top + destY;
    clip_y1313 = __cil_tmp234 - __cil_tmp233;
    __cil_tmp235 = 480;
    __cil_tmp236 = (unsigned long )unit;
    __cil_tmp237 = __cil_tmp236 + __cil_tmp235;
    __cil_tmp238 = *((int *)__cil_tmp237);
    __cil_tmp239 = right + destX;
    clip_x2314 = __cil_tmp239 - __cil_tmp238;
    __cil_tmp240 = 484;
    __cil_tmp241 = (unsigned long )unit;
    __cil_tmp242 = __cil_tmp241 + __cil_tmp240;
    __cil_tmp243 = *((int *)__cil_tmp242);
    __cil_tmp244 = bottom + destY;
    clip_y2312 = __cil_tmp244 - __cil_tmp243;
    __cil_tmp245 = 116;
    __cil_tmp246 = __cil_tmp245;
    __cil_tmp247 = (unsigned long )unit;
    __cil_tmp248 = __cil_tmp247 + __cil_tmp246;
    __cil_tmp249 = *((int *)__cil_tmp248);
    if (clip_x1315 >= __cil_tmp249) {
      goto __Cont___0;
    } else {
      __cil_tmp250 = 136;
      __cil_tmp251 = __cil_tmp250;
      __cil_tmp252 = (unsigned long )unit;
      __cil_tmp253 = __cil_tmp252 + __cil_tmp251;
      __cil_tmp254 = *((int *)__cil_tmp253);
      if (clip_y1313 >= __cil_tmp254) {
        goto __Cont___0;
      } else
      if (clip_x2314 <= 0) {
        goto __Cont___0;
      } else
      if (clip_y2312 <= 0) {
        goto __Cont___0;
      }
    }
    __cil_tmp255 = 40;
    __cil_tmp256 = (unsigned long )cmd;
    __cil_tmp257 = __cil_tmp256 + __cil_tmp255;
    *((int32 *)__cil_tmp257) = clip_x1315;
    __cil_tmp258 = 40;
    __cil_tmp259 = 8UL + __cil_tmp258;
    __cil_tmp260 = (unsigned long )cmd;
    __cil_tmp261 = __cil_tmp260 + __cil_tmp259;
    *((int32 *)__cil_tmp261) = clip_x2314;
    __cil_tmp262 = 36;
    __cil_tmp263 = 8UL + __cil_tmp262;
    __cil_tmp264 = (unsigned long )cmd;
    __cil_tmp265 = __cil_tmp264 + __cil_tmp263;
    *((int32 *)__cil_tmp265) = clip_y1313;
    __cil_tmp266 = 44;
    __cil_tmp267 = 8UL + __cil_tmp266;
    __cil_tmp268 = (unsigned long )cmd;
    __cil_tmp269 = __cil_tmp268 + __cil_tmp267;
    *((int32 *)__cil_tmp269) = clip_y2312;
    __cil_tmp270 = 116;
    __cil_tmp271 = __cil_tmp270;
    __cil_tmp272 = (unsigned long )unit;
    __cil_tmp273 = __cil_tmp272 + __cil_tmp271;
    __cil_tmp274 = *((int *)__cil_tmp273);
    clip_x2314 = __cil_tmp274 - clip_x1315;
    __cil_tmp275 = 136;
    __cil_tmp276 = __cil_tmp275;
    __cil_tmp277 = (unsigned long )unit;
    __cil_tmp278 = __cil_tmp277 + __cil_tmp276;
    __cil_tmp279 = *((int *)__cil_tmp278);
    clip_y2312 = __cil_tmp279 - clip_y1313;
    clip_x1315 = 0 - clip_x1315;
    clip_y1313 = 0 - clip_y1313;
    __cil_tmp280 = (unsigned long )cmd;
    __cil_tmp281 = __cil_tmp280 + 8UL;
    *((uint32 *)__cil_tmp281) = sid;
    __cil_tmp282 = 36;
    __cil_tmp283 = (unsigned long )cmd;
    __cil_tmp284 = __cil_tmp283 + __cil_tmp282;
    __cil_tmp285 = (unsigned long )unit;
    __cil_tmp286 = __cil_tmp285 + 2032UL;
    *((uint32 *)__cil_tmp284) = *((unsigned int *)__cil_tmp286);
    __cil_tmp287 = (int )num_clips;
    vmw_clip_cliprects(tmp___7, __cil_tmp287, clip_x1315, clip_x2314, clip_y1313,
                       clip_y2312, blits, & num);
    __cil_tmp288 = & num;
    __cil_tmp289 = *__cil_tmp288;
    if (__cil_tmp289 == 0) {
      goto __Cont___0;
    }
    __cil_tmp290 = & num;
    __cil_tmp291 = *__cil_tmp290;
    __cil_tmp292 = (unsigned long )__cil_tmp291;
    __cil_tmp293 = 16UL * __cil_tmp292;
    fifo_size = 56UL + __cil_tmp293;
    __cil_tmp294 = 4;
    __cil_tmp295 = (unsigned long )cmd;
    __cil_tmp296 = __cil_tmp295 + __cil_tmp294;
    __cil_tmp297 = fifo_size - 8UL;
    *((uint32 *)__cil_tmp296) = (__u32 )__cil_tmp297;
    __cil_tmp298 = (void *)0;
    __cil_tmp299 = (void *)cmd;
    __cil_tmp300 = (uint32_t )fifo_size;
    __cil_tmp301 = (uint64_t )0;
    __cil_tmp302 = (void *)0;
    __cil_tmp303 = (struct drm_vmw_fence_rep *)__cil_tmp302;
    __cil_tmp304 = (void *)0;
    __cil_tmp305 = (struct vmw_fence_obj **)__cil_tmp304;
    ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp298, __cil_tmp299, __cil_tmp300,
                              __cil_tmp301, __cil_tmp303, __cil_tmp305);
    __cil_tmp306 = ret != 0;
    __cil_tmp307 = ! __cil_tmp306;
    __cil_tmp308 = ! __cil_tmp307;
    __cil_tmp309 = (long )__cil_tmp308;
    tmp___20 = ldv__builtin_expect(__cil_tmp309, 0L);
    if (tmp___20) {
      goto while_break___8;
    }
    __Cont___0: 
    k ++;
  }
  while_break___8: 
  __cil_tmp310 = (void *)cmd;
  kfree(__cil_tmp310);
  out_free_tmp: 
  __cil_tmp311 = (void *)tmp___7;
  kfree(__cil_tmp311);
  return (ret);
}
}
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer *__mptr ;
  struct vmw_dma_buffer *dmabuf ;
  struct vmw_display_unit *units[8] ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int ret ;
  int num_units ;
  int blits_pos ;
  struct __anonstruct_cmd_435 *cmd ;
  struct __anonstruct_blits_436 *blits ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  int tmp___7 ;
  struct drm_crtc *__mptr___2 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  struct drm_vmw_rect *c ;
  int clip_x1 ;
  int clip_x2 ;
  int clip_y1 ;
  int clip_y2 ;
  int dest_x ;
  int dest_y ;
  int _max1 ;
  int _max2 ;
  int tmp___13 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___14 ;
  int _min1 ;
  int _min2 ;
  int tmp___15 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___16 ;
  struct drm_framebuffer *__cil_tmp48 ;
  struct vmw_framebuffer_dmabuf *__cil_tmp49 ;
  struct drm_framebuffer *__cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct drm_device *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct list_head *__cil_tmp62 ;
  struct drm_crtc *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct drm_device *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct list_head *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct drm_framebuffer *__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct drm_framebuffer *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct vmw_display_unit *__cil_tmp90 ;
  struct drm_crtc *__cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct list_head *__cil_tmp97 ;
  struct drm_crtc *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  struct list_head *__cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  void *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  long __cil_tmp111 ;
  long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  void *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  long __cil_tmp123 ;
  void *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  int __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  struct __anonstruct_cmd_435 *__cil_tmp163 ;
  void *__cil_tmp164 ;
  uint32_t __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  struct vmw_display_unit *__cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  int __cil_tmp172 ;
  int32_t __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  uint32_t __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  struct vmw_display_unit *__cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  int __cil_tmp183 ;
  int32_t __cil_tmp184 ;
  int32_t __cil_tmp185 ;
  uint32_t __cil_tmp186 ;
  uint32_t __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  struct vmw_display_unit *__cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  int __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  int32_t __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint32_t __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  struct vmw_display_unit *__cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  int __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  int32_t __cil_tmp210 ;
  int32_t __cil_tmp211 ;
  uint32_t __cil_tmp212 ;
  uint32_t __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  int __cil_tmp216 ;
  int __cil_tmp217 ;
  int *__cil_tmp218 ;
  int *__cil_tmp219 ;
  int *__cil_tmp220 ;
  int __cil_tmp221 ;
  int *__cil_tmp222 ;
  int __cil_tmp223 ;
  int *__cil_tmp224 ;
  int *__cil_tmp225 ;
  int *__cil_tmp226 ;
  int *__cil_tmp227 ;
  int *__cil_tmp228 ;
  int __cil_tmp229 ;
  int *__cil_tmp230 ;
  int __cil_tmp231 ;
  int *__cil_tmp232 ;
  int *__cil_tmp233 ;
  int *__cil_tmp234 ;
  int *__cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct vmw_display_unit *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  int *__cil_tmp243 ;
  int __cil_tmp244 ;
  int *__cil_tmp245 ;
  int __cil_tmp246 ;
  int *__cil_tmp247 ;
  int *__cil_tmp248 ;
  int *__cil_tmp249 ;
  int *__cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  struct vmw_display_unit *__cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  int *__cil_tmp258 ;
  int __cil_tmp259 ;
  int *__cil_tmp260 ;
  int __cil_tmp261 ;
  int *__cil_tmp262 ;
  int *__cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  struct vmw_display_unit *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  int __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  struct vmw_display_unit *__cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  int __cil_tmp279 ;
  struct __anonstruct_blits_436 *__cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  struct __anonstruct_blits_436 *__cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  struct vmw_display_unit *__cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  struct __anonstruct_blits_436 *__cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  struct __anonstruct_blits_436 *__cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  struct __anonstruct_blits_436 *__cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  struct __anonstruct_blits_436 *__cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  unsigned long __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  struct __anonstruct_blits_436 *__cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct __anonstruct_blits_436 *__cil_tmp314 ;
  unsigned long __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  unsigned long __cil_tmp318 ;
  void *__cil_tmp319 ;
  void *__cil_tmp320 ;
  uint32_t __cil_tmp321 ;
  uint64_t __cil_tmp322 ;
  void *__cil_tmp323 ;
  struct vmw_fence_obj **__cil_tmp324 ;
  void *__cil_tmp325 ;

  {
  __cil_tmp48 = (struct drm_framebuffer *)vfb;
  __mptr = __cil_tmp48;
  __cil_tmp49 = (struct vmw_framebuffer_dmabuf *)0;
  __cil_tmp50 = (struct drm_framebuffer *)__cil_tmp49;
  __cil_tmp51 = (unsigned int )__cil_tmp50;
  __cil_tmp52 = (char *)__mptr;
  __cil_tmp53 = __cil_tmp52 - __cil_tmp51;
  vfbd = (struct vmw_framebuffer_dmabuf *)__cil_tmp53;
  __cil_tmp54 = (unsigned long )vfbd;
  __cil_tmp55 = __cil_tmp54 + 160UL;
  dmabuf = *((struct vmw_dma_buffer **)__cil_tmp55);
  num_units = 0;
  __cil_tmp56 = 1448;
  __cil_tmp57 = (unsigned long )dev_priv;
  __cil_tmp58 = __cil_tmp57 + 2088UL;
  __cil_tmp59 = *((struct drm_device **)__cil_tmp58);
  __cil_tmp60 = (unsigned long )__cil_tmp59;
  __cil_tmp61 = __cil_tmp60 + __cil_tmp56;
  __cil_tmp62 = *((struct list_head **)__cil_tmp61);
  __mptr___0 = __cil_tmp62;
  __cil_tmp63 = (struct drm_crtc *)0;
  __cil_tmp64 = (unsigned long )__cil_tmp63;
  __cil_tmp65 = __cil_tmp64 + 8UL;
  __cil_tmp66 = (struct list_head *)__cil_tmp65;
  __cil_tmp67 = (unsigned int )__cil_tmp66;
  __cil_tmp68 = (char *)__mptr___0;
  __cil_tmp69 = __cil_tmp68 - __cil_tmp67;
  crtc = (struct drm_crtc *)__cil_tmp69;
  while (1) {
    __cil_tmp70 = 1448;
    __cil_tmp71 = (unsigned long )dev_priv;
    __cil_tmp72 = __cil_tmp71 + 2088UL;
    __cil_tmp73 = *((struct drm_device **)__cil_tmp72);
    __cil_tmp74 = (unsigned long )__cil_tmp73;
    __cil_tmp75 = __cil_tmp74 + __cil_tmp70;
    __cil_tmp76 = (struct list_head *)__cil_tmp75;
    __cil_tmp77 = (unsigned long )__cil_tmp76;
    __cil_tmp78 = (unsigned long )crtc;
    __cil_tmp79 = __cil_tmp78 + 8UL;
    __cil_tmp80 = (struct list_head *)__cil_tmp79;
    __cil_tmp81 = (unsigned long )__cil_tmp80;
    if (! (__cil_tmp81 != __cil_tmp77)) {
      goto while_break;
    }
    __cil_tmp82 = (struct drm_framebuffer *)vfb;
    __cil_tmp83 = (unsigned long )__cil_tmp82;
    __cil_tmp84 = (unsigned long )crtc;
    __cil_tmp85 = __cil_tmp84 + 32UL;
    __cil_tmp86 = *((struct drm_framebuffer **)__cil_tmp85);
    __cil_tmp87 = (unsigned long )__cil_tmp86;
    if (__cil_tmp87 != __cil_tmp83) {
      goto __Cont;
    }
    tmp___7 = num_units;
    num_units ++;
    __mptr___2 = crtc;
    __cil_tmp88 = (unsigned long )tmp___7 * 8UL;
    __cil_tmp89 = (unsigned long )(units) + __cil_tmp88;
    __cil_tmp90 = (struct vmw_display_unit *)0;
    __cil_tmp91 = (struct drm_crtc *)__cil_tmp90;
    __cil_tmp92 = (unsigned int )__cil_tmp91;
    __cil_tmp93 = (char *)__mptr___2;
    __cil_tmp94 = __cil_tmp93 - __cil_tmp92;
    *((struct vmw_display_unit **)__cil_tmp89) = (struct vmw_display_unit *)__cil_tmp94;
    __Cont: 
    __cil_tmp95 = (unsigned long )crtc;
    __cil_tmp96 = __cil_tmp95 + 8UL;
    __cil_tmp97 = *((struct list_head **)__cil_tmp96);
    __mptr___1 = __cil_tmp97;
    __cil_tmp98 = (struct drm_crtc *)0;
    __cil_tmp99 = (unsigned long )__cil_tmp98;
    __cil_tmp100 = __cil_tmp99 + 8UL;
    __cil_tmp101 = (struct list_head *)__cil_tmp100;
    __cil_tmp102 = (unsigned int )__cil_tmp101;
    __cil_tmp103 = (char *)__mptr___1;
    __cil_tmp104 = __cil_tmp103 - __cil_tmp102;
    crtc = (struct drm_crtc *)__cil_tmp104;
  }
  while_break: ;
  while (1) {
    __cil_tmp105 = (void *)0;
    __cil_tmp106 = (unsigned long )__cil_tmp105;
    __cil_tmp107 = (unsigned long )dmabuf;
    __cil_tmp108 = __cil_tmp107 == __cil_tmp106;
    __cil_tmp109 = ! __cil_tmp108;
    __cil_tmp110 = ! __cil_tmp109;
    __cil_tmp111 = (long )__cil_tmp110;
    tmp___8 = ldv__builtin_expect(__cil_tmp111, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1353), "i" (12UL));
        while (1) {

        }

        goto while_break___1;
      }
      while_break___1: ;
    }
    goto while_break___0;
  }
  while_break___0: ;
  while (1) {

    if (! clips) {
      tmp___9 = 1;
    } else
    if (! num_clips) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    __cil_tmp112 = (long )tmp___9;
    tmp___10 = ldv__builtin_expect(__cil_tmp112, 0L);
    if (tmp___10) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c"),
                             "i" (1354), "i" (12UL));
        while (1) {

        }

        goto while_break___4;
      }
      while_break___4: ;
    }
    goto while_break___3;
  }
  while_break___3: 
  __cil_tmp113 = (unsigned long )num_units;
  __cil_tmp114 = (unsigned long )num_clips;
  __cil_tmp115 = 32UL * __cil_tmp114;
  __cil_tmp116 = __cil_tmp115 * __cil_tmp113;
  fifo_size = 20UL + __cil_tmp116;
  tmp___11 = kmalloc(fifo_size, 208U);
  cmd = (struct __anonstruct_cmd_435 *)tmp___11;
  __cil_tmp117 = (void *)0;
  __cil_tmp118 = (unsigned long )__cil_tmp117;
  __cil_tmp119 = (unsigned long )cmd;
  __cil_tmp120 = __cil_tmp119 == __cil_tmp118;
  __cil_tmp121 = ! __cil_tmp120;
  __cil_tmp122 = ! __cil_tmp121;
  __cil_tmp123 = (long )__cil_tmp122;
  tmp___12 = ldv__builtin_expect(__cil_tmp123, 0L);
  if (tmp___12) {
    drm_err("vmw_kms_readback", "Failed to allocate temporary fifo memory.\n");
    return (-12);
  }
  __cil_tmp124 = (void *)cmd;
  memset(__cil_tmp124, 0, fifo_size);
  *((uint32_t *)cmd) = (uint32_t )36;
  __cil_tmp125 = 16;
  __cil_tmp126 = (unsigned long )cmd;
  __cil_tmp127 = __cil_tmp126 + __cil_tmp125;
  __cil_tmp128 = 84;
  __cil_tmp129 = (unsigned long )vfb;
  __cil_tmp130 = __cil_tmp129 + __cil_tmp128;
  __cil_tmp131 = *((int *)__cil_tmp130);
  *((uint32 *)__cil_tmp127) = (uint32 )__cil_tmp131;
  __cil_tmp132 = 1;
  __cil_tmp133 = __cil_tmp132;
  __cil_tmp134 = 12UL + __cil_tmp133;
  __cil_tmp135 = 4UL + __cil_tmp134;
  __cil_tmp136 = (unsigned long )cmd;
  __cil_tmp137 = __cil_tmp136 + __cil_tmp135;
  __cil_tmp138 = 80;
  __cil_tmp139 = (unsigned long )vfb;
  __cil_tmp140 = __cil_tmp139 + __cil_tmp138;
  *((uint32 *)__cil_tmp137) = *((unsigned int *)__cil_tmp140);
  __cil_tmp141 = 2;
  __cil_tmp142 = __cil_tmp141;
  __cil_tmp143 = 12UL + __cil_tmp142;
  __cil_tmp144 = 4UL + __cil_tmp143;
  __cil_tmp145 = (unsigned long )cmd;
  __cil_tmp146 = __cil_tmp145 + __cil_tmp144;
  *((uint32 *)__cil_tmp146) = (uint32 )0;
  __cil_tmp147 = 12;
  __cil_tmp148 = (unsigned long )cmd;
  __cil_tmp149 = __cil_tmp148 + __cil_tmp147;
  __cil_tmp150 = 0UL;
  __cil_tmp151 = 40UL + __cil_tmp150;
  __cil_tmp152 = __cil_tmp151;
  __cil_tmp153 = (unsigned long )vfb;
  __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
  *((uint32 *)__cil_tmp149) = *((unsigned int *)__cil_tmp154);
  __cil_tmp155 = (unsigned long )cmd;
  __cil_tmp156 = __cil_tmp155 + 4UL;
  __cil_tmp157 = (unsigned long )vfb;
  __cil_tmp158 = __cil_tmp157 + 152UL;
  *((uint32 *)__cil_tmp156) = *((uint32_t *)__cil_tmp158);
  __cil_tmp159 = 4;
  __cil_tmp160 = 4UL + __cil_tmp159;
  __cil_tmp161 = (unsigned long )cmd;
  __cil_tmp162 = __cil_tmp161 + __cil_tmp160;
  *((uint32 *)__cil_tmp162) = (uint32 )0;
  __cil_tmp163 = cmd + 1;
  __cil_tmp164 = (void *)__cil_tmp163;
  blits = (struct __anonstruct_blits_436 *)__cil_tmp164;
  blits_pos = 0;
  i = 0;
  while (1) {

    if (! (i < num_units)) {
      goto while_break___6;
    }
    c = clips;
    k = 0;
    while (1) {
      __cil_tmp165 = (uint32_t )k;
      if (! (__cil_tmp165 < num_clips)) {
        goto while_break___7;
      }
      __cil_tmp166 = 480;
      __cil_tmp167 = (unsigned long )i * 8UL;
      __cil_tmp168 = (unsigned long )(units) + __cil_tmp167;
      __cil_tmp169 = *((struct vmw_display_unit **)__cil_tmp168);
      __cil_tmp170 = (unsigned long )__cil_tmp169;
      __cil_tmp171 = __cil_tmp170 + __cil_tmp166;
      __cil_tmp172 = *((int *)__cil_tmp171);
      __cil_tmp173 = *((int32_t *)c);
      clip_x1 = __cil_tmp173 - __cil_tmp172;
      __cil_tmp174 = (unsigned long )c;
      __cil_tmp175 = __cil_tmp174 + 8UL;
      __cil_tmp176 = *((uint32_t *)__cil_tmp175);
      __cil_tmp177 = 480;
      __cil_tmp178 = (unsigned long )i * 8UL;
      __cil_tmp179 = (unsigned long )(units) + __cil_tmp178;
      __cil_tmp180 = *((struct vmw_display_unit **)__cil_tmp179);
      __cil_tmp181 = (unsigned long )__cil_tmp180;
      __cil_tmp182 = __cil_tmp181 + __cil_tmp177;
      __cil_tmp183 = *((int *)__cil_tmp182);
      __cil_tmp184 = *((int32_t *)c);
      __cil_tmp185 = __cil_tmp184 - __cil_tmp183;
      __cil_tmp186 = (uint32_t )__cil_tmp185;
      __cil_tmp187 = __cil_tmp186 + __cil_tmp176;
      clip_x2 = (int )__cil_tmp187;
      __cil_tmp188 = 484;
      __cil_tmp189 = (unsigned long )i * 8UL;
      __cil_tmp190 = (unsigned long )(units) + __cil_tmp189;
      __cil_tmp191 = *((struct vmw_display_unit **)__cil_tmp190);
      __cil_tmp192 = (unsigned long )__cil_tmp191;
      __cil_tmp193 = __cil_tmp192 + __cil_tmp188;
      __cil_tmp194 = *((int *)__cil_tmp193);
      __cil_tmp195 = (unsigned long )c;
      __cil_tmp196 = __cil_tmp195 + 4UL;
      __cil_tmp197 = *((int32_t *)__cil_tmp196);
      clip_y1 = __cil_tmp197 - __cil_tmp194;
      __cil_tmp198 = (unsigned long )c;
      __cil_tmp199 = __cil_tmp198 + 12UL;
      __cil_tmp200 = *((uint32_t *)__cil_tmp199);
      __cil_tmp201 = 484;
      __cil_tmp202 = (unsigned long )i * 8UL;
      __cil_tmp203 = (unsigned long )(units) + __cil_tmp202;
      __cil_tmp204 = *((struct vmw_display_unit **)__cil_tmp203);
      __cil_tmp205 = (unsigned long )__cil_tmp204;
      __cil_tmp206 = __cil_tmp205 + __cil_tmp201;
      __cil_tmp207 = *((int *)__cil_tmp206);
      __cil_tmp208 = (unsigned long )c;
      __cil_tmp209 = __cil_tmp208 + 4UL;
      __cil_tmp210 = *((int32_t *)__cil_tmp209);
      __cil_tmp211 = __cil_tmp210 - __cil_tmp207;
      __cil_tmp212 = (uint32_t )__cil_tmp211;
      __cil_tmp213 = __cil_tmp212 + __cil_tmp200;
      clip_y2 = (int )__cil_tmp213;
      dest_x = *((int32_t *)c);
      __cil_tmp214 = (unsigned long )c;
      __cil_tmp215 = __cil_tmp214 + 4UL;
      dest_y = *((int32_t *)__cil_tmp215);
      if (clip_x1 < 0) {
        __cil_tmp216 = - clip_x1;
        dest_x += __cil_tmp216;
      }
      if (clip_y1 < 0) {
        __cil_tmp217 = - clip_y1;
        dest_y += __cil_tmp217;
      }
      __cil_tmp218 = & _max1;
      *__cil_tmp218 = clip_x1;
      __cil_tmp219 = & _max2;
      *__cil_tmp219 = 0;
      __cil_tmp220 = & _max2;
      __cil_tmp221 = *__cil_tmp220;
      __cil_tmp222 = & _max1;
      __cil_tmp223 = *__cil_tmp222;
      if (__cil_tmp223 > __cil_tmp221) {
        __cil_tmp224 = & _max1;
        tmp___13 = *__cil_tmp224;
      } else {
        __cil_tmp225 = & _max2;
        tmp___13 = *__cil_tmp225;
      }
      clip_x1 = tmp___13;
      __cil_tmp226 = & _max1___0;
      *__cil_tmp226 = clip_y1;
      __cil_tmp227 = & _max2___0;
      *__cil_tmp227 = 0;
      __cil_tmp228 = & _max2___0;
      __cil_tmp229 = *__cil_tmp228;
      __cil_tmp230 = & _max1___0;
      __cil_tmp231 = *__cil_tmp230;
      if (__cil_tmp231 > __cil_tmp229) {
        __cil_tmp232 = & _max1___0;
        tmp___14 = *__cil_tmp232;
      } else {
        __cil_tmp233 = & _max2___0;
        tmp___14 = *__cil_tmp233;
      }
      clip_y1 = tmp___14;
      __cil_tmp234 = & _min1;
      *__cil_tmp234 = clip_x2;
      __cil_tmp235 = & _min2;
      __cil_tmp236 = 116;
      __cil_tmp237 = __cil_tmp236;
      __cil_tmp238 = (unsigned long )i * 8UL;
      __cil_tmp239 = (unsigned long )(units) + __cil_tmp238;
      __cil_tmp240 = *((struct vmw_display_unit **)__cil_tmp239);
      __cil_tmp241 = (unsigned long )__cil_tmp240;
      __cil_tmp242 = __cil_tmp241 + __cil_tmp237;
      *__cil_tmp235 = *((int *)__cil_tmp242);
      __cil_tmp243 = & _min2;
      __cil_tmp244 = *__cil_tmp243;
      __cil_tmp245 = & _min1;
      __cil_tmp246 = *__cil_tmp245;
      if (__cil_tmp246 < __cil_tmp244) {
        __cil_tmp247 = & _min1;
        tmp___15 = *__cil_tmp247;
      } else {
        __cil_tmp248 = & _min2;
        tmp___15 = *__cil_tmp248;
      }
      clip_x2 = tmp___15;
      __cil_tmp249 = & _min1___0;
      *__cil_tmp249 = clip_y2;
      __cil_tmp250 = & _min2___0;
      __cil_tmp251 = 136;
      __cil_tmp252 = __cil_tmp251;
      __cil_tmp253 = (unsigned long )i * 8UL;
      __cil_tmp254 = (unsigned long )(units) + __cil_tmp253;
      __cil_tmp255 = *((struct vmw_display_unit **)__cil_tmp254);
      __cil_tmp256 = (unsigned long )__cil_tmp255;
      __cil_tmp257 = __cil_tmp256 + __cil_tmp252;
      *__cil_tmp250 = *((int *)__cil_tmp257);
      __cil_tmp258 = & _min2___0;
      __cil_tmp259 = *__cil_tmp258;
      __cil_tmp260 = & _min1___0;
      __cil_tmp261 = *__cil_tmp260;
      if (__cil_tmp261 < __cil_tmp259) {
        __cil_tmp262 = & _min1___0;
        tmp___16 = *__cil_tmp262;
      } else {
        __cil_tmp263 = & _min2___0;
        tmp___16 = *__cil_tmp263;
      }
      clip_y2 = tmp___16;
      __cil_tmp264 = 116;
      __cil_tmp265 = __cil_tmp264;
      __cil_tmp266 = (unsigned long )i * 8UL;
      __cil_tmp267 = (unsigned long )(units) + __cil_tmp266;
      __cil_tmp268 = *((struct vmw_display_unit **)__cil_tmp267);
      __cil_tmp269 = (unsigned long )__cil_tmp268;
      __cil_tmp270 = __cil_tmp269 + __cil_tmp265;
      __cil_tmp271 = *((int *)__cil_tmp270);
      if (clip_x1 >= __cil_tmp271) {
        goto __Cont___0;
      } else {
        __cil_tmp272 = 136;
        __cil_tmp273 = __cil_tmp272;
        __cil_tmp274 = (unsigned long )i * 8UL;
        __cil_tmp275 = (unsigned long )(units) + __cil_tmp274;
        __cil_tmp276 = *((struct vmw_display_unit **)__cil_tmp275);
        __cil_tmp277 = (unsigned long )__cil_tmp276;
        __cil_tmp278 = __cil_tmp277 + __cil_tmp273;
        __cil_tmp279 = *((int *)__cil_tmp278);
        if (clip_y1 >= __cil_tmp279) {
          goto __Cont___0;
        } else
        if (clip_x2 <= 0) {
          goto __Cont___0;
        } else
        if (clip_y2 <= 0) {
          goto __Cont___0;
        }
      }
      __cil_tmp280 = blits + blits_pos;
      *((uint32_t *)__cil_tmp280) = (uint32_t )38;
      __cil_tmp281 = 28;
      __cil_tmp282 = blits + blits_pos;
      __cil_tmp283 = (unsigned long )__cil_tmp282;
      __cil_tmp284 = __cil_tmp283 + __cil_tmp281;
      __cil_tmp285 = (unsigned long )i * 8UL;
      __cil_tmp286 = (unsigned long )(units) + __cil_tmp285;
      __cil_tmp287 = *((struct vmw_display_unit **)__cil_tmp286);
      __cil_tmp288 = (unsigned long )__cil_tmp287;
      __cil_tmp289 = __cil_tmp288 + 2032UL;
      *((uint32 *)__cil_tmp284) = *((unsigned int *)__cil_tmp289);
      __cil_tmp290 = blits + blits_pos;
      __cil_tmp291 = (unsigned long )__cil_tmp290;
      __cil_tmp292 = __cil_tmp291 + 4UL;
      *((int32 *)__cil_tmp292) = dest_x;
      __cil_tmp293 = 4;
      __cil_tmp294 = 4UL + __cil_tmp293;
      __cil_tmp295 = blits + blits_pos;
      __cil_tmp296 = (unsigned long )__cil_tmp295;
      __cil_tmp297 = __cil_tmp296 + __cil_tmp294;
      *((int32 *)__cil_tmp297) = dest_y;
      __cil_tmp298 = 12;
      __cil_tmp299 = blits + blits_pos;
      __cil_tmp300 = (unsigned long )__cil_tmp299;
      __cil_tmp301 = __cil_tmp300 + __cil_tmp298;
      *((int32 *)__cil_tmp301) = clip_x1;
      __cil_tmp302 = 12;
      __cil_tmp303 = 4UL + __cil_tmp302;
      __cil_tmp304 = blits + blits_pos;
      __cil_tmp305 = (unsigned long )__cil_tmp304;
      __cil_tmp306 = __cil_tmp305 + __cil_tmp303;
      *((int32 *)__cil_tmp306) = clip_y1;
      __cil_tmp307 = 16;
      __cil_tmp308 = 4UL + __cil_tmp307;
      __cil_tmp309 = blits + blits_pos;
      __cil_tmp310 = (unsigned long )__cil_tmp309;
      __cil_tmp311 = __cil_tmp310 + __cil_tmp308;
      *((int32 *)__cil_tmp311) = clip_x2;
      __cil_tmp312 = 20;
      __cil_tmp313 = 4UL + __cil_tmp312;
      __cil_tmp314 = blits + blits_pos;
      __cil_tmp315 = (unsigned long )__cil_tmp314;
      __cil_tmp316 = __cil_tmp315 + __cil_tmp313;
      *((int32 *)__cil_tmp316) = clip_y2;
      blits_pos ++;
      __Cont___0: 
      k ++;
      c ++;
    }
    while_break___7: 
    i ++;
  }
  while_break___6: 
  __cil_tmp317 = (unsigned long )blits_pos;
  __cil_tmp318 = 32UL * __cil_tmp317;
  fifo_size = 20UL + __cil_tmp318;
  __cil_tmp319 = (void *)0;
  __cil_tmp320 = (void *)cmd;
  __cil_tmp321 = (uint32_t )fifo_size;
  __cil_tmp322 = (uint64_t )0;
  __cil_tmp323 = (void *)0;
  __cil_tmp324 = (struct vmw_fence_obj **)__cil_tmp323;
  ret = vmw_execbuf_process(file_priv, dev_priv, __cil_tmp319, __cil_tmp320, __cil_tmp321,
                            __cil_tmp322, user_fence_rep, __cil_tmp324);
  __cil_tmp325 = (void *)cmd;
  kfree(__cil_tmp325);
  return (ret);
}
}
int vmw_kms_init(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int ret ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp5);
  drm_mode_config_init(dev);
  __cil_tmp6 = 1496;
  __cil_tmp7 = (unsigned long )dev;
  __cil_tmp8 = __cil_tmp7 + __cil_tmp6;
  *((struct drm_mode_config_funcs **)__cil_tmp8) = & vmw_kms_funcs;
  __cil_tmp9 = 1480;
  __cil_tmp10 = (unsigned long )dev;
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
  *((int *)__cil_tmp11) = 1;
  __cil_tmp12 = 1484;
  __cil_tmp13 = (unsigned long )dev;
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
  *((int *)__cil_tmp14) = 1;
  __cil_tmp15 = 1488;
  __cil_tmp16 = (unsigned long )dev;
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
  *((int *)__cil_tmp17) = 8192;
  __cil_tmp18 = 1492;
  __cil_tmp19 = (unsigned long )dev;
  __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
  *((int *)__cil_tmp20) = 8192;
  ret = vmw_kms_init_screen_object_display(dev_priv);
  if (ret) {
    vmw_kms_init_legacy_display_system(dev_priv);
  }
  return (0);
}
}
int vmw_kms_close(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct drm_device *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  __cil_tmp2 = (unsigned long )dev_priv;
  __cil_tmp3 = __cil_tmp2 + 2088UL;
  __cil_tmp4 = *((struct drm_device **)__cil_tmp3);
  drm_mode_config_cleanup(__cil_tmp4);
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2616UL;
  if (*((struct vmw_screen_object_display **)__cil_tmp6)) {
    vmw_kms_close_screen_object_display(dev_priv);
  } else {
    vmw_kms_close_legacy_display_system(dev_priv);
  }
  return (0);
}
}
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_cursor_bypass_arg *arg ;
  struct vmw_display_unit *du ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  int ret ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct drm_crtc *__mptr___1 ;
  struct drm_mode_object *__mptr___2 ;
  struct drm_crtc *__mptr___3 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct mutex *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct drm_crtc *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_display_unit *__cil_tmp38 ;
  struct drm_crtc *__cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct list_head *__cil_tmp53 ;
  struct drm_crtc *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct mutex *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  struct drm_crtc *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct drm_mode_object *__cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  struct vmw_display_unit *__cil_tmp74 ;
  struct drm_crtc *__cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct mutex *__cil_tmp89 ;

  {
  arg = (struct drm_vmw_cursor_bypass_arg *)data;
  ret = 0;
  __cil_tmp14 = (unsigned long )dev;
  __cil_tmp15 = __cil_tmp14 + 1152UL;
  __cil_tmp16 = (struct mutex *)__cil_tmp15;
  mutex_lock(__cil_tmp16);
  __cil_tmp17 = *((uint32_t *)arg);
  if (__cil_tmp17 & 1U) {
    __cil_tmp18 = 1448;
    __cil_tmp19 = (unsigned long )dev;
    __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
    __cil_tmp21 = *((struct list_head **)__cil_tmp20);
    __mptr = __cil_tmp21;
    __cil_tmp22 = (struct drm_crtc *)0;
    __cil_tmp23 = (unsigned long )__cil_tmp22;
    __cil_tmp24 = __cil_tmp23 + 8UL;
    __cil_tmp25 = (struct list_head *)__cil_tmp24;
    __cil_tmp26 = (unsigned int )__cil_tmp25;
    __cil_tmp27 = (char *)__mptr;
    __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
    crtc = (struct drm_crtc *)__cil_tmp28;
    while (1) {
      __cil_tmp29 = 1448;
      __cil_tmp30 = (unsigned long )dev;
      __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
      __cil_tmp32 = (struct list_head *)__cil_tmp31;
      __cil_tmp33 = (unsigned long )__cil_tmp32;
      __cil_tmp34 = (unsigned long )crtc;
      __cil_tmp35 = __cil_tmp34 + 8UL;
      __cil_tmp36 = (struct list_head *)__cil_tmp35;
      __cil_tmp37 = (unsigned long )__cil_tmp36;
      if (! (__cil_tmp37 != __cil_tmp33)) {
        goto while_break;
      }
      __mptr___1 = crtc;
      __cil_tmp38 = (struct vmw_display_unit *)0;
      __cil_tmp39 = (struct drm_crtc *)__cil_tmp38;
      __cil_tmp40 = (unsigned int )__cil_tmp39;
      __cil_tmp41 = (char *)__mptr___1;
      __cil_tmp42 = __cil_tmp41 - __cil_tmp40;
      du = (struct vmw_display_unit *)__cil_tmp42;
      __cil_tmp43 = (unsigned long )du;
      __cil_tmp44 = __cil_tmp43 + 2024UL;
      __cil_tmp45 = (unsigned long )arg;
      __cil_tmp46 = __cil_tmp45 + 16UL;
      *((int *)__cil_tmp44) = *((int32_t *)__cil_tmp46);
      __cil_tmp47 = (unsigned long )du;
      __cil_tmp48 = __cil_tmp47 + 2028UL;
      __cil_tmp49 = (unsigned long )arg;
      __cil_tmp50 = __cil_tmp49 + 20UL;
      *((int *)__cil_tmp48) = *((int32_t *)__cil_tmp50);
      __cil_tmp51 = (unsigned long )crtc;
      __cil_tmp52 = __cil_tmp51 + 8UL;
      __cil_tmp53 = *((struct list_head **)__cil_tmp52);
      __mptr___0 = __cil_tmp53;
      __cil_tmp54 = (struct drm_crtc *)0;
      __cil_tmp55 = (unsigned long )__cil_tmp54;
      __cil_tmp56 = __cil_tmp55 + 8UL;
      __cil_tmp57 = (struct list_head *)__cil_tmp56;
      __cil_tmp58 = (unsigned int )__cil_tmp57;
      __cil_tmp59 = (char *)__mptr___0;
      __cil_tmp60 = __cil_tmp59 - __cil_tmp58;
      crtc = (struct drm_crtc *)__cil_tmp60;
    }
    while_break: 
    __cil_tmp61 = (unsigned long )dev;
    __cil_tmp62 = __cil_tmp61 + 1152UL;
    __cil_tmp63 = (struct mutex *)__cil_tmp62;
    mutex_unlock(__cil_tmp63);
    return (0);
  }
  __cil_tmp64 = (unsigned long )arg;
  __cil_tmp65 = __cil_tmp64 + 4UL;
  __cil_tmp66 = *((uint32_t *)__cil_tmp65);
  obj = drm_mode_object_find(dev, __cil_tmp66, 3435973836U);
  if (! obj) {
    ret = -22;
    goto out;
  }
  __mptr___2 = obj;
  __cil_tmp67 = (struct drm_crtc *)0;
  __cil_tmp68 = (unsigned long )__cil_tmp67;
  __cil_tmp69 = __cil_tmp68 + 24UL;
  __cil_tmp70 = (struct drm_mode_object *)__cil_tmp69;
  __cil_tmp71 = (unsigned int )__cil_tmp70;
  __cil_tmp72 = (char *)__mptr___2;
  __cil_tmp73 = __cil_tmp72 - __cil_tmp71;
  crtc = (struct drm_crtc *)__cil_tmp73;
  __mptr___3 = crtc;
  __cil_tmp74 = (struct vmw_display_unit *)0;
  __cil_tmp75 = (struct drm_crtc *)__cil_tmp74;
  __cil_tmp76 = (unsigned int )__cil_tmp75;
  __cil_tmp77 = (char *)__mptr___3;
  __cil_tmp78 = __cil_tmp77 - __cil_tmp76;
  du = (struct vmw_display_unit *)__cil_tmp78;
  __cil_tmp79 = (unsigned long )du;
  __cil_tmp80 = __cil_tmp79 + 2024UL;
  __cil_tmp81 = (unsigned long )arg;
  __cil_tmp82 = __cil_tmp81 + 16UL;
  *((int *)__cil_tmp80) = *((int32_t *)__cil_tmp82);
  __cil_tmp83 = (unsigned long )du;
  __cil_tmp84 = __cil_tmp83 + 2028UL;
  __cil_tmp85 = (unsigned long )arg;
  __cil_tmp86 = __cil_tmp85 + 20UL;
  *((int *)__cil_tmp84) = *((int32_t *)__cil_tmp86);
  out: 
  __cil_tmp87 = (unsigned long )dev;
  __cil_tmp88 = __cil_tmp87 + 1152UL;
  __cil_tmp89 = (struct mutex *)__cil_tmp88;
  mutex_unlock(__cil_tmp89);
  return (ret);
}
}
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) 
{ bool tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  __cil_tmp10 = (unsigned long )vmw_priv___0;
  __cil_tmp11 = __cil_tmp10 + 2156UL;
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
  if (__cil_tmp12 & 131072U) {
    vmw_write(vmw_priv___0, 32U, pitch);
  } else {
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    if (tmp___7) {
      __cil_tmp13 = (unsigned long )vmw_priv___0;
      __cil_tmp14 = __cil_tmp13 + 2144UL;
      __cil_tmp15 = *((__le32 **)__cil_tmp14);
      __cil_tmp16 = __cil_tmp15 + 8;
      __cil_tmp17 = (void *)__cil_tmp16;
      iowrite32(pitch, __cil_tmp17);
    }
  }
  vmw_write(vmw_priv___0, 2U, width);
  vmw_write(vmw_priv___0, 3U, height);
  vmw_write(vmw_priv___0, 7U, bpp);
  tmp___9 = vmw_read(vmw_priv___0, 6U);
  if (tmp___9 != depth) {
    tmp___8 = vmw_read(vmw_priv___0, 6U);
    drm_err("vmw_kms_write_svga", "Invalid depth %u for %u bpp, host expects %u\n",
            depth, bpp, tmp___8);
    return (-22);
  }
  return (0);
}
}
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  uint32_t __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32_t __cil_tmp69 ;

  {
  __cil_tmp5 = (unsigned long )vmw_priv___0;
  __cil_tmp6 = __cil_tmp5 + 2576UL;
  *((uint32_t *)__cil_tmp6) = vmw_read(vmw_priv___0, 2U);
  __cil_tmp7 = (unsigned long )vmw_priv___0;
  __cil_tmp8 = __cil_tmp7 + 2580UL;
  *((uint32_t *)__cil_tmp8) = vmw_read(vmw_priv___0, 3U);
  __cil_tmp9 = (unsigned long )vmw_priv___0;
  __cil_tmp10 = __cil_tmp9 + 2584UL;
  *((uint32_t *)__cil_tmp10) = vmw_read(vmw_priv___0, 7U);
  __cil_tmp11 = (unsigned long )vmw_priv___0;
  __cil_tmp12 = __cil_tmp11 + 2156UL;
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
  if (__cil_tmp13 & 131072U) {
    __cil_tmp14 = (unsigned long )vmw_priv___0;
    __cil_tmp15 = __cil_tmp14 + 2592UL;
    *((uint32_t *)__cil_tmp15) = vmw_read(vmw_priv___0, 32U);
  } else {
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    if (tmp___7) {
      __cil_tmp16 = (unsigned long )vmw_priv___0;
      __cil_tmp17 = __cil_tmp16 + 2592UL;
      __cil_tmp18 = (unsigned long )vmw_priv___0;
      __cil_tmp19 = __cil_tmp18 + 2144UL;
      __cil_tmp20 = *((__le32 **)__cil_tmp19);
      __cil_tmp21 = __cil_tmp20 + 8;
      __cil_tmp22 = (void *)__cil_tmp21;
      *((uint32_t *)__cil_tmp17) = ioread32(__cil_tmp22);
    }
  }
  __cil_tmp23 = (unsigned long )vmw_priv___0;
  __cil_tmp24 = __cil_tmp23 + 2156UL;
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
  __cil_tmp26 = __cil_tmp25 & 524288U;
  if (! __cil_tmp26) {
    return (0);
  }
  __cil_tmp27 = (unsigned long )vmw_priv___0;
  __cil_tmp28 = __cil_tmp27 + 2596UL;
  *((uint32_t *)__cil_tmp28) = vmw_read(vmw_priv___0, 34U);
  __cil_tmp29 = (unsigned long )vmw_priv___0;
  __cil_tmp30 = __cil_tmp29 + 2596UL;
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
  if (__cil_tmp31 == 0U) {
    __cil_tmp32 = (unsigned long )vmw_priv___0;
    __cil_tmp33 = __cil_tmp32 + 2596UL;
    *((uint32_t *)__cil_tmp33) = (uint32_t )1;
  }
  i = (uint32_t )0;
  while (1) {
    __cil_tmp34 = (unsigned long )vmw_priv___0;
    __cil_tmp35 = __cil_tmp34 + 2596UL;
    __cil_tmp36 = *((uint32_t *)__cil_tmp35);
    if (! (i < __cil_tmp36)) {
      goto while_break;
    }
    __cil_tmp37 = (unsigned long )i * 20UL;
    __cil_tmp38 = 2256UL + __cil_tmp37;
    __cil_tmp39 = (unsigned long )vmw_priv___0;
    __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
    save = (struct vmw_vga_topology_state *)__cil_tmp40;
    vmw_write(vmw_priv___0, 35U, i);
    __cil_tmp41 = (unsigned long )save;
    __cil_tmp42 = __cil_tmp41 + 8UL;
    *((uint32_t *)__cil_tmp42) = vmw_read(vmw_priv___0, 36U);
    __cil_tmp43 = (unsigned long )save;
    __cil_tmp44 = __cil_tmp43 + 12UL;
    *((uint32_t *)__cil_tmp44) = vmw_read(vmw_priv___0, 37U);
    __cil_tmp45 = (unsigned long )save;
    __cil_tmp46 = __cil_tmp45 + 16UL;
    *((uint32_t *)__cil_tmp46) = vmw_read(vmw_priv___0, 38U);
    *((uint32_t *)save) = vmw_read(vmw_priv___0, 39U);
    __cil_tmp47 = (unsigned long )save;
    __cil_tmp48 = __cil_tmp47 + 4UL;
    *((uint32_t *)__cil_tmp48) = vmw_read(vmw_priv___0, 40U);
    vmw_write(vmw_priv___0, 35U, 4294967295U);
    if (i == 0U) {
      __cil_tmp49 = (unsigned long )vmw_priv___0;
      __cil_tmp50 = __cil_tmp49 + 2596UL;
      __cil_tmp51 = *((uint32_t *)__cil_tmp50);
      if (__cil_tmp51 == 1U) {
        __cil_tmp52 = *((uint32_t *)save);
        if (__cil_tmp52 == 0U) {
          __cil_tmp53 = (unsigned long )save;
          __cil_tmp54 = __cil_tmp53 + 4UL;
          __cil_tmp55 = *((uint32_t *)__cil_tmp54);
          if (__cil_tmp55 == 0U) {
            __cil_tmp56 = (unsigned long )save;
            __cil_tmp57 = __cil_tmp56 + 12UL;
            __cil_tmp58 = *((uint32_t *)__cil_tmp57);
            __cil_tmp59 = (unsigned long )vmw_priv___0;
            __cil_tmp60 = __cil_tmp59 + 2576UL;
            __cil_tmp61 = *((uint32_t *)__cil_tmp60);
            *((uint32_t *)save) = __cil_tmp61 - __cil_tmp58;
            __cil_tmp62 = (unsigned long )save;
            __cil_tmp63 = __cil_tmp62 + 4UL;
            __cil_tmp64 = (unsigned long )save;
            __cil_tmp65 = __cil_tmp64 + 16UL;
            __cil_tmp66 = *((uint32_t *)__cil_tmp65);
            __cil_tmp67 = (unsigned long )vmw_priv___0;
            __cil_tmp68 = __cil_tmp67 + 2580UL;
            __cil_tmp69 = *((uint32_t *)__cil_tmp68);
            *((uint32_t *)__cil_tmp63) = __cil_tmp69 - __cil_tmp66;
          }
        }
      }
    }
    i ++;
  }
  while_break: ;
  return (0);
}
}
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  __le32 *__cil_tmp25 ;
  __le32 *__cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;

  {
  __cil_tmp5 = (unsigned long )vmw_priv___0;
  __cil_tmp6 = __cil_tmp5 + 2576UL;
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
  vmw_write(vmw_priv___0, 2U, __cil_tmp7);
  __cil_tmp8 = (unsigned long )vmw_priv___0;
  __cil_tmp9 = __cil_tmp8 + 2580UL;
  __cil_tmp10 = *((uint32_t *)__cil_tmp9);
  vmw_write(vmw_priv___0, 3U, __cil_tmp10);
  __cil_tmp11 = (unsigned long )vmw_priv___0;
  __cil_tmp12 = __cil_tmp11 + 2584UL;
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
  vmw_write(vmw_priv___0, 7U, __cil_tmp13);
  __cil_tmp14 = (unsigned long )vmw_priv___0;
  __cil_tmp15 = __cil_tmp14 + 2156UL;
  __cil_tmp16 = *((uint32_t *)__cil_tmp15);
  if (__cil_tmp16 & 131072U) {
    __cil_tmp17 = (unsigned long )vmw_priv___0;
    __cil_tmp18 = __cil_tmp17 + 2592UL;
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
    vmw_write(vmw_priv___0, 32U, __cil_tmp19);
  } else {
    tmp___7 = vmw_fifo_have_pitchlock(vmw_priv___0);
    if (tmp___7) {
      __cil_tmp20 = (unsigned long )vmw_priv___0;
      __cil_tmp21 = __cil_tmp20 + 2592UL;
      __cil_tmp22 = *((uint32_t *)__cil_tmp21);
      __cil_tmp23 = (unsigned long )vmw_priv___0;
      __cil_tmp24 = __cil_tmp23 + 2144UL;
      __cil_tmp25 = *((__le32 **)__cil_tmp24);
      __cil_tmp26 = __cil_tmp25 + 8;
      __cil_tmp27 = (void *)__cil_tmp26;
      iowrite32(__cil_tmp22, __cil_tmp27);
    }
  }
  __cil_tmp28 = (unsigned long )vmw_priv___0;
  __cil_tmp29 = __cil_tmp28 + 2156UL;
  __cil_tmp30 = *((uint32_t *)__cil_tmp29);
  __cil_tmp31 = __cil_tmp30 & 524288U;
  if (! __cil_tmp31) {
    return (0);
  }
  i = (uint32_t )0;
  while (1) {
    __cil_tmp32 = (unsigned long )vmw_priv___0;
    __cil_tmp33 = __cil_tmp32 + 2596UL;
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
    if (! (i < __cil_tmp34)) {
      goto while_break;
    }
    __cil_tmp35 = (unsigned long )i * 20UL;
    __cil_tmp36 = 2256UL + __cil_tmp35;
    __cil_tmp37 = (unsigned long )vmw_priv___0;
    __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
    save = (struct vmw_vga_topology_state *)__cil_tmp38;
    vmw_write(vmw_priv___0, 35U, i);
    __cil_tmp39 = (unsigned long )save;
    __cil_tmp40 = __cil_tmp39 + 8UL;
    __cil_tmp41 = *((uint32_t *)__cil_tmp40);
    vmw_write(vmw_priv___0, 36U, __cil_tmp41);
    __cil_tmp42 = (unsigned long )save;
    __cil_tmp43 = __cil_tmp42 + 12UL;
    __cil_tmp44 = *((uint32_t *)__cil_tmp43);
    vmw_write(vmw_priv___0, 37U, __cil_tmp44);
    __cil_tmp45 = (unsigned long )save;
    __cil_tmp46 = __cil_tmp45 + 16UL;
    __cil_tmp47 = *((uint32_t *)__cil_tmp46);
    vmw_write(vmw_priv___0, 38U, __cil_tmp47);
    __cil_tmp48 = *((uint32_t *)save);
    vmw_write(vmw_priv___0, 39U, __cil_tmp48);
    __cil_tmp49 = (unsigned long )save;
    __cil_tmp50 = __cil_tmp49 + 4UL;
    __cil_tmp51 = *((uint32_t *)__cil_tmp50);
    vmw_write(vmw_priv___0, 40U, __cil_tmp51);
    vmw_write(vmw_priv___0, 35U, 4294967295U);
    i ++;
  }
  while_break: ;
  return (0);
}
}
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  u64 __cil_tmp7 ;
  u64 __cil_tmp8 ;
  u64 __cil_tmp9 ;
  u64 __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2112UL;
  __cil_tmp6 = *((uint32_t *)__cil_tmp5);
  __cil_tmp7 = (u64 )__cil_tmp6;
  __cil_tmp8 = (u64 )height;
  __cil_tmp9 = (u64 )pitch;
  __cil_tmp10 = __cil_tmp9 * __cil_tmp8;
  __cil_tmp11 = __cil_tmp10 < __cil_tmp7;
  return ((bool )__cil_tmp11);
}
}
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) 
{ 

  {
  return ((u32 )0);
}
}
int vmw_enable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
  return (-38);
}
}
void vmw_disable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
  return;
}
}
int vmw_du_update_layout(struct vmw_private *dev_priv , unsigned int num , struct drm_vmw_rect *rects ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_connector *con ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct drm_connector *__mptr___1 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct drm_connector *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct vmw_display_unit *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct drm_connector *__cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  struct drm_vmw_rect *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  struct drm_vmw_rect *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  struct drm_vmw_rect *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  struct drm_vmw_rect *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  bool __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct list_head *__cil_tmp88 ;
  struct drm_connector *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct list_head *__cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct mutex *__cil_tmp98 ;

  {
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp11);
  __cil_tmp12 = (unsigned long )dev;
  __cil_tmp13 = __cil_tmp12 + 1152UL;
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
  mutex_lock(__cil_tmp14);
  __cil_tmp15 = 1376;
  __cil_tmp16 = (unsigned long )dev;
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
  __cil_tmp18 = *((struct list_head **)__cil_tmp17);
  __mptr = __cil_tmp18;
  __cil_tmp19 = (struct drm_connector *)0;
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = __cil_tmp20 + 784UL;
  __cil_tmp22 = (struct list_head *)__cil_tmp21;
  __cil_tmp23 = (unsigned int )__cil_tmp22;
  __cil_tmp24 = (char *)__mptr;
  __cil_tmp25 = __cil_tmp24 - __cil_tmp23;
  con = (struct drm_connector *)__cil_tmp25;
  while (1) {
    __cil_tmp26 = 1376;
    __cil_tmp27 = (unsigned long )dev;
    __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
    __cil_tmp30 = (unsigned long )__cil_tmp29;
    __cil_tmp31 = (unsigned long )con;
    __cil_tmp32 = __cil_tmp31 + 784UL;
    __cil_tmp33 = (struct list_head *)__cil_tmp32;
    __cil_tmp34 = (unsigned long )__cil_tmp33;
    if (! (__cil_tmp34 != __cil_tmp30)) {
      goto while_break;
    }
    __mptr___1 = con;
    __cil_tmp35 = (struct vmw_display_unit *)0;
    __cil_tmp36 = (unsigned long )__cil_tmp35;
    __cil_tmp37 = __cil_tmp36 + 616UL;
    __cil_tmp38 = (struct drm_connector *)__cil_tmp37;
    __cil_tmp39 = (unsigned int )__cil_tmp38;
    __cil_tmp40 = (char *)__mptr___1;
    __cil_tmp41 = __cil_tmp40 - __cil_tmp39;
    du = (struct vmw_display_unit *)__cil_tmp41;
    __cil_tmp42 = (unsigned long )du;
    __cil_tmp43 = __cil_tmp42 + 2032UL;
    __cil_tmp44 = *((unsigned int *)__cil_tmp43);
    if (num > __cil_tmp44) {
      __cil_tmp45 = (unsigned long )du;
      __cil_tmp46 = __cil_tmp45 + 2036UL;
      __cil_tmp47 = (unsigned long )du;
      __cil_tmp48 = __cil_tmp47 + 2032UL;
      __cil_tmp49 = *((unsigned int *)__cil_tmp48);
      __cil_tmp50 = rects + __cil_tmp49;
      __cil_tmp51 = (unsigned long )__cil_tmp50;
      __cil_tmp52 = __cil_tmp51 + 8UL;
      *((unsigned int *)__cil_tmp46) = *((uint32_t *)__cil_tmp52);
      __cil_tmp53 = (unsigned long )du;
      __cil_tmp54 = __cil_tmp53 + 2040UL;
      __cil_tmp55 = (unsigned long )du;
      __cil_tmp56 = __cil_tmp55 + 2032UL;
      __cil_tmp57 = *((unsigned int *)__cil_tmp56);
      __cil_tmp58 = rects + __cil_tmp57;
      __cil_tmp59 = (unsigned long )__cil_tmp58;
      __cil_tmp60 = __cil_tmp59 + 12UL;
      *((unsigned int *)__cil_tmp54) = *((uint32_t *)__cil_tmp60);
      __cil_tmp61 = (unsigned long )du;
      __cil_tmp62 = __cil_tmp61 + 2044UL;
      *((bool *)__cil_tmp62) = (bool )1;
      __cil_tmp63 = (unsigned long )du;
      __cil_tmp64 = __cil_tmp63 + 2056UL;
      __cil_tmp65 = (unsigned long )du;
      __cil_tmp66 = __cil_tmp65 + 2032UL;
      __cil_tmp67 = *((unsigned int *)__cil_tmp66);
      __cil_tmp68 = rects + __cil_tmp67;
      *((int *)__cil_tmp64) = *((int32_t *)__cil_tmp68);
      __cil_tmp69 = (unsigned long )du;
      __cil_tmp70 = __cil_tmp69 + 2060UL;
      __cil_tmp71 = (unsigned long )du;
      __cil_tmp72 = __cil_tmp71 + 2032UL;
      __cil_tmp73 = *((unsigned int *)__cil_tmp72);
      __cil_tmp74 = rects + __cil_tmp73;
      __cil_tmp75 = (unsigned long )__cil_tmp74;
      __cil_tmp76 = __cil_tmp75 + 4UL;
      *((int *)__cil_tmp70) = *((int32_t *)__cil_tmp76);
    } else {
      __cil_tmp77 = (unsigned long )du;
      __cil_tmp78 = __cil_tmp77 + 2036UL;
      *((unsigned int *)__cil_tmp78) = 800U;
      __cil_tmp79 = (unsigned long )du;
      __cil_tmp80 = __cil_tmp79 + 2040UL;
      *((unsigned int *)__cil_tmp80) = 600U;
      __cil_tmp81 = (unsigned long )du;
      __cil_tmp82 = __cil_tmp81 + 2044UL;
      *((bool *)__cil_tmp82) = (bool )0;
    }
    __cil_tmp83 = (unsigned long )con;
    __cil_tmp84 = __cil_tmp83 + 840UL;
    __cil_tmp85 = (bool )1;
    *((enum drm_connector_status *)__cil_tmp84) = vmw_du_connector_detect(con, __cil_tmp85);
    __cil_tmp86 = (unsigned long )con;
    __cil_tmp87 = __cil_tmp86 + 784UL;
    __cil_tmp88 = *((struct list_head **)__cil_tmp87);
    __mptr___0 = __cil_tmp88;
    __cil_tmp89 = (struct drm_connector *)0;
    __cil_tmp90 = (unsigned long )__cil_tmp89;
    __cil_tmp91 = __cil_tmp90 + 784UL;
    __cil_tmp92 = (struct list_head *)__cil_tmp91;
    __cil_tmp93 = (unsigned int )__cil_tmp92;
    __cil_tmp94 = (char *)__mptr___0;
    __cil_tmp95 = __cil_tmp94 - __cil_tmp93;
    con = (struct drm_connector *)__cil_tmp95;
  }
  while_break: 
  __cil_tmp96 = (unsigned long )dev;
  __cil_tmp97 = __cil_tmp96 + 1152UL;
  __cil_tmp98 = (struct mutex *)__cil_tmp97;
  mutex_unlock(__cil_tmp98);
  return (0);
}
}
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_framebuffer *old_fb ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *__mptr ;
  struct drm_file *file_priv ;
  struct vmw_fence_obj *fence ;
  struct drm_clip_rect clips ;
  int ret ;
  bool tmp___8 ;
  struct drm_crtc *__mptr___0 ;
  struct drm_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_framebuffer *__cil_tmp18 ;
  struct drm_framebuffer *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_fence_obj **__cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_screen_object_display *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct drm_clip_rect *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct vmw_fence_obj **__cil_tmp46 ;
  struct vmw_fence_obj *__cil_tmp47 ;
  struct vmw_fence_obj **__cil_tmp48 ;
  struct vmw_fence_obj *__cil_tmp49 ;
  struct drm_pending_event *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __u32 *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  __u32 *__cil_tmp58 ;
  bool __cil_tmp59 ;
  struct vmw_display_unit *__cil_tmp60 ;
  struct drm_crtc *__cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  struct vmw_display_unit *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;

  {
  __cil_tmp15 = *((struct drm_device **)crtc);
  tmp___7 = vmw_priv(__cil_tmp15);
  dev_priv = tmp___7;
  __cil_tmp16 = (unsigned long )crtc;
  __cil_tmp17 = __cil_tmp16 + 32UL;
  old_fb = *((struct drm_framebuffer **)__cil_tmp17);
  __mptr = fb;
  __cil_tmp18 = (struct vmw_framebuffer *)0;
  __cil_tmp19 = (struct drm_framebuffer *)__cil_tmp18;
  __cil_tmp20 = (unsigned int )__cil_tmp19;
  __cil_tmp21 = (char *)__mptr;
  __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
  vfb = (struct vmw_framebuffer *)__cil_tmp22;
  __cil_tmp23 = 24;
  __cil_tmp24 = (unsigned long )event;
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
  file_priv = *((struct drm_file **)__cil_tmp25);
  __cil_tmp26 = & fence;
  __cil_tmp27 = (void *)0;
  *__cil_tmp26 = (struct vmw_fence_obj *)__cil_tmp27;
  __cil_tmp28 = (unsigned long )dev_priv;
  __cil_tmp29 = __cil_tmp28 + 2616UL;
  __cil_tmp30 = *((struct vmw_screen_object_display **)__cil_tmp29);
  if (! __cil_tmp30) {
    return (-38);
  }
  tmp___8 = vmw_kms_screen_object_flippable(dev_priv, crtc);
  if (! tmp___8) {
    return (-22);
  }
  __cil_tmp31 = (unsigned long )crtc;
  __cil_tmp32 = __cil_tmp31 + 32UL;
  *((struct drm_framebuffer **)__cil_tmp32) = fb;
  __cil_tmp33 = (unsigned long )(& clips) + 2UL;
  *((unsigned short *)__cil_tmp33) = (unsigned short)0;
  __cil_tmp34 = & clips;
  __cil_tmp35 = (unsigned long )(& clips) + 2UL;
  *((unsigned short *)__cil_tmp34) = *((unsigned short *)__cil_tmp35);
  __cil_tmp36 = (unsigned long )(& clips) + 4UL;
  __cil_tmp37 = (unsigned long )fb;
  __cil_tmp38 = __cil_tmp37 + 72UL;
  __cil_tmp39 = *((unsigned int *)__cil_tmp38);
  *((unsigned short *)__cil_tmp36) = (unsigned short )__cil_tmp39;
  __cil_tmp40 = (unsigned long )(& clips) + 6UL;
  __cil_tmp41 = (unsigned long )fb;
  __cil_tmp42 = __cil_tmp41 + 76UL;
  __cil_tmp43 = *((unsigned int *)__cil_tmp42);
  *((unsigned short *)__cil_tmp40) = (unsigned short )__cil_tmp43;
  __cil_tmp44 = (unsigned long )vfb;
  __cil_tmp45 = __cil_tmp44 + 136UL;
  if (*((bool *)__cil_tmp45)) {
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  } else {
    ret = do_surface_dirty_sou(dev_priv, file_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  }
  if (ret != 0) {
    goto out_no_fence;
  }
  __cil_tmp46 = & fence;
  __cil_tmp47 = *__cil_tmp46;
  if (! __cil_tmp47) {
    ret = -22;
    goto out_no_fence;
  }
  __cil_tmp48 = & fence;
  __cil_tmp49 = *__cil_tmp48;
  __cil_tmp50 = (struct drm_pending_event *)event;
  __cil_tmp51 = 72;
  __cil_tmp52 = (unsigned long )event;
  __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
  __cil_tmp54 = (__u32 *)__cil_tmp53;
  __cil_tmp55 = 76;
  __cil_tmp56 = (unsigned long )event;
  __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
  __cil_tmp58 = (__u32 *)__cil_tmp57;
  __cil_tmp59 = (bool )1;
  ret = vmw_event_fence_action_queue(file_priv, __cil_tmp49, __cil_tmp50, __cil_tmp54,
                                     __cil_tmp58, __cil_tmp59);
  vmw_fence_obj_unreference(& fence);
  __mptr___0 = crtc;
  __cil_tmp60 = (struct vmw_display_unit *)0;
  __cil_tmp61 = (struct drm_crtc *)__cil_tmp60;
  __cil_tmp62 = (unsigned int )__cil_tmp61;
  __cil_tmp63 = (char *)__mptr___0;
  __cil_tmp64 = __cil_tmp63 - __cil_tmp62;
  __cil_tmp65 = (struct vmw_display_unit *)__cil_tmp64;
  __cil_tmp66 = (unsigned long )__cil_tmp65;
  __cil_tmp67 = __cil_tmp66 + 2064UL;
  if (*((bool *)__cil_tmp67)) {
    vmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);
  }
  return (ret);
  out_no_fence: 
  __cil_tmp68 = (unsigned long )crtc;
  __cil_tmp69 = __cil_tmp68 + 32UL;
  *((struct drm_framebuffer **)__cil_tmp69) = old_fb;
  return (ret);
}
}
void vmw_du_crtc_save(struct drm_crtc *crtc ) 
{ 

  {
  return;
}
}
void vmw_du_crtc_restore(struct drm_crtc *crtc ) 
{ 

  {
  return;
}
}
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  int i ;
  struct drm_device *__cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  u16 *__cil_tmp12 ;
  u16 __cil_tmp13 ;
  int __cil_tmp14 ;
  u16 *__cil_tmp15 ;
  u16 __cil_tmp16 ;
  int __cil_tmp17 ;
  u16 *__cil_tmp18 ;
  u16 __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  u16 *__cil_tmp24 ;
  u16 __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  u16 *__cil_tmp33 ;
  u16 __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  u16 *__cil_tmp42 ;
  u16 __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  uint32_t __cil_tmp46 ;

  {
  __cil_tmp10 = *((struct drm_device **)crtc);
  tmp___7 = vmw_priv(__cil_tmp10);
  dev_priv = tmp___7;
  i = 0;
  while (1) {
    __cil_tmp11 = (uint32_t )i;
    if (! (__cil_tmp11 < size)) {
      goto while_break;
    }
    while (1) {
      __cil_tmp12 = r + i;
      __cil_tmp13 = *__cil_tmp12;
      __cil_tmp14 = (int )__cil_tmp13;
      __cil_tmp15 = g + i;
      __cil_tmp16 = *__cil_tmp15;
      __cil_tmp17 = (int )__cil_tmp16;
      __cil_tmp18 = b + i;
      __cil_tmp19 = *__cil_tmp18;
      __cil_tmp20 = (int )__cil_tmp19;
      drm_ut_debug_printk(1U, "drm", "vmw_du_crtc_gamma_set", "%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n",
                          i, __cil_tmp14, __cil_tmp17, __cil_tmp20);
      goto while_break___0;
    }
    while_break___0: 
    __cil_tmp21 = i * 3;
    __cil_tmp22 = 1024 + __cil_tmp21;
    __cil_tmp23 = (unsigned int )__cil_tmp22;
    __cil_tmp24 = r + i;
    __cil_tmp25 = *__cil_tmp24;
    __cil_tmp26 = (int )__cil_tmp25;
    __cil_tmp27 = __cil_tmp26 >> 8;
    __cil_tmp28 = (uint32_t )__cil_tmp27;
    vmw_write(dev_priv, __cil_tmp23, __cil_tmp28);
    __cil_tmp29 = i * 3;
    __cil_tmp30 = 1024 + __cil_tmp29;
    __cil_tmp31 = __cil_tmp30 + 1;
    __cil_tmp32 = (unsigned int )__cil_tmp31;
    __cil_tmp33 = g + i;
    __cil_tmp34 = *__cil_tmp33;
    __cil_tmp35 = (int )__cil_tmp34;
    __cil_tmp36 = __cil_tmp35 >> 8;
    __cil_tmp37 = (uint32_t )__cil_tmp36;
    vmw_write(dev_priv, __cil_tmp32, __cil_tmp37);
    __cil_tmp38 = i * 3;
    __cil_tmp39 = 1024 + __cil_tmp38;
    __cil_tmp40 = __cil_tmp39 + 2;
    __cil_tmp41 = (unsigned int )__cil_tmp40;
    __cil_tmp42 = b + i;
    __cil_tmp43 = *__cil_tmp42;
    __cil_tmp44 = (int )__cil_tmp43;
    __cil_tmp45 = __cil_tmp44 >> 8;
    __cil_tmp46 = (uint32_t )__cil_tmp45;
    vmw_write(dev_priv, __cil_tmp41, __cil_tmp46);
    i ++;
  }
  while_break: ;
  return;
}
}
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) 
{ 

  {
  return;
}
}
void vmw_du_connector_save(struct drm_connector *connector ) 
{ 

  {
  return;
}
}
void vmw_du_connector_restore(struct drm_connector *connector ) 
{ 

  {
  return;
}
}
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) 
{ uint32_t num_displays ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_display_unit *du ;
  struct drm_connector *__mptr ;
  int tmp___8 ;
  struct drm_connector *__mptr___1 ;
  struct vmw_display_unit *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_connector *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct mutex *__cil_tmp24 ;
  struct vmw_display_unit *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct drm_connector *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  struct vmw_display_unit *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  dev = *((struct drm_device **)connector);
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __mptr = connector;
  __cil_tmp12 = (struct vmw_display_unit *)0;
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = __cil_tmp13 + 616UL;
  __cil_tmp15 = (struct drm_connector *)__cil_tmp14;
  __cil_tmp16 = (unsigned int )__cil_tmp15;
  __cil_tmp17 = (char *)__mptr;
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
  du = (struct vmw_display_unit *)__cil_tmp18;
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 2184UL;
  __cil_tmp21 = (struct mutex *)__cil_tmp20;
  mutex_lock(__cil_tmp21);
  num_displays = vmw_read(dev_priv, 31U);
  __cil_tmp22 = (unsigned long )dev_priv;
  __cil_tmp23 = __cil_tmp22 + 2184UL;
  __cil_tmp24 = (struct mutex *)__cil_tmp23;
  mutex_unlock(__cil_tmp24);
  __mptr___1 = connector;
  __cil_tmp25 = (struct vmw_display_unit *)0;
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  __cil_tmp27 = __cil_tmp26 + 616UL;
  __cil_tmp28 = (struct drm_connector *)__cil_tmp27;
  __cil_tmp29 = (unsigned int )__cil_tmp28;
  __cil_tmp30 = (char *)__mptr___1;
  __cil_tmp31 = __cil_tmp30 - __cil_tmp29;
  __cil_tmp32 = (struct vmw_display_unit *)__cil_tmp31;
  __cil_tmp33 = (unsigned long )__cil_tmp32;
  __cil_tmp34 = __cil_tmp33 + 2032UL;
  __cil_tmp35 = *((unsigned int *)__cil_tmp34);
  if (__cil_tmp35 < num_displays) {
    __cil_tmp36 = (unsigned long )du;
    __cil_tmp37 = __cil_tmp36 + 2044UL;
    if (*((bool *)__cil_tmp37)) {
      tmp___8 = 1;
    } else {
      tmp___8 = 2;
    }
  } else {
    tmp___8 = 2;
  }
  return ((enum drm_connector_status )tmp___8);
}
}
static struct drm_display_mode vmw_kms_connector_builtin[19]  = 
  {      {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'6', (char )'4',
                                                                 (char )'0', (char )'x',
                                                                 (char )'4', (char )'8',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 25175, 640, 656, 752, 800,
      0, 480, 489, 492, 525, 0, (unsigned int )((1 << 1) | (1 << 3)), 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'8', (char )'0',
                                                                 (char )'0', (char )'x',
                                                                 (char )'6', (char )'0',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 40000, 800, 840, 968, 1056,
      0, 600, 601, 605, 628, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'0',
                                                                 (char )'2', (char )'4',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806,
      0, (unsigned int )((1 << 1) | (1 << 3)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'1',
                                                                 (char )'5', (char )'2',
                                                                 (char )'x', (char )'8',
                                                                 (char )'6', (char )'4',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798,
      0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'8',
                                                                 (char )'0', (char )'0',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831,
      0, (unsigned int )(1 | (1 << 3)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'9',
                                                                 (char )'6', (char )'0',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'2',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'2',
                                                                 (char )'4', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 108000, 1280, 1328, 1440,
      1688, 0, 1024, 1025, 1028, 1066, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'3',
                                                                 (char )'6', (char )'0',
                                                                 (char )'x', (char )'7',
                                                                 (char )'6', (char )'8',
                                                                 (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795,
      0, (unsigned int )(1 | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'4',
                                                                 (char )'0', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'5',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 121750, 1400, 1488, 1632,
      1864, 0, 1050, 1053, 1057, 1089, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'4', (char )'4', (char )'0',
                                          (char )'x', (char )'9', (char )'0', (char )'0',
                                          (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934,
      0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'6',
                                                                 (char )'0', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'2', (char )'0',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 162000, 1600, 1664, 1856,
      2160, 0, 1200, 1201, 1204, 1250, 0, (unsigned int )(1 | (1 << 2)), 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'6',
                                                                 (char )'8', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'0', (char )'5',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 146250, 1680, 1784, 1960,
      2240, 0, 1050, 1053, 1059, 1089, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'7', (char )'9', (char )'2',
                                          (char )'x', (char )'1', (char )'3', (char )'4',
                                          (char )'4', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 204750, 1792, 1920, 2120, 2448, 0, 1344, 1345, 1348,
      1394, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'8',
                                                                 (char )'5', (char )'6',
                                                                 (char )'x', (char )'1',
                                                                 (char )'3', (char )'9',
                                                                 (char )'2', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 218250, 1856, 1952, 2176,
      2528, 0, 1392, 1393, 1396, 1439, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'9', (char )'2', (char )'0',
                                          (char )'x', (char )'1', (char )'2', (char )'0',
                                          (char )'0', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 193250, 1920, 2056, 2256, 2592, 0, 1200, 1203, 1209,
      1245, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'1', (char )'9',
                                                                 (char )'2', (char )'0',
                                                                 (char )'x', (char )'1',
                                                                 (char )'4', (char )'4',
                                                                 (char )'0', (char )'\000'},
      (enum drm_mode_status )0, (unsigned int )(1 << 6), 234000, 1920, 2048, 2256,
      2600, 0, 1440, 1441, 1444, 1500, 0, (unsigned int )((1 << 1) | (1 << 2)), 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0,
       (struct list_head *)0}, {0U, 0U}, {(char )'2', (char )'5', (char )'6', (char )'0',
                                          (char )'x', (char )'1', (char )'6', (char )'0',
                                          (char )'0', (char )'\000'}, (enum drm_mode_status )0,
      (unsigned int )(1 << 6), 348500, 2560, 2752, 3032, 3504, 0, 1600, 1603, 1609,
      1658, 0, (unsigned int )((1 << 1) | (1 << 2)), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}, 
        {{(struct list_head *)0, (struct list_head *)0}, {0U, 0U}, {(char )'\000'}, (enum drm_mode_status )0,
      0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, (int *)0, 0, 0, 0}};
static void vmw_guess_mode_timing(struct drm_display_mode *mode ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  u32 __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  u32 __cil_tmp41 ;
  u32 __cil_tmp42 ;
  u32 __cil_tmp43 ;
  u32 __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_display_mode *__cil_tmp47 ;

  {
  __cil_tmp2 = (unsigned long )mode;
  __cil_tmp3 = __cil_tmp2 + 72UL;
  __cil_tmp4 = (unsigned long )mode;
  __cil_tmp5 = __cil_tmp4 + 68UL;
  __cil_tmp6 = *((int *)__cil_tmp5);
  *((int *)__cil_tmp3) = __cil_tmp6 + 50;
  __cil_tmp7 = (unsigned long )mode;
  __cil_tmp8 = __cil_tmp7 + 76UL;
  __cil_tmp9 = (unsigned long )mode;
  __cil_tmp10 = __cil_tmp9 + 72UL;
  __cil_tmp11 = *((int *)__cil_tmp10);
  *((int *)__cil_tmp8) = __cil_tmp11 + 50;
  __cil_tmp12 = (unsigned long )mode;
  __cil_tmp13 = __cil_tmp12 + 80UL;
  __cil_tmp14 = (unsigned long )mode;
  __cil_tmp15 = __cil_tmp14 + 76UL;
  __cil_tmp16 = *((int *)__cil_tmp15);
  *((int *)__cil_tmp13) = __cil_tmp16 + 50;
  __cil_tmp17 = (unsigned long )mode;
  __cil_tmp18 = __cil_tmp17 + 92UL;
  __cil_tmp19 = (unsigned long )mode;
  __cil_tmp20 = __cil_tmp19 + 88UL;
  __cil_tmp21 = *((int *)__cil_tmp20);
  *((int *)__cil_tmp18) = __cil_tmp21 + 50;
  __cil_tmp22 = (unsigned long )mode;
  __cil_tmp23 = __cil_tmp22 + 96UL;
  __cil_tmp24 = (unsigned long )mode;
  __cil_tmp25 = __cil_tmp24 + 92UL;
  __cil_tmp26 = *((int *)__cil_tmp25);
  *((int *)__cil_tmp23) = __cil_tmp26 + 50;
  __cil_tmp27 = (unsigned long )mode;
  __cil_tmp28 = __cil_tmp27 + 100UL;
  __cil_tmp29 = (unsigned long )mode;
  __cil_tmp30 = __cil_tmp29 + 96UL;
  __cil_tmp31 = *((int *)__cil_tmp30);
  *((int *)__cil_tmp28) = __cil_tmp31 + 50;
  __cil_tmp32 = (unsigned long )mode;
  __cil_tmp33 = __cil_tmp32 + 64UL;
  __cil_tmp34 = (unsigned long )mode;
  __cil_tmp35 = __cil_tmp34 + 100UL;
  __cil_tmp36 = *((int *)__cil_tmp35);
  __cil_tmp37 = (u32 )__cil_tmp36;
  __cil_tmp38 = (unsigned long )mode;
  __cil_tmp39 = __cil_tmp38 + 80UL;
  __cil_tmp40 = *((int *)__cil_tmp39);
  __cil_tmp41 = (u32 )__cil_tmp40;
  __cil_tmp42 = __cil_tmp41 * __cil_tmp37;
  __cil_tmp43 = __cil_tmp42 / 100U;
  __cil_tmp44 = __cil_tmp43 * 6U;
  *((int *)__cil_tmp33) = (int )__cil_tmp44;
  __cil_tmp45 = (unsigned long )mode;
  __cil_tmp46 = __cil_tmp45 + 204UL;
  __cil_tmp47 = mode;
  *((int *)__cil_tmp46) = drm_mode_vrefresh(__cil_tmp47);
  return;
}
}
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) 
{ struct vmw_display_unit *du ;
  struct drm_connector *__mptr ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *bmode ;
  struct drm_display_mode prefmode ;
  int i ;
  bool tmp___8 ;
  bool tmp___9 ;
  struct vmw_display_unit *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_connector *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  void *__cil_tmp22 ;
  struct drm_display_mode *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  struct drm_display_mode *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  uint32_t __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  int __cil_tmp121 ;
  uint32_t __cil_tmp122 ;
  void *__cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  struct drm_display_mode *__cil_tmp128 ;
  struct list_head *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  struct drm_display_mode *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  int __cil_tmp143 ;
  uint32_t __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  int __cil_tmp147 ;
  uint32_t __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  uint32_t __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  int __cil_tmp156 ;
  uint32_t __cil_tmp157 ;
  struct drm_display_mode *__cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  struct drm_display_mode *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct drm_display_mode *__cil_tmp166 ;
  struct list_head *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  struct list_head *__cil_tmp170 ;

  {
  __mptr = connector;
  __cil_tmp15 = (struct vmw_display_unit *)0;
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  __cil_tmp17 = __cil_tmp16 + 616UL;
  __cil_tmp18 = (struct drm_connector *)__cil_tmp17;
  __cil_tmp19 = (unsigned int )__cil_tmp18;
  __cil_tmp20 = (char *)__mptr;
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
  du = (struct vmw_display_unit *)__cil_tmp21;
  dev = *((struct drm_device **)connector);
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp22 = (void *)0;
  mode = (struct drm_display_mode *)__cil_tmp22;
  __cil_tmp23 = & prefmode;
  *((struct list_head **)__cil_tmp23) = (struct list_head *)0;
  __cil_tmp24 = 8;
  __cil_tmp25 = (unsigned long )(& prefmode) + __cil_tmp24;
  *((struct list_head **)__cil_tmp25) = (struct list_head *)0;
  __cil_tmp26 = (unsigned long )(& prefmode) + 16UL;
  *((uint32_t *)__cil_tmp26) = 0U;
  __cil_tmp27 = 20;
  __cil_tmp28 = (unsigned long )(& prefmode) + __cil_tmp27;
  *((uint32_t *)__cil_tmp28) = 0U;
  __cil_tmp29 = 0UL;
  __cil_tmp30 = 24UL + __cil_tmp29;
  __cil_tmp31 = (unsigned long )(& prefmode) + __cil_tmp30;
  *((char *)__cil_tmp31) = (char )'p';
  __cil_tmp32 = 1UL;
  __cil_tmp33 = 24UL + __cil_tmp32;
  __cil_tmp34 = (unsigned long )(& prefmode) + __cil_tmp33;
  *((char *)__cil_tmp34) = (char )'r';
  __cil_tmp35 = 2UL;
  __cil_tmp36 = 24UL + __cil_tmp35;
  __cil_tmp37 = (unsigned long )(& prefmode) + __cil_tmp36;
  *((char *)__cil_tmp37) = (char )'e';
  __cil_tmp38 = 3UL;
  __cil_tmp39 = 24UL + __cil_tmp38;
  __cil_tmp40 = (unsigned long )(& prefmode) + __cil_tmp39;
  *((char *)__cil_tmp40) = (char )'f';
  __cil_tmp41 = 4UL;
  __cil_tmp42 = 24UL + __cil_tmp41;
  __cil_tmp43 = (unsigned long )(& prefmode) + __cil_tmp42;
  *((char *)__cil_tmp43) = (char )'e';
  __cil_tmp44 = 5UL;
  __cil_tmp45 = 24UL + __cil_tmp44;
  __cil_tmp46 = (unsigned long )(& prefmode) + __cil_tmp45;
  *((char *)__cil_tmp46) = (char )'r';
  __cil_tmp47 = 6UL;
  __cil_tmp48 = 24UL + __cil_tmp47;
  __cil_tmp49 = (unsigned long )(& prefmode) + __cil_tmp48;
  *((char *)__cil_tmp49) = (char )'r';
  __cil_tmp50 = 7UL;
  __cil_tmp51 = 24UL + __cil_tmp50;
  __cil_tmp52 = (unsigned long )(& prefmode) + __cil_tmp51;
  *((char *)__cil_tmp52) = (char )'e';
  __cil_tmp53 = 8UL;
  __cil_tmp54 = 24UL + __cil_tmp53;
  __cil_tmp55 = (unsigned long )(& prefmode) + __cil_tmp54;
  *((char *)__cil_tmp55) = (char )'d';
  __cil_tmp56 = 9UL;
  __cil_tmp57 = 24UL + __cil_tmp56;
  __cil_tmp58 = (unsigned long )(& prefmode) + __cil_tmp57;
  *((char *)__cil_tmp58) = (char )'\000';
  __cil_tmp59 = (unsigned long )(& prefmode) + 56UL;
  *((enum drm_mode_status *)__cil_tmp59) = (enum drm_mode_status )0;
  __cil_tmp60 = (unsigned long )(& prefmode) + 60UL;
  __cil_tmp61 = 1 << 3;
  __cil_tmp62 = 1 << 6;
  __cil_tmp63 = __cil_tmp62 | __cil_tmp61;
  *((unsigned int *)__cil_tmp60) = (unsigned int )__cil_tmp63;
  __cil_tmp64 = (unsigned long )(& prefmode) + 64UL;
  *((int *)__cil_tmp64) = 0;
  __cil_tmp65 = (unsigned long )(& prefmode) + 68UL;
  *((int *)__cil_tmp65) = 0;
  __cil_tmp66 = (unsigned long )(& prefmode) + 72UL;
  *((int *)__cil_tmp66) = 0;
  __cil_tmp67 = (unsigned long )(& prefmode) + 76UL;
  *((int *)__cil_tmp67) = 0;
  __cil_tmp68 = (unsigned long )(& prefmode) + 80UL;
  *((int *)__cil_tmp68) = 0;
  __cil_tmp69 = (unsigned long )(& prefmode) + 84UL;
  *((int *)__cil_tmp69) = 0;
  __cil_tmp70 = (unsigned long )(& prefmode) + 88UL;
  *((int *)__cil_tmp70) = 0;
  __cil_tmp71 = (unsigned long )(& prefmode) + 92UL;
  *((int *)__cil_tmp71) = 0;
  __cil_tmp72 = (unsigned long )(& prefmode) + 96UL;
  *((int *)__cil_tmp72) = 0;
  __cil_tmp73 = (unsigned long )(& prefmode) + 100UL;
  *((int *)__cil_tmp73) = 0;
  __cil_tmp74 = (unsigned long )(& prefmode) + 104UL;
  *((int *)__cil_tmp74) = 0;
  __cil_tmp75 = (unsigned long )(& prefmode) + 108UL;
  __cil_tmp76 = 1 << 2;
  __cil_tmp77 = 1 << 1;
  __cil_tmp78 = __cil_tmp77 | __cil_tmp76;
  *((unsigned int *)__cil_tmp75) = (unsigned int )__cil_tmp78;
  __cil_tmp79 = (unsigned long )(& prefmode) + 112UL;
  *((int *)__cil_tmp79) = 0;
  __cil_tmp80 = (unsigned long )(& prefmode) + 116UL;
  *((int *)__cil_tmp80) = 0;
  __cil_tmp81 = (unsigned long )(& prefmode) + 120UL;
  *((int *)__cil_tmp81) = 0;
  __cil_tmp82 = (unsigned long )(& prefmode) + 124UL;
  *((int *)__cil_tmp82) = 0;
  __cil_tmp83 = (unsigned long )(& prefmode) + 128UL;
  *((int *)__cil_tmp83) = 0;
  __cil_tmp84 = (unsigned long )(& prefmode) + 132UL;
  *((int *)__cil_tmp84) = 0;
  __cil_tmp85 = (unsigned long )(& prefmode) + 136UL;
  *((int *)__cil_tmp85) = 0;
  __cil_tmp86 = (unsigned long )(& prefmode) + 140UL;
  *((int *)__cil_tmp86) = 0;
  __cil_tmp87 = (unsigned long )(& prefmode) + 144UL;
  *((int *)__cil_tmp87) = 0;
  __cil_tmp88 = (unsigned long )(& prefmode) + 148UL;
  *((int *)__cil_tmp88) = 0;
  __cil_tmp89 = (unsigned long )(& prefmode) + 152UL;
  *((int *)__cil_tmp89) = 0;
  __cil_tmp90 = (unsigned long )(& prefmode) + 156UL;
  *((int *)__cil_tmp90) = 0;
  __cil_tmp91 = (unsigned long )(& prefmode) + 160UL;
  *((int *)__cil_tmp91) = 0;
  __cil_tmp92 = (unsigned long )(& prefmode) + 164UL;
  *((int *)__cil_tmp92) = 0;
  __cil_tmp93 = (unsigned long )(& prefmode) + 168UL;
  *((int *)__cil_tmp93) = 0;
  __cil_tmp94 = (unsigned long )(& prefmode) + 172UL;
  *((int *)__cil_tmp94) = 0;
  __cil_tmp95 = (unsigned long )(& prefmode) + 176UL;
  *((int *)__cil_tmp95) = 0;
  __cil_tmp96 = (unsigned long )(& prefmode) + 180UL;
  *((int *)__cil_tmp96) = 0;
  __cil_tmp97 = (unsigned long )(& prefmode) + 184UL;
  *((int *)__cil_tmp97) = 0;
  __cil_tmp98 = (unsigned long )(& prefmode) + 188UL;
  *((int *)__cil_tmp98) = 0;
  __cil_tmp99 = (unsigned long )(& prefmode) + 192UL;
  *((int **)__cil_tmp99) = (int *)0;
  __cil_tmp100 = (unsigned long )(& prefmode) + 200UL;
  *((int *)__cil_tmp100) = 0;
  __cil_tmp101 = (unsigned long )(& prefmode) + 204UL;
  *((int *)__cil_tmp101) = 0;
  __cil_tmp102 = (unsigned long )(& prefmode) + 208UL;
  *((int *)__cil_tmp102) = 0;
  __cil_tmp103 = & prefmode;
  mode = drm_mode_duplicate(dev, __cil_tmp103);
  if (! mode) {
    return (0);
  }
  __cil_tmp104 = (unsigned long )mode;
  __cil_tmp105 = __cil_tmp104 + 68UL;
  __cil_tmp106 = (unsigned long )du;
  __cil_tmp107 = __cil_tmp106 + 2036UL;
  __cil_tmp108 = *((unsigned int *)__cil_tmp107);
  *((int *)__cil_tmp105) = (int )__cil_tmp108;
  __cil_tmp109 = (unsigned long )mode;
  __cil_tmp110 = __cil_tmp109 + 88UL;
  __cil_tmp111 = (unsigned long )du;
  __cil_tmp112 = __cil_tmp111 + 2040UL;
  __cil_tmp113 = *((unsigned int *)__cil_tmp112);
  *((int *)__cil_tmp110) = (int )__cil_tmp113;
  vmw_guess_mode_timing(mode);
  __cil_tmp114 = (unsigned long )mode;
  __cil_tmp115 = __cil_tmp114 + 68UL;
  __cil_tmp116 = *((int *)__cil_tmp115);
  __cil_tmp117 = __cil_tmp116 * 2;
  __cil_tmp118 = (uint32_t )__cil_tmp117;
  __cil_tmp119 = (unsigned long )mode;
  __cil_tmp120 = __cil_tmp119 + 88UL;
  __cil_tmp121 = *((int *)__cil_tmp120);
  __cil_tmp122 = (uint32_t )__cil_tmp121;
  tmp___8 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp118, __cil_tmp122);
  if (tmp___8) {
    drm_mode_probed_add(connector, mode);
  } else {
    drm_mode_destroy(dev, mode);
    __cil_tmp123 = (void *)0;
    mode = (struct drm_display_mode *)__cil_tmp123;
  }
  __cil_tmp124 = (unsigned long )du;
  __cil_tmp125 = __cil_tmp124 + 2048UL;
  if (*((struct drm_display_mode **)__cil_tmp125)) {
    __cil_tmp126 = (unsigned long )du;
    __cil_tmp127 = __cil_tmp126 + 2048UL;
    __cil_tmp128 = *((struct drm_display_mode **)__cil_tmp127);
    __cil_tmp129 = (struct list_head *)__cil_tmp128;
    list_del_init(__cil_tmp129);
    __cil_tmp130 = (unsigned long )du;
    __cil_tmp131 = __cil_tmp130 + 2048UL;
    __cil_tmp132 = *((struct drm_display_mode **)__cil_tmp131);
    drm_mode_destroy(dev, __cil_tmp132);
  }
  __cil_tmp133 = (unsigned long )du;
  __cil_tmp134 = __cil_tmp133 + 2048UL;
  *((struct drm_display_mode **)__cil_tmp134) = mode;
  i = 0;
  while (1) {
    __cil_tmp135 = (unsigned long )i * 216UL;
    __cil_tmp136 = __cil_tmp135 + 60UL;
    __cil_tmp137 = (unsigned long )(vmw_kms_connector_builtin) + __cil_tmp136;
    __cil_tmp138 = *((unsigned int *)__cil_tmp137);
    if (! (__cil_tmp138 != 0U)) {
      goto while_break;
    }
    __cil_tmp139 = (unsigned long )i * 216UL;
    __cil_tmp140 = (unsigned long )(vmw_kms_connector_builtin) + __cil_tmp139;
    bmode = (struct drm_display_mode *)__cil_tmp140;
    __cil_tmp141 = (unsigned long )bmode;
    __cil_tmp142 = __cil_tmp141 + 68UL;
    __cil_tmp143 = *((int *)__cil_tmp142);
    __cil_tmp144 = (uint32_t )__cil_tmp143;
    if (__cil_tmp144 > max_width) {
      goto __Cont;
    } else {
      __cil_tmp145 = (unsigned long )bmode;
      __cil_tmp146 = __cil_tmp145 + 88UL;
      __cil_tmp147 = *((int *)__cil_tmp146);
      __cil_tmp148 = (uint32_t )__cil_tmp147;
      if (__cil_tmp148 > max_height) {
        goto __Cont;
      }
    }
    __cil_tmp149 = (unsigned long )bmode;
    __cil_tmp150 = __cil_tmp149 + 68UL;
    __cil_tmp151 = *((int *)__cil_tmp150);
    __cil_tmp152 = __cil_tmp151 * 2;
    __cil_tmp153 = (uint32_t )__cil_tmp152;
    __cil_tmp154 = (unsigned long )bmode;
    __cil_tmp155 = __cil_tmp154 + 88UL;
    __cil_tmp156 = *((int *)__cil_tmp155);
    __cil_tmp157 = (uint32_t )__cil_tmp156;
    tmp___9 = vmw_kms_validate_mode_vram(dev_priv, __cil_tmp153, __cil_tmp157);
    if (! tmp___9) {
      goto __Cont;
    }
    __cil_tmp158 = bmode;
    mode = drm_mode_duplicate(dev, __cil_tmp158);
    if (! mode) {
      return (0);
    }
    __cil_tmp159 = (unsigned long )mode;
    __cil_tmp160 = __cil_tmp159 + 204UL;
    __cil_tmp161 = mode;
    *((int *)__cil_tmp160) = drm_mode_vrefresh(__cil_tmp161);
    drm_mode_probed_add(connector, mode);
    __Cont: 
    i ++;
  }
  while_break: 
  __cil_tmp162 = (unsigned long )du;
  __cil_tmp163 = __cil_tmp162 + 2048UL;
  if (*((struct drm_display_mode **)__cil_tmp163)) {
    __cil_tmp164 = (unsigned long )du;
    __cil_tmp165 = __cil_tmp164 + 2048UL;
    __cil_tmp166 = *((struct drm_display_mode **)__cil_tmp165);
    __cil_tmp167 = (struct list_head *)__cil_tmp166;
    __cil_tmp168 = (unsigned long )connector;
    __cil_tmp169 = __cil_tmp168 + 848UL;
    __cil_tmp170 = (struct list_head *)__cil_tmp169;
    list_move(__cil_tmp167, __cil_tmp170);
  }
  drm_mode_connector_list_update(connector);
  return (1);
}
}
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) 
{ 

  {
  return (0);
}
}
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_update_layout_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  void *user_rects ;
  struct drm_vmw_rect *rects ;
  unsigned int rects_size ;
  int ret ;
  int i ;
  struct drm_mode_config *mode_config ;
  long tmp___9 ;
  struct drm_vmw_rect def_rect ;
  void *tmp___10 ;
  long tmp___11 ;
  unsigned long tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct drm_master *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct ttm_lock *__cil_tmp26 ;
  bool __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  struct drm_vmw_rect *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  size_t __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint64_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  struct drm_vmw_rect *__cil_tmp59 ;
  int32_t __cil_tmp60 ;
  struct drm_vmw_rect *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int32_t __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  struct drm_vmw_rect *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  struct drm_vmw_rect *__cil_tmp73 ;
  int32_t __cil_tmp74 ;
  uint32_t __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  int __cil_tmp79 ;
  uint32_t __cil_tmp80 ;
  struct drm_vmw_rect *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  struct drm_vmw_rect *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  int32_t __cil_tmp88 ;
  uint32_t __cil_tmp89 ;
  uint32_t __cil_tmp90 ;
  uint32_t __cil_tmp91 ;
  void *__cil_tmp92 ;
  struct ttm_lock *__cil_tmp93 ;
  unsigned long tmp ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_update_layout_arg *)data;
  __cil_tmp21 = (unsigned long )file_priv;
  __cil_tmp22 = __cil_tmp21 + 152UL;
  __cil_tmp23 = *((struct drm_master **)__cil_tmp22);
  tmp___8 = vmw_master(__cil_tmp23);
  vmaster = tmp___8;
  __cil_tmp24 = (unsigned long )dev;
  __cil_tmp25 = __cil_tmp24 + 1152UL;
  mode_config = (struct drm_mode_config *)__cil_tmp25;
  __cil_tmp26 = (struct ttm_lock *)vmaster;
  __cil_tmp27 = (bool )1;
  ret = ttm_read_lock(__cil_tmp26, __cil_tmp27);
  __cil_tmp28 = ret != 0;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___9 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___9) {
    return (ret);
  }
  __cil_tmp32 = *((uint32_t *)arg);
  if (! __cil_tmp32) {
    __cil_tmp33 = & def_rect;
    *((int32_t *)__cil_tmp33) = 0;
    __cil_tmp34 = (unsigned long )(& def_rect) + 4UL;
    *((int32_t *)__cil_tmp34) = 0;
    __cil_tmp35 = (unsigned long )(& def_rect) + 8UL;
    *((uint32_t *)__cil_tmp35) = (uint32_t )800;
    __cil_tmp36 = (unsigned long )(& def_rect) + 12UL;
    *((uint32_t *)__cil_tmp36) = (uint32_t )600;
    vmw_du_update_layout(dev_priv, 1U, & def_rect);
    goto out_unlock;
  }
  __cil_tmp37 = *((uint32_t *)arg);
  __cil_tmp38 = (unsigned long )__cil_tmp37;
  __cil_tmp39 = __cil_tmp38 * 16UL;
  rects_size = (unsigned int )__cil_tmp39;
  __cil_tmp40 = *((uint32_t *)arg);
  __cil_tmp41 = (size_t )__cil_tmp40;
  tmp___10 = kcalloc(__cil_tmp41, 16UL, 208U);
  rects = (struct drm_vmw_rect *)tmp___10;
  __cil_tmp42 = ! rects;
  __cil_tmp43 = ! __cil_tmp42;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = (long )__cil_tmp44;
  tmp___11 = ldv__builtin_expect(__cil_tmp45, 0L);
  if (tmp___11) {
    ret = -12;
    goto out_unlock;
  }
  __cil_tmp46 = (unsigned long )arg;
  __cil_tmp47 = __cil_tmp46 + 8UL;
  __cil_tmp48 = *((uint64_t *)__cil_tmp47);
  __cil_tmp49 = (unsigned long )__cil_tmp48;
  user_rects = (void *)__cil_tmp49;
  __cil_tmp50 = (void *)rects;
  __cil_tmp51 = user_rects;
  __cil_tmp52 = (unsigned long )rects_size;
  tmp = (unsigned long )copy_from_user(__cil_tmp50, __cil_tmp51, __cil_tmp52);
  tmp___12 = tmp;
  ret = (int )tmp___12;
  __cil_tmp53 = ret != 0;
  __cil_tmp54 = ! __cil_tmp53;
  __cil_tmp55 = ! __cil_tmp54;
  __cil_tmp56 = (long )__cil_tmp55;
  tmp___13 = ldv__builtin_expect(__cil_tmp56, 0L);
  if (tmp___13) {
    drm_err("vmw_kms_update_layout_ioctl", "Failed to get rects.\n");
    ret = -14;
    goto out_free;
  }
  i = 0;
  while (1) {
    __cil_tmp57 = *((uint32_t *)arg);
    __cil_tmp58 = (uint32_t )i;
    if (! (__cil_tmp58 < __cil_tmp57)) {
      goto while_break;
    }
    __cil_tmp59 = rects + i;
    __cil_tmp60 = *((int32_t *)__cil_tmp59);
    if (__cil_tmp60 < 0) {
      drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
      ret = -22;
      goto out_free;
    } else {
      __cil_tmp61 = rects + i;
      __cil_tmp62 = (unsigned long )__cil_tmp61;
      __cil_tmp63 = __cil_tmp62 + 4UL;
      __cil_tmp64 = *((int32_t *)__cil_tmp63);
      if (__cil_tmp64 < 0) {
        drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
        ret = -22;
        goto out_free;
      } else {
        __cil_tmp65 = (unsigned long )mode_config;
        __cil_tmp66 = __cil_tmp65 + 336UL;
        __cil_tmp67 = *((int *)__cil_tmp66);
        __cil_tmp68 = (uint32_t )__cil_tmp67;
        __cil_tmp69 = rects + i;
        __cil_tmp70 = (unsigned long )__cil_tmp69;
        __cil_tmp71 = __cil_tmp70 + 8UL;
        __cil_tmp72 = *((uint32_t *)__cil_tmp71);
        __cil_tmp73 = rects + i;
        __cil_tmp74 = *((int32_t *)__cil_tmp73);
        __cil_tmp75 = (uint32_t )__cil_tmp74;
        __cil_tmp76 = __cil_tmp75 + __cil_tmp72;
        if (__cil_tmp76 > __cil_tmp68) {
          drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
          ret = -22;
          goto out_free;
        } else {
          __cil_tmp77 = (unsigned long )mode_config;
          __cil_tmp78 = __cil_tmp77 + 340UL;
          __cil_tmp79 = *((int *)__cil_tmp78);
          __cil_tmp80 = (uint32_t )__cil_tmp79;
          __cil_tmp81 = rects + i;
          __cil_tmp82 = (unsigned long )__cil_tmp81;
          __cil_tmp83 = __cil_tmp82 + 12UL;
          __cil_tmp84 = *((uint32_t *)__cil_tmp83);
          __cil_tmp85 = rects + i;
          __cil_tmp86 = (unsigned long )__cil_tmp85;
          __cil_tmp87 = __cil_tmp86 + 4UL;
          __cil_tmp88 = *((int32_t *)__cil_tmp87);
          __cil_tmp89 = (uint32_t )__cil_tmp88;
          __cil_tmp90 = __cil_tmp89 + __cil_tmp84;
          if (__cil_tmp90 > __cil_tmp80) {
            drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
            ret = -22;
            goto out_free;
          }
        }
      }
    }
    i ++;
  }
  while_break: 
  __cil_tmp91 = *((uint32_t *)arg);
  vmw_du_update_layout(dev_priv, __cil_tmp91, rects);
  out_free: 
  __cil_tmp92 = (void *)rects;
  kfree(__cil_tmp92);
  out_unlock: 
  __cil_tmp93 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp93);
  return (ret);
}
}
extern void ldv_initialize(void) ;
int LDV_IN_INTERRUPT  ;
void ldv_main2_sequence_infinite_withcheck_stateful(void) 
{ struct drm_framebuffer *var_group1 ;
  struct drm_file *var_group2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p2 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_surface_dirty_12_p4 ;
  unsigned int var_vmw_framebuffer_surface_dirty_12_p5 ;
  unsigned int *var_vmw_framebuffer_create_handle_9_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p2 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p3 ;
  struct drm_clip_rect *var_vmw_framebuffer_dmabuf_dirty_18_p4 ;
  unsigned int var_vmw_framebuffer_dmabuf_dirty_18_p5 ;
  struct drm_device *var_group3 ;
  struct drm_mode_fb_cmd2 *var_vmw_kms_fb_create_22_p2 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___8 = __VERIFIER_nondet_int();
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = __VERIFIER_nondet_int();
    if (tmp___7 == 0) {
      goto case_0;
    } else
    if (tmp___7 == 1) {
      goto case_1;
    } else
    if (tmp___7 == 2) {
      goto case_2;
    } else
    if (tmp___7 == 3) {
      goto case_3;
    } else
    if (tmp___7 == 4) {
      goto case_4;
    } else
    if (tmp___7 == 5) {
      goto case_5;
    } else
    if (tmp___7 == 6) {
      goto case_6;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_framebuffer_surface_destroy(var_group1);
        goto switch_break;
        case_1: 
        vmw_framebuffer_surface_dirty(var_group1, var_group2, var_vmw_framebuffer_surface_dirty_12_p2,
                                      var_vmw_framebuffer_surface_dirty_12_p3, var_vmw_framebuffer_surface_dirty_12_p4,
                                      var_vmw_framebuffer_surface_dirty_12_p5);
        goto switch_break;
        case_2: 
        vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
        goto switch_break;
        case_3: 
        vmw_framebuffer_dmabuf_destroy(var_group1);
        goto switch_break;
        case_4: 
        vmw_framebuffer_dmabuf_dirty(var_group1, var_group2, var_vmw_framebuffer_dmabuf_dirty_18_p2,
                                     var_vmw_framebuffer_dmabuf_dirty_18_p3, var_vmw_framebuffer_dmabuf_dirty_18_p4,
                                     var_vmw_framebuffer_dmabuf_dirty_18_p5);
        goto switch_break;
        case_5: 
        vmw_framebuffer_create_handle(var_group1, var_group2, var_vmw_framebuffer_create_handle_9_p2);
        goto switch_break;
        case_6: 
        vmw_kms_fb_create(var_group3, var_group2, var_vmw_kms_fb_create_22_p2);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: 
  ldv_check_final_state();
  return;
}
}
 static void atomic_set(atomic_t *v , int i )  __attribute__((__no_instrument_function__)) ;
 static void atomic_set(atomic_t *v , int i )  __attribute__((__no_instrument_function__)) ;
 static void atomic_set(atomic_t *v , int i ) 
{ 

  {
  *((int *)v) = i;
  return;
}
}
extern void __rwlock_init(rwlock_t *lock , char *name , struct lock_class_key *key ) ;
extern void _raw_spin_lock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_spin_unlock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
 static void spin_lock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_lock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_lock(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct raw_spinlock *)lock;
  _raw_spin_lock(__cil_tmp2);
  return;
}
}
 static void spin_unlock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct raw_spinlock *)lock;
  _raw_spin_unlock(__cil_tmp2);
  return;
}
}
extern void __init_waitqueue_head(wait_queue_head_t *q , char *name , struct lock_class_key * ) ;
extern void __mutex_init(struct mutex *lock , char *name , struct lock_class_key *key ) ;
extern void iounmap(void volatile   *addr ) ;
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
extern struct kernel_param_ops param_ops_int ;
extern struct module __this_module ;
int init_module(void) ;
void cleanup_module(void) ;
extern loff_t noop_llseek(struct file *file , loff_t offset , int origin ) ;
extern void *dev_get_drvdata(struct device *dev ) ;
extern int __attribute__((__warn_unused_result__))  pci_enable_device(struct pci_dev *dev ) ;
extern void pci_disable_device(struct pci_dev *dev ) ;
extern void pci_set_master(struct pci_dev *dev ) ;
extern int pci_save_state(struct pci_dev *dev ) ;
extern void pci_restore_state(struct pci_dev *dev ) ;
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
extern int __attribute__((__warn_unused_result__))  pci_request_regions(struct pci_dev * ,
                                                                        char * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int __attribute__((__warn_unused_result__))  pci_request_region(struct pci_dev * ,
                                                                       int  , char * ) ;
extern void pci_release_region(struct pci_dev * , int  ) ;
 static void *pci_get_drvdata(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
 static void *pci_get_drvdata(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
 static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct device *__cil_tmp5 ;
  struct device *__cil_tmp6 ;

  {
  __cil_tmp3 = (unsigned long )pdev;
  __cil_tmp4 = __cil_tmp3 + 144UL;
  __cil_tmp5 = (struct device *)__cil_tmp4;
  __cil_tmp6 = __cil_tmp5;
  tmp = dev_get_drvdata(__cil_tmp6);
  return (tmp);
}
}
extern int mtrr_add(unsigned long base , unsigned long size , unsigned int type ,
                    bool increment ) ;
extern int mtrr_del(int reg , unsigned long base , unsigned long size ) ;
extern void idr_destroy(struct idr *idp ) ;
extern void idr_init(struct idr *idp ) ;
 static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags )  __attribute__((__no_instrument_function__)) ;
 static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags )  __attribute__((__no_instrument_function__)) ;
 static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags ) 
{ int tmp___7 ;
  bool __cil_tmp5 ;

  {
  __cil_tmp5 = (bool )1;
  tmp___7 = mtrr_add(offset, size, flags, __cil_tmp5);
  return (tmp___7);
}
}
 static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags )  __attribute__((__no_instrument_function__)) ;
 static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags )  __attribute__((__no_instrument_function__)) ;
 static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags ) 
{ int tmp___7 ;

  {
  tmp___7 = mtrr_del(handle, offset, size);
  return (tmp___7);
}
}
extern long drm_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) ;
extern long drm_compat_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) ;
extern int drm_open(struct inode *inode , struct file *filp ) ;
extern int drm_fasync(int fd , struct file *filp , int on ) ;
extern int drm_release(struct inode *inode , struct file *filp ) ;
extern int drm_irq_install(struct drm_device *dev ) ;
extern int drm_irq_uninstall(struct drm_device *dev ) ;
extern void drm_put_dev(struct drm_device *dev ) ;
extern int drm_pci_init(struct drm_driver *driver , struct pci_driver *pdriver ) ;
extern void drm_pci_exit(struct drm_driver *driver , struct pci_driver *pdriver ) ;
extern int drm_get_pci_dev(struct pci_dev *pdev , struct pci_device_id *ent , struct drm_driver *driver ) ;
extern int register_pm_notifier(struct notifier_block *nb ) ;
extern int unregister_pm_notifier(struct notifier_block *nb ) ;
extern int ttm_bo_wait(struct ttm_buffer_object *bo , bool lazy , bool interruptible ,
                       bool no_wait ) ;
extern int ttm_bo_create(struct ttm_bo_device *bdev , unsigned long size , enum ttm_bo_type type ,
                         struct ttm_placement *placement , uint32_t page_alignment ,
                         unsigned long buffer_start , bool interruptible , struct file *persistent_swap_storage ,
                         struct ttm_buffer_object **p_bo ) ;
extern int ttm_bo_init_mm(struct ttm_bo_device *bdev , unsigned int type , unsigned long p_size ) ;
extern int ttm_bo_clean_mm(struct ttm_bo_device *bdev , unsigned int mem_type ) ;
extern int ttm_bo_evict_mm(struct ttm_bo_device *bdev , unsigned int mem_type ) ;
extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev ) ;
extern int ttm_bo_device_release(struct ttm_bo_device *bdev ) ;
extern int ttm_bo_device_init(struct ttm_bo_device *bdev , struct ttm_bo_global *glob ,
                              struct ttm_bo_driver *driver , uint64_t file_page_offset ,
                              bool need_dma32 ) ;
extern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device *tdev ,
                                                    unsigned int hash_order ) ;
extern void ttm_object_file_release(struct ttm_object_file **p_tfile ) ;
extern struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global *mem_glob ,
                                                        unsigned int hash_order ) ;
extern void ttm_object_device_release(struct ttm_object_device **p_tdev ) ;
extern void ttm_lock_init(struct ttm_lock *lock ) ;
extern void ttm_suspend_lock(struct ttm_lock *lock ) ;
extern void ttm_suspend_unlock(struct ttm_lock *lock ) ;
extern int ttm_vt_lock(struct ttm_lock *lock , bool interruptible , struct ttm_object_file *tfile ) ;
extern int ttm_vt_unlock(struct ttm_lock *lock ) ;
 static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal )  __attribute__((__no_instrument_function__)) ;
 static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal )  __attribute__((__no_instrument_function__)) ;
 static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  __cil_tmp4 = (unsigned long )lock;
  __cil_tmp5 = __cil_tmp4 + 136UL;
  *((bool *)__cil_tmp5) = val;
  if (val) {
    __cil_tmp6 = (unsigned long )lock;
    __cil_tmp7 = __cil_tmp6 + 140UL;
    *((int *)__cil_tmp7) = signal;
  }
  return;
}
}
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) ;
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) ;
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) ;
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) ;
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) ;
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) ;
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) ;
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) ;
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) ;
int vmw_ttm_global_init(struct vmw_private *dev_priv ) ;
void vmw_ttm_global_release(struct vmw_private *dev_priv ) ;
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) ;
struct ttm_placement vmw_vram_sys_placement ;
struct ttm_bo_driver vmw_bo_driver ;
irqreturn_t vmw_irq_handler(int irq , void *arg ) ;
void vmw_irq_preinstall(struct drm_device *dev ) ;
int vmw_irq_postinstall(struct drm_device *dev ) ;
void vmw_irq_uninstall(struct drm_device *dev ) ;
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) ;
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) ;
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) ;
int vmw_overlay_init(struct vmw_private *dev_priv ) ;
int vmw_overlay_close(struct vmw_private *dev_priv ) ;
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static struct drm_ioctl_desc vmw_ioctls[21]  = 
  {      {0U, 17, & vmw_getparam_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 64U) | (sizeof(struct drm_vmw_getparam_arg ) << 16))}, 
        {1U,
      17, & vmw_dmabuf_alloc_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 65U) | (sizeof(union drm_vmw_alloc_dmabuf_arg ) << 16))}, 
        {2U,
      17, & vmw_dmabuf_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 66U) | (sizeof(struct drm_vmw_unref_dmabuf_arg ) << 16))}, 
        {3U,
      26, & vmw_kms_cursor_bypass_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 67U) | (sizeof(struct drm_vmw_cursor_bypass_arg ) << 16))}, 
        {4U,
      26, & vmw_overlay_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 68U) | (sizeof(struct drm_vmw_control_stream_arg ) << 16))}, 
        {5U,
      26, & vmw_stream_claim_ioctl, (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(100 << 8)) | 69U) | (sizeof(struct drm_vmw_stream_arg ) << 16))}, 
        {6U,
      26, & vmw_stream_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 70U) | (sizeof(struct drm_vmw_stream_arg ) << 16))}, 
        {7U,
      17, & vmw_context_define_ioctl, (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(100 << 8)) | 71U) | (sizeof(struct drm_vmw_context_arg ) << 16))}, 
        {8U,
      17, & vmw_context_destroy_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 72U) | (sizeof(struct drm_vmw_context_arg ) << 16))}, 
        {9U,
      17, & vmw_surface_define_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 73U) | (sizeof(union drm_vmw_surface_create_arg ) << 16))}, 
        {10U,
      17, & vmw_surface_destroy_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 74U) | (sizeof(struct drm_vmw_surface_arg ) << 16))}, 
        {11U,
      17, & vmw_surface_reference_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 75U) | (sizeof(union drm_vmw_surface_reference_arg ) << 16))}, 
        {12U,
      17, & vmw_execbuf_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 76U) | (sizeof(struct drm_vmw_execbuf_arg ) << 16))}, 
        {13U,
      17, & vmw_get_cap_3d_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 77U) | (sizeof(struct drm_vmw_get_3d_cap_arg ) << 16))}, 
        {14U,
      17, & vmw_fence_obj_wait_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 78U) | (sizeof(struct drm_vmw_fence_wait_arg ) << 16))}, 
        {15U,
      17, & vmw_fence_obj_signaled_ioctl, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(100 << 8)) | 79U) | (sizeof(struct drm_vmw_fence_signaled_arg ) << 16))}, 
        {16U,
      17, & vmw_fence_obj_unref_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 80U) | (sizeof(struct drm_vmw_fence_arg ) << 16))}, 
        {17U,
      17, & vmw_fence_event_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 81U) | (sizeof(struct drm_vmw_fence_event_arg ) << 16))}, 
        {18U,
      19, & vmw_present_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 82U) | (sizeof(struct drm_vmw_present_arg ) << 16))}, 
        {19U,
      19, & vmw_present_readback_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 83U) | (sizeof(struct drm_vmw_present_readback_arg ) << 16))}, 
        {20U,
      18, & vmw_kms_update_layout_ioctl, (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(100 << 8)) | 84U) | (sizeof(struct drm_vmw_update_layout_arg ) << 16))}};
static struct pci_device_id vmw_pci_id_list[2]  = {      {(__u32 )5549,
      (__u32 )1029, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )0,
      (__u32 )0, (__u32 )0, 0U, 0U, 0U, 0UL}};
static int enable_fbdev  ;
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id *ent ) ;
static void vmw_master_init(struct vmw_master *vmaster ) ;
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) ;
static char __mod_enable_fbdev194[38]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char )'p',      (char )'a',      (char const   )'r',      (char const   )'m', 
        (char )'=',      (char )'e',      (char const   )'n',      (char const   )'a', 
        (char )'b',      (char )'l',      (char const   )'e',      (char const   )'_', 
        (char )'f',      (char )'b',      (char const   )'d',      (char const   )'e', 
        (char )'v',      (char )':',      (char const   )'E',      (char const   )'n', 
        (char )'a',      (char )'b',      (char const   )'l',      (char const   )'e', 
        (char )' ',      (char )'v',      (char const   )'m',      (char const   )'w', 
        (char )'g',      (char )'f',      (char const   )'x',      (char const   )' ', 
        (char )'f',      (char )'b',      (char const   )'d',      (char const   )'e', 
        (char )'v',      (char )'\000'};
static char __param_str_enable_fbdev[13]  = 
  {      (char )'e',      (char )'n',      (char const   )'a',      (char const   )'b', 
        (char )'l',      (char )'e',      (char const   )'_',      (char const   )'f', 
        (char )'b',      (char )'d',      (char const   )'e',      (char const   )'v', 
        (char )'\000'};
static struct kernel_param __param_enable_fbdev  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable_fbdev, & param_ops_int, (u16 )384, (s16 )0, {(void *)(& enable_fbdev)}};
static char __mod_enable_fbdevtype195[26]  __attribute__((__used__,
__unused__, __section__(".modinfo"), __aligned__(1)))  = 
  {      (char )'p',      (char )'a',      (char const   )'r',      (char const   )'m', 
        (char )'t',      (char )'y',      (char const   )'p',      (char const   )'e', 
        (char )'=',      (char )'e',      (char const   )'n',      (char const   )'a', 
        (char )'b',      (char )'l',      (char const   )'e',      (char const   )'_', 
        (char )'f',      (char )'b',      (char const   )'d',      (char const   )'e', 
        (char )'v',      (char )':',      (char const   )'i',      (char const   )'n', 
        (char )'t',      (char )'\000'};
static void vmw_print_capabilities(uint32_t capabilities ) 
{ 

  {
  printk("<6>[drm] Capabilities:\n");
  if (capabilities & 2U) {
    printk("<6>[drm]   Rect copy.\n");
  }
  if (capabilities & 32U) {
    printk("<6>[drm]   Cursor.\n");
  }
  if (capabilities & 64U) {
    printk("<6>[drm]   Cursor bypass.\n");
  }
  if (capabilities & 128U) {
    printk("<6>[drm]   Cursor bypass 2.\n");
  }
  if (capabilities & 256U) {
    printk("<6>[drm]   8bit emulation.\n");
  }
  if (capabilities & 512U) {
    printk("<6>[drm]   Alpha cursor.\n");
  }
  if (capabilities & 16384U) {
    printk("<6>[drm]   3D.\n");
  }
  if (capabilities & 32768U) {
    printk("<6>[drm]   Extended Fifo.\n");
  }
  if (capabilities & 65536U) {
    printk("<6>[drm]   Multimon.\n");
  }
  if (capabilities & 131072U) {
    printk("<6>[drm]   Pitchlock.\n");
  }
  if (capabilities & 262144U) {
    printk("<6>[drm]   Irq mask.\n");
  }
  if (capabilities & 524288U) {
    printk("<6>[drm]   Display Topology.\n");
  }
  if (capabilities & 1048576U) {
    printk("<6>[drm]   GMR.\n");
  }
  if (capabilities & 2097152U) {
    printk("<6>[drm]   Traces.\n");
  }
  if (capabilities & 4194304U) {
    printk("<6>[drm]   GMR2.\n");
  }
  if (capabilities & 8388608U) {
    printk("<6>[drm]   Screen Object 2.\n");
  }
  return;
}
}
static void vmw_dummy_query_bo_prepare(struct vmw_private *dev_priv ) 
{ struct ttm_bo_kmap_obj map ;
  SVGA3dQueryResult volatile   *result ;
  bool dummy ;
  int ret ;
  struct ttm_bo_device *bdev ;
  struct ttm_buffer_object *bo ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  bool __cil_tmp14 ;
  bool __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  bool __cil_tmp20 ;
  bool __cil_tmp21 ;
  bool __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  bool __cil_tmp30 ;
  bool __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  bool __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  bdev = (struct ttm_bo_device *)dev_priv;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 134744UL;
  bo = *((struct ttm_buffer_object **)__cil_tmp12);
  __cil_tmp13 = (bool )0;
  __cil_tmp14 = (bool )0;
  __cil_tmp15 = (bool )0;
  __cil_tmp16 = (uint32_t )0;
  ttm_bo_reserve(bo, __cil_tmp13, __cil_tmp14, __cil_tmp15, __cil_tmp16);
  __cil_tmp17 = (unsigned long )bdev;
  __cil_tmp18 = __cil_tmp17 + 1400UL;
  __cil_tmp19 = (spinlock_t *)__cil_tmp18;
  spin_lock(__cil_tmp19);
  __cil_tmp20 = (bool )0;
  __cil_tmp21 = (bool )0;
  __cil_tmp22 = (bool )0;
  ret = ttm_bo_wait(bo, __cil_tmp20, __cil_tmp21, __cil_tmp22);
  __cil_tmp23 = (unsigned long )bdev;
  __cil_tmp24 = __cil_tmp23 + 1400UL;
  __cil_tmp25 = (spinlock_t *)__cil_tmp24;
  spin_unlock(__cil_tmp25);
  __cil_tmp26 = ret != 0;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___7) {
    __cil_tmp30 = (bool )0;
    __cil_tmp31 = (bool )1;
    __cil_tmp32 = (uint32_t )0;
    __cil_tmp33 = (bool )0;
    vmw_fallback_wait(dev_priv, __cil_tmp30, __cil_tmp31, __cil_tmp32, __cil_tmp33,
                      2500UL);
  }
  ret = ttm_bo_kmap(bo, 0UL, 1UL, & map);
  __cil_tmp34 = ret == 0;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = (long )__cil_tmp36;
  tmp___9 = ldv__builtin_expect(__cil_tmp37, 1L);
  if (tmp___9) {
    tmp___8 = ttm_kmap_obj_virtual(& map, & dummy);
    result = (SVGA3dQueryResult volatile   *)tmp___8;
    *((uint32 volatile   *)result) = (uint32 volatile   )12UL;
    __cil_tmp38 = (unsigned long )result;
    __cil_tmp39 = __cil_tmp38 + 4UL;
    *((SVGA3dQueryState volatile   *)__cil_tmp39) = (SVGA3dQueryState volatile   )0;
    __cil_tmp40 = (unsigned long )result;
    __cil_tmp41 = __cil_tmp40 + 8UL;
    *((uint32 volatile   *)__cil_tmp41) = (uint32 volatile   )255;
    ttm_bo_kunmap(& map);
  } else {
    drm_err("vmw_dummy_query_bo_prepare", "Dummy query buffer map failed.\n");
  }
  ttm_bo_unreserve(bo);
  return;
}
}
static int vmw_dummy_query_bo_create(struct vmw_private *dev_priv ) 
{ int tmp___7 ;
  struct ttm_bo_device *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  enum ttm_bo_type __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  bool __cil_tmp7 ;
  void *__cil_tmp8 ;
  struct file *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_buffer_object **__cil_tmp12 ;

  {
  __cil_tmp3 = (struct ttm_bo_device *)dev_priv;
  __cil_tmp4 = 1UL << 12;
  __cil_tmp5 = (enum ttm_bo_type )0;
  __cil_tmp6 = (uint32_t )0;
  __cil_tmp7 = (bool )0;
  __cil_tmp8 = (void *)0;
  __cil_tmp9 = (struct file *)__cil_tmp8;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 134744UL;
  __cil_tmp12 = (struct ttm_buffer_object **)__cil_tmp11;
  tmp___7 = ttm_bo_create(__cil_tmp3, __cil_tmp4, __cil_tmp5, & vmw_vram_sys_placement,
                          __cil_tmp6, 0UL, __cil_tmp7, __cil_tmp9, __cil_tmp12);
  return (tmp___7);
}
}
static int vmw_request_device(struct vmw_private *dev_priv ) 
{ int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct vmw_fifo_state *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_fence_manager *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fence_manager *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_fifo_state *__cil_tmp24 ;

  {
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 1856UL;
  __cil_tmp7 = (struct vmw_fifo_state *)__cil_tmp6;
  ret = vmw_fifo_init(dev_priv, __cil_tmp7);
  __cil_tmp8 = ret != 0;
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = ! __cil_tmp9;
  __cil_tmp11 = (long )__cil_tmp10;
  tmp___7 = ldv__builtin_expect(__cil_tmp11, 0L);
  if (tmp___7) {
    drm_err("vmw_request_device", "Unable to initialize FIFO.\n");
    return (ret);
  }
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 3008UL;
  __cil_tmp14 = *((struct vmw_fence_manager **)__cil_tmp13);
  vmw_fence_fifo_up(__cil_tmp14);
  ret = vmw_dummy_query_bo_create(dev_priv);
  __cil_tmp15 = ret != 0;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___8 = ldv__builtin_expect(__cil_tmp18, 0L);
  if (tmp___8) {
    goto out_no_query_bo;
  }
  vmw_dummy_query_bo_prepare(dev_priv);
  return (0);
  out_no_query_bo: 
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 3008UL;
  __cil_tmp21 = *((struct vmw_fence_manager **)__cil_tmp20);
  vmw_fence_fifo_down(__cil_tmp21);
  __cil_tmp22 = (unsigned long )dev_priv;
  __cil_tmp23 = __cil_tmp22 + 1856UL;
  __cil_tmp24 = (struct vmw_fifo_state *)__cil_tmp23;
  vmw_fifo_release(dev_priv, __cil_tmp24);
  return (ret);
}
}
static void vmw_release_device(struct vmw_private *dev_priv ) 
{ long tmp___7 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct ttm_buffer_object *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct ttm_buffer_object **__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_fence_manager *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fifo_state *__cil_tmp21 ;

  {
  while (1) {
    __cil_tmp3 = (void *)0;
    __cil_tmp4 = (unsigned long )__cil_tmp3;
    __cil_tmp5 = (unsigned long )dev_priv;
    __cil_tmp6 = __cil_tmp5 + 134752UL;
    __cil_tmp7 = *((struct ttm_buffer_object **)__cil_tmp6);
    __cil_tmp8 = (unsigned long )__cil_tmp7;
    __cil_tmp9 = __cil_tmp8 != __cil_tmp4;
    __cil_tmp10 = ! __cil_tmp9;
    __cil_tmp11 = ! __cil_tmp10;
    __cil_tmp12 = (long )__cil_tmp11;
    tmp___7 = ldv__builtin_expect(__cil_tmp12, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                             "i" (330), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 134744UL;
  __cil_tmp15 = (struct ttm_buffer_object **)__cil_tmp14;
  ttm_bo_unref(__cil_tmp15);
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 3008UL;
  __cil_tmp18 = *((struct vmw_fence_manager **)__cil_tmp17);
  vmw_fence_fifo_down(__cil_tmp18);
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 1856UL;
  __cil_tmp21 = (struct vmw_fifo_state *)__cil_tmp20;
  vmw_fifo_release(dev_priv, __cil_tmp21);
  return;
}
}
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) 
{ int ret ;
  long tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct mutex *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct mutex *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  ret = 0;
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 134664UL;
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
  mutex_lock(__cil_tmp11);
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 134736UL;
  tmp___9 = *((uint32_t *)__cil_tmp13);
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 134736UL;
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 134736UL;
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
  *((uint32_t *)__cil_tmp15) = __cil_tmp18 + 1U;
  if (tmp___9 == 0U) {
    tmp___10 = 1;
  } else {
    tmp___10 = 0;
  }
  __cil_tmp19 = (long )tmp___10;
  tmp___11 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___11) {
    ret = vmw_request_device(dev_priv);
    __cil_tmp20 = ret != 0;
    __cil_tmp21 = ! __cil_tmp20;
    __cil_tmp22 = ! __cil_tmp21;
    __cil_tmp23 = (long )__cil_tmp22;
    tmp___7 = ldv__builtin_expect(__cil_tmp23, 0L);
    if (tmp___7) {
      __cil_tmp24 = (unsigned long )dev_priv;
      __cil_tmp25 = __cil_tmp24 + 134736UL;
      __cil_tmp26 = (unsigned long )dev_priv;
      __cil_tmp27 = __cil_tmp26 + 134736UL;
      __cil_tmp28 = *((uint32_t *)__cil_tmp27);
      *((uint32_t *)__cil_tmp25) = __cil_tmp28 - 1U;
    }
  } else
  if (unhide_svga) {
    __cil_tmp29 = (unsigned long )dev_priv;
    __cil_tmp30 = __cil_tmp29 + 2184UL;
    __cil_tmp31 = (struct mutex *)__cil_tmp30;
    mutex_lock(__cil_tmp31);
    tmp___8 = vmw_read(dev_priv, 1U);
    __cil_tmp32 = tmp___8 & 4294967293U;
    vmw_write(dev_priv, 1U, __cil_tmp32);
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 2184UL;
    __cil_tmp35 = (struct mutex *)__cil_tmp34;
    mutex_unlock(__cil_tmp35);
  }
  __cil_tmp36 = (unsigned long )dev_priv;
  __cil_tmp37 = __cil_tmp36 + 134664UL;
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
  mutex_unlock(__cil_tmp38);
  return (ret);
}
}
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) 
{ int32_t n3d ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct mutex *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct mutex *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct mutex *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 134664UL;
  __cil_tmp10 = (struct mutex *)__cil_tmp9;
  mutex_lock(__cil_tmp10);
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 134736UL;
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 134736UL;
  __cil_tmp15 = *((uint32_t *)__cil_tmp14);
  *((uint32_t *)__cil_tmp12) = __cil_tmp15 - 1U;
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 134736UL;
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
  if (__cil_tmp18 == 0U) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __cil_tmp19 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___9) {
    vmw_release_device(dev_priv);
  } else
  if (hide_svga) {
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 2184UL;
    __cil_tmp22 = (struct mutex *)__cil_tmp21;
    mutex_lock(__cil_tmp22);
    tmp___7 = vmw_read(dev_priv, 1U);
    __cil_tmp23 = tmp___7 | 2U;
    vmw_write(dev_priv, 1U, __cil_tmp23);
    __cil_tmp24 = (unsigned long )dev_priv;
    __cil_tmp25 = __cil_tmp24 + 2184UL;
    __cil_tmp26 = (struct mutex *)__cil_tmp25;
    mutex_unlock(__cil_tmp26);
  }
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 134736UL;
  __cil_tmp29 = *((uint32_t *)__cil_tmp28);
  n3d = (int32_t )__cil_tmp29;
  __cil_tmp30 = (unsigned long )dev_priv;
  __cil_tmp31 = __cil_tmp30 + 134664UL;
  __cil_tmp32 = (struct mutex *)__cil_tmp31;
  mutex_unlock(__cil_tmp32);
  while (1) {
    __cil_tmp33 = n3d < 0;
    __cil_tmp34 = ! __cil_tmp33;
    __cil_tmp35 = ! __cil_tmp34;
    __cil_tmp36 = (long )__cil_tmp35;
    tmp___10 = ldv__builtin_expect(__cil_tmp36, 0L);
    if (tmp___10) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                             "i" (392), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  return;
}
}
static void vmw_get_initial_size(struct vmw_private *dev_priv ) 
{ uint32_t width ;
  uint32_t height ;
  uint32_t __max1 ;
  uint32_t __max2 ;
  uint32_t tmp___7 ;
  uint32_t __max1___0 ;
  uint32_t __max2___0 ;
  uint32_t tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;

  {
  width = vmw_read(dev_priv, 2U);
  height = vmw_read(dev_priv, 3U);
  __max1 = width;
  __max2 = (uint32_t )800;
  if (__max1 > __max2) {
    tmp___7 = __max1;
  } else {
    tmp___7 = __max2;
  }
  width = tmp___7;
  __max1___0 = height;
  __max2___0 = (uint32_t )600;
  if (__max1___0 > __max2___0) {
    tmp___8 = __max1___0;
  } else {
    tmp___8 = __max2___0;
  }
  height = tmp___8;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2124UL;
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
  if (width > __cil_tmp12) {
    width = (uint32_t )800;
    height = (uint32_t )600;
  } else {
    __cil_tmp13 = (unsigned long )dev_priv;
    __cil_tmp14 = __cil_tmp13 + 2128UL;
    __cil_tmp15 = *((uint32_t *)__cil_tmp14);
    if (height > __cil_tmp15) {
      width = (uint32_t )800;
      height = (uint32_t )600;
    }
  }
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 2132UL;
  *((uint32_t *)__cil_tmp17) = width;
  __cil_tmp18 = (unsigned long )dev_priv;
  __cil_tmp19 = __cil_tmp18 + 2136UL;
  *((uint32_t *)__cil_tmp19) = height;
  return;
}
}
static struct lock_class_key __key___4  ;
static struct lock_class_key __key___5  ;
static struct lock_class_key __key___6  ;
static struct lock_class_key __key___7  ;
static struct lock_class_key __key___8  ;
static struct lock_class_key __key___9  ;
static struct lock_class_key __key___10  ;
static int vmw_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ struct vmw_private *dev_priv ;
  int ret ;
  uint32_t svga_id ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  bool tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  char *tmp___22 ;
  bool tmp___23 ;
  long tmp___24 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct pci_dev *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct mutex *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct mutex *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  rwlock_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct idr *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct idr *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct idr *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct mutex *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  wait_queue_head_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  wait_queue_head_t *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  atomic_t *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct pci_dev *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  resource_size_t __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct pci_dev *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  resource_size_t __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct pci_dev *__cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  resource_size_t __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  int *__cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  struct mutex *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  uint32_t __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  struct mutex *__cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  uint32_t __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  uint32_t __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  struct mutex *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  uint32_t __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  uint32_t __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  uint32_t __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  uint32_t __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  uint32_t __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  uint32_t __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  unsigned int __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  uint32_t __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  uint32_t __cil_tmp191 ;
  uint32_t __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  uint32_t __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  uint32_t __cil_tmp198 ;
  uint32_t __cil_tmp199 ;
  int __cil_tmp200 ;
  int __cil_tmp201 ;
  int __cil_tmp202 ;
  long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  struct vmw_master *__cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  struct ttm_lock *__cil_tmp209 ;
  bool __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  struct ttm_bo_device *__cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  void *__cil_tmp220 ;
  struct ttm_bo_global *__cil_tmp221 ;
  uint64_t __cil_tmp222 ;
  bool __cil_tmp223 ;
  int __cil_tmp224 ;
  int __cil_tmp225 ;
  int __cil_tmp226 ;
  long __cil_tmp227 ;
  struct ttm_bo_device *__cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  uint32_t __cil_tmp231 ;
  uint32_t __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  int __cil_tmp234 ;
  int __cil_tmp235 ;
  int __cil_tmp236 ;
  long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct ttm_bo_device *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  uint32_t __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  uint32_t __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  uint32_t __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  uint32_t __cil_tmp259 ;
  resource_size_t __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  uint32_t __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  void *__cil_tmp267 ;
  unsigned long __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  __le32 *__cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  int __cil_tmp273 ;
  int __cil_tmp274 ;
  int __cil_tmp275 ;
  long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  uint32_t __cil_tmp279 ;
  unsigned int __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  uint32_t __cil_tmp283 ;
  unsigned int __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  void *__cil_tmp290 ;
  struct ttm_mem_global *__cil_tmp291 ;
  void *__cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  struct ttm_object_device *__cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  int __cil_tmp298 ;
  int __cil_tmp299 ;
  int __cil_tmp300 ;
  long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  struct pci_dev *__cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  int __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct pci_dev *__cil_tmp314 ;
  int __cil_tmp315 ;
  int __cil_tmp316 ;
  int __cil_tmp317 ;
  long __cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  void *__cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;
  struct vmw_fence_manager *__cil_tmp325 ;
  unsigned long __cil_tmp326 ;
  int __cil_tmp327 ;
  int __cil_tmp328 ;
  int __cil_tmp329 ;
  long __cil_tmp330 ;
  bool __cil_tmp331 ;
  int __cil_tmp332 ;
  int __cil_tmp333 ;
  int __cil_tmp334 ;
  long __cil_tmp335 ;
  int __cil_tmp336 ;
  int __cil_tmp337 ;
  int __cil_tmp338 ;
  long __cil_tmp339 ;
  unsigned long __cil_tmp340 ;
  unsigned long __cil_tmp341 ;
  bool __cil_tmp342 ;
  unsigned long __cil_tmp343 ;
  unsigned long __cil_tmp344 ;
  uint32_t __cil_tmp345 ;
  int __cil_tmp346 ;
  int __cil_tmp347 ;
  int __cil_tmp348 ;
  long __cil_tmp349 ;
  unsigned long __cil_tmp350 ;
  unsigned long __cil_tmp351 ;
  unsigned long __cil_tmp352 ;
  unsigned long __cil_tmp353 ;
  struct notifier_block *__cil_tmp354 ;
  unsigned long __cil_tmp355 ;
  unsigned long __cil_tmp356 ;
  unsigned long __cil_tmp357 ;
  unsigned long __cil_tmp358 ;
  bool __cil_tmp359 ;
  unsigned long __cil_tmp360 ;
  unsigned long __cil_tmp361 ;
  struct vmw_fence_manager *__cil_tmp362 ;
  unsigned long __cil_tmp363 ;
  unsigned long __cil_tmp364 ;
  unsigned long __cil_tmp365 ;
  unsigned long __cil_tmp366 ;
  struct pci_dev *__cil_tmp367 ;
  unsigned long __cil_tmp368 ;
  unsigned long __cil_tmp369 ;
  struct pci_dev *__cil_tmp370 ;
  unsigned long __cil_tmp371 ;
  unsigned long __cil_tmp372 ;
  struct ttm_object_device **__cil_tmp373 ;
  unsigned long __cil_tmp374 ;
  unsigned long __cil_tmp375 ;
  __le32 *__cil_tmp376 ;
  void volatile   *__cil_tmp377 ;
  unsigned long __cil_tmp378 ;
  unsigned long __cil_tmp379 ;
  int __cil_tmp380 ;
  unsigned long __cil_tmp381 ;
  unsigned long __cil_tmp382 ;
  uint32_t __cil_tmp383 ;
  unsigned long __cil_tmp384 ;
  unsigned long __cil_tmp385 ;
  unsigned long __cil_tmp386 ;
  uint32_t __cil_tmp387 ;
  unsigned long __cil_tmp388 ;
  unsigned long __cil_tmp389 ;
  unsigned long __cil_tmp390 ;
  struct ttm_bo_device *__cil_tmp391 ;
  struct ttm_bo_device *__cil_tmp392 ;
  struct ttm_bo_device *__cil_tmp393 ;
  unsigned long __cil_tmp394 ;
  unsigned long __cil_tmp395 ;
  struct idr *__cil_tmp396 ;
  unsigned long __cil_tmp397 ;
  unsigned long __cil_tmp398 ;
  struct idr *__cil_tmp399 ;
  unsigned long __cil_tmp400 ;
  unsigned long __cil_tmp401 ;
  struct idr *__cil_tmp402 ;
  void *__cil_tmp403 ;
  int tmp ;
  int tmp___25 ;

  {
  tmp___7 = kzalloc(134792UL, 208U);
  dev_priv = (struct vmw_private *)tmp___7;
  __cil_tmp24 = (void *)0;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = (unsigned long )dev_priv;
  __cil_tmp27 = __cil_tmp26 == __cil_tmp25;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = (long )__cil_tmp29;
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 0L);
  if (tmp___8) {
    drm_err("vmw_driver_load", "Failed allocating a device private struct.\n");
    return (-12);
  }
  __cil_tmp31 = (void *)dev_priv;
  memset(__cil_tmp31, 0, 134792UL);
  __cil_tmp32 = (unsigned long )dev;
  __cil_tmp33 = __cil_tmp32 + 1016UL;
  __cil_tmp34 = *((struct pci_dev **)__cil_tmp33);
  pci_set_master(__cil_tmp34);
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2088UL;
  *((struct drm_device **)__cil_tmp36) = dev;
  __cil_tmp37 = (unsigned long )dev_priv;
  __cil_tmp38 = __cil_tmp37 + 2096UL;
  *((unsigned long *)__cil_tmp38) = chipset;
  __cil_tmp39 = (unsigned long )dev_priv;
  __cil_tmp40 = __cil_tmp39 + 2980UL;
  *((uint32_t *)__cil_tmp40) = (uint32_t )-100;
  while (1) {
    __cil_tmp41 = (unsigned long )dev_priv;
    __cil_tmp42 = __cil_tmp41 + 2184UL;
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
    __mutex_init(__cil_tmp43, "&dev_priv->hw_mutex", & __key___4);
    goto while_break;
  }
  while_break: ;
  while (1) {
    __cil_tmp44 = (unsigned long )dev_priv;
    __cil_tmp45 = __cil_tmp44 + 134304UL;
    __cil_tmp46 = (struct mutex *)__cil_tmp45;
    __mutex_init(__cil_tmp46, "&dev_priv->cmdbuf_mutex", & __key___5);
    goto while_break___0;
  }
  while_break___0: ;
  while (1) {
    __cil_tmp47 = (unsigned long )dev_priv;
    __cil_tmp48 = __cil_tmp47 + 134664UL;
    __cil_tmp49 = (struct mutex *)__cil_tmp48;
    __mutex_init(__cil_tmp49, "&dev_priv->release_mutex", & __key___6);
    goto while_break___1;
  }
  while_break___1: ;
  while (1) {
    __cil_tmp50 = (unsigned long )dev_priv;
    __cil_tmp51 = __cil_tmp50 + 2632UL;
    __cil_tmp52 = (rwlock_t *)__cil_tmp51;
    __rwlock_init(__cil_tmp52, "&dev_priv->resource_lock", & __key___7);
    goto while_break___2;
  }
  while_break___2: 
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 2656UL;
  __cil_tmp55 = (struct idr *)__cil_tmp54;
  idr_init(__cil_tmp55);
  __cil_tmp56 = (unsigned long )dev_priv;
  __cil_tmp57 = __cil_tmp56 + 2704UL;
  __cil_tmp58 = (struct idr *)__cil_tmp57;
  idr_init(__cil_tmp58);
  __cil_tmp59 = (unsigned long )dev_priv;
  __cil_tmp60 = __cil_tmp59 + 2752UL;
  __cil_tmp61 = (struct idr *)__cil_tmp60;
  idr_init(__cil_tmp61);
  while (1) {
    __cil_tmp62 = (unsigned long )dev_priv;
    __cil_tmp63 = __cil_tmp62 + 2800UL;
    __cil_tmp64 = (struct mutex *)__cil_tmp63;
    __mutex_init(__cil_tmp64, "&dev_priv->init_mutex", & __key___8);
    goto while_break___3;
  }
  while_break___3: ;
  while (1) {
    __cil_tmp65 = (unsigned long )dev_priv;
    __cil_tmp66 = __cil_tmp65 + 2888UL;
    __cil_tmp67 = (wait_queue_head_t *)__cil_tmp66;
    __init_waitqueue_head(__cil_tmp67, "&dev_priv->fence_queue", & __key___9);
    goto while_break___4;
  }
  while_break___4: ;
  while (1) {
    __cil_tmp68 = (unsigned long )dev_priv;
    __cil_tmp69 = __cil_tmp68 + 2928UL;
    __cil_tmp70 = (wait_queue_head_t *)__cil_tmp69;
    __init_waitqueue_head(__cil_tmp70, "&dev_priv->fifo_queue", & __key___10);
    goto while_break___5;
  }
  while_break___5: 
  __cil_tmp71 = (unsigned long )dev_priv;
  __cil_tmp72 = __cil_tmp71 + 2968UL;
  *((int *)__cil_tmp72) = 0;
  __cil_tmp73 = (unsigned long )dev_priv;
  __cil_tmp74 = __cil_tmp73 + 2976UL;
  __cil_tmp75 = (atomic_t *)__cil_tmp74;
  atomic_set(__cil_tmp75, 0);
  __cil_tmp76 = (unsigned long )dev_priv;
  __cil_tmp77 = __cil_tmp76 + 134768UL;
  __cil_tmp78 = (struct list_head *)__cil_tmp77;
  INIT_LIST_HEAD(__cil_tmp78);
  __cil_tmp79 = (unsigned long )dev_priv;
  __cil_tmp80 = __cil_tmp79 + 134784UL;
  *((uint32_t *)__cil_tmp80) = (uint32_t )0;
  __cil_tmp81 = (unsigned long )dev_priv;
  __cil_tmp82 = __cil_tmp81 + 2104UL;
  __cil_tmp83 = 0UL;
  __cil_tmp84 = 920UL + __cil_tmp83;
  __cil_tmp85 = (unsigned long )dev;
  __cil_tmp86 = __cil_tmp85 + 1016UL;
  __cil_tmp87 = *((struct pci_dev **)__cil_tmp86);
  __cil_tmp88 = (unsigned long )__cil_tmp87;
  __cil_tmp89 = __cil_tmp88 + __cil_tmp84;
  __cil_tmp90 = *((resource_size_t *)__cil_tmp89);
  *((unsigned int *)__cil_tmp82) = (unsigned int )__cil_tmp90;
  __cil_tmp91 = (unsigned long )dev_priv;
  __cil_tmp92 = __cil_tmp91 + 2108UL;
  __cil_tmp93 = 56UL;
  __cil_tmp94 = 920UL + __cil_tmp93;
  __cil_tmp95 = (unsigned long )dev;
  __cil_tmp96 = __cil_tmp95 + 1016UL;
  __cil_tmp97 = *((struct pci_dev **)__cil_tmp96);
  __cil_tmp98 = (unsigned long )__cil_tmp97;
  __cil_tmp99 = __cil_tmp98 + __cil_tmp94;
  __cil_tmp100 = *((resource_size_t *)__cil_tmp99);
  *((uint32_t *)__cil_tmp92) = (uint32_t )__cil_tmp100;
  __cil_tmp101 = (unsigned long )dev_priv;
  __cil_tmp102 = __cil_tmp101 + 2116UL;
  __cil_tmp103 = 112UL;
  __cil_tmp104 = 920UL + __cil_tmp103;
  __cil_tmp105 = (unsigned long )dev;
  __cil_tmp106 = __cil_tmp105 + 1016UL;
  __cil_tmp107 = *((struct pci_dev **)__cil_tmp106);
  __cil_tmp108 = (unsigned long )__cil_tmp107;
  __cil_tmp109 = __cil_tmp108 + __cil_tmp104;
  __cil_tmp110 = *((resource_size_t *)__cil_tmp109);
  *((uint32_t *)__cil_tmp102) = (uint32_t )__cil_tmp110;
  __cil_tmp111 = (unsigned long )dev_priv;
  __cil_tmp112 = __cil_tmp111 + 134378UL;
  __cil_tmp113 = & enable_fbdev;
  __cil_tmp114 = *__cil_tmp113;
  *((bool *)__cil_tmp112) = (bool )__cil_tmp114;
  __cil_tmp115 = (unsigned long )dev_priv;
  __cil_tmp116 = __cil_tmp115 + 2184UL;
  __cil_tmp117 = (struct mutex *)__cil_tmp116;
  mutex_lock(__cil_tmp117);
  __cil_tmp118 = 9437184UL << 8;
  __cil_tmp119 = __cil_tmp118 | 2UL;
  __cil_tmp120 = (uint32_t )__cil_tmp119;
  vmw_write(dev_priv, 0U, __cil_tmp120);
  svga_id = vmw_read(dev_priv, 0U);
  __cil_tmp121 = 9437184UL << 8;
  __cil_tmp122 = __cil_tmp121 | 2UL;
  __cil_tmp123 = (unsigned long )svga_id;
  if (__cil_tmp123 != __cil_tmp122) {
    ret = -38;
    drm_err("vmw_driver_load", "Unsupported SVGA ID 0x%x\n", svga_id);
    __cil_tmp124 = (unsigned long )dev_priv;
    __cil_tmp125 = __cil_tmp124 + 2184UL;
    __cil_tmp126 = (struct mutex *)__cil_tmp125;
    mutex_unlock(__cil_tmp126);
    goto out_err0;
  }
  __cil_tmp127 = (unsigned long )dev_priv;
  __cil_tmp128 = __cil_tmp127 + 2156UL;
  *((uint32_t *)__cil_tmp128) = vmw_read(dev_priv, 17U);
  __cil_tmp129 = (unsigned long )dev_priv;
  __cil_tmp130 = __cil_tmp129 + 2112UL;
  *((uint32_t *)__cil_tmp130) = vmw_read(dev_priv, 15U);
  __cil_tmp131 = (unsigned long )dev_priv;
  __cil_tmp132 = __cil_tmp131 + 2120UL;
  *((uint32_t *)__cil_tmp132) = vmw_read(dev_priv, 19U);
  __cil_tmp133 = (unsigned long )dev_priv;
  __cil_tmp134 = __cil_tmp133 + 2124UL;
  *((uint32_t *)__cil_tmp134) = vmw_read(dev_priv, 4U);
  __cil_tmp135 = (unsigned long )dev_priv;
  __cil_tmp136 = __cil_tmp135 + 2128UL;
  *((uint32_t *)__cil_tmp136) = vmw_read(dev_priv, 5U);
  vmw_get_initial_size(dev_priv);
  __cil_tmp137 = (unsigned long )dev_priv;
  __cil_tmp138 = __cil_tmp137 + 2156UL;
  __cil_tmp139 = *((uint32_t *)__cil_tmp138);
  if (__cil_tmp139 & 1048576U) {
    __cil_tmp140 = (unsigned long )dev_priv;
    __cil_tmp141 = __cil_tmp140 + 2160UL;
    *((uint32_t *)__cil_tmp141) = vmw_read(dev_priv, 44U);
    __cil_tmp142 = (unsigned long )dev_priv;
    __cil_tmp143 = __cil_tmp142 + 2164UL;
    *((uint32_t *)__cil_tmp143) = vmw_read(dev_priv, 43U);
  }
  __cil_tmp144 = (unsigned long )dev_priv;
  __cil_tmp145 = __cil_tmp144 + 2156UL;
  __cil_tmp146 = *((uint32_t *)__cil_tmp145);
  if (__cil_tmp146 & 4194304U) {
    __cil_tmp147 = (unsigned long )dev_priv;
    __cil_tmp148 = __cil_tmp147 + 2168UL;
    *((uint32_t *)__cil_tmp148) = vmw_read(dev_priv, 46U);
    __cil_tmp149 = (unsigned long )dev_priv;
    __cil_tmp150 = __cil_tmp149 + 2172UL;
    *((uint32_t *)__cil_tmp150) = vmw_read(dev_priv, 47U);
    __cil_tmp151 = (unsigned long )dev_priv;
    __cil_tmp152 = __cil_tmp151 + 2172UL;
    __cil_tmp153 = (unsigned long )dev_priv;
    __cil_tmp154 = __cil_tmp153 + 2112UL;
    __cil_tmp155 = *((uint32_t *)__cil_tmp154);
    __cil_tmp156 = (unsigned long )dev_priv;
    __cil_tmp157 = __cil_tmp156 + 2172UL;
    __cil_tmp158 = *((uint32_t *)__cil_tmp157);
    *((uint32_t *)__cil_tmp152) = __cil_tmp158 - __cil_tmp155;
  } else {
    __cil_tmp159 = (unsigned long )dev_priv;
    __cil_tmp160 = __cil_tmp159 + 2172UL;
    *((uint32_t *)__cil_tmp160) = (uint32_t )536870912;
  }
  __cil_tmp161 = (unsigned long )dev_priv;
  __cil_tmp162 = __cil_tmp161 + 2184UL;
  __cil_tmp163 = (struct mutex *)__cil_tmp162;
  mutex_unlock(__cil_tmp163);
  __cil_tmp164 = (unsigned long )dev_priv;
  __cil_tmp165 = __cil_tmp164 + 2156UL;
  __cil_tmp166 = *((uint32_t *)__cil_tmp165);
  vmw_print_capabilities(__cil_tmp166);
  __cil_tmp167 = (unsigned long )dev_priv;
  __cil_tmp168 = __cil_tmp167 + 2156UL;
  __cil_tmp169 = *((uint32_t *)__cil_tmp168);
  if (__cil_tmp169 & 1048576U) {
    __cil_tmp170 = (unsigned long )dev_priv;
    __cil_tmp171 = __cil_tmp170 + 2164UL;
    __cil_tmp172 = *((uint32_t *)__cil_tmp171);
    printk("<6>[drm] Max GMR ids is %u\n", __cil_tmp172);
    __cil_tmp173 = (unsigned long )dev_priv;
    __cil_tmp174 = __cil_tmp173 + 2160UL;
    __cil_tmp175 = *((uint32_t *)__cil_tmp174);
    printk("<6>[drm] Max GMR descriptors is %u\n", __cil_tmp175);
  }
  __cil_tmp176 = (unsigned long )dev_priv;
  __cil_tmp177 = __cil_tmp176 + 2156UL;
  __cil_tmp178 = *((uint32_t *)__cil_tmp177);
  if (__cil_tmp178 & 4194304U) {
    __cil_tmp179 = (unsigned long )dev_priv;
    __cil_tmp180 = __cil_tmp179 + 2168UL;
    __cil_tmp181 = *((uint32_t *)__cil_tmp180);
    printk("<6>[drm] Max number of GMR pages is %u\n", __cil_tmp181);
    __cil_tmp182 = (unsigned long )dev_priv;
    __cil_tmp183 = __cil_tmp182 + 2172UL;
    __cil_tmp184 = *((uint32_t *)__cil_tmp183);
    __cil_tmp185 = __cil_tmp184 / 1024U;
    printk("<6>[drm] Max dedicated hypervisor surface memory is %u kiB\n", __cil_tmp185);
  }
  __cil_tmp186 = (unsigned long )dev_priv;
  __cil_tmp187 = __cil_tmp186 + 2108UL;
  __cil_tmp188 = *((uint32_t *)__cil_tmp187);
  __cil_tmp189 = (unsigned long )dev_priv;
  __cil_tmp190 = __cil_tmp189 + 2112UL;
  __cil_tmp191 = *((uint32_t *)__cil_tmp190);
  __cil_tmp192 = __cil_tmp191 / 1024U;
  printk("<6>[drm] VRAM at 0x%08x size is %u kiB\n", __cil_tmp188, __cil_tmp192);
  __cil_tmp193 = (unsigned long )dev_priv;
  __cil_tmp194 = __cil_tmp193 + 2116UL;
  __cil_tmp195 = *((uint32_t *)__cil_tmp194);
  __cil_tmp196 = (unsigned long )dev_priv;
  __cil_tmp197 = __cil_tmp196 + 2120UL;
  __cil_tmp198 = *((uint32_t *)__cil_tmp197);
  __cil_tmp199 = __cil_tmp198 / 1024U;
  printk("<6>[drm] MMIO at 0x%08x size is %u kiB\n", __cil_tmp195, __cil_tmp199);
  ret = vmw_ttm_global_init(dev_priv);
  __cil_tmp200 = ret != 0;
  __cil_tmp201 = ! __cil_tmp200;
  __cil_tmp202 = ! __cil_tmp201;
  __cil_tmp203 = (long )__cil_tmp202;
  tmp___9 = ldv__builtin_expect(__cil_tmp203, 0L);
  if (tmp___9) {
    goto out_err0;
  }
  __cil_tmp204 = (unsigned long )dev_priv;
  __cil_tmp205 = __cil_tmp204 + 134392UL;
  __cil_tmp206 = (struct vmw_master *)__cil_tmp205;
  vmw_master_init(__cil_tmp206);
  __cil_tmp207 = (unsigned long )dev_priv;
  __cil_tmp208 = __cil_tmp207 + 134392UL;
  __cil_tmp209 = (struct ttm_lock *)__cil_tmp208;
  __cil_tmp210 = (bool )0;
  ttm_lock_set_kill(__cil_tmp209, __cil_tmp210, 15);
  __cil_tmp211 = (unsigned long )dev_priv;
  __cil_tmp212 = __cil_tmp211 + 134384UL;
  __cil_tmp213 = (unsigned long )dev_priv;
  __cil_tmp214 = __cil_tmp213 + 134392UL;
  *((struct vmw_master **)__cil_tmp212) = (struct vmw_master *)__cil_tmp214;
  __cil_tmp215 = (struct ttm_bo_device *)dev_priv;
  __cil_tmp216 = 16;
  __cil_tmp217 = 1768UL + __cil_tmp216;
  __cil_tmp218 = (unsigned long )dev_priv;
  __cil_tmp219 = __cil_tmp218 + __cil_tmp217;
  __cil_tmp220 = *((void **)__cil_tmp219);
  __cil_tmp221 = (struct ttm_bo_global *)__cil_tmp220;
  __cil_tmp222 = (uint64_t )1048576;
  __cil_tmp223 = (bool )0;
  ret = ttm_bo_device_init(__cil_tmp215, __cil_tmp221, & vmw_bo_driver, __cil_tmp222,
                           __cil_tmp223);
  __cil_tmp224 = ret != 0;
  __cil_tmp225 = ! __cil_tmp224;
  __cil_tmp226 = ! __cil_tmp225;
  __cil_tmp227 = (long )__cil_tmp226;
  tmp___10 = ldv__builtin_expect(__cil_tmp227, 0L);
  if (tmp___10) {
    drm_err("vmw_driver_load", "Failed initializing TTM buffer object driver.\n");
    goto out_err1;
  }
  __cil_tmp228 = (struct ttm_bo_device *)dev_priv;
  __cil_tmp229 = (unsigned long )dev_priv;
  __cil_tmp230 = __cil_tmp229 + 2112UL;
  __cil_tmp231 = *((uint32_t *)__cil_tmp230);
  __cil_tmp232 = __cil_tmp231 >> 12;
  __cil_tmp233 = (unsigned long )__cil_tmp232;
  ret = ttm_bo_init_mm(__cil_tmp228, 2U, __cil_tmp233);
  __cil_tmp234 = ret != 0;
  __cil_tmp235 = ! __cil_tmp234;
  __cil_tmp236 = ! __cil_tmp235;
  __cil_tmp237 = (long )__cil_tmp236;
  tmp___11 = ldv__builtin_expect(__cil_tmp237, 0L);
  if (tmp___11) {
    drm_err("vmw_driver_load", "Failed initializing memory manager for VRAM.\n");
    goto out_err2;
  }
  __cil_tmp238 = (unsigned long )dev_priv;
  __cil_tmp239 = __cil_tmp238 + 2176UL;
  *((bool *)__cil_tmp239) = (bool )1;
  __cil_tmp240 = (struct ttm_bo_device *)dev_priv;
  __cil_tmp241 = (unsigned long )dev_priv;
  __cil_tmp242 = __cil_tmp241 + 2164UL;
  __cil_tmp243 = *((uint32_t *)__cil_tmp242);
  __cil_tmp244 = (unsigned long )__cil_tmp243;
  tmp___12 = ttm_bo_init_mm(__cil_tmp240, 3U, __cil_tmp244);
  if (tmp___12 != 0) {
    printk("<6>[drm] No GMR memory available. Graphics memory resources are very limited.\n");
    __cil_tmp245 = (unsigned long )dev_priv;
    __cil_tmp246 = __cil_tmp245 + 2176UL;
    *((bool *)__cil_tmp246) = (bool )0;
  }
  __cil_tmp247 = (unsigned long )dev_priv;
  __cil_tmp248 = __cil_tmp247 + 2152UL;
  __cil_tmp249 = (unsigned long )dev_priv;
  __cil_tmp250 = __cil_tmp249 + 2116UL;
  __cil_tmp251 = *((uint32_t *)__cil_tmp250);
  __cil_tmp252 = (unsigned long )__cil_tmp251;
  __cil_tmp253 = (unsigned long )dev_priv;
  __cil_tmp254 = __cil_tmp253 + 2120UL;
  __cil_tmp255 = *((uint32_t *)__cil_tmp254);
  __cil_tmp256 = (unsigned long )__cil_tmp255;
  *((int *)__cil_tmp248) = drm_mtrr_add(__cil_tmp252, __cil_tmp256, 1U);
  __cil_tmp257 = (unsigned long )dev_priv;
  __cil_tmp258 = __cil_tmp257 + 2116UL;
  __cil_tmp259 = *((uint32_t *)__cil_tmp258);
  __cil_tmp260 = (resource_size_t )__cil_tmp259;
  __cil_tmp261 = (unsigned long )dev_priv;
  __cil_tmp262 = __cil_tmp261 + 2120UL;
  __cil_tmp263 = *((uint32_t *)__cil_tmp262);
  __cil_tmp264 = (unsigned long )__cil_tmp263;
  tmp___13 = ioremap_wc(__cil_tmp260, __cil_tmp264);
  __cil_tmp265 = (unsigned long )dev_priv;
  __cil_tmp266 = __cil_tmp265 + 2144UL;
  *((__le32 **)__cil_tmp266) = (__le32 *)tmp___13;
  __cil_tmp267 = (void *)0;
  __cil_tmp268 = (unsigned long )__cil_tmp267;
  __cil_tmp269 = (unsigned long )dev_priv;
  __cil_tmp270 = __cil_tmp269 + 2144UL;
  __cil_tmp271 = *((__le32 **)__cil_tmp270);
  __cil_tmp272 = (unsigned long )__cil_tmp271;
  __cil_tmp273 = __cil_tmp272 == __cil_tmp268;
  __cil_tmp274 = ! __cil_tmp273;
  __cil_tmp275 = ! __cil_tmp274;
  __cil_tmp276 = (long )__cil_tmp275;
  tmp___14 = ldv__builtin_expect(__cil_tmp276, 0L);
  if (tmp___14) {
    ret = -12;
    drm_err("vmw_driver_load", "Failed mapping MMIO.\n");
    goto out_err3;
  }
  __cil_tmp277 = (unsigned long )dev_priv;
  __cil_tmp278 = __cil_tmp277 + 2156UL;
  __cil_tmp279 = *((uint32_t *)__cil_tmp278);
  __cil_tmp280 = __cil_tmp279 & 524288U;
  if (! __cil_tmp280) {
    __cil_tmp281 = (unsigned long )dev_priv;
    __cil_tmp282 = __cil_tmp281 + 2156UL;
    __cil_tmp283 = *((uint32_t *)__cil_tmp282);
    __cil_tmp284 = __cil_tmp283 & 131072U;
    if (! __cil_tmp284) {
      tmp___15 = vmw_fifo_have_pitchlock(dev_priv);
      if (! tmp___15) {
        ret = -38;
        drm_err("vmw_driver_load", "Hardware has no pitchlock\n");
        goto out_err4;
      }
    }
  }
  __cil_tmp285 = (unsigned long )dev_priv;
  __cil_tmp286 = __cil_tmp285 + 2872UL;
  __cil_tmp287 = 1832;
  __cil_tmp288 = (unsigned long )dev_priv;
  __cil_tmp289 = __cil_tmp288 + __cil_tmp287;
  __cil_tmp290 = *((void **)__cil_tmp289);
  __cil_tmp291 = (struct ttm_mem_global *)__cil_tmp290;
  *((struct ttm_object_device **)__cil_tmp286) = ttm_object_device_init(__cil_tmp291,
                                                                        12U);
  __cil_tmp292 = (void *)0;
  __cil_tmp293 = (unsigned long )__cil_tmp292;
  __cil_tmp294 = (unsigned long )dev_priv;
  __cil_tmp295 = __cil_tmp294 + 2872UL;
  __cil_tmp296 = *((struct ttm_object_device **)__cil_tmp295);
  __cil_tmp297 = (unsigned long )__cil_tmp296;
  __cil_tmp298 = __cil_tmp297 == __cil_tmp293;
  __cil_tmp299 = ! __cil_tmp298;
  __cil_tmp300 = ! __cil_tmp299;
  __cil_tmp301 = (long )__cil_tmp300;
  tmp___16 = ldv__builtin_expect(__cil_tmp301, 0L);
  if (tmp___16) {
    drm_err("vmw_driver_load", "Unable to initialize TTM object management.\n");
    ret = -12;
    goto out_err4;
  }
  __cil_tmp302 = (unsigned long )dev;
  __cil_tmp303 = __cil_tmp302 + 1064UL;
  *((void **)__cil_tmp303) = (void *)dev_priv;
  __cil_tmp304 = (unsigned long )dev;
  __cil_tmp305 = __cil_tmp304 + 1016UL;
  __cil_tmp306 = *((struct pci_dev **)__cil_tmp305);
  tmp = (int )pci_request_regions(__cil_tmp306, "vmwgfx probe");
  ret = tmp;
  __cil_tmp307 = (unsigned long )dev_priv;
  __cil_tmp308 = __cil_tmp307 + 134376UL;
  __cil_tmp309 = ret != 0;
  *((bool *)__cil_tmp308) = (bool )__cil_tmp309;
  __cil_tmp310 = (unsigned long )dev_priv;
  __cil_tmp311 = __cil_tmp310 + 134376UL;
  if (*((bool *)__cil_tmp311)) {
    printk("<6>[drm] It appears like vesafb is loaded. Ignore above error if any.\n");
    __cil_tmp312 = (unsigned long )dev;
    __cil_tmp313 = __cil_tmp312 + 1016UL;
    __cil_tmp314 = *((struct pci_dev **)__cil_tmp313);
    tmp___25 = (int )pci_request_region(__cil_tmp314, 2, "vmwgfx stealth probe");
    ret = tmp___25;
    __cil_tmp315 = ret != 0;
    __cil_tmp316 = ! __cil_tmp315;
    __cil_tmp317 = ! __cil_tmp316;
    __cil_tmp318 = (long )__cil_tmp317;
    tmp___17 = ldv__builtin_expect(__cil_tmp318, 0L);
    if (tmp___17) {
      drm_err("vmw_driver_load", "Failed reserving the SVGA MMIO resource.\n");
      goto out_no_device;
    }
  }
  __cil_tmp319 = (unsigned long )dev_priv;
  __cil_tmp320 = __cil_tmp319 + 3008UL;
  *((struct vmw_fence_manager **)__cil_tmp320) = vmw_fence_manager_init(dev_priv);
  __cil_tmp321 = (void *)0;
  __cil_tmp322 = (unsigned long )__cil_tmp321;
  __cil_tmp323 = (unsigned long )dev_priv;
  __cil_tmp324 = __cil_tmp323 + 3008UL;
  __cil_tmp325 = *((struct vmw_fence_manager **)__cil_tmp324);
  __cil_tmp326 = (unsigned long )__cil_tmp325;
  __cil_tmp327 = __cil_tmp326 == __cil_tmp322;
  __cil_tmp328 = ! __cil_tmp327;
  __cil_tmp329 = ! __cil_tmp328;
  __cil_tmp330 = (long )__cil_tmp329;
  tmp___18 = ldv__builtin_expect(__cil_tmp330, 0L);
  if (tmp___18) {
    goto out_no_fman;
  }
  __cil_tmp331 = (bool )1;
  ret = vmw_3d_resource_inc(dev_priv, __cil_tmp331);
  __cil_tmp332 = ret != 0;
  __cil_tmp333 = ! __cil_tmp332;
  __cil_tmp334 = ! __cil_tmp333;
  __cil_tmp335 = (long )__cil_tmp334;
  tmp___19 = ldv__builtin_expect(__cil_tmp335, 0L);
  if (tmp___19) {
    goto out_no_fifo;
  }
  vmw_kms_save_vga(dev_priv);
  ret = vmw_kms_init(dev_priv);
  __cil_tmp336 = ret != 0;
  __cil_tmp337 = ! __cil_tmp336;
  __cil_tmp338 = ! __cil_tmp337;
  __cil_tmp339 = (long )__cil_tmp338;
  tmp___20 = ldv__builtin_expect(__cil_tmp339, 0L);
  if (tmp___20) {
    goto out_no_kms;
  }
  vmw_overlay_init(dev_priv);
  tmp___23 = vmw_fifo_have_3d(dev_priv);
  if (tmp___23) {
    tmp___22 = "";
  } else {
    tmp___22 = "no ";
  }
  printk("<6>[drm] Detected %sdevice 3D availability.\n", tmp___22);
  __cil_tmp340 = (unsigned long )dev_priv;
  __cil_tmp341 = __cil_tmp340 + 134378UL;
  if (*((bool *)__cil_tmp341)) {
    vmw_fb_init(dev_priv);
  } else {
    vmw_kms_restore_vga(dev_priv);
    __cil_tmp342 = (bool )1;
    vmw_3d_resource_dec(dev_priv, __cil_tmp342);
  }
  __cil_tmp343 = (unsigned long )dev_priv;
  __cil_tmp344 = __cil_tmp343 + 2156UL;
  __cil_tmp345 = *((uint32_t *)__cil_tmp344);
  if (__cil_tmp345 & 262144U) {
    ret = drm_irq_install(dev);
    __cil_tmp346 = ret != 0;
    __cil_tmp347 = ! __cil_tmp346;
    __cil_tmp348 = ! __cil_tmp347;
    __cil_tmp349 = (long )__cil_tmp348;
    tmp___24 = ldv__builtin_expect(__cil_tmp349, 0L);
    if (tmp___24) {
      drm_err("vmw_driver_load", "Failed installing irq: %d\n", ret);
      goto out_no_irq;
    }
  }
  __cil_tmp350 = (unsigned long )dev_priv;
  __cil_tmp351 = __cil_tmp350 + 134632UL;
  *((int (**)(struct notifier_block * , unsigned long  , void * ))__cil_tmp351) = & vmwgfx_pm_notifier;
  __cil_tmp352 = (unsigned long )dev_priv;
  __cil_tmp353 = __cil_tmp352 + 134632UL;
  __cil_tmp354 = (struct notifier_block *)__cil_tmp353;
  register_pm_notifier(__cil_tmp354);
  return (0);
  out_no_irq: 
  __cil_tmp355 = (unsigned long )dev_priv;
  __cil_tmp356 = __cil_tmp355 + 134378UL;
  if (*((bool *)__cil_tmp356)) {
    vmw_fb_close(dev_priv);
  }
  vmw_overlay_close(dev_priv);
  vmw_kms_close(dev_priv);
  out_no_kms: 
  __cil_tmp357 = (unsigned long )dev_priv;
  __cil_tmp358 = __cil_tmp357 + 134378UL;
  if (*((bool *)__cil_tmp358)) {
    vmw_kms_restore_vga(dev_priv);
    __cil_tmp359 = (bool )0;
    vmw_3d_resource_dec(dev_priv, __cil_tmp359);
  }
  out_no_fifo: 
  __cil_tmp360 = (unsigned long )dev_priv;
  __cil_tmp361 = __cil_tmp360 + 3008UL;
  __cil_tmp362 = *((struct vmw_fence_manager **)__cil_tmp361);
  vmw_fence_manager_takedown(__cil_tmp362);
  out_no_fman: 
  __cil_tmp363 = (unsigned long )dev_priv;
  __cil_tmp364 = __cil_tmp363 + 134376UL;
  if (*((bool *)__cil_tmp364)) {
    __cil_tmp365 = (unsigned long )dev;
    __cil_tmp366 = __cil_tmp365 + 1016UL;
    __cil_tmp367 = *((struct pci_dev **)__cil_tmp366);
    pci_release_region(__cil_tmp367, 2);
  } else {
    __cil_tmp368 = (unsigned long )dev;
    __cil_tmp369 = __cil_tmp368 + 1016UL;
    __cil_tmp370 = *((struct pci_dev **)__cil_tmp369);
    pci_release_regions(__cil_tmp370);
  }
  out_no_device: 
  __cil_tmp371 = (unsigned long )dev_priv;
  __cil_tmp372 = __cil_tmp371 + 2872UL;
  __cil_tmp373 = (struct ttm_object_device **)__cil_tmp372;
  ttm_object_device_release(__cil_tmp373);
  out_err4: 
  __cil_tmp374 = (unsigned long )dev_priv;
  __cil_tmp375 = __cil_tmp374 + 2144UL;
  __cil_tmp376 = *((__le32 **)__cil_tmp375);
  __cil_tmp377 = (void volatile   *)__cil_tmp376;
  iounmap(__cil_tmp377);
  out_err3: 
  __cil_tmp378 = (unsigned long )dev_priv;
  __cil_tmp379 = __cil_tmp378 + 2152UL;
  __cil_tmp380 = *((int *)__cil_tmp379);
  __cil_tmp381 = (unsigned long )dev_priv;
  __cil_tmp382 = __cil_tmp381 + 2116UL;
  __cil_tmp383 = *((uint32_t *)__cil_tmp382);
  __cil_tmp384 = (unsigned long )__cil_tmp383;
  __cil_tmp385 = (unsigned long )dev_priv;
  __cil_tmp386 = __cil_tmp385 + 2120UL;
  __cil_tmp387 = *((uint32_t *)__cil_tmp386);
  __cil_tmp388 = (unsigned long )__cil_tmp387;
  drm_mtrr_del(__cil_tmp380, __cil_tmp384, __cil_tmp388, 1U);
  __cil_tmp389 = (unsigned long )dev_priv;
  __cil_tmp390 = __cil_tmp389 + 2176UL;
  if (*((bool *)__cil_tmp390)) {
    __cil_tmp391 = (struct ttm_bo_device *)dev_priv;
    ttm_bo_clean_mm(__cil_tmp391, 3U);
  }
  __cil_tmp392 = (struct ttm_bo_device *)dev_priv;
  ttm_bo_clean_mm(__cil_tmp392, 2U);
  out_err2: 
  __cil_tmp393 = (struct ttm_bo_device *)dev_priv;
  ttm_bo_device_release(__cil_tmp393);
  out_err1: 
  vmw_ttm_global_release(dev_priv);
  out_err0: 
  __cil_tmp394 = (unsigned long )dev_priv;
  __cil_tmp395 = __cil_tmp394 + 2704UL;
  __cil_tmp396 = (struct idr *)__cil_tmp395;
  idr_destroy(__cil_tmp396);
  __cil_tmp397 = (unsigned long )dev_priv;
  __cil_tmp398 = __cil_tmp397 + 2656UL;
  __cil_tmp399 = (struct idr *)__cil_tmp398;
  idr_destroy(__cil_tmp399);
  __cil_tmp400 = (unsigned long )dev_priv;
  __cil_tmp401 = __cil_tmp400 + 2752UL;
  __cil_tmp402 = (struct idr *)__cil_tmp401;
  idr_destroy(__cil_tmp402);
  __cil_tmp403 = (void *)dev_priv;
  kfree(__cil_tmp403);
  return (ret);
}
}
static int vmw_driver_unload(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct notifier_block *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_device *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  bool __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_fence_manager *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct pci_dev *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct pci_dev *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct ttm_object_device **__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void volatile   *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  uint32_t __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_bo_device *__cil_tmp55 ;
  struct ttm_bo_device *__cil_tmp56 ;
  struct ttm_bo_device *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct idr *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct idr *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct idr *__cil_tmp66 ;
  void *__cil_tmp67 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 134632UL;
  __cil_tmp6 = (struct notifier_block *)__cil_tmp5;
  unregister_pm_notifier(__cil_tmp6);
  __cil_tmp7 = 134232;
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
  if (*((uint32_t **)__cil_tmp9)) {
    __cil_tmp10 = 134232;
    __cil_tmp11 = (unsigned long )dev_priv;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    __cil_tmp13 = *((uint32_t **)__cil_tmp12);
    __cil_tmp14 = (void *)__cil_tmp13;
    vfree(__cil_tmp14);
  }
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2156UL;
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
  if (__cil_tmp17 & 262144U) {
    __cil_tmp18 = (unsigned long )dev_priv;
    __cil_tmp19 = __cil_tmp18 + 2088UL;
    __cil_tmp20 = *((struct drm_device **)__cil_tmp19);
    drm_irq_uninstall(__cil_tmp20);
  }
  __cil_tmp21 = (unsigned long )dev_priv;
  __cil_tmp22 = __cil_tmp21 + 134378UL;
  if (*((bool *)__cil_tmp22)) {
    vmw_fb_close(dev_priv);
    vmw_kms_restore_vga(dev_priv);
    __cil_tmp23 = (bool )0;
    vmw_3d_resource_dec(dev_priv, __cil_tmp23);
  }
  vmw_kms_close(dev_priv);
  vmw_overlay_close(dev_priv);
  __cil_tmp24 = (unsigned long )dev_priv;
  __cil_tmp25 = __cil_tmp24 + 3008UL;
  __cil_tmp26 = *((struct vmw_fence_manager **)__cil_tmp25);
  vmw_fence_manager_takedown(__cil_tmp26);
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 134376UL;
  if (*((bool *)__cil_tmp28)) {
    __cil_tmp29 = (unsigned long )dev;
    __cil_tmp30 = __cil_tmp29 + 1016UL;
    __cil_tmp31 = *((struct pci_dev **)__cil_tmp30);
    pci_release_region(__cil_tmp31, 2);
  } else {
    __cil_tmp32 = (unsigned long )dev;
    __cil_tmp33 = __cil_tmp32 + 1016UL;
    __cil_tmp34 = *((struct pci_dev **)__cil_tmp33);
    pci_release_regions(__cil_tmp34);
  }
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2872UL;
  __cil_tmp37 = (struct ttm_object_device **)__cil_tmp36;
  ttm_object_device_release(__cil_tmp37);
  __cil_tmp38 = (unsigned long )dev_priv;
  __cil_tmp39 = __cil_tmp38 + 2144UL;
  __cil_tmp40 = *((__le32 **)__cil_tmp39);
  __cil_tmp41 = (void volatile   *)__cil_tmp40;
  iounmap(__cil_tmp41);
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 2152UL;
  __cil_tmp44 = *((int *)__cil_tmp43);
  __cil_tmp45 = (unsigned long )dev_priv;
  __cil_tmp46 = __cil_tmp45 + 2116UL;
  __cil_tmp47 = *((uint32_t *)__cil_tmp46);
  __cil_tmp48 = (unsigned long )__cil_tmp47;
  __cil_tmp49 = (unsigned long )dev_priv;
  __cil_tmp50 = __cil_tmp49 + 2120UL;
  __cil_tmp51 = *((uint32_t *)__cil_tmp50);
  __cil_tmp52 = (unsigned long )__cil_tmp51;
  drm_mtrr_del(__cil_tmp44, __cil_tmp48, __cil_tmp52, 1U);
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 2176UL;
  if (*((bool *)__cil_tmp54)) {
    __cil_tmp55 = (struct ttm_bo_device *)dev_priv;
    ttm_bo_clean_mm(__cil_tmp55, 3U);
  }
  __cil_tmp56 = (struct ttm_bo_device *)dev_priv;
  ttm_bo_clean_mm(__cil_tmp56, 2U);
  __cil_tmp57 = (struct ttm_bo_device *)dev_priv;
  ttm_bo_device_release(__cil_tmp57);
  vmw_ttm_global_release(dev_priv);
  __cil_tmp58 = (unsigned long )dev_priv;
  __cil_tmp59 = __cil_tmp58 + 2704UL;
  __cil_tmp60 = (struct idr *)__cil_tmp59;
  idr_destroy(__cil_tmp60);
  __cil_tmp61 = (unsigned long )dev_priv;
  __cil_tmp62 = __cil_tmp61 + 2656UL;
  __cil_tmp63 = (struct idr *)__cil_tmp62;
  idr_destroy(__cil_tmp63);
  __cil_tmp64 = (unsigned long )dev_priv;
  __cil_tmp65 = __cil_tmp64 + 2752UL;
  __cil_tmp66 = (struct idr *)__cil_tmp65;
  idr_destroy(__cil_tmp66);
  __cil_tmp67 = (void *)dev_priv;
  kfree(__cil_tmp67);
  return (0);
}
}
static void vmw_preclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_fence_manager *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct list_head *__cil_tmp12 ;

  {
  tmp___7 = vmw_fpriv(file_priv);
  vmw_fp = tmp___7;
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 3008UL;
  __cil_tmp9 = *((struct vmw_fence_manager **)__cil_tmp8);
  __cil_tmp10 = (unsigned long )vmw_fp;
  __cil_tmp11 = __cil_tmp10 + 16UL;
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
  vmw_event_fence_fpriv_gone(__cil_tmp9, __cil_tmp12);
  return;
}
}
static void vmw_postclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct ttm_object_file **__cil_tmp6 ;
  struct drm_master **__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  vmw_fp = vmw_fpriv(file_priv);
  __cil_tmp4 = (unsigned long )vmw_fp;
  __cil_tmp5 = __cil_tmp4 + 8UL;
  __cil_tmp6 = (struct ttm_object_file **)__cil_tmp5;
  ttm_object_file_release(__cil_tmp6);
  if (*((struct drm_master **)vmw_fp)) {
    __cil_tmp7 = (struct drm_master **)vmw_fp;
    drm_master_put(__cil_tmp7);
  }
  __cil_tmp8 = (void *)vmw_fp;
  kfree(__cil_tmp8);
  return;
}
}
static int vmw_driver_open(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  int ret ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct ttm_object_device *__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_object_file *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct address_space *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct file *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct dentry *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct inode *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  void *__cil_tmp64 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  ret = -12;
  tmp___8 = kzalloc(32UL, 208U);
  vmw_fp = (struct vmw_fpriv *)tmp___8;
  __cil_tmp11 = (void *)0;
  __cil_tmp12 = (unsigned long )__cil_tmp11;
  __cil_tmp13 = (unsigned long )vmw_fp;
  __cil_tmp14 = __cil_tmp13 == __cil_tmp12;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = (long )__cil_tmp16;
  tmp___9 = ldv__builtin_expect(__cil_tmp17, 0L);
  if (tmp___9) {
    return (ret);
  }
  __cil_tmp18 = (unsigned long )vmw_fp;
  __cil_tmp19 = __cil_tmp18 + 16UL;
  __cil_tmp20 = (struct list_head *)__cil_tmp19;
  INIT_LIST_HEAD(__cil_tmp20);
  __cil_tmp21 = (unsigned long )vmw_fp;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  __cil_tmp23 = (unsigned long )dev_priv;
  __cil_tmp24 = __cil_tmp23 + 2872UL;
  __cil_tmp25 = *((struct ttm_object_device **)__cil_tmp24);
  *((struct ttm_object_file **)__cil_tmp22) = ttm_object_file_init(__cil_tmp25, 10U);
  __cil_tmp26 = (void *)0;
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = (unsigned long )vmw_fp;
  __cil_tmp29 = __cil_tmp28 + 8UL;
  __cil_tmp30 = *((struct ttm_object_file **)__cil_tmp29);
  __cil_tmp31 = (unsigned long )__cil_tmp30;
  __cil_tmp32 = __cil_tmp31 == __cil_tmp27;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = (long )__cil_tmp34;
  tmp___10 = ldv__builtin_expect(__cil_tmp35, 0L);
  if (tmp___10) {
    goto out_no_tfile;
  }
  __cil_tmp36 = (unsigned long )file_priv;
  __cil_tmp37 = __cil_tmp36 + 136UL;
  *((void **)__cil_tmp37) = (void *)vmw_fp;
  __cil_tmp38 = (void *)0;
  __cil_tmp39 = (unsigned long )__cil_tmp38;
  __cil_tmp40 = 1640;
  __cil_tmp41 = (unsigned long )dev_priv;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  __cil_tmp43 = *((struct address_space **)__cil_tmp42);
  __cil_tmp44 = (unsigned long )__cil_tmp43;
  __cil_tmp45 = __cil_tmp44 == __cil_tmp39;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = ! __cil_tmp46;
  __cil_tmp48 = (long )__cil_tmp47;
  tmp___11 = ldv__builtin_expect(__cil_tmp48, 0L);
  if (tmp___11) {
    __cil_tmp49 = 1640;
    __cil_tmp50 = (unsigned long )dev_priv;
    __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
    __cil_tmp52 = 24;
    __cil_tmp53 = (unsigned long )file_priv;
    __cil_tmp54 = __cil_tmp53 + 128UL;
    __cil_tmp55 = *((struct file **)__cil_tmp54);
    __cil_tmp56 = (unsigned long )__cil_tmp55;
    __cil_tmp57 = __cil_tmp56 + __cil_tmp52;
    __cil_tmp58 = *((struct dentry **)__cil_tmp57);
    __cil_tmp59 = (unsigned long )__cil_tmp58;
    __cil_tmp60 = __cil_tmp59 + 48UL;
    __cil_tmp61 = *((struct inode **)__cil_tmp60);
    __cil_tmp62 = (unsigned long )__cil_tmp61;
    __cil_tmp63 = __cil_tmp62 + 48UL;
    *((struct address_space **)__cil_tmp51) = *((struct address_space **)__cil_tmp63);
  }
  return (0);
  out_no_tfile: 
  __cil_tmp64 = (void *)vmw_fp;
  kfree(__cil_tmp64);
  return (ret);
}
}
static long vmw_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ struct drm_file *file_priv ;
  struct drm_device *dev ;
  unsigned int nr ;
  struct drm_ioctl_desc *ioctl ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_minor *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct drm_driver *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;

  {
  __cil_tmp10 = (unsigned long )filp;
  __cil_tmp11 = __cil_tmp10 + 200UL;
  __cil_tmp12 = *((void **)__cil_tmp11);
  file_priv = (struct drm_file *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )file_priv;
  __cil_tmp14 = __cil_tmp13 + 40UL;
  __cil_tmp15 = *((struct drm_minor **)__cil_tmp14);
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  __cil_tmp17 = __cil_tmp16 + 784UL;
  dev = *((struct drm_device **)__cil_tmp17);
  __cil_tmp18 = 1 << 8;
  __cil_tmp19 = __cil_tmp18 - 1;
  __cil_tmp20 = (unsigned int )__cil_tmp19;
  nr = cmd & __cil_tmp20;
  if (nr >= 64U) {
    if (nr < 160U) {
      __cil_tmp21 = (unsigned long )dev;
      __cil_tmp22 = __cil_tmp21 + 1112UL;
      __cil_tmp23 = *((struct drm_driver **)__cil_tmp22);
      __cil_tmp24 = (unsigned long )__cil_tmp23;
      __cil_tmp25 = __cil_tmp24 + 416UL;
      __cil_tmp26 = *((int *)__cil_tmp25);
      __cil_tmp27 = 64 + __cil_tmp26;
      __cil_tmp28 = (unsigned int )__cil_tmp27;
      if (nr < __cil_tmp28) {
        __cil_tmp29 = nr - 64U;
        __cil_tmp30 = (unsigned long )__cil_tmp29 * 24UL;
        __cil_tmp31 = (unsigned long )(vmw_ioctls) + __cil_tmp30;
        ioctl = (struct drm_ioctl_desc *)__cil_tmp31;
        __cil_tmp32 = (unsigned long )ioctl;
        __cil_tmp33 = __cil_tmp32 + 16UL;
        __cil_tmp34 = *((unsigned int *)__cil_tmp33);
        __cil_tmp35 = __cil_tmp34 != cmd;
        __cil_tmp36 = ! __cil_tmp35;
        __cil_tmp37 = ! __cil_tmp36;
        __cil_tmp38 = (long )__cil_tmp37;
        tmp___7 = ldv__builtin_expect(__cil_tmp38, 0L);
        if (tmp___7) {
          __cil_tmp39 = nr - 64U;
          drm_err("vmw_unlocked_ioctl", "Invalid command format, ioctl %d\n", __cil_tmp39);
          return (-22L);
        }
      }
    }
  }
  tmp___8 = drm_ioctl(filp, cmd, arg);
  return (tmp___8);
}
}
static int vmw_firstopen(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 134377UL;
  *((bool *)__cil_tmp5) = (bool )1;
  return (0);
}
}
static void vmw_lastclose(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_crtc *crtc ;
  struct drm_mode_set set ;
  int ret ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int __ret_warn_on ;
  long tmp___8 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  struct drm_crtc *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct list_head *__cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct drm_crtc_funcs *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int (*__cil_tmp51)(struct drm_mode_set *set ) ;
  int (*__cil_tmp52)(struct drm_mode_set *set ) ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  long __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  struct drm_crtc *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 134377UL;
  __cil_tmp13 = *((bool *)__cil_tmp12);
  if (! __cil_tmp13) {
    return;
  }
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 134377UL;
  *((bool *)__cil_tmp15) = (bool )0;
  __cil_tmp16 = (unsigned long )(& set) + 40UL;
  *((uint32_t *)__cil_tmp16) = (uint32_t )0;
  __cil_tmp17 = (unsigned long )(& set) + 44UL;
  *((uint32_t *)__cil_tmp17) = (uint32_t )0;
  __cil_tmp18 = (unsigned long )(& set) + 16UL;
  __cil_tmp19 = (void *)0;
  *((struct drm_framebuffer **)__cil_tmp18) = (struct drm_framebuffer *)__cil_tmp19;
  __cil_tmp20 = (unsigned long )(& set) + 32UL;
  __cil_tmp21 = (void *)0;
  *((struct drm_display_mode **)__cil_tmp20) = (struct drm_display_mode *)__cil_tmp21;
  __cil_tmp22 = (unsigned long )(& set) + 48UL;
  __cil_tmp23 = (void *)0;
  *((struct drm_connector ***)__cil_tmp22) = (struct drm_connector **)__cil_tmp23;
  __cil_tmp24 = (unsigned long )(& set) + 56UL;
  *((size_t *)__cil_tmp24) = (size_t )0;
  __cil_tmp25 = 1448;
  __cil_tmp26 = (unsigned long )dev;
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
  __cil_tmp28 = *((struct list_head **)__cil_tmp27);
  __mptr = __cil_tmp28;
  __cil_tmp29 = (struct drm_crtc *)0;
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  __cil_tmp31 = __cil_tmp30 + 8UL;
  __cil_tmp32 = (struct list_head *)__cil_tmp31;
  __cil_tmp33 = (unsigned int )__cil_tmp32;
  __cil_tmp34 = (char *)__mptr;
  __cil_tmp35 = __cil_tmp34 - __cil_tmp33;
  crtc = (struct drm_crtc *)__cil_tmp35;
  while (1) {
    __cil_tmp36 = 1448;
    __cil_tmp37 = (unsigned long )dev;
    __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
    __cil_tmp39 = (struct list_head *)__cil_tmp38;
    __cil_tmp40 = (unsigned long )__cil_tmp39;
    __cil_tmp41 = (unsigned long )crtc;
    __cil_tmp42 = __cil_tmp41 + 8UL;
    __cil_tmp43 = (struct list_head *)__cil_tmp42;
    __cil_tmp44 = (unsigned long )__cil_tmp43;
    if (! (__cil_tmp44 != __cil_tmp40)) {
      goto while_break;
    }
    __cil_tmp45 = (unsigned long )(& set) + 24UL;
    *((struct drm_crtc **)__cil_tmp45) = crtc;
    __cil_tmp46 = (unsigned long )crtc;
    __cil_tmp47 = __cil_tmp46 + 488UL;
    __cil_tmp48 = *((struct drm_crtc_funcs **)__cil_tmp47);
    __cil_tmp49 = (unsigned long )__cil_tmp48;
    __cil_tmp50 = __cil_tmp49 + 56UL;
    __cil_tmp51 = *((int (**)(struct drm_mode_set *set ))__cil_tmp50);
    __cil_tmp52 = __cil_tmp51;
    ret = (*__cil_tmp52)(& set);
    __cil_tmp53 = ret != 0;
    __cil_tmp54 = ! __cil_tmp53;
    __ret_warn_on = ! __cil_tmp54;
    __cil_tmp55 = ! __ret_warn_on;
    __cil_tmp56 = ! __cil_tmp55;
    __cil_tmp57 = (long )__cil_tmp56;
    tmp___8 = ldv__builtin_expect(__cil_tmp57, 0L);
    if (tmp___8) {
      __cil_tmp58 = 844;
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c",
                         __cil_tmp58);
    }
    __cil_tmp59 = ! __ret_warn_on;
    __cil_tmp60 = ! __cil_tmp59;
    __cil_tmp61 = (long )__cil_tmp60;
    ldv__builtin_expect(__cil_tmp61, 0L);
    __cil_tmp62 = (unsigned long )crtc;
    __cil_tmp63 = __cil_tmp62 + 8UL;
    __cil_tmp64 = *((struct list_head **)__cil_tmp63);
    __mptr___0 = __cil_tmp64;
    __cil_tmp65 = (struct drm_crtc *)0;
    __cil_tmp66 = (unsigned long )__cil_tmp65;
    __cil_tmp67 = __cil_tmp66 + 8UL;
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
    __cil_tmp69 = (unsigned int )__cil_tmp68;
    __cil_tmp70 = (char *)__mptr___0;
    __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
    crtc = (struct drm_crtc *)__cil_tmp71;
  }
  while_break: ;
  return;
}
}
static struct lock_class_key __key___11  ;
static void vmw_master_init(struct vmw_master *vmaster ) 
{ struct ttm_lock *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct list_head *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;

  {
  __cil_tmp2 = (struct ttm_lock *)vmaster;
  ttm_lock_init(__cil_tmp2);
  __cil_tmp3 = (unsigned long )vmaster;
  __cil_tmp4 = __cil_tmp3 + 224UL;
  __cil_tmp5 = (struct list_head *)__cil_tmp4;
  INIT_LIST_HEAD(__cil_tmp5);
  while (1) {
    __cil_tmp6 = (unsigned long )vmaster;
    __cil_tmp7 = __cil_tmp6 + 152UL;
    __cil_tmp8 = (struct mutex *)__cil_tmp7;
    __mutex_init(__cil_tmp8, "&vmaster->fb_surf_mutex", & __key___11);
    goto while_break;
  }
  while_break: ;
  return;
}
}
static int vmw_master_create(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  void *tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  struct ttm_lock *__cil_tmp13 ;
  bool __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
  tmp___7 = kzalloc(240UL, 208U);
  vmaster = (struct vmw_master *)tmp___7;
  __cil_tmp6 = (void *)0;
  __cil_tmp7 = (unsigned long )__cil_tmp6;
  __cil_tmp8 = (unsigned long )vmaster;
  __cil_tmp9 = __cil_tmp8 == __cil_tmp7;
  __cil_tmp10 = ! __cil_tmp9;
  __cil_tmp11 = ! __cil_tmp10;
  __cil_tmp12 = (long )__cil_tmp11;
  tmp___8 = ldv__builtin_expect(__cil_tmp12, 0L);
  if (tmp___8) {
    return (-12);
  }
  vmw_master_init(vmaster);
  __cil_tmp13 = (struct ttm_lock *)vmaster;
  __cil_tmp14 = (bool )1;
  ttm_lock_set_kill(__cil_tmp13, __cil_tmp14, 15);
  __cil_tmp15 = (unsigned long )master;
  __cil_tmp16 = __cil_tmp15 + 192UL;
  *((void **)__cil_tmp16) = (void *)vmaster;
  return (0);
}
}
static void vmw_master_destroy(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  struct vmw_master *tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  tmp___7 = vmw_master(master);
  vmaster = tmp___7;
  __cil_tmp5 = (unsigned long )master;
  __cil_tmp6 = __cil_tmp5 + 192UL;
  *((void **)__cil_tmp6) = (void *)0;
  __cil_tmp7 = (void *)vmaster;
  kfree(__cil_tmp7);
  return;
}
}
static int vmw_master_set(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_master *active ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct drm_master *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  bool __cil_tmp24 ;
  bool __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct mutex *__cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_master *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  struct ttm_lock *__cil_tmp46 ;
  bool __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_object_file *__cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  long __cil_tmp54 ;
  struct ttm_lock *__cil_tmp55 ;
  bool __cil_tmp56 ;
  struct ttm_bo_device *__cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  void *__cil_tmp64 ;
  struct ttm_lock *__cil_tmp65 ;
  bool __cil_tmp66 ;
  struct ttm_lock *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct drm_master *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct drm_master *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  long __cil_tmp77 ;
  struct drm_master **__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  bool __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct mutex *__cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct mutex *__cil_tmp90 ;
  bool __cil_tmp91 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  tmp___8 = vmw_fpriv(file_priv);
  vmw_fp = tmp___8;
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 134384UL;
  active = *((struct vmw_master **)__cil_tmp18);
  __cil_tmp19 = (unsigned long )file_priv;
  __cil_tmp20 = __cil_tmp19 + 152UL;
  __cil_tmp21 = *((struct drm_master **)__cil_tmp20);
  tmp___9 = vmw_master(__cil_tmp21);
  vmaster = tmp___9;
  ret = 0;
  __cil_tmp22 = (unsigned long )dev_priv;
  __cil_tmp23 = __cil_tmp22 + 134378UL;
  __cil_tmp24 = *((bool *)__cil_tmp23);
  if (! __cil_tmp24) {
    __cil_tmp25 = (bool )1;
    ret = vmw_3d_resource_inc(dev_priv, __cil_tmp25);
    __cil_tmp26 = ret != 0;
    __cil_tmp27 = ! __cil_tmp26;
    __cil_tmp28 = ! __cil_tmp27;
    __cil_tmp29 = (long )__cil_tmp28;
    tmp___10 = ldv__builtin_expect(__cil_tmp29, 0L);
    if (tmp___10) {
      return (ret);
    }
    vmw_kms_save_vga(dev_priv);
    __cil_tmp30 = (unsigned long )dev_priv;
    __cil_tmp31 = __cil_tmp30 + 2184UL;
    __cil_tmp32 = (struct mutex *)__cil_tmp31;
    mutex_lock(__cil_tmp32);
    __cil_tmp33 = (uint32_t )0;
    vmw_write(dev_priv, 45U, __cil_tmp33);
    __cil_tmp34 = (unsigned long )dev_priv;
    __cil_tmp35 = __cil_tmp34 + 2184UL;
    __cil_tmp36 = (struct mutex *)__cil_tmp35;
    mutex_unlock(__cil_tmp36);
  }
  if (active) {
    while (1) {
      __cil_tmp37 = (unsigned long )dev_priv;
      __cil_tmp38 = __cil_tmp37 + 134392UL;
      __cil_tmp39 = (struct vmw_master *)__cil_tmp38;
      __cil_tmp40 = (unsigned long )__cil_tmp39;
      __cil_tmp41 = (unsigned long )active;
      __cil_tmp42 = __cil_tmp41 != __cil_tmp40;
      __cil_tmp43 = ! __cil_tmp42;
      __cil_tmp44 = ! __cil_tmp43;
      __cil_tmp45 = (long )__cil_tmp44;
      tmp___11 = ldv__builtin_expect(__cil_tmp45, 0L);
      if (tmp___11) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                               "i" (903), "i" (12UL));
          while (1) {

          }

          goto while_break___0;
        }
        while_break___0: ;
      }
      goto while_break;
    }
    while_break: 
    __cil_tmp46 = (struct ttm_lock *)active;
    __cil_tmp47 = (bool )0;
    __cil_tmp48 = (unsigned long )vmw_fp;
    __cil_tmp49 = __cil_tmp48 + 8UL;
    __cil_tmp50 = *((struct ttm_object_file **)__cil_tmp49);
    ret = ttm_vt_lock(__cil_tmp46, __cil_tmp47, __cil_tmp50);
    __cil_tmp51 = ret != 0;
    __cil_tmp52 = ! __cil_tmp51;
    __cil_tmp53 = ! __cil_tmp52;
    __cil_tmp54 = (long )__cil_tmp53;
    tmp___12 = ldv__builtin_expect(__cil_tmp54, 0L);
    if (tmp___12) {
      goto out_no_active_lock;
    }
    __cil_tmp55 = (struct ttm_lock *)active;
    __cil_tmp56 = (bool )1;
    ttm_lock_set_kill(__cil_tmp55, __cil_tmp56, 15);
    __cil_tmp57 = (struct ttm_bo_device *)dev_priv;
    ret = ttm_bo_evict_mm(__cil_tmp57, 2U);
    __cil_tmp58 = ret != 0;
    __cil_tmp59 = ! __cil_tmp58;
    __cil_tmp60 = ! __cil_tmp59;
    __cil_tmp61 = (long )__cil_tmp60;
    tmp___13 = ldv__builtin_expect(__cil_tmp61, 0L);
    if (tmp___13) {
      drm_err("vmw_master_set", "Unable to clean VRAM on master drop.\n");
    }
    __cil_tmp62 = (unsigned long )dev_priv;
    __cil_tmp63 = __cil_tmp62 + 134384UL;
    __cil_tmp64 = (void *)0;
    *((struct vmw_master **)__cil_tmp63) = (struct vmw_master *)__cil_tmp64;
  }
  __cil_tmp65 = (struct ttm_lock *)vmaster;
  __cil_tmp66 = (bool )0;
  ttm_lock_set_kill(__cil_tmp65, __cil_tmp66, 15);
  if (! from_open) {
    __cil_tmp67 = (struct ttm_lock *)vmaster;
    ttm_vt_unlock(__cil_tmp67);
    while (1) {
      __cil_tmp68 = (unsigned long )file_priv;
      __cil_tmp69 = __cil_tmp68 + 152UL;
      __cil_tmp70 = *((struct drm_master **)__cil_tmp69);
      __cil_tmp71 = (unsigned long )__cil_tmp70;
      __cil_tmp72 = *((struct drm_master **)vmw_fp);
      __cil_tmp73 = (unsigned long )__cil_tmp72;
      __cil_tmp74 = __cil_tmp73 != __cil_tmp71;
      __cil_tmp75 = ! __cil_tmp74;
      __cil_tmp76 = ! __cil_tmp75;
      __cil_tmp77 = (long )__cil_tmp76;
      tmp___14 = ldv__builtin_expect(__cil_tmp77, 0L);
      if (tmp___14) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c"),
                               "i" (921), "i" (12UL));
          while (1) {

          }

          goto while_break___3;
        }
        while_break___3: ;
      }
      goto while_break___2;
    }
    while_break___2: 
    __cil_tmp78 = (struct drm_master **)vmw_fp;
    drm_master_put(__cil_tmp78);
  }
  __cil_tmp79 = (unsigned long )dev_priv;
  __cil_tmp80 = __cil_tmp79 + 134384UL;
  *((struct vmw_master **)__cil_tmp80) = vmaster;
  return (0);
  out_no_active_lock: 
  __cil_tmp81 = (unsigned long )dev_priv;
  __cil_tmp82 = __cil_tmp81 + 134378UL;
  __cil_tmp83 = *((bool *)__cil_tmp82);
  if (! __cil_tmp83) {
    __cil_tmp84 = (unsigned long )dev_priv;
    __cil_tmp85 = __cil_tmp84 + 2184UL;
    __cil_tmp86 = (struct mutex *)__cil_tmp85;
    mutex_lock(__cil_tmp86);
    __cil_tmp87 = (uint32_t )1;
    vmw_write(dev_priv, 45U, __cil_tmp87);
    __cil_tmp88 = (unsigned long )dev_priv;
    __cil_tmp89 = __cil_tmp88 + 2184UL;
    __cil_tmp90 = (struct mutex *)__cil_tmp89;
    mutex_unlock(__cil_tmp90);
    vmw_kms_restore_vga(dev_priv);
    __cil_tmp91 = (bool )1;
    vmw_3d_resource_dec(dev_priv, __cil_tmp91);
  }
  return (ret);
}
}
static void vmw_master_drop(struct drm_device *dev , struct drm_file *file_priv ,
                            bool from_release ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_master *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct drm_master *__cil_tmp18 ;
  struct ttm_lock *__cil_tmp19 ;
  bool __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_object_file *__cil_tmp23 ;
  bool __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct drm_master **__cil_tmp30 ;
  struct ttm_lock *__cil_tmp31 ;
  bool __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  bool __cil_tmp35 ;
  struct ttm_bo_device *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct mutex *__cil_tmp47 ;
  bool __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct ttm_lock *__cil_tmp55 ;
  bool __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct ttm_lock *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  tmp___8 = vmw_fpriv(file_priv);
  vmw_fp = tmp___8;
  __cil_tmp13 = (unsigned long )file_priv;
  __cil_tmp14 = __cil_tmp13 + 152UL;
  __cil_tmp15 = *((struct drm_master **)__cil_tmp14);
  tmp___9 = vmw_master(__cil_tmp15);
  vmaster = tmp___9;
  __cil_tmp16 = (unsigned long )file_priv;
  __cil_tmp17 = __cil_tmp16 + 152UL;
  __cil_tmp18 = *((struct drm_master **)__cil_tmp17);
  *((struct drm_master **)vmw_fp) = drm_master_get(__cil_tmp18);
  __cil_tmp19 = (struct ttm_lock *)vmaster;
  __cil_tmp20 = (bool )0;
  __cil_tmp21 = (unsigned long )vmw_fp;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  __cil_tmp23 = *((struct ttm_object_file **)__cil_tmp22);
  ret = ttm_vt_lock(__cil_tmp19, __cil_tmp20, __cil_tmp23);
  __cil_tmp24 = (bool )0;
  __cil_tmp25 = (uint32_t )0;
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp24, __cil_tmp25);
  __cil_tmp26 = ret != 0;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___10 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___10) {
    drm_err("vmw_master_drop", "Unable to lock TTM at VT switch.\n");
    __cil_tmp30 = (struct drm_master **)vmw_fp;
    drm_master_put(__cil_tmp30);
  }
  __cil_tmp31 = (struct ttm_lock *)vmaster;
  __cil_tmp32 = (bool )1;
  ttm_lock_set_kill(__cil_tmp31, __cil_tmp32, 15);
  __cil_tmp33 = (unsigned long )dev_priv;
  __cil_tmp34 = __cil_tmp33 + 134378UL;
  __cil_tmp35 = *((bool *)__cil_tmp34);
  if (! __cil_tmp35) {
    __cil_tmp36 = (struct ttm_bo_device *)dev_priv;
    ret = ttm_bo_evict_mm(__cil_tmp36, 2U);
    __cil_tmp37 = ret != 0;
    __cil_tmp38 = ! __cil_tmp37;
    __cil_tmp39 = ! __cil_tmp38;
    __cil_tmp40 = (long )__cil_tmp39;
    tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
    if (tmp___11) {
      drm_err("vmw_master_drop", "Unable to clean VRAM on master drop.\n");
    }
    __cil_tmp41 = (unsigned long )dev_priv;
    __cil_tmp42 = __cil_tmp41 + 2184UL;
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
    mutex_lock(__cil_tmp43);
    __cil_tmp44 = (uint32_t )1;
    vmw_write(dev_priv, 45U, __cil_tmp44);
    __cil_tmp45 = (unsigned long )dev_priv;
    __cil_tmp46 = __cil_tmp45 + 2184UL;
    __cil_tmp47 = (struct mutex *)__cil_tmp46;
    mutex_unlock(__cil_tmp47);
    vmw_kms_restore_vga(dev_priv);
    __cil_tmp48 = (bool )1;
    vmw_3d_resource_dec(dev_priv, __cil_tmp48);
  }
  __cil_tmp49 = (unsigned long )dev_priv;
  __cil_tmp50 = __cil_tmp49 + 134384UL;
  __cil_tmp51 = (unsigned long )dev_priv;
  __cil_tmp52 = __cil_tmp51 + 134392UL;
  *((struct vmw_master **)__cil_tmp50) = (struct vmw_master *)__cil_tmp52;
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 134392UL;
  __cil_tmp55 = (struct ttm_lock *)__cil_tmp54;
  __cil_tmp56 = (bool )0;
  ttm_lock_set_kill(__cil_tmp55, __cil_tmp56, 15);
  __cil_tmp57 = (unsigned long )dev_priv;
  __cil_tmp58 = __cil_tmp57 + 134392UL;
  __cil_tmp59 = (struct ttm_lock *)__cil_tmp58;
  ttm_vt_unlock(__cil_tmp59);
  __cil_tmp60 = (unsigned long )dev_priv;
  __cil_tmp61 = __cil_tmp60 + 134378UL;
  if (*((bool *)__cil_tmp61)) {
    vmw_fb_on(dev_priv);
  }
  return;
}
}
static void vmw_remove(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp___7 ;

  {
  tmp___7 = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp___7;
  drm_put_dev(dev);
  return;
}
}
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) 
{ struct vmw_private *dev_priv ;
  struct notifier_block *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_private *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct notifier_block *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_lock *__cil_tmp16 ;
  bool __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  struct ttm_bo_device *__cil_tmp19 ;
  struct ttm_lock *__cil_tmp20 ;

  {
  __mptr = nb;
  __cil_tmp7 = (struct vmw_private *)0;
  __cil_tmp8 = (unsigned long )__cil_tmp7;
  __cil_tmp9 = __cil_tmp8 + 134632UL;
  __cil_tmp10 = (struct notifier_block *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  dev_priv = (struct vmw_private *)__cil_tmp13;
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 134384UL;
  vmaster = *((struct vmw_master **)__cil_tmp15);
  if ((int )val == 1) {
    goto case_1;
  } else
  if ((int )val == 3) {
    goto case_1;
  } else
  if ((int )val == 2) {
    goto case_2;
  } else
  if ((int )val == 4) {
    goto case_2;
  } else
  if ((int )val == 6) {
    goto case_2;
  } else
  if ((int )val == 5) {
    goto case_5;
  } else {
    goto switch_default;
    if (0) {
      case_1: 
      __cil_tmp16 = (struct ttm_lock *)vmaster;
      ttm_suspend_lock(__cil_tmp16);
      __cil_tmp17 = (bool )0;
      __cil_tmp18 = (uint32_t )0;
      vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp17, __cil_tmp18);
      __cil_tmp19 = (struct ttm_bo_device *)dev_priv;
      ttm_bo_swapout_all(__cil_tmp19);
      goto switch_break;
      case_2: 
      __cil_tmp20 = (struct ttm_lock *)vmaster;
      ttm_suspend_unlock(__cil_tmp20);
      goto switch_break;
      case_5: 
      goto switch_break;
      switch_default: 
      goto switch_break;
    } else {
      switch_break: ;
    }
  }
  return (0);
}
}
static int vmw_pci_suspend(struct pci_dev *pdev , int state_event10 ) 
{ struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
  tmp___7 = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp___7;
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 134736UL;
  __cil_tmp9 = *((uint32_t *)__cil_tmp8);
  if (__cil_tmp9 != 0U) {
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
    return (-16);
  }
  pci_save_state(pdev);
  pci_disable_device(pdev);
  pci_set_power_state(pdev, 3);
  return (0);
}
}
static int vmw_pci_resume(struct pci_dev *pdev ) 
{ int tmp___7 ;
  int tmp ;

  {
  pci_set_power_state(pdev, 0);
  pci_restore_state(pdev);
  tmp = (int )pci_enable_device(pdev);
  tmp___7 = tmp;
  return (tmp___7);
}
}
static int vmw_pm_suspend(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device *__mptr ;
  int tmp___7 ;
  struct pci_dev *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct device *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int dummy_event13 ;

  {
  __mptr = kdev;
  __cil_tmp6 = (struct pci_dev *)0;
  __cil_tmp7 = (unsigned long )__cil_tmp6;
  __cil_tmp8 = __cil_tmp7 + 144UL;
  __cil_tmp9 = (struct device *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  pdev = (struct pci_dev *)__cil_tmp12;
  dummy_event13 = 0;
  tmp___7 = vmw_pci_suspend(pdev, dummy_event13);
  return (tmp___7);
}
}
static int vmw_pm_resume(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device *__mptr ;
  int tmp___7 ;
  struct pci_dev *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct device *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  __mptr = kdev;
  __cil_tmp5 = (struct pci_dev *)0;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = __cil_tmp6 + 144UL;
  __cil_tmp8 = (struct device *)__cil_tmp7;
  __cil_tmp9 = (unsigned int )__cil_tmp8;
  __cil_tmp10 = (char *)__mptr;
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
  pdev = (struct pci_dev *)__cil_tmp11;
  tmp___7 = vmw_pci_resume(pdev);
  return (tmp___7);
}
}
static int vmw_pm_prepare(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device *__mptr ;
  struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct pci_dev *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct device *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  bool __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  bool __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;

  {
  __mptr = kdev;
  __cil_tmp8 = (struct pci_dev *)0;
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = __cil_tmp9 + 144UL;
  __cil_tmp11 = (struct device *)__cil_tmp10;
  __cil_tmp12 = (unsigned int )__cil_tmp11;
  __cil_tmp13 = (char *)__mptr;
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
  pdev = (struct pci_dev *)__cil_tmp14;
  tmp___7 = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp___7;
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 134656UL;
  *((bool *)__cil_tmp16) = (bool )1;
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 134378UL;
  if (*((bool *)__cil_tmp18)) {
    __cil_tmp19 = (bool )1;
    vmw_3d_resource_dec(dev_priv, __cil_tmp19);
  }
  __cil_tmp20 = (unsigned long )dev_priv;
  __cil_tmp21 = __cil_tmp20 + 134736UL;
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
  if (__cil_tmp22 != 0U) {
    printk("<6>[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
    __cil_tmp23 = (unsigned long )dev_priv;
    __cil_tmp24 = __cil_tmp23 + 134378UL;
    if (*((bool *)__cil_tmp24)) {
      __cil_tmp25 = (bool )1;
      vmw_3d_resource_inc(dev_priv, __cil_tmp25);
    }
    __cil_tmp26 = (unsigned long )dev_priv;
    __cil_tmp27 = __cil_tmp26 + 134656UL;
    *((bool *)__cil_tmp27) = (bool )0;
    return (-16);
  }
  return (0);
}
}
static void vmw_pm_complete(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device *__mptr ;
  struct drm_device *dev ;
  void *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct pci_dev *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct device *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  bool __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;

  {
  __mptr = kdev;
  __cil_tmp8 = (struct pci_dev *)0;
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = __cil_tmp9 + 144UL;
  __cil_tmp11 = (struct device *)__cil_tmp10;
  __cil_tmp12 = (unsigned int )__cil_tmp11;
  __cil_tmp13 = (char *)__mptr;
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
  pdev = (struct pci_dev *)__cil_tmp14;
  tmp___7 = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp___7;
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 134378UL;
  if (*((bool *)__cil_tmp16)) {
    __cil_tmp17 = (bool )0;
    vmw_3d_resource_inc(dev_priv, __cil_tmp17);
  }
  __cil_tmp18 = (unsigned long )dev_priv;
  __cil_tmp19 = __cil_tmp18 + 134656UL;
  *((bool *)__cil_tmp19) = (bool )0;
  return;
}
}
static struct dev_pm_ops vmw_pm_ops  = 
     {& vmw_pm_prepare, & vmw_pm_complete, & vmw_pm_suspend, & vmw_pm_resume, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0};
static struct file_operations vmwgfx_driver_fops  = 
     {& __this_module, & noop_llseek, & vmw_fops_read, (ssize_t (*)(struct file * ,
                                                                  char * , size_t  ,
                                                                  loff_t * ))0, (ssize_t (*)(struct kiocb * ,
                                                                                             struct iovec * ,
                                                                                             unsigned long  ,
                                                                                             loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec * , unsigned long  , loff_t  ))0, (int (*)(struct file * ,
                                                                                          void * ,
                                                                                          int (*)(void * ,
                                                                                                  char * ,
                                                                                                  int  ,
                                                                                                  loff_t  ,
                                                                                                  u64  ,
                                                                                                  unsigned int  ) ))0,
    & vmw_fops_poll, & vmw_unlocked_ioctl, & drm_compat_ioctl, & vmw_mmap, & drm_open,
    (int (*)(struct file * , fl_owner_t id ))0, & drm_release, (int (*)(struct file * ,
                                                                        loff_t  ,
                                                                        loff_t  ,
                                                                        int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, & drm_fasync, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (long (*)(struct file *file ,
                                                                        int mode ,
                                                                        loff_t offset ,
                                                                        loff_t len ))0};
static struct drm_driver driver  = 
     {& vmw_driver_load, & vmw_firstopen, & vmw_driver_open, & vmw_preclose, & vmw_postclose,
    & vmw_lastclose, & vmw_driver_unload, (int (*)(struct drm_device * , pm_message_t state ))0,
    (int (*)(struct drm_device * ))0, (int (*)(struct drm_device *dev , void *data ,
                                               struct drm_file *file_priv ))0, (int (*)(struct drm_device * ))((void *)0),
    (int (*)(struct drm_device *dev , int context ))0, & vmw_get_vblank_counter, & vmw_enable_vblank,
    & vmw_disable_vblank, (int (*)(struct drm_device *dev ))0, (int (*)(struct drm_device *dev ,
                                                                        int crtc ,
                                                                        int *vpos ,
                                                                        int *hpos ))0,
    (int (*)(struct drm_device *dev , int crtc , int *max_error , struct timeval *vblank_time ,
             unsigned int flags ))0, & vmw_irq_handler, & vmw_irq_preinstall, & vmw_irq_postinstall,
    & vmw_irq_uninstall, (void (*)(struct drm_device *dev , struct drm_file *file_priv ))0,
    (void (*)(struct drm_device *dev , struct drm_file *file_priv ))((void *)0), (void (*)(struct drm_device *dev ,
                                                                                           struct drm_file *file_priv ))0,
    (void (*)(struct drm_device *dev , struct drm_set_version *sv ))0, & vmw_master_create,
    & vmw_master_destroy, & vmw_master_set, & vmw_master_drop, (int (*)(struct drm_minor *minor ))0,
    (void (*)(struct drm_minor *minor ))0, (int (*)(struct drm_gem_object *obj ))0,
    (void (*)(struct drm_gem_object *obj ))0, (int (*)(struct drm_gem_object * , struct drm_file * ))0,
    (void (*)(struct drm_gem_object * , struct drm_file * ))0, (int (*)(struct drm_device *dev ,
                                                                        struct drm_file *file_priv ,
                                                                        uint32_t handle ,
                                                                        uint32_t flags ,
                                                                        int *prime_fd ))0,
    (int (*)(struct drm_device *dev , struct drm_file *file_priv , int prime_fd ,
             uint32_t *handle ))0, (struct dma_buf *(*)(struct drm_device *dev , struct drm_gem_object *obj ,
                                                        int flags ))0, (struct drm_gem_object *(*)(struct drm_device *dev ,
                                                                                                   struct dma_buf *dma_buf ))0,
    (void (*)(struct drm_device *dev , bool state ))0, (int (*)(struct drm_file *file_priv ,
                                                                struct drm_device *dev ,
                                                                struct drm_mode_create_dumb *args ))0,
    (int (*)(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
             uint64_t *offset ))0, (int (*)(struct drm_file *file_priv , struct drm_device *dev ,
                                            uint32_t handle ))0, (struct vm_operations_struct *)0,
    2, 4, 0, (char *)"vmwgfx", (char *)"Linux drm driver for VMware graphics devices",
    (char *)"20120209", (u32 )8384, 0, vmw_ioctls, (int )(sizeof(vmw_ioctls) / sizeof(vmw_ioctls[0]) + sizeof(struct __anonstruct_437 )),
    & vmwgfx_driver_fops, {(struct pci_driver *)0}, (struct drm_bus *)0, {(struct list_head *)0,
                                                                          (struct list_head *)0}};
static struct pci_driver vmw_pci_driver  = 
     {{(struct list_head *)0, (struct list_head *)0}, "vmwgfx", vmw_pci_id_list, & vmw_probe,
    & vmw_remove, (int (*)(struct pci_dev *dev , pm_message_t state ))0, (int (*)(struct pci_dev *dev ,
                                                                                  pm_message_t state ))0,
    (int (*)(struct pci_dev *dev ))0, (int (*)(struct pci_dev *dev ))0, (void (*)(struct pci_dev *dev ))0,
    (struct pci_error_handlers *)0, {(char *)0, (struct bus_type *)0, (struct module *)0,
                                     (char *)0, (_Bool)0, (struct of_device_id *)0,
                                     (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
                                     (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                pm_message_t state ))0,
                                     (int (*)(struct device *dev ))0, (struct attribute_group **)0,
                                     & vmw_pm_ops, (struct driver_private *)0}, {{{{{{0U}},
                                                                                    0U,
                                                                                    0U,
                                                                                    (void *)0}}},
                                                                                 {(struct list_head *)0,
                                                                                  (struct list_head *)0}}};
static int vmw_probe(struct pci_dev *pdev ,
                     struct pci_device_id *ent ) 
{ int tmp___7 ;

  {
  tmp___7 = drm_get_pci_dev(pdev, ent, & driver);
  return (tmp___7);
}
}
static int vmwgfx_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int vmwgfx_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int vmwgfx_init(void) 
{ int ret ;

  {
  ret = drm_pci_init(& driver, & vmw_pci_driver);
  if (ret) {
    drm_err("vmwgfx_init", "Failed initializing DRM.\n");
  }
  return (ret);
}
}
static void vmwgfx_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
static void vmwgfx_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
static void vmwgfx_exit(void) 
{ 

  {
  drm_pci_exit(& driver, & vmw_pci_driver);
  return;
}
}
int init_module(void) 
{ int tmp___7 ;

  {
  tmp___7 = vmwgfx_init();
  return (tmp___7);
}
}
void cleanup_module(void) 
{ 

  {
  vmwgfx_exit();
  return;
}
}
static char __mod_author1203[30]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char )'a',      (char )'u',      (char const   )'t',      (char const   )'h', 
        (char )'o',      (char )'r',      (char const   )'=',      (char const   )'V', 
        (char )'M',      (char )'w',      (char const   )'a',      (char const   )'r', 
        (char )'e',      (char )' ',      (char const   )'I',      (char const   )'n', 
        (char )'c',      (char )'.',      (char const   )' ',      (char const   )'a', 
        (char )'n',      (char )'d',      (char const   )' ',      (char const   )'o', 
        (char )'t',      (char )'h',      (char const   )'e',      (char const   )'r', 
        (char )'s',      (char )'\000'};
static char __mod_description1204[61]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char )'d',      (char )'e',      (char const   )'s',      (char const   )'c', 
        (char )'r',      (char )'i',      (char const   )'p',      (char const   )'t', 
        (char )'i',      (char )'o',      (char const   )'n',      (char const   )'=', 
        (char )'S',      (char )'t',      (char const   )'a',      (char const   )'n', 
        (char )'d',      (char )'a',      (char const   )'l',      (char const   )'o', 
        (char )'n',      (char )'e',      (char const   )' ',      (char const   )'d', 
        (char )'r',      (char )'m',      (char const   )' ',      (char const   )'d', 
        (char )'r',      (char )'i',      (char const   )'v',      (char const   )'e', 
        (char )'r',      (char )' ',      (char const   )'f',      (char const   )'o', 
        (char )'r',      (char )' ',      (char const   )'t',      (char const   )'h', 
        (char )'e',      (char )' ',      (char const   )'V',      (char const   )'M', 
        (char )'w',      (char )'a',      (char const   )'r',      (char const   )'e', 
        (char )' ',      (char )'S',      (char const   )'V',      (char const   )'G', 
        (char )'A',      (char )' ',      (char const   )'d',      (char const   )'e', 
        (char )'v',      (char )'i',      (char const   )'c',      (char const   )'e', 
        (char )'\000'};
static char __mod_license1205[34]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char )'l',      (char )'i',      (char const   )'c',      (char const   )'e', 
        (char )'n',      (char )'s',      (char const   )'e',      (char const   )'=', 
        (char )'G',      (char )'P',      (char const   )'L',      (char const   )' ', 
        (char )'a',      (char )'n',      (char const   )'d',      (char const   )' ', 
        (char )'a',      (char )'d',      (char const   )'d',      (char const   )'i', 
        (char )'t',      (char )'i',      (char const   )'o',      (char const   )'n', 
        (char )'a',      (char )'l',      (char const   )' ',      (char const   )'r', 
        (char )'i',      (char )'g',      (char const   )'h',      (char const   )'t', 
        (char )'s',      (char )'\000'};
static char __mod_version1209[16]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char )'v',      (char )'e',      (char const   )'r',      (char const   )'s', 
        (char )'i',      (char )'o',      (char const   )'n',      (char const   )'=', 
        (char )'2',      (char )'.',      (char const   )'4',      (char const   )'.', 
        (char )'0',      (char )'.',      (char const   )'0',      (char const   )'\000'};
extern void ldv_check_return_value(int res ) ;
static int res_vmw_driver_open_12  ;
static int res_vmw_probe_29  ;
int main(void) 
{ struct device *var_group1 ;
  struct file *var_group2 ;
  unsigned int var_vmw_unlocked_ioctl_13_p1 ;
  unsigned long var_vmw_unlocked_ioctl_13_p2 ;
  struct drm_device *var_group3 ;
  unsigned long var_vmw_driver_load_8_p1 ;
  struct drm_master *var_group4 ;
  struct drm_file *var_group5 ;
  bool var_vmw_master_set_19_p2 ;
  bool var_vmw_master_drop_20_p2 ;
  struct pci_dev *var_group6 ;
  struct pci_device_id *var_vmw_probe_29_p1 ;
  int tmp___7 ;
  int ldv_s_driver_drm_driver ;
  int ldv_s_vmw_pci_driver_pci_driver ;
  int tmp___8 ;
  int tmp___9 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  tmp___7 = vmwgfx_init();
  if (tmp___7) {
    goto ldv_final;
  }
  ldv_s_driver_drm_driver = 0;
  ldv_s_vmw_pci_driver_pci_driver = 0;
  while (1) {
    tmp___9 = __VERIFIER_nondet_int();
    if (! tmp___9) {
      __cil_tmp18 = ldv_s_driver_drm_driver == 0;
      if (! (! __cil_tmp18)) {
        __cil_tmp19 = ldv_s_vmw_pci_driver_pci_driver == 0;
        if (! (! __cil_tmp19)) {
          goto while_break;
        }
      }
    }
    tmp___8 = __VERIFIER_nondet_int();
    if (tmp___8 == 0) {
      goto case_0;
    } else
    if (tmp___8 == 1) {
      goto case_1;
    } else
    if (tmp___8 == 2) {
      goto case_2;
    } else
    if (tmp___8 == 3) {
      goto case_3;
    } else
    if (tmp___8 == 4) {
      goto case_4;
    } else
    if (tmp___8 == 5) {
      goto case_5;
    } else
    if (tmp___8 == 6) {
      goto case_6;
    } else
    if (tmp___8 == 7) {
      goto case_7;
    } else
    if (tmp___8 == 8) {
      goto case_8;
    } else
    if (tmp___8 == 9) {
      goto case_9;
    } else
    if (tmp___8 == 10) {
      goto case_10;
    } else
    if (tmp___8 == 11) {
      goto case_11;
    } else
    if (tmp___8 == 12) {
      goto case_12;
    } else
    if (tmp___8 == 13) {
      goto case_13;
    } else
    if (tmp___8 == 14) {
      goto case_14;
    } else
    if (tmp___8 == 15) {
      goto case_15;
    } else
    if (tmp___8 == 16) {
      goto case_16;
    } else
    if (tmp___8 == 17) {
      goto case_17;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_pm_prepare(var_group1);
        goto switch_break;
        case_1: 
        vmw_pm_complete(var_group1);
        goto switch_break;
        case_2: 
        vmw_pm_suspend(var_group1);
        goto switch_break;
        case_3: 
        vmw_pm_resume(var_group1);
        goto switch_break;
        case_4: 
        vmw_unlocked_ioctl(var_group2, var_vmw_unlocked_ioctl_13_p1, var_vmw_unlocked_ioctl_13_p2);
        goto switch_break;
        case_5: 
        if (ldv_s_driver_drm_driver == 0) {
          res_vmw_driver_open_12 = vmw_driver_open(var_group3, var_group5);
          ldv_check_return_value(res_vmw_driver_open_12);
          if (res_vmw_driver_open_12) {
            goto ldv_module_exit;
          }
          ldv_s_driver_drm_driver = 0;
        }
        goto switch_break;
        case_6: 
        vmw_driver_load(var_group3, var_vmw_driver_load_8_p1);
        goto switch_break;
        case_7: 
        vmw_driver_unload(var_group3);
        goto switch_break;
        case_8: 
        vmw_firstopen(var_group3);
        goto switch_break;
        case_9: 
        vmw_lastclose(var_group3);
        goto switch_break;
        case_10: 
        vmw_master_create(var_group3, var_group4);
        goto switch_break;
        case_11: 
        vmw_master_destroy(var_group3, var_group4);
        goto switch_break;
        case_12: 
        vmw_master_set(var_group3, var_group5, var_vmw_master_set_19_p2);
        goto switch_break;
        case_13: 
        vmw_master_drop(var_group3, var_group5, var_vmw_master_drop_20_p2);
        goto switch_break;
        case_14: 
        vmw_preclose(var_group3, var_group5);
        goto switch_break;
        case_15: 
        vmw_postclose(var_group3, var_group5);
        goto switch_break;
        case_16: 
        if (ldv_s_vmw_pci_driver_pci_driver == 0) {
          res_vmw_probe_29 = vmw_probe(var_group6, var_vmw_probe_29_p1);
          ldv_check_return_value(res_vmw_probe_29);
          if (res_vmw_probe_29) {
            goto ldv_module_exit;
          }
          ldv_s_vmw_pci_driver_pci_driver = 0;
        }
        goto switch_break;
        case_17: 
        vmw_remove(var_group6);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: ;
  ldv_module_exit: 
  vmwgfx_exit();
  ldv_final: 
  ldv_check_final_state();
  return;
}
}
extern char *strcpy(char *dest , char *src ) ;
extern void __raw_spin_lock_init(raw_spinlock_t *lock , char *name , struct lock_class_key *key ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
 static raw_spinlock_t *spinlock_check(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static raw_spinlock_t *spinlock_check(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
  return ((struct raw_spinlock *)lock);
}
}
 static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ struct raw_spinlock *__cil_tmp5 ;

  {
  while (1) {
    __cil_tmp5 = (struct raw_spinlock *)lock;
    _raw_spin_unlock_irqrestore(__cil_tmp5, flags);
    goto while_break;
  }
  while_break: ;
  return;
}
}
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
extern bool flush_delayed_work_sync(struct delayed_work *work ) ;
 static struct apertures_struct *alloc_apertures(unsigned int max_num )  __attribute__((__no_instrument_function__)) ;
 static struct apertures_struct *alloc_apertures(unsigned int max_num )  __attribute__((__no_instrument_function__)) ;
 static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ struct apertures_struct *a ;
  void *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  __cil_tmp4 = (unsigned long )max_num;
  __cil_tmp5 = __cil_tmp4 * 16UL;
  __cil_tmp6 = 8UL + __cil_tmp5;
  tmp___7 = kzalloc(__cil_tmp6, 208U);
  a = (struct apertures_struct *)tmp___7;
  if (! a) {
    __cil_tmp7 = (void *)0;
    return ((struct apertures_struct *)__cil_tmp7);
  }
  *((unsigned int *)a) = max_num;
  return (a);
}
}
extern void cfb_fillrect(struct fb_info *info , struct fb_fillrect *rect ) ;
extern void cfb_copyarea(struct fb_info *info , struct fb_copyarea *area ) ;
extern void cfb_imageblit(struct fb_info *info , struct fb_image *image ) ;
extern int register_framebuffer(struct fb_info *fb_info ) ;
extern int unregister_framebuffer(struct fb_info *fb_info ) ;
extern void fb_deferred_io_init(struct fb_info *info ) ;
extern void fb_deferred_io_cleanup(struct fb_info *info ) ;
extern struct fb_info *framebuffer_alloc(size_t size , struct device *dev ) ;
extern void framebuffer_release(struct fb_info *info ) ;
extern void ttm_write_unlock(struct ttm_lock *lock ) ;
extern int ttm_write_lock(struct ttm_lock *lock , bool interruptible ) ;
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) ;
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object *bo ) ) ;
struct ttm_placement vmw_vram_ne_placement ;
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) ;
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) ;
static int vmw_fb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                            unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  u32 *pal ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u32 *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned int __cil_tmp31 ;

  {
  __cil_tmp9 = (unsigned long )info;
  __cil_tmp10 = __cil_tmp9 + 1160UL;
  __cil_tmp11 = *((void **)__cil_tmp10);
  par = (struct vmw_fb_par *)__cil_tmp11;
  __cil_tmp12 = 0UL;
  __cil_tmp13 = 56UL + __cil_tmp12;
  __cil_tmp14 = (unsigned long )par;
  __cil_tmp15 = __cil_tmp14 + __cil_tmp13;
  pal = (u32 *)__cil_tmp15;
  if (regno > 15U) {
    drm_err("vmw_fb_setcolreg", "Bad regno %u.\n", regno);
    return (1);
  }
  __cil_tmp16 = (unsigned long )par;
  __cil_tmp17 = __cil_tmp16 + 124UL;
  __cil_tmp18 = *((unsigned int *)__cil_tmp17);
  if ((int )__cil_tmp18 == 24) {
    goto case_24;
  } else
  if ((int )__cil_tmp18 == 32) {
    goto case_24;
  } else {
    goto switch_default;
    if (0) {
      case_24: 
      __cil_tmp19 = pal + regno;
      __cil_tmp20 = blue & 65280U;
      __cil_tmp21 = __cil_tmp20 >> 8;
      __cil_tmp22 = green & 65280U;
      __cil_tmp23 = red & 65280U;
      __cil_tmp24 = __cil_tmp23 << 8;
      __cil_tmp25 = __cil_tmp24 | __cil_tmp22;
      *__cil_tmp19 = __cil_tmp25 | __cil_tmp21;
      goto switch_break;
      switch_default: 
      __cil_tmp26 = (unsigned long )par;
      __cil_tmp27 = __cil_tmp26 + 124UL;
      __cil_tmp28 = *((unsigned int *)__cil_tmp27);
      __cil_tmp29 = (unsigned long )par;
      __cil_tmp30 = __cil_tmp29 + 128UL;
      __cil_tmp31 = *((unsigned int *)__cil_tmp30);
      drm_err("vmw_fb_setcolreg", "Bad depth %u, bpp %u.\n", __cil_tmp28, __cil_tmp31);
      return (1);
    } else {
      switch_break: ;
    }
  }
  return (0);
}
}
static int vmw_fb_check_var(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ int depth ;
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  bool tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  __u32 __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32 __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  __u32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  __u32 __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  __u32 __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  __u32 __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  __u32 __cil_tmp79 ;
  __u32 __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  __u32 __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  __u32 __cil_tmp89 ;
  __u32 __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  __u32 __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  __u32 __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  __u32 __cil_tmp100 ;
  __u32 __cil_tmp101 ;

  {
  __cil_tmp7 = (unsigned long )var;
  __cil_tmp8 = __cil_tmp7 + 24UL;
  __cil_tmp9 = *((__u32 *)__cil_tmp8);
  depth = (int )__cil_tmp9;
  __cil_tmp10 = (unsigned long )info;
  __cil_tmp11 = __cil_tmp10 + 1160UL;
  __cil_tmp12 = *((void **)__cil_tmp11);
  par = (struct vmw_fb_par *)__cil_tmp12;
  vmw_priv___0 = *((struct vmw_private **)par);
  __cil_tmp13 = (unsigned long )var;
  __cil_tmp14 = __cil_tmp13 + 24UL;
  __cil_tmp15 = *((__u32 *)__cil_tmp14);
  if ((int )__cil_tmp15 == 32) {
    goto case_32;
  } else {
    goto switch_default;
    if (0) {
      case_32: 
      __cil_tmp16 = 72;
      __cil_tmp17 = (unsigned long )var;
      __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
      __cil_tmp19 = *((__u32 *)__cil_tmp18);
      if (__cil_tmp19 > 0U) {
        depth = 32;
      } else {
        depth = 24;
      }
      goto switch_break;
      switch_default: 
      __cil_tmp20 = (unsigned long )var;
      __cil_tmp21 = __cil_tmp20 + 24UL;
      __cil_tmp22 = *((__u32 *)__cil_tmp21);
      drm_err("vmw_fb_check_var", "Bad bpp %u.\n", __cil_tmp22);
      return (-22);
    } else {
      switch_break: ;
    }
  }
  if (depth == 24) {
    goto case_24;
  } else
  if (depth == 32) {
    goto case_32___0;
  } else {
    goto switch_default___0;
    if (0) {
      case_24: 
      __cil_tmp23 = (unsigned long )var;
      __cil_tmp24 = __cil_tmp23 + 32UL;
      *((__u32 *)__cil_tmp24) = (__u32 )16;
      __cil_tmp25 = (unsigned long )var;
      __cil_tmp26 = __cil_tmp25 + 44UL;
      *((__u32 *)__cil_tmp26) = (__u32 )8;
      __cil_tmp27 = (unsigned long )var;
      __cil_tmp28 = __cil_tmp27 + 56UL;
      *((__u32 *)__cil_tmp28) = (__u32 )0;
      __cil_tmp29 = 36;
      __cil_tmp30 = (unsigned long )var;
      __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
      *((__u32 *)__cil_tmp31) = (__u32 )8;
      __cil_tmp32 = 48;
      __cil_tmp33 = (unsigned long )var;
      __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
      *((__u32 *)__cil_tmp34) = (__u32 )8;
      __cil_tmp35 = 60;
      __cil_tmp36 = (unsigned long )var;
      __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
      *((__u32 *)__cil_tmp37) = (__u32 )8;
      __cil_tmp38 = 72;
      __cil_tmp39 = (unsigned long )var;
      __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
      *((__u32 *)__cil_tmp40) = (__u32 )0;
      __cil_tmp41 = (unsigned long )var;
      __cil_tmp42 = __cil_tmp41 + 68UL;
      *((__u32 *)__cil_tmp42) = (__u32 )0;
      goto switch_break___0;
      case_32___0: 
      __cil_tmp43 = (unsigned long )var;
      __cil_tmp44 = __cil_tmp43 + 32UL;
      *((__u32 *)__cil_tmp44) = (__u32 )16;
      __cil_tmp45 = (unsigned long )var;
      __cil_tmp46 = __cil_tmp45 + 44UL;
      *((__u32 *)__cil_tmp46) = (__u32 )8;
      __cil_tmp47 = (unsigned long )var;
      __cil_tmp48 = __cil_tmp47 + 56UL;
      *((__u32 *)__cil_tmp48) = (__u32 )0;
      __cil_tmp49 = 36;
      __cil_tmp50 = (unsigned long )var;
      __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
      *((__u32 *)__cil_tmp51) = (__u32 )8;
      __cil_tmp52 = 48;
      __cil_tmp53 = (unsigned long )var;
      __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
      *((__u32 *)__cil_tmp54) = (__u32 )8;
      __cil_tmp55 = 60;
      __cil_tmp56 = (unsigned long )var;
      __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
      *((__u32 *)__cil_tmp57) = (__u32 )8;
      __cil_tmp58 = 72;
      __cil_tmp59 = (unsigned long )var;
      __cil_tmp60 = __cil_tmp59 + __cil_tmp58;
      *((__u32 *)__cil_tmp60) = (__u32 )8;
      __cil_tmp61 = (unsigned long )var;
      __cil_tmp62 = __cil_tmp61 + 68UL;
      *((__u32 *)__cil_tmp62) = (__u32 )24;
      goto switch_break___0;
      switch_default___0: 
      drm_err("vmw_fb_check_var", "Bad depth %u.\n", depth);
      return (-22);
    } else {
      switch_break___0: ;
    }
  }
  __cil_tmp63 = (unsigned long )vmw_priv___0;
  __cil_tmp64 = __cil_tmp63 + 2156UL;
  __cil_tmp65 = *((uint32_t *)__cil_tmp64);
  __cil_tmp66 = __cil_tmp65 & 524288U;
  if (! __cil_tmp66) {
    __cil_tmp67 = (unsigned long )var;
    __cil_tmp68 = __cil_tmp67 + 16UL;
    __cil_tmp69 = *((__u32 *)__cil_tmp68);
    if (__cil_tmp69 != 0U) {
      drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
      return (-22);
    } else {
      __cil_tmp70 = (unsigned long )var;
      __cil_tmp71 = __cil_tmp70 + 20UL;
      __cil_tmp72 = *((__u32 *)__cil_tmp71);
      if (__cil_tmp72 != 0U) {
        drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
        return (-22);
      }
    }
  }
  __cil_tmp73 = (unsigned long )par;
  __cil_tmp74 = __cil_tmp73 + 132UL;
  __cil_tmp75 = *((unsigned int *)__cil_tmp74);
  __cil_tmp76 = *((__u32 *)var);
  __cil_tmp77 = (unsigned long )var;
  __cil_tmp78 = __cil_tmp77 + 16UL;
  __cil_tmp79 = *((__u32 *)__cil_tmp78);
  __cil_tmp80 = __cil_tmp79 + __cil_tmp76;
  if (__cil_tmp80 > __cil_tmp75) {
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
    return (-22);
  } else {
    __cil_tmp81 = (unsigned long )par;
    __cil_tmp82 = __cil_tmp81 + 136UL;
    __cil_tmp83 = *((unsigned int *)__cil_tmp82);
    __cil_tmp84 = (unsigned long )var;
    __cil_tmp85 = __cil_tmp84 + 4UL;
    __cil_tmp86 = *((__u32 *)__cil_tmp85);
    __cil_tmp87 = (unsigned long )var;
    __cil_tmp88 = __cil_tmp87 + 20UL;
    __cil_tmp89 = *((__u32 *)__cil_tmp88);
    __cil_tmp90 = __cil_tmp89 + __cil_tmp86;
    if (__cil_tmp90 > __cil_tmp83) {
      drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
      return (-22);
    }
  }
  __cil_tmp91 = 368;
  __cil_tmp92 = (unsigned long )info;
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
  __cil_tmp94 = *((__u32 *)__cil_tmp93);
  __cil_tmp95 = (unsigned long )var;
  __cil_tmp96 = __cil_tmp95 + 4UL;
  __cil_tmp97 = *((__u32 *)__cil_tmp96);
  __cil_tmp98 = (unsigned long )var;
  __cil_tmp99 = __cil_tmp98 + 20UL;
  __cil_tmp100 = *((__u32 *)__cil_tmp99);
  __cil_tmp101 = __cil_tmp100 + __cil_tmp97;
  tmp___7 = vmw_kms_validate_mode_vram(vmw_priv___0, __cil_tmp94, __cil_tmp101);
  if (! tmp___7) {
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
    return (-22);
  }
  return (0);
}
}
static int vmw_fb_set_par(struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  int ret ;
  int __ret_warn_on ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  __u32 __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  __u32 __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  __u32 __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  __u32 __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  __u32 __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  __u32 __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  __u32 __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  long __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;

  {
  __cil_tmp9 = (unsigned long )info;
  __cil_tmp10 = __cil_tmp9 + 1160UL;
  __cil_tmp11 = *((void **)__cil_tmp10);
  par = (struct vmw_fb_par *)__cil_tmp11;
  vmw_priv___0 = *((struct vmw_private **)par);
  __cil_tmp12 = (unsigned long )info;
  __cil_tmp13 = __cil_tmp12 + 160UL;
  __cil_tmp14 = *((__u32 *)__cil_tmp13);
  __cil_tmp15 = 164;
  __cil_tmp16 = (unsigned long )info;
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
  __cil_tmp18 = *((__u32 *)__cil_tmp17);
  __cil_tmp19 = 368;
  __cil_tmp20 = (unsigned long )info;
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
  __cil_tmp22 = *((__u32 *)__cil_tmp21);
  __cil_tmp23 = (unsigned long )par;
  __cil_tmp24 = __cil_tmp23 + 128UL;
  __cil_tmp25 = *((unsigned int *)__cil_tmp24);
  __cil_tmp26 = (unsigned long )par;
  __cil_tmp27 = __cil_tmp26 + 124UL;
  __cil_tmp28 = *((unsigned int *)__cil_tmp27);
  ret = vmw_kms_write_svga(vmw_priv___0, __cil_tmp14, __cil_tmp18, __cil_tmp22, __cil_tmp25,
                           __cil_tmp28);
  if (ret) {
    return (ret);
  }
  __cil_tmp29 = (unsigned long )vmw_priv___0;
  __cil_tmp30 = __cil_tmp29 + 2156UL;
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
  if (__cil_tmp31 & 524288U) {
    __cil_tmp32 = (uint32_t )1;
    vmw_write(vmw_priv___0, 34U, __cil_tmp32);
    __cil_tmp33 = (uint32_t )0;
    vmw_write(vmw_priv___0, 35U, __cil_tmp33);
    __cil_tmp34 = (uint32_t )1;
    vmw_write(vmw_priv___0, 36U, __cil_tmp34);
    __cil_tmp35 = 176;
    __cil_tmp36 = (unsigned long )info;
    __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
    __cil_tmp38 = *((__u32 *)__cil_tmp37);
    vmw_write(vmw_priv___0, 37U, __cil_tmp38);
    __cil_tmp39 = 180;
    __cil_tmp40 = (unsigned long )info;
    __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
    __cil_tmp42 = *((__u32 *)__cil_tmp41);
    vmw_write(vmw_priv___0, 38U, __cil_tmp42);
    __cil_tmp43 = (unsigned long )info;
    __cil_tmp44 = __cil_tmp43 + 160UL;
    __cil_tmp45 = *((__u32 *)__cil_tmp44);
    vmw_write(vmw_priv___0, 39U, __cil_tmp45);
    __cil_tmp46 = 164;
    __cil_tmp47 = (unsigned long )info;
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
    __cil_tmp49 = *((__u32 *)__cil_tmp48);
    vmw_write(vmw_priv___0, 40U, __cil_tmp49);
    vmw_write(vmw_priv___0, 35U, 4294967295U);
  }
  tmp___7 = vmw_read(vmw_priv___0, 14U);
  if (tmp___7 != 0U) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __ret_warn_on = tmp___8;
  __cil_tmp50 = ! __ret_warn_on;
  __cil_tmp51 = ! __cil_tmp50;
  __cil_tmp52 = (long )__cil_tmp51;
  tmp___9 = ldv__builtin_expect(__cil_tmp52, 0L);
  if (tmp___9) {
    __cil_tmp53 = 187;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c",
                       __cil_tmp53);
  }
  __cil_tmp54 = ! __ret_warn_on;
  __cil_tmp55 = ! __cil_tmp54;
  __cil_tmp56 = (long )__cil_tmp55;
  ldv__builtin_expect(__cil_tmp56, 0L);
  return (0);
}
}
static int vmw_fb_pan_display(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 

  {
  return (0);
}
}
static int vmw_fb_blank(int blank , struct fb_info *info ) 
{ 

  {
  return (0);
}
}
static void vmw_fb_dirty_flush(struct vmw_fb_par *par ) 
{ struct vmw_private *vmw_priv___0 ;
  struct fb_info *info ;
  int stride ;
  int *src ;
  __le32 *vram_mem ;
  unsigned long flags ;
  unsigned int x ;
  unsigned int y ;
  unsigned int w ;
  unsigned int h ;
  int i ;
  int k ;
  struct __anonstruct_cmd_430___0 *cmd ;
  raw_spinlock_t *tmp___7 ;
  unsigned int _min1 ;
  __u32 _min2 ;
  unsigned int tmp___8 ;
  unsigned int _min1___0 ;
  __u32 _min2___0 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  __u32 __cil_tmp34 ;
  __u32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  char *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  spinlock_t *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  bool __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  spinlock_t *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned int *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  __u32 *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  __u32 *__cil_tmp67 ;
  __u32 __cil_tmp68 ;
  unsigned int *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int *__cil_tmp71 ;
  __u32 *__cil_tmp72 ;
  unsigned int *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  __u32 *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  __u32 *__cil_tmp81 ;
  __u32 __cil_tmp82 ;
  unsigned int *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int *__cil_tmp85 ;
  __u32 *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  spinlock_t *__cil_tmp101 ;
  unsigned int __cil_tmp102 ;
  unsigned int __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  __u32 __cil_tmp107 ;
  __u32 __cil_tmp108 ;
  __u32 __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  __u32 __cil_tmp119 ;
  __u32 __cil_tmp120 ;
  __u32 __cil_tmp121 ;
  int *__cil_tmp122 ;
  int __cil_tmp123 ;
  u32 __cil_tmp124 ;
  __le32 *__cil_tmp125 ;
  void *__cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  int __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;

  {
  vmw_priv___0 = *((struct vmw_private **)par);
  __cil_tmp28 = (unsigned long )vmw_priv___0;
  __cil_tmp29 = __cil_tmp28 + 2600UL;
  __cil_tmp30 = *((void **)__cil_tmp29);
  info = (struct fb_info *)__cil_tmp30;
  __cil_tmp31 = 368;
  __cil_tmp32 = (unsigned long )info;
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
  __cil_tmp34 = *((__u32 *)__cil_tmp33);
  __cil_tmp35 = __cil_tmp34 / 4U;
  stride = (int )__cil_tmp35;
  __cil_tmp36 = (unsigned long )info;
  __cil_tmp37 = __cil_tmp36 + 1120UL;
  __cil_tmp38 = *((char **)__cil_tmp37);
  src = (int *)__cil_tmp38;
  __cil_tmp39 = (unsigned long )par;
  __cil_tmp40 = __cil_tmp39 + 144UL;
  __cil_tmp41 = *((void **)__cil_tmp40);
  vram_mem = (__le32 *)__cil_tmp41;
  __cil_tmp42 = (unsigned long )vmw_priv___0;
  __cil_tmp43 = __cil_tmp42 + 134656UL;
  if (*((bool *)__cil_tmp43)) {
    return;
  }
  while (1) {

    while (1) {
      __cil_tmp44 = (unsigned long )par;
      __cil_tmp45 = __cil_tmp44 + 160UL;
      __cil_tmp46 = (spinlock_t *)__cil_tmp45;
      tmp___7 = spinlock_check(__cil_tmp46);
      flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp47 = 184;
  __cil_tmp48 = (unsigned long )par;
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
  __cil_tmp50 = *((bool *)__cil_tmp49);
  if (! __cil_tmp50) {
    __cil_tmp51 = (unsigned long )par;
    __cil_tmp52 = __cil_tmp51 + 160UL;
    __cil_tmp53 = (spinlock_t *)__cil_tmp52;
    spin_unlock_irqrestore(__cil_tmp53, flags);
    return;
  }
  __cil_tmp54 = 188;
  __cil_tmp55 = (unsigned long )par;
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
  x = *((unsigned int *)__cil_tmp56);
  __cil_tmp57 = 192;
  __cil_tmp58 = (unsigned long )par;
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
  y = *((unsigned int *)__cil_tmp59);
  __cil_tmp60 = & _min1;
  __cil_tmp61 = 196;
  __cil_tmp62 = (unsigned long )par;
  __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
  *__cil_tmp60 = *((unsigned int *)__cil_tmp63);
  __cil_tmp64 = & _min2;
  __cil_tmp65 = (unsigned long )info;
  __cil_tmp66 = __cil_tmp65 + 160UL;
  *__cil_tmp64 = *((__u32 *)__cil_tmp66);
  __cil_tmp67 = & _min2;
  __cil_tmp68 = *__cil_tmp67;
  __cil_tmp69 = & _min1;
  __cil_tmp70 = *__cil_tmp69;
  if (__cil_tmp70 < __cil_tmp68) {
    __cil_tmp71 = & _min1;
    tmp___8 = *__cil_tmp71;
  } else {
    __cil_tmp72 = & _min2;
    tmp___8 = *__cil_tmp72;
  }
  w = tmp___8 - x;
  __cil_tmp73 = & _min1___0;
  __cil_tmp74 = 200;
  __cil_tmp75 = (unsigned long )par;
  __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
  *__cil_tmp73 = *((unsigned int *)__cil_tmp76);
  __cil_tmp77 = & _min2___0;
  __cil_tmp78 = 164;
  __cil_tmp79 = (unsigned long )info;
  __cil_tmp80 = __cil_tmp79 + __cil_tmp78;
  *__cil_tmp77 = *((__u32 *)__cil_tmp80);
  __cil_tmp81 = & _min2___0;
  __cil_tmp82 = *__cil_tmp81;
  __cil_tmp83 = & _min1___0;
  __cil_tmp84 = *__cil_tmp83;
  if (__cil_tmp84 < __cil_tmp82) {
    __cil_tmp85 = & _min1___0;
    tmp___9 = *__cil_tmp85;
  } else {
    __cil_tmp86 = & _min2___0;
    tmp___9 = *__cil_tmp86;
  }
  h = tmp___9 - y;
  tmp___10 = 0U;
  __cil_tmp87 = 196;
  __cil_tmp88 = (unsigned long )par;
  __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
  *((unsigned int *)__cil_tmp89) = tmp___10;
  __cil_tmp90 = 188;
  __cil_tmp91 = (unsigned long )par;
  __cil_tmp92 = __cil_tmp91 + __cil_tmp90;
  *((unsigned int *)__cil_tmp92) = tmp___10;
  tmp___11 = 0U;
  __cil_tmp93 = 200;
  __cil_tmp94 = (unsigned long )par;
  __cil_tmp95 = __cil_tmp94 + __cil_tmp93;
  *((unsigned int *)__cil_tmp95) = tmp___11;
  __cil_tmp96 = 192;
  __cil_tmp97 = (unsigned long )par;
  __cil_tmp98 = __cil_tmp97 + __cil_tmp96;
  *((unsigned int *)__cil_tmp98) = tmp___11;
  __cil_tmp99 = (unsigned long )par;
  __cil_tmp100 = __cil_tmp99 + 160UL;
  __cil_tmp101 = (spinlock_t *)__cil_tmp100;
  spin_unlock_irqrestore(__cil_tmp101, flags);
  __cil_tmp102 = (unsigned int )stride;
  __cil_tmp103 = y * __cil_tmp102;
  i = (int )__cil_tmp103;
  while (1) {
    __cil_tmp104 = 344;
    __cil_tmp105 = (unsigned long )info;
    __cil_tmp106 = __cil_tmp105 + __cil_tmp104;
    __cil_tmp107 = *((__u32 *)__cil_tmp106);
    __cil_tmp108 = __cil_tmp107 / 4U;
    __cil_tmp109 = (__u32 )i;
    if (! (__cil_tmp109 < __cil_tmp108)) {
      goto while_break___1;
    }
    __cil_tmp110 = (unsigned int )i;
    __cil_tmp111 = __cil_tmp110 + x;
    k = (int )__cil_tmp111;
    while (1) {
      __cil_tmp112 = (unsigned int )i;
      __cil_tmp113 = __cil_tmp112 + x;
      __cil_tmp114 = __cil_tmp113 + w;
      __cil_tmp115 = (unsigned int )k;
      if (__cil_tmp115 < __cil_tmp114) {
        __cil_tmp116 = 344;
        __cil_tmp117 = (unsigned long )info;
        __cil_tmp118 = __cil_tmp117 + __cil_tmp116;
        __cil_tmp119 = *((__u32 *)__cil_tmp118);
        __cil_tmp120 = __cil_tmp119 / 4U;
        __cil_tmp121 = (__u32 )k;
        if (! (__cil_tmp121 < __cil_tmp120)) {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
      __cil_tmp122 = src + k;
      __cil_tmp123 = *__cil_tmp122;
      __cil_tmp124 = (u32 )__cil_tmp123;
      __cil_tmp125 = vram_mem + k;
      __cil_tmp126 = (void *)__cil_tmp125;
      iowrite32(__cil_tmp124, __cil_tmp126);
      k ++;
    }
    while_break___2: 
    i += stride;
  }
  while_break___1: 
  __cil_tmp127 = (uint32_t )20UL;
  tmp___12 = vmw_fifo_reserve(vmw_priv___0, __cil_tmp127);
  cmd = (struct __anonstruct_cmd_430___0 *)tmp___12;
  __cil_tmp128 = (void *)0;
  __cil_tmp129 = (unsigned long )__cil_tmp128;
  __cil_tmp130 = (unsigned long )cmd;
  __cil_tmp131 = __cil_tmp130 == __cil_tmp129;
  __cil_tmp132 = ! __cil_tmp131;
  __cil_tmp133 = ! __cil_tmp132;
  __cil_tmp134 = (long )__cil_tmp133;
  tmp___13 = ldv__builtin_expect(__cil_tmp134, 0L);
  if (tmp___13) {
    drm_err("vmw_fb_dirty_flush", "Fifo reserve failed.\n");
    return;
  }
  *((uint32_t *)cmd) = (__u32 )1;
  __cil_tmp135 = (unsigned long )cmd;
  __cil_tmp136 = __cil_tmp135 + 4UL;
  *((uint32 *)__cil_tmp136) = x;
  __cil_tmp137 = 8;
  __cil_tmp138 = (unsigned long )cmd;
  __cil_tmp139 = __cil_tmp138 + __cil_tmp137;
  *((uint32 *)__cil_tmp139) = y;
  __cil_tmp140 = 12;
  __cil_tmp141 = (unsigned long )cmd;
  __cil_tmp142 = __cil_tmp141 + __cil_tmp140;
  *((uint32 *)__cil_tmp142) = w;
  __cil_tmp143 = 16;
  __cil_tmp144 = (unsigned long )cmd;
  __cil_tmp145 = __cil_tmp144 + __cil_tmp143;
  *((uint32 *)__cil_tmp145) = h;
  __cil_tmp146 = (uint32_t )20UL;
  vmw_fifo_commit(vmw_priv___0, __cil_tmp146);
  return;
}
}
static void vmw_fb_dirty_mark(struct vmw_fb_par *par , unsigned int x1 , unsigned int y1 ,
                              unsigned int width , unsigned int height ) 
{ struct fb_info *info ;
  unsigned long flags ;
  unsigned int x2 ;
  unsigned int y2 ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_private *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct delayed_work *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;

  {
  __cil_tmp13 = *((struct vmw_private **)par);
  __cil_tmp14 = (unsigned long )__cil_tmp13;
  __cil_tmp15 = __cil_tmp14 + 2600UL;
  __cil_tmp16 = *((void **)__cil_tmp15);
  info = (struct fb_info *)__cil_tmp16;
  x2 = x1 + width;
  y2 = y1 + height;
  while (1) {

    while (1) {
      __cil_tmp17 = (unsigned long )par;
      __cil_tmp18 = __cil_tmp17 + 160UL;
      __cil_tmp19 = (spinlock_t *)__cil_tmp18;
      tmp___7 = spinlock_check(__cil_tmp19);
      flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp20 = 196;
  __cil_tmp21 = (unsigned long )par;
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
  __cil_tmp23 = *((unsigned int *)__cil_tmp22);
  __cil_tmp24 = 188;
  __cil_tmp25 = (unsigned long )par;
  __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
  __cil_tmp27 = *((unsigned int *)__cil_tmp26);
  if (__cil_tmp27 == __cil_tmp23) {
    __cil_tmp28 = 188;
    __cil_tmp29 = (unsigned long )par;
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
    *((unsigned int *)__cil_tmp30) = x1;
    __cil_tmp31 = 192;
    __cil_tmp32 = (unsigned long )par;
    __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
    *((unsigned int *)__cil_tmp33) = y1;
    __cil_tmp34 = 196;
    __cil_tmp35 = (unsigned long )par;
    __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
    *((unsigned int *)__cil_tmp36) = x2;
    __cil_tmp37 = 200;
    __cil_tmp38 = (unsigned long )par;
    __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
    *((unsigned int *)__cil_tmp39) = y2;
    __cil_tmp40 = 184;
    __cil_tmp41 = (unsigned long )par;
    __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
    if (*((bool *)__cil_tmp42)) {
      __cil_tmp43 = (unsigned long )info;
      __cil_tmp44 = __cil_tmp43 + 960UL;
      __cil_tmp45 = (struct delayed_work *)__cil_tmp44;
      schedule_delayed_work(__cil_tmp45, 8UL);
    }
  } else {
    __cil_tmp46 = 188;
    __cil_tmp47 = (unsigned long )par;
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
    __cil_tmp49 = *((unsigned int *)__cil_tmp48);
    if (x1 < __cil_tmp49) {
      __cil_tmp50 = 188;
      __cil_tmp51 = (unsigned long )par;
      __cil_tmp52 = __cil_tmp51 + __cil_tmp50;
      *((unsigned int *)__cil_tmp52) = x1;
    }
    __cil_tmp53 = 192;
    __cil_tmp54 = (unsigned long )par;
    __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
    __cil_tmp56 = *((unsigned int *)__cil_tmp55);
    if (y1 < __cil_tmp56) {
      __cil_tmp57 = 192;
      __cil_tmp58 = (unsigned long )par;
      __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
      *((unsigned int *)__cil_tmp59) = y1;
    }
    __cil_tmp60 = 196;
    __cil_tmp61 = (unsigned long )par;
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
    __cil_tmp63 = *((unsigned int *)__cil_tmp62);
    if (x2 > __cil_tmp63) {
      __cil_tmp64 = 196;
      __cil_tmp65 = (unsigned long )par;
      __cil_tmp66 = __cil_tmp65 + __cil_tmp64;
      *((unsigned int *)__cil_tmp66) = x2;
    }
    __cil_tmp67 = 200;
    __cil_tmp68 = (unsigned long )par;
    __cil_tmp69 = __cil_tmp68 + __cil_tmp67;
    __cil_tmp70 = *((unsigned int *)__cil_tmp69);
    if (y2 > __cil_tmp70) {
      __cil_tmp71 = 200;
      __cil_tmp72 = (unsigned long )par;
      __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
      *((unsigned int *)__cil_tmp73) = y2;
    }
  }
  __cil_tmp74 = (unsigned long )par;
  __cil_tmp75 = __cil_tmp74 + 160UL;
  __cil_tmp76 = (spinlock_t *)__cil_tmp75;
  spin_unlock_irqrestore(__cil_tmp76, flags);
  return;
}
}
static void vmw_deferred_io(struct fb_info *info , struct list_head *pagelist ) 
{ struct vmw_fb_par *par ;
  unsigned long start ;
  unsigned long end ;
  unsigned long min ;
  unsigned long max ;
  unsigned long flags ;
  struct page *page ;
  int y1 ;
  int y2 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___7 ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___8 ;
  raw_spinlock_t *tmp___9 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  struct list_head *__cil_tmp26 ;
  struct page *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long *__cil_tmp44 ;
  unsigned long *__cil_tmp45 ;
  unsigned long *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long *__cil_tmp50 ;
  unsigned long *__cil_tmp51 ;
  unsigned long *__cil_tmp52 ;
  unsigned long *__cil_tmp53 ;
  unsigned long *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long *__cil_tmp58 ;
  unsigned long *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct list_head *__cil_tmp62 ;
  struct page *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  __u32 __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  __u32 __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  spinlock_t *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  spinlock_t *__cil_tmp102 ;

  {
  __cil_tmp23 = (unsigned long )info;
  __cil_tmp24 = __cil_tmp23 + 1160UL;
  __cil_tmp25 = *((void **)__cil_tmp24);
  par = (struct vmw_fb_par *)__cil_tmp25;
  min = ~ 0UL;
  max = 0UL;
  __cil_tmp26 = *((struct list_head **)pagelist);
  __mptr = __cil_tmp26;
  __cil_tmp27 = (struct page *)0;
  __cil_tmp28 = (unsigned long )__cil_tmp27;
  __cil_tmp29 = __cil_tmp28 + 32UL;
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
  __cil_tmp31 = (unsigned int )__cil_tmp30;
  __cil_tmp32 = (char *)__mptr;
  __cil_tmp33 = __cil_tmp32 - __cil_tmp31;
  page = (struct page *)__cil_tmp33;
  while (1) {
    __cil_tmp34 = (unsigned long )pagelist;
    __cil_tmp35 = (unsigned long )page;
    __cil_tmp36 = __cil_tmp35 + 32UL;
    __cil_tmp37 = (struct list_head *)__cil_tmp36;
    __cil_tmp38 = (unsigned long )__cil_tmp37;
    if (! (__cil_tmp38 != __cil_tmp34)) {
      goto while_break;
    }
    __cil_tmp39 = (unsigned long )page;
    __cil_tmp40 = __cil_tmp39 + 16UL;
    __cil_tmp41 = *((unsigned long *)__cil_tmp40);
    start = __cil_tmp41 << 12;
    __cil_tmp42 = 1UL << 12;
    __cil_tmp43 = start + __cil_tmp42;
    end = __cil_tmp43 - 1UL;
    __cil_tmp44 = & _min1;
    *__cil_tmp44 = min;
    __cil_tmp45 = & _min2;
    *__cil_tmp45 = start;
    __cil_tmp46 = & _min2;
    __cil_tmp47 = *__cil_tmp46;
    __cil_tmp48 = & _min1;
    __cil_tmp49 = *__cil_tmp48;
    if (__cil_tmp49 < __cil_tmp47) {
      __cil_tmp50 = & _min1;
      tmp___7 = *__cil_tmp50;
    } else {
      __cil_tmp51 = & _min2;
      tmp___7 = *__cil_tmp51;
    }
    min = tmp___7;
    __cil_tmp52 = & _max1;
    *__cil_tmp52 = max;
    __cil_tmp53 = & _max2;
    *__cil_tmp53 = end;
    __cil_tmp54 = & _max2;
    __cil_tmp55 = *__cil_tmp54;
    __cil_tmp56 = & _max1;
    __cil_tmp57 = *__cil_tmp56;
    if (__cil_tmp57 > __cil_tmp55) {
      __cil_tmp58 = & _max1;
      tmp___8 = *__cil_tmp58;
    } else {
      __cil_tmp59 = & _max2;
      tmp___8 = *__cil_tmp59;
    }
    max = tmp___8;
    __cil_tmp60 = (unsigned long )page;
    __cil_tmp61 = __cil_tmp60 + 32UL;
    __cil_tmp62 = *((struct list_head **)__cil_tmp61);
    __mptr___0 = __cil_tmp62;
    __cil_tmp63 = (struct page *)0;
    __cil_tmp64 = (unsigned long )__cil_tmp63;
    __cil_tmp65 = __cil_tmp64 + 32UL;
    __cil_tmp66 = (struct list_head *)__cil_tmp65;
    __cil_tmp67 = (unsigned int )__cil_tmp66;
    __cil_tmp68 = (char *)__mptr___0;
    __cil_tmp69 = __cil_tmp68 - __cil_tmp67;
    page = (struct page *)__cil_tmp69;
  }
  while_break: ;
  if (min < max) {
    __cil_tmp70 = 368;
    __cil_tmp71 = (unsigned long )info;
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
    __cil_tmp73 = *((__u32 *)__cil_tmp72);
    __cil_tmp74 = (unsigned long )__cil_tmp73;
    __cil_tmp75 = min / __cil_tmp74;
    y1 = (int )__cil_tmp75;
    __cil_tmp76 = 368;
    __cil_tmp77 = (unsigned long )info;
    __cil_tmp78 = __cil_tmp77 + __cil_tmp76;
    __cil_tmp79 = *((__u32 *)__cil_tmp78);
    __cil_tmp80 = (unsigned long )__cil_tmp79;
    __cil_tmp81 = max / __cil_tmp80;
    __cil_tmp82 = __cil_tmp81 + 1UL;
    y2 = (int )__cil_tmp82;
    while (1) {

      while (1) {
        __cil_tmp83 = (unsigned long )par;
        __cil_tmp84 = __cil_tmp83 + 160UL;
        __cil_tmp85 = (spinlock_t *)__cil_tmp84;
        tmp___9 = spinlock_check(__cil_tmp85);
        flags = _raw_spin_lock_irqsave(tmp___9);
        goto while_break___1;
      }
      while_break___1: ;
      goto while_break___0;
    }
    while_break___0: 
    __cil_tmp86 = 188;
    __cil_tmp87 = (unsigned long )par;
    __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
    *((unsigned int *)__cil_tmp88) = 0U;
    __cil_tmp89 = 192;
    __cil_tmp90 = (unsigned long )par;
    __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
    *((unsigned int *)__cil_tmp91) = (unsigned int )y1;
    __cil_tmp92 = 196;
    __cil_tmp93 = (unsigned long )par;
    __cil_tmp94 = __cil_tmp93 + __cil_tmp92;
    __cil_tmp95 = (unsigned long )info;
    __cil_tmp96 = __cil_tmp95 + 160UL;
    *((unsigned int *)__cil_tmp94) = *((__u32 *)__cil_tmp96);
    __cil_tmp97 = 200;
    __cil_tmp98 = (unsigned long )par;
    __cil_tmp99 = __cil_tmp98 + __cil_tmp97;
    *((unsigned int *)__cil_tmp99) = (unsigned int )y2;
    __cil_tmp100 = (unsigned long )par;
    __cil_tmp101 = __cil_tmp100 + 160UL;
    __cil_tmp102 = (spinlock_t *)__cil_tmp101;
    spin_unlock_irqrestore(__cil_tmp102, flags);
  }
  vmw_fb_dirty_flush(par);
  return;
}
}
struct fb_deferred_io vmw_defio  =    {8UL, {{0}, {{{{{0U}}, 0U, 0U, (void *)0}}}, {(struct list_head *)0, (struct list_head *)0},
          (struct task_struct *)0, (char *)0, (void *)0}, {(struct list_head *)0,
                                                           (struct list_head *)0},
    & vmw_deferred_io};
static void vmw_fb_fillrect(struct fb_info *info , struct fb_fillrect *rect ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32 __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32 __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32 __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  cfb_fillrect(info, rect);
  __cil_tmp3 = (unsigned long )info;
  __cil_tmp4 = __cil_tmp3 + 1160UL;
  __cil_tmp5 = *((void **)__cil_tmp4);
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
  __cil_tmp7 = *((__u32 *)rect);
  __cil_tmp8 = __cil_tmp7;
  __cil_tmp9 = (unsigned long )rect;
  __cil_tmp10 = __cil_tmp9 + 4UL;
  __cil_tmp11 = *((__u32 *)__cil_tmp10);
  __cil_tmp12 = __cil_tmp11;
  __cil_tmp13 = (unsigned long )rect;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((__u32 *)__cil_tmp14);
  __cil_tmp16 = __cil_tmp15;
  __cil_tmp17 = (unsigned long )rect;
  __cil_tmp18 = __cil_tmp17 + 12UL;
  __cil_tmp19 = *((__u32 *)__cil_tmp18);
  __cil_tmp20 = __cil_tmp19;
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  return;
}
}
static void vmw_fb_copyarea(struct fb_info *info , struct fb_copyarea *region ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32 __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32 __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32 __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  cfb_copyarea(info, region);
  __cil_tmp3 = (unsigned long )info;
  __cil_tmp4 = __cil_tmp3 + 1160UL;
  __cil_tmp5 = *((void **)__cil_tmp4);
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
  __cil_tmp7 = *((__u32 *)region);
  __cil_tmp8 = __cil_tmp7;
  __cil_tmp9 = (unsigned long )region;
  __cil_tmp10 = __cil_tmp9 + 4UL;
  __cil_tmp11 = *((__u32 *)__cil_tmp10);
  __cil_tmp12 = __cil_tmp11;
  __cil_tmp13 = (unsigned long )region;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((__u32 *)__cil_tmp14);
  __cil_tmp16 = __cil_tmp15;
  __cil_tmp17 = (unsigned long )region;
  __cil_tmp18 = __cil_tmp17 + 12UL;
  __cil_tmp19 = *((__u32 *)__cil_tmp18);
  __cil_tmp20 = __cil_tmp19;
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  return;
}
}
static void vmw_fb_imageblit(struct fb_info *info , struct fb_image *image ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct vmw_fb_par *__cil_tmp6 ;
  __u32 __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  __u32 __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u32 __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  __u32 __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  cfb_imageblit(info, image);
  __cil_tmp3 = (unsigned long )info;
  __cil_tmp4 = __cil_tmp3 + 1160UL;
  __cil_tmp5 = *((void **)__cil_tmp4);
  __cil_tmp6 = (struct vmw_fb_par *)__cil_tmp5;
  __cil_tmp7 = *((__u32 *)image);
  __cil_tmp8 = __cil_tmp7;
  __cil_tmp9 = (unsigned long )image;
  __cil_tmp10 = __cil_tmp9 + 4UL;
  __cil_tmp11 = *((__u32 *)__cil_tmp10);
  __cil_tmp12 = __cil_tmp11;
  __cil_tmp13 = (unsigned long )image;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((__u32 *)__cil_tmp14);
  __cil_tmp16 = __cil_tmp15;
  __cil_tmp17 = (unsigned long )image;
  __cil_tmp18 = __cil_tmp17 + 12UL;
  __cil_tmp19 = *((__u32 *)__cil_tmp18);
  __cil_tmp20 = __cil_tmp19;
  vmw_fb_dirty_mark(__cil_tmp6, __cil_tmp8, __cil_tmp12, __cil_tmp16, __cil_tmp20);
  return;
}
}
static struct fb_ops vmw_fb_ops  = 
     {& __this_module, (int (*)(struct fb_info *info , int user ))0, (int (*)(struct fb_info *info ,
                                                                            int user ))0,
    (ssize_t (*)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ))0,
    (ssize_t (*)(struct fb_info *info , char *buf , size_t count , loff_t *ppos ))0,
    & vmw_fb_check_var, & vmw_fb_set_par, & vmw_fb_setcolreg, (int (*)(struct fb_cmap *cmap ,
                                                                       struct fb_info *info ))0,
    & vmw_fb_blank, & vmw_fb_pan_display, & vmw_fb_fillrect, & vmw_fb_copyarea, & vmw_fb_imageblit,
    (int (*)(struct fb_info *info , struct fb_cursor *cursor ))0, (void (*)(struct fb_info *info ,
                                                                            int angle ))0,
    (int (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info , unsigned int cmd ,
                                                unsigned long arg ))0, (int (*)(struct fb_info *info ,
                                                                                unsigned int cmd ,
                                                                                unsigned long arg ))0,
    (int (*)(struct fb_info *info , struct vm_area_struct *vma ))0, (void (*)(struct fb_info *info ,
                                                                              struct fb_blit_caps *caps ,
                                                                              struct fb_var_screeninfo *var ))0,
    (void (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info ))0, (int (*)(struct fb_info *info ))0};
static int vmw_fb_create_bo(struct vmw_private *vmw_priv___0 ,
                            size_t size , struct vmw_dma_buffer **out ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_placement ne_placement ;
  int ret ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  struct ttm_placement *__cil_tmp10 ;
  struct ttm_placement *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct ttm_lock *__cil_tmp19 ;
  bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  bool __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_lock *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;

  {
  __cil_tmp10 = & ne_placement;
  __cil_tmp11 = & vmw_vram_ne_placement;
  *__cil_tmp10 = *__cil_tmp11;
  __cil_tmp12 = (unsigned long )(& ne_placement) + 4UL;
  __cil_tmp13 = 1UL << 12;
  __cil_tmp14 = size + __cil_tmp13;
  __cil_tmp15 = __cil_tmp14 - 1UL;
  __cil_tmp16 = __cil_tmp15 >> 12;
  *((unsigned int *)__cil_tmp12) = (unsigned int )__cil_tmp16;
  __cil_tmp17 = (unsigned long )vmw_priv___0;
  __cil_tmp18 = __cil_tmp17 + 134392UL;
  __cil_tmp19 = (struct ttm_lock *)__cil_tmp18;
  __cil_tmp20 = (bool )0;
  ret = ttm_write_lock(__cil_tmp19, __cil_tmp20);
  __cil_tmp21 = ret != 0;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___7) {
    return (ret);
  }
  tmp___8 = kmalloc(416UL, 208U);
  vmw_bo = (struct vmw_dma_buffer *)tmp___8;
  if (! vmw_bo) {
    goto err_unlock;
  }
  __cil_tmp25 = (bool )0;
  ret = vmw_dmabuf_init(vmw_priv___0, vmw_bo, size, & ne_placement, __cil_tmp25, & vmw_dmabuf_bo_free);
  __cil_tmp26 = ret != 0;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___9) {
    goto err_unlock;
  }
  *out = vmw_bo;
  __cil_tmp30 = (unsigned long )vmw_priv___0;
  __cil_tmp31 = __cil_tmp30 + 134392UL;
  __cil_tmp32 = (struct ttm_lock *)__cil_tmp31;
  ttm_write_unlock(__cil_tmp32);
  return (0);
  err_unlock: 
  __cil_tmp33 = (unsigned long )vmw_priv___0;
  __cil_tmp34 = __cil_tmp33 + 134392UL;
  __cil_tmp35 = (struct ttm_lock *)__cil_tmp34;
  ttm_write_unlock(__cil_tmp35);
  return (ret);
}
}
static struct lock_class_key __key___12  ;
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) 
{ struct device *device ;
  struct vmw_fb_par *par ;
  struct fb_info *info ;
  unsigned int initial_width ;
  unsigned int initial_height ;
  unsigned int fb_width ;
  unsigned int fb_height ;
  unsigned int fb_bpp ;
  unsigned int fb_depth ;
  unsigned int fb_offset ;
  unsigned int fb_pitch ;
  unsigned int fb_size ;
  int ret ;
  uint32_t _min1 ;
  unsigned int _min2 ;
  uint32_t tmp___7 ;
  uint32_t _min1___0 ;
  unsigned int _min2___0 ;
  uint32_t tmp___8 ;
  uint32_t _min1___1 ;
  unsigned int _min2___1 ;
  uint32_t tmp___9 ;
  uint32_t _min1___2 ;
  unsigned int _min2___2 ;
  uint32_t tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct drm_device *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct pci_dev *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned int *__cil_tmp44 ;
  unsigned int *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  uint32_t *__cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  uint32_t *__cil_tmp49 ;
  unsigned int *__cil_tmp50 ;
  uint32_t *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned int *__cil_tmp54 ;
  unsigned int *__cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  uint32_t *__cil_tmp57 ;
  uint32_t __cil_tmp58 ;
  uint32_t *__cil_tmp59 ;
  unsigned int *__cil_tmp60 ;
  uint32_t *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned int *__cil_tmp64 ;
  unsigned int *__cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  uint32_t *__cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  uint32_t *__cil_tmp69 ;
  unsigned int *__cil_tmp70 ;
  uint32_t *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned int *__cil_tmp74 ;
  unsigned int *__cil_tmp75 ;
  unsigned int __cil_tmp76 ;
  uint32_t *__cil_tmp77 ;
  uint32_t __cil_tmp78 ;
  uint32_t *__cil_tmp79 ;
  unsigned int *__cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  void *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  void *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  void *__cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  long __cil_tmp109 ;
  size_t __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  struct vmw_dma_buffer **__cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  struct vmw_dma_buffer *__cil_tmp120 ;
  struct ttm_buffer_object *__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  struct vmw_dma_buffer *__cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  struct ttm_bo_kmap_obj *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct ttm_bo_kmap_obj *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  bool *__cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  char *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  u32 *__cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  void *__cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  struct apertures_struct *__cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  struct apertures_struct *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  uint32_t __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  struct apertures_struct *__cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  uint32_t __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  unsigned long __cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  spinlock_t *__cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  struct raw_spinlock *__cil_tmp305 ;
  unsigned long __cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  int __cil_tmp308 ;
  int __cil_tmp309 ;
  int __cil_tmp310 ;
  long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  struct ttm_bo_kmap_obj *__cil_tmp314 ;
  unsigned long __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  struct vmw_dma_buffer **__cil_tmp317 ;
  struct ttm_buffer_object **__cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  void *__cil_tmp321 ;
  void *__cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;

  {
  __cil_tmp33 = (unsigned long )vmw_priv___0;
  __cil_tmp34 = __cil_tmp33 + 2088UL;
  __cil_tmp35 = *((struct drm_device **)__cil_tmp34);
  __cil_tmp36 = (unsigned long )__cil_tmp35;
  __cil_tmp37 = __cil_tmp36 + 1016UL;
  __cil_tmp38 = *((struct pci_dev **)__cil_tmp37);
  __cil_tmp39 = (unsigned long )__cil_tmp38;
  __cil_tmp40 = __cil_tmp39 + 144UL;
  device = (struct device *)__cil_tmp40;
  fb_bpp = 32U;
  fb_depth = 24U;
  __cil_tmp41 = & _min1;
  __cil_tmp42 = (unsigned long )vmw_priv___0;
  __cil_tmp43 = __cil_tmp42 + 2124UL;
  *__cil_tmp41 = *((uint32_t *)__cil_tmp43);
  __cil_tmp44 = & _min2;
  *__cil_tmp44 = 2048U;
  __cil_tmp45 = & _min2;
  __cil_tmp46 = *__cil_tmp45;
  __cil_tmp47 = & _min1;
  __cil_tmp48 = *__cil_tmp47;
  if (__cil_tmp48 < __cil_tmp46) {
    __cil_tmp49 = & _min1;
    tmp___7 = *__cil_tmp49;
  } else {
    __cil_tmp50 = & _min2;
    tmp___7 = *__cil_tmp50;
  }
  fb_width = tmp___7;
  __cil_tmp51 = & _min1___0;
  __cil_tmp52 = (unsigned long )vmw_priv___0;
  __cil_tmp53 = __cil_tmp52 + 2128UL;
  *__cil_tmp51 = *((uint32_t *)__cil_tmp53);
  __cil_tmp54 = & _min2___0;
  *__cil_tmp54 = 2048U;
  __cil_tmp55 = & _min2___0;
  __cil_tmp56 = *__cil_tmp55;
  __cil_tmp57 = & _min1___0;
  __cil_tmp58 = *__cil_tmp57;
  if (__cil_tmp58 < __cil_tmp56) {
    __cil_tmp59 = & _min1___0;
    tmp___8 = *__cil_tmp59;
  } else {
    __cil_tmp60 = & _min2___0;
    tmp___8 = *__cil_tmp60;
  }
  fb_height = tmp___8;
  __cil_tmp61 = & _min1___1;
  __cil_tmp62 = (unsigned long )vmw_priv___0;
  __cil_tmp63 = __cil_tmp62 + 2132UL;
  *__cil_tmp61 = *((uint32_t *)__cil_tmp63);
  __cil_tmp64 = & _min2___1;
  *__cil_tmp64 = fb_width;
  __cil_tmp65 = & _min2___1;
  __cil_tmp66 = *__cil_tmp65;
  __cil_tmp67 = & _min1___1;
  __cil_tmp68 = *__cil_tmp67;
  if (__cil_tmp68 < __cil_tmp66) {
    __cil_tmp69 = & _min1___1;
    tmp___9 = *__cil_tmp69;
  } else {
    __cil_tmp70 = & _min2___1;
    tmp___9 = *__cil_tmp70;
  }
  initial_width = tmp___9;
  __cil_tmp71 = & _min1___2;
  __cil_tmp72 = (unsigned long )vmw_priv___0;
  __cil_tmp73 = __cil_tmp72 + 2136UL;
  *__cil_tmp71 = *((uint32_t *)__cil_tmp73);
  __cil_tmp74 = & _min2___2;
  *__cil_tmp74 = fb_height;
  __cil_tmp75 = & _min2___2;
  __cil_tmp76 = *__cil_tmp75;
  __cil_tmp77 = & _min1___2;
  __cil_tmp78 = *__cil_tmp77;
  if (__cil_tmp78 < __cil_tmp76) {
    __cil_tmp79 = & _min1___2;
    tmp___10 = *__cil_tmp79;
  } else {
    __cil_tmp80 = & _min2___2;
    tmp___10 = *__cil_tmp80;
  }
  initial_height = tmp___10;
  __cil_tmp81 = fb_width * fb_bpp;
  fb_pitch = __cil_tmp81 / 8U;
  fb_size = fb_pitch * fb_height;
  fb_offset = vmw_read(vmw_priv___0, 14U);
  info = framebuffer_alloc(208UL, device);
  if (! info) {
    return (-12);
  }
  __cil_tmp82 = (unsigned long )vmw_priv___0;
  __cil_tmp83 = __cil_tmp82 + 2600UL;
  *((void **)__cil_tmp83) = (void *)info;
  __cil_tmp84 = (unsigned long )info;
  __cil_tmp85 = __cil_tmp84 + 1160UL;
  __cil_tmp86 = *((void **)__cil_tmp85);
  par = (struct vmw_fb_par *)__cil_tmp86;
  *((struct vmw_private **)par) = vmw_priv___0;
  __cil_tmp87 = (unsigned long )par;
  __cil_tmp88 = __cil_tmp87 + 124UL;
  *((unsigned int *)__cil_tmp88) = fb_depth;
  __cil_tmp89 = (unsigned long )par;
  __cil_tmp90 = __cil_tmp89 + 128UL;
  *((unsigned int *)__cil_tmp90) = fb_bpp;
  __cil_tmp91 = (unsigned long )par;
  __cil_tmp92 = __cil_tmp91 + 8UL;
  *((void **)__cil_tmp92) = (void *)0;
  __cil_tmp93 = (unsigned long )par;
  __cil_tmp94 = __cil_tmp93 + 132UL;
  *((unsigned int *)__cil_tmp94) = fb_width;
  __cil_tmp95 = (unsigned long )par;
  __cil_tmp96 = __cil_tmp95 + 136UL;
  *((unsigned int *)__cil_tmp96) = fb_height;
  __cil_tmp97 = (unsigned long )par;
  __cil_tmp98 = __cil_tmp97 + 8UL;
  __cil_tmp99 = (unsigned long )fb_size;
  *((void **)__cil_tmp98) = vmalloc(__cil_tmp99);
  __cil_tmp100 = (void *)0;
  __cil_tmp101 = (unsigned long )__cil_tmp100;
  __cil_tmp102 = (unsigned long )par;
  __cil_tmp103 = __cil_tmp102 + 8UL;
  __cil_tmp104 = *((void **)__cil_tmp103);
  __cil_tmp105 = (unsigned long )__cil_tmp104;
  __cil_tmp106 = __cil_tmp105 == __cil_tmp101;
  __cil_tmp107 = ! __cil_tmp106;
  __cil_tmp108 = ! __cil_tmp107;
  __cil_tmp109 = (long )__cil_tmp108;
  tmp___11 = ldv__builtin_expect(__cil_tmp109, 0L);
  if (tmp___11) {
    ret = -12;
    goto err_free;
  }
  __cil_tmp110 = (size_t )fb_size;
  __cil_tmp111 = (unsigned long )par;
  __cil_tmp112 = __cil_tmp111 + 16UL;
  __cil_tmp113 = (struct vmw_dma_buffer **)__cil_tmp112;
  ret = vmw_fb_create_bo(vmw_priv___0, __cil_tmp110, __cil_tmp113);
  __cil_tmp114 = ret != 0;
  __cil_tmp115 = ! __cil_tmp114;
  __cil_tmp116 = ! __cil_tmp115;
  __cil_tmp117 = (long )__cil_tmp116;
  tmp___12 = ldv__builtin_expect(__cil_tmp117, 0L);
  if (tmp___12) {
    goto err_free;
  }
  __cil_tmp118 = (unsigned long )par;
  __cil_tmp119 = __cil_tmp118 + 16UL;
  __cil_tmp120 = *((struct vmw_dma_buffer **)__cil_tmp119);
  __cil_tmp121 = (struct ttm_buffer_object *)__cil_tmp120;
  __cil_tmp122 = 40;
  __cil_tmp123 = (unsigned long )par;
  __cil_tmp124 = __cil_tmp123 + 16UL;
  __cil_tmp125 = *((struct vmw_dma_buffer **)__cil_tmp124);
  __cil_tmp126 = (unsigned long )__cil_tmp125;
  __cil_tmp127 = __cil_tmp126 + __cil_tmp122;
  __cil_tmp128 = *((unsigned long *)__cil_tmp127);
  __cil_tmp129 = (unsigned long )par;
  __cil_tmp130 = __cil_tmp129 + 24UL;
  __cil_tmp131 = (struct ttm_bo_kmap_obj *)__cil_tmp130;
  ret = ttm_bo_kmap(__cil_tmp121, 0UL, __cil_tmp128, __cil_tmp131);
  __cil_tmp132 = ret != 0;
  __cil_tmp133 = ! __cil_tmp132;
  __cil_tmp134 = ! __cil_tmp133;
  __cil_tmp135 = (long )__cil_tmp134;
  tmp___13 = ldv__builtin_expect(__cil_tmp135, 0L);
  if (tmp___13) {
    goto err_unref;
  }
  __cil_tmp136 = (unsigned long )par;
  __cil_tmp137 = __cil_tmp136 + 144UL;
  __cil_tmp138 = (unsigned long )par;
  __cil_tmp139 = __cil_tmp138 + 24UL;
  __cil_tmp140 = (struct ttm_bo_kmap_obj *)__cil_tmp139;
  __cil_tmp141 = (unsigned long )par;
  __cil_tmp142 = __cil_tmp141 + 156UL;
  __cil_tmp143 = (bool *)__cil_tmp142;
  *((void **)__cil_tmp137) = ttm_kmap_obj_virtual(__cil_tmp140, __cil_tmp143);
  __cil_tmp144 = (unsigned long )par;
  __cil_tmp145 = __cil_tmp144 + 152UL;
  *((unsigned int *)__cil_tmp145) = fb_size;
  __cil_tmp146 = 0UL;
  __cil_tmp147 = __cil_tmp146;
  __cil_tmp148 = 320UL + __cil_tmp147;
  __cil_tmp149 = (unsigned long )info;
  __cil_tmp150 = __cil_tmp149 + __cil_tmp148;
  __cil_tmp151 = (char *)__cil_tmp150;
  strcpy(__cil_tmp151, "svgadrmfb");
  __cil_tmp152 = 348;
  __cil_tmp153 = (unsigned long )info;
  __cil_tmp154 = __cil_tmp153 + __cil_tmp152;
  *((__u32 *)__cil_tmp154) = (__u32 )0;
  __cil_tmp155 = 356;
  __cil_tmp156 = (unsigned long )info;
  __cil_tmp157 = __cil_tmp156 + __cil_tmp155;
  *((__u32 *)__cil_tmp157) = (__u32 )2;
  __cil_tmp158 = 352;
  __cil_tmp159 = (unsigned long )info;
  __cil_tmp160 = __cil_tmp159 + __cil_tmp158;
  *((__u32 *)__cil_tmp160) = (__u32 )0;
  __cil_tmp161 = 360;
  __cil_tmp162 = (unsigned long )info;
  __cil_tmp163 = __cil_tmp162 + __cil_tmp161;
  *((__u16 *)__cil_tmp163) = (__u16 )1;
  __cil_tmp164 = 362;
  __cil_tmp165 = (unsigned long )info;
  __cil_tmp166 = __cil_tmp165 + __cil_tmp164;
  *((__u16 *)__cil_tmp166) = (__u16 )1;
  __cil_tmp167 = 364;
  __cil_tmp168 = (unsigned long )info;
  __cil_tmp169 = __cil_tmp168 + __cil_tmp167;
  *((__u16 *)__cil_tmp169) = (__u16 )0;
  __cil_tmp170 = 388;
  __cil_tmp171 = (unsigned long )info;
  __cil_tmp172 = __cil_tmp171 + __cil_tmp170;
  *((__u32 *)__cil_tmp172) = (__u32 )0;
  __cil_tmp173 = 368;
  __cil_tmp174 = (unsigned long )info;
  __cil_tmp175 = __cil_tmp174 + __cil_tmp173;
  *((__u32 *)__cil_tmp175) = fb_pitch;
  __cil_tmp176 = 336;
  __cil_tmp177 = (unsigned long )info;
  __cil_tmp178 = __cil_tmp177 + __cil_tmp176;
  *((unsigned long *)__cil_tmp178) = 0UL;
  __cil_tmp179 = 344;
  __cil_tmp180 = (unsigned long )info;
  __cil_tmp181 = __cil_tmp180 + __cil_tmp179;
  *((__u32 *)__cil_tmp181) = fb_size;
  __cil_tmp182 = (unsigned long )info;
  __cil_tmp183 = __cil_tmp182 + 1136UL;
  __cil_tmp184 = 0UL;
  __cil_tmp185 = 56UL + __cil_tmp184;
  __cil_tmp186 = (unsigned long )par;
  __cil_tmp187 = __cil_tmp186 + __cil_tmp185;
  __cil_tmp188 = (u32 *)__cil_tmp187;
  *((void **)__cil_tmp183) = (void *)__cil_tmp188;
  __cil_tmp189 = (unsigned long )info;
  __cil_tmp190 = __cil_tmp189 + 1120UL;
  __cil_tmp191 = (unsigned long )par;
  __cil_tmp192 = __cil_tmp191 + 8UL;
  __cil_tmp193 = *((void **)__cil_tmp192);
  *((char **)__cil_tmp190) = (char *)__cil_tmp193;
  __cil_tmp194 = (unsigned long )info;
  __cil_tmp195 = __cil_tmp194 + 1128UL;
  *((unsigned long *)__cil_tmp195) = (unsigned long )fb_size;
  __cil_tmp196 = (unsigned long )info;
  __cil_tmp197 = __cil_tmp196 + 8UL;
  *((int *)__cil_tmp197) = 1;
  __cil_tmp198 = (unsigned long )info;
  __cil_tmp199 = __cil_tmp198 + 1080UL;
  *((struct fb_ops **)__cil_tmp199) = & vmw_fb_ops;
  __cil_tmp200 = 192;
  __cil_tmp201 = (unsigned long )info;
  __cil_tmp202 = __cil_tmp201 + __cil_tmp200;
  *((__u32 *)__cil_tmp202) = (__u32 )16;
  __cil_tmp203 = 204;
  __cil_tmp204 = (unsigned long )info;
  __cil_tmp205 = __cil_tmp204 + __cil_tmp203;
  *((__u32 *)__cil_tmp205) = (__u32 )8;
  __cil_tmp206 = 216;
  __cil_tmp207 = (unsigned long )info;
  __cil_tmp208 = __cil_tmp207 + __cil_tmp206;
  *((__u32 *)__cil_tmp208) = (__u32 )0;
  __cil_tmp209 = 36;
  __cil_tmp210 = 160UL + __cil_tmp209;
  __cil_tmp211 = (unsigned long )info;
  __cil_tmp212 = __cil_tmp211 + __cil_tmp210;
  *((__u32 *)__cil_tmp212) = (__u32 )8;
  __cil_tmp213 = 48;
  __cil_tmp214 = 160UL + __cil_tmp213;
  __cil_tmp215 = (unsigned long )info;
  __cil_tmp216 = __cil_tmp215 + __cil_tmp214;
  *((__u32 *)__cil_tmp216) = (__u32 )8;
  __cil_tmp217 = 60;
  __cil_tmp218 = 160UL + __cil_tmp217;
  __cil_tmp219 = (unsigned long )info;
  __cil_tmp220 = __cil_tmp219 + __cil_tmp218;
  *((__u32 *)__cil_tmp220) = (__u32 )8;
  __cil_tmp221 = 228;
  __cil_tmp222 = (unsigned long )info;
  __cil_tmp223 = __cil_tmp222 + __cil_tmp221;
  *((__u32 *)__cil_tmp223) = (__u32 )0;
  __cil_tmp224 = 72;
  __cil_tmp225 = 160UL + __cil_tmp224;
  __cil_tmp226 = (unsigned long )info;
  __cil_tmp227 = __cil_tmp226 + __cil_tmp225;
  *((__u32 *)__cil_tmp227) = (__u32 )0;
  __cil_tmp228 = 168;
  __cil_tmp229 = (unsigned long )info;
  __cil_tmp230 = __cil_tmp229 + __cil_tmp228;
  *((__u32 *)__cil_tmp230) = fb_width;
  __cil_tmp231 = 172;
  __cil_tmp232 = (unsigned long )info;
  __cil_tmp233 = __cil_tmp232 + __cil_tmp231;
  *((__u32 *)__cil_tmp233) = fb_height;
  __cil_tmp234 = 184;
  __cil_tmp235 = (unsigned long )info;
  __cil_tmp236 = __cil_tmp235 + __cil_tmp234;
  __cil_tmp237 = (unsigned long )par;
  __cil_tmp238 = __cil_tmp237 + 128UL;
  *((__u32 *)__cil_tmp236) = *((unsigned int *)__cil_tmp238);
  __cil_tmp239 = 176;
  __cil_tmp240 = (unsigned long )info;
  __cil_tmp241 = __cil_tmp240 + __cil_tmp239;
  *((__u32 *)__cil_tmp241) = (__u32 )0;
  __cil_tmp242 = 180;
  __cil_tmp243 = (unsigned long )info;
  __cil_tmp244 = __cil_tmp243 + __cil_tmp242;
  *((__u32 *)__cil_tmp244) = (__u32 )0;
  __cil_tmp245 = 244;
  __cil_tmp246 = (unsigned long )info;
  __cil_tmp247 = __cil_tmp246 + __cil_tmp245;
  *((__u32 *)__cil_tmp247) = (__u32 )0;
  __cil_tmp248 = 248;
  __cil_tmp249 = (unsigned long )info;
  __cil_tmp250 = __cil_tmp249 + __cil_tmp248;
  *((__u32 *)__cil_tmp250) = (__u32 )-1;
  __cil_tmp251 = 252;
  __cil_tmp252 = (unsigned long )info;
  __cil_tmp253 = __cil_tmp252 + __cil_tmp251;
  *((__u32 *)__cil_tmp253) = (__u32 )-1;
  __cil_tmp254 = (unsigned long )info;
  __cil_tmp255 = __cil_tmp254 + 160UL;
  *((__u32 *)__cil_tmp255) = initial_width;
  __cil_tmp256 = 164;
  __cil_tmp257 = (unsigned long )info;
  __cil_tmp258 = __cil_tmp257 + __cil_tmp256;
  *((__u32 *)__cil_tmp258) = initial_height;
  __cil_tmp259 = (unsigned long )info;
  __cil_tmp260 = __cil_tmp259 + 1168UL;
  *((struct apertures_struct **)__cil_tmp260) = alloc_apertures(1U);
  __cil_tmp261 = (unsigned long )info;
  __cil_tmp262 = __cil_tmp261 + 1168UL;
  __cil_tmp263 = *((struct apertures_struct **)__cil_tmp262);
  if (! __cil_tmp263) {
    ret = -12;
    goto err_aper;
  }
  __cil_tmp264 = 0UL;
  __cil_tmp265 = 8UL + __cil_tmp264;
  __cil_tmp266 = (unsigned long )info;
  __cil_tmp267 = __cil_tmp266 + 1168UL;
  __cil_tmp268 = *((struct apertures_struct **)__cil_tmp267);
  __cil_tmp269 = (unsigned long )__cil_tmp268;
  __cil_tmp270 = __cil_tmp269 + __cil_tmp265;
  __cil_tmp271 = (unsigned long )vmw_priv___0;
  __cil_tmp272 = __cil_tmp271 + 2108UL;
  __cil_tmp273 = *((uint32_t *)__cil_tmp272);
  *((resource_size_t *)__cil_tmp270) = (resource_size_t )__cil_tmp273;
  __cil_tmp274 = 0UL;
  __cil_tmp275 = __cil_tmp274 + 8UL;
  __cil_tmp276 = 8UL + __cil_tmp275;
  __cil_tmp277 = (unsigned long )info;
  __cil_tmp278 = __cil_tmp277 + 1168UL;
  __cil_tmp279 = *((struct apertures_struct **)__cil_tmp278);
  __cil_tmp280 = (unsigned long )__cil_tmp279;
  __cil_tmp281 = __cil_tmp280 + __cil_tmp276;
  __cil_tmp282 = (unsigned long )vmw_priv___0;
  __cil_tmp283 = __cil_tmp282 + 2112UL;
  __cil_tmp284 = *((uint32_t *)__cil_tmp283);
  *((resource_size_t *)__cil_tmp281) = (resource_size_t )__cil_tmp284;
  tmp___14 = 0U;
  __cil_tmp285 = 196;
  __cil_tmp286 = (unsigned long )par;
  __cil_tmp287 = __cil_tmp286 + __cil_tmp285;
  *((unsigned int *)__cil_tmp287) = tmp___14;
  __cil_tmp288 = 188;
  __cil_tmp289 = (unsigned long )par;
  __cil_tmp290 = __cil_tmp289 + __cil_tmp288;
  *((unsigned int *)__cil_tmp290) = tmp___14;
  tmp___15 = 0U;
  __cil_tmp291 = 200;
  __cil_tmp292 = (unsigned long )par;
  __cil_tmp293 = __cil_tmp292 + __cil_tmp291;
  *((unsigned int *)__cil_tmp293) = tmp___15;
  __cil_tmp294 = 192;
  __cil_tmp295 = (unsigned long )par;
  __cil_tmp296 = __cil_tmp295 + __cil_tmp294;
  *((unsigned int *)__cil_tmp296) = tmp___15;
  __cil_tmp297 = 184;
  __cil_tmp298 = (unsigned long )par;
  __cil_tmp299 = __cil_tmp298 + __cil_tmp297;
  *((bool *)__cil_tmp299) = (bool )1;
  while (1) {
    __cil_tmp300 = (unsigned long )par;
    __cil_tmp301 = __cil_tmp300 + 160UL;
    __cil_tmp302 = (spinlock_t *)__cil_tmp301;
    spinlock_check(__cil_tmp302);
    while (1) {
      __cil_tmp303 = (unsigned long )par;
      __cil_tmp304 = __cil_tmp303 + 160UL;
      __cil_tmp305 = (struct raw_spinlock *)__cil_tmp304;
      __raw_spin_lock_init(__cil_tmp305, "&(&par->dirty.lock)->rlock", & __key___12);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp306 = (unsigned long )info;
  __cil_tmp307 = __cil_tmp306 + 1072UL;
  *((struct fb_deferred_io **)__cil_tmp307) = & vmw_defio;
  fb_deferred_io_init(info);
  ret = register_framebuffer(info);
  __cil_tmp308 = ret != 0;
  __cil_tmp309 = ! __cil_tmp308;
  __cil_tmp310 = ! __cil_tmp309;
  __cil_tmp311 = (long )__cil_tmp310;
  tmp___16 = ldv__builtin_expect(__cil_tmp311, 0L);
  if (tmp___16) {
    goto err_defio;
  }
  return (0);
  err_defio: 
  fb_deferred_io_cleanup(info);
  err_aper: 
  __cil_tmp312 = (unsigned long )par;
  __cil_tmp313 = __cil_tmp312 + 24UL;
  __cil_tmp314 = (struct ttm_bo_kmap_obj *)__cil_tmp313;
  ttm_bo_kunmap(__cil_tmp314);
  err_unref: 
  __cil_tmp315 = (unsigned long )par;
  __cil_tmp316 = __cil_tmp315 + 16UL;
  __cil_tmp317 = (struct vmw_dma_buffer **)__cil_tmp316;
  __cil_tmp318 = (struct ttm_buffer_object **)__cil_tmp317;
  ttm_bo_unref(__cil_tmp318);
  err_free: 
  __cil_tmp319 = (unsigned long )par;
  __cil_tmp320 = __cil_tmp319 + 8UL;
  __cil_tmp321 = *((void **)__cil_tmp320);
  __cil_tmp322 = __cil_tmp321;
  vfree(__cil_tmp322);
  framebuffer_release(info);
  __cil_tmp323 = (unsigned long )vmw_priv___0;
  __cil_tmp324 = __cil_tmp323 + 2600UL;
  *((void **)__cil_tmp324) = (void *)0;
  return (ret);
}
}
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  struct ttm_buffer_object *bo ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  struct ttm_buffer_object **__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_dma_buffer *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_bo_kmap_obj *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
  __cil_tmp5 = (unsigned long )vmw_priv___0;
  __cil_tmp6 = __cil_tmp5 + 2600UL;
  __cil_tmp7 = *((void **)__cil_tmp6);
  if (! __cil_tmp7) {
    return (0);
  }
  __cil_tmp8 = (unsigned long )vmw_priv___0;
  __cil_tmp9 = __cil_tmp8 + 2600UL;
  __cil_tmp10 = *((void **)__cil_tmp9);
  info = (struct fb_info *)__cil_tmp10;
  __cil_tmp11 = (unsigned long )info;
  __cil_tmp12 = __cil_tmp11 + 1160UL;
  __cil_tmp13 = *((void **)__cil_tmp12);
  par = (struct vmw_fb_par *)__cil_tmp13;
  __cil_tmp14 = & bo;
  __cil_tmp15 = (unsigned long )par;
  __cil_tmp16 = __cil_tmp15 + 16UL;
  __cil_tmp17 = *((struct vmw_dma_buffer **)__cil_tmp16);
  *__cil_tmp14 = (struct ttm_buffer_object *)__cil_tmp17;
  __cil_tmp18 = (unsigned long )par;
  __cil_tmp19 = __cil_tmp18 + 16UL;
  __cil_tmp20 = (void *)0;
  *((struct vmw_dma_buffer **)__cil_tmp19) = (struct vmw_dma_buffer *)__cil_tmp20;
  fb_deferred_io_cleanup(info);
  unregister_framebuffer(info);
  __cil_tmp21 = (unsigned long )par;
  __cil_tmp22 = __cil_tmp21 + 24UL;
  __cil_tmp23 = (struct ttm_bo_kmap_obj *)__cil_tmp22;
  ttm_bo_kunmap(__cil_tmp23);
  ttm_bo_unref(& bo);
  __cil_tmp24 = (unsigned long )par;
  __cil_tmp25 = __cil_tmp24 + 8UL;
  __cil_tmp26 = *((void **)__cil_tmp25);
  __cil_tmp27 = __cil_tmp26;
  vfree(__cil_tmp27);
  framebuffer_release(info);
  return (0);
}
}
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct delayed_work *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct ttm_bo_kmap_obj *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct vmw_dma_buffer *__cil_tmp36 ;
  bool __cil_tmp37 ;

  {
  __cil_tmp8 = (unsigned long )vmw_priv___0;
  __cil_tmp9 = __cil_tmp8 + 2600UL;
  __cil_tmp10 = *((void **)__cil_tmp9);
  if (! __cil_tmp10) {
    return (-22);
  }
  __cil_tmp11 = (unsigned long )vmw_priv___0;
  __cil_tmp12 = __cil_tmp11 + 2600UL;
  __cil_tmp13 = *((void **)__cil_tmp12);
  info = (struct fb_info *)__cil_tmp13;
  __cil_tmp14 = (unsigned long )info;
  __cil_tmp15 = __cil_tmp14 + 1160UL;
  __cil_tmp16 = *((void **)__cil_tmp15);
  par = (struct vmw_fb_par *)__cil_tmp16;
  while (1) {

    while (1) {
      __cil_tmp17 = (unsigned long )par;
      __cil_tmp18 = __cil_tmp17 + 160UL;
      __cil_tmp19 = (spinlock_t *)__cil_tmp18;
      tmp___7 = spinlock_check(__cil_tmp19);
      flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp20 = 184;
  __cil_tmp21 = (unsigned long )par;
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
  *((bool *)__cil_tmp22) = (bool )0;
  __cil_tmp23 = (unsigned long )par;
  __cil_tmp24 = __cil_tmp23 + 160UL;
  __cil_tmp25 = (spinlock_t *)__cil_tmp24;
  spin_unlock_irqrestore(__cil_tmp25, flags);
  __cil_tmp26 = (unsigned long )info;
  __cil_tmp27 = __cil_tmp26 + 960UL;
  __cil_tmp28 = (struct delayed_work *)__cil_tmp27;
  flush_delayed_work_sync(__cil_tmp28);
  __cil_tmp29 = (unsigned long )par;
  __cil_tmp30 = __cil_tmp29 + 144UL;
  *((void **)__cil_tmp30) = (void *)0;
  __cil_tmp31 = (unsigned long )par;
  __cil_tmp32 = __cil_tmp31 + 24UL;
  __cil_tmp33 = (struct ttm_bo_kmap_obj *)__cil_tmp32;
  ttm_bo_kunmap(__cil_tmp33);
  __cil_tmp34 = (unsigned long )par;
  __cil_tmp35 = __cil_tmp34 + 16UL;
  __cil_tmp36 = *((struct vmw_dma_buffer **)__cil_tmp35);
  __cil_tmp37 = (bool )0;
  vmw_dmabuf_unpin(vmw_priv___0, __cil_tmp36, __cil_tmp37);
  return (0);
}
}
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  bool dummy ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  raw_spinlock_t *tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_dma_buffer *__cil_tmp29 ;
  bool __cil_tmp30 ;
  bool __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_dma_buffer *__cil_tmp38 ;
  struct ttm_buffer_object *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_dma_buffer *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct ttm_bo_kmap_obj *__cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct ttm_bo_kmap_obj *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  spinlock_t *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  spinlock_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  __u32 __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  __u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct delayed_work *__cil_tmp77 ;

  {
  __cil_tmp12 = (unsigned long )vmw_priv___0;
  __cil_tmp13 = __cil_tmp12 + 2600UL;
  __cil_tmp14 = *((void **)__cil_tmp13);
  if (! __cil_tmp14) {
    return (-22);
  }
  __cil_tmp15 = (unsigned long )vmw_priv___0;
  __cil_tmp16 = __cil_tmp15 + 2600UL;
  __cil_tmp17 = *((void **)__cil_tmp16);
  info = (struct fb_info *)__cil_tmp17;
  __cil_tmp18 = (unsigned long )info;
  __cil_tmp19 = __cil_tmp18 + 1160UL;
  __cil_tmp20 = *((void **)__cil_tmp19);
  par = (struct vmw_fb_par *)__cil_tmp20;
  __cil_tmp21 = (void *)0;
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = (unsigned long )par;
  __cil_tmp24 = __cil_tmp23 + 144UL;
  __cil_tmp25 = *((void **)__cil_tmp24);
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  if (__cil_tmp26 != __cil_tmp22) {
    return (0);
  }
  vmw_overlay_stop_all(vmw_priv___0);
  __cil_tmp27 = (unsigned long )par;
  __cil_tmp28 = __cil_tmp27 + 16UL;
  __cil_tmp29 = *((struct vmw_dma_buffer **)__cil_tmp28);
  __cil_tmp30 = (bool )1;
  __cil_tmp31 = (bool )0;
  ret = vmw_dmabuf_to_start_of_vram(vmw_priv___0, __cil_tmp29, __cil_tmp30, __cil_tmp31);
  __cil_tmp32 = ret != 0;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = (long )__cil_tmp34;
  tmp___7 = ldv__builtin_expect(__cil_tmp35, 0L);
  if (tmp___7) {
    drm_err("vmw_fb_on", "could not move buffer to start of VRAM\n");
    goto err_no_buffer;
  }
  __cil_tmp36 = (unsigned long )par;
  __cil_tmp37 = __cil_tmp36 + 16UL;
  __cil_tmp38 = *((struct vmw_dma_buffer **)__cil_tmp37);
  __cil_tmp39 = (struct ttm_buffer_object *)__cil_tmp38;
  __cil_tmp40 = 40;
  __cil_tmp41 = (unsigned long )par;
  __cil_tmp42 = __cil_tmp41 + 16UL;
  __cil_tmp43 = *((struct vmw_dma_buffer **)__cil_tmp42);
  __cil_tmp44 = (unsigned long )__cil_tmp43;
  __cil_tmp45 = __cil_tmp44 + __cil_tmp40;
  __cil_tmp46 = *((unsigned long *)__cil_tmp45);
  __cil_tmp47 = (unsigned long )par;
  __cil_tmp48 = __cil_tmp47 + 24UL;
  __cil_tmp49 = (struct ttm_bo_kmap_obj *)__cil_tmp48;
  ret = ttm_bo_kmap(__cil_tmp39, 0UL, __cil_tmp46, __cil_tmp49);
  while (1) {
    __cil_tmp50 = ret != 0;
    __cil_tmp51 = ! __cil_tmp50;
    __cil_tmp52 = ! __cil_tmp51;
    __cil_tmp53 = (long )__cil_tmp52;
    tmp___8 = ldv__builtin_expect(__cil_tmp53, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c"),
                             "i" (639), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp54 = (unsigned long )par;
  __cil_tmp55 = __cil_tmp54 + 144UL;
  __cil_tmp56 = (unsigned long )par;
  __cil_tmp57 = __cil_tmp56 + 24UL;
  __cil_tmp58 = (struct ttm_bo_kmap_obj *)__cil_tmp57;
  *((void **)__cil_tmp55) = ttm_kmap_obj_virtual(__cil_tmp58, & dummy);
  while (1) {

    while (1) {
      __cil_tmp59 = (unsigned long )par;
      __cil_tmp60 = __cil_tmp59 + 160UL;
      __cil_tmp61 = (spinlock_t *)__cil_tmp60;
      tmp___9 = spinlock_check(__cil_tmp61);
      flags = _raw_spin_lock_irqsave(tmp___9);
      goto while_break___3;
    }
    while_break___3: ;
    goto while_break___2;
  }
  while_break___2: 
  __cil_tmp62 = 184;
  __cil_tmp63 = (unsigned long )par;
  __cil_tmp64 = __cil_tmp63 + __cil_tmp62;
  *((bool *)__cil_tmp64) = (bool )1;
  __cil_tmp65 = (unsigned long )par;
  __cil_tmp66 = __cil_tmp65 + 160UL;
  __cil_tmp67 = (spinlock_t *)__cil_tmp66;
  spin_unlock_irqrestore(__cil_tmp67, flags);
  err_no_buffer: 
  vmw_fb_set_par(info);
  __cil_tmp68 = (unsigned long )info;
  __cil_tmp69 = __cil_tmp68 + 160UL;
  __cil_tmp70 = *((__u32 *)__cil_tmp69);
  __cil_tmp71 = 164;
  __cil_tmp72 = (unsigned long )info;
  __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
  __cil_tmp74 = *((__u32 *)__cil_tmp73);
  vmw_fb_dirty_mark(par, 0U, 0U, __cil_tmp70, __cil_tmp74);
  __cil_tmp75 = (unsigned long )info;
  __cil_tmp76 = __cil_tmp75 + 960UL;
  __cil_tmp77 = (struct delayed_work *)__cil_tmp76;
  schedule_delayed_work(__cil_tmp77, 0UL);
  return (0);
}
}
void ldv_main4_sequence_infinite_withcheck_stateful(void) 
{ struct fb_info *var_group1 ;
  struct list_head *var_group2 ;
  struct fb_var_screeninfo *var_group3 ;
  unsigned int var_vmw_fb_setcolreg_0_p0 ;
  unsigned int var_vmw_fb_setcolreg_0_p1 ;
  unsigned int var_vmw_fb_setcolreg_0_p2 ;
  unsigned int var_vmw_fb_setcolreg_0_p3 ;
  unsigned int var_vmw_fb_setcolreg_0_p4 ;
  struct fb_info *var_vmw_fb_setcolreg_0_p5 ;
  struct fb_fillrect *var_vmw_fb_fillrect_8_p1 ;
  struct fb_copyarea *var_vmw_fb_copyarea_9_p1 ;
  struct fb_image *var_vmw_fb_imageblit_10_p1 ;
  int var_vmw_fb_blank_4_p0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___8 = __VERIFIER_nondet_int();
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = __VERIFIER_nondet_int();
    if (tmp___7 == 0) {
      goto case_0;
    } else
    if (tmp___7 == 1) {
      goto case_1;
    } else
    if (tmp___7 == 2) {
      goto case_2;
    } else
    if (tmp___7 == 3) {
      goto case_3;
    } else
    if (tmp___7 == 4) {
      goto case_4;
    } else
    if (tmp___7 == 5) {
      goto case_5;
    } else
    if (tmp___7 == 6) {
      goto case_6;
    } else
    if (tmp___7 == 7) {
      goto case_7;
    } else
    if (tmp___7 == 8) {
      goto case_8;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_deferred_io(var_group1, var_group2);
        goto switch_break;
        case_1: 
        vmw_fb_check_var(var_group3, var_group1);
        goto switch_break;
        case_2: 
        vmw_fb_set_par(var_group1);
        goto switch_break;
        case_3: 
        vmw_fb_setcolreg(var_vmw_fb_setcolreg_0_p0, var_vmw_fb_setcolreg_0_p1, var_vmw_fb_setcolreg_0_p2,
                         var_vmw_fb_setcolreg_0_p3, var_vmw_fb_setcolreg_0_p4, var_vmw_fb_setcolreg_0_p5);
        goto switch_break;
        case_4: 
        vmw_fb_fillrect(var_group1, var_vmw_fb_fillrect_8_p1);
        goto switch_break;
        case_5: 
        vmw_fb_copyarea(var_group1, var_vmw_fb_copyarea_9_p1);
        goto switch_break;
        case_6: 
        vmw_fb_imageblit(var_group1, var_vmw_fb_imageblit_10_p1);
        goto switch_break;
        case_7: 
        vmw_fb_pan_display(var_group3, var_group1);
        goto switch_break;
        case_8: 
        vmw_fb_blank(var_vmw_fb_blank_4_p0, var_group1);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: 
  ldv_check_final_state();
  return;
}
}
 static void memcpy_fromio(void *dst , void volatile   *src , size_t count )  __attribute__((__no_instrument_function__)) ;
 static void memcpy_fromio(void *dst , void volatile   *src , size_t count )  __attribute__((__no_instrument_function__)) ;
 static void memcpy_fromio(void *dst , void volatile   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void *__cil_tmp6 ;

  {
  __len = count;
  __cil_tmp6 = (void *)src;
  __ret = __builtin_memcpy(dst, __cil_tmp6, __len);
  return;
}
}
extern ssize_t drm_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
extern unsigned int drm_poll(struct file *filp , struct poll_table_struct *wait ) ;
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) ;
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) ;
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) ;
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_getparam_arg *param ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___11 ;
  __le32 *fifo_mem ;
  struct vmw_fifo_state *fifo ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_fifo_state *__cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t __cil_tmp42 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  param = (struct drm_vmw_getparam_arg *)data;
  __cil_tmp15 = (unsigned long )param;
  __cil_tmp16 = __cil_tmp15 + 8UL;
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
  if ((int )__cil_tmp17 == 0) {
    goto case_0;
  } else
  if ((int )__cil_tmp17 == 1) {
    goto case_1;
  } else
  if ((int )__cil_tmp17 == 2) {
    goto case_2;
  } else
  if ((int )__cil_tmp17 == 3) {
    goto case_3;
  } else
  if ((int )__cil_tmp17 == 4) {
    goto case_4;
  } else
  if ((int )__cil_tmp17 == 5) {
    goto case_5;
  } else
  if ((int )__cil_tmp17 == 6) {
    goto case_6;
  } else {
    goto switch_default;
    if (0) {
      case_0: 
      tmp___8 = vmw_overlay_num_overlays(dev_priv);
      *((uint64_t *)param) = (uint64_t )tmp___8;
      goto switch_break;
      case_1: 
      tmp___9 = vmw_overlay_num_free_overlays(dev_priv);
      *((uint64_t *)param) = (uint64_t )tmp___9;
      goto switch_break;
      case_2: 
      tmp___11 = vmw_fifo_have_3d(dev_priv);
      if (tmp___11) {
        *((uint64_t *)param) = (uint64_t )1;
      } else {
        *((uint64_t *)param) = (uint64_t )0;
      }
      goto switch_break;
      case_3: 
      __cil_tmp18 = (unsigned long )dev_priv;
      __cil_tmp19 = __cil_tmp18 + 2156UL;
      __cil_tmp20 = *((uint32_t *)__cil_tmp19);
      *((uint64_t *)param) = (uint64_t )__cil_tmp20;
      goto switch_break;
      case_4: 
      __cil_tmp21 = 1892;
      __cil_tmp22 = (unsigned long )dev_priv;
      __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
      __cil_tmp24 = *((uint32_t *)__cil_tmp23);
      *((uint64_t *)param) = (uint64_t )__cil_tmp24;
      goto switch_break;
      case_5: 
      __cil_tmp25 = (unsigned long )dev_priv;
      __cil_tmp26 = __cil_tmp25 + 2112UL;
      __cil_tmp27 = *((uint32_t *)__cil_tmp26);
      *((uint64_t *)param) = (uint64_t )__cil_tmp27;
      goto switch_break;
      case_6: 
      __cil_tmp28 = (unsigned long )dev_priv;
      __cil_tmp29 = __cil_tmp28 + 2144UL;
      fifo_mem = *((__le32 **)__cil_tmp29);
      __cil_tmp30 = (unsigned long )dev_priv;
      __cil_tmp31 = __cil_tmp30 + 1856UL;
      __cil_tmp32 = (struct vmw_fifo_state *)__cil_tmp31;
      fifo = __cil_tmp32;
      __cil_tmp33 = 1 << 8;
      __cil_tmp34 = (unsigned int )__cil_tmp33;
      __cil_tmp35 = (unsigned long )fifo;
      __cil_tmp36 = __cil_tmp35 + 36UL;
      __cil_tmp37 = *((uint32_t *)__cil_tmp36);
      if (__cil_tmp37 & __cil_tmp34) {
        tmp___12 = 17;
      } else {
        tmp___12 = 7;
      }
      __cil_tmp38 = fifo_mem + tmp___12;
      __cil_tmp39 = (void *)__cil_tmp38;
      tmp___13 = ioread32(__cil_tmp39);
      *((uint64_t *)param) = (uint64_t )tmp___13;
      goto switch_break;
      switch_default: 
      __cil_tmp40 = (unsigned long )param;
      __cil_tmp41 = __cil_tmp40 + 8UL;
      __cil_tmp42 = *((uint32_t *)__cil_tmp41);
      drm_err("vmw_getparam_ioctl", "Illegal vmwgfx get param request: %d\n", __cil_tmp42);
      return (-22);
    } else {
      switch_break: ;
    }
  }
  return (0);
}
}
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_get_3d_cap_arg *arg ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t size ;
  __le32 *fifo_mem ;
  void *buffer ;
  void *bounce ;
  int ret ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint64_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void volatile   *__cil_tmp41 ;
  size_t __cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  int tmp ;

  {
  arg = (struct drm_vmw_get_3d_cap_arg *)data;
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp15 = *((uint64_t *)arg);
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  buffer = (void *)__cil_tmp16;
  __cil_tmp17 = (unsigned long )arg;
  __cil_tmp18 = __cil_tmp17 + 12UL;
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
  __cil_tmp20 = __cil_tmp19 != 0U;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = (long )__cil_tmp22;
  tmp___8 = ldv__builtin_expect(__cil_tmp23, 0L);
  if (tmp___8) {
    drm_err("vmw_get_cap_3d_ioctl", "Illegal GET_3D_CAP argument.\n");
    return (-22);
  }
  __cil_tmp24 = 256 << 2;
  size = (uint32_t )__cil_tmp24;
  __cil_tmp25 = (unsigned long )arg;
  __cil_tmp26 = __cil_tmp25 + 8UL;
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
  if (__cil_tmp27 < size) {
    __cil_tmp28 = (unsigned long )arg;
    __cil_tmp29 = __cil_tmp28 + 8UL;
    size = *((uint32_t *)__cil_tmp29);
  }
  __cil_tmp30 = (unsigned long )size;
  bounce = vmalloc(__cil_tmp30);
  __cil_tmp31 = (void *)0;
  __cil_tmp32 = (unsigned long )__cil_tmp31;
  __cil_tmp33 = (unsigned long )bounce;
  __cil_tmp34 = __cil_tmp33 == __cil_tmp32;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = (long )__cil_tmp36;
  tmp___9 = ldv__builtin_expect(__cil_tmp37, 0L);
  if (tmp___9) {
    drm_err("vmw_get_cap_3d_ioctl", "Failed to allocate bounce buffer for 3D caps.\n");
    return (-12);
  }
  __cil_tmp38 = (unsigned long )dev_priv;
  __cil_tmp39 = __cil_tmp38 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp39);
  __cil_tmp40 = fifo_mem + 32;
  __cil_tmp41 = (void volatile   *)__cil_tmp40;
  __cil_tmp42 = (size_t )size;
  memcpy_fromio(bounce, __cil_tmp41, __cil_tmp42);
  __cil_tmp43 = bounce;
  tmp = (int )copy_to_user(buffer, __cil_tmp43, size);
  ret = tmp;
  __cil_tmp44 = bounce;
  vfree(__cil_tmp44);
  __cil_tmp45 = ret != 0;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = ! __cil_tmp46;
  __cil_tmp48 = (long )__cil_tmp47;
  tmp___10 = ldv__builtin_expect(__cil_tmp48, 0L);
  if (tmp___10) {
    drm_err("vmw_get_cap_3d_ioctl", "Failed to report 3D caps info.\n");
  }
  return (ret);
}
}
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct drm_vmw_present_arg *arg ;
  struct vmw_surface *surface ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___10 ;
  void *tmp___11 ;
  unsigned long tmp___12 ;
  long tmp___13 ;
  struct drm_framebuffer *__mptr ;
  struct drm_mode_object *__mptr___0 ;
  long tmp___14 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint64_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  size_t __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  struct drm_framebuffer *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_mode_object *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  struct drm_framebuffer *__cil_tmp67 ;
  struct vmw_framebuffer *__cil_tmp68 ;
  struct drm_framebuffer *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  struct ttm_lock *__cil_tmp73 ;
  bool __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  uint32_t __cil_tmp81 ;
  struct vmw_surface **__cil_tmp82 ;
  struct vmw_surface *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  int32_t __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  int32_t __cil_tmp92 ;
  struct ttm_lock *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct mutex *__cil_tmp96 ;
  void *__cil_tmp97 ;
  unsigned long tmp ;
  int tmp___15 ;

  {
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp25 = (unsigned long )tmp___7;
  __cil_tmp26 = __cil_tmp25 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp26);
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  arg = (struct drm_vmw_present_arg *)data;
  __cil_tmp27 = (unsigned long )file_priv;
  __cil_tmp28 = __cil_tmp27 + 152UL;
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
  tmp___9 = vmw_master(__cil_tmp29);
  vmaster = tmp___9;
  __cil_tmp30 = (void *)0;
  clips = (struct drm_vmw_rect *)__cil_tmp30;
  __cil_tmp31 = (unsigned long )arg;
  __cil_tmp32 = __cil_tmp31 + 24UL;
  num_clips = *((uint32_t *)__cil_tmp32);
  __cil_tmp33 = (unsigned long )arg;
  __cil_tmp34 = __cil_tmp33 + 16UL;
  __cil_tmp35 = *((uint64_t *)__cil_tmp34);
  __cil_tmp36 = (unsigned long )__cil_tmp35;
  clips_ptr = (struct drm_vmw_rect *)__cil_tmp36;
  __cil_tmp37 = num_clips == 0U;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___10 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___10) {
    return (0);
  }
  __cil_tmp41 = (void *)0;
  __cil_tmp42 = (unsigned long )__cil_tmp41;
  __cil_tmp43 = (unsigned long )clips_ptr;
  if (__cil_tmp43 == __cil_tmp42) {
    drm_err("vmw_present_ioctl", "Variable clips_ptr must be specified.\n");
    ret = -22;
    goto out_clips;
  }
  __cil_tmp44 = (size_t )num_clips;
  tmp___11 = kcalloc(__cil_tmp44, 16UL, 208U);
  clips = (struct drm_vmw_rect *)tmp___11;
  __cil_tmp45 = (void *)0;
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  __cil_tmp47 = (unsigned long )clips;
  if (__cil_tmp47 == __cil_tmp46) {
    drm_err("vmw_present_ioctl", "Failed to allocate clip rect list.\n");
    ret = -12;
    goto out_clips;
  }
  __cil_tmp48 = (void *)clips;
  __cil_tmp49 = (void *)clips_ptr;
  __cil_tmp50 = (unsigned long )num_clips;
  __cil_tmp51 = __cil_tmp50 * 16UL;
  tmp = (unsigned long )copy_from_user(__cil_tmp48, __cil_tmp49, __cil_tmp51);
  tmp___12 = tmp;
  ret = (int )tmp___12;
  if (ret) {
    drm_err("vmw_present_ioctl", "Failed to copy clip rects from userspace.\n");
    ret = -14;
    goto out_no_mode_mutex;
  }
  __cil_tmp52 = (unsigned long )dev;
  __cil_tmp53 = __cil_tmp52 + 1152UL;
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
  tmp___15 = (int )mutex_lock_interruptible(__cil_tmp54);
  ret = tmp___15;
  __cil_tmp55 = ret != 0;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___13 = ldv__builtin_expect(__cil_tmp58, 0L);
  if (tmp___13) {
    ret = -512;
    goto out_no_mode_mutex;
  }
  __cil_tmp59 = *((uint32_t *)arg);
  obj = drm_mode_object_find(dev, __cil_tmp59, 4227595259U);
  if (! obj) {
    drm_err("vmw_present_ioctl", "Invalid framebuffer id.\n");
    ret = -22;
    goto out_no_ttm_lock;
  }
  __mptr___0 = obj;
  __cil_tmp60 = (struct drm_framebuffer *)0;
  __cil_tmp61 = (unsigned long )__cil_tmp60;
  __cil_tmp62 = __cil_tmp61 + 24UL;
  __cil_tmp63 = (struct drm_mode_object *)__cil_tmp62;
  __cil_tmp64 = (unsigned int )__cil_tmp63;
  __cil_tmp65 = (char *)__mptr___0;
  __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
  __cil_tmp67 = (struct drm_framebuffer *)__cil_tmp66;
  __mptr = __cil_tmp67;
  __cil_tmp68 = (struct vmw_framebuffer *)0;
  __cil_tmp69 = (struct drm_framebuffer *)__cil_tmp68;
  __cil_tmp70 = (unsigned int )__cil_tmp69;
  __cil_tmp71 = (char *)__mptr;
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
  vfb = (struct vmw_framebuffer *)__cil_tmp72;
  __cil_tmp73 = (struct ttm_lock *)vmaster;
  __cil_tmp74 = (bool )1;
  ret = ttm_read_lock(__cil_tmp73, __cil_tmp74);
  __cil_tmp75 = ret != 0;
  __cil_tmp76 = ! __cil_tmp75;
  __cil_tmp77 = ! __cil_tmp76;
  __cil_tmp78 = (long )__cil_tmp77;
  tmp___14 = ldv__builtin_expect(__cil_tmp78, 0L);
  if (tmp___14) {
    goto out_no_ttm_lock;
  }
  __cil_tmp79 = (unsigned long )arg;
  __cil_tmp80 = __cil_tmp79 + 4UL;
  __cil_tmp81 = *((uint32_t *)__cil_tmp80);
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, __cil_tmp81, & surface);
  if (ret) {
    goto out_no_surface;
  }
  __cil_tmp82 = & surface;
  __cil_tmp83 = *__cil_tmp82;
  __cil_tmp84 = (unsigned long )arg;
  __cil_tmp85 = __cil_tmp84 + 4UL;
  __cil_tmp86 = *((uint32_t *)__cil_tmp85);
  __cil_tmp87 = (unsigned long )arg;
  __cil_tmp88 = __cil_tmp87 + 8UL;
  __cil_tmp89 = *((int32_t *)__cil_tmp88);
  __cil_tmp90 = (unsigned long )arg;
  __cil_tmp91 = __cil_tmp90 + 12UL;
  __cil_tmp92 = *((int32_t *)__cil_tmp91);
  ret = vmw_kms_present(dev_priv, file_priv, vfb, __cil_tmp83, __cil_tmp86, __cil_tmp89,
                        __cil_tmp92, clips, num_clips);
  vmw_surface_unreference(& surface);
  out_no_surface: 
  __cil_tmp93 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp93);
  out_no_ttm_lock: 
  __cil_tmp94 = (unsigned long )dev;
  __cil_tmp95 = __cil_tmp94 + 1152UL;
  __cil_tmp96 = (struct mutex *)__cil_tmp95;
  mutex_unlock(__cil_tmp96);
  out_no_mode_mutex: 
  __cil_tmp97 = (void *)clips;
  kfree(__cil_tmp97);
  out_clips: 
  return (ret);
}
}
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_present_readback_arg *arg ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___8 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___9 ;
  void *tmp___10 ;
  unsigned long tmp___11 ;
  long tmp___12 ;
  struct drm_framebuffer *__mptr ;
  struct drm_mode_object *__mptr___0 ;
  long tmp___13 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint64_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint64_t __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  size_t __cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  uint32_t __cil_tmp59 ;
  struct drm_framebuffer *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct drm_mode_object *__cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  struct drm_framebuffer *__cil_tmp67 ;
  struct vmw_framebuffer *__cil_tmp68 ;
  struct drm_framebuffer *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  bool __cil_tmp75 ;
  struct ttm_lock *__cil_tmp76 ;
  bool __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  long __cil_tmp81 ;
  struct ttm_lock *__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct mutex *__cil_tmp85 ;
  void *__cil_tmp86 ;
  unsigned long tmp ;
  int tmp___14 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_present_readback_arg *)data;
  __cil_tmp23 = (unsigned long )arg;
  __cil_tmp24 = __cil_tmp23 + 16UL;
  __cil_tmp25 = *((uint64_t *)__cil_tmp24);
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  user_fence_rep = (struct drm_vmw_fence_rep *)__cil_tmp26;
  __cil_tmp27 = (unsigned long )file_priv;
  __cil_tmp28 = __cil_tmp27 + 152UL;
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
  tmp___8 = vmw_master(__cil_tmp29);
  vmaster = tmp___8;
  __cil_tmp30 = (void *)0;
  clips = (struct drm_vmw_rect *)__cil_tmp30;
  __cil_tmp31 = (unsigned long )arg;
  __cil_tmp32 = __cil_tmp31 + 4UL;
  num_clips = *((uint32_t *)__cil_tmp32);
  __cil_tmp33 = (unsigned long )arg;
  __cil_tmp34 = __cil_tmp33 + 8UL;
  __cil_tmp35 = *((uint64_t *)__cil_tmp34);
  __cil_tmp36 = (unsigned long )__cil_tmp35;
  clips_ptr = (struct drm_vmw_rect *)__cil_tmp36;
  __cil_tmp37 = num_clips == 0U;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___9 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___9) {
    return (0);
  }
  __cil_tmp41 = (void *)0;
  __cil_tmp42 = (unsigned long )__cil_tmp41;
  __cil_tmp43 = (unsigned long )clips_ptr;
  if (__cil_tmp43 == __cil_tmp42) {
    drm_err("vmw_present_readback_ioctl", "Argument clips_ptr must be specified.\n");
    ret = -22;
    goto out_clips;
  }
  __cil_tmp44 = (size_t )num_clips;
  tmp___10 = kcalloc(__cil_tmp44, 16UL, 208U);
  clips = (struct drm_vmw_rect *)tmp___10;
  __cil_tmp45 = (void *)0;
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  __cil_tmp47 = (unsigned long )clips;
  if (__cil_tmp47 == __cil_tmp46) {
    drm_err("vmw_present_readback_ioctl", "Failed to allocate clip rect list.\n");
    ret = -12;
    goto out_clips;
  }
  __cil_tmp48 = (void *)clips;
  __cil_tmp49 = (void *)clips_ptr;
  __cil_tmp50 = (unsigned long )num_clips;
  __cil_tmp51 = __cil_tmp50 * 16UL;
  tmp = (unsigned long )copy_from_user(__cil_tmp48, __cil_tmp49, __cil_tmp51);
  tmp___11 = tmp;
  ret = (int )tmp___11;
  if (ret) {
    drm_err("vmw_present_readback_ioctl", "Failed to copy clip rects from userspace.\n");
    ret = -14;
    goto out_no_mode_mutex;
  }
  __cil_tmp52 = (unsigned long )dev;
  __cil_tmp53 = __cil_tmp52 + 1152UL;
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
  tmp___14 = (int )mutex_lock_interruptible(__cil_tmp54);
  ret = tmp___14;
  __cil_tmp55 = ret != 0;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___12 = ldv__builtin_expect(__cil_tmp58, 0L);
  if (tmp___12) {
    ret = -512;
    goto out_no_mode_mutex;
  }
  __cil_tmp59 = *((uint32_t *)arg);
  obj = drm_mode_object_find(dev, __cil_tmp59, 4227595259U);
  if (! obj) {
    drm_err("vmw_present_readback_ioctl", "Invalid framebuffer id.\n");
    ret = -22;
    goto out_no_ttm_lock;
  }
  __mptr___0 = obj;
  __cil_tmp60 = (struct drm_framebuffer *)0;
  __cil_tmp61 = (unsigned long )__cil_tmp60;
  __cil_tmp62 = __cil_tmp61 + 24UL;
  __cil_tmp63 = (struct drm_mode_object *)__cil_tmp62;
  __cil_tmp64 = (unsigned int )__cil_tmp63;
  __cil_tmp65 = (char *)__mptr___0;
  __cil_tmp66 = __cil_tmp65 - __cil_tmp64;
  __cil_tmp67 = (struct drm_framebuffer *)__cil_tmp66;
  __mptr = __cil_tmp67;
  __cil_tmp68 = (struct vmw_framebuffer *)0;
  __cil_tmp69 = (struct drm_framebuffer *)__cil_tmp68;
  __cil_tmp70 = (unsigned int )__cil_tmp69;
  __cil_tmp71 = (char *)__mptr;
  __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
  vfb = (struct vmw_framebuffer *)__cil_tmp72;
  __cil_tmp73 = (unsigned long )vfb;
  __cil_tmp74 = __cil_tmp73 + 136UL;
  __cil_tmp75 = *((bool *)__cil_tmp74);
  if (! __cil_tmp75) {
    drm_err("vmw_present_readback_ioctl", "Framebuffer not dmabuf backed.\n");
    ret = -22;
    goto out_no_ttm_lock;
  }
  __cil_tmp76 = (struct ttm_lock *)vmaster;
  __cil_tmp77 = (bool )1;
  ret = ttm_read_lock(__cil_tmp76, __cil_tmp77);
  __cil_tmp78 = ret != 0;
  __cil_tmp79 = ! __cil_tmp78;
  __cil_tmp80 = ! __cil_tmp79;
  __cil_tmp81 = (long )__cil_tmp80;
  tmp___13 = ldv__builtin_expect(__cil_tmp81, 0L);
  if (tmp___13) {
    goto out_no_ttm_lock;
  }
  ret = vmw_kms_readback(dev_priv, file_priv, vfb, user_fence_rep, clips, num_clips);
  __cil_tmp82 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp82);
  out_no_ttm_lock: 
  __cil_tmp83 = (unsigned long )dev;
  __cil_tmp84 = __cil_tmp83 + 1152UL;
  __cil_tmp85 = (struct mutex *)__cil_tmp84;
  mutex_unlock(__cil_tmp85);
  out_no_mode_mutex: 
  __cil_tmp86 = (void *)clips;
  kfree(__cil_tmp86);
  out_clips: 
  return (ret);
}
}
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct drm_minor *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct drm_device *__cil_tmp15 ;
  uint32_t __cil_tmp16 ;

  {
  __cil_tmp7 = (unsigned long )filp;
  __cil_tmp8 = __cil_tmp7 + 200UL;
  __cil_tmp9 = *((void **)__cil_tmp8);
  file_priv = (struct drm_file *)__cil_tmp9;
  __cil_tmp10 = (unsigned long )file_priv;
  __cil_tmp11 = __cil_tmp10 + 40UL;
  __cil_tmp12 = *((struct drm_minor **)__cil_tmp11);
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = __cil_tmp13 + 784UL;
  __cil_tmp15 = *((struct drm_device **)__cil_tmp14);
  tmp___7 = vmw_priv(__cil_tmp15);
  dev_priv = tmp___7;
  __cil_tmp16 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp16);
  tmp___8 = drm_poll(filp, wait);
  return (tmp___8);
}
}
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  ssize_t tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct drm_minor *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct drm_device *__cil_tmp17 ;
  uint32_t __cil_tmp18 ;

  {
  __cil_tmp9 = (unsigned long )filp;
  __cil_tmp10 = __cil_tmp9 + 200UL;
  __cil_tmp11 = *((void **)__cil_tmp10);
  file_priv = (struct drm_file *)__cil_tmp11;
  __cil_tmp12 = (unsigned long )file_priv;
  __cil_tmp13 = __cil_tmp12 + 40UL;
  __cil_tmp14 = *((struct drm_minor **)__cil_tmp13);
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = __cil_tmp15 + 784UL;
  __cil_tmp17 = *((struct drm_device **)__cil_tmp16);
  tmp___7 = vmw_priv(__cil_tmp17);
  dev_priv = tmp___7;
  __cil_tmp18 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp18);
  tmp___8 = drm_read(filp, buffer, count, offset);
  return (tmp___8);
}
}
 static int atomic_sub_and_test(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_sub_and_test(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (*((int *)v)), "=qm" (c): "ir" (i): "memory");
  return ((int )c);
}
}
extern void _raw_read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
 static void kref_init(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
 static void kref_init(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
 static void kref_init(struct kref *kref ) 
{ atomic_t *__cil_tmp2 ;

  {
  __cil_tmp2 = (atomic_t *)kref;
  atomic_set(__cil_tmp2, 1);
  return;
}
}
 static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
 static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
 static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) ) 
{ int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  atomic_t *__cil_tmp20 ;

  {
  __cil_tmp7 = (void *)0;
  __cil_tmp8 = (unsigned long )__cil_tmp7;
  __cil_tmp9 = (unsigned long )release;
  __cil_tmp10 = __cil_tmp9 == __cil_tmp8;
  __cil_tmp11 = ! __cil_tmp10;
  __ret_warn_on = ! __cil_tmp11;
  __cil_tmp12 = ! __ret_warn_on;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  tmp = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp) {
    __cil_tmp15 = 66;
    warn_slowpath_null("include/linux/kref.h", __cil_tmp15);
  }
  __cil_tmp16 = ! __ret_warn_on;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  ldv__builtin_expect(__cil_tmp18, 0L);
  __cil_tmp19 = (int )count;
  __cil_tmp20 = (atomic_t *)kref;
  tmp___0 = atomic_sub_and_test(__cil_tmp19, __cil_tmp20);
  if (tmp___0) {
    (*release)(kref);
    return (1);
  }
  return (0);
}
}
 static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
 static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
 static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) 
{ int tmp ;

  {
  tmp = kref_sub(kref, 1U, release);
  return (tmp);
}
}
extern void *idr_find(struct idr *idp , int id ) ;
extern int idr_pre_get(struct idr *idp , gfp_t gfp_mask ) ;
extern int idr_get_new_above(struct idr *idp , void *ptr , int starting_id , int *id ) ;
extern void idr_remove(struct idr *idp , int id ) ;
extern size_t ttm_bo_acc_size(struct ttm_bo_device *bdev , unsigned long bo_size ,
                              unsigned int struct_size ) ;
extern int ttm_bo_init(struct ttm_bo_device *bdev , struct ttm_buffer_object *bo ,
                       unsigned long size , enum ttm_bo_type type , struct ttm_placement *placement ,
                       uint32_t page_alignment , unsigned long buffer_start , bool interrubtible ,
                       struct file *persistent_swap_storage , size_t acc_size , void (*destroy)(struct ttm_buffer_object * ) ) ;
extern int ttm_mem_global_alloc(struct ttm_mem_global *glob , uint64_t memory , bool no_wait ,
                                bool interruptible ) ;
extern void ttm_mem_global_free(struct ttm_mem_global *glob , uint64_t amount ) ;
extern size_t ttm_round_pot(size_t size ) ;
extern int ttm_base_object_init(struct ttm_object_file *tfile , struct ttm_base_object *base ,
                                bool shareable , enum ttm_object_type type , void (*refcount_release)(struct ttm_base_object ** ) ,
                                void (*ref_obj_release)(struct ttm_base_object * ,
                                                        enum ttm_ref_type ref_type ) ) ;
extern int ttm_ref_object_add(struct ttm_object_file *tfile , struct ttm_base_object *base ,
                              enum ttm_ref_type ref_type , bool *existed ) ;
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) ;
void vmw_surface_res_free(struct vmw_resource *res ) ;
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource *res ) ) ;
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) ;
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) ;
void vmw_bo_get_guest_ptr(struct ttm_buffer_object *bo , SVGAGuestPtr *ptr ) ;
struct ttm_placement vmw_srf_placement ;
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) ;
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) ;
 static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv )  __attribute__((__no_instrument_function__)) ;
 static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv )  __attribute__((__no_instrument_function__)) ;
 static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  __cil_tmp2 = 1832;
  __cil_tmp3 = (unsigned long )dev_priv;
  __cil_tmp4 = __cil_tmp3 + __cil_tmp2;
  __cil_tmp5 = *((void **)__cil_tmp4);
  return ((struct ttm_mem_global *)__cil_tmp5);
}
}
static uint64_t vmw_user_context_size  ;
static uint64_t vmw_user_surface_size  ;
static uint64_t vmw_user_stream_size  ;
 static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct ttm_buffer_object *__mptr ;
  struct vmw_dma_buffer *__cil_tmp3 ;
  struct ttm_buffer_object *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  __mptr = bo;
  __cil_tmp3 = (struct vmw_dma_buffer *)0;
  __cil_tmp4 = (struct ttm_buffer_object *)__cil_tmp3;
  __cil_tmp5 = (unsigned int )__cil_tmp4;
  __cil_tmp6 = (char *)__mptr;
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
  return ((struct vmw_dma_buffer *)__cil_tmp7);
}
}
 static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo )  __attribute__((__no_instrument_function__)) ;
 static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  struct vmw_dma_buffer *__mptr ;
  struct vmw_user_dma_buffer *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct vmw_dma_buffer *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  tmp___7 = vmw_dma_buffer(bo);
  vmw_bo = tmp___7;
  __mptr = vmw_bo;
  __cil_tmp5 = (struct vmw_user_dma_buffer *)0;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = __cil_tmp6 + 64UL;
  __cil_tmp8 = (struct vmw_dma_buffer *)__cil_tmp7;
  __cil_tmp9 = (unsigned int )__cil_tmp8;
  __cil_tmp10 = (char *)__mptr;
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
  return ((struct vmw_user_dma_buffer *)__cil_tmp11);
}
}
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) 
{ struct kref *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct kref *)res;
  kref_get(__cil_tmp2);
  return (res);
}
}
static void vmw_resource_release_id(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  rwlock_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct idr *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  rwlock_t *__cil_tmp21 ;

  {
  __cil_tmp3 = (unsigned long )res;
  __cil_tmp4 = __cil_tmp3 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp4);
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2632UL;
  __cil_tmp7 = (rwlock_t *)__cil_tmp6;
  _raw_write_lock(__cil_tmp7);
  __cil_tmp8 = (unsigned long )res;
  __cil_tmp9 = __cil_tmp8 + 24UL;
  __cil_tmp10 = *((int *)__cil_tmp9);
  if (__cil_tmp10 != -1) {
    __cil_tmp11 = (unsigned long )res;
    __cil_tmp12 = __cil_tmp11 + 16UL;
    __cil_tmp13 = *((struct idr **)__cil_tmp12);
    __cil_tmp14 = (unsigned long )res;
    __cil_tmp15 = __cil_tmp14 + 24UL;
    __cil_tmp16 = *((int *)__cil_tmp15);
    idr_remove(__cil_tmp13, __cil_tmp16);
  }
  __cil_tmp17 = (unsigned long )res;
  __cil_tmp18 = __cil_tmp17 + 24UL;
  *((int *)__cil_tmp18) = -1;
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 2632UL;
  __cil_tmp21 = (rwlock_t *)__cil_tmp20;
  _raw_write_unlock(__cil_tmp21);
  return;
}
}
static void vmw_resource_release(struct kref *kref ) 
{ struct vmw_resource *res ;
  struct kref *__mptr ;
  struct vmw_private *dev_priv ;
  int id ;
  struct idr *idr ;
  long tmp___7 ;
  struct vmw_resource *__cil_tmp8 ;
  struct kref *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void (*__cil_tmp25)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void (*__cil_tmp29)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  rwlock_t *__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void (*__cil_tmp37)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  void (*__cil_tmp45)(struct vmw_resource *res ) ;
  void *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void (*__cil_tmp50)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void (*__cil_tmp54)(struct vmw_resource *res ) ;
  void *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  rwlock_t *__cil_tmp58 ;

  {
  __mptr = kref;
  __cil_tmp8 = (struct vmw_resource *)0;
  __cil_tmp9 = (struct kref *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  res = (struct vmw_resource *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )res;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp14);
  __cil_tmp15 = (unsigned long )res;
  __cil_tmp16 = __cil_tmp15 + 24UL;
  id = *((int *)__cil_tmp16);
  __cil_tmp17 = (unsigned long )res;
  __cil_tmp18 = __cil_tmp17 + 16UL;
  idr = *((struct idr **)__cil_tmp18);
  __cil_tmp19 = (unsigned long )res;
  __cil_tmp20 = __cil_tmp19 + 32UL;
  *((bool *)__cil_tmp20) = (bool )0;
  __cil_tmp21 = (void *)0;
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = (unsigned long )res;
  __cil_tmp24 = __cil_tmp23 + 40UL;
  __cil_tmp25 = *((void (**)(struct vmw_resource *res ))__cil_tmp24);
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  if (__cil_tmp26 != __cil_tmp22) {
    __cil_tmp27 = (unsigned long )res;
    __cil_tmp28 = __cil_tmp27 + 40UL;
    __cil_tmp29 = *((void (**)(struct vmw_resource *res ))__cil_tmp28);
    (*__cil_tmp29)(res);
  }
  __cil_tmp30 = (unsigned long )dev_priv;
  __cil_tmp31 = __cil_tmp30 + 2632UL;
  __cil_tmp32 = (rwlock_t *)__cil_tmp31;
  _raw_write_unlock(__cil_tmp32);
  __cil_tmp33 = (void *)0;
  __cil_tmp34 = (unsigned long )__cil_tmp33;
  __cil_tmp35 = (unsigned long )res;
  __cil_tmp36 = __cil_tmp35 + 48UL;
  __cil_tmp37 = *((void (**)(struct vmw_resource *res ))__cil_tmp36);
  __cil_tmp38 = (unsigned long )__cil_tmp37;
  __cil_tmp39 = __cil_tmp38 != __cil_tmp34;
  __cil_tmp40 = ! __cil_tmp39;
  __cil_tmp41 = ! __cil_tmp40;
  __cil_tmp42 = (long )__cil_tmp41;
  tmp___7 = ldv__builtin_expect(__cil_tmp42, 1L);
  if (tmp___7) {
    __cil_tmp43 = (unsigned long )res;
    __cil_tmp44 = __cil_tmp43 + 48UL;
    __cil_tmp45 = *((void (**)(struct vmw_resource *res ))__cil_tmp44);
    (*__cil_tmp45)(res);
  }
  __cil_tmp46 = (void *)0;
  __cil_tmp47 = (unsigned long )__cil_tmp46;
  __cil_tmp48 = (unsigned long )res;
  __cil_tmp49 = __cil_tmp48 + 56UL;
  __cil_tmp50 = *((void (**)(struct vmw_resource *res ))__cil_tmp49);
  __cil_tmp51 = (unsigned long )__cil_tmp50;
  if (__cil_tmp51 != __cil_tmp47) {
    __cil_tmp52 = (unsigned long )res;
    __cil_tmp53 = __cil_tmp52 + 56UL;
    __cil_tmp54 = *((void (**)(struct vmw_resource *res ))__cil_tmp53);
    (*__cil_tmp54)(res);
  } else {
    __cil_tmp55 = (void *)res;
    kfree(__cil_tmp55);
  }
  __cil_tmp56 = (unsigned long )dev_priv;
  __cil_tmp57 = __cil_tmp56 + 2632UL;
  __cil_tmp58 = (rwlock_t *)__cil_tmp57;
  _raw_write_lock(__cil_tmp58);
  if (id != -1) {
    idr_remove(idr, id);
  }
  return;
}
}
void vmw_resource_unreference(struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  struct vmw_private *dev_priv ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  rwlock_t *__cil_tmp9 ;
  struct kref *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  rwlock_t *__cil_tmp13 ;

  {
  res = *p_res;
  __cil_tmp4 = (unsigned long )res;
  __cil_tmp5 = __cil_tmp4 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp5);
  __cil_tmp6 = (void *)0;
  *p_res = (struct vmw_resource *)__cil_tmp6;
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2632UL;
  __cil_tmp9 = (rwlock_t *)__cil_tmp8;
  _raw_write_lock(__cil_tmp9);
  __cil_tmp10 = (struct kref *)res;
  kref_put(__cil_tmp10, & vmw_resource_release);
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2632UL;
  __cil_tmp13 = (rwlock_t *)__cil_tmp12;
  _raw_write_unlock(__cil_tmp13);
  return;
}
}
static int vmw_resource_alloc_id(struct vmw_private *dev_priv , struct vmw_resource *res ) 
{ int ret ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct idr *__cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  rwlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct idr *__cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  rwlock_t *__cil_tmp31 ;

  {
  while (1) {
    __cil_tmp8 = (unsigned long )res;
    __cil_tmp9 = __cil_tmp8 + 24UL;
    __cil_tmp10 = *((int *)__cil_tmp9);
    __cil_tmp11 = __cil_tmp10 != -1;
    __cil_tmp12 = ! __cil_tmp11;
    __cil_tmp13 = ! __cil_tmp12;
    __cil_tmp14 = (long )__cil_tmp13;
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (167), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  while (1) {
    __cil_tmp15 = (unsigned long )res;
    __cil_tmp16 = __cil_tmp15 + 16UL;
    __cil_tmp17 = *((struct idr **)__cil_tmp16);
    tmp___8 = idr_pre_get(__cil_tmp17, 208U);
    if (tmp___8 == 0) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    __cil_tmp18 = (long )tmp___9;
    tmp___10 = ldv__builtin_expect(__cil_tmp18, 0L);
    if (tmp___10) {
      return (-12);
    }
    __cil_tmp19 = (unsigned long )dev_priv;
    __cil_tmp20 = __cil_tmp19 + 2632UL;
    __cil_tmp21 = (rwlock_t *)__cil_tmp20;
    _raw_write_lock(__cil_tmp21);
    __cil_tmp22 = (unsigned long )res;
    __cil_tmp23 = __cil_tmp22 + 16UL;
    __cil_tmp24 = *((struct idr **)__cil_tmp23);
    __cil_tmp25 = (void *)res;
    __cil_tmp26 = (unsigned long )res;
    __cil_tmp27 = __cil_tmp26 + 24UL;
    __cil_tmp28 = (int *)__cil_tmp27;
    ret = idr_get_new_above(__cil_tmp24, __cil_tmp25, 1, __cil_tmp28);
    __cil_tmp29 = (unsigned long )dev_priv;
    __cil_tmp30 = __cil_tmp29 + 2632UL;
    __cil_tmp31 = (rwlock_t *)__cil_tmp30;
    _raw_write_unlock(__cil_tmp31);
    if (! (ret == -11)) {
      goto while_break___2;
    }
  }
  while_break___2: ;
  return (ret);
}
}
static int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                             struct idr *idr , enum ttm_object_type obj_type , bool delay_id ,
                             void (*res_free)(struct vmw_resource *res ) , void (*remove_from_lists)(struct vmw_resource *res ) ) 
{ int tmp___7 ;
  struct kref *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;

  {
  __cil_tmp9 = (struct kref *)res;
  kref_init(__cil_tmp9);
  __cil_tmp10 = (unsigned long )res;
  __cil_tmp11 = __cil_tmp10 + 48UL;
  __cil_tmp12 = (void *)0;
  *((void (**)(struct vmw_resource *res ))__cil_tmp11) = (void (*)(struct vmw_resource *res ))__cil_tmp12;
  __cil_tmp13 = (unsigned long )res;
  __cil_tmp14 = __cil_tmp13 + 56UL;
  *((void (**)(struct vmw_resource *res ))__cil_tmp14) = res_free;
  __cil_tmp15 = (unsigned long )res;
  __cil_tmp16 = __cil_tmp15 + 40UL;
  *((void (**)(struct vmw_resource *res ))__cil_tmp16) = remove_from_lists;
  __cil_tmp17 = (unsigned long )res;
  __cil_tmp18 = __cil_tmp17 + 28UL;
  *((enum ttm_object_type *)__cil_tmp18) = obj_type;
  __cil_tmp19 = (unsigned long )res;
  __cil_tmp20 = __cil_tmp19 + 16UL;
  *((struct idr **)__cil_tmp20) = idr;
  __cil_tmp21 = (unsigned long )res;
  __cil_tmp22 = __cil_tmp21 + 32UL;
  *((bool *)__cil_tmp22) = (bool )0;
  __cil_tmp23 = (unsigned long )res;
  __cil_tmp24 = __cil_tmp23 + 8UL;
  *((struct vmw_private **)__cil_tmp24) = dev_priv;
  __cil_tmp25 = (unsigned long )res;
  __cil_tmp26 = __cil_tmp25 + 80UL;
  __cil_tmp27 = (struct list_head *)__cil_tmp26;
  INIT_LIST_HEAD(__cil_tmp27);
  __cil_tmp28 = (unsigned long )res;
  __cil_tmp29 = __cil_tmp28 + 64UL;
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
  INIT_LIST_HEAD(__cil_tmp30);
  __cil_tmp31 = (unsigned long )res;
  __cil_tmp32 = __cil_tmp31 + 24UL;
  *((int *)__cil_tmp32) = -1;
  if (delay_id) {
    return (0);
  } else {
    tmp___7 = vmw_resource_alloc_id(dev_priv, res);
    return (tmp___7);
  }
}
}
static void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  rwlock_t *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  rwlock_t *__cil_tmp15 ;

  {
  __cil_tmp4 = (unsigned long )res;
  __cil_tmp5 = __cil_tmp4 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp5);
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2632UL;
  __cil_tmp8 = (rwlock_t *)__cil_tmp7;
  _raw_write_lock(__cil_tmp8);
  __cil_tmp9 = (unsigned long )res;
  __cil_tmp10 = __cil_tmp9 + 32UL;
  *((bool *)__cil_tmp10) = (bool )1;
  __cil_tmp11 = (unsigned long )res;
  __cil_tmp12 = __cil_tmp11 + 48UL;
  *((void (**)(struct vmw_resource *res ))__cil_tmp12) = hw_destroy;
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2632UL;
  __cil_tmp15 = (rwlock_t *)__cil_tmp14;
  _raw_write_unlock(__cil_tmp15);
  return;
}
}
struct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv , struct idr *idr ,
                                         int id ) 
{ struct vmw_resource *res ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  rwlock_t *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct kref *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  rwlock_t *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  void *__cil_tmp25 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2632UL;
  __cil_tmp9 = (rwlock_t *)__cil_tmp8;
  _raw_read_lock(__cil_tmp9);
  tmp___7 = idr_find(idr, id);
  res = (struct vmw_resource *)tmp___7;
  if (res) {
    __cil_tmp10 = (unsigned long )res;
    __cil_tmp11 = __cil_tmp10 + 32UL;
    if (*((bool *)__cil_tmp11)) {
      __cil_tmp12 = (struct kref *)res;
      kref_get(__cil_tmp12);
    } else {
      __cil_tmp13 = (void *)0;
      res = (struct vmw_resource *)__cil_tmp13;
    }
  } else {
    __cil_tmp14 = (void *)0;
    res = (struct vmw_resource *)__cil_tmp14;
  }
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2632UL;
  __cil_tmp17 = (rwlock_t *)__cil_tmp16;
  _raw_read_unlock(__cil_tmp17);
  __cil_tmp18 = (void *)0;
  __cil_tmp19 = (unsigned long )__cil_tmp18;
  __cil_tmp20 = (unsigned long )res;
  __cil_tmp21 = __cil_tmp20 == __cil_tmp19;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___8) {
    __cil_tmp25 = (void *)0;
    return ((struct vmw_resource *)__cil_tmp25);
  }
  return (res);
}
}
static void vmw_hw_context_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct __anonstruct_cmd_429___1 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  bool __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  bool __cil_tmp30 ;

  {
  __cil_tmp6 = (unsigned long )res;
  __cil_tmp7 = __cil_tmp6 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp7);
  __cil_tmp8 = (bool )1;
  __cil_tmp9 = (unsigned long )res;
  __cil_tmp10 = __cil_tmp9 + 24UL;
  __cil_tmp11 = *((int *)__cil_tmp10);
  __cil_tmp12 = (uint32_t )__cil_tmp11;
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp8, __cil_tmp12);
  __cil_tmp13 = (uint32_t )12UL;
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp13);
  cmd = (struct __anonstruct_cmd_429___1 *)tmp___7;
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = (unsigned long )cmd;
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___8) {
    drm_err("vmw_hw_context_destroy", "Failed reserving FIFO space for surface destruction.\n");
    return;
  }
  *((uint32 *)cmd) = (__u32 )1046;
  __cil_tmp21 = 4;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  *((uint32 *)__cil_tmp23) = (__u32 )4UL;
  __cil_tmp24 = (unsigned long )cmd;
  __cil_tmp25 = __cil_tmp24 + 8UL;
  __cil_tmp26 = (unsigned long )res;
  __cil_tmp27 = __cil_tmp26 + 24UL;
  __cil_tmp28 = *((int *)__cil_tmp27);
  *((uint32 *)__cil_tmp25) = (__u32 )__cil_tmp28;
  __cil_tmp29 = (uint32_t )12UL;
  vmw_fifo_commit(dev_priv, __cil_tmp29);
  __cil_tmp30 = (bool )0;
  vmw_3d_resource_dec(dev_priv, __cil_tmp30);
  return;
}
}
static int vmw_context_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                            void (*res_free)(struct vmw_resource *res ) ) 
{ int ret ;
  struct __anonstruct_cmd_430___1 *cmd ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  struct vmw_resource **__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct idr *__cil_tmp14 ;
  enum ttm_object_type __cil_tmp15 ;
  bool __cil_tmp16 ;
  void *__cil_tmp17 ;
  void (*__cil_tmp18)(struct vmw_resource *res ) ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct vmw_resource **__cil_tmp23 ;
  struct vmw_resource *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_resource **__cil_tmp45 ;
  struct vmw_resource *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  bool __cil_tmp51 ;
  struct vmw_resource **__cil_tmp52 ;
  struct vmw_resource *__cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct vmw_resource **__cil_tmp57 ;
  struct vmw_resource *__cil_tmp58 ;
  void *__cil_tmp59 ;
  struct vmw_resource **__cil_tmp60 ;
  struct vmw_resource *__cil_tmp61 ;

  {
  __cil_tmp10 = & res;
  __cil_tmp11 = *__cil_tmp10;
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2656UL;
  __cil_tmp14 = (struct idr *)__cil_tmp13;
  __cil_tmp15 = (enum ttm_object_type )256;
  __cil_tmp16 = (bool )0;
  __cil_tmp17 = (void *)0;
  __cil_tmp18 = (void (*)(struct vmw_resource *res ))__cil_tmp17;
  ret = vmw_resource_init(dev_priv, __cil_tmp11, __cil_tmp14, __cil_tmp15, __cil_tmp16,
                          res_free, __cil_tmp18);
  __cil_tmp19 = ret != 0;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    drm_err("vmw_context_init", "Failed to allocate a resource id.\n");
    goto out_early;
  }
  __cil_tmp23 = & res;
  __cil_tmp24 = *__cil_tmp23;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = __cil_tmp25 + 24UL;
  __cil_tmp27 = *((int *)__cil_tmp26);
  __cil_tmp28 = __cil_tmp27 >= 256;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___8) {
    drm_err("vmw_context_init", "Out of hw context ids.\n");
    vmw_resource_unreference(& res);
    return (-12);
  }
  __cil_tmp32 = (uint32_t )12UL;
  tmp___9 = vmw_fifo_reserve(dev_priv, __cil_tmp32);
  cmd = (struct __anonstruct_cmd_430___1 *)tmp___9;
  __cil_tmp33 = (void *)0;
  __cil_tmp34 = (unsigned long )__cil_tmp33;
  __cil_tmp35 = (unsigned long )cmd;
  __cil_tmp36 = __cil_tmp35 == __cil_tmp34;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = (long )__cil_tmp38;
  tmp___10 = ldv__builtin_expect(__cil_tmp39, 0L);
  if (tmp___10) {
    drm_err("vmw_context_init", "Fifo reserve failed.\n");
    vmw_resource_unreference(& res);
    return (-12);
  }
  *((uint32 *)cmd) = (__u32 )1045;
  __cil_tmp40 = 4;
  __cil_tmp41 = (unsigned long )cmd;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  *((uint32 *)__cil_tmp42) = (__u32 )4UL;
  __cil_tmp43 = (unsigned long )cmd;
  __cil_tmp44 = __cil_tmp43 + 8UL;
  __cil_tmp45 = & res;
  __cil_tmp46 = *__cil_tmp45;
  __cil_tmp47 = (unsigned long )__cil_tmp46;
  __cil_tmp48 = __cil_tmp47 + 24UL;
  __cil_tmp49 = *((int *)__cil_tmp48);
  *((uint32 *)__cil_tmp44) = (__u32 )__cil_tmp49;
  __cil_tmp50 = (uint32_t )12UL;
  vmw_fifo_commit(dev_priv, __cil_tmp50);
  __cil_tmp51 = (bool )0;
  vmw_3d_resource_inc(dev_priv, __cil_tmp51);
  __cil_tmp52 = & res;
  __cil_tmp53 = *__cil_tmp52;
  vmw_resource_activate(__cil_tmp53, & vmw_hw_context_destroy);
  return (0);
  out_early: 
  __cil_tmp54 = (void *)0;
  __cil_tmp55 = (unsigned long )__cil_tmp54;
  __cil_tmp56 = (unsigned long )res_free;
  if (__cil_tmp56 == __cil_tmp55) {
    __cil_tmp57 = & res;
    __cil_tmp58 = *__cil_tmp57;
    __cil_tmp59 = (void *)__cil_tmp58;
    kfree(__cil_tmp59);
  } else {
    __cil_tmp60 = & res;
    __cil_tmp61 = *__cil_tmp60;
    (*res_free)(__cil_tmp61);
  }
  return (ret);
}
}
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) 
{ struct vmw_resource *res ;
  void *tmp___7 ;
  int ret ;
  long tmp___8 ;
  struct vmw_resource *tmp___9 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void (*__cil_tmp16)(struct vmw_resource *res ) ;
  void *__cil_tmp17 ;

  {
  tmp___7 = kmalloc(96UL, 208U);
  res = (struct vmw_resource *)tmp___7;
  __cil_tmp7 = (void *)0;
  __cil_tmp8 = (unsigned long )__cil_tmp7;
  __cil_tmp9 = (unsigned long )res;
  __cil_tmp10 = __cil_tmp9 == __cil_tmp8;
  __cil_tmp11 = ! __cil_tmp10;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = (long )__cil_tmp12;
  tmp___8 = ldv__builtin_expect(__cil_tmp13, 0L);
  if (tmp___8) {
    __cil_tmp14 = (void *)0;
    return ((struct vmw_resource *)__cil_tmp14);
  }
  __cil_tmp15 = (void *)0;
  __cil_tmp16 = (void (*)(struct vmw_resource *res ))__cil_tmp15;
  ret = vmw_context_init(dev_priv, res, __cil_tmp16);
  if (ret == 0) {
    tmp___9 = res;
  } else {
    __cil_tmp17 = (void *)0;
    tmp___9 = (struct vmw_resource *)__cil_tmp17;
  }
  return (tmp___9);
}
}
static void vmw_user_context_free(struct vmw_resource *res ) 
{ struct vmw_user_context *ctx ;
  struct vmw_resource *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_context *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  __mptr = res;
  __cil_tmp6 = (struct vmw_user_context *)0;
  __cil_tmp7 = (unsigned long )__cil_tmp6;
  __cil_tmp8 = __cil_tmp7 + 64UL;
  __cil_tmp9 = (struct vmw_resource *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  ctx = (struct vmw_user_context *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )res;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp14);
  __cil_tmp15 = (void *)ctx;
  kfree(__cil_tmp15);
  tmp___7 = vmw_mem_glob(dev_priv);
  ttm_mem_global_free(tmp___7, vmw_user_context_size);
  return;
}
}
static void vmw_user_context_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_context *ctx ;
  struct ttm_base_object *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_context *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  base = *p_base;
  __mptr = base;
  __cil_tmp6 = (struct vmw_user_context *)0;
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  ctx = (struct vmw_user_context *)__cil_tmp10;
  __cil_tmp11 = & res;
  __cil_tmp12 = (unsigned long )ctx;
  __cil_tmp13 = __cil_tmp12 + 64UL;
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
  __cil_tmp14 = (void *)0;
  *p_base = (struct ttm_base_object *)__cil_tmp14;
  vmw_resource_unreference(& res);
  return;
}
}
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_resource *res ;
  struct vmw_user_context *ctx ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  int ret ;
  long tmp___9 ;
  struct vmw_resource *__mptr ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_resource **__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct idr *__cil_tmp19 ;
  int32_t __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_resource **__cil_tmp23 ;
  struct vmw_resource *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_resource **__cil_tmp31 ;
  struct vmw_resource *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  void (*__cil_tmp35)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp36 ;
  struct vmw_resource **__cil_tmp37 ;
  struct vmw_resource *__cil_tmp38 ;
  struct vmw_user_context *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_resource *__cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_object_file *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  bool __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  enum ttm_ref_type __cil_tmp61 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_context_arg *)data;
  tmp___8 = vmw_fpriv(file_priv);
  __cil_tmp14 = (unsigned long )tmp___8;
  __cil_tmp15 = __cil_tmp14 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp15);
  ret = 0;
  __cil_tmp16 = & res;
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 2656UL;
  __cil_tmp19 = (struct idr *)__cil_tmp18;
  __cil_tmp20 = *((int32_t *)arg);
  *__cil_tmp16 = vmw_resource_lookup(dev_priv, __cil_tmp19, __cil_tmp20);
  __cil_tmp21 = (void *)0;
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = & res;
  __cil_tmp24 = *__cil_tmp23;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = __cil_tmp25 == __cil_tmp22;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___9 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___9) {
    return (-22);
  }
  __cil_tmp30 = (unsigned long )(& vmw_user_context_free);
  __cil_tmp31 = & res;
  __cil_tmp32 = *__cil_tmp31;
  __cil_tmp33 = (unsigned long )__cil_tmp32;
  __cil_tmp34 = __cil_tmp33 + 56UL;
  __cil_tmp35 = *((void (**)(struct vmw_resource *res ))__cil_tmp34);
  __cil_tmp36 = (unsigned long )__cil_tmp35;
  if (__cil_tmp36 != __cil_tmp30) {
    ret = -22;
    goto out;
  }
  __cil_tmp37 = & res;
  __cil_tmp38 = *__cil_tmp37;
  __mptr = __cil_tmp38;
  __cil_tmp39 = (struct vmw_user_context *)0;
  __cil_tmp40 = (unsigned long )__cil_tmp39;
  __cil_tmp41 = __cil_tmp40 + 64UL;
  __cil_tmp42 = (struct vmw_resource *)__cil_tmp41;
  __cil_tmp43 = (unsigned int )__cil_tmp42;
  __cil_tmp44 = (char *)__mptr;
  __cil_tmp45 = __cil_tmp44 - __cil_tmp43;
  ctx = (struct vmw_user_context *)__cil_tmp45;
  __cil_tmp46 = (unsigned long )tfile;
  __cil_tmp47 = 32;
  __cil_tmp48 = (unsigned long )ctx;
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
  __cil_tmp50 = *((struct ttm_object_file **)__cil_tmp49);
  __cil_tmp51 = (unsigned long )__cil_tmp50;
  if (__cil_tmp51 != __cil_tmp46) {
    __cil_tmp52 = 28;
    __cil_tmp53 = (unsigned long )ctx;
    __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
    __cil_tmp55 = *((bool *)__cil_tmp54);
    if (! __cil_tmp55) {
      ret = -1;
      goto out;
    }
  }
  __cil_tmp56 = 16;
  __cil_tmp57 = __cil_tmp56;
  __cil_tmp58 = (unsigned long )ctx;
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
  __cil_tmp60 = *((unsigned long *)__cil_tmp59);
  __cil_tmp61 = (enum ttm_ref_type )0;
  ttm_ref_object_base_unref(tfile, __cil_tmp60, __cil_tmp61);
  out: 
  vmw_resource_unreference(& res);
  return (ret);
}
}
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  int ret ;
  size_t tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct ttm_mem_global *tmp___14 ;
  long tmp___15 ;
  void *tmp___16 ;
  struct ttm_mem_global *tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  size_t __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;
  bool __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  bool __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  struct vmw_resource **__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  void *__cil_tmp63 ;
  struct vmw_resource **__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  long __cil_tmp69 ;
  struct vmw_resource **__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  struct ttm_base_object *__cil_tmp74 ;
  bool __cil_tmp75 ;
  enum ttm_object_type __cil_tmp76 ;
  void *__cil_tmp77 ;
  void (*__cil_tmp78)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct vmw_resource **__cil_tmp83 ;
  struct vmw_resource *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct ttm_lock *__cil_tmp87 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_context_arg *)data;
  tmp___9 = vmw_fpriv(file_priv);
  __cil_tmp25 = (unsigned long )tmp___9;
  __cil_tmp26 = __cil_tmp25 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp26);
  __cil_tmp27 = (unsigned long )file_priv;
  __cil_tmp28 = __cil_tmp27 + 152UL;
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
  tmp___10 = vmw_master(__cil_tmp29);
  vmaster = tmp___10;
  __cil_tmp30 = vmw_user_context_size == 0ULL;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___12 = ldv__builtin_expect(__cil_tmp33, 0L);
  if (tmp___12) {
    tmp___11 = ttm_round_pot(160UL);
    __cil_tmp34 = tmp___11 + 128UL;
    vmw_user_context_size = (uint64_t )__cil_tmp34;
  }
  __cil_tmp35 = (struct ttm_lock *)vmaster;
  __cil_tmp36 = (bool )1;
  ret = ttm_read_lock(__cil_tmp35, __cil_tmp36);
  __cil_tmp37 = ret != 0;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___13 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___13) {
    return (ret);
  }
  tmp___14 = vmw_mem_glob(dev_priv);
  __cil_tmp41 = (bool )0;
  __cil_tmp42 = (bool )1;
  ret = ttm_mem_global_alloc(tmp___14, vmw_user_context_size, __cil_tmp41, __cil_tmp42);
  __cil_tmp43 = ret != 0;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = (long )__cil_tmp45;
  tmp___15 = ldv__builtin_expect(__cil_tmp46, 0L);
  if (tmp___15) {
    if (ret != -512) {
      drm_err("vmw_context_define_ioctl", "Out of graphics memory for context creation.\n");
    }
    goto out_unlock;
  }
  tmp___16 = kmalloc(160UL, 208U);
  ctx = (struct vmw_user_context *)tmp___16;
  __cil_tmp47 = (void *)0;
  __cil_tmp48 = (unsigned long )__cil_tmp47;
  __cil_tmp49 = (unsigned long )ctx;
  __cil_tmp50 = __cil_tmp49 == __cil_tmp48;
  __cil_tmp51 = ! __cil_tmp50;
  __cil_tmp52 = ! __cil_tmp51;
  __cil_tmp53 = (long )__cil_tmp52;
  tmp___18 = ldv__builtin_expect(__cil_tmp53, 0L);
  if (tmp___18) {
    tmp___17 = vmw_mem_glob(dev_priv);
    ttm_mem_global_free(tmp___17, vmw_user_context_size);
    ret = -12;
    goto out_unlock;
  }
  __cil_tmp54 = & res;
  __cil_tmp55 = (unsigned long )ctx;
  __cil_tmp56 = __cil_tmp55 + 64UL;
  *__cil_tmp54 = (struct vmw_resource *)__cil_tmp56;
  __cil_tmp57 = 28;
  __cil_tmp58 = (unsigned long )ctx;
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
  *((bool *)__cil_tmp59) = (bool )0;
  __cil_tmp60 = 32;
  __cil_tmp61 = (unsigned long )ctx;
  __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
  __cil_tmp63 = (void *)0;
  *((struct ttm_object_file **)__cil_tmp62) = (struct ttm_object_file *)__cil_tmp63;
  __cil_tmp64 = & res;
  __cil_tmp65 = *__cil_tmp64;
  ret = vmw_context_init(dev_priv, __cil_tmp65, & vmw_user_context_free);
  __cil_tmp66 = ret != 0;
  __cil_tmp67 = ! __cil_tmp66;
  __cil_tmp68 = ! __cil_tmp67;
  __cil_tmp69 = (long )__cil_tmp68;
  tmp___19 = ldv__builtin_expect(__cil_tmp69, 0L);
  if (tmp___19) {
    goto out_unlock;
  }
  __cil_tmp70 = & tmp___8;
  __cil_tmp71 = (unsigned long )ctx;
  __cil_tmp72 = __cil_tmp71 + 64UL;
  __cil_tmp73 = (struct vmw_resource *)__cil_tmp72;
  *__cil_tmp70 = vmw_resource_reference(__cil_tmp73);
  __cil_tmp74 = (struct ttm_base_object *)ctx;
  __cil_tmp75 = (bool )0;
  __cil_tmp76 = (enum ttm_object_type )256;
  __cil_tmp77 = (void *)0;
  __cil_tmp78 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp77;
  ret = ttm_base_object_init(tfile, __cil_tmp74, __cil_tmp75, __cil_tmp76, & vmw_user_context_base_release,
                             __cil_tmp78);
  __cil_tmp79 = ret != 0;
  __cil_tmp80 = ! __cil_tmp79;
  __cil_tmp81 = ! __cil_tmp80;
  __cil_tmp82 = (long )__cil_tmp81;
  tmp___20 = ldv__builtin_expect(__cil_tmp82, 0L);
  if (tmp___20) {
    vmw_resource_unreference(& tmp___8);
    goto out_err;
  }
  __cil_tmp83 = & res;
  __cil_tmp84 = *__cil_tmp83;
  __cil_tmp85 = (unsigned long )__cil_tmp84;
  __cil_tmp86 = __cil_tmp85 + 24UL;
  *((int32_t *)arg) = *((int *)__cil_tmp86);
  out_err: 
  vmw_resource_unreference(& res);
  out_unlock: 
  __cil_tmp87 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp87);
  return (ret);
}
}
int vmw_context_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      int id , struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  int ret ;
  void *tmp___7 ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *__mptr ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  rwlock_t *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct idr *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_user_context *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_resource *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct ttm_object_file *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  bool __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  rwlock_t *__cil_tmp37 ;

  {
  ret = 0;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2632UL;
  __cil_tmp12 = (rwlock_t *)__cil_tmp11;
  _raw_read_lock(__cil_tmp12);
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2656UL;
  __cil_tmp15 = (struct idr *)__cil_tmp14;
  tmp___7 = idr_find(__cil_tmp15, id);
  res = (struct vmw_resource *)tmp___7;
  if (res) {
    __cil_tmp16 = (unsigned long )res;
    __cil_tmp17 = __cil_tmp16 + 32UL;
    if (*((bool *)__cil_tmp17)) {
      __mptr = res;
      __cil_tmp18 = (struct vmw_user_context *)0;
      __cil_tmp19 = (unsigned long )__cil_tmp18;
      __cil_tmp20 = __cil_tmp19 + 64UL;
      __cil_tmp21 = (struct vmw_resource *)__cil_tmp20;
      __cil_tmp22 = (unsigned int )__cil_tmp21;
      __cil_tmp23 = (char *)__mptr;
      __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
      ctx = (struct vmw_user_context *)__cil_tmp24;
      __cil_tmp25 = (unsigned long )tfile;
      __cil_tmp26 = 32;
      __cil_tmp27 = (unsigned long )ctx;
      __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
      __cil_tmp29 = *((struct ttm_object_file **)__cil_tmp28);
      __cil_tmp30 = (unsigned long )__cil_tmp29;
      if (__cil_tmp30 != __cil_tmp25) {
        __cil_tmp31 = 28;
        __cil_tmp32 = (unsigned long )ctx;
        __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
        __cil_tmp34 = *((bool *)__cil_tmp33);
        if (! __cil_tmp34) {
          ret = -1;
        }
      }
      if (p_res) {
        *p_res = vmw_resource_reference(res);
      }
    } else {
      ret = -22;
    }
  } else {
    ret = -22;
  }
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2632UL;
  __cil_tmp37 = (rwlock_t *)__cil_tmp36;
  _raw_read_unlock(__cil_tmp37);
  return (ret);
}
}
static struct vmw_bpp vmw_sf_bpp[121]  = 
  {      {(uint8_t )0, (uint8_t )0}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )4, (uint8_t )16}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )8, (uint8_t )8}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(uint8_t )64, (uint8_t )64}, 
        {(uint8_t )12, (uint8_t )12}, 
        {(uint8_t )12, (uint8_t )12}, 
        {(uint8_t )12, (uint8_t )8}, 
        {(uint8_t )32, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )4, (uint8_t )16}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )8, (uint8_t )32}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(uint8_t )16, (uint8_t )16}, 
        {(uint8_t )24, (uint8_t )24}, 
        {(uint8_t )32, (uint8_t )32}};
 static uint32_t vmw_surface_dma_size(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_dma_size(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_dma_size(struct vmw_surface *srf ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  __cil_tmp2 = (unsigned long )srf;
  __cil_tmp3 = __cil_tmp2 + 152UL;
  __cil_tmp4 = *((uint32_t *)__cil_tmp3);
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 * 84UL;
  return ((uint32_t )__cil_tmp6);
}
}
 static uint32_t vmw_surface_define_size(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_define_size(struct vmw_surface *srf )  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_define_size(struct vmw_surface *srf ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  __cil_tmp2 = (unsigned long )srf;
  __cil_tmp3 = __cil_tmp2 + 152UL;
  __cil_tmp4 = *((uint32_t *)__cil_tmp3);
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 * 12UL;
  __cil_tmp7 = 44UL + __cil_tmp6;
  return ((uint32_t )__cil_tmp7);
}
}
 static uint32_t vmw_surface_destroy_size(void)  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_destroy_size(void)  __attribute__((__no_instrument_function__)) ;
 static uint32_t vmw_surface_destroy_size(void) 
{ 

  {
  return ((uint32_t )12UL);
}
}
static void vmw_surface_destroy_encode(uint32_t id , void *cmd_space ) 
{ struct vmw_surface_destroy *cmd ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;

  {
  cmd = (struct vmw_surface_destroy *)cmd_space;
  *((uint32 *)cmd) = (uint32 )1041;
  __cil_tmp4 = 4;
  __cil_tmp5 = (unsigned long )cmd;
  __cil_tmp6 = __cil_tmp5 + __cil_tmp4;
  *((uint32 *)__cil_tmp6) = (uint32 )4UL;
  __cil_tmp7 = (unsigned long )cmd;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  *((uint32 *)__cil_tmp8) = id;
  return;
}
}
static void vmw_surface_define_encode(struct vmw_surface *srf , void *cmd_space ) 
{ struct vmw_surface_define *cmd ;
  struct drm_vmw_size *src_size ;
  SVGA3dSize *cmd_size ;
  uint32_t cmd_len ;
  int i ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  __u32 __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct drm_vmw_size *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  uint32_t __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;

  {
  cmd = (struct vmw_surface_define *)cmd_space;
  __cil_tmp8 = (unsigned long )srf;
  __cil_tmp9 = __cil_tmp8 + 152UL;
  __cil_tmp10 = *((uint32_t *)__cil_tmp9);
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = __cil_tmp11 * 12UL;
  __cil_tmp13 = 36UL + __cil_tmp12;
  cmd_len = (uint32_t )__cil_tmp13;
  *((uint32 *)cmd) = (uint32 )1040;
  __cil_tmp14 = 4;
  __cil_tmp15 = (unsigned long )cmd;
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
  *((uint32 *)__cil_tmp16) = cmd_len;
  __cil_tmp17 = (unsigned long )cmd;
  __cil_tmp18 = __cil_tmp17 + 8UL;
  __cil_tmp19 = 24;
  __cil_tmp20 = (unsigned long )srf;
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
  __cil_tmp22 = *((int *)__cil_tmp21);
  *((uint32 *)__cil_tmp18) = (uint32 )__cil_tmp22;
  __cil_tmp23 = 12;
  __cil_tmp24 = (unsigned long )cmd;
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
  __cil_tmp26 = (unsigned long )srf;
  __cil_tmp27 = __cil_tmp26 + 112UL;
  __cil_tmp28 = *((uint32_t *)__cil_tmp27);
  *((SVGA3dSurfaceFlags *)__cil_tmp25) = (SVGA3dSurfaceFlags )__cil_tmp28;
  __cil_tmp29 = 16;
  __cil_tmp30 = (unsigned long )cmd;
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
  __cil_tmp32 = (unsigned long )srf;
  __cil_tmp33 = __cil_tmp32 + 116UL;
  __cil_tmp34 = *((uint32_t *)__cil_tmp33);
  __cil_tmp35 = __cil_tmp34;
  *((SVGA3dSurfaceFormat *)__cil_tmp31) = (SVGA3dSurfaceFormat )__cil_tmp35;
  i = 0;
  while (1) {

    if (! (i < 6)) {
      goto while_break;
    }
    __cil_tmp36 = (unsigned long )i * 4UL;
    __cil_tmp37 = 12UL + __cil_tmp36;
    __cil_tmp38 = 8UL + __cil_tmp37;
    __cil_tmp39 = (unsigned long )cmd;
    __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
    __cil_tmp41 = (unsigned long )i * 4UL;
    __cil_tmp42 = 120UL + __cil_tmp41;
    __cil_tmp43 = (unsigned long )srf;
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
    *((uint32 *)__cil_tmp40) = *((uint32_t *)__cil_tmp44);
    i ++;
  }
  while_break: 
  cmd ++;
  cmd_size = (SVGA3dSize *)cmd;
  __cil_tmp45 = (unsigned long )srf;
  __cil_tmp46 = __cil_tmp45 + 144UL;
  __cil_tmp47 = *((struct drm_vmw_size **)__cil_tmp46);
  src_size = __cil_tmp47;
  i = 0;
  while (1) {
    __cil_tmp48 = (unsigned long )srf;
    __cil_tmp49 = __cil_tmp48 + 152UL;
    __cil_tmp50 = *((uint32_t *)__cil_tmp49);
    __cil_tmp51 = (uint32_t )i;
    if (! (__cil_tmp51 < __cil_tmp50)) {
      goto while_break___0;
    }
    *((uint32 *)cmd_size) = *((uint32_t *)src_size);
    __cil_tmp52 = (unsigned long )cmd_size;
    __cil_tmp53 = __cil_tmp52 + 4UL;
    __cil_tmp54 = (unsigned long )src_size;
    __cil_tmp55 = __cil_tmp54 + 4UL;
    *((uint32 *)__cil_tmp53) = *((uint32_t *)__cil_tmp55);
    __cil_tmp56 = (unsigned long )cmd_size;
    __cil_tmp57 = __cil_tmp56 + 8UL;
    __cil_tmp58 = (unsigned long )src_size;
    __cil_tmp59 = __cil_tmp58 + 8UL;
    *((uint32 *)__cil_tmp57) = *((uint32_t *)__cil_tmp59);
    i ++;
    cmd_size ++;
    src_size ++;
  }
  while_break___0: ;
  return;
}
}
static void vmw_surface_dma_encode(struct vmw_surface *srf , void *cmd_space , SVGAGuestPtr *ptr ,
                                   bool to_surface ) 
{ uint32_t i ;
  uint32_t bpp ;
  uint32_t stride_bpp ;
  struct vmw_surface_dma *cmd ;
  SVGA3dCmdHeader *header ;
  SVGA3dCmdSurfaceDMA *body ;
  SVGA3dCopyBox *cb ;
  SVGA3dCmdSurfaceDMASuffix *suffix ;
  struct vmw_surface_offset *cur_offset ;
  struct drm_vmw_size *cur_size ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint8_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint8_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_surface_offset *__cil_tmp39 ;
  struct vmw_surface_offset *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct drm_vmw_size *__cil_tmp43 ;
  struct drm_vmw_size *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  SVGAGuestPtr __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  uint32_t __cil_tmp56 ;
  uint32 __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  uint32 __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  uint32_t __cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  uint32_t __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  uint32_t __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  uint32_t __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  uint32_t __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  uint32_t __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  uint32_t __cil_tmp118 ;
  uint32 __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  uint32_t __cil_tmp122 ;
  uint32 __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32 __cil_tmp127 ;
  uint32 __cil_tmp128 ;
  uint32 __cil_tmp129 ;
  uint32 __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  uint32 __cil_tmp49_offset137 ;
  uint32 __cil_tmp49_gmrId138 ;
  uint32 __cil_tmp139 ;
  uint32 __cil_tmp140 ;

  {
  __cil_tmp15 = (unsigned long )srf;
  __cil_tmp16 = __cil_tmp15 + 116UL;
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
  __cil_tmp18 = (unsigned long )__cil_tmp17 * 2UL;
  __cil_tmp19 = (unsigned long )(vmw_sf_bpp) + __cil_tmp18;
  __cil_tmp20 = *((uint8_t *)__cil_tmp19);
  bpp = (uint32_t )__cil_tmp20;
  __cil_tmp21 = (unsigned long )srf;
  __cil_tmp22 = __cil_tmp21 + 116UL;
  __cil_tmp23 = *((uint32_t *)__cil_tmp22);
  __cil_tmp24 = (unsigned long )__cil_tmp23 * 2UL;
  __cil_tmp25 = __cil_tmp24 + 1UL;
  __cil_tmp26 = (unsigned long )(vmw_sf_bpp) + __cil_tmp25;
  __cil_tmp27 = *((uint8_t *)__cil_tmp26);
  stride_bpp = (uint32_t )__cil_tmp27;
  cmd = (struct vmw_surface_dma *)cmd_space;
  i = (uint32_t )0;
  while (1) {
    __cil_tmp28 = (unsigned long )srf;
    __cil_tmp29 = __cil_tmp28 + 152UL;
    __cil_tmp30 = *((uint32_t *)__cil_tmp29);
    if (! (i < __cil_tmp30)) {
      goto while_break;
    }
    header = (SVGA3dCmdHeader *)cmd;
    __cil_tmp31 = (unsigned long )cmd;
    __cil_tmp32 = __cil_tmp31 + 8UL;
    body = (SVGA3dCmdSurfaceDMA *)__cil_tmp32;
    __cil_tmp33 = (unsigned long )cmd;
    __cil_tmp34 = __cil_tmp33 + 36UL;
    cb = (SVGA3dCopyBox *)__cil_tmp34;
    __cil_tmp35 = (unsigned long )cmd;
    __cil_tmp36 = __cil_tmp35 + 72UL;
    suffix = (SVGA3dCmdSurfaceDMASuffix *)__cil_tmp36;
    __cil_tmp37 = (unsigned long )srf;
    __cil_tmp38 = __cil_tmp37 + 192UL;
    __cil_tmp39 = *((struct vmw_surface_offset **)__cil_tmp38);
    __cil_tmp40 = __cil_tmp39 + i;
    cur_offset = __cil_tmp40;
    __cil_tmp41 = (unsigned long )srf;
    __cil_tmp42 = __cil_tmp41 + 144UL;
    __cil_tmp43 = *((struct drm_vmw_size **)__cil_tmp42);
    __cil_tmp44 = __cil_tmp43 + i;
    cur_size = __cil_tmp44;
    *((uint32 *)header) = (uint32 )1044;
    __cil_tmp45 = (unsigned long )header;
    __cil_tmp46 = __cil_tmp45 + 4UL;
    __cil_tmp47 = 64UL;
    __cil_tmp48 = __cil_tmp47 + 12UL;
    *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp48;
    __cil_tmp139 = ptr->gmrId;
    __cil_tmp140 = ptr->offset;
    __cil_tmp49_gmrId138 = __cil_tmp139;
    __cil_tmp49_offset137 = __cil_tmp140;
    *((SVGAGuestPtr *)body) = __cil_tmp49;
    __cil_tmp50 = 4;
    __cil_tmp51 = __cil_tmp50;
    __cil_tmp52 = (unsigned long )body;
    __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
    __cil_tmp54 = (unsigned long )cur_offset;
    __cil_tmp55 = __cil_tmp54 + 8UL;
    __cil_tmp56 = *((uint32_t *)__cil_tmp55);
    __cil_tmp57 = __cil_tmp56;
    __cil_tmp58 = 4;
    __cil_tmp59 = __cil_tmp58;
    __cil_tmp60 = (unsigned long )body;
    __cil_tmp61 = __cil_tmp60 + __cil_tmp59;
    __cil_tmp62 = *((uint32 *)__cil_tmp61);
    *((uint32 *)__cil_tmp53) = __cil_tmp62 + __cil_tmp57;
    __cil_tmp63 = 8;
    __cil_tmp64 = (unsigned long )body;
    __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
    __cil_tmp66 = stride_bpp;
    __cil_tmp67 = *((uint32_t *)cur_size);
    __cil_tmp68 = __cil_tmp67 * __cil_tmp66;
    __cil_tmp69 = __cil_tmp68 + 7U;
    __cil_tmp70 = __cil_tmp69 >> 3;
    *((uint32 *)__cil_tmp65) = __cil_tmp70;
    __cil_tmp71 = (unsigned long )body;
    __cil_tmp72 = __cil_tmp71 + 12UL;
    __cil_tmp73 = 24;
    __cil_tmp74 = (unsigned long )srf;
    __cil_tmp75 = __cil_tmp74 + __cil_tmp73;
    __cil_tmp76 = *((int *)__cil_tmp75);
    *((uint32 *)__cil_tmp72) = (uint32 )__cil_tmp76;
    __cil_tmp77 = 16;
    __cil_tmp78 = (unsigned long )body;
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
    __cil_tmp80 = *((uint32_t *)cur_offset);
    *((uint32 *)__cil_tmp79) = __cil_tmp80;
    __cil_tmp81 = 20;
    __cil_tmp82 = (unsigned long )body;
    __cil_tmp83 = __cil_tmp82 + __cil_tmp81;
    __cil_tmp84 = (unsigned long )cur_offset;
    __cil_tmp85 = __cil_tmp84 + 4UL;
    __cil_tmp86 = *((uint32_t *)__cil_tmp85);
    *((uint32 *)__cil_tmp83) = __cil_tmp86;
    if (to_surface) {
      __cil_tmp87 = (unsigned long )body;
      __cil_tmp88 = __cil_tmp87 + 24UL;
      *((SVGA3dTransferType *)__cil_tmp88) = (SVGA3dTransferType )1;
    } else {
      __cil_tmp89 = (unsigned long )body;
      __cil_tmp90 = __cil_tmp89 + 24UL;
      *((SVGA3dTransferType *)__cil_tmp90) = (SVGA3dTransferType )2;
    }
    *((uint32 *)cb) = (uint32 )0;
    __cil_tmp91 = (unsigned long )cb;
    __cil_tmp92 = __cil_tmp91 + 4UL;
    *((uint32 *)__cil_tmp92) = (uint32 )0;
    __cil_tmp93 = (unsigned long )cb;
    __cil_tmp94 = __cil_tmp93 + 8UL;
    *((uint32 *)__cil_tmp94) = (uint32 )0;
    __cil_tmp95 = (unsigned long )cb;
    __cil_tmp96 = __cil_tmp95 + 24UL;
    *((uint32 *)__cil_tmp96) = (uint32 )0;
    __cil_tmp97 = (unsigned long )cb;
    __cil_tmp98 = __cil_tmp97 + 28UL;
    *((uint32 *)__cil_tmp98) = (uint32 )0;
    __cil_tmp99 = (unsigned long )cb;
    __cil_tmp100 = __cil_tmp99 + 32UL;
    *((uint32 *)__cil_tmp100) = (uint32 )0;
    __cil_tmp101 = (unsigned long )cb;
    __cil_tmp102 = __cil_tmp101 + 12UL;
    __cil_tmp103 = *((uint32_t *)cur_size);
    *((uint32 *)__cil_tmp102) = __cil_tmp103;
    __cil_tmp104 = (unsigned long )cb;
    __cil_tmp105 = __cil_tmp104 + 16UL;
    __cil_tmp106 = (unsigned long )cur_size;
    __cil_tmp107 = __cil_tmp106 + 4UL;
    __cil_tmp108 = *((uint32_t *)__cil_tmp107);
    *((uint32 *)__cil_tmp105) = __cil_tmp108;
    __cil_tmp109 = (unsigned long )cb;
    __cil_tmp110 = __cil_tmp109 + 20UL;
    __cil_tmp111 = (unsigned long )cur_size;
    __cil_tmp112 = __cil_tmp111 + 8UL;
    __cil_tmp113 = *((uint32_t *)__cil_tmp112);
    *((uint32 *)__cil_tmp110) = __cil_tmp113;
    *((uint32 *)suffix) = (uint32 )12UL;
    __cil_tmp114 = (unsigned long )suffix;
    __cil_tmp115 = __cil_tmp114 + 4UL;
    __cil_tmp116 = (unsigned long )cur_size;
    __cil_tmp117 = __cil_tmp116 + 8UL;
    __cil_tmp118 = *((uint32_t *)__cil_tmp117);
    __cil_tmp119 = __cil_tmp118;
    __cil_tmp120 = (unsigned long )cur_size;
    __cil_tmp121 = __cil_tmp120 + 4UL;
    __cil_tmp122 = *((uint32_t *)__cil_tmp121);
    __cil_tmp123 = __cil_tmp122;
    __cil_tmp124 = 8;
    __cil_tmp125 = (unsigned long )body;
    __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
    __cil_tmp127 = *((uint32 *)__cil_tmp126);
    __cil_tmp128 = __cil_tmp127 * __cil_tmp123;
    __cil_tmp129 = __cil_tmp128 * __cil_tmp119;
    __cil_tmp130 = __cil_tmp129 * bpp;
    *((uint32 *)__cil_tmp115) = __cil_tmp130 / stride_bpp;
    __cil_tmp131 = (unsigned long )suffix;
    __cil_tmp132 = __cil_tmp131 + 8UL;
    *((uint32 *)__cil_tmp132) = (uint32 )0;
    __cil_tmp133 = (unsigned long )suffix;
    __cil_tmp134 = __cil_tmp133 + 8UL;
    ((struct __anonstruct_SVGA3dSurfaceDMAFlags_107 *)__cil_tmp134)->unsynchronized = (uint32 )0;
    __cil_tmp135 = (unsigned long )suffix;
    __cil_tmp136 = __cil_tmp135 + 8UL;
    ((struct __anonstruct_SVGA3dSurfaceDMAFlags_107 *)__cil_tmp136)->reserved = (uint32 )0;
    cmd ++;
    i ++;
  }
  while_break: ;
  return;
}
}
static void vmw_hw_surface_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  void *cmd ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  struct vmw_resource *__mptr ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct mutex *__cil_tmp27 ;
  struct vmw_surface *__cil_tmp28 ;
  struct vmw_resource *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct mutex *__cil_tmp43 ;
  bool __cil_tmp44 ;

  {
  __cil_tmp9 = (unsigned long )res;
  __cil_tmp10 = __cil_tmp9 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp10);
  __cil_tmp11 = (unsigned long )res;
  __cil_tmp12 = __cil_tmp11 + 24UL;
  __cil_tmp13 = *((int *)__cil_tmp12);
  if (__cil_tmp13 != -1) {
    tmp___7 = vmw_surface_destroy_size();
    cmd = vmw_fifo_reserve(dev_priv, tmp___7);
    __cil_tmp14 = (void *)0;
    __cil_tmp15 = (unsigned long )__cil_tmp14;
    __cil_tmp16 = (unsigned long )cmd;
    __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
    __cil_tmp18 = ! __cil_tmp17;
    __cil_tmp19 = ! __cil_tmp18;
    __cil_tmp20 = (long )__cil_tmp19;
    tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
    if (tmp___8) {
      drm_err("vmw_hw_surface_destroy", "Failed reserving FIFO space for surface destruction.\n");
      return;
    }
    __cil_tmp21 = (unsigned long )res;
    __cil_tmp22 = __cil_tmp21 + 24UL;
    __cil_tmp23 = *((int *)__cil_tmp22);
    __cil_tmp24 = (uint32_t )__cil_tmp23;
    vmw_surface_destroy_encode(__cil_tmp24, cmd);
    tmp___9 = vmw_surface_destroy_size();
    vmw_fifo_commit(dev_priv, tmp___9);
    __cil_tmp25 = (unsigned long )dev_priv;
    __cil_tmp26 = __cil_tmp25 + 134304UL;
    __cil_tmp27 = (struct mutex *)__cil_tmp26;
    mutex_lock(__cil_tmp27);
    __mptr = res;
    __cil_tmp28 = (struct vmw_surface *)0;
    __cil_tmp29 = (struct vmw_resource *)__cil_tmp28;
    __cil_tmp30 = (unsigned int )__cil_tmp29;
    __cil_tmp31 = (char *)__mptr;
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
    srf = (struct vmw_surface *)__cil_tmp32;
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 134784UL;
    __cil_tmp35 = (unsigned long )srf;
    __cil_tmp36 = __cil_tmp35 + 200UL;
    __cil_tmp37 = *((uint32_t *)__cil_tmp36);
    __cil_tmp38 = (unsigned long )dev_priv;
    __cil_tmp39 = __cil_tmp38 + 134784UL;
    __cil_tmp40 = *((uint32_t *)__cil_tmp39);
    *((uint32_t *)__cil_tmp34) = __cil_tmp40 - __cil_tmp37;
    __cil_tmp41 = (unsigned long )dev_priv;
    __cil_tmp42 = __cil_tmp41 + 134304UL;
    __cil_tmp43 = (struct mutex *)__cil_tmp42;
    mutex_unlock(__cil_tmp43);
  }
  __cil_tmp44 = (bool )0;
  vmw_3d_resource_dec(dev_priv, __cil_tmp44);
  return;
}
}
void vmw_surface_res_free(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource *__mptr ;
  struct vmw_surface *__cil_tmp4 ;
  struct vmw_resource *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct ttm_buffer_object **__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_surface_offset *__cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_vmw_size *__cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
  __mptr = res;
  __cil_tmp4 = (struct vmw_surface *)0;
  __cil_tmp5 = (struct vmw_resource *)__cil_tmp4;
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = (char *)__mptr;
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
  srf = (struct vmw_surface *)__cil_tmp8;
  __cil_tmp9 = (unsigned long )srf;
  __cil_tmp10 = __cil_tmp9 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp10)) {
    __cil_tmp11 = (unsigned long )srf;
    __cil_tmp12 = __cil_tmp11 + 184UL;
    __cil_tmp13 = (struct ttm_buffer_object **)__cil_tmp12;
    ttm_bo_unref(__cil_tmp13);
  }
  __cil_tmp14 = (unsigned long )srf;
  __cil_tmp15 = __cil_tmp14 + 192UL;
  __cil_tmp16 = *((struct vmw_surface_offset **)__cil_tmp15);
  __cil_tmp17 = (void *)__cil_tmp16;
  kfree(__cil_tmp17);
  __cil_tmp18 = (unsigned long )srf;
  __cil_tmp19 = __cil_tmp18 + 144UL;
  __cil_tmp20 = *((struct drm_vmw_size **)__cil_tmp19);
  __cil_tmp21 = (void *)__cil_tmp20;
  kfree(__cil_tmp21);
  __cil_tmp22 = 176;
  __cil_tmp23 = (unsigned long )srf;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = *((uint32_t **)__cil_tmp24);
  __cil_tmp26 = (void *)__cil_tmp25;
  kfree(__cil_tmp26);
  __cil_tmp27 = (void *)srf;
  kfree(__cil_tmp27);
  return;
}
}
int vmw_surface_do_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  uint32_t tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  SVGAGuestPtr ptr ;
  uint32_t tmp___16 ;
  struct vmw_fence_obj *fence ;
  long tmp___17 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct ttm_buffer_object *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_validate_buffer *__cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct ttm_buffer_object *__cil_tmp58 ;
  bool __cil_tmp59 ;
  bool __cil_tmp60 ;
  bool __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  long __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  struct vmw_surface *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct vmw_surface *__cil_tmp80 ;
  void *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  long __cil_tmp87 ;
  struct vmw_surface *__cil_tmp88 ;
  void *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct vmw_surface *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  struct ttm_buffer_object *__cil_tmp95 ;
  struct ttm_buffer_object *__cil_tmp96 ;
  void *__cil_tmp97 ;
  SVGAGuestPtr *__cil_tmp98 ;
  bool __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  void *__cil_tmp102 ;
  struct drm_file *__cil_tmp103 ;
  void *__cil_tmp104 ;
  uint32_t *__cil_tmp105 ;
  struct vmw_fence_obj **__cil_tmp106 ;
  struct vmw_fence_obj *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  struct vmw_fence_obj **__cil_tmp111 ;
  struct vmw_fence_obj *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  struct ttm_buffer_object **__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  struct ttm_buffer_object **__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  struct ttm_buffer_object **__cil_tmp136 ;

  {
  res = (struct vmw_resource *)srf;
  __cil_tmp22 = (unsigned long )res;
  __cil_tmp23 = __cil_tmp22 + 24UL;
  __cil_tmp24 = *((int *)__cil_tmp23);
  __cil_tmp25 = __cil_tmp24 != -1;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 1L);
  if (tmp___7) {
    return (0);
  }
  __cil_tmp29 = (unsigned long )dev_priv;
  __cil_tmp30 = __cil_tmp29 + 2172UL;
  __cil_tmp31 = *((uint32_t *)__cil_tmp30);
  __cil_tmp32 = (unsigned long )srf;
  __cil_tmp33 = __cil_tmp32 + 200UL;
  __cil_tmp34 = *((uint32_t *)__cil_tmp33);
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 134784UL;
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
  __cil_tmp38 = __cil_tmp37 + __cil_tmp34;
  __cil_tmp39 = __cil_tmp38 >= __cil_tmp31;
  __cil_tmp40 = ! __cil_tmp39;
  __cil_tmp41 = ! __cil_tmp40;
  __cil_tmp42 = (long )__cil_tmp41;
  tmp___8 = ldv__builtin_expect(__cil_tmp42, 0L);
  if (tmp___8) {
    return (-16);
  }
  __cil_tmp43 = (unsigned long )srf;
  __cil_tmp44 = __cil_tmp43 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp44)) {
    INIT_LIST_HEAD(& val_list);
    __cil_tmp45 = (unsigned long )(& val_buf) + 16UL;
    __cil_tmp46 = (unsigned long )srf;
    __cil_tmp47 = __cil_tmp46 + 184UL;
    __cil_tmp48 = *((struct ttm_buffer_object **)__cil_tmp47);
    *((struct ttm_buffer_object **)__cil_tmp45) = ttm_bo_reference(__cil_tmp48);
    __cil_tmp49 = (unsigned long )(& val_buf) + 24UL;
    *((void **)__cil_tmp49) = (void *)1UL;
    __cil_tmp50 = & val_buf;
    __cil_tmp51 = (struct list_head *)__cil_tmp50;
    list_add_tail(__cil_tmp51, & val_list);
    ret = ttm_eu_reserve_buffers(& val_list);
    __cil_tmp52 = ret != 0;
    __cil_tmp53 = ! __cil_tmp52;
    __cil_tmp54 = ! __cil_tmp53;
    __cil_tmp55 = (long )__cil_tmp54;
    tmp___9 = ldv__builtin_expect(__cil_tmp55, 0L);
    if (tmp___9) {
      goto out_no_reserve;
    }
    __cil_tmp56 = (unsigned long )srf;
    __cil_tmp57 = __cil_tmp56 + 184UL;
    __cil_tmp58 = *((struct ttm_buffer_object **)__cil_tmp57);
    __cil_tmp59 = (bool )1;
    __cil_tmp60 = (bool )0;
    __cil_tmp61 = (bool )0;
    ret = ttm_bo_validate(__cil_tmp58, & vmw_srf_placement, __cil_tmp59, __cil_tmp60,
                          __cil_tmp61);
    __cil_tmp62 = ret != 0;
    __cil_tmp63 = ! __cil_tmp62;
    __cil_tmp64 = ! __cil_tmp63;
    __cil_tmp65 = (long )__cil_tmp64;
    tmp___10 = ldv__builtin_expect(__cil_tmp65, 0L);
    if (tmp___10) {
      goto out_no_id;
    }
  }
  ret = vmw_resource_alloc_id(dev_priv, res);
  __cil_tmp66 = ret != 0;
  __cil_tmp67 = ! __cil_tmp66;
  __cil_tmp68 = ! __cil_tmp67;
  __cil_tmp69 = (long )__cil_tmp68;
  tmp___11 = ldv__builtin_expect(__cil_tmp69, 0L);
  if (tmp___11) {
    drm_err("vmw_surface_do_validate", "Failed to allocate a surface id.\n");
    goto out_no_id;
  }
  __cil_tmp70 = (unsigned long )res;
  __cil_tmp71 = __cil_tmp70 + 24UL;
  __cil_tmp72 = *((int *)__cil_tmp71);
  __cil_tmp73 = __cil_tmp72 >= 32768;
  __cil_tmp74 = ! __cil_tmp73;
  __cil_tmp75 = ! __cil_tmp74;
  __cil_tmp76 = (long )__cil_tmp75;
  tmp___12 = ldv__builtin_expect(__cil_tmp76, 0L);
  if (tmp___12) {
    ret = -16;
    goto out_no_fifo;
  }
  __cil_tmp77 = srf;
  submit_size = vmw_surface_define_size(__cil_tmp77);
  __cil_tmp78 = (unsigned long )srf;
  __cil_tmp79 = __cil_tmp78 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp79)) {
    __cil_tmp80 = srf;
    tmp___13 = vmw_surface_dma_size(__cil_tmp80);
    submit_size += tmp___13;
  }
  tmp___14 = vmw_fifo_reserve(dev_priv, submit_size);
  cmd = (uint8_t *)tmp___14;
  __cil_tmp81 = (void *)0;
  __cil_tmp82 = (unsigned long )__cil_tmp81;
  __cil_tmp83 = (unsigned long )cmd;
  __cil_tmp84 = __cil_tmp83 == __cil_tmp82;
  __cil_tmp85 = ! __cil_tmp84;
  __cil_tmp86 = ! __cil_tmp85;
  __cil_tmp87 = (long )__cil_tmp86;
  tmp___15 = ldv__builtin_expect(__cil_tmp87, 0L);
  if (tmp___15) {
    drm_err("vmw_surface_do_validate", "Failed reserving FIFO space for surface validation.\n");
    ret = -12;
    goto out_no_fifo;
  }
  __cil_tmp88 = srf;
  __cil_tmp89 = (void *)cmd;
  vmw_surface_define_encode(__cil_tmp88, __cil_tmp89);
  __cil_tmp90 = (unsigned long )srf;
  __cil_tmp91 = __cil_tmp90 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp91)) {
    __cil_tmp92 = srf;
    tmp___16 = vmw_surface_define_size(__cil_tmp92);
    cmd += tmp___16;
    __cil_tmp93 = (unsigned long )srf;
    __cil_tmp94 = __cil_tmp93 + 184UL;
    __cil_tmp95 = *((struct ttm_buffer_object **)__cil_tmp94);
    __cil_tmp96 = __cil_tmp95;
    vmw_bo_get_guest_ptr(__cil_tmp96, & ptr);
    __cil_tmp97 = (void *)cmd;
    __cil_tmp98 = & ptr;
    __cil_tmp99 = (bool )1;
    vmw_surface_dma_encode(srf, __cil_tmp97, __cil_tmp98, __cil_tmp99);
  }
  vmw_fifo_commit(dev_priv, submit_size);
  __cil_tmp100 = (unsigned long )srf;
  __cil_tmp101 = __cil_tmp100 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp101)) {
    __cil_tmp102 = (void *)0;
    __cil_tmp103 = (struct drm_file *)__cil_tmp102;
    __cil_tmp104 = (void *)0;
    __cil_tmp105 = (uint32_t *)__cil_tmp104;
    vmw_execbuf_fence_commands(__cil_tmp103, dev_priv, & fence, __cil_tmp105);
    __cil_tmp106 = & fence;
    __cil_tmp107 = *__cil_tmp106;
    __cil_tmp108 = (void *)__cil_tmp107;
    ttm_eu_fence_buffer_objects(& val_list, __cil_tmp108);
    __cil_tmp109 = (void *)0;
    __cil_tmp110 = (unsigned long )__cil_tmp109;
    __cil_tmp111 = & fence;
    __cil_tmp112 = *__cil_tmp111;
    __cil_tmp113 = (unsigned long )__cil_tmp112;
    __cil_tmp114 = __cil_tmp113 != __cil_tmp110;
    __cil_tmp115 = ! __cil_tmp114;
    __cil_tmp116 = ! __cil_tmp115;
    __cil_tmp117 = (long )__cil_tmp116;
    tmp___17 = ldv__builtin_expect(__cil_tmp117, 1L);
    if (tmp___17) {
      vmw_fence_obj_unreference(& fence);
    }
    __cil_tmp118 = (unsigned long )(& val_buf) + 16UL;
    __cil_tmp119 = (struct ttm_buffer_object **)__cil_tmp118;
    ttm_bo_unref(__cil_tmp119);
    __cil_tmp120 = (unsigned long )srf;
    __cil_tmp121 = __cil_tmp120 + 184UL;
    __cil_tmp122 = (struct ttm_buffer_object **)__cil_tmp121;
    ttm_bo_unref(__cil_tmp122);
  }
  __cil_tmp123 = (unsigned long )dev_priv;
  __cil_tmp124 = __cil_tmp123 + 134784UL;
  __cil_tmp125 = (unsigned long )srf;
  __cil_tmp126 = __cil_tmp125 + 200UL;
  __cil_tmp127 = *((uint32_t *)__cil_tmp126);
  __cil_tmp128 = (unsigned long )dev_priv;
  __cil_tmp129 = __cil_tmp128 + 134784UL;
  __cil_tmp130 = *((uint32_t *)__cil_tmp129);
  *((uint32_t *)__cil_tmp124) = __cil_tmp130 + __cil_tmp127;
  return (0);
  out_no_fifo: 
  vmw_resource_release_id(res);
  out_no_id: 
  __cil_tmp131 = (unsigned long )srf;
  __cil_tmp132 = __cil_tmp131 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp132)) {
    ttm_eu_backoff_reservation(& val_list);
  }
  out_no_reserve: 
  __cil_tmp133 = (unsigned long )srf;
  __cil_tmp134 = __cil_tmp133 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp134)) {
    __cil_tmp135 = (unsigned long )(& val_buf) + 16UL;
    __cil_tmp136 = (struct ttm_buffer_object **)__cil_tmp135;
    ttm_bo_unref(__cil_tmp136);
  }
  return (ret);
}
}
int vmw_surface_evict(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ struct vmw_resource *res ;
  struct list_head val_list ;
  struct ttm_validate_buffer val_buf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  struct vmw_fence_obj *fence ;
  SVGAGuestPtr ptr ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  uint32_t tmp___15 ;
  long tmp___16 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_buffer_object *__cil_tmp30 ;
  struct ttm_bo_device *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  enum ttm_bo_type __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  bool __cil_tmp38 ;
  void *__cil_tmp39 ;
  struct file *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct ttm_buffer_object **__cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_buffer_object *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct ttm_validate_buffer *__cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct ttm_buffer_object *__cil_tmp61 ;
  bool __cil_tmp62 ;
  bool __cil_tmp63 ;
  bool __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  long __cil_tmp68 ;
  struct vmw_surface *__cil_tmp69 ;
  void *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct ttm_buffer_object *__cil_tmp79 ;
  struct ttm_buffer_object *__cil_tmp80 ;
  void *__cil_tmp81 ;
  SVGAGuestPtr *__cil_tmp82 ;
  bool __cil_tmp83 ;
  struct vmw_surface *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int __cil_tmp87 ;
  uint32_t __cil_tmp88 ;
  void *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  uint32_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  void *__cil_tmp98 ;
  struct drm_file *__cil_tmp99 ;
  void *__cil_tmp100 ;
  uint32_t *__cil_tmp101 ;
  struct vmw_fence_obj **__cil_tmp102 ;
  struct vmw_fence_obj *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  struct vmw_fence_obj **__cil_tmp107 ;
  struct vmw_fence_obj *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  struct ttm_buffer_object **__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  struct ttm_buffer_object **__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  struct ttm_buffer_object **__cil_tmp122 ;

  {
  res = (struct vmw_resource *)srf;
  while (1) {
    __cil_tmp21 = (unsigned long )res;
    __cil_tmp22 = __cil_tmp21 + 24UL;
    __cil_tmp23 = *((int *)__cil_tmp22);
    __cil_tmp24 = __cil_tmp23 == -1;
    __cil_tmp25 = ! __cil_tmp24;
    __cil_tmp26 = ! __cil_tmp25;
    __cil_tmp27 = (long )__cil_tmp26;
    tmp___7 = ldv__builtin_expect(__cil_tmp27, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (948), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp28 = (unsigned long )srf;
  __cil_tmp29 = __cil_tmp28 + 184UL;
  __cil_tmp30 = *((struct ttm_buffer_object **)__cil_tmp29);
  if (! __cil_tmp30) {
    __cil_tmp31 = (struct ttm_bo_device *)dev_priv;
    __cil_tmp32 = (unsigned long )srf;
    __cil_tmp33 = __cil_tmp32 + 200UL;
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
    __cil_tmp35 = (unsigned long )__cil_tmp34;
    __cil_tmp36 = (enum ttm_bo_type )0;
    __cil_tmp37 = (uint32_t )0;
    __cil_tmp38 = (bool )1;
    __cil_tmp39 = (void *)0;
    __cil_tmp40 = (struct file *)__cil_tmp39;
    __cil_tmp41 = (unsigned long )srf;
    __cil_tmp42 = __cil_tmp41 + 184UL;
    __cil_tmp43 = (struct ttm_buffer_object **)__cil_tmp42;
    ret = ttm_bo_create(__cil_tmp31, __cil_tmp35, __cil_tmp36, & vmw_srf_placement,
                        __cil_tmp37, 0UL, __cil_tmp38, __cil_tmp40, __cil_tmp43);
    __cil_tmp44 = ret != 0;
    __cil_tmp45 = ! __cil_tmp44;
    __cil_tmp46 = ! __cil_tmp45;
    __cil_tmp47 = (long )__cil_tmp46;
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 0L);
    if (tmp___8) {
      return (ret);
    }
  }
  INIT_LIST_HEAD(& val_list);
  __cil_tmp48 = (unsigned long )(& val_buf) + 16UL;
  __cil_tmp49 = (unsigned long )srf;
  __cil_tmp50 = __cil_tmp49 + 184UL;
  __cil_tmp51 = *((struct ttm_buffer_object **)__cil_tmp50);
  *((struct ttm_buffer_object **)__cil_tmp48) = ttm_bo_reference(__cil_tmp51);
  __cil_tmp52 = (unsigned long )(& val_buf) + 24UL;
  *((void **)__cil_tmp52) = (void *)1UL;
  __cil_tmp53 = & val_buf;
  __cil_tmp54 = (struct list_head *)__cil_tmp53;
  list_add_tail(__cil_tmp54, & val_list);
  ret = ttm_eu_reserve_buffers(& val_list);
  __cil_tmp55 = ret != 0;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 0L);
  if (tmp___9) {
    goto out_no_reserve;
  }
  __cil_tmp59 = (unsigned long )srf;
  __cil_tmp60 = __cil_tmp59 + 184UL;
  __cil_tmp61 = *((struct ttm_buffer_object **)__cil_tmp60);
  __cil_tmp62 = (bool )1;
  __cil_tmp63 = (bool )0;
  __cil_tmp64 = (bool )0;
  ret = ttm_bo_validate(__cil_tmp61, & vmw_srf_placement, __cil_tmp62, __cil_tmp63,
                        __cil_tmp64);
  __cil_tmp65 = ret != 0;
  __cil_tmp66 = ! __cil_tmp65;
  __cil_tmp67 = ! __cil_tmp66;
  __cil_tmp68 = (long )__cil_tmp67;
  tmp___10 = ldv__builtin_expect(__cil_tmp68, 0L);
  if (tmp___10) {
    goto out_no_fifo;
  }
  __cil_tmp69 = srf;
  tmp___11 = vmw_surface_dma_size(__cil_tmp69);
  tmp___12 = vmw_surface_destroy_size();
  submit_size = tmp___11 + tmp___12;
  tmp___13 = vmw_fifo_reserve(dev_priv, submit_size);
  cmd = (uint8_t *)tmp___13;
  __cil_tmp70 = (void *)0;
  __cil_tmp71 = (unsigned long )__cil_tmp70;
  __cil_tmp72 = (unsigned long )cmd;
  __cil_tmp73 = __cil_tmp72 == __cil_tmp71;
  __cil_tmp74 = ! __cil_tmp73;
  __cil_tmp75 = ! __cil_tmp74;
  __cil_tmp76 = (long )__cil_tmp75;
  tmp___14 = ldv__builtin_expect(__cil_tmp76, 0L);
  if (tmp___14) {
    drm_err("vmw_surface_evict", "Failed reserving FIFO space for surface eviction.\n");
    ret = -12;
    goto out_no_fifo;
  }
  __cil_tmp77 = (unsigned long )srf;
  __cil_tmp78 = __cil_tmp77 + 184UL;
  __cil_tmp79 = *((struct ttm_buffer_object **)__cil_tmp78);
  __cil_tmp80 = __cil_tmp79;
  vmw_bo_get_guest_ptr(__cil_tmp80, & ptr);
  __cil_tmp81 = (void *)cmd;
  __cil_tmp82 = & ptr;
  __cil_tmp83 = (bool )0;
  vmw_surface_dma_encode(srf, __cil_tmp81, __cil_tmp82, __cil_tmp83);
  __cil_tmp84 = srf;
  tmp___15 = vmw_surface_dma_size(__cil_tmp84);
  cmd += tmp___15;
  __cil_tmp85 = (unsigned long )res;
  __cil_tmp86 = __cil_tmp85 + 24UL;
  __cil_tmp87 = *((int *)__cil_tmp86);
  __cil_tmp88 = (uint32_t )__cil_tmp87;
  __cil_tmp89 = (void *)cmd;
  vmw_surface_destroy_encode(__cil_tmp88, __cil_tmp89);
  vmw_fifo_commit(dev_priv, submit_size);
  __cil_tmp90 = (unsigned long )dev_priv;
  __cil_tmp91 = __cil_tmp90 + 134784UL;
  __cil_tmp92 = (unsigned long )srf;
  __cil_tmp93 = __cil_tmp92 + 200UL;
  __cil_tmp94 = *((uint32_t *)__cil_tmp93);
  __cil_tmp95 = (unsigned long )dev_priv;
  __cil_tmp96 = __cil_tmp95 + 134784UL;
  __cil_tmp97 = *((uint32_t *)__cil_tmp96);
  *((uint32_t *)__cil_tmp91) = __cil_tmp97 - __cil_tmp94;
  __cil_tmp98 = (void *)0;
  __cil_tmp99 = (struct drm_file *)__cil_tmp98;
  __cil_tmp100 = (void *)0;
  __cil_tmp101 = (uint32_t *)__cil_tmp100;
  vmw_execbuf_fence_commands(__cil_tmp99, dev_priv, & fence, __cil_tmp101);
  __cil_tmp102 = & fence;
  __cil_tmp103 = *__cil_tmp102;
  __cil_tmp104 = (void *)__cil_tmp103;
  ttm_eu_fence_buffer_objects(& val_list, __cil_tmp104);
  __cil_tmp105 = (void *)0;
  __cil_tmp106 = (unsigned long )__cil_tmp105;
  __cil_tmp107 = & fence;
  __cil_tmp108 = *__cil_tmp107;
  __cil_tmp109 = (unsigned long )__cil_tmp108;
  __cil_tmp110 = __cil_tmp109 != __cil_tmp106;
  __cil_tmp111 = ! __cil_tmp110;
  __cil_tmp112 = ! __cil_tmp111;
  __cil_tmp113 = (long )__cil_tmp112;
  tmp___16 = ldv__builtin_expect(__cil_tmp113, 1L);
  if (tmp___16) {
    vmw_fence_obj_unreference(& fence);
  }
  __cil_tmp114 = (unsigned long )(& val_buf) + 16UL;
  __cil_tmp115 = (struct ttm_buffer_object **)__cil_tmp114;
  ttm_bo_unref(__cil_tmp115);
  vmw_resource_release_id(res);
  return (0);
  out_no_fifo: 
  __cil_tmp116 = (unsigned long )srf;
  __cil_tmp117 = __cil_tmp116 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp117)) {
    ttm_eu_backoff_reservation(& val_list);
  }
  out_no_reserve: 
  __cil_tmp118 = (unsigned long )(& val_buf) + 16UL;
  __cil_tmp119 = (struct ttm_buffer_object **)__cil_tmp118;
  ttm_bo_unref(__cil_tmp119);
  __cil_tmp120 = (unsigned long )srf;
  __cil_tmp121 = __cil_tmp120 + 184UL;
  __cil_tmp122 = (struct ttm_buffer_object **)__cil_tmp121;
  ttm_bo_unref(__cil_tmp122);
  return (ret);
}
}
int vmw_surface_validate(struct vmw_private *dev_priv , struct vmw_surface *srf ) 
{ int ret ;
  struct vmw_surface *evict_srf ;
  long tmp___7 ;
  int tmp___8 ;
  struct list_head *__mptr ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  rwlock_t *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  rwlock_t *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  rwlock_t *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  rwlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct vmw_surface **__cil_tmp36 ;
  struct vmw_surface *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  struct vmw_surface *__cil_tmp44 ;
  struct vmw_surface **__cil_tmp45 ;
  struct vmw_surface *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct list_head *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  rwlock_t *__cil_tmp52 ;
  struct vmw_surface **__cil_tmp53 ;
  struct vmw_surface *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  rwlock_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  rwlock_t *__cil_tmp71 ;

  {
  while (1) {
    __cil_tmp10 = (unsigned long )dev_priv;
    __cil_tmp11 = __cil_tmp10 + 2632UL;
    __cil_tmp12 = (rwlock_t *)__cil_tmp11;
    _raw_write_lock(__cil_tmp12);
    __cil_tmp13 = (unsigned long )srf;
    __cil_tmp14 = __cil_tmp13 + 96UL;
    __cil_tmp15 = (struct list_head *)__cil_tmp14;
    list_del_init(__cil_tmp15);
    __cil_tmp16 = (unsigned long )dev_priv;
    __cil_tmp17 = __cil_tmp16 + 2632UL;
    __cil_tmp18 = (rwlock_t *)__cil_tmp17;
    _raw_write_unlock(__cil_tmp18);
    ret = vmw_surface_do_validate(dev_priv, srf);
    __cil_tmp19 = ret != -16;
    __cil_tmp20 = ! __cil_tmp19;
    __cil_tmp21 = ! __cil_tmp20;
    __cil_tmp22 = (long )__cil_tmp21;
    tmp___7 = ldv__builtin_expect(__cil_tmp22, 1L);
    if (tmp___7) {
      goto while_break;
    }
    __cil_tmp23 = (unsigned long )dev_priv;
    __cil_tmp24 = __cil_tmp23 + 2632UL;
    __cil_tmp25 = (rwlock_t *)__cil_tmp24;
    _raw_write_lock(__cil_tmp25);
    __cil_tmp26 = (unsigned long )dev_priv;
    __cil_tmp27 = __cil_tmp26 + 134768UL;
    __cil_tmp28 = (struct list_head *)__cil_tmp27;
    __cil_tmp29 = __cil_tmp28;
    tmp___8 = list_empty(__cil_tmp29);
    if (tmp___8) {
      drm_err("vmw_surface_validate", "Out of device memory for surfaces.\n");
      ret = -16;
      __cil_tmp30 = (unsigned long )dev_priv;
      __cil_tmp31 = __cil_tmp30 + 2632UL;
      __cil_tmp32 = (rwlock_t *)__cil_tmp31;
      _raw_write_unlock(__cil_tmp32);
      goto while_break;
    }
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 134768UL;
    __cil_tmp35 = *((struct list_head **)__cil_tmp34);
    __mptr = __cil_tmp35;
    __cil_tmp36 = & evict_srf;
    __cil_tmp37 = (struct vmw_surface *)0;
    __cil_tmp38 = (unsigned long )__cil_tmp37;
    __cil_tmp39 = __cil_tmp38 + 96UL;
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
    __cil_tmp41 = (unsigned int )__cil_tmp40;
    __cil_tmp42 = (char *)__mptr;
    __cil_tmp43 = __cil_tmp42 - __cil_tmp41;
    __cil_tmp44 = (struct vmw_surface *)__cil_tmp43;
    *__cil_tmp36 = vmw_surface_reference(__cil_tmp44);
    __cil_tmp45 = & evict_srf;
    __cil_tmp46 = *__cil_tmp45;
    __cil_tmp47 = (unsigned long )__cil_tmp46;
    __cil_tmp48 = __cil_tmp47 + 96UL;
    __cil_tmp49 = (struct list_head *)__cil_tmp48;
    list_del_init(__cil_tmp49);
    __cil_tmp50 = (unsigned long )dev_priv;
    __cil_tmp51 = __cil_tmp50 + 2632UL;
    __cil_tmp52 = (rwlock_t *)__cil_tmp51;
    _raw_write_unlock(__cil_tmp52);
    __cil_tmp53 = & evict_srf;
    __cil_tmp54 = *__cil_tmp53;
    vmw_surface_evict(dev_priv, __cil_tmp54);
    vmw_surface_unreference(& evict_srf);
  }
  while_break: ;
  if (ret != 0) {
    __cil_tmp55 = 24;
    __cil_tmp56 = (unsigned long )srf;
    __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
    __cil_tmp58 = *((int *)__cil_tmp57);
    if (__cil_tmp58 != -1) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  __cil_tmp59 = (long )tmp___9;
  tmp___10 = ldv__builtin_expect(__cil_tmp59, 0L);
  if (tmp___10) {
    __cil_tmp60 = (unsigned long )dev_priv;
    __cil_tmp61 = __cil_tmp60 + 2632UL;
    __cil_tmp62 = (rwlock_t *)__cil_tmp61;
    _raw_write_lock(__cil_tmp62);
    __cil_tmp63 = (unsigned long )srf;
    __cil_tmp64 = __cil_tmp63 + 96UL;
    __cil_tmp65 = (struct list_head *)__cil_tmp64;
    __cil_tmp66 = (unsigned long )dev_priv;
    __cil_tmp67 = __cil_tmp66 + 134768UL;
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
    list_add_tail(__cil_tmp65, __cil_tmp68);
    __cil_tmp69 = (unsigned long )dev_priv;
    __cil_tmp70 = __cil_tmp69 + 2632UL;
    __cil_tmp71 = (rwlock_t *)__cil_tmp70;
    _raw_write_unlock(__cil_tmp71);
  }
  return (ret);
}
}
static void vmw_surface_remove_from_lists(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource *__mptr ;
  struct vmw_surface *__cil_tmp4 ;
  struct vmw_resource *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct list_head *__cil_tmp11 ;

  {
  __mptr = res;
  __cil_tmp4 = (struct vmw_surface *)0;
  __cil_tmp5 = (struct vmw_resource *)__cil_tmp4;
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = (char *)__mptr;
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
  srf = (struct vmw_surface *)__cil_tmp8;
  __cil_tmp9 = (unsigned long )srf;
  __cil_tmp10 = __cil_tmp9 + 96UL;
  __cil_tmp11 = (struct list_head *)__cil_tmp10;
  list_del_init(__cil_tmp11);
  return;
}
}
int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf , void (*res_free)(struct vmw_resource *res ) ) 
{ int ret ;
  struct vmw_resource *res ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct idr *__cil_tmp20 ;
  enum ttm_object_type __cil_tmp21 ;
  bool __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  bool __cil_tmp27 ;

  {
  res = (struct vmw_resource *)srf;
  while (1) {
    __cil_tmp8 = (void *)0;
    __cil_tmp9 = (unsigned long )__cil_tmp8;
    __cil_tmp10 = (unsigned long )res_free;
    __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
    __cil_tmp12 = ! __cil_tmp11;
    __cil_tmp13 = ! __cil_tmp12;
    __cil_tmp14 = (long )__cil_tmp13;
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1118), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp15 = (unsigned long )srf;
  __cil_tmp16 = __cil_tmp15 + 96UL;
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
  INIT_LIST_HEAD(__cil_tmp17);
  __cil_tmp18 = (unsigned long )dev_priv;
  __cil_tmp19 = __cil_tmp18 + 2704UL;
  __cil_tmp20 = (struct idr *)__cil_tmp19;
  __cil_tmp21 = (enum ttm_object_type )257;
  __cil_tmp22 = (bool )1;
  ret = vmw_resource_init(dev_priv, res, __cil_tmp20, __cil_tmp21, __cil_tmp22, res_free,
                          & vmw_surface_remove_from_lists);
  __cil_tmp23 = ret != 0;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  tmp___8 = ldv__builtin_expect(__cil_tmp26, 0L);
  if (tmp___8) {
    (*res_free)(res);
  }
  __cil_tmp27 = (bool )0;
  vmw_3d_resource_inc(dev_priv, __cil_tmp27);
  vmw_resource_activate(res, & vmw_hw_surface_destroy);
  return (ret);
}
}
static void vmw_user_surface_free(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_resource *__mptr ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *__mptr___0 ;
  struct vmw_private *dev_priv ;
  uint32_t size ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_surface *__cil_tmp9 ;
  struct vmw_resource *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct vmw_user_surface *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_surface *__cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_buffer_object **__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_surface_offset *__cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct drm_vmw_size *__cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  uint32_t *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  uint64_t __cil_tmp45 ;

  {
  __mptr = res;
  __cil_tmp9 = (struct vmw_surface *)0;
  __cil_tmp10 = (struct vmw_resource *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  srf = (struct vmw_surface *)__cil_tmp13;
  __mptr___0 = srf;
  __cil_tmp14 = (struct vmw_user_surface *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = __cil_tmp15 + 64UL;
  __cil_tmp17 = (struct vmw_surface *)__cil_tmp16;
  __cil_tmp18 = (unsigned int )__cil_tmp17;
  __cil_tmp19 = (char *)__mptr___0;
  __cil_tmp20 = __cil_tmp19 - __cil_tmp18;
  user_srf = (struct vmw_user_surface *)__cil_tmp20;
  __cil_tmp21 = 8;
  __cil_tmp22 = (unsigned long )srf;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  dev_priv = *((struct vmw_private **)__cil_tmp23);
  __cil_tmp24 = (unsigned long )user_srf;
  __cil_tmp25 = __cil_tmp24 + 272UL;
  size = *((uint32_t *)__cil_tmp25);
  __cil_tmp26 = (unsigned long )srf;
  __cil_tmp27 = __cil_tmp26 + 184UL;
  if (*((struct ttm_buffer_object **)__cil_tmp27)) {
    __cil_tmp28 = (unsigned long )srf;
    __cil_tmp29 = __cil_tmp28 + 184UL;
    __cil_tmp30 = (struct ttm_buffer_object **)__cil_tmp29;
    ttm_bo_unref(__cil_tmp30);
  }
  __cil_tmp31 = (unsigned long )srf;
  __cil_tmp32 = __cil_tmp31 + 192UL;
  __cil_tmp33 = *((struct vmw_surface_offset **)__cil_tmp32);
  __cil_tmp34 = (void *)__cil_tmp33;
  kfree(__cil_tmp34);
  __cil_tmp35 = (unsigned long )srf;
  __cil_tmp36 = __cil_tmp35 + 144UL;
  __cil_tmp37 = *((struct drm_vmw_size **)__cil_tmp36);
  __cil_tmp38 = (void *)__cil_tmp37;
  kfree(__cil_tmp38);
  __cil_tmp39 = 176;
  __cil_tmp40 = (unsigned long )srf;
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
  __cil_tmp42 = *((uint32_t **)__cil_tmp41);
  __cil_tmp43 = (void *)__cil_tmp42;
  kfree(__cil_tmp43);
  __cil_tmp44 = (void *)user_srf;
  kfree(__cil_tmp44);
  tmp___7 = vmw_mem_glob(dev_priv);
  __cil_tmp45 = (uint64_t )size;
  ttm_mem_global_free(tmp___7, __cil_tmp45);
  return;
}
}
void vmw_resource_unreserve(struct list_head *list ) 
{ struct vmw_resource *res ;
  struct vmw_surface *srf ;
  rwlock_t *lock ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  long tmp___7 ;
  struct vmw_resource *__mptr___1 ;
  void *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void (*__cil_tmp26)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  void (*__cil_tmp31)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_private *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct vmw_surface *__cil_tmp45 ;
  struct vmw_resource *__cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct vmw_private *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct list_head *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  struct vmw_resource *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  void *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;

  {
  __cil_tmp9 = (void *)0;
  lock = (rwlock_t *)__cil_tmp9;
  __cil_tmp10 = *((struct list_head **)list);
  __mptr = __cil_tmp10;
  __cil_tmp11 = (struct vmw_resource *)0;
  __cil_tmp12 = (unsigned long )__cil_tmp11;
  __cil_tmp13 = __cil_tmp12 + 64UL;
  __cil_tmp14 = (struct list_head *)__cil_tmp13;
  __cil_tmp15 = (unsigned int )__cil_tmp14;
  __cil_tmp16 = (char *)__mptr;
  __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
  res = (struct vmw_resource *)__cil_tmp17;
  while (1) {
    __cil_tmp18 = (unsigned long )list;
    __cil_tmp19 = (unsigned long )res;
    __cil_tmp20 = __cil_tmp19 + 64UL;
    __cil_tmp21 = (struct list_head *)__cil_tmp20;
    __cil_tmp22 = (unsigned long )__cil_tmp21;
    if (! (__cil_tmp22 != __cil_tmp18)) {
      goto while_break;
    }
    __cil_tmp23 = (unsigned long )(& vmw_surface_res_free);
    __cil_tmp24 = (unsigned long )res;
    __cil_tmp25 = __cil_tmp24 + 56UL;
    __cil_tmp26 = *((void (**)(struct vmw_resource *res ))__cil_tmp25);
    __cil_tmp27 = (unsigned long )__cil_tmp26;
    if (__cil_tmp27 != __cil_tmp23) {
      __cil_tmp28 = (unsigned long )(& vmw_user_surface_free);
      __cil_tmp29 = (unsigned long )res;
      __cil_tmp30 = __cil_tmp29 + 56UL;
      __cil_tmp31 = *((void (**)(struct vmw_resource *res ))__cil_tmp30);
      __cil_tmp32 = (unsigned long )__cil_tmp31;
      if (__cil_tmp32 != __cil_tmp28) {
        goto __Cont;
      }
    }
    __cil_tmp33 = (void *)0;
    __cil_tmp34 = (unsigned long )__cil_tmp33;
    __cil_tmp35 = (unsigned long )lock;
    __cil_tmp36 = __cil_tmp35 == __cil_tmp34;
    __cil_tmp37 = ! __cil_tmp36;
    __cil_tmp38 = ! __cil_tmp37;
    __cil_tmp39 = (long )__cil_tmp38;
    tmp___7 = ldv__builtin_expect(__cil_tmp39, 0L);
    if (tmp___7) {
      __cil_tmp40 = (unsigned long )res;
      __cil_tmp41 = __cil_tmp40 + 8UL;
      __cil_tmp42 = *((struct vmw_private **)__cil_tmp41);
      __cil_tmp43 = (unsigned long )__cil_tmp42;
      __cil_tmp44 = __cil_tmp43 + 2632UL;
      lock = (rwlock_t *)__cil_tmp44;
      _raw_write_lock(lock);
    }
    __mptr___1 = res;
    __cil_tmp45 = (struct vmw_surface *)0;
    __cil_tmp46 = (struct vmw_resource *)__cil_tmp45;
    __cil_tmp47 = (unsigned int )__cil_tmp46;
    __cil_tmp48 = (char *)__mptr___1;
    __cil_tmp49 = __cil_tmp48 - __cil_tmp47;
    srf = (struct vmw_surface *)__cil_tmp49;
    __cil_tmp50 = (unsigned long )srf;
    __cil_tmp51 = __cil_tmp50 + 96UL;
    __cil_tmp52 = (struct list_head *)__cil_tmp51;
    list_del_init(__cil_tmp52);
    __cil_tmp53 = (unsigned long )srf;
    __cil_tmp54 = __cil_tmp53 + 96UL;
    __cil_tmp55 = (struct list_head *)__cil_tmp54;
    __cil_tmp56 = (unsigned long )res;
    __cil_tmp57 = __cil_tmp56 + 8UL;
    __cil_tmp58 = *((struct vmw_private **)__cil_tmp57);
    __cil_tmp59 = (unsigned long )__cil_tmp58;
    __cil_tmp60 = __cil_tmp59 + 134768UL;
    __cil_tmp61 = (struct list_head *)__cil_tmp60;
    list_add_tail(__cil_tmp55, __cil_tmp61);
    __Cont: 
    __cil_tmp62 = (unsigned long )res;
    __cil_tmp63 = __cil_tmp62 + 64UL;
    __cil_tmp64 = *((struct list_head **)__cil_tmp63);
    __mptr___0 = __cil_tmp64;
    __cil_tmp65 = (struct vmw_resource *)0;
    __cil_tmp66 = (unsigned long )__cil_tmp65;
    __cil_tmp67 = __cil_tmp66 + 64UL;
    __cil_tmp68 = (struct list_head *)__cil_tmp67;
    __cil_tmp69 = (unsigned int )__cil_tmp68;
    __cil_tmp70 = (char *)__mptr___0;
    __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
    res = (struct vmw_resource *)__cil_tmp71;
  }
  while_break: 
  __cil_tmp72 = (void *)0;
  __cil_tmp73 = (unsigned long )__cil_tmp72;
  __cil_tmp74 = (unsigned long )lock;
  if (__cil_tmp74 != __cil_tmp73) {
    _raw_write_unlock(lock);
  }
  return;
}
}
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) 
{ int ret ;
  int tmp___7 ;
  long tmp___8 ;
  long __cil_tmp9 ;

  {
  while (1) {

    if (*out_surf) {
      tmp___7 = 1;
    } else
    if (*out_buf) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
    __cil_tmp9 = (long )tmp___7;
    tmp___8 = ldv__builtin_expect(__cil_tmp9, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1206), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  ret = vmw_user_surface_lookup_handle(dev_priv, tfile, handle, out_surf);
  if (! ret) {
    return (0);
  }
  ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);
  return (ret);
}
}
int vmw_user_surface_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                   uint32_t handle , struct vmw_surface **out ) 
{ struct vmw_resource *res ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object *__mptr ;
  struct ttm_base_object **__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_base_object **__cil_tmp16 ;
  struct ttm_base_object *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  struct ttm_base_object **__cil_tmp23 ;
  struct ttm_base_object *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  enum ttm_object_type __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  struct ttm_base_object **__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  struct vmw_user_surface *__cil_tmp35 ;
  struct ttm_base_object *__cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  rwlock_t *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  rwlock_t *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void (*__cil_tmp54)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  rwlock_t *__cil_tmp58 ;
  struct kref *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  rwlock_t *__cil_tmp62 ;

  {
  ret = -22;
  __cil_tmp13 = & base;
  *__cil_tmp13 = ttm_base_object_lookup(tfile, handle);
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = & base;
  __cil_tmp17 = *__cil_tmp16;
  __cil_tmp18 = (unsigned long )__cil_tmp17;
  __cil_tmp19 = __cil_tmp18 == __cil_tmp15;
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    return (-22);
  }
  __cil_tmp23 = & base;
  __cil_tmp24 = *__cil_tmp23;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = __cil_tmp25 + 24UL;
  __cil_tmp27 = *((enum ttm_object_type *)__cil_tmp26);
  __cil_tmp28 = (unsigned int )__cil_tmp27;
  __cil_tmp29 = __cil_tmp28 != 257U;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = (long )__cil_tmp31;
  tmp___8 = ldv__builtin_expect(__cil_tmp32, 0L);
  if (tmp___8) {
    goto out_bad_resource;
  }
  __cil_tmp33 = & base;
  __cil_tmp34 = *__cil_tmp33;
  __mptr = __cil_tmp34;
  __cil_tmp35 = (struct vmw_user_surface *)0;
  __cil_tmp36 = (struct ttm_base_object *)__cil_tmp35;
  __cil_tmp37 = (unsigned int )__cil_tmp36;
  __cil_tmp38 = (char *)__mptr;
  __cil_tmp39 = __cil_tmp38 - __cil_tmp37;
  user_srf = (struct vmw_user_surface *)__cil_tmp39;
  __cil_tmp40 = (unsigned long )user_srf;
  __cil_tmp41 = __cil_tmp40 + 64UL;
  srf = (struct vmw_surface *)__cil_tmp41;
  res = (struct vmw_resource *)srf;
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 2632UL;
  __cil_tmp44 = (rwlock_t *)__cil_tmp43;
  _raw_read_lock(__cil_tmp44);
  __cil_tmp45 = (unsigned long )res;
  __cil_tmp46 = __cil_tmp45 + 32UL;
  __cil_tmp47 = *((bool *)__cil_tmp46);
  if (! __cil_tmp47) {
    __cil_tmp48 = (unsigned long )dev_priv;
    __cil_tmp49 = __cil_tmp48 + 2632UL;
    __cil_tmp50 = (rwlock_t *)__cil_tmp49;
    _raw_read_unlock(__cil_tmp50);
    goto out_bad_resource;
  } else {
    __cil_tmp51 = (unsigned long )(& vmw_user_surface_free);
    __cil_tmp52 = (unsigned long )res;
    __cil_tmp53 = __cil_tmp52 + 56UL;
    __cil_tmp54 = *((void (**)(struct vmw_resource *res ))__cil_tmp53);
    __cil_tmp55 = (unsigned long )__cil_tmp54;
    if (__cil_tmp55 != __cil_tmp51) {
      __cil_tmp56 = (unsigned long )dev_priv;
      __cil_tmp57 = __cil_tmp56 + 2632UL;
      __cil_tmp58 = (rwlock_t *)__cil_tmp57;
      _raw_read_unlock(__cil_tmp58);
      goto out_bad_resource;
    }
  }
  __cil_tmp59 = (struct kref *)res;
  kref_get(__cil_tmp59);
  __cil_tmp60 = (unsigned long )dev_priv;
  __cil_tmp61 = __cil_tmp60 + 2632UL;
  __cil_tmp62 = (rwlock_t *)__cil_tmp61;
  _raw_read_unlock(__cil_tmp62);
  *out = srf;
  ret = 0;
  out_bad_resource: 
  ttm_base_object_unref(& base);
  return (ret);
}
}
static void vmw_user_surface_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_surface *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  base = *p_base;
  __mptr = base;
  __cil_tmp6 = (struct vmw_user_surface *)0;
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  user_srf = (struct vmw_user_surface *)__cil_tmp10;
  __cil_tmp11 = & res;
  __cil_tmp12 = (unsigned long )user_srf;
  __cil_tmp13 = __cil_tmp12 + 64UL;
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
  __cil_tmp14 = (void *)0;
  *p_base = (struct ttm_base_object *)__cil_tmp14;
  vmw_resource_unreference(& res);
  return;
}
}
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_surface_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  arg = (struct drm_vmw_surface_arg *)data;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp8 = (unsigned long )tmp___7;
  __cil_tmp9 = __cil_tmp8 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp9);
  __cil_tmp10 = *((int32_t *)arg);
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = (enum ttm_ref_type )0;
  tmp___8 = ttm_ref_object_base_unref(tfile, __cil_tmp11, __cil_tmp12);
  return (tmp___8);
}
}
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *srf ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  union drm_vmw_surface_create_arg *arg ;
  struct drm_vmw_surface_create_req *req ;
  struct drm_vmw_surface_arg *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct drm_vmw_size *user_sizes ;
  int ret ;
  int i ;
  int j ;
  uint32_t cur_bo_offset ;
  struct drm_vmw_size *cur_size ;
  struct vmw_surface_offset *cur_offset ;
  uint32_t stride_bpp ;
  uint32_t bpp ;
  uint32_t num_sizes ;
  uint32_t size ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  long tmp___15 ;
  struct ttm_mem_global *tmp___16 ;
  long tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  size_t __len ;
  void *__ret ;
  void *tmp___20 ;
  long tmp___21 ;
  void *tmp___22 ;
  long tmp___23 ;
  unsigned long tmp___24 ;
  long tmp___25 ;
  uint32_t stride ;
  void *tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;
  struct ttm_mem_global *tmp___29 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_master *__cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  size_t __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  uint32_t __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint64_t __cil_tmp69 ;
  uint64_t __cil_tmp70 ;
  uint64_t __cil_tmp71 ;
  uint64_t __cil_tmp72 ;
  uint64_t __cil_tmp73 ;
  struct ttm_lock *__cil_tmp74 ;
  bool __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  long __cil_tmp79 ;
  uint64_t __cil_tmp80 ;
  bool __cil_tmp81 ;
  bool __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  long __cil_tmp86 ;
  void *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  struct vmw_resource **__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  int32_t __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  void *__cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  uint32_t *__cil_tmp115 ;
  void *__cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  uint32_t *__cil_tmp121 ;
  void *__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  uint32_t *__cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  uint32_t *__cil_tmp133 ;
  void *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  void *__cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  struct drm_vmw_size *__cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  int __cil_tmp154 ;
  long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  void *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  struct drm_vmw_size *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  int __cil_tmp169 ;
  int __cil_tmp170 ;
  int __cil_tmp171 ;
  long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  uint64_t __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  struct drm_vmw_size *__cil_tmp179 ;
  void *__cil_tmp180 ;
  void *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  int __cil_tmp187 ;
  int __cil_tmp188 ;
  int __cil_tmp189 ;
  long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  uint32_t __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  uint8_t __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  uint32_t __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  uint8_t __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  uint32_t __cil_tmp212 ;
  uint32_t __cil_tmp213 ;
  uint32_t __cil_tmp214 ;
  uint32_t __cil_tmp215 ;
  uint32_t __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  uint32_t __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  uint32_t __cil_tmp226 ;
  uint32_t __cil_tmp227 ;
  uint32_t __cil_tmp228 ;
  uint32_t __cil_tmp229 ;
  uint32_t __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  uint32_t __cil_tmp237 ;
  unsigned long __cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  struct drm_vmw_size *__cil_tmp240 ;
  struct drm_vmw_size *__cil_tmp241 ;
  uint32_t __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  struct drm_vmw_size *__cil_tmp245 ;
  struct drm_vmw_size *__cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  uint32_t __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  uint32_t __cil_tmp252 ;
  size_t __cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  uint32_t *__cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  void *__cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  void *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  void *__cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  unsigned long __cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  void *__cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  unsigned long __cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  void *__cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  void *__cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  void *__cil_tmp290 ;
  int __cil_tmp291 ;
  int __cil_tmp292 ;
  int __cil_tmp293 ;
  long __cil_tmp294 ;
  struct vmw_resource **__cil_tmp295 ;
  struct vmw_resource *__cil_tmp296 ;
  struct ttm_base_object *__cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  unsigned long __cil_tmp299 ;
  int32_t __cil_tmp300 ;
  bool __cil_tmp301 ;
  enum ttm_object_type __cil_tmp302 ;
  void *__cil_tmp303 ;
  void (*__cil_tmp304)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp305 ;
  int __cil_tmp306 ;
  int __cil_tmp307 ;
  long __cil_tmp308 ;
  unsigned long __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  int32_t __cil_tmp314 ;
  uint32 __cil_tmp315 ;
  struct ttm_lock *__cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  unsigned long __cil_tmp318 ;
  struct vmw_surface_offset *__cil_tmp319 ;
  void *__cil_tmp320 ;
  unsigned long __cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  struct drm_vmw_size *__cil_tmp323 ;
  void *__cil_tmp324 ;
  void *__cil_tmp325 ;
  uint64_t __cil_tmp326 ;
  struct ttm_lock *__cil_tmp327 ;
  unsigned long tmp ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (union drm_vmw_surface_create_arg *)data;
  req = (struct drm_vmw_surface_create_req *)arg;
  rep = (struct drm_vmw_surface_arg *)arg;
  tmp___9 = vmw_fpriv(file_priv);
  __cil_tmp50 = (unsigned long )tmp___9;
  __cil_tmp51 = __cil_tmp50 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp51);
  __cil_tmp52 = (unsigned long )file_priv;
  __cil_tmp53 = __cil_tmp52 + 152UL;
  __cil_tmp54 = *((struct drm_master **)__cil_tmp53);
  tmp___10 = vmw_master(__cil_tmp54);
  vmaster = tmp___10;
  __cil_tmp55 = vmw_user_surface_size == 0ULL;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___12 = ldv__builtin_expect(__cil_tmp58, 0L);
  if (tmp___12) {
    tmp___11 = ttm_round_pot(280UL);
    __cil_tmp59 = tmp___11 + 128UL;
    vmw_user_surface_size = (uint64_t )__cil_tmp59;
  }
  num_sizes = (uint32_t )0;
  i = 0;
  while (1) {

    if (! (i < 6)) {
      goto while_break;
    }
    __cil_tmp60 = (unsigned long )i * 4UL;
    __cil_tmp61 = 8UL + __cil_tmp60;
    __cil_tmp62 = (unsigned long )req;
    __cil_tmp63 = __cil_tmp62 + __cil_tmp61;
    __cil_tmp64 = *((uint32_t *)__cil_tmp63);
    num_sizes += __cil_tmp64;
    i ++;
  }
  while_break: ;
  if (num_sizes > 144U) {
    return (-22);
  }
  __cil_tmp65 = (unsigned long )num_sizes;
  __cil_tmp66 = __cil_tmp65 * 16UL;
  tmp___13 = ttm_round_pot(__cil_tmp66);
  __cil_tmp67 = (unsigned long )num_sizes;
  __cil_tmp68 = __cil_tmp67 * 12UL;
  tmp___14 = ttm_round_pot(__cil_tmp68);
  __cil_tmp69 = (uint64_t )tmp___14;
  __cil_tmp70 = (uint64_t )tmp___13;
  __cil_tmp71 = vmw_user_surface_size + 128ULL;
  __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
  __cil_tmp73 = __cil_tmp72 + __cil_tmp69;
  size = (uint32_t )__cil_tmp73;
  __cil_tmp74 = (struct ttm_lock *)vmaster;
  __cil_tmp75 = (bool )1;
  ret = ttm_read_lock(__cil_tmp74, __cil_tmp75);
  __cil_tmp76 = ret != 0;
  __cil_tmp77 = ! __cil_tmp76;
  __cil_tmp78 = ! __cil_tmp77;
  __cil_tmp79 = (long )__cil_tmp78;
  tmp___15 = ldv__builtin_expect(__cil_tmp79, 0L);
  if (tmp___15) {
    return (ret);
  }
  tmp___16 = vmw_mem_glob(dev_priv);
  __cil_tmp80 = (uint64_t )size;
  __cil_tmp81 = (bool )0;
  __cil_tmp82 = (bool )1;
  ret = ttm_mem_global_alloc(tmp___16, __cil_tmp80, __cil_tmp81, __cil_tmp82);
  __cil_tmp83 = ret != 0;
  __cil_tmp84 = ! __cil_tmp83;
  __cil_tmp85 = ! __cil_tmp84;
  __cil_tmp86 = (long )__cil_tmp85;
  tmp___17 = ldv__builtin_expect(__cil_tmp86, 0L);
  if (tmp___17) {
    if (ret != -512) {
      drm_err("vmw_surface_define_ioctl", "Out of graphics memory for surface creation.\n");
    }
    goto out_unlock;
  }
  tmp___18 = kmalloc(280UL, 208U);
  user_srf = (struct vmw_user_surface *)tmp___18;
  __cil_tmp87 = (void *)0;
  __cil_tmp88 = (unsigned long )__cil_tmp87;
  __cil_tmp89 = (unsigned long )user_srf;
  __cil_tmp90 = __cil_tmp89 == __cil_tmp88;
  __cil_tmp91 = ! __cil_tmp90;
  __cil_tmp92 = ! __cil_tmp91;
  __cil_tmp93 = (long )__cil_tmp92;
  tmp___19 = ldv__builtin_expect(__cil_tmp93, 0L);
  if (tmp___19) {
    ret = -12;
    goto out_no_user_srf;
  }
  __cil_tmp94 = (unsigned long )user_srf;
  __cil_tmp95 = __cil_tmp94 + 64UL;
  srf = (struct vmw_surface *)__cil_tmp95;
  __cil_tmp96 = & res;
  *__cil_tmp96 = (struct vmw_resource *)srf;
  __cil_tmp97 = (unsigned long )srf;
  __cil_tmp98 = __cil_tmp97 + 112UL;
  *((uint32_t *)__cil_tmp98) = *((uint32_t *)req);
  __cil_tmp99 = (unsigned long )srf;
  __cil_tmp100 = __cil_tmp99 + 116UL;
  __cil_tmp101 = (unsigned long )req;
  __cil_tmp102 = __cil_tmp101 + 4UL;
  *((uint32_t *)__cil_tmp100) = *((uint32_t *)__cil_tmp102);
  __cil_tmp103 = (unsigned long )srf;
  __cil_tmp104 = __cil_tmp103 + 156UL;
  __cil_tmp105 = (unsigned long )req;
  __cil_tmp106 = __cil_tmp105 + 44UL;
  __cil_tmp107 = *((int32_t *)__cil_tmp106);
  *((bool *)__cil_tmp104) = (bool )__cil_tmp107;
  __cil_tmp108 = (unsigned long )srf;
  __cil_tmp109 = __cil_tmp108 + 184UL;
  __cil_tmp110 = (void *)0;
  *((struct ttm_buffer_object **)__cil_tmp109) = (struct ttm_buffer_object *)__cil_tmp110;
  __len = 24UL;
  if (__len >= 64UL) {
    __cil_tmp111 = 0UL;
    __cil_tmp112 = 120UL + __cil_tmp111;
    __cil_tmp113 = (unsigned long )srf;
    __cil_tmp114 = __cil_tmp113 + __cil_tmp112;
    __cil_tmp115 = (uint32_t *)__cil_tmp114;
    __cil_tmp116 = (void *)__cil_tmp115;
    __cil_tmp117 = 0UL;
    __cil_tmp118 = 8UL + __cil_tmp117;
    __cil_tmp119 = (unsigned long )req;
    __cil_tmp120 = __cil_tmp119 + __cil_tmp118;
    __cil_tmp121 = (uint32_t *)__cil_tmp120;
    __cil_tmp122 = (void *)__cil_tmp121;
    __ret = __memcpy(__cil_tmp116, __cil_tmp122, __len);
  } else {
    __cil_tmp123 = 0UL;
    __cil_tmp124 = 120UL + __cil_tmp123;
    __cil_tmp125 = (unsigned long )srf;
    __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
    __cil_tmp127 = (uint32_t *)__cil_tmp126;
    __cil_tmp128 = (void *)__cil_tmp127;
    __cil_tmp129 = 0UL;
    __cil_tmp130 = 8UL + __cil_tmp129;
    __cil_tmp131 = (unsigned long )req;
    __cil_tmp132 = __cil_tmp131 + __cil_tmp130;
    __cil_tmp133 = (uint32_t *)__cil_tmp132;
    __cil_tmp134 = (void *)__cil_tmp133;
    __ret = __builtin_memcpy(__cil_tmp128, __cil_tmp134, __len);
  }
  __cil_tmp135 = (unsigned long )srf;
  __cil_tmp136 = __cil_tmp135 + 152UL;
  *((uint32_t *)__cil_tmp136) = num_sizes;
  __cil_tmp137 = (unsigned long )user_srf;
  __cil_tmp138 = __cil_tmp137 + 272UL;
  *((uint32_t *)__cil_tmp138) = size;
  __cil_tmp139 = (unsigned long )srf;
  __cil_tmp140 = __cil_tmp139 + 152UL;
  __cil_tmp141 = *((uint32_t *)__cil_tmp140);
  __cil_tmp142 = (unsigned long )__cil_tmp141;
  __cil_tmp143 = __cil_tmp142 * 16UL;
  tmp___20 = kmalloc(__cil_tmp143, 208U);
  __cil_tmp144 = (unsigned long )srf;
  __cil_tmp145 = __cil_tmp144 + 144UL;
  *((struct drm_vmw_size **)__cil_tmp145) = (struct drm_vmw_size *)tmp___20;
  __cil_tmp146 = (void *)0;
  __cil_tmp147 = (unsigned long )__cil_tmp146;
  __cil_tmp148 = (unsigned long )srf;
  __cil_tmp149 = __cil_tmp148 + 144UL;
  __cil_tmp150 = *((struct drm_vmw_size **)__cil_tmp149);
  __cil_tmp151 = (unsigned long )__cil_tmp150;
  __cil_tmp152 = __cil_tmp151 == __cil_tmp147;
  __cil_tmp153 = ! __cil_tmp152;
  __cil_tmp154 = ! __cil_tmp153;
  __cil_tmp155 = (long )__cil_tmp154;
  tmp___21 = ldv__builtin_expect(__cil_tmp155, 0L);
  if (tmp___21) {
    ret = -12;
    goto out_no_sizes;
  }
  __cil_tmp156 = (unsigned long )srf;
  __cil_tmp157 = __cil_tmp156 + 152UL;
  __cil_tmp158 = *((uint32_t *)__cil_tmp157);
  __cil_tmp159 = (unsigned long )__cil_tmp158;
  __cil_tmp160 = __cil_tmp159 * 12UL;
  tmp___22 = kmalloc(__cil_tmp160, 208U);
  __cil_tmp161 = (unsigned long )srf;
  __cil_tmp162 = __cil_tmp161 + 192UL;
  *((struct vmw_surface_offset **)__cil_tmp162) = (struct vmw_surface_offset *)tmp___22;
  __cil_tmp163 = (void *)0;
  __cil_tmp164 = (unsigned long )__cil_tmp163;
  __cil_tmp165 = (unsigned long )srf;
  __cil_tmp166 = __cil_tmp165 + 144UL;
  __cil_tmp167 = *((struct drm_vmw_size **)__cil_tmp166);
  __cil_tmp168 = (unsigned long )__cil_tmp167;
  __cil_tmp169 = __cil_tmp168 == __cil_tmp164;
  __cil_tmp170 = ! __cil_tmp169;
  __cil_tmp171 = ! __cil_tmp170;
  __cil_tmp172 = (long )__cil_tmp171;
  tmp___23 = ldv__builtin_expect(__cil_tmp172, 0L);
  if (tmp___23) {
    ret = -12;
    goto out_no_offsets;
  }
  __cil_tmp173 = (unsigned long )req;
  __cil_tmp174 = __cil_tmp173 + 32UL;
  __cil_tmp175 = *((uint64_t *)__cil_tmp174);
  __cil_tmp176 = (unsigned long )__cil_tmp175;
  user_sizes = (struct drm_vmw_size *)__cil_tmp176;
  __cil_tmp177 = (unsigned long )srf;
  __cil_tmp178 = __cil_tmp177 + 144UL;
  __cil_tmp179 = *((struct drm_vmw_size **)__cil_tmp178);
  __cil_tmp180 = (void *)__cil_tmp179;
  __cil_tmp181 = (void *)user_sizes;
  __cil_tmp182 = (unsigned long )srf;
  __cil_tmp183 = __cil_tmp182 + 152UL;
  __cil_tmp184 = *((uint32_t *)__cil_tmp183);
  __cil_tmp185 = (unsigned long )__cil_tmp184;
  __cil_tmp186 = __cil_tmp185 * 16UL;
  tmp = (unsigned long )copy_from_user(__cil_tmp180, __cil_tmp181, __cil_tmp186);
  tmp___24 = tmp;
  ret = (int )tmp___24;
  __cil_tmp187 = ret != 0;
  __cil_tmp188 = ! __cil_tmp187;
  __cil_tmp189 = ! __cil_tmp188;
  __cil_tmp190 = (long )__cil_tmp189;
  tmp___25 = ldv__builtin_expect(__cil_tmp190, 0L);
  if (tmp___25) {
    ret = -14;
    goto out_no_copy;
  }
  cur_bo_offset = (uint32_t )0;
  __cil_tmp191 = (unsigned long )srf;
  __cil_tmp192 = __cil_tmp191 + 192UL;
  cur_offset = *((struct vmw_surface_offset **)__cil_tmp192);
  __cil_tmp193 = (unsigned long )srf;
  __cil_tmp194 = __cil_tmp193 + 144UL;
  cur_size = *((struct drm_vmw_size **)__cil_tmp194);
  __cil_tmp195 = (unsigned long )srf;
  __cil_tmp196 = __cil_tmp195 + 116UL;
  __cil_tmp197 = *((uint32_t *)__cil_tmp196);
  __cil_tmp198 = (unsigned long )__cil_tmp197 * 2UL;
  __cil_tmp199 = (unsigned long )(vmw_sf_bpp) + __cil_tmp198;
  __cil_tmp200 = *((uint8_t *)__cil_tmp199);
  bpp = (uint32_t )__cil_tmp200;
  __cil_tmp201 = (unsigned long )srf;
  __cil_tmp202 = __cil_tmp201 + 116UL;
  __cil_tmp203 = *((uint32_t *)__cil_tmp202);
  __cil_tmp204 = (unsigned long )__cil_tmp203 * 2UL;
  __cil_tmp205 = __cil_tmp204 + 1UL;
  __cil_tmp206 = (unsigned long )(vmw_sf_bpp) + __cil_tmp205;
  __cil_tmp207 = *((uint8_t *)__cil_tmp206);
  stride_bpp = (uint32_t )__cil_tmp207;
  i = 0;
  while (1) {

    if (! (i < 6)) {
      goto while_break___0;
    }
    j = 0;
    while (1) {
      __cil_tmp208 = (unsigned long )i * 4UL;
      __cil_tmp209 = 120UL + __cil_tmp208;
      __cil_tmp210 = (unsigned long )srf;
      __cil_tmp211 = __cil_tmp210 + __cil_tmp209;
      __cil_tmp212 = *((uint32_t *)__cil_tmp211);
      __cil_tmp213 = (uint32_t )j;
      if (! (__cil_tmp213 < __cil_tmp212)) {
        goto while_break___1;
      }
      __cil_tmp214 = *((uint32_t *)cur_size);
      __cil_tmp215 = __cil_tmp214 * stride_bpp;
      __cil_tmp216 = __cil_tmp215 + 7U;
      stride = __cil_tmp216 >> 3;
      *((uint32_t *)cur_offset) = (uint32_t )i;
      __cil_tmp217 = (unsigned long )cur_offset;
      __cil_tmp218 = __cil_tmp217 + 4UL;
      *((uint32_t *)__cil_tmp218) = (uint32_t )j;
      __cil_tmp219 = (unsigned long )cur_offset;
      __cil_tmp220 = __cil_tmp219 + 8UL;
      *((uint32_t *)__cil_tmp220) = cur_bo_offset;
      __cil_tmp221 = (unsigned long )cur_size;
      __cil_tmp222 = __cil_tmp221 + 8UL;
      __cil_tmp223 = *((uint32_t *)__cil_tmp222);
      __cil_tmp224 = (unsigned long )cur_size;
      __cil_tmp225 = __cil_tmp224 + 4UL;
      __cil_tmp226 = *((uint32_t *)__cil_tmp225);
      __cil_tmp227 = stride * __cil_tmp226;
      __cil_tmp228 = __cil_tmp227 * __cil_tmp223;
      __cil_tmp229 = __cil_tmp228 * bpp;
      __cil_tmp230 = __cil_tmp229 / stride_bpp;
      cur_bo_offset += __cil_tmp230;
      cur_offset ++;
      cur_size ++;
      j ++;
    }
    while_break___1: 
    i ++;
  }
  while_break___0: 
  __cil_tmp231 = (unsigned long )srf;
  __cil_tmp232 = __cil_tmp231 + 200UL;
  *((uint32_t *)__cil_tmp232) = cur_bo_offset;
  __cil_tmp233 = (unsigned long )srf;
  __cil_tmp234 = __cil_tmp233 + 156UL;
  if (*((bool *)__cil_tmp234)) {
    __cil_tmp235 = (unsigned long )srf;
    __cil_tmp236 = __cil_tmp235 + 152UL;
    __cil_tmp237 = *((uint32_t *)__cil_tmp236);
    if (__cil_tmp237 == 1U) {
      __cil_tmp238 = (unsigned long )srf;
      __cil_tmp239 = __cil_tmp238 + 144UL;
      __cil_tmp240 = *((struct drm_vmw_size **)__cil_tmp239);
      __cil_tmp241 = __cil_tmp240 + 0;
      __cil_tmp242 = *((uint32_t *)__cil_tmp241);
      if (__cil_tmp242 == 64U) {
        __cil_tmp243 = (unsigned long )srf;
        __cil_tmp244 = __cil_tmp243 + 144UL;
        __cil_tmp245 = *((struct drm_vmw_size **)__cil_tmp244);
        __cil_tmp246 = __cil_tmp245 + 0;
        __cil_tmp247 = (unsigned long )__cil_tmp246;
        __cil_tmp248 = __cil_tmp247 + 4UL;
        __cil_tmp249 = *((uint32_t *)__cil_tmp248);
        if (__cil_tmp249 == 64U) {
          __cil_tmp250 = (unsigned long )srf;
          __cil_tmp251 = __cil_tmp250 + 116UL;
          __cil_tmp252 = *((uint32_t *)__cil_tmp251);
          if (__cil_tmp252 == 2U) {
            __cil_tmp253 = (size_t )16384;
            tmp___26 = kzalloc(__cil_tmp253, 208U);
            __cil_tmp254 = 176;
            __cil_tmp255 = (unsigned long )srf;
            __cil_tmp256 = __cil_tmp255 + __cil_tmp254;
            *((uint32_t **)__cil_tmp256) = (uint32_t *)tmp___26;
            __cil_tmp257 = 176;
            __cil_tmp258 = (unsigned long )srf;
            __cil_tmp259 = __cil_tmp258 + __cil_tmp257;
            __cil_tmp260 = *((uint32_t **)__cil_tmp259);
            if (! __cil_tmp260) {
              drm_err("vmw_surface_define_ioctl", "Failed to allocate cursor_image\n");
              ret = -12;
              goto out_no_copy;
            }
          } else {
            __cil_tmp261 = 176;
            __cil_tmp262 = (unsigned long )srf;
            __cil_tmp263 = __cil_tmp262 + __cil_tmp261;
            __cil_tmp264 = (void *)0;
            *((uint32_t **)__cil_tmp263) = (uint32_t *)__cil_tmp264;
          }
        } else {
          __cil_tmp265 = 176;
          __cil_tmp266 = (unsigned long )srf;
          __cil_tmp267 = __cil_tmp266 + __cil_tmp265;
          __cil_tmp268 = (void *)0;
          *((uint32_t **)__cil_tmp267) = (uint32_t *)__cil_tmp268;
        }
      } else {
        __cil_tmp269 = 176;
        __cil_tmp270 = (unsigned long )srf;
        __cil_tmp271 = __cil_tmp270 + __cil_tmp269;
        __cil_tmp272 = (void *)0;
        *((uint32_t **)__cil_tmp271) = (uint32_t *)__cil_tmp272;
      }
    } else {
      __cil_tmp273 = 176;
      __cil_tmp274 = (unsigned long )srf;
      __cil_tmp275 = __cil_tmp274 + __cil_tmp273;
      __cil_tmp276 = (void *)0;
      *((uint32_t **)__cil_tmp275) = (uint32_t *)__cil_tmp276;
    }
  } else {
    __cil_tmp277 = 176;
    __cil_tmp278 = (unsigned long )srf;
    __cil_tmp279 = __cil_tmp278 + __cil_tmp277;
    __cil_tmp280 = (void *)0;
    *((uint32_t **)__cil_tmp279) = (uint32_t *)__cil_tmp280;
  }
  __cil_tmp281 = (unsigned long )srf;
  __cil_tmp282 = __cil_tmp281 + 160UL;
  __cil_tmp283 = (void *)0;
  *((struct drm_crtc **)__cil_tmp282) = (struct drm_crtc *)__cil_tmp283;
  __cil_tmp284 = 28;
  __cil_tmp285 = (unsigned long )user_srf;
  __cil_tmp286 = __cil_tmp285 + __cil_tmp284;
  *((bool *)__cil_tmp286) = (bool )0;
  __cil_tmp287 = 32;
  __cil_tmp288 = (unsigned long )user_srf;
  __cil_tmp289 = __cil_tmp288 + __cil_tmp287;
  __cil_tmp290 = (void *)0;
  *((struct ttm_object_file **)__cil_tmp289) = (struct ttm_object_file *)__cil_tmp290;
  ret = vmw_surface_init(dev_priv, srf, & vmw_user_surface_free);
  __cil_tmp291 = ret != 0;
  __cil_tmp292 = ! __cil_tmp291;
  __cil_tmp293 = ! __cil_tmp292;
  __cil_tmp294 = (long )__cil_tmp293;
  tmp___27 = ldv__builtin_expect(__cil_tmp294, 0L);
  if (tmp___27) {
    goto out_unlock;
  }
  __cil_tmp295 = & tmp___8;
  __cil_tmp296 = (struct vmw_resource *)srf;
  *__cil_tmp295 = vmw_resource_reference(__cil_tmp296);
  __cil_tmp297 = (struct ttm_base_object *)user_srf;
  __cil_tmp298 = (unsigned long )req;
  __cil_tmp299 = __cil_tmp298 + 40UL;
  __cil_tmp300 = *((int32_t *)__cil_tmp299);
  __cil_tmp301 = (bool )__cil_tmp300;
  __cil_tmp302 = (enum ttm_object_type )257;
  __cil_tmp303 = (void *)0;
  __cil_tmp304 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp303;
  ret = ttm_base_object_init(tfile, __cil_tmp297, __cil_tmp301, __cil_tmp302, & vmw_user_surface_base_release,
                             __cil_tmp304);
  __cil_tmp305 = ret != 0;
  __cil_tmp306 = ! __cil_tmp305;
  __cil_tmp307 = ! __cil_tmp306;
  __cil_tmp308 = (long )__cil_tmp307;
  tmp___28 = ldv__builtin_expect(__cil_tmp308, 0L);
  if (tmp___28) {
    vmw_resource_unreference(& tmp___8);
    vmw_resource_unreference(& res);
    goto out_unlock;
  }
  __cil_tmp309 = 16;
  __cil_tmp310 = __cil_tmp309;
  __cil_tmp311 = (unsigned long )user_srf;
  __cil_tmp312 = __cil_tmp311 + __cil_tmp310;
  __cil_tmp313 = *((unsigned long *)__cil_tmp312);
  *((int32_t *)rep) = (int32_t )__cil_tmp313;
  __cil_tmp314 = *((int32_t *)rep);
  __cil_tmp315 = (uint32 )__cil_tmp314;
  if (__cil_tmp315 == 4294967295U) {
    drm_err("vmw_surface_define_ioctl", "Created bad Surface ID.\n");
  }
  vmw_resource_unreference(& res);
  __cil_tmp316 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp316);
  return (0);
  out_no_copy: 
  __cil_tmp317 = (unsigned long )srf;
  __cil_tmp318 = __cil_tmp317 + 192UL;
  __cil_tmp319 = *((struct vmw_surface_offset **)__cil_tmp318);
  __cil_tmp320 = (void *)__cil_tmp319;
  kfree(__cil_tmp320);
  out_no_offsets: 
  __cil_tmp321 = (unsigned long )srf;
  __cil_tmp322 = __cil_tmp321 + 144UL;
  __cil_tmp323 = *((struct drm_vmw_size **)__cil_tmp322);
  __cil_tmp324 = (void *)__cil_tmp323;
  kfree(__cil_tmp324);
  out_no_sizes: 
  __cil_tmp325 = (void *)user_srf;
  kfree(__cil_tmp325);
  out_no_user_srf: 
  tmp___29 = vmw_mem_glob(dev_priv);
  __cil_tmp326 = (uint64_t )size;
  ttm_mem_global_free(tmp___29, __cil_tmp326);
  out_unlock: 
  __cil_tmp327 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp327);
  return (ret);
}
}
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ union drm_vmw_surface_reference_arg *arg ;
  struct drm_vmw_surface_arg *req ;
  struct drm_vmw_surface_create_req *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct drm_vmw_size *user_sizes ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___8 ;
  long tmp___9 ;
  struct ttm_base_object *__mptr ;
  long tmp___10 ;
  size_t __len ;
  void *__ret ;
  long tmp___11 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct ttm_base_object **__cil_tmp23 ;
  int32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct ttm_base_object **__cil_tmp28 ;
  struct ttm_base_object *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  struct ttm_base_object **__cil_tmp35 ;
  struct ttm_base_object *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  enum ttm_object_type __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  struct ttm_base_object **__cil_tmp45 ;
  struct ttm_base_object *__cil_tmp46 ;
  struct vmw_user_surface *__cil_tmp47 ;
  struct ttm_base_object *__cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  enum ttm_ref_type __cil_tmp55 ;
  void *__cil_tmp56 ;
  bool *__cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  uint32_t *__cil_tmp72 ;
  void *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  uint32_t *__cil_tmp78 ;
  void *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t *__cil_tmp84 ;
  void *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  uint32_t *__cil_tmp90 ;
  void *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  uint64_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  void *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct drm_vmw_size *__cil_tmp99 ;
  void *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  uint32_t __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  uint32_t __cil_tmp113 ;
  int tmp ;

  {
  arg = (union drm_vmw_surface_reference_arg *)data;
  req = (struct drm_vmw_surface_arg *)arg;
  rep = (struct drm_vmw_surface_create_req *)arg;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp21 = (unsigned long )tmp___7;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp22);
  ret = -22;
  __cil_tmp23 = & base;
  __cil_tmp24 = *((int32_t *)req);
  __cil_tmp25 = (uint32_t )__cil_tmp24;
  *__cil_tmp23 = ttm_base_object_lookup(tfile, __cil_tmp25);
  __cil_tmp26 = (void *)0;
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = & base;
  __cil_tmp29 = *__cil_tmp28;
  __cil_tmp30 = (unsigned long )__cil_tmp29;
  __cil_tmp31 = __cil_tmp30 == __cil_tmp27;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = (long )__cil_tmp33;
  tmp___8 = ldv__builtin_expect(__cil_tmp34, 0L);
  if (tmp___8) {
    drm_err("vmw_surface_reference_ioctl", "Could not find surface to reference.\n");
    return (-22);
  }
  __cil_tmp35 = & base;
  __cil_tmp36 = *__cil_tmp35;
  __cil_tmp37 = (unsigned long )__cil_tmp36;
  __cil_tmp38 = __cil_tmp37 + 24UL;
  __cil_tmp39 = *((enum ttm_object_type *)__cil_tmp38);
  __cil_tmp40 = (unsigned int )__cil_tmp39;
  __cil_tmp41 = __cil_tmp40 != 257U;
  __cil_tmp42 = ! __cil_tmp41;
  __cil_tmp43 = ! __cil_tmp42;
  __cil_tmp44 = (long )__cil_tmp43;
  tmp___9 = ldv__builtin_expect(__cil_tmp44, 0L);
  if (tmp___9) {
    goto out_bad_resource;
  }
  __cil_tmp45 = & base;
  __cil_tmp46 = *__cil_tmp45;
  __mptr = __cil_tmp46;
  __cil_tmp47 = (struct vmw_user_surface *)0;
  __cil_tmp48 = (struct ttm_base_object *)__cil_tmp47;
  __cil_tmp49 = (unsigned int )__cil_tmp48;
  __cil_tmp50 = (char *)__mptr;
  __cil_tmp51 = __cil_tmp50 - __cil_tmp49;
  user_srf = (struct vmw_user_surface *)__cil_tmp51;
  __cil_tmp52 = (unsigned long )user_srf;
  __cil_tmp53 = __cil_tmp52 + 64UL;
  srf = (struct vmw_surface *)__cil_tmp53;
  __cil_tmp54 = (struct ttm_base_object *)user_srf;
  __cil_tmp55 = (enum ttm_ref_type )0;
  __cil_tmp56 = (void *)0;
  __cil_tmp57 = (bool *)__cil_tmp56;
  ret = ttm_ref_object_add(tfile, __cil_tmp54, __cil_tmp55, __cil_tmp57);
  __cil_tmp58 = ret != 0;
  __cil_tmp59 = ! __cil_tmp58;
  __cil_tmp60 = ! __cil_tmp59;
  __cil_tmp61 = (long )__cil_tmp60;
  tmp___10 = ldv__builtin_expect(__cil_tmp61, 0L);
  if (tmp___10) {
    drm_err("vmw_surface_reference_ioctl", "Could not add a reference to a surface.\n");
    goto out_bad_resource;
  }
  __cil_tmp62 = (unsigned long )srf;
  __cil_tmp63 = __cil_tmp62 + 112UL;
  *((uint32_t *)rep) = *((uint32_t *)__cil_tmp63);
  __cil_tmp64 = (unsigned long )rep;
  __cil_tmp65 = __cil_tmp64 + 4UL;
  __cil_tmp66 = (unsigned long )srf;
  __cil_tmp67 = __cil_tmp66 + 116UL;
  *((uint32_t *)__cil_tmp65) = *((uint32_t *)__cil_tmp67);
  __len = 24UL;
  if (__len >= 64UL) {
    __cil_tmp68 = 0UL;
    __cil_tmp69 = 8UL + __cil_tmp68;
    __cil_tmp70 = (unsigned long )rep;
    __cil_tmp71 = __cil_tmp70 + __cil_tmp69;
    __cil_tmp72 = (uint32_t *)__cil_tmp71;
    __cil_tmp73 = (void *)__cil_tmp72;
    __cil_tmp74 = 0UL;
    __cil_tmp75 = 120UL + __cil_tmp74;
    __cil_tmp76 = (unsigned long )srf;
    __cil_tmp77 = __cil_tmp76 + __cil_tmp75;
    __cil_tmp78 = (uint32_t *)__cil_tmp77;
    __cil_tmp79 = (void *)__cil_tmp78;
    __ret = __memcpy(__cil_tmp73, __cil_tmp79, __len);
  } else {
    __cil_tmp80 = 0UL;
    __cil_tmp81 = 8UL + __cil_tmp80;
    __cil_tmp82 = (unsigned long )rep;
    __cil_tmp83 = __cil_tmp82 + __cil_tmp81;
    __cil_tmp84 = (uint32_t *)__cil_tmp83;
    __cil_tmp85 = (void *)__cil_tmp84;
    __cil_tmp86 = 0UL;
    __cil_tmp87 = 120UL + __cil_tmp86;
    __cil_tmp88 = (unsigned long )srf;
    __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
    __cil_tmp90 = (uint32_t *)__cil_tmp89;
    __cil_tmp91 = (void *)__cil_tmp90;
    __ret = __builtin_memcpy(__cil_tmp85, __cil_tmp91, __len);
  }
  __cil_tmp92 = (unsigned long )rep;
  __cil_tmp93 = __cil_tmp92 + 32UL;
  __cil_tmp94 = *((uint64_t *)__cil_tmp93);
  __cil_tmp95 = (unsigned long )__cil_tmp94;
  user_sizes = (struct drm_vmw_size *)__cil_tmp95;
  if (user_sizes) {
    __cil_tmp96 = (void *)user_sizes;
    __cil_tmp97 = (unsigned long )srf;
    __cil_tmp98 = __cil_tmp97 + 144UL;
    __cil_tmp99 = *((struct drm_vmw_size **)__cil_tmp98);
    __cil_tmp100 = (void *)__cil_tmp99;
    __cil_tmp101 = (unsigned long )srf;
    __cil_tmp102 = __cil_tmp101 + 152UL;
    __cil_tmp103 = *((uint32_t *)__cil_tmp102);
    __cil_tmp104 = (unsigned long )__cil_tmp103;
    __cil_tmp105 = __cil_tmp104 * 16UL;
    __cil_tmp106 = (unsigned int )__cil_tmp105;
    tmp = (int )copy_to_user(__cil_tmp96, __cil_tmp100, __cil_tmp106);
    ret = tmp;
  }
  __cil_tmp107 = ret != 0;
  __cil_tmp108 = ! __cil_tmp107;
  __cil_tmp109 = ! __cil_tmp108;
  __cil_tmp110 = (long )__cil_tmp109;
  tmp___11 = ldv__builtin_expect(__cil_tmp110, 0L);
  if (tmp___11) {
    __cil_tmp111 = (unsigned long )srf;
    __cil_tmp112 = __cil_tmp111 + 152UL;
    __cil_tmp113 = *((uint32_t *)__cil_tmp112);
    drm_err("vmw_surface_reference_ioctl", "copy_to_user failed %p %u\n", user_sizes,
            __cil_tmp113);
    ret = -14;
  }
  out_bad_resource: 
  ttm_base_object_unref(& base);
  return (ret);
}
}
int vmw_surface_check(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                      uint32_t handle , int *id ) 
{ struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object *__mptr ;
  struct ttm_base_object **__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct ttm_base_object **__cil_tmp14 ;
  struct ttm_base_object *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  struct ttm_base_object **__cil_tmp21 ;
  struct ttm_base_object *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  enum ttm_object_type __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  struct ttm_base_object **__cil_tmp31 ;
  struct ttm_base_object *__cil_tmp32 ;
  struct vmw_user_surface *__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  ret = -1;
  __cil_tmp11 = & base;
  *__cil_tmp11 = ttm_base_object_lookup(tfile, handle);
  __cil_tmp12 = (void *)0;
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = & base;
  __cil_tmp15 = *__cil_tmp14;
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  __cil_tmp17 = __cil_tmp16 == __cil_tmp13;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___7) {
    return (-22);
  }
  __cil_tmp21 = & base;
  __cil_tmp22 = *__cil_tmp21;
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = __cil_tmp23 + 24UL;
  __cil_tmp25 = *((enum ttm_object_type *)__cil_tmp24);
  __cil_tmp26 = (unsigned int )__cil_tmp25;
  __cil_tmp27 = __cil_tmp26 != 257U;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = (long )__cil_tmp29;
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 0L);
  if (tmp___8) {
    goto out_bad_surface;
  }
  __cil_tmp31 = & base;
  __cil_tmp32 = *__cil_tmp31;
  __mptr = __cil_tmp32;
  __cil_tmp33 = (struct vmw_user_surface *)0;
  __cil_tmp34 = (struct ttm_base_object *)__cil_tmp33;
  __cil_tmp35 = (unsigned int )__cil_tmp34;
  __cil_tmp36 = (char *)__mptr;
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
  user_srf = (struct vmw_user_surface *)__cil_tmp37;
  __cil_tmp38 = 24;
  __cil_tmp39 = 64UL + __cil_tmp38;
  __cil_tmp40 = (unsigned long )user_srf;
  __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
  *id = *((int *)__cil_tmp41);
  ret = 0;
  out_bad_surface: 
  ttm_base_object_unref(& base);
  return (ret);
}
}
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  void *__cil_tmp4 ;

  {
  tmp___7 = vmw_dma_buffer(bo);
  vmw_bo = tmp___7;
  __cil_tmp4 = (void *)vmw_bo;
  kfree(__cil_tmp4);
  return;
}
}
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object *bo ) ) 
{ struct ttm_bo_device *bdev ;
  size_t acc_size ;
  int ret ;
  long tmp___7 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  struct ttm_buffer_object *__cil_tmp20 ;
  enum ttm_bo_type __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  void *__cil_tmp23 ;
  struct file *__cil_tmp24 ;

  {
  bdev = (struct ttm_bo_device *)dev_priv;
  while (1) {
    __cil_tmp11 = ! bo_free;
    __cil_tmp12 = ! __cil_tmp11;
    __cil_tmp13 = ! __cil_tmp12;
    __cil_tmp14 = (long )__cil_tmp13;
    tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c"),
                             "i" (1560), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp15 = 416U;
  acc_size = ttm_bo_acc_size(bdev, size, __cil_tmp15);
  __cil_tmp16 = (void *)vmw_bo;
  memset(__cil_tmp16, 0, 416UL);
  __cil_tmp17 = (unsigned long )vmw_bo;
  __cil_tmp18 = __cil_tmp17 + 384UL;
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
  INIT_LIST_HEAD(__cil_tmp19);
  __cil_tmp20 = (struct ttm_buffer_object *)vmw_bo;
  __cil_tmp21 = (enum ttm_bo_type )0;
  __cil_tmp22 = (uint32_t )0;
  __cil_tmp23 = (void *)0;
  __cil_tmp24 = (struct file *)__cil_tmp23;
  ret = ttm_bo_init(bdev, __cil_tmp20, size, __cil_tmp21, placement, __cil_tmp22,
                    0UL, interruptible, __cil_tmp24, acc_size, bo_free);
  return (ret);
}
}
static void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct vmw_user_dma_buffer *tmp___7 ;
  void *__cil_tmp4 ;

  {
  tmp___7 = vmw_user_dma_buffer(bo);
  vmw_user_bo = tmp___7;
  __cil_tmp4 = (void *)vmw_user_bo;
  kfree(__cil_tmp4);
  return;
}
}
static void vmw_user_dmabuf_release(struct ttm_base_object **p_base ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  struct ttm_buffer_object *bo ;
  long tmp___7 ;
  struct ttm_base_object *__mptr ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct vmw_user_dma_buffer *__cil_tmp15 ;
  struct ttm_base_object *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct ttm_buffer_object **__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;

  {
  base = *p_base;
  __cil_tmp7 = (void *)0;
  *p_base = (struct ttm_base_object *)__cil_tmp7;
  __cil_tmp8 = (void *)0;
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = (unsigned long )base;
  __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp___7) {
    return;
  }
  __mptr = base;
  __cil_tmp15 = (struct vmw_user_dma_buffer *)0;
  __cil_tmp16 = (struct ttm_base_object *)__cil_tmp15;
  __cil_tmp17 = (unsigned int )__cil_tmp16;
  __cil_tmp18 = (char *)__mptr;
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
  vmw_user_bo = (struct vmw_user_dma_buffer *)__cil_tmp19;
  __cil_tmp20 = & bo;
  __cil_tmp21 = (unsigned long )vmw_user_bo;
  __cil_tmp22 = __cil_tmp21 + 64UL;
  *__cil_tmp20 = (struct ttm_buffer_object *)__cil_tmp22;
  ttm_bo_unref(& bo);
  return;
}
}
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  union drm_vmw_alloc_dmabuf_arg *arg ;
  struct drm_vmw_alloc_dmabuf_req *req ;
  struct drm_vmw_dmabuf_rep *rep ;
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_buffer_object *tmp___8 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___9 ;
  int ret ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct vmw_fpriv *tmp___14 ;
  long tmp___15 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_master *__cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  struct ttm_lock *__cil_tmp30 ;
  bool __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  long __cil_tmp35 ;
  void *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_dma_buffer *__cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  size_t __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  struct ttm_buffer_object **__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_buffer_object *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct ttm_object_file *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  bool __cil_tmp55 ;
  enum ttm_object_type __cil_tmp56 ;
  void *__cil_tmp57 ;
  void (*__cil_tmp58)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct ttm_lock *__cil_tmp83 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (union drm_vmw_alloc_dmabuf_arg *)data;
  req = (struct drm_vmw_alloc_dmabuf_req *)arg;
  rep = (struct drm_vmw_dmabuf_rep *)arg;
  __cil_tmp20 = (unsigned long )file_priv;
  __cil_tmp21 = __cil_tmp20 + 152UL;
  __cil_tmp22 = *((struct drm_master **)__cil_tmp21);
  tmp___9 = vmw_master(__cil_tmp22);
  vmaster = tmp___9;
  tmp___10 = kzalloc(480UL, 208U);
  vmw_user_bo = (struct vmw_user_dma_buffer *)tmp___10;
  __cil_tmp23 = (void *)0;
  __cil_tmp24 = (unsigned long )__cil_tmp23;
  __cil_tmp25 = (unsigned long )vmw_user_bo;
  __cil_tmp26 = __cil_tmp25 == __cil_tmp24;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___11 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___11) {
    return (-12);
  }
  __cil_tmp30 = (struct ttm_lock *)vmaster;
  __cil_tmp31 = (bool )1;
  ret = ttm_read_lock(__cil_tmp30, __cil_tmp31);
  __cil_tmp32 = ret != 0;
  __cil_tmp33 = ! __cil_tmp32;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = (long )__cil_tmp34;
  tmp___12 = ldv__builtin_expect(__cil_tmp35, 0L);
  if (tmp___12) {
    __cil_tmp36 = (void *)vmw_user_bo;
    kfree(__cil_tmp36);
    return (ret);
  }
  __cil_tmp37 = (unsigned long )vmw_user_bo;
  __cil_tmp38 = __cil_tmp37 + 64UL;
  __cil_tmp39 = (struct vmw_dma_buffer *)__cil_tmp38;
  __cil_tmp40 = *((uint32_t *)req);
  __cil_tmp41 = (size_t )__cil_tmp40;
  __cil_tmp42 = (bool )1;
  ret = vmw_dmabuf_init(dev_priv, __cil_tmp39, __cil_tmp41, & vmw_vram_sys_placement,
                        __cil_tmp42, & vmw_user_dmabuf_destroy);
  __cil_tmp43 = ret != 0;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = (long )__cil_tmp45;
  tmp___13 = ldv__builtin_expect(__cil_tmp46, 0L);
  if (tmp___13) {
    goto out_no_dmabuf;
  }
  __cil_tmp47 = & tmp___8;
  __cil_tmp48 = (unsigned long )vmw_user_bo;
  __cil_tmp49 = __cil_tmp48 + 64UL;
  __cil_tmp50 = (struct ttm_buffer_object *)__cil_tmp49;
  *__cil_tmp47 = ttm_bo_reference(__cil_tmp50);
  tmp___14 = vmw_fpriv(file_priv);
  __cil_tmp51 = (unsigned long )tmp___14;
  __cil_tmp52 = __cil_tmp51 + 8UL;
  __cil_tmp53 = *((struct ttm_object_file **)__cil_tmp52);
  __cil_tmp54 = (struct ttm_base_object *)vmw_user_bo;
  __cil_tmp55 = (bool )0;
  __cil_tmp56 = (enum ttm_object_type )1;
  __cil_tmp57 = (void *)0;
  __cil_tmp58 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp57;
  ret = ttm_base_object_init(__cil_tmp53, __cil_tmp54, __cil_tmp55, __cil_tmp56, & vmw_user_dmabuf_release,
                             __cil_tmp58);
  __cil_tmp59 = ret != 0;
  __cil_tmp60 = ! __cil_tmp59;
  __cil_tmp61 = ! __cil_tmp60;
  __cil_tmp62 = (long )__cil_tmp61;
  tmp___15 = ldv__builtin_expect(__cil_tmp62, 0L);
  if (! tmp___15) {
    __cil_tmp63 = (unsigned long )rep;
    __cil_tmp64 = __cil_tmp63 + 8UL;
    __cil_tmp65 = 16;
    __cil_tmp66 = __cil_tmp65;
    __cil_tmp67 = (unsigned long )vmw_user_bo;
    __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
    __cil_tmp69 = *((unsigned long *)__cil_tmp68);
    *((uint32_t *)__cil_tmp64) = (uint32_t )__cil_tmp69;
    __cil_tmp70 = 48;
    __cil_tmp71 = 64UL + __cil_tmp70;
    __cil_tmp72 = (unsigned long )vmw_user_bo;
    __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
    *((uint64_t *)rep) = *((uint64_t *)__cil_tmp73);
    __cil_tmp74 = (unsigned long )rep;
    __cil_tmp75 = __cil_tmp74 + 12UL;
    __cil_tmp76 = 16;
    __cil_tmp77 = __cil_tmp76;
    __cil_tmp78 = (unsigned long )vmw_user_bo;
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
    __cil_tmp80 = *((unsigned long *)__cil_tmp79);
    *((uint32_t *)__cil_tmp75) = (uint32_t )__cil_tmp80;
    __cil_tmp81 = (unsigned long )rep;
    __cil_tmp82 = __cil_tmp81 + 16UL;
    *((uint32_t *)__cil_tmp82) = (uint32_t )0;
  }
  out_no_base_object: 
  ttm_bo_unref(& tmp___8);
  out_no_dmabuf: 
  __cil_tmp83 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp83);
  return (ret);
}
}
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_unref_dmabuf_arg *arg ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct ttm_object_file *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  arg = (struct drm_vmw_unref_dmabuf_arg *)data;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp7 = (unsigned long )tmp___7;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  __cil_tmp9 = *((struct ttm_object_file **)__cil_tmp8);
  __cil_tmp10 = *((uint32_t *)arg);
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = (enum ttm_ref_type )0;
  tmp___8 = ttm_ref_object_base_unref(__cil_tmp9, __cil_tmp11, __cil_tmp12);
  return (tmp___8);
}
}
uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo , uint32_t cur_validate_node ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  bool __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  tmp___7 = vmw_dma_buffer(bo);
  vmw_bo = tmp___7;
  __cil_tmp6 = (unsigned long )vmw_bo;
  __cil_tmp7 = __cil_tmp6 + 408UL;
  __cil_tmp8 = *((bool *)__cil_tmp7);
  __cil_tmp9 = ! __cil_tmp8;
  __cil_tmp10 = ! __cil_tmp9;
  __cil_tmp11 = (long )__cil_tmp10;
  tmp___8 = ldv__builtin_expect(__cil_tmp11, 1L);
  if (tmp___8) {
    __cil_tmp12 = (unsigned long )vmw_bo;
    __cil_tmp13 = __cil_tmp12 + 404UL;
    return (*((uint32_t *)__cil_tmp13));
  }
  __cil_tmp14 = (unsigned long )vmw_bo;
  __cil_tmp15 = __cil_tmp14 + 404UL;
  *((uint32_t *)__cil_tmp15) = cur_validate_node;
  __cil_tmp16 = (unsigned long )vmw_bo;
  __cil_tmp17 = __cil_tmp16 + 408UL;
  *((bool *)__cil_tmp17) = (bool )1;
  return (cur_validate_node);
}
}
void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  tmp___7 = vmw_dma_buffer(bo);
  vmw_bo = tmp___7;
  __cil_tmp4 = (unsigned long )vmw_bo;
  __cil_tmp5 = __cil_tmp4 + 408UL;
  *((bool *)__cil_tmp5) = (bool )0;
  return;
}
}
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_base_object *__mptr ;
  struct ttm_base_object **__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_base_object **__cil_tmp12 ;
  struct ttm_base_object *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct ttm_base_object **__cil_tmp20 ;
  struct ttm_base_object *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  enum ttm_object_type __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct ttm_base_object **__cil_tmp31 ;
  struct ttm_base_object *__cil_tmp32 ;
  struct vmw_user_dma_buffer *__cil_tmp33 ;
  struct ttm_base_object *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct ttm_buffer_object *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;

  {
  __cil_tmp9 = & base;
  *__cil_tmp9 = ttm_base_object_lookup(tfile, handle);
  __cil_tmp10 = (void *)0;
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = & base;
  __cil_tmp13 = *__cil_tmp12;
  __cil_tmp14 = (unsigned long )__cil_tmp13;
  __cil_tmp15 = __cil_tmp14 == __cil_tmp11;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  if (tmp___7) {
    __cil_tmp19 = (unsigned long )handle;
    printk("<3>Invalid buffer object handle 0x%08lx.\n", __cil_tmp19);
    return (-3);
  }
  __cil_tmp20 = & base;
  __cil_tmp21 = *__cil_tmp20;
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = __cil_tmp22 + 24UL;
  __cil_tmp24 = *((enum ttm_object_type *)__cil_tmp23);
  __cil_tmp25 = (unsigned int )__cil_tmp24;
  __cil_tmp26 = __cil_tmp25 != 1U;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___8 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___8) {
    ttm_base_object_unref(& base);
    __cil_tmp30 = (unsigned long )handle;
    printk("<3>Invalid buffer object handle 0x%08lx.\n", __cil_tmp30);
    return (-22);
  }
  __cil_tmp31 = & base;
  __cil_tmp32 = *__cil_tmp31;
  __mptr = __cil_tmp32;
  __cil_tmp33 = (struct vmw_user_dma_buffer *)0;
  __cil_tmp34 = (struct ttm_base_object *)__cil_tmp33;
  __cil_tmp35 = (unsigned int )__cil_tmp34;
  __cil_tmp36 = (char *)__mptr;
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
  vmw_user_bo = (struct vmw_user_dma_buffer *)__cil_tmp37;
  __cil_tmp38 = (unsigned long )vmw_user_bo;
  __cil_tmp39 = __cil_tmp38 + 64UL;
  __cil_tmp40 = (struct ttm_buffer_object *)__cil_tmp39;
  ttm_bo_reference(__cil_tmp40);
  ttm_base_object_unref(& base);
  __cil_tmp41 = (unsigned long )vmw_user_bo;
  __cil_tmp42 = __cil_tmp41 + 64UL;
  *out = (struct vmw_dma_buffer *)__cil_tmp42;
  return (0);
}
}
static void vmw_stream_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_stream *stream ;
  int ret ;
  struct vmw_resource *__mptr ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_stream *__cil_tmp10 ;
  struct vmw_resource *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;

  {
  __cil_tmp8 = (unsigned long )res;
  __cil_tmp9 = __cil_tmp8 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp9);
  printk("<6>[drm] %s: unref\n", "vmw_stream_destroy");
  __mptr = res;
  __cil_tmp10 = (struct vmw_stream *)0;
  __cil_tmp11 = (struct vmw_resource *)__cil_tmp10;
  __cil_tmp12 = (unsigned int )__cil_tmp11;
  __cil_tmp13 = (char *)__mptr;
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
  stream = (struct vmw_stream *)__cil_tmp14;
  __cil_tmp15 = (unsigned long )stream;
  __cil_tmp16 = __cil_tmp15 + 96UL;
  __cil_tmp17 = *((uint32_t *)__cil_tmp16);
  ret = vmw_overlay_unref(dev_priv, __cil_tmp17);
  __cil_tmp18 = ret != 0;
  __cil_tmp19 = ! __cil_tmp18;
  __ret_warn_on = ! __cil_tmp19;
  __cil_tmp20 = ! __ret_warn_on;
  __cil_tmp21 = ! __cil_tmp20;
  __cil_tmp22 = (long )__cil_tmp21;
  tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
  if (tmp___7) {
    __cil_tmp23 = 1723;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c",
                       __cil_tmp23);
  }
  __cil_tmp24 = ! __ret_warn_on;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  ldv__builtin_expect(__cil_tmp26, 0L);
  return;
}
}
static int vmw_stream_init(struct vmw_private *dev_priv , struct vmw_stream *stream ,
                           void (*res_free)(struct vmw_resource *res ) ) 
{ struct vmw_resource *res ;
  int ret ;
  long tmp___7 ;
  struct vmw_resource **__cil_tmp7 ;
  struct vmw_resource **__cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct idr *__cil_tmp12 ;
  enum ttm_object_type __cil_tmp13 ;
  bool __cil_tmp14 ;
  void *__cil_tmp15 ;
  void (*__cil_tmp16)(struct vmw_resource *res ) ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  struct vmw_resource *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t *__cil_tmp28 ;
  struct vmw_resource *__cil_tmp29 ;

  {
  __cil_tmp7 = & res;
  *__cil_tmp7 = (struct vmw_resource *)stream;
  __cil_tmp8 = & res;
  __cil_tmp9 = *__cil_tmp8;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2752UL;
  __cil_tmp12 = (struct idr *)__cil_tmp11;
  __cil_tmp13 = (enum ttm_object_type )258;
  __cil_tmp14 = (bool )0;
  __cil_tmp15 = (void *)0;
  __cil_tmp16 = (void (*)(struct vmw_resource *res ))__cil_tmp15;
  ret = vmw_resource_init(dev_priv, __cil_tmp9, __cil_tmp12, __cil_tmp13, __cil_tmp14,
                          res_free, __cil_tmp16);
  __cil_tmp17 = ret != 0;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___7 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___7) {
    __cil_tmp21 = (void *)0;
    __cil_tmp22 = (unsigned long )__cil_tmp21;
    __cil_tmp23 = (unsigned long )res_free;
    if (__cil_tmp23 == __cil_tmp22) {
      __cil_tmp24 = (void *)stream;
      kfree(__cil_tmp24);
    } else {
      __cil_tmp25 = (struct vmw_resource *)stream;
      (*res_free)(__cil_tmp25);
    }
    return (ret);
  }
  __cil_tmp26 = (unsigned long )stream;
  __cil_tmp27 = __cil_tmp26 + 96UL;
  __cil_tmp28 = (uint32_t *)__cil_tmp27;
  ret = vmw_overlay_claim(dev_priv, __cil_tmp28);
  if (ret) {
    vmw_resource_unreference(& res);
    return (ret);
  }
  printk("<6>[drm] %s: claimed\n", "vmw_stream_init");
  __cil_tmp29 = (struct vmw_resource *)stream;
  vmw_resource_activate(__cil_tmp29, & vmw_stream_destroy);
  return (0);
}
}
static void vmw_user_stream_free(struct vmw_resource *res ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_stream *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_resource *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  __mptr = res;
  __cil_tmp6 = (struct vmw_user_stream *)0;
  __cil_tmp7 = (unsigned long )__cil_tmp6;
  __cil_tmp8 = __cil_tmp7 + 64UL;
  __cil_tmp9 = (struct vmw_resource *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  stream = (struct vmw_user_stream *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )res;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp14);
  __cil_tmp15 = (void *)stream;
  kfree(__cil_tmp15);
  tmp___7 = vmw_mem_glob(dev_priv);
  ttm_mem_global_free(tmp___7, vmw_user_stream_size);
  return;
}
}
static void vmw_user_stream_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_stream *stream ;
  struct ttm_base_object *__mptr ;
  struct vmw_resource *res ;
  struct vmw_user_stream *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_resource **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  base = *p_base;
  __mptr = base;
  __cil_tmp6 = (struct vmw_user_stream *)0;
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  stream = (struct vmw_user_stream *)__cil_tmp10;
  __cil_tmp11 = & res;
  __cil_tmp12 = (unsigned long )stream;
  __cil_tmp13 = __cil_tmp12 + 64UL;
  *__cil_tmp11 = (struct vmw_resource *)__cil_tmp13;
  __cil_tmp14 = (void *)0;
  *p_base = (struct ttm_base_object *)__cil_tmp14;
  vmw_resource_unreference(& res);
  return;
}
}
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_resource *res ;
  struct vmw_user_stream *stream ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___8 ;
  int ret ;
  long tmp___9 ;
  struct vmw_resource *__mptr ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_resource **__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct idr *__cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_resource **__cil_tmp24 ;
  struct vmw_resource *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_resource **__cil_tmp32 ;
  struct vmw_resource *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  void (*__cil_tmp36)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp37 ;
  struct vmw_resource **__cil_tmp38 ;
  struct vmw_resource *__cil_tmp39 ;
  struct vmw_user_stream *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_resource *__cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_object_file *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  enum ttm_ref_type __cil_tmp58 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_stream_arg *)data;
  tmp___8 = vmw_fpriv(file_priv);
  __cil_tmp14 = (unsigned long )tmp___8;
  __cil_tmp15 = __cil_tmp14 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp15);
  ret = 0;
  __cil_tmp16 = & res;
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 2752UL;
  __cil_tmp19 = (struct idr *)__cil_tmp18;
  __cil_tmp20 = *((uint32_t *)arg);
  __cil_tmp21 = (int )__cil_tmp20;
  *__cil_tmp16 = vmw_resource_lookup(dev_priv, __cil_tmp19, __cil_tmp21);
  __cil_tmp22 = (void *)0;
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = & res;
  __cil_tmp25 = *__cil_tmp24;
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  __cil_tmp27 = __cil_tmp26 == __cil_tmp23;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = (long )__cil_tmp29;
  tmp___9 = ldv__builtin_expect(__cil_tmp30, 0L);
  if (tmp___9) {
    return (-22);
  }
  __cil_tmp31 = (unsigned long )(& vmw_user_stream_free);
  __cil_tmp32 = & res;
  __cil_tmp33 = *__cil_tmp32;
  __cil_tmp34 = (unsigned long )__cil_tmp33;
  __cil_tmp35 = __cil_tmp34 + 56UL;
  __cil_tmp36 = *((void (**)(struct vmw_resource *res ))__cil_tmp35);
  __cil_tmp37 = (unsigned long )__cil_tmp36;
  if (__cil_tmp37 != __cil_tmp31) {
    ret = -22;
    goto out;
  }
  __cil_tmp38 = & res;
  __cil_tmp39 = *__cil_tmp38;
  __mptr = __cil_tmp39;
  __cil_tmp40 = (struct vmw_user_stream *)0;
  __cil_tmp41 = (unsigned long )__cil_tmp40;
  __cil_tmp42 = __cil_tmp41 + 64UL;
  __cil_tmp43 = (struct vmw_resource *)__cil_tmp42;
  __cil_tmp44 = (unsigned int )__cil_tmp43;
  __cil_tmp45 = (char *)__mptr;
  __cil_tmp46 = __cil_tmp45 - __cil_tmp44;
  stream = (struct vmw_user_stream *)__cil_tmp46;
  __cil_tmp47 = (unsigned long )tfile;
  __cil_tmp48 = 32;
  __cil_tmp49 = (unsigned long )stream;
  __cil_tmp50 = __cil_tmp49 + __cil_tmp48;
  __cil_tmp51 = *((struct ttm_object_file **)__cil_tmp50);
  __cil_tmp52 = (unsigned long )__cil_tmp51;
  if (__cil_tmp52 != __cil_tmp47) {
    ret = -22;
    goto out;
  }
  __cil_tmp53 = 16;
  __cil_tmp54 = __cil_tmp53;
  __cil_tmp55 = (unsigned long )stream;
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
  __cil_tmp57 = *((unsigned long *)__cil_tmp56);
  __cil_tmp58 = (enum ttm_ref_type )0;
  ttm_ref_object_base_unref(tfile, __cil_tmp57, __cil_tmp58);
  out: 
  vmw_resource_unreference(& res);
  return (ret);
}
}
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___8 ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___9 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___10 ;
  int ret ;
  size_t tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  struct ttm_mem_global *tmp___14 ;
  long tmp___15 ;
  void *tmp___16 ;
  struct ttm_mem_global *tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_master *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  size_t __cil_tmp34 ;
  struct ttm_lock *__cil_tmp35 ;
  bool __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  bool __cil_tmp41 ;
  bool __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  long __cil_tmp53 ;
  struct vmw_resource **__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct vmw_stream *__cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  long __cil_tmp70 ;
  struct vmw_resource **__cil_tmp71 ;
  struct vmw_resource **__cil_tmp72 ;
  struct vmw_resource *__cil_tmp73 ;
  struct ttm_base_object *__cil_tmp74 ;
  bool __cil_tmp75 ;
  enum ttm_object_type __cil_tmp76 ;
  void *__cil_tmp77 ;
  void (*__cil_tmp78)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct vmw_resource **__cil_tmp83 ;
  struct vmw_resource *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int __cil_tmp87 ;
  struct ttm_lock *__cil_tmp88 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_stream_arg *)data;
  tmp___9 = vmw_fpriv(file_priv);
  __cil_tmp25 = (unsigned long )tmp___9;
  __cil_tmp26 = __cil_tmp25 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp26);
  __cil_tmp27 = (unsigned long )file_priv;
  __cil_tmp28 = __cil_tmp27 + 152UL;
  __cil_tmp29 = *((struct drm_master **)__cil_tmp28);
  tmp___10 = vmw_master(__cil_tmp29);
  vmaster = tmp___10;
  __cil_tmp30 = vmw_user_stream_size == 0ULL;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___12 = ldv__builtin_expect(__cil_tmp33, 0L);
  if (tmp___12) {
    tmp___11 = ttm_round_pot(168UL);
    __cil_tmp34 = tmp___11 + 128UL;
    vmw_user_stream_size = (uint64_t )__cil_tmp34;
  }
  __cil_tmp35 = (struct ttm_lock *)vmaster;
  __cil_tmp36 = (bool )1;
  ret = ttm_read_lock(__cil_tmp35, __cil_tmp36);
  __cil_tmp37 = ret != 0;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___13 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___13) {
    return (ret);
  }
  tmp___14 = vmw_mem_glob(dev_priv);
  __cil_tmp41 = (bool )0;
  __cil_tmp42 = (bool )1;
  ret = ttm_mem_global_alloc(tmp___14, vmw_user_stream_size, __cil_tmp41, __cil_tmp42);
  __cil_tmp43 = ret != 0;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = (long )__cil_tmp45;
  tmp___15 = ldv__builtin_expect(__cil_tmp46, 0L);
  if (tmp___15) {
    if (ret != -512) {
      drm_err("vmw_stream_claim_ioctl", "Out of graphics memory for stream creation.\n");
    }
    goto out_unlock;
  }
  tmp___16 = kmalloc(168UL, 208U);
  stream = (struct vmw_user_stream *)tmp___16;
  __cil_tmp47 = (void *)0;
  __cil_tmp48 = (unsigned long )__cil_tmp47;
  __cil_tmp49 = (unsigned long )stream;
  __cil_tmp50 = __cil_tmp49 == __cil_tmp48;
  __cil_tmp51 = ! __cil_tmp50;
  __cil_tmp52 = ! __cil_tmp51;
  __cil_tmp53 = (long )__cil_tmp52;
  tmp___18 = ldv__builtin_expect(__cil_tmp53, 0L);
  if (tmp___18) {
    tmp___17 = vmw_mem_glob(dev_priv);
    ttm_mem_global_free(tmp___17, vmw_user_stream_size);
    ret = -12;
    goto out_unlock;
  }
  __cil_tmp54 = & res;
  __cil_tmp55 = (unsigned long )stream;
  __cil_tmp56 = __cil_tmp55 + 64UL;
  *__cil_tmp54 = (struct vmw_resource *)__cil_tmp56;
  __cil_tmp57 = 28;
  __cil_tmp58 = (unsigned long )stream;
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
  *((bool *)__cil_tmp59) = (bool )0;
  __cil_tmp60 = 32;
  __cil_tmp61 = (unsigned long )stream;
  __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
  __cil_tmp63 = (void *)0;
  *((struct ttm_object_file **)__cil_tmp62) = (struct ttm_object_file *)__cil_tmp63;
  __cil_tmp64 = (unsigned long )stream;
  __cil_tmp65 = __cil_tmp64 + 64UL;
  __cil_tmp66 = (struct vmw_stream *)__cil_tmp65;
  ret = vmw_stream_init(dev_priv, __cil_tmp66, & vmw_user_stream_free);
  __cil_tmp67 = ret != 0;
  __cil_tmp68 = ! __cil_tmp67;
  __cil_tmp69 = ! __cil_tmp68;
  __cil_tmp70 = (long )__cil_tmp69;
  tmp___19 = ldv__builtin_expect(__cil_tmp70, 0L);
  if (tmp___19) {
    goto out_unlock;
  }
  __cil_tmp71 = & tmp___8;
  __cil_tmp72 = & res;
  __cil_tmp73 = *__cil_tmp72;
  *__cil_tmp71 = vmw_resource_reference(__cil_tmp73);
  __cil_tmp74 = (struct ttm_base_object *)stream;
  __cil_tmp75 = (bool )0;
  __cil_tmp76 = (enum ttm_object_type )258;
  __cil_tmp77 = (void *)0;
  __cil_tmp78 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp77;
  ret = ttm_base_object_init(tfile, __cil_tmp74, __cil_tmp75, __cil_tmp76, & vmw_user_stream_base_release,
                             __cil_tmp78);
  __cil_tmp79 = ret != 0;
  __cil_tmp80 = ! __cil_tmp79;
  __cil_tmp81 = ! __cil_tmp80;
  __cil_tmp82 = (long )__cil_tmp81;
  tmp___20 = ldv__builtin_expect(__cil_tmp82, 0L);
  if (tmp___20) {
    vmw_resource_unreference(& tmp___8);
    goto out_err;
  }
  __cil_tmp83 = & res;
  __cil_tmp84 = *__cil_tmp83;
  __cil_tmp85 = (unsigned long )__cil_tmp84;
  __cil_tmp86 = __cil_tmp85 + 24UL;
  __cil_tmp87 = *((int *)__cil_tmp86);
  *((uint32_t *)arg) = (uint32_t )__cil_tmp87;
  out_err: 
  vmw_resource_unreference(& res);
  out_unlock: 
  __cil_tmp88 = (struct ttm_lock *)vmaster;
  ttm_read_unlock(__cil_tmp88);
  return (ret);
}
}
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  int ret ;
  long tmp___7 ;
  struct vmw_resource *__mptr ;
  struct vmw_resource **__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct idr *__cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_resource **__cil_tmp18 ;
  struct vmw_resource *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_resource **__cil_tmp26 ;
  struct vmw_resource *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void (*__cil_tmp30)(struct vmw_resource *res ) ;
  unsigned long __cil_tmp31 ;
  struct vmw_resource **__cil_tmp32 ;
  struct vmw_resource *__cil_tmp33 ;
  struct vmw_user_stream *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_resource *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct ttm_object_file *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct vmw_resource **__cil_tmp50 ;

  {
  __cil_tmp10 = & res;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2752UL;
  __cil_tmp13 = (struct idr *)__cil_tmp12;
  __cil_tmp14 = *inout_id;
  __cil_tmp15 = (int )__cil_tmp14;
  *__cil_tmp10 = vmw_resource_lookup(dev_priv, __cil_tmp13, __cil_tmp15);
  __cil_tmp16 = (void *)0;
  __cil_tmp17 = (unsigned long )__cil_tmp16;
  __cil_tmp18 = & res;
  __cil_tmp19 = *__cil_tmp18;
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = __cil_tmp20 == __cil_tmp17;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___7) {
    return (-22);
  }
  __cil_tmp25 = (unsigned long )(& vmw_user_stream_free);
  __cil_tmp26 = & res;
  __cil_tmp27 = *__cil_tmp26;
  __cil_tmp28 = (unsigned long )__cil_tmp27;
  __cil_tmp29 = __cil_tmp28 + 56UL;
  __cil_tmp30 = *((void (**)(struct vmw_resource *res ))__cil_tmp29);
  __cil_tmp31 = (unsigned long )__cil_tmp30;
  if (__cil_tmp31 != __cil_tmp25) {
    ret = -22;
    goto err_ref;
  }
  __cil_tmp32 = & res;
  __cil_tmp33 = *__cil_tmp32;
  __mptr = __cil_tmp33;
  __cil_tmp34 = (struct vmw_user_stream *)0;
  __cil_tmp35 = (unsigned long )__cil_tmp34;
  __cil_tmp36 = __cil_tmp35 + 64UL;
  __cil_tmp37 = (struct vmw_resource *)__cil_tmp36;
  __cil_tmp38 = (unsigned int )__cil_tmp37;
  __cil_tmp39 = (char *)__mptr;
  __cil_tmp40 = __cil_tmp39 - __cil_tmp38;
  stream = (struct vmw_user_stream *)__cil_tmp40;
  __cil_tmp41 = (unsigned long )tfile;
  __cil_tmp42 = 32;
  __cil_tmp43 = (unsigned long )stream;
  __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
  __cil_tmp45 = *((struct ttm_object_file **)__cil_tmp44);
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  if (__cil_tmp46 != __cil_tmp41) {
    ret = -1;
    goto err_ref;
  }
  __cil_tmp47 = 160;
  __cil_tmp48 = (unsigned long )stream;
  __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
  *inout_id = *((uint32_t *)__cil_tmp49);
  __cil_tmp50 = & res;
  *out = *__cil_tmp50;
  return (0);
  err_ref: 
  vmw_resource_unreference(& res);
  return (ret);
}
}
extern int ttm_tt_init(struct ttm_tt *ttm , struct ttm_bo_device *bdev , unsigned long size ,
                       uint32_t page_flags , struct page *dummy_read_page ) ;
extern void ttm_tt_fini(struct ttm_tt *ttm ) ;
extern struct ttm_mem_type_manager_func ttm_bo_manager_func ;
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) ;
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) ;
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) ;
struct ttm_placement vmw_vram_gmr_ne_placement ;
struct ttm_placement vmw_sys_placement ;
struct ttm_placement vmw_evictable_placement ;
struct ttm_mem_type_manager_func vmw_gmrid_manager_func ;
extern int ttm_pool_populate(struct ttm_tt *ttm ) ;
extern void ttm_pool_unpopulate(struct ttm_tt *ttm ) ;
static uint32_t vram_placement_flags  =    (uint32_t )((1 << 2) | (1 << 16));
static uint32_t vram_ne_placement_flags  =    (uint32_t )(((1 << 2) | (1 << 16)) | (1 << 21));
static uint32_t sys_placement_flags  =    (uint32_t )(1 | (1 << 16));
static uint32_t gmr_placement_flags  =    (uint32_t )((1 << 3) | (1 << 16));
static uint32_t gmr_ne_placement_flags  =    (uint32_t )(((1 << 3) | (1 << 16)) | (1 << 21));
struct ttm_placement vmw_vram_placement  =    {0U, 0U, 1U, & vram_placement_flags, 1U, & vram_placement_flags};
static uint32_t vram_gmr_placement_flags[2]  = {      (uint32_t )((1 << 2) | (1 << 16)),      (uint32_t )((1 << 3) | (1 << 16))};
static uint32_t gmr_vram_placement_flags[2]  = {      (uint32_t )((1 << 3) | (1 << 16)),      (uint32_t )((1 << 2) | (1 << 16))};
struct ttm_placement vmw_vram_gmr_placement  =    {0U, 0U, 2U, vram_gmr_placement_flags, 1U, & gmr_placement_flags};
static uint32_t vram_gmr_ne_placement_flags[2]  = {      (uint32_t )(((1 << 2) | (1 << 16)) | (1 << 21)),      (uint32_t )(((1 << 3) | (1 << 16)) | (1 << 21))};
struct ttm_placement vmw_vram_gmr_ne_placement  =    {0U, 0U, 2U, vram_gmr_ne_placement_flags, 1U, & gmr_ne_placement_flags};
struct ttm_placement vmw_vram_sys_placement  =    {0U, 0U, 1U, & vram_placement_flags, 1U, & sys_placement_flags};
struct ttm_placement vmw_vram_ne_placement  =    {0U, 0U, 1U, & vram_ne_placement_flags, 1U, & vram_ne_placement_flags};
struct ttm_placement vmw_sys_placement  =    {0U, 0U, 1U, & sys_placement_flags, 1U, & sys_placement_flags};
static uint32_t evictable_placement_flags[3]  = {      (uint32_t )(1 | (1 << 16)),      (uint32_t )((1 << 2) | (1 << 16)),      (uint32_t )((1 << 3) | (1 << 16))};
struct ttm_placement vmw_evictable_placement  =    {0U, 0U, 3U, evictable_placement_flags, 1U, & sys_placement_flags};
struct ttm_placement vmw_srf_placement  =    {0U, 0U, 1U, & gmr_placement_flags, 2U, gmr_vram_placement_flags};
static int vmw_ttm_bind(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt *__mptr ;
  int tmp___7 ;
  struct vmw_ttm_tt *__cil_tmp6 ;
  struct ttm_tt *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_private *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct page **__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;

  {
  __mptr = ttm;
  __cil_tmp6 = (struct vmw_ttm_tt *)0;
  __cil_tmp7 = (struct ttm_tt *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp10;
  __cil_tmp11 = (unsigned long )vmw_be;
  __cil_tmp12 = __cil_tmp11 + 88UL;
  __cil_tmp13 = (unsigned long )bo_mem;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((unsigned long *)__cil_tmp14);
  *((int *)__cil_tmp12) = (int )__cil_tmp15;
  __cil_tmp16 = (unsigned long )vmw_be;
  __cil_tmp17 = __cil_tmp16 + 80UL;
  __cil_tmp18 = *((struct vmw_private **)__cil_tmp17);
  __cil_tmp19 = (unsigned long )ttm;
  __cil_tmp20 = __cil_tmp19 + 24UL;
  __cil_tmp21 = *((struct page ***)__cil_tmp20);
  __cil_tmp22 = (unsigned long )ttm;
  __cil_tmp23 = __cil_tmp22 + 40UL;
  __cil_tmp24 = *((unsigned long *)__cil_tmp23);
  __cil_tmp25 = (unsigned long )vmw_be;
  __cil_tmp26 = __cil_tmp25 + 88UL;
  __cil_tmp27 = *((int *)__cil_tmp26);
  tmp___7 = vmw_gmr_bind(__cil_tmp18, __cil_tmp21, __cil_tmp24, __cil_tmp27);
  return (tmp___7);
}
}
static int vmw_ttm_unbind(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt *__mptr ;
  struct vmw_ttm_tt *__cil_tmp4 ;
  struct ttm_tt *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_private *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  __mptr = ttm;
  __cil_tmp4 = (struct vmw_ttm_tt *)0;
  __cil_tmp5 = (struct ttm_tt *)__cil_tmp4;
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = (char *)__mptr;
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp8;
  __cil_tmp9 = (unsigned long )vmw_be;
  __cil_tmp10 = __cil_tmp9 + 80UL;
  __cil_tmp11 = *((struct vmw_private **)__cil_tmp10);
  __cil_tmp12 = (unsigned long )vmw_be;
  __cil_tmp13 = __cil_tmp12 + 88UL;
  __cil_tmp14 = *((int *)__cil_tmp13);
  vmw_gmr_unbind(__cil_tmp11, __cil_tmp14);
  return (0);
}
}
static void vmw_ttm_destroy(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt *__mptr ;
  struct vmw_ttm_tt *__cil_tmp4 ;
  struct ttm_tt *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  __mptr = ttm;
  __cil_tmp4 = (struct vmw_ttm_tt *)0;
  __cil_tmp5 = (struct ttm_tt *)__cil_tmp4;
  __cil_tmp6 = (unsigned int )__cil_tmp5;
  __cil_tmp7 = (char *)__mptr;
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
  vmw_be = (struct vmw_ttm_tt *)__cil_tmp8;
  ttm_tt_fini(ttm);
  __cil_tmp9 = (void *)vmw_be;
  kfree(__cil_tmp9);
  return;
}
}
static struct ttm_backend_func vmw_ttm_func  =    {& vmw_ttm_bind, & vmw_ttm_unbind, & vmw_ttm_destroy};
struct ttm_tt *vmw_ttm_tt_create(struct ttm_bo_device *bdev , unsigned long size ,
                                 uint32_t page_flags , struct page *dummy_read_page ) 
{ struct vmw_ttm_tt *vmw_be ;
  void *tmp___7 ;
  struct ttm_bo_device *__mptr ;
  int tmp___8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_private *__cil_tmp15 ;
  struct ttm_bo_device *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct ttm_tt *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
  tmp___7 = kmalloc(96UL, 208U);
  vmw_be = (struct vmw_ttm_tt *)tmp___7;
  if (! vmw_be) {
    __cil_tmp9 = (void *)0;
    return ((struct ttm_tt *)__cil_tmp9);
  }
  __cil_tmp10 = 8;
  __cil_tmp11 = (unsigned long )vmw_be;
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
  *((struct ttm_backend_func **)__cil_tmp12) = & vmw_ttm_func;
  __mptr = bdev;
  __cil_tmp13 = (unsigned long )vmw_be;
  __cil_tmp14 = __cil_tmp13 + 80UL;
  __cil_tmp15 = (struct vmw_private *)0;
  __cil_tmp16 = (struct ttm_bo_device *)__cil_tmp15;
  __cil_tmp17 = (unsigned int )__cil_tmp16;
  __cil_tmp18 = (char *)__mptr;
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
  *((struct vmw_private **)__cil_tmp14) = (struct vmw_private *)__cil_tmp19;
  __cil_tmp20 = (struct ttm_tt *)vmw_be;
  tmp___8 = ttm_tt_init(__cil_tmp20, bdev, size, page_flags, dummy_read_page);
  if (tmp___8) {
    __cil_tmp21 = (void *)vmw_be;
    kfree(__cil_tmp21);
    __cil_tmp22 = (void *)0;
    return ((struct ttm_tt *)__cil_tmp22);
  }
  return ((struct ttm_tt *)vmw_be);
}
}
int vmw_invalidate_caches(struct ttm_bo_device *bdev , uint32_t flags ) 
{ 

  {
  return (0);
}
}
int vmw_init_mem_type(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;

  {
  if ((int )type == 0) {
    goto case_0;
  } else
  if ((int )type == 2) {
    goto case_2;
  } else
  if ((int )type == 3) {
    goto case_3;
  } else {
    goto switch_default;
    if (0) {
      case_0: 
      __cil_tmp4 = (unsigned long )man;
      __cil_tmp5 = __cil_tmp4 + 12UL;
      __cil_tmp6 = 1 << 1;
      *((uint32_t *)__cil_tmp5) = (uint32_t )__cil_tmp6;
      __cil_tmp7 = (unsigned long )man;
      __cil_tmp8 = __cil_tmp7 + 32UL;
      __cil_tmp9 = 1 << 16;
      *((uint32_t *)__cil_tmp8) = (uint32_t )__cil_tmp9;
      __cil_tmp10 = (unsigned long )man;
      __cil_tmp11 = __cil_tmp10 + 36UL;
      __cil_tmp12 = 1 << 16;
      *((uint32_t *)__cil_tmp11) = (uint32_t )__cil_tmp12;
      goto switch_break;
      case_2: 
      __cil_tmp13 = (unsigned long )man;
      __cil_tmp14 = __cil_tmp13 + 40UL;
      *((struct ttm_mem_type_manager_func **)__cil_tmp14) = & ttm_bo_manager_func;
      __cil_tmp15 = (unsigned long )man;
      __cil_tmp16 = __cil_tmp15 + 16UL;
      *((unsigned long *)__cil_tmp16) = 0UL;
      __cil_tmp17 = (unsigned long )man;
      __cil_tmp18 = __cil_tmp17 + 12UL;
      __cil_tmp19 = 1 << 1;
      __cil_tmp20 = 1 | __cil_tmp19;
      *((uint32_t *)__cil_tmp18) = (uint32_t )__cil_tmp20;
      __cil_tmp21 = (unsigned long )man;
      __cil_tmp22 = __cil_tmp21 + 32UL;
      __cil_tmp23 = 1 << 16;
      *((uint32_t *)__cil_tmp22) = (uint32_t )__cil_tmp23;
      __cil_tmp24 = (unsigned long )man;
      __cil_tmp25 = __cil_tmp24 + 36UL;
      __cil_tmp26 = 1 << 16;
      *((uint32_t *)__cil_tmp25) = (uint32_t )__cil_tmp26;
      goto switch_break;
      case_3: 
      __cil_tmp27 = (unsigned long )man;
      __cil_tmp28 = __cil_tmp27 + 40UL;
      *((struct ttm_mem_type_manager_func **)__cil_tmp28) = & vmw_gmrid_manager_func;
      __cil_tmp29 = (unsigned long )man;
      __cil_tmp30 = __cil_tmp29 + 16UL;
      *((unsigned long *)__cil_tmp30) = 0UL;
      __cil_tmp31 = (unsigned long )man;
      __cil_tmp32 = __cil_tmp31 + 12UL;
      __cil_tmp33 = 1 << 1;
      __cil_tmp34 = 1 << 3;
      __cil_tmp35 = __cil_tmp34 | __cil_tmp33;
      *((uint32_t *)__cil_tmp32) = (uint32_t )__cil_tmp35;
      __cil_tmp36 = (unsigned long )man;
      __cil_tmp37 = __cil_tmp36 + 32UL;
      __cil_tmp38 = 1 << 16;
      *((uint32_t *)__cil_tmp37) = (uint32_t )__cil_tmp38;
      __cil_tmp39 = (unsigned long )man;
      __cil_tmp40 = __cil_tmp39 + 36UL;
      __cil_tmp41 = 1 << 16;
      *((uint32_t *)__cil_tmp40) = (uint32_t )__cil_tmp41;
      goto switch_break;
      switch_default: 
      drm_err("vmw_init_mem_type", "Unsupported memory type %u\n", type);
      return (-22);
    } else {
      switch_break: ;
    }
  }
  return (0);
}
}
void vmw_evict_flags(struct ttm_buffer_object *bo , struct ttm_placement *placement ) 
{ struct ttm_placement *__cil_tmp3 ;

  {
  __cil_tmp3 = & vmw_sys_placement;
  *placement = *__cil_tmp3;
  return;
}
}
static int vmw_verify_access(struct ttm_buffer_object *bo , struct file *filp ) 
{ 

  {
  return (0);
}
}
static int vmw_ttm_io_mem_reserve(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ struct ttm_mem_type_manager *man ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device *__mptr ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct vmw_private *__cil_tmp13 ;
  struct ttm_bo_device *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;

  {
  __cil_tmp6 = (unsigned long )mem;
  __cil_tmp7 = __cil_tmp6 + 36UL;
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
  __cil_tmp9 = (unsigned long )__cil_tmp8 * 168UL;
  __cil_tmp10 = 56UL + __cil_tmp9;
  __cil_tmp11 = (unsigned long )bdev;
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
  man = (struct ttm_mem_type_manager *)__cil_tmp12;
  __mptr = bdev;
  __cil_tmp13 = (struct vmw_private *)0;
  __cil_tmp14 = (struct ttm_bo_device *)__cil_tmp13;
  __cil_tmp15 = (unsigned int )__cil_tmp14;
  __cil_tmp16 = (char *)__mptr;
  __cil_tmp17 = __cil_tmp16 - __cil_tmp15;
  dev_priv = (struct vmw_private *)__cil_tmp17;
  __cil_tmp18 = (unsigned long )mem;
  __cil_tmp19 = __cil_tmp18 + 48UL;
  *((void **)__cil_tmp19) = (void *)0;
  __cil_tmp20 = 80;
  __cil_tmp21 = (unsigned long )mem;
  __cil_tmp22 = __cil_tmp21 + __cil_tmp20;
  *((bool *)__cil_tmp22) = (bool )0;
  __cil_tmp23 = 72;
  __cil_tmp24 = (unsigned long )mem;
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
  *((unsigned long *)__cil_tmp25) = 0UL;
  __cil_tmp26 = 64;
  __cil_tmp27 = (unsigned long )mem;
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
  __cil_tmp29 = (unsigned long )mem;
  __cil_tmp30 = __cil_tmp29 + 24UL;
  __cil_tmp31 = *((unsigned long *)__cil_tmp30);
  *((unsigned long *)__cil_tmp28) = __cil_tmp31 << 12;
  __cil_tmp32 = 56;
  __cil_tmp33 = (unsigned long )mem;
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
  *((unsigned long *)__cil_tmp34) = 0UL;
  __cil_tmp35 = 1 << 1;
  __cil_tmp36 = (unsigned int )__cil_tmp35;
  __cil_tmp37 = (unsigned long )man;
  __cil_tmp38 = __cil_tmp37 + 12UL;
  __cil_tmp39 = *((uint32_t *)__cil_tmp38);
  __cil_tmp40 = __cil_tmp39 & __cil_tmp36;
  if (! __cil_tmp40) {
    return (-22);
  }
  __cil_tmp41 = (unsigned long )mem;
  __cil_tmp42 = __cil_tmp41 + 36UL;
  __cil_tmp43 = *((uint32_t *)__cil_tmp42);
  if ((int )__cil_tmp43 == 0) {
    goto case_0;
  } else
  if ((int )__cil_tmp43 == 3) {
    goto case_0;
  } else
  if ((int )__cil_tmp43 == 2) {
    goto case_2;
  } else {
    goto switch_default;
    if (0) {
      case_0: 
      return (0);
      case_2: 
      __cil_tmp44 = 72;
      __cil_tmp45 = (unsigned long )mem;
      __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
      __cil_tmp47 = (unsigned long )mem;
      __cil_tmp48 = __cil_tmp47 + 8UL;
      __cil_tmp49 = *((unsigned long *)__cil_tmp48);
      *((unsigned long *)__cil_tmp46) = __cil_tmp49 << 12;
      __cil_tmp50 = 56;
      __cil_tmp51 = (unsigned long )mem;
      __cil_tmp52 = __cil_tmp51 + __cil_tmp50;
      __cil_tmp53 = (unsigned long )dev_priv;
      __cil_tmp54 = __cil_tmp53 + 2108UL;
      __cil_tmp55 = *((uint32_t *)__cil_tmp54);
      *((unsigned long *)__cil_tmp52) = (unsigned long )__cil_tmp55;
      __cil_tmp56 = 80;
      __cil_tmp57 = (unsigned long )mem;
      __cil_tmp58 = __cil_tmp57 + __cil_tmp56;
      *((bool *)__cil_tmp58) = (bool )1;
      goto switch_break;
      switch_default: 
      return (-22);
    } else {
      switch_break: ;
    }
  }
  return (0);
}
}
static void vmw_ttm_io_mem_free(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 

  {
  return;
}
}
static int vmw_ttm_fault_reserve_notify(struct ttm_buffer_object *bo ) 
{ 

  {
  return (0);
}
}
static void *vmw_sync_obj_ref(void *sync_obj ) 
{ struct vmw_fence_obj *tmp___7 ;
  struct vmw_fence_obj *__cil_tmp3 ;

  {
  __cil_tmp3 = (struct vmw_fence_obj *)sync_obj;
  tmp___7 = vmw_fence_obj_reference(__cil_tmp3);
  return ((void *)tmp___7);
}
}
static void vmw_sync_obj_unref(void **sync_obj ) 
{ struct vmw_fence_obj **__cil_tmp2 ;

  {
  __cil_tmp2 = (struct vmw_fence_obj **)sync_obj;
  vmw_fence_obj_unreference(__cil_tmp2);
  return;
}
}
static int vmw_sync_obj_flush(void *sync_obj , void *sync_arg ) 
{ struct vmw_fence_obj *__cil_tmp3 ;

  {
  __cil_tmp3 = (struct vmw_fence_obj *)sync_obj;
  vmw_fence_obj_flush(__cil_tmp3);
  return (0);
}
}
static bool vmw_sync_obj_signaled(void *sync_obj , void *sync_arg ) 
{ unsigned long flags ;
  bool tmp___7 ;
  struct vmw_fence_obj *__cil_tmp5 ;
  uint32_t __cil_tmp6 ;

  {
  flags = (unsigned long )sync_arg;
  __cil_tmp5 = (struct vmw_fence_obj *)sync_obj;
  __cil_tmp6 = (uint32_t )flags;
  tmp___7 = vmw_fence_obj_signaled(__cil_tmp5, __cil_tmp6);
  return (tmp___7);
}
}
static int vmw_sync_obj_wait(void *sync_obj , void *sync_arg , bool lazy , bool interruptible ) 
{ unsigned long flags ;
  int tmp___7 ;
  struct vmw_fence_obj *__cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  flags = (unsigned long )sync_arg;
  __cil_tmp7 = (struct vmw_fence_obj *)sync_obj;
  __cil_tmp8 = (uint32_t )flags;
  tmp___7 = vmw_fence_obj_wait(__cil_tmp7, __cil_tmp8, lazy, interruptible, 1250UL);
  return (tmp___7);
}
}
struct ttm_bo_driver vmw_bo_driver  = 
     {& vmw_ttm_tt_create, & ttm_pool_populate, & ttm_pool_unpopulate, & vmw_invalidate_caches,
    & vmw_init_mem_type, & vmw_evict_flags, (int (*)(struct ttm_buffer_object *bo ,
                                                     bool evict , bool interruptible ,
                                                     bool no_wait_reserve , bool no_wait_gpu ,
                                                     struct ttm_mem_reg *new_mem ))((void *)0),
    & vmw_verify_access, & vmw_sync_obj_signaled, & vmw_sync_obj_wait, & vmw_sync_obj_flush,
    & vmw_sync_obj_unref, & vmw_sync_obj_ref, (void (*)(struct ttm_buffer_object *bo ,
                                                        struct ttm_mem_reg *new_mem ))((void *)0),
    & vmw_ttm_fault_reserve_notify, (void (*)(struct ttm_buffer_object *bo ))((void *)0),
    & vmw_ttm_io_mem_reserve, & vmw_ttm_io_mem_free};
void ldv_main7_sequence_infinite_withcheck_stateful(void) 
{ struct ttm_tt *var_group1 ;
  struct ttm_mem_reg *var_group2 ;
  struct ttm_bo_device *var_group3 ;
  uint32_t var_vmw_invalidate_caches_4_p1 ;
  uint32_t var_vmw_init_mem_type_5_p1 ;
  struct ttm_mem_type_manager *var_vmw_init_mem_type_5_p2 ;
  struct ttm_buffer_object *var_group4 ;
  struct ttm_placement *var_group5 ;
  struct file *var_group6 ;
  void *var_vmw_sync_obj_signaled_14_p0 ;
  void *var_vmw_sync_obj_signaled_14_p1 ;
  void *var_vmw_sync_obj_wait_15_p0 ;
  void *var_vmw_sync_obj_wait_15_p1 ;
  bool var_vmw_sync_obj_wait_15_p2 ;
  bool var_vmw_sync_obj_wait_15_p3 ;
  void *var_vmw_sync_obj_flush_13_p0 ;
  void *var_vmw_sync_obj_flush_13_p1 ;
  void **var_vmw_sync_obj_unref_12_p0 ;
  void *var_vmw_sync_obj_ref_11_p0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___8 = __VERIFIER_nondet_int();
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = __VERIFIER_nondet_int();
    if (tmp___7 == 0) {
      goto case_0;
    } else
    if (tmp___7 == 1) {
      goto case_1;
    } else
    if (tmp___7 == 2) {
      goto case_2;
    } else
    if (tmp___7 == 3) {
      goto case_3;
    } else
    if (tmp___7 == 4) {
      goto case_4;
    } else
    if (tmp___7 == 5) {
      goto case_5;
    } else
    if (tmp___7 == 6) {
      goto case_6;
    } else
    if (tmp___7 == 7) {
      goto case_7;
    } else
    if (tmp___7 == 8) {
      goto case_8;
    } else
    if (tmp___7 == 9) {
      goto case_9;
    } else
    if (tmp___7 == 10) {
      goto case_10;
    } else
    if (tmp___7 == 11) {
      goto case_11;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_ttm_bind(var_group1, var_group2);
        goto switch_break;
        case_1: 
        vmw_ttm_unbind(var_group1);
        goto switch_break;
        case_2: 
        vmw_ttm_destroy(var_group1);
        goto switch_break;
        case_3: 
        vmw_invalidate_caches(var_group3, var_vmw_invalidate_caches_4_p1);
        goto switch_break;
        case_4: 
        vmw_init_mem_type(var_group3, var_vmw_init_mem_type_5_p1, var_vmw_init_mem_type_5_p2);
        goto switch_break;
        case_5: 
        vmw_evict_flags(var_group4, var_group5);
        goto switch_break;
        case_6: 
        vmw_verify_access(var_group4, var_group6);
        goto switch_break;
        case_7: 
        vmw_sync_obj_signaled(var_vmw_sync_obj_signaled_14_p0, var_vmw_sync_obj_signaled_14_p1);
        goto switch_break;
        case_8: 
        vmw_sync_obj_wait(var_vmw_sync_obj_wait_15_p0, var_vmw_sync_obj_wait_15_p1,
                          var_vmw_sync_obj_wait_15_p2, var_vmw_sync_obj_wait_15_p3);
        goto switch_break;
        case_9: 
        vmw_sync_obj_flush(var_vmw_sync_obj_flush_13_p0, var_vmw_sync_obj_flush_13_p1);
        goto switch_break;
        case_10: 
        vmw_sync_obj_unref(var_vmw_sync_obj_unref_12_p0);
        goto switch_break;
        case_11: 
        vmw_sync_obj_ref(var_vmw_sync_obj_ref_11_p0);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: 
  ldv_check_final_state();
  return;
}
}
 static int variable_test_bit(int nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
 static int variable_test_bit(int nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
 static int variable_test_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;
  unsigned long *__cil_tmp4 ;

  {
  __cil_tmp4 = (unsigned long *)addr;
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*__cil_tmp4), "Ir" (nr));
  return (oldbit);
}
}
extern struct task_struct *current_task  __attribute__((__section__(".data..percpu"))) ;
 static struct task_struct *( __attribute__((__always_inline__)) get_current)(void)  __attribute__((__no_instrument_function__)) ;
 static struct task_struct *( __attribute__((__always_inline__)) get_current)(void)  __attribute__((__no_instrument_function__)) ;
 static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ struct task_struct *pfo_ret__ ;

  {
  if (1) {
    goto case_8;
  } else {
    goto switch_default;
    if (0) {
      __asm__  ("mov"
                "b "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=q" (pfo_ret__): "p" (& current_task));
      goto switch_break;
      __asm__  ("mov"
                "w "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
      goto switch_break;
      __asm__  ("mov"
                "l "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
      goto switch_break;
      case_8: 
      __asm__  ("mov"
                "q "
                "%%"
                "gs"
                ":"
                "%P"
                "1"
                ",%0": "=r" (pfo_ret__): "p" (& current_task));
      goto switch_break;
      switch_default: 
      __bad_percpu_size();
    } else {
      switch_break: ;
    }
  }
  return (pfo_ret__);
}
}
extern void __xadd_wrong_size(void) ;
 static int atomic_dec_and_test(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_dec_and_test(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;
  int __cil_tmp3 ;

  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".previous\n"
                       "671:"
                       "\n\tlock; "
                       "decl %0; sete %1": "+m" (*((int *)v)), "=qm" (c): : "memory");
  __cil_tmp3 = (int )c;
  return (__cil_tmp3 != 0);
}
}
 static int atomic_add_return(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_add_return(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
 static int atomic_add_return(int i , atomic_t *v ) 
{ int __ret ;

  {
  __ret = i;
  if (1) {
    goto case_4;
  } else {
    goto switch_default;
    if (0) {
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "b %b0, %1\n": "+q" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
      goto switch_break;
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "w %w0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
      goto switch_break;
      case_4: 
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "l %0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
      goto switch_break;
      __asm__  volatile   (".section .smp_locks,\"a\"\n"
                           ".balign 4\n"
                           ".long 671f - .\n"
                           ".previous\n"
                           "671:"
                           "\n\tlock; "
                           "xadd"
                           "q %q0, %1\n": "+r" (__ret), "+m" (*((int *)v)): : "memory",
                           "cc");
      goto switch_break;
      switch_default: 
      __xadd_wrong_size();
    } else {
      switch_break: ;
    }
  }
  return (i + __ret);
}
}
 static int test_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
 static int test_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
 static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp___0 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  __u32 *__cil_tmp7 ;
  unsigned long *__cil_tmp8 ;
  unsigned long volatile   *__cil_tmp9 ;

  {
  __cil_tmp5 = (unsigned long )ti;
  __cil_tmp6 = __cil_tmp5 + 16UL;
  __cil_tmp7 = (__u32 *)__cil_tmp6;
  __cil_tmp8 = (unsigned long *)__cil_tmp7;
  __cil_tmp9 = (unsigned long volatile   *)__cil_tmp8;
  tmp___0 = variable_test_bit(flag, __cil_tmp9);
  return (tmp___0);
}
}
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
extern void __init_rwsem(struct rw_semaphore *sem , char *name , struct lock_class_key *key ) ;
extern void down_write(struct rw_semaphore *sem ) ;
extern void up_write(struct rw_semaphore *sem ) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
 static void memcpy_toio(void volatile   *dst , void *src , size_t count )  __attribute__((__no_instrument_function__)) ;
 static void memcpy_toio(void volatile   *dst , void *src , size_t count )  __attribute__((__no_instrument_function__)) ;
 static void memcpy_toio(void volatile   *dst , void *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void *__cil_tmp6 ;

  {
  __len = count;
  __cil_tmp6 = (void *)dst;
  __ret = __builtin_memcpy(__cil_tmp6, src, __len);
  return;
}
}
extern long schedule_timeout(long timeout ) ;
 static int test_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
 static int test_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
 static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  struct thread_info *__cil_tmp7 ;

  {
  __cil_tmp4 = (unsigned long )tsk;
  __cil_tmp5 = __cil_tmp4 + 8UL;
  __cil_tmp6 = *((void **)__cil_tmp5);
  __cil_tmp7 = (struct thread_info *)__cil_tmp6;
  tmp___7 = test_ti_thread_flag(__cil_tmp7, flag);
  return (tmp___7);
}
}
 static int signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
 static int signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
 static int signal_pending(struct task_struct *p ) 
{ int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long __cil_tmp5 ;

  {
  tmp___7 = test_tsk_thread_flag(p, 2);
  if (tmp___7) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __cil_tmp5 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp5, 0L);
  return ((int )tmp___9);
}
}
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) ;
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) ;
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) ;
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t fifo_min ;
  uint32_t hwversion ;
  struct vmw_fifo_state *fifo ;
  int tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_fifo_state *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  __le32 *__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_screen_object_display *__cil_tmp29 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp8);
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 1856UL;
  __cil_tmp11 = (struct vmw_fifo_state *)__cil_tmp10;
  fifo = __cil_tmp11;
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2156UL;
  __cil_tmp14 = *((uint32_t *)__cil_tmp13);
  __cil_tmp15 = __cil_tmp14 & 32768U;
  if (! __cil_tmp15) {
    return ((bool )0);
  }
  __cil_tmp16 = fifo_mem + 0;
  __cil_tmp17 = (void *)__cil_tmp16;
  fifo_min = ioread32(__cil_tmp17);
  __cil_tmp18 = 28UL;
  __cil_tmp19 = (unsigned long )fifo_min;
  if (__cil_tmp19 <= __cil_tmp18) {
    return ((bool )0);
  }
  __cil_tmp20 = 1 << 8;
  __cil_tmp21 = (unsigned int )__cil_tmp20;
  __cil_tmp22 = (unsigned long )fifo;
  __cil_tmp23 = __cil_tmp22 + 36UL;
  __cil_tmp24 = *((uint32_t *)__cil_tmp23);
  if (__cil_tmp24 & __cil_tmp21) {
    tmp___7 = 17;
  } else {
    tmp___7 = 7;
  }
  __cil_tmp25 = fifo_mem + tmp___7;
  __cil_tmp26 = (void *)__cil_tmp25;
  hwversion = ioread32(__cil_tmp26);
  if (hwversion == 0U) {
    return ((bool )0);
  }
  if (hwversion < 131073U) {
    return ((bool )0);
  }
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 2616UL;
  __cil_tmp29 = *((struct vmw_screen_object_display **)__cil_tmp28);
  if (! __cil_tmp29) {
    return ((bool )0);
  }
  return ((bool )1);
}
}
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t caps ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  __le32 *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp5);
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2156UL;
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
  __cil_tmp9 = __cil_tmp8 & 32768U;
  if (! __cil_tmp9) {
    return ((bool )0);
  }
  __cil_tmp10 = fifo_mem + 4;
  __cil_tmp11 = (void *)__cil_tmp10;
  caps = ioread32(__cil_tmp11);
  __cil_tmp12 = 1 << 2;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  if (caps & __cil_tmp13) {
    return ((bool )1);
  }
  return ((bool )0);
}
}
static struct lock_class_key __key___13  ;
static struct lock_class_key __key___14  ;
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t dummy ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  int tmp___12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  __le32 *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct mutex *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct rw_semaphore *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct mutex *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  __le32 *__cil_tmp59 ;
  void *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint32_t __cil_tmp63 ;
  __le32 *__cil_tmp64 ;
  void *__cil_tmp65 ;
  __le32 *__cil_tmp66 ;
  void *__cil_tmp67 ;
  __le32 *__cil_tmp68 ;
  void *__cil_tmp69 ;
  u32 __cil_tmp70 ;
  __le32 *__cil_tmp71 ;
  void *__cil_tmp72 ;
  uint32_t __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct mutex *__cil_tmp76 ;
  __le32 *__cil_tmp77 ;
  void *__cil_tmp78 ;
  __le32 *__cil_tmp79 ;
  void *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  __le32 *__cil_tmp83 ;
  void *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  atomic_t *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  uint32_t __cil_tmp93 ;
  int __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  __le32 *__cil_tmp98 ;
  void *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct vmw_marker_queue *__cil_tmp102 ;

  {
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp14);
  __cil_tmp15 = (unsigned long )fifo;
  __cil_tmp16 = __cil_tmp15 + 24UL;
  *((unsigned long *)__cil_tmp16) = 1048576UL;
  __cil_tmp17 = (unsigned long )fifo;
  __cil_tmp18 = __cil_tmp17 + 24UL;
  __cil_tmp19 = *((unsigned long *)__cil_tmp18);
  tmp___7 = vmalloc(__cil_tmp19);
  __cil_tmp20 = (unsigned long )fifo;
  __cil_tmp21 = __cil_tmp20 + 16UL;
  *((__le32 **)__cil_tmp21) = (__le32 *)tmp___7;
  __cil_tmp22 = (void *)0;
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = (unsigned long )fifo;
  __cil_tmp25 = __cil_tmp24 + 16UL;
  __cil_tmp26 = *((__le32 **)__cil_tmp25);
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = __cil_tmp27 == __cil_tmp23;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 0L);
  if (tmp___8) {
    return (-12);
  }
  __cil_tmp32 = (unsigned long )fifo;
  __cil_tmp33 = __cil_tmp32 + 8UL;
  __cil_tmp34 = (void *)0;
  *((__le32 **)__cil_tmp33) = (__le32 *)__cil_tmp34;
  *((unsigned long *)fifo) = 0UL;
  __cil_tmp35 = (unsigned long )fifo;
  __cil_tmp36 = __cil_tmp35 + 32UL;
  *((bool *)__cil_tmp36) = (bool )0;
  while (1) {
    __cil_tmp37 = (unsigned long )fifo;
    __cil_tmp38 = __cil_tmp37 + 40UL;
    __cil_tmp39 = (struct mutex *)__cil_tmp38;
    __mutex_init(__cil_tmp39, "&fifo->fifo_mutex", & __key___13);
    goto while_break;
  }
  while_break: ;
  while (1) {
    __cil_tmp40 = (unsigned long )fifo;
    __cil_tmp41 = __cil_tmp40 + 112UL;
    __cil_tmp42 = (struct rw_semaphore *)__cil_tmp41;
    __init_rwsem(__cil_tmp42, "&fifo->rwsem", & __key___14);
    goto while_break___0;
  }
  while_break___0: 
  tmp___9 = vmw_read(dev_priv, 2U);
  printk("<6>[drm] width %d\n", tmp___9);
  tmp___10 = vmw_read(dev_priv, 3U);
  printk("<6>[drm] height %d\n", tmp___10);
  tmp___11 = vmw_read(dev_priv, 7U);
  printk("<6>[drm] bpp %d\n", tmp___11);
  __cil_tmp43 = (unsigned long )dev_priv;
  __cil_tmp44 = __cil_tmp43 + 2184UL;
  __cil_tmp45 = (struct mutex *)__cil_tmp44;
  mutex_lock(__cil_tmp45);
  __cil_tmp46 = (unsigned long )dev_priv;
  __cil_tmp47 = __cil_tmp46 + 3024UL;
  *((uint32_t *)__cil_tmp47) = vmw_read(dev_priv, 1U);
  __cil_tmp48 = (unsigned long )dev_priv;
  __cil_tmp49 = __cil_tmp48 + 3028UL;
  *((uint32_t *)__cil_tmp49) = vmw_read(dev_priv, 20U);
  __cil_tmp50 = (unsigned long )dev_priv;
  __cil_tmp51 = __cil_tmp50 + 3020UL;
  *((uint32_t *)__cil_tmp51) = vmw_read(dev_priv, 45U);
  __cil_tmp52 = (uint32_t )1;
  vmw_write(dev_priv, 1U, __cil_tmp52);
  min = (uint32_t )4;
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 2156UL;
  __cil_tmp55 = *((uint32_t *)__cil_tmp54);
  if (__cil_tmp55 & 32768U) {
    min = vmw_read(dev_priv, 30U);
  }
  min <<= 2;
  __cil_tmp56 = 1UL << 12;
  __cil_tmp57 = (unsigned long )min;
  if (__cil_tmp57 < __cil_tmp56) {
    __cil_tmp58 = 1UL << 12;
    min = (uint32_t )__cil_tmp58;
  }
  __cil_tmp59 = fifo_mem + 0;
  __cil_tmp60 = (void *)__cil_tmp59;
  iowrite32(min, __cil_tmp60);
  __cil_tmp61 = (unsigned long )dev_priv;
  __cil_tmp62 = __cil_tmp61 + 2120UL;
  __cil_tmp63 = *((uint32_t *)__cil_tmp62);
  __cil_tmp64 = fifo_mem + 1;
  __cil_tmp65 = (void *)__cil_tmp64;
  iowrite32(__cil_tmp63, __cil_tmp65);
  __asm__  volatile   ("sfence": : : "memory");
  __cil_tmp66 = fifo_mem + 2;
  __cil_tmp67 = (void *)__cil_tmp66;
  iowrite32(min, __cil_tmp67);
  __cil_tmp68 = fifo_mem + 3;
  __cil_tmp69 = (void *)__cil_tmp68;
  iowrite32(min, __cil_tmp69);
  __cil_tmp70 = (u32 )0;
  __cil_tmp71 = fifo_mem + 290;
  __cil_tmp72 = (void *)__cil_tmp71;
  iowrite32(__cil_tmp70, __cil_tmp72);
  __asm__  volatile   ("mfence": : : "memory");
  __cil_tmp73 = (uint32_t )1;
  vmw_write(dev_priv, 20U, __cil_tmp73);
  __cil_tmp74 = (unsigned long )dev_priv;
  __cil_tmp75 = __cil_tmp74 + 2184UL;
  __cil_tmp76 = (struct mutex *)__cil_tmp75;
  mutex_unlock(__cil_tmp76);
  __cil_tmp77 = fifo_mem + 1;
  __cil_tmp78 = (void *)__cil_tmp77;
  max = ioread32(__cil_tmp78);
  __cil_tmp79 = fifo_mem + 0;
  __cil_tmp80 = (void *)__cil_tmp79;
  min = ioread32(__cil_tmp80);
  __cil_tmp81 = (unsigned long )fifo;
  __cil_tmp82 = __cil_tmp81 + 36UL;
  __cil_tmp83 = fifo_mem + 4;
  __cil_tmp84 = (void *)__cil_tmp83;
  *((uint32_t *)__cil_tmp82) = ioread32(__cil_tmp84);
  __cil_tmp85 = (unsigned long )fifo;
  __cil_tmp86 = __cil_tmp85 + 36UL;
  __cil_tmp87 = *((uint32_t *)__cil_tmp86);
  printk("<6>[drm] Fifo max 0x%08x min 0x%08x cap 0x%08x\n", max, min, __cil_tmp87);
  __cil_tmp88 = (unsigned long )dev_priv;
  __cil_tmp89 = __cil_tmp88 + 2880UL;
  __cil_tmp90 = (atomic_t *)__cil_tmp89;
  __cil_tmp91 = (unsigned long )dev_priv;
  __cil_tmp92 = __cil_tmp91 + 2980UL;
  __cil_tmp93 = *((uint32_t *)__cil_tmp92);
  __cil_tmp94 = (int )__cil_tmp93;
  atomic_set(__cil_tmp90, __cil_tmp94);
  __cil_tmp95 = (unsigned long )dev_priv;
  __cil_tmp96 = __cil_tmp95 + 2980UL;
  __cil_tmp97 = *((uint32_t *)__cil_tmp96);
  __cil_tmp98 = fifo_mem + 6;
  __cil_tmp99 = (void *)__cil_tmp98;
  iowrite32(__cil_tmp97, __cil_tmp99);
  __cil_tmp100 = (unsigned long )fifo;
  __cil_tmp101 = __cil_tmp100 + 160UL;
  __cil_tmp102 = (struct vmw_marker_queue *)__cil_tmp101;
  vmw_marker_queue_init(__cil_tmp102);
  tmp___12 = vmw_fifo_send_fence(dev_priv, & dummy);
  return (tmp___12);
}
}
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) 
{ __le32 *fifo_mem ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  __le32 *__cil_tmp12 ;
  void *__cil_tmp13 ;
  long __cil_tmp14 ;
  u32 __cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct mutex *__cil_tmp20 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp8);
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2184UL;
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
  mutex_lock(__cil_tmp11);
  __cil_tmp12 = fifo_mem + 290;
  __cil_tmp13 = (void *)__cil_tmp12;
  tmp___7 = ioread32(__cil_tmp13);
  if (tmp___7 == 0U) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __cil_tmp14 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp___9) {
    __cil_tmp15 = (u32 )1;
    __cil_tmp16 = fifo_mem + 290;
    __cil_tmp17 = (void *)__cil_tmp16;
    iowrite32(__cil_tmp15, __cil_tmp17);
    vmw_write(dev_priv, 21U, reason);
  }
  __cil_tmp18 = (unsigned long )dev_priv;
  __cil_tmp19 = __cil_tmp18 + 2184UL;
  __cil_tmp20 = (struct mutex *)__cil_tmp19;
  mutex_unlock(__cil_tmp20);
  return;
}
}
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct mutex *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_marker_queue *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  __le32 *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  __le32 *__cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  __le32 *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  void *__cil_tmp65 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp8);
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2184UL;
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
  mutex_lock(__cil_tmp11);
  while (1) {
    tmp___7 = vmw_read(dev_priv, 22U);
    if (! (tmp___7 != 0U)) {
      goto while_break;
    }
    __cil_tmp12 = (uint32_t )1;
    vmw_write(dev_priv, 21U, __cil_tmp12);
  }
  while_break: 
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2980UL;
  __cil_tmp15 = fifo_mem + 6;
  __cil_tmp16 = (void *)__cil_tmp15;
  *((uint32_t *)__cil_tmp14) = ioread32(__cil_tmp16);
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 3028UL;
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
  vmw_write(dev_priv, 20U, __cil_tmp19);
  __cil_tmp20 = (unsigned long )dev_priv;
  __cil_tmp21 = __cil_tmp20 + 3024UL;
  __cil_tmp22 = *((uint32_t *)__cil_tmp21);
  vmw_write(dev_priv, 1U, __cil_tmp22);
  __cil_tmp23 = (unsigned long )dev_priv;
  __cil_tmp24 = __cil_tmp23 + 3020UL;
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
  vmw_write(dev_priv, 45U, __cil_tmp25);
  __cil_tmp26 = (unsigned long )dev_priv;
  __cil_tmp27 = __cil_tmp26 + 2184UL;
  __cil_tmp28 = (struct mutex *)__cil_tmp27;
  mutex_unlock(__cil_tmp28);
  __cil_tmp29 = (unsigned long )fifo;
  __cil_tmp30 = __cil_tmp29 + 160UL;
  __cil_tmp31 = (struct vmw_marker_queue *)__cil_tmp30;
  vmw_marker_queue_takedown(__cil_tmp31);
  __cil_tmp32 = (void *)0;
  __cil_tmp33 = (unsigned long )__cil_tmp32;
  __cil_tmp34 = (unsigned long )fifo;
  __cil_tmp35 = __cil_tmp34 + 16UL;
  __cil_tmp36 = *((__le32 **)__cil_tmp35);
  __cil_tmp37 = (unsigned long )__cil_tmp36;
  __cil_tmp38 = __cil_tmp37 != __cil_tmp33;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = ! __cil_tmp39;
  __cil_tmp41 = (long )__cil_tmp40;
  tmp___8 = ldv__builtin_expect(__cil_tmp41, 1L);
  if (tmp___8) {
    __cil_tmp42 = (unsigned long )fifo;
    __cil_tmp43 = __cil_tmp42 + 16UL;
    __cil_tmp44 = *((__le32 **)__cil_tmp43);
    __cil_tmp45 = (void *)__cil_tmp44;
    vfree(__cil_tmp45);
    __cil_tmp46 = (unsigned long )fifo;
    __cil_tmp47 = __cil_tmp46 + 16UL;
    __cil_tmp48 = (void *)0;
    *((__le32 **)__cil_tmp47) = (__le32 *)__cil_tmp48;
  }
  __cil_tmp49 = (void *)0;
  __cil_tmp50 = (unsigned long )__cil_tmp49;
  __cil_tmp51 = (unsigned long )fifo;
  __cil_tmp52 = __cil_tmp51 + 8UL;
  __cil_tmp53 = *((__le32 **)__cil_tmp52);
  __cil_tmp54 = (unsigned long )__cil_tmp53;
  __cil_tmp55 = __cil_tmp54 != __cil_tmp50;
  __cil_tmp56 = ! __cil_tmp55;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = (long )__cil_tmp57;
  tmp___9 = ldv__builtin_expect(__cil_tmp58, 1L);
  if (tmp___9) {
    __cil_tmp59 = (unsigned long )fifo;
    __cil_tmp60 = __cil_tmp59 + 8UL;
    __cil_tmp61 = *((__le32 **)__cil_tmp60);
    __cil_tmp62 = (void *)__cil_tmp61;
    vfree(__cil_tmp62);
    __cil_tmp63 = (unsigned long )fifo;
    __cil_tmp64 = __cil_tmp63 + 8UL;
    __cil_tmp65 = (void *)0;
    *((__le32 **)__cil_tmp64) = (__le32 *)__cil_tmp65;
  }
  return;
}
}
static bool vmw_fifo_is_full(struct vmw_private *dev_priv , uint32_t bytes ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  unsigned int tmp___7 ;
  uint32_t next_cmd ;
  unsigned int tmp___8 ;
  uint32_t min ;
  unsigned int tmp___9 ;
  uint32_t stop ;
  unsigned int tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  __le32 *__cil_tmp14 ;
  void *__cil_tmp15 ;
  __le32 *__cil_tmp16 ;
  void *__cil_tmp17 ;
  __le32 *__cil_tmp18 ;
  void *__cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  void *__cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp13);
  __cil_tmp14 = fifo_mem + 1;
  __cil_tmp15 = (void *)__cil_tmp14;
  tmp___7 = ioread32(__cil_tmp15);
  max = tmp___7;
  __cil_tmp16 = fifo_mem + 2;
  __cil_tmp17 = (void *)__cil_tmp16;
  tmp___8 = ioread32(__cil_tmp17);
  next_cmd = tmp___8;
  __cil_tmp18 = fifo_mem + 0;
  __cil_tmp19 = (void *)__cil_tmp18;
  tmp___9 = ioread32(__cil_tmp19);
  min = tmp___9;
  __cil_tmp20 = fifo_mem + 3;
  __cil_tmp21 = (void *)__cil_tmp20;
  tmp___10 = ioread32(__cil_tmp21);
  stop = tmp___10;
  __cil_tmp22 = stop - min;
  __cil_tmp23 = max - next_cmd;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = __cil_tmp24 <= bytes;
  return ((bool )__cil_tmp25);
}
}
static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                               unsigned long timeout ) 
{ int ret ;
  unsigned long end_jiffies ;
  wait_queue_t __wait ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  struct task_struct *tmp___10 ;
  int tmp___11 ;
  unsigned long volatile   __cil_tmp17 ;
  unsigned long volatile   __cil_tmp18 ;
  wait_queue_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  wait_queue_head_t *__cil_tmp29 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  wait_queue_head_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  wait_queue_head_t *__cil_tmp38 ;
  void *__cil_tmp39 ;

  {
  ret = 0;
  __cil_tmp17 = (unsigned long volatile   )timeout;
  __cil_tmp18 = jiffies + __cil_tmp17;
  end_jiffies = (unsigned long )__cil_tmp18;
  tmp___7 = get_current();
  __cil_tmp19 = & __wait;
  *((unsigned int *)__cil_tmp19) = 0U;
  __cil_tmp20 = (unsigned long )(& __wait) + 8UL;
  *((void **)__cil_tmp20) = (void *)tmp___7;
  __cil_tmp21 = (unsigned long )(& __wait) + 16UL;
  *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp21) = & autoremove_wake_function;
  __cil_tmp22 = (unsigned long )(& __wait) + 24UL;
  __cil_tmp23 = (unsigned long )(& __wait) + 24UL;
  *((struct list_head **)__cil_tmp22) = (struct list_head *)__cil_tmp23;
  __cil_tmp24 = 32;
  __cil_tmp25 = (unsigned long )(& __wait) + __cil_tmp24;
  __cil_tmp26 = (unsigned long )(& __wait) + 24UL;
  *((struct list_head **)__cil_tmp25) = (struct list_head *)__cil_tmp26;
  printk("<6>[drm] Fifo wait noirq.\n");
  while (1) {

    if (interruptible) {
      tmp___8 = 1;
    } else {
      tmp___8 = 2;
    }
    __cil_tmp27 = (unsigned long )dev_priv;
    __cil_tmp28 = __cil_tmp27 + 2928UL;
    __cil_tmp29 = (wait_queue_head_t *)__cil_tmp28;
    prepare_to_wait(__cil_tmp29, & __wait, tmp___8);
    tmp___9 = vmw_fifo_is_full(dev_priv, bytes);
    if (! tmp___9) {
      goto while_break;
    }
    __cil_tmp30 = (long )end_jiffies;
    __cil_tmp31 = (long )jiffies;
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
    if (__cil_tmp32 >= 0L) {
      ret = -16;
      drm_err("vmw_fifo_wait_noirq", "SVGA device lockup.\n");
      goto while_break;
    }
    schedule_timeout(1L);
    if (interruptible) {
      tmp___10 = get_current();
      tmp___11 = signal_pending(tmp___10);
      if (tmp___11) {
        ret = -512;
        goto while_break;
      }
    }
  }
  while_break: 
  __cil_tmp33 = (unsigned long )dev_priv;
  __cil_tmp34 = __cil_tmp33 + 2928UL;
  __cil_tmp35 = (wait_queue_head_t *)__cil_tmp34;
  finish_wait(__cil_tmp35, & __wait);
  __cil_tmp36 = (unsigned long )dev_priv;
  __cil_tmp37 = __cil_tmp36 + 2928UL;
  __cil_tmp38 = (wait_queue_head_t *)__cil_tmp37;
  __cil_tmp39 = (void *)0;
  __wake_up(__cil_tmp38, 3U, 0, __cil_tmp39);
  printk("<6>[drm] Fifo noirq exit.\n");
  return (ret);
}
}
static int vmw_fifo_wait(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                         unsigned long timeout ) 
{ long ret ;
  unsigned long irq_flags ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  raw_spinlock_t *tmp___11 ;
  int tmp___12 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___13 ;
  bool tmp___14 ;
  struct task_struct *tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  raw_spinlock_t *tmp___23 ;
  int tmp___24 ;
  long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct mutex *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  atomic_t *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  spinlock_t *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  uint32_t __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  spinlock_t *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct mutex *__cil_tmp66 ;
  wait_queue_t *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  wait_queue_head_t *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  wait_queue_head_t *__cil_tmp80 ;
  wait_queue_t *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  wait_queue_head_t *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  wait_queue_head_t *__cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  long __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  struct mutex *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  atomic_t *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  spinlock_t *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  uint32_t __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  uint32_t __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  spinlock_t *__cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  struct mutex *__cil_tmp125 ;

  {
  ret = 1L;
  tmp___7 = vmw_fifo_is_full(dev_priv, bytes);
  if (tmp___7) {
    tmp___8 = 0;
  } else {
    tmp___8 = 1;
  }
  __cil_tmp33 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp33, 1L);
  if (tmp___9) {
    return (0);
  }
  __cil_tmp34 = (uint32_t )2;
  vmw_fifo_ping_host(dev_priv, __cil_tmp34);
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2156UL;
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
  __cil_tmp38 = __cil_tmp37 & 262144U;
  if (! __cil_tmp38) {
    tmp___10 = vmw_fifo_wait_noirq(dev_priv, bytes, interruptible, timeout);
    return (tmp___10);
  }
  __cil_tmp39 = (unsigned long )dev_priv;
  __cil_tmp40 = __cil_tmp39 + 2184UL;
  __cil_tmp41 = (struct mutex *)__cil_tmp40;
  mutex_lock(__cil_tmp41);
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 2976UL;
  __cil_tmp44 = (atomic_t *)__cil_tmp43;
  tmp___12 = atomic_add_return(1, __cil_tmp44);
  if (tmp___12 > 0) {
    while (1) {

      while (1) {
        __cil_tmp45 = (unsigned long )dev_priv;
        __cil_tmp46 = __cil_tmp45 + 2984UL;
        __cil_tmp47 = (spinlock_t *)__cil_tmp46;
        tmp___11 = spinlock_check(__cil_tmp47);
        irq_flags = _raw_spin_lock_irqsave(tmp___11);
        goto while_break___0;
      }
      while_break___0: ;
      goto while_break;
    }
    while_break: 
    __cil_tmp48 = (unsigned long )dev_priv;
    __cil_tmp49 = __cil_tmp48 + 2104UL;
    __cil_tmp50 = *((unsigned int *)__cil_tmp49);
    __cil_tmp51 = __cil_tmp50 + 8U;
    __cil_tmp52 = (int )__cil_tmp51;
    outl(2U, __cil_tmp52);
    __cil_tmp53 = (unsigned long )dev_priv;
    __cil_tmp54 = __cil_tmp53 + 3016UL;
    __cil_tmp55 = (unsigned long )dev_priv;
    __cil_tmp56 = __cil_tmp55 + 3016UL;
    __cil_tmp57 = *((uint32_t *)__cil_tmp56);
    *((uint32_t *)__cil_tmp54) = __cil_tmp57 | 2U;
    __cil_tmp58 = (unsigned long )dev_priv;
    __cil_tmp59 = __cil_tmp58 + 3016UL;
    __cil_tmp60 = *((uint32_t *)__cil_tmp59);
    vmw_write(dev_priv, 33U, __cil_tmp60);
    __cil_tmp61 = (unsigned long )dev_priv;
    __cil_tmp62 = __cil_tmp61 + 2984UL;
    __cil_tmp63 = (spinlock_t *)__cil_tmp62;
    spin_unlock_irqrestore(__cil_tmp63, irq_flags);
  }
  __cil_tmp64 = (unsigned long )dev_priv;
  __cil_tmp65 = __cil_tmp64 + 2184UL;
  __cil_tmp66 = (struct mutex *)__cil_tmp65;
  mutex_unlock(__cil_tmp66);
  if (interruptible) {
    __ret = (long )timeout;
    tmp___17 = vmw_fifo_is_full(dev_priv, bytes);
    if (tmp___17) {
      while (1) {
        tmp___13 = get_current();
        __cil_tmp67 = & __wait;
        *((unsigned int *)__cil_tmp67) = 0U;
        __cil_tmp68 = (unsigned long )(& __wait) + 8UL;
        *((void **)__cil_tmp68) = (void *)tmp___13;
        __cil_tmp69 = (unsigned long )(& __wait) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp69) = & autoremove_wake_function;
        __cil_tmp70 = (unsigned long )(& __wait) + 24UL;
        __cil_tmp71 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp70) = (struct list_head *)__cil_tmp71;
        __cil_tmp72 = 32;
        __cil_tmp73 = (unsigned long )(& __wait) + __cil_tmp72;
        __cil_tmp74 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp73) = (struct list_head *)__cil_tmp74;
        while (1) {
          __cil_tmp75 = (unsigned long )dev_priv;
          __cil_tmp76 = __cil_tmp75 + 2928UL;
          __cil_tmp77 = (wait_queue_head_t *)__cil_tmp76;
          prepare_to_wait(__cil_tmp77, & __wait, 1);
          tmp___14 = vmw_fifo_is_full(dev_priv, bytes);
          if (! tmp___14) {
            goto while_break___2;
          }
          tmp___15 = get_current();
          tmp___16 = signal_pending(tmp___15);
          if (! tmp___16) {
            __ret = schedule_timeout(__ret);
            if (! __ret) {
              goto while_break___2;
            }
            goto __Cont;
          }
          __ret = -512L;
          goto while_break___2;
          __Cont: ;
        }
        while_break___2: 
        __cil_tmp78 = (unsigned long )dev_priv;
        __cil_tmp79 = __cil_tmp78 + 2928UL;
        __cil_tmp80 = (wait_queue_head_t *)__cil_tmp79;
        finish_wait(__cil_tmp80, & __wait);
        goto while_break___1;
      }
      while_break___1: ;
    }
    ret = __ret;
  } else {
    __ret___0 = (long )timeout;
    tmp___20 = vmw_fifo_is_full(dev_priv, bytes);
    if (tmp___20) {
      while (1) {
        tmp___18 = get_current();
        __cil_tmp81 = & __wait___0;
        *((unsigned int *)__cil_tmp81) = 0U;
        __cil_tmp82 = (unsigned long )(& __wait___0) + 8UL;
        *((void **)__cil_tmp82) = (void *)tmp___18;
        __cil_tmp83 = (unsigned long )(& __wait___0) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp83) = & autoremove_wake_function;
        __cil_tmp84 = (unsigned long )(& __wait___0) + 24UL;
        __cil_tmp85 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp84) = (struct list_head *)__cil_tmp85;
        __cil_tmp86 = 32;
        __cil_tmp87 = (unsigned long )(& __wait___0) + __cil_tmp86;
        __cil_tmp88 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp87) = (struct list_head *)__cil_tmp88;
        while (1) {
          __cil_tmp89 = (unsigned long )dev_priv;
          __cil_tmp90 = __cil_tmp89 + 2928UL;
          __cil_tmp91 = (wait_queue_head_t *)__cil_tmp90;
          prepare_to_wait(__cil_tmp91, & __wait___0, 2);
          tmp___19 = vmw_fifo_is_full(dev_priv, bytes);
          if (! tmp___19) {
            goto while_break___4;
          }
          __ret___0 = schedule_timeout(__ret___0);
          if (! __ret___0) {
            goto while_break___4;
          }
        }
        while_break___4: 
        __cil_tmp92 = (unsigned long )dev_priv;
        __cil_tmp93 = __cil_tmp92 + 2928UL;
        __cil_tmp94 = (wait_queue_head_t *)__cil_tmp93;
        finish_wait(__cil_tmp94, & __wait___0);
        goto while_break___3;
      }
      while_break___3: ;
    }
    ret = __ret___0;
  }
  __cil_tmp95 = ret == 0L;
  __cil_tmp96 = ! __cil_tmp95;
  __cil_tmp97 = ! __cil_tmp96;
  __cil_tmp98 = (long )__cil_tmp97;
  tmp___22 = ldv__builtin_expect(__cil_tmp98, 0L);
  if (tmp___22) {
    ret = -16L;
  } else {
    __cil_tmp99 = ret > 0L;
    __cil_tmp100 = ! __cil_tmp99;
    __cil_tmp101 = ! __cil_tmp100;
    __cil_tmp102 = (long )__cil_tmp101;
    tmp___21 = ldv__builtin_expect(__cil_tmp102, 1L);
    if (tmp___21) {
      ret = 0L;
    }
  }
  __cil_tmp103 = (unsigned long )dev_priv;
  __cil_tmp104 = __cil_tmp103 + 2184UL;
  __cil_tmp105 = (struct mutex *)__cil_tmp104;
  mutex_lock(__cil_tmp105);
  __cil_tmp106 = (unsigned long )dev_priv;
  __cil_tmp107 = __cil_tmp106 + 2976UL;
  __cil_tmp108 = (atomic_t *)__cil_tmp107;
  tmp___24 = atomic_dec_and_test(__cil_tmp108);
  if (tmp___24) {
    while (1) {

      while (1) {
        __cil_tmp109 = (unsigned long )dev_priv;
        __cil_tmp110 = __cil_tmp109 + 2984UL;
        __cil_tmp111 = (spinlock_t *)__cil_tmp110;
        tmp___23 = spinlock_check(__cil_tmp111);
        irq_flags = _raw_spin_lock_irqsave(tmp___23);
        goto while_break___6;
      }
      while_break___6: ;
      goto while_break___5;
    }
    while_break___5: 
    __cil_tmp112 = (unsigned long )dev_priv;
    __cil_tmp113 = __cil_tmp112 + 3016UL;
    __cil_tmp114 = (unsigned long )dev_priv;
    __cil_tmp115 = __cil_tmp114 + 3016UL;
    __cil_tmp116 = *((uint32_t *)__cil_tmp115);
    *((uint32_t *)__cil_tmp113) = __cil_tmp116 & 4294967293U;
    __cil_tmp117 = (unsigned long )dev_priv;
    __cil_tmp118 = __cil_tmp117 + 3016UL;
    __cil_tmp119 = *((uint32_t *)__cil_tmp118);
    vmw_write(dev_priv, 33U, __cil_tmp119);
    __cil_tmp120 = (unsigned long )dev_priv;
    __cil_tmp121 = __cil_tmp120 + 2984UL;
    __cil_tmp122 = (spinlock_t *)__cil_tmp121;
    spin_unlock_irqrestore(__cil_tmp122, irq_flags);
  }
  __cil_tmp123 = (unsigned long )dev_priv;
  __cil_tmp124 = __cil_tmp123 + 2184UL;
  __cil_tmp125 = (struct mutex *)__cil_tmp124;
  mutex_unlock(__cil_tmp125);
  return ((int )ret);
}
}
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t next_cmd ;
  uint32_t reserveable ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  uint32_t stop ;
  unsigned int tmp___10 ;
  bool need_bounce ;
  bool reserve_in_place ;
  long tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  void *tmp___17 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct mutex *__cil_tmp35 ;
  __le32 *__cil_tmp36 ;
  void *__cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  void *__cil_tmp39 ;
  __le32 *__cil_tmp40 ;
  void *__cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  long __cil_tmp51 ;
  void *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  __le32 *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  __le32 *__cil_tmp62 ;
  void *__cil_tmp63 ;
  uint32_t __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  long __cil_tmp66 ;
  bool __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  long __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  bool __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  __le32 *__cil_tmp85 ;
  void *__cil_tmp86 ;
  uint32_t __cil_tmp87 ;
  __le32 *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  __le32 *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  __le32 *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct mutex *__cil_tmp106 ;

  {
  __cil_tmp24 = (unsigned long )dev_priv;
  __cil_tmp25 = __cil_tmp24 + 1856UL;
  fifo_state = (struct vmw_fifo_state *)__cil_tmp25;
  __cil_tmp26 = (unsigned long )dev_priv;
  __cil_tmp27 = __cil_tmp26 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp27);
  __cil_tmp28 = 1 << 6;
  __cil_tmp29 = (unsigned int )__cil_tmp28;
  __cil_tmp30 = (unsigned long )fifo_state;
  __cil_tmp31 = __cil_tmp30 + 36UL;
  __cil_tmp32 = *((uint32_t *)__cil_tmp31);
  reserveable = __cil_tmp32 & __cil_tmp29;
  __cil_tmp33 = (unsigned long )fifo_state;
  __cil_tmp34 = __cil_tmp33 + 40UL;
  __cil_tmp35 = (struct mutex *)__cil_tmp34;
  mutex_lock(__cil_tmp35);
  __cil_tmp36 = fifo_mem + 1;
  __cil_tmp37 = (void *)__cil_tmp36;
  max = ioread32(__cil_tmp37);
  __cil_tmp38 = fifo_mem + 0;
  __cil_tmp39 = (void *)__cil_tmp38;
  min = ioread32(__cil_tmp39);
  __cil_tmp40 = fifo_mem + 2;
  __cil_tmp41 = (void *)__cil_tmp40;
  next_cmd = ioread32(__cil_tmp41);
  __cil_tmp42 = max - min;
  __cil_tmp43 = bytes >= __cil_tmp42;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = (long )__cil_tmp45;
  tmp___7 = ldv__builtin_expect(__cil_tmp46, 0L);
  if (tmp___7) {
    goto out_err;
  }
  while (1) {
    __cil_tmp47 = *((unsigned long *)fifo_state);
    __cil_tmp48 = __cil_tmp47 != 0UL;
    __cil_tmp49 = ! __cil_tmp48;
    __cil_tmp50 = ! __cil_tmp49;
    __cil_tmp51 = (long )__cil_tmp50;
    tmp___8 = ldv__builtin_expect(__cil_tmp51, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (316), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  while (1) {
    __cil_tmp52 = (void *)0;
    __cil_tmp53 = (unsigned long )__cil_tmp52;
    __cil_tmp54 = (unsigned long )fifo_state;
    __cil_tmp55 = __cil_tmp54 + 8UL;
    __cil_tmp56 = *((__le32 **)__cil_tmp55);
    __cil_tmp57 = (unsigned long )__cil_tmp56;
    __cil_tmp58 = __cil_tmp57 != __cil_tmp53;
    __cil_tmp59 = ! __cil_tmp58;
    __cil_tmp60 = ! __cil_tmp59;
    __cil_tmp61 = (long )__cil_tmp60;
    tmp___9 = ldv__builtin_expect(__cil_tmp61, 0L);
    if (tmp___9) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (317), "i" (12UL));
        while (1) {

        }

        goto while_break___3;
      }
      while_break___3: ;
    }
    goto while_break___2;
  }
  while_break___2: 
  *((unsigned long *)fifo_state) = (unsigned long )bytes;
  while (1) {
    __cil_tmp62 = fifo_mem + 3;
    __cil_tmp63 = (void *)__cil_tmp62;
    tmp___10 = ioread32(__cil_tmp63);
    stop = tmp___10;
    need_bounce = (bool )0;
    reserve_in_place = (bool )0;
    if (next_cmd >= stop) {
      __cil_tmp64 = next_cmd + bytes;
      if (__cil_tmp64 < max) {
        tmp___13 = 1;
      } else {
        __cil_tmp65 = next_cmd + bytes;
        if (__cil_tmp65 == max) {
          if (stop > min) {
            tmp___13 = 1;
          } else {
            tmp___13 = 0;
          }
        } else {
          tmp___13 = 0;
        }
      }
      __cil_tmp66 = (long )tmp___13;
      tmp___14 = ldv__builtin_expect(__cil_tmp66, 1L);
      if (tmp___14) {
        reserve_in_place = (bool )1;
      } else {
        tmp___12 = vmw_fifo_is_full(dev_priv, bytes);
        if (tmp___12) {
          __cil_tmp67 = (bool )0;
          ret = vmw_fifo_wait(dev_priv, bytes, __cil_tmp67, 750UL);
          __cil_tmp68 = ret != 0;
          __cil_tmp69 = ! __cil_tmp68;
          __cil_tmp70 = ! __cil_tmp69;
          __cil_tmp71 = (long )__cil_tmp70;
          tmp___11 = ldv__builtin_expect(__cil_tmp71, 0L);
          if (tmp___11) {
            goto out_err;
          }
        } else {
          need_bounce = (bool )1;
        }
      }
    } else {
      __cil_tmp72 = next_cmd + bytes;
      __cil_tmp73 = __cil_tmp72 < stop;
      __cil_tmp74 = ! __cil_tmp73;
      __cil_tmp75 = ! __cil_tmp74;
      __cil_tmp76 = (long )__cil_tmp75;
      tmp___16 = ldv__builtin_expect(__cil_tmp76, 1L);
      if (tmp___16) {
        reserve_in_place = (bool )1;
      } else {
        __cil_tmp77 = (bool )0;
        ret = vmw_fifo_wait(dev_priv, bytes, __cil_tmp77, 750UL);
        __cil_tmp78 = ret != 0;
        __cil_tmp79 = ! __cil_tmp78;
        __cil_tmp80 = ! __cil_tmp79;
        __cil_tmp81 = (long )__cil_tmp80;
        tmp___15 = ldv__builtin_expect(__cil_tmp81, 0L);
        if (tmp___15) {
          goto out_err;
        }
      }
    }
    if (reserve_in_place) {
      if (reserveable) {
        goto _L;
      } else {
        __cil_tmp82 = (unsigned long )bytes;
        if (__cil_tmp82 <= 4UL) {
          _L: 
          __cil_tmp83 = (unsigned long )fifo_state;
          __cil_tmp84 = __cil_tmp83 + 32UL;
          *((bool *)__cil_tmp84) = (bool )0;
          if (reserveable) {
            __cil_tmp85 = fifo_mem + 14;
            __cil_tmp86 = (void *)__cil_tmp85;
            iowrite32(bytes, __cil_tmp86);
          }
          __cil_tmp87 = next_cmd >> 2;
          __cil_tmp88 = fifo_mem + __cil_tmp87;
          return ((void *)__cil_tmp88);
        } else {
          need_bounce = (bool )1;
        }
      }
    }
    if (need_bounce) {
      __cil_tmp89 = (unsigned long )fifo_state;
      __cil_tmp90 = __cil_tmp89 + 32UL;
      *((bool *)__cil_tmp90) = (bool )1;
      __cil_tmp91 = (unsigned long )fifo_state;
      __cil_tmp92 = __cil_tmp91 + 24UL;
      __cil_tmp93 = *((unsigned long *)__cil_tmp92);
      __cil_tmp94 = (unsigned long )bytes;
      if (__cil_tmp94 < __cil_tmp93) {
        __cil_tmp95 = (unsigned long )fifo_state;
        __cil_tmp96 = __cil_tmp95 + 16UL;
        __cil_tmp97 = *((__le32 **)__cil_tmp96);
        return ((void *)__cil_tmp97);
      } else {
        __cil_tmp98 = (unsigned long )bytes;
        tmp___17 = vmalloc(__cil_tmp98);
        __cil_tmp99 = (unsigned long )fifo_state;
        __cil_tmp100 = __cil_tmp99 + 8UL;
        *((__le32 **)__cil_tmp100) = (__le32 *)tmp___17;
        __cil_tmp101 = (unsigned long )fifo_state;
        __cil_tmp102 = __cil_tmp101 + 8UL;
        __cil_tmp103 = *((__le32 **)__cil_tmp102);
        return ((void *)__cil_tmp103);
      }
    }
  }

  out_err: 
  *((unsigned long *)fifo_state) = 0UL;
  __cil_tmp104 = (unsigned long )fifo_state;
  __cil_tmp105 = __cil_tmp104 + 40UL;
  __cil_tmp106 = (struct mutex *)__cil_tmp105;
  mutex_unlock(__cil_tmp106);
  return ((void *)0);
}
}
static void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                              uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t chunk_size ;
  uint32_t rest ;
  uint32_t *buffer ;
  __le32 *tmp___7 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  __le32 *__cil_tmp21 ;
  void *__cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  __le32 *__cil_tmp24 ;
  void volatile   *__cil_tmp25 ;
  void *__cil_tmp26 ;
  size_t __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  __le32 *__cil_tmp29 ;
  void volatile   *__cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t *__cil_tmp32 ;
  void *__cil_tmp33 ;
  size_t __cil_tmp34 ;

  {
  chunk_size = max - next_cmd;
  __cil_tmp11 = (void *)0;
  __cil_tmp12 = (unsigned long )__cil_tmp11;
  __cil_tmp13 = (unsigned long )fifo_state;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((__le32 **)__cil_tmp14);
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  if (__cil_tmp16 != __cil_tmp12) {
    __cil_tmp17 = (unsigned long )fifo_state;
    __cil_tmp18 = __cil_tmp17 + 8UL;
    tmp___7 = *((__le32 **)__cil_tmp18);
  } else {
    __cil_tmp19 = (unsigned long )fifo_state;
    __cil_tmp20 = __cil_tmp19 + 16UL;
    tmp___7 = *((__le32 **)__cil_tmp20);
  }
  buffer = tmp___7;
  if (bytes < chunk_size) {
    chunk_size = bytes;
  }
  __cil_tmp21 = fifo_mem + 14;
  __cil_tmp22 = (void *)__cil_tmp21;
  iowrite32(bytes, __cil_tmp22);
  __asm__  volatile   ("mfence": : : "memory");
  __cil_tmp23 = next_cmd >> 2;
  __cil_tmp24 = fifo_mem + __cil_tmp23;
  __cil_tmp25 = (void volatile   *)__cil_tmp24;
  __cil_tmp26 = (void *)buffer;
  __cil_tmp27 = (size_t )chunk_size;
  memcpy_toio(__cil_tmp25, __cil_tmp26, __cil_tmp27);
  rest = bytes - chunk_size;
  if (rest) {
    __cil_tmp28 = min >> 2;
    __cil_tmp29 = fifo_mem + __cil_tmp28;
    __cil_tmp30 = (void volatile   *)__cil_tmp29;
    __cil_tmp31 = chunk_size >> 2;
    __cil_tmp32 = buffer + __cil_tmp31;
    __cil_tmp33 = (void *)__cil_tmp32;
    __cil_tmp34 = (size_t )rest;
    memcpy_toio(__cil_tmp30, __cil_tmp33, __cil_tmp34);
  }
  return;
}
}
static void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                               uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t *buffer ;
  __le32 *tmp___7 ;
  uint32_t *tmp___8 ;
  long tmp___9 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __le32 *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  __le32 *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;

  {
  __cil_tmp11 = (void *)0;
  __cil_tmp12 = (unsigned long )__cil_tmp11;
  __cil_tmp13 = (unsigned long )fifo_state;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((__le32 **)__cil_tmp14);
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  if (__cil_tmp16 != __cil_tmp12) {
    __cil_tmp17 = (unsigned long )fifo_state;
    __cil_tmp18 = __cil_tmp17 + 8UL;
    tmp___7 = *((__le32 **)__cil_tmp18);
  } else {
    __cil_tmp19 = (unsigned long )fifo_state;
    __cil_tmp20 = __cil_tmp19 + 16UL;
    tmp___7 = *((__le32 **)__cil_tmp20);
  }
  buffer = tmp___7;
  while (1) {

    if (! (bytes > 0U)) {
      goto while_break;
    }
    tmp___8 = buffer;
    buffer ++;
    __cil_tmp21 = *tmp___8;
    __cil_tmp22 = next_cmd >> 2;
    __cil_tmp23 = fifo_mem + __cil_tmp22;
    __cil_tmp24 = (void *)__cil_tmp23;
    iowrite32(__cil_tmp21, __cil_tmp24);
    __cil_tmp25 = (unsigned long )next_cmd;
    __cil_tmp26 = __cil_tmp25 + 4UL;
    next_cmd = (uint32_t )__cil_tmp26;
    __cil_tmp27 = next_cmd == max;
    __cil_tmp28 = ! __cil_tmp27;
    __cil_tmp29 = ! __cil_tmp28;
    __cil_tmp30 = (long )__cil_tmp29;
    tmp___9 = ldv__builtin_expect(__cil_tmp30, 0L);
    if (tmp___9) {
      next_cmd = min;
    }
    __asm__  volatile   ("mfence": : : "memory");
    __cil_tmp31 = fifo_mem + 2;
    __cil_tmp32 = (void *)__cil_tmp31;
    iowrite32(next_cmd, __cil_tmp32);
    __asm__  volatile   ("mfence": : : "memory");
    __cil_tmp33 = (unsigned long )bytes;
    __cil_tmp34 = __cil_tmp33 - 4UL;
    bytes = (uint32_t )__cil_tmp34;
  }
  while_break: ;
  return;
}
}
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t next_cmd ;
  unsigned int tmp___7 ;
  uint32_t max ;
  unsigned int tmp___8 ;
  uint32_t min ;
  unsigned int tmp___9 ;
  bool reserveable ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  __le32 *__cil_tmp18 ;
  void *__cil_tmp19 ;
  __le32 *__cil_tmp20 ;
  void *__cil_tmp21 ;
  __le32 *__cil_tmp22 ;
  void *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  __le32 *__cil_tmp47 ;
  void *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  void *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct rw_semaphore *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  __le32 *__cil_tmp58 ;
  void *__cil_tmp59 ;
  u32 __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct rw_semaphore *__cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct mutex *__cil_tmp69 ;

  {
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 1856UL;
  fifo_state = (struct vmw_fifo_state *)__cil_tmp15;
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp17);
  __cil_tmp18 = fifo_mem + 2;
  __cil_tmp19 = (void *)__cil_tmp18;
  tmp___7 = ioread32(__cil_tmp19);
  next_cmd = tmp___7;
  __cil_tmp20 = fifo_mem + 1;
  __cil_tmp21 = (void *)__cil_tmp20;
  tmp___8 = ioread32(__cil_tmp21);
  max = tmp___8;
  __cil_tmp22 = fifo_mem + 0;
  __cil_tmp23 = (void *)__cil_tmp22;
  tmp___9 = ioread32(__cil_tmp23);
  min = tmp___9;
  __cil_tmp24 = 1 << 6;
  __cil_tmp25 = (unsigned int )__cil_tmp24;
  __cil_tmp26 = (unsigned long )fifo_state;
  __cil_tmp27 = __cil_tmp26 + 36UL;
  __cil_tmp28 = *((uint32_t *)__cil_tmp27);
  __cil_tmp29 = __cil_tmp28 & __cil_tmp25;
  reserveable = (bool )__cil_tmp29;
  while (1) {
    __cil_tmp30 = bytes & 3U;
    __cil_tmp31 = __cil_tmp30 != 0U;
    __cil_tmp32 = ! __cil_tmp31;
    __cil_tmp33 = ! __cil_tmp32;
    __cil_tmp34 = (long )__cil_tmp33;
    tmp___10 = ldv__builtin_expect(__cil_tmp34, 0L);
    if (tmp___10) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (431), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  while (1) {
    __cil_tmp35 = *((unsigned long *)fifo_state);
    __cil_tmp36 = (unsigned long )bytes;
    __cil_tmp37 = __cil_tmp36 > __cil_tmp35;
    __cil_tmp38 = ! __cil_tmp37;
    __cil_tmp39 = ! __cil_tmp38;
    __cil_tmp40 = (long )__cil_tmp39;
    tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
    if (tmp___11) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c"),
                             "i" (432), "i" (12UL));
        while (1) {

        }

        goto while_break___3;
      }
      while_break___3: ;
    }
    goto while_break___2;
  }
  while_break___2: 
  *((unsigned long *)fifo_state) = 0UL;
  __cil_tmp41 = (unsigned long )fifo_state;
  __cil_tmp42 = __cil_tmp41 + 32UL;
  if (*((bool *)__cil_tmp42)) {
    if (reserveable) {
      vmw_fifo_res_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    } else {
      vmw_fifo_slow_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    }
    __cil_tmp43 = (unsigned long )fifo_state;
    __cil_tmp44 = __cil_tmp43 + 8UL;
    if (*((__le32 **)__cil_tmp44)) {
      __cil_tmp45 = (unsigned long )fifo_state;
      __cil_tmp46 = __cil_tmp45 + 8UL;
      __cil_tmp47 = *((__le32 **)__cil_tmp46);
      __cil_tmp48 = (void *)__cil_tmp47;
      vfree(__cil_tmp48);
      __cil_tmp49 = (unsigned long )fifo_state;
      __cil_tmp50 = __cil_tmp49 + 8UL;
      __cil_tmp51 = (void *)0;
      *((__le32 **)__cil_tmp50) = (__le32 *)__cil_tmp51;
    }
  }
  __cil_tmp52 = (unsigned long )fifo_state;
  __cil_tmp53 = __cil_tmp52 + 112UL;
  __cil_tmp54 = (struct rw_semaphore *)__cil_tmp53;
  down_write(__cil_tmp54);
  __cil_tmp55 = (unsigned long )fifo_state;
  __cil_tmp56 = __cil_tmp55 + 32UL;
  if (*((bool *)__cil_tmp56)) {
    goto _L;
  } else
  if (reserveable) {
    _L: 
    next_cmd += bytes;
    if (next_cmd >= max) {
      __cil_tmp57 = max - min;
      next_cmd -= __cil_tmp57;
    }
    __asm__  volatile   ("mfence": : : "memory");
    __cil_tmp58 = fifo_mem + 2;
    __cil_tmp59 = (void *)__cil_tmp58;
    iowrite32(next_cmd, __cil_tmp59);
  }
  if (reserveable) {
    __cil_tmp60 = (u32 )0;
    __cil_tmp61 = fifo_mem + 14;
    __cil_tmp62 = (void *)__cil_tmp61;
    iowrite32(__cil_tmp60, __cil_tmp62);
  }
  __asm__  volatile   ("mfence": : : "memory");
  __cil_tmp63 = (unsigned long )fifo_state;
  __cil_tmp64 = __cil_tmp63 + 112UL;
  __cil_tmp65 = (struct rw_semaphore *)__cil_tmp64;
  up_write(__cil_tmp65);
  __cil_tmp66 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp66);
  __cil_tmp67 = (unsigned long )fifo_state;
  __cil_tmp68 = __cil_tmp67 + 40UL;
  __cil_tmp69 = (struct mutex *)__cil_tmp68;
  mutex_unlock(__cil_tmp69);
  return;
}
}
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  struct svga_fifo_cmd_fence *cmd_fence ;
  void *fm ;
  int ret ;
  uint32_t bytes ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  atomic_t *__cil_tmp23 ;
  atomic_t *__cil_tmp24 ;
  bool __cil_tmp25 ;
  bool __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  bool __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  atomic_t *__cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  __le32 *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  __le32 *__cil_tmp42 ;
  void *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct vmw_marker_queue *__cil_tmp46 ;
  uint32_t __cil_tmp47 ;

  {
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 1856UL;
  fifo_state = (struct vmw_fifo_state *)__cil_tmp12;
  ret = 0;
  __cil_tmp13 = 8UL;
  bytes = (uint32_t )__cil_tmp13;
  fm = vmw_fifo_reserve(dev_priv, bytes);
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = (unsigned long )fm;
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___8) {
    __cil_tmp21 = (unsigned long )dev_priv;
    __cil_tmp22 = __cil_tmp21 + 2880UL;
    __cil_tmp23 = (atomic_t *)__cil_tmp22;
    __cil_tmp24 = __cil_tmp23;
    tmp___7 = atomic_read(__cil_tmp24);
    *seqno = (uint32_t )tmp___7;
    ret = -12;
    __cil_tmp25 = (bool )0;
    __cil_tmp26 = (bool )1;
    __cil_tmp27 = *seqno;
    __cil_tmp28 = (bool )0;
    vmw_fallback_wait(dev_priv, __cil_tmp25, __cil_tmp26, __cil_tmp27, __cil_tmp28,
                      750UL);
    goto out_err;
  }
  while (1) {
    __cil_tmp29 = (unsigned long )dev_priv;
    __cil_tmp30 = __cil_tmp29 + 2880UL;
    __cil_tmp31 = (atomic_t *)__cil_tmp30;
    tmp___9 = atomic_add_return(1, __cil_tmp31);
    *seqno = (uint32_t )tmp___9;
    __cil_tmp32 = *seqno;
    if (! (__cil_tmp32 == 0U)) {
      goto while_break;
    }
  }
  while_break: 
  __cil_tmp33 = (unsigned long )fifo_state;
  __cil_tmp34 = __cil_tmp33 + 36UL;
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
  __cil_tmp36 = __cil_tmp35 & 1U;
  if (! __cil_tmp36) {
    __cil_tmp37 = (uint32_t )0;
    vmw_fifo_commit(dev_priv, __cil_tmp37);
    return (0);
  }
  __cil_tmp38 = (__le32 *)fm;
  *__cil_tmp38 = (__u32 )30;
  __cil_tmp39 = (unsigned long )fm;
  __cil_tmp40 = __cil_tmp39 + 4UL;
  cmd_fence = (struct svga_fifo_cmd_fence *)__cil_tmp40;
  __cil_tmp41 = *seqno;
  __cil_tmp42 = (__le32 *)cmd_fence;
  __cil_tmp43 = (void *)__cil_tmp42;
  iowrite32(__cil_tmp41, __cil_tmp43);
  vmw_fifo_commit(dev_priv, bytes);
  __cil_tmp44 = (unsigned long )fifo_state;
  __cil_tmp45 = __cil_tmp44 + 160UL;
  __cil_tmp46 = (struct vmw_marker_queue *)__cil_tmp45;
  __cil_tmp47 = *seqno;
  vmw_marker_push(__cil_tmp46, __cil_tmp47);
  vmw_update_seqno(dev_priv, fifo_state);
  out_err: 
  return (ret);
}
}
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) 
{ struct ttm_buffer_object *bo ;
  struct __anonstruct_cmd_429___2 *cmd ;
  void *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  uint32_t __cil_tmp50 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 134744UL;
  bo = *((struct ttm_buffer_object **)__cil_tmp8);
  __cil_tmp9 = (uint32_t )24UL;
  tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp9);
  cmd = (struct __anonstruct_cmd_429___2 *)tmp___7;
  __cil_tmp10 = (void *)0;
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = (unsigned long )cmd;
  __cil_tmp13 = __cil_tmp12 == __cil_tmp11;
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = (long )__cil_tmp15;
  tmp___8 = ldv__builtin_expect(__cil_tmp16, 0L);
  if (tmp___8) {
    drm_err("vmw_fifo_emit_dummy_query", "Out of fifo space for dummy query.\n");
    return (-12);
  }
  *((uint32 *)cmd) = (uint32 )1067;
  __cil_tmp17 = 4;
  __cil_tmp18 = (unsigned long )cmd;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  *((uint32 *)__cil_tmp19) = (uint32 )16UL;
  __cil_tmp20 = (unsigned long )cmd;
  __cil_tmp21 = __cil_tmp20 + 8UL;
  *((uint32 *)__cil_tmp21) = cid;
  __cil_tmp22 = 12;
  __cil_tmp23 = (unsigned long )cmd;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  *((SVGA3dQueryType *)__cil_tmp24) = (SVGA3dQueryType )0;
  __cil_tmp25 = 148;
  __cil_tmp26 = (unsigned long )bo;
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
  __cil_tmp28 = *((uint32_t *)__cil_tmp27);
  if (__cil_tmp28 == 2U) {
    __cil_tmp29 = 16;
    __cil_tmp30 = (unsigned long )cmd;
    __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
    *((uint32 *)__cil_tmp31) = (uint32 )-2;
    __cil_tmp32 = 12;
    __cil_tmp33 = 8UL + __cil_tmp32;
    __cil_tmp34 = (unsigned long )cmd;
    __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
    __cil_tmp36 = (unsigned long )bo;
    __cil_tmp37 = __cil_tmp36 + 368UL;
    __cil_tmp38 = *((unsigned long *)__cil_tmp37);
    *((uint32 *)__cil_tmp35) = (uint32 )__cil_tmp38;
  } else {
    __cil_tmp39 = 16;
    __cil_tmp40 = (unsigned long )cmd;
    __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
    __cil_tmp42 = 120;
    __cil_tmp43 = (unsigned long )bo;
    __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
    __cil_tmp45 = *((unsigned long *)__cil_tmp44);
    *((uint32 *)__cil_tmp41) = (uint32 )__cil_tmp45;
    __cil_tmp46 = 12;
    __cil_tmp47 = 8UL + __cil_tmp46;
    __cil_tmp48 = (unsigned long )cmd;
    __cil_tmp49 = __cil_tmp48 + __cil_tmp47;
    *((uint32 *)__cil_tmp49) = (uint32 )0;
  }
  __cil_tmp50 = (uint32_t )24UL;
  vmw_fifo_commit(dev_priv, __cil_tmp50);
  return (0);
}
}
extern void down_read(struct rw_semaphore *sem ) ;
extern void up_read(struct rw_semaphore *sem ) ;
extern void schedule(void) ;
void vmw_fences_update(struct vmw_fence_manager *fman ) ;
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) ;
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) ;
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) ;
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) ;
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) ;
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) ;
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) ;
irqreturn_t vmw_irq_handler(int irq , void *arg ) 
{ struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  uint32_t masked_status ;
  long tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct vmw_fence_manager *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  wait_queue_head_t *__cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  wait_queue_head_t *__cil_tmp40 ;
  void *__cil_tmp41 ;

  {
  dev = (struct drm_device *)arg;
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2984UL;
  __cil_tmp11 = (spinlock_t *)__cil_tmp10;
  spin_lock(__cil_tmp11);
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2104UL;
  __cil_tmp14 = *((unsigned int *)__cil_tmp13);
  __cil_tmp15 = __cil_tmp14 + 8U;
  __cil_tmp16 = (int )__cil_tmp15;
  status = inl(__cil_tmp16);
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 3016UL;
  __cil_tmp19 = *((uint32_t *)__cil_tmp18);
  masked_status = status & __cil_tmp19;
  __cil_tmp20 = (unsigned long )dev_priv;
  __cil_tmp21 = __cil_tmp20 + 2984UL;
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
  spin_unlock(__cil_tmp22);
  __cil_tmp23 = ! status;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = (long )__cil_tmp24;
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 1L);
  if (tmp___8) {
    __cil_tmp26 = (unsigned long )dev_priv;
    __cil_tmp27 = __cil_tmp26 + 2104UL;
    __cil_tmp28 = *((unsigned int *)__cil_tmp27);
    __cil_tmp29 = __cil_tmp28 + 8U;
    __cil_tmp30 = (int )__cil_tmp29;
    outl(status, __cil_tmp30);
  }
  if (! masked_status) {
    return ((irqreturn_t )0);
  }
  if (masked_status & 5U) {
    __cil_tmp31 = (unsigned long )dev_priv;
    __cil_tmp32 = __cil_tmp31 + 3008UL;
    __cil_tmp33 = *((struct vmw_fence_manager **)__cil_tmp32);
    vmw_fences_update(__cil_tmp33);
    __cil_tmp34 = (unsigned long )dev_priv;
    __cil_tmp35 = __cil_tmp34 + 2888UL;
    __cil_tmp36 = (wait_queue_head_t *)__cil_tmp35;
    __cil_tmp37 = (void *)0;
    __wake_up(__cil_tmp36, 3U, 0, __cil_tmp37);
  }
  if (masked_status & 2U) {
    __cil_tmp38 = (unsigned long )dev_priv;
    __cil_tmp39 = __cil_tmp38 + 2928UL;
    __cil_tmp40 = (wait_queue_head_t *)__cil_tmp39;
    __cil_tmp41 = (void *)0;
    __wake_up(__cil_tmp40, 3U, 0, __cil_tmp41);
  }
  return ((irqreturn_t )1);
}
}
static bool vmw_fifo_idle(struct vmw_private *dev_priv , uint32_t seqno ) 
{ uint32_t busy ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct mutex *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  __cil_tmp4 = (unsigned long )dev_priv;
  __cil_tmp5 = __cil_tmp4 + 2184UL;
  __cil_tmp6 = (struct mutex *)__cil_tmp5;
  mutex_lock(__cil_tmp6);
  busy = vmw_read(dev_priv, 22U);
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2184UL;
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
  mutex_unlock(__cil_tmp9);
  __cil_tmp10 = busy == 0U;
  return ((bool )__cil_tmp10);
}
}
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) 
{ __le32 *fifo_mem ;
  uint32_t seqno ;
  unsigned int tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  __le32 *__cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_marker_queue *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_fence_manager *__cil_tmp20 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp7);
  __cil_tmp8 = fifo_mem + 6;
  __cil_tmp9 = (void *)__cil_tmp8;
  tmp___7 = ioread32(__cil_tmp9);
  seqno = tmp___7;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2980UL;
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
  if (__cil_tmp12 != seqno) {
    __cil_tmp13 = (unsigned long )dev_priv;
    __cil_tmp14 = __cil_tmp13 + 2980UL;
    *((uint32_t *)__cil_tmp14) = seqno;
    __cil_tmp15 = (unsigned long )fifo_state;
    __cil_tmp16 = __cil_tmp15 + 160UL;
    __cil_tmp17 = (struct vmw_marker_queue *)__cil_tmp16;
    vmw_marker_pull(__cil_tmp17, seqno);
    __cil_tmp18 = (unsigned long )dev_priv;
    __cil_tmp19 = __cil_tmp18 + 3008UL;
    __cil_tmp20 = *((struct vmw_fence_manager **)__cil_tmp19);
    vmw_fences_update(__cil_tmp20);
  }
  return;
}
}
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  bool ret ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  atomic_t *__cil_tmp37 ;
  atomic_t *__cil_tmp38 ;
  int __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  int __cil_tmp43 ;

  {
  __cil_tmp9 = 1 << 24;
  __cil_tmp10 = (uint32_t )__cil_tmp9;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2980UL;
  __cil_tmp13 = *((uint32_t *)__cil_tmp12);
  __cil_tmp14 = __cil_tmp13 - seqno;
  __cil_tmp15 = __cil_tmp14 < __cil_tmp10;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 1L);
  if (tmp___7) {
    return ((bool )1);
  }
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 1856UL;
  fifo_state = (struct vmw_fifo_state *)__cil_tmp20;
  vmw_update_seqno(dev_priv, fifo_state);
  __cil_tmp21 = 1 << 24;
  __cil_tmp22 = (uint32_t )__cil_tmp21;
  __cil_tmp23 = (unsigned long )dev_priv;
  __cil_tmp24 = __cil_tmp23 + 2980UL;
  __cil_tmp25 = *((uint32_t *)__cil_tmp24);
  __cil_tmp26 = __cil_tmp25 - seqno;
  __cil_tmp27 = __cil_tmp26 < __cil_tmp22;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = (long )__cil_tmp29;
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 1L);
  if (tmp___8) {
    return ((bool )1);
  }
  __cil_tmp31 = (unsigned long )fifo_state;
  __cil_tmp32 = __cil_tmp31 + 36UL;
  __cil_tmp33 = *((uint32_t *)__cil_tmp32);
  __cil_tmp34 = __cil_tmp33 & 1U;
  if (! __cil_tmp34) {
    tmp___9 = vmw_fifo_idle(dev_priv, seqno);
    if (tmp___9) {
      return ((bool )1);
    }
  }
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2880UL;
  __cil_tmp37 = (atomic_t *)__cil_tmp36;
  __cil_tmp38 = __cil_tmp37;
  tmp___10 = atomic_read(__cil_tmp38);
  __cil_tmp39 = 1 << 24;
  __cil_tmp40 = (uint32_t )__cil_tmp39;
  __cil_tmp41 = (uint32_t )tmp___10;
  __cil_tmp42 = __cil_tmp41 - seqno;
  __cil_tmp43 = __cil_tmp42 > __cil_tmp40;
  ret = (bool )__cil_tmp43;
  return (ret);
}
}
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) 
{ struct vmw_fifo_state *fifo_state ;
  uint32_t count ;
  uint32_t signal_seq ;
  int ret ;
  unsigned long end_jiffies ;
  bool (*wait_condition)(struct vmw_private * , uint32_t  ) ;
  wait_queue_t __wait ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  int tmp___14 ;
  __le32 *fifo_mem ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long volatile   __cil_tmp29 ;
  unsigned long volatile   __cil_tmp30 ;
  wait_queue_t *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct rw_semaphore *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  atomic_t *__cil_tmp44 ;
  atomic_t *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  wait_queue_head_t *__cil_tmp48 ;
  long __cil_tmp49 ;
  long __cil_tmp50 ;
  long __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  wait_queue_head_t *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  __le32 *__cil_tmp58 ;
  void *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  wait_queue_head_t *__cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct rw_semaphore *__cil_tmp66 ;

  {
  __cil_tmp27 = (unsigned long )dev_priv;
  __cil_tmp28 = __cil_tmp27 + 1856UL;
  fifo_state = (struct vmw_fifo_state *)__cil_tmp28;
  count = (uint32_t )0;
  __cil_tmp29 = (unsigned long volatile   )timeout;
  __cil_tmp30 = jiffies + __cil_tmp29;
  end_jiffies = (unsigned long )__cil_tmp30;
  tmp___7 = get_current();
  __cil_tmp31 = & __wait;
  *((unsigned int *)__cil_tmp31) = 0U;
  __cil_tmp32 = (unsigned long )(& __wait) + 8UL;
  *((void **)__cil_tmp32) = (void *)tmp___7;
  __cil_tmp33 = (unsigned long )(& __wait) + 16UL;
  *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp33) = & autoremove_wake_function;
  __cil_tmp34 = (unsigned long )(& __wait) + 24UL;
  __cil_tmp35 = (unsigned long )(& __wait) + 24UL;
  *((struct list_head **)__cil_tmp34) = (struct list_head *)__cil_tmp35;
  __cil_tmp36 = 32;
  __cil_tmp37 = (unsigned long )(& __wait) + __cil_tmp36;
  __cil_tmp38 = (unsigned long )(& __wait) + 24UL;
  *((struct list_head **)__cil_tmp37) = (struct list_head *)__cil_tmp38;
  if (fifo_idle) {
    wait_condition = & vmw_fifo_idle;
  } else {
    wait_condition = & vmw_seqno_passed;
  }
  if (fifo_idle) {
    __cil_tmp39 = (unsigned long )fifo_state;
    __cil_tmp40 = __cil_tmp39 + 112UL;
    __cil_tmp41 = (struct rw_semaphore *)__cil_tmp40;
    down_read(__cil_tmp41);
  }
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 2880UL;
  __cil_tmp44 = (atomic_t *)__cil_tmp43;
  __cil_tmp45 = __cil_tmp44;
  tmp___8 = atomic_read(__cil_tmp45);
  signal_seq = (uint32_t )tmp___8;
  ret = 0;
  while (1) {

    if (interruptible) {
      tmp___9 = 1;
    } else {
      tmp___9 = 2;
    }
    __cil_tmp46 = (unsigned long )dev_priv;
    __cil_tmp47 = __cil_tmp46 + 2888UL;
    __cil_tmp48 = (wait_queue_head_t *)__cil_tmp47;
    prepare_to_wait(__cil_tmp48, & __wait, tmp___9);
    tmp___10 = (*wait_condition)(dev_priv, seqno);
    if (tmp___10) {
      goto while_break;
    }
    __cil_tmp49 = (long )end_jiffies;
    __cil_tmp50 = (long )jiffies;
    __cil_tmp51 = __cil_tmp50 - __cil_tmp49;
    if (__cil_tmp51 >= 0L) {
      drm_err("vmw_fallback_wait", "SVGA device lockup.\n");
      goto while_break;
    }
    if (lazy) {
      schedule_timeout(1L);
    } else {
      count ++;
      __cil_tmp52 = count & 15U;
      if (__cil_tmp52 == 0U) {
        while (1) {
          tmp___11 = get_current();
          *((long volatile   *)tmp___11) = (long volatile   )0;
          goto while_break___0;
        }
        while_break___0: 
        schedule();
        while (1) {
          tmp___12 = get_current();
          if (interruptible) {
            *((long volatile   *)tmp___12) = (long volatile   )1;
          } else {
            *((long volatile   *)tmp___12) = (long volatile   )2;
          }
          goto while_break___1;
        }
        while_break___1: ;
      }
    }
    if (interruptible) {
      tmp___13 = get_current();
      tmp___14 = signal_pending(tmp___13);
      if (tmp___14) {
        ret = -512;
        goto while_break;
      }
    }
  }
  while_break: 
  __cil_tmp53 = (unsigned long )dev_priv;
  __cil_tmp54 = __cil_tmp53 + 2888UL;
  __cil_tmp55 = (wait_queue_head_t *)__cil_tmp54;
  finish_wait(__cil_tmp55, & __wait);
  if (ret == 0) {
    if (fifo_idle) {
      __cil_tmp56 = (unsigned long )dev_priv;
      __cil_tmp57 = __cil_tmp56 + 2144UL;
      fifo_mem = *((__le32 **)__cil_tmp57);
      __cil_tmp58 = fifo_mem + 6;
      __cil_tmp59 = (void *)__cil_tmp58;
      iowrite32(signal_seq, __cil_tmp59);
    }
  }
  __cil_tmp60 = (unsigned long )dev_priv;
  __cil_tmp61 = __cil_tmp60 + 2888UL;
  __cil_tmp62 = (wait_queue_head_t *)__cil_tmp61;
  __cil_tmp63 = (void *)0;
  __wake_up(__cil_tmp62, 3U, 0, __cil_tmp63);
  if (fifo_idle) {
    __cil_tmp64 = (unsigned long )fifo_state;
    __cil_tmp65 = __cil_tmp64 + 112UL;
    __cil_tmp66 = (struct rw_semaphore *)__cil_tmp65;
    up_read(__cil_tmp66);
  }
  return (ret);
}
}
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2184UL;
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
  mutex_lock(__cil_tmp9);
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2968UL;
  tmp___8 = *((int *)__cil_tmp11);
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2968UL;
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 2968UL;
  __cil_tmp16 = *((int *)__cil_tmp15);
  *((int *)__cil_tmp13) = __cil_tmp16 + 1;
  if (tmp___8 == 0) {
    while (1) {

      while (1) {
        __cil_tmp17 = (unsigned long )dev_priv;
        __cil_tmp18 = __cil_tmp17 + 2984UL;
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
        tmp___7 = spinlock_check(__cil_tmp19);
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        goto while_break___0;
      }
      while_break___0: ;
      goto while_break;
    }
    while_break: 
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 2104UL;
    __cil_tmp22 = *((unsigned int *)__cil_tmp21);
    __cil_tmp23 = __cil_tmp22 + 8U;
    __cil_tmp24 = (int )__cil_tmp23;
    outl(1U, __cil_tmp24);
    __cil_tmp25 = (unsigned long )dev_priv;
    __cil_tmp26 = __cil_tmp25 + 3016UL;
    __cil_tmp27 = (unsigned long )dev_priv;
    __cil_tmp28 = __cil_tmp27 + 3016UL;
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
    *((uint32_t *)__cil_tmp26) = __cil_tmp29 | 1U;
    __cil_tmp30 = (unsigned long )dev_priv;
    __cil_tmp31 = __cil_tmp30 + 3016UL;
    __cil_tmp32 = *((uint32_t *)__cil_tmp31);
    vmw_write(dev_priv, 33U, __cil_tmp32);
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 2984UL;
    __cil_tmp35 = (spinlock_t *)__cil_tmp34;
    spin_unlock_irqrestore(__cil_tmp35, irq_flags);
  }
  __cil_tmp36 = (unsigned long )dev_priv;
  __cil_tmp37 = __cil_tmp36 + 2184UL;
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
  mutex_unlock(__cil_tmp38);
  return;
}
}
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2184UL;
  __cil_tmp8 = (struct mutex *)__cil_tmp7;
  mutex_lock(__cil_tmp8);
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2968UL;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2968UL;
  __cil_tmp13 = *((int *)__cil_tmp12);
  *((int *)__cil_tmp10) = __cil_tmp13 - 1;
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 2968UL;
  __cil_tmp16 = *((int *)__cil_tmp15);
  if (__cil_tmp16 == 0) {
    while (1) {

      while (1) {
        __cil_tmp17 = (unsigned long )dev_priv;
        __cil_tmp18 = __cil_tmp17 + 2984UL;
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
        tmp___7 = spinlock_check(__cil_tmp19);
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        goto while_break___0;
      }
      while_break___0: ;
      goto while_break;
    }
    while_break: 
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 3016UL;
    __cil_tmp22 = (unsigned long )dev_priv;
    __cil_tmp23 = __cil_tmp22 + 3016UL;
    __cil_tmp24 = *((uint32_t *)__cil_tmp23);
    *((uint32_t *)__cil_tmp21) = __cil_tmp24 & 4294967294U;
    __cil_tmp25 = (unsigned long )dev_priv;
    __cil_tmp26 = __cil_tmp25 + 3016UL;
    __cil_tmp27 = *((uint32_t *)__cil_tmp26);
    vmw_write(dev_priv, 33U, __cil_tmp27);
    __cil_tmp28 = (unsigned long )dev_priv;
    __cil_tmp29 = __cil_tmp28 + 2984UL;
    __cil_tmp30 = (spinlock_t *)__cil_tmp29;
    spin_unlock_irqrestore(__cil_tmp30, irq_flags);
  }
  __cil_tmp31 = (unsigned long )dev_priv;
  __cil_tmp32 = __cil_tmp31 + 2184UL;
  __cil_tmp33 = (struct mutex *)__cil_tmp32;
  mutex_unlock(__cil_tmp33);
  return;
}
}
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct mutex *__cil_tmp38 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2184UL;
  __cil_tmp9 = (struct mutex *)__cil_tmp8;
  mutex_lock(__cil_tmp9);
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2972UL;
  tmp___8 = *((int *)__cil_tmp11);
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2972UL;
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 2972UL;
  __cil_tmp16 = *((int *)__cil_tmp15);
  *((int *)__cil_tmp13) = __cil_tmp16 + 1;
  if (tmp___8 == 0) {
    while (1) {

      while (1) {
        __cil_tmp17 = (unsigned long )dev_priv;
        __cil_tmp18 = __cil_tmp17 + 2984UL;
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
        tmp___7 = spinlock_check(__cil_tmp19);
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        goto while_break___0;
      }
      while_break___0: ;
      goto while_break;
    }
    while_break: 
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 2104UL;
    __cil_tmp22 = *((unsigned int *)__cil_tmp21);
    __cil_tmp23 = __cil_tmp22 + 8U;
    __cil_tmp24 = (int )__cil_tmp23;
    outl(4U, __cil_tmp24);
    __cil_tmp25 = (unsigned long )dev_priv;
    __cil_tmp26 = __cil_tmp25 + 3016UL;
    __cil_tmp27 = (unsigned long )dev_priv;
    __cil_tmp28 = __cil_tmp27 + 3016UL;
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
    *((uint32_t *)__cil_tmp26) = __cil_tmp29 | 4U;
    __cil_tmp30 = (unsigned long )dev_priv;
    __cil_tmp31 = __cil_tmp30 + 3016UL;
    __cil_tmp32 = *((uint32_t *)__cil_tmp31);
    vmw_write(dev_priv, 33U, __cil_tmp32);
    __cil_tmp33 = (unsigned long )dev_priv;
    __cil_tmp34 = __cil_tmp33 + 2984UL;
    __cil_tmp35 = (spinlock_t *)__cil_tmp34;
    spin_unlock_irqrestore(__cil_tmp35, irq_flags);
  }
  __cil_tmp36 = (unsigned long )dev_priv;
  __cil_tmp37 = __cil_tmp36 + 2184UL;
  __cil_tmp38 = (struct mutex *)__cil_tmp37;
  mutex_unlock(__cil_tmp38);
  return;
}
}
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  spinlock_t *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct mutex *__cil_tmp33 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2184UL;
  __cil_tmp8 = (struct mutex *)__cil_tmp7;
  mutex_lock(__cil_tmp8);
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2972UL;
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2972UL;
  __cil_tmp13 = *((int *)__cil_tmp12);
  *((int *)__cil_tmp10) = __cil_tmp13 - 1;
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 2972UL;
  __cil_tmp16 = *((int *)__cil_tmp15);
  if (__cil_tmp16 == 0) {
    while (1) {

      while (1) {
        __cil_tmp17 = (unsigned long )dev_priv;
        __cil_tmp18 = __cil_tmp17 + 2984UL;
        __cil_tmp19 = (spinlock_t *)__cil_tmp18;
        tmp___7 = spinlock_check(__cil_tmp19);
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        goto while_break___0;
      }
      while_break___0: ;
      goto while_break;
    }
    while_break: 
    __cil_tmp20 = (unsigned long )dev_priv;
    __cil_tmp21 = __cil_tmp20 + 3016UL;
    __cil_tmp22 = (unsigned long )dev_priv;
    __cil_tmp23 = __cil_tmp22 + 3016UL;
    __cil_tmp24 = *((uint32_t *)__cil_tmp23);
    *((uint32_t *)__cil_tmp21) = __cil_tmp24 & 4294967291U;
    __cil_tmp25 = (unsigned long )dev_priv;
    __cil_tmp26 = __cil_tmp25 + 3016UL;
    __cil_tmp27 = *((uint32_t *)__cil_tmp26);
    vmw_write(dev_priv, 33U, __cil_tmp27);
    __cil_tmp28 = (unsigned long )dev_priv;
    __cil_tmp29 = __cil_tmp28 + 2984UL;
    __cil_tmp30 = (spinlock_t *)__cil_tmp29;
    spin_unlock_irqrestore(__cil_tmp30, irq_flags);
  }
  __cil_tmp31 = (unsigned long )dev_priv;
  __cil_tmp32 = __cil_tmp31 + 2184UL;
  __cil_tmp33 = (struct mutex *)__cil_tmp32;
  mutex_unlock(__cil_tmp33);
  return;
}
}
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) 
{ long ret ;
  struct vmw_fifo_state *fifo ;
  long tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___13 ;
  bool tmp___14 ;
  struct task_struct *tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  bool __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  bool __cil_tmp51 ;
  wait_queue_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  wait_queue_head_t *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  wait_queue_head_t *__cil_tmp65 ;
  wait_queue_t *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  wait_queue_head_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  wait_queue_head_t *__cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  long __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  long __cil_tmp87 ;

  {
  __cil_tmp28 = (unsigned long )dev_priv;
  __cil_tmp29 = __cil_tmp28 + 1856UL;
  fifo = (struct vmw_fifo_state *)__cil_tmp29;
  __cil_tmp30 = 1 << 24;
  __cil_tmp31 = (uint32_t )__cil_tmp30;
  __cil_tmp32 = (unsigned long )dev_priv;
  __cil_tmp33 = __cil_tmp32 + 2980UL;
  __cil_tmp34 = *((uint32_t *)__cil_tmp33);
  __cil_tmp35 = __cil_tmp34 - seqno;
  __cil_tmp36 = __cil_tmp35 < __cil_tmp31;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = (long )__cil_tmp38;
  tmp___7 = ldv__builtin_expect(__cil_tmp39, 1L);
  if (tmp___7) {
    return (0);
  }
  tmp___8 = vmw_seqno_passed(dev_priv, seqno);
  if (tmp___8) {
    tmp___9 = 1;
  } else {
    tmp___9 = 0;
  }
  __cil_tmp40 = (long )tmp___9;
  tmp___10 = ldv__builtin_expect(__cil_tmp40, 1L);
  if (tmp___10) {
    return (0);
  }
  __cil_tmp41 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp41);
  __cil_tmp42 = (unsigned long )fifo;
  __cil_tmp43 = __cil_tmp42 + 36UL;
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
  __cil_tmp45 = __cil_tmp44 & 1U;
  if (! __cil_tmp45) {
    __cil_tmp46 = (bool )1;
    tmp___11 = vmw_fallback_wait(dev_priv, lazy, __cil_tmp46, seqno, interruptible,
                                 timeout);
    return (tmp___11);
  }
  __cil_tmp47 = (unsigned long )dev_priv;
  __cil_tmp48 = __cil_tmp47 + 2156UL;
  __cil_tmp49 = *((uint32_t *)__cil_tmp48);
  __cil_tmp50 = __cil_tmp49 & 262144U;
  if (! __cil_tmp50) {
    __cil_tmp51 = (bool )0;
    tmp___12 = vmw_fallback_wait(dev_priv, lazy, __cil_tmp51, seqno, interruptible,
                                 timeout);
    return (tmp___12);
  }
  vmw_seqno_waiter_add(dev_priv);
  if (interruptible) {
    __ret = (long )timeout;
    tmp___17 = vmw_seqno_passed(dev_priv, seqno);
    if (! tmp___17) {
      while (1) {
        tmp___13 = get_current();
        __cil_tmp52 = & __wait;
        *((unsigned int *)__cil_tmp52) = 0U;
        __cil_tmp53 = (unsigned long )(& __wait) + 8UL;
        *((void **)__cil_tmp53) = (void *)tmp___13;
        __cil_tmp54 = (unsigned long )(& __wait) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp54) = & autoremove_wake_function;
        __cil_tmp55 = (unsigned long )(& __wait) + 24UL;
        __cil_tmp56 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp55) = (struct list_head *)__cil_tmp56;
        __cil_tmp57 = 32;
        __cil_tmp58 = (unsigned long )(& __wait) + __cil_tmp57;
        __cil_tmp59 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp58) = (struct list_head *)__cil_tmp59;
        while (1) {
          __cil_tmp60 = (unsigned long )dev_priv;
          __cil_tmp61 = __cil_tmp60 + 2888UL;
          __cil_tmp62 = (wait_queue_head_t *)__cil_tmp61;
          prepare_to_wait(__cil_tmp62, & __wait, 1);
          tmp___14 = vmw_seqno_passed(dev_priv, seqno);
          if (tmp___14) {
            goto while_break___0;
          }
          tmp___15 = get_current();
          tmp___16 = signal_pending(tmp___15);
          if (! tmp___16) {
            __ret = schedule_timeout(__ret);
            if (! __ret) {
              goto while_break___0;
            }
            goto __Cont;
          }
          __ret = -512L;
          goto while_break___0;
          __Cont: ;
        }
        while_break___0: 
        __cil_tmp63 = (unsigned long )dev_priv;
        __cil_tmp64 = __cil_tmp63 + 2888UL;
        __cil_tmp65 = (wait_queue_head_t *)__cil_tmp64;
        finish_wait(__cil_tmp65, & __wait);
        goto while_break;
      }
      while_break: ;
    }
    ret = __ret;
  } else {
    __ret___0 = (long )timeout;
    tmp___20 = vmw_seqno_passed(dev_priv, seqno);
    if (! tmp___20) {
      while (1) {
        tmp___18 = get_current();
        __cil_tmp66 = & __wait___0;
        *((unsigned int *)__cil_tmp66) = 0U;
        __cil_tmp67 = (unsigned long )(& __wait___0) + 8UL;
        *((void **)__cil_tmp67) = (void *)tmp___18;
        __cil_tmp68 = (unsigned long )(& __wait___0) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp68) = & autoremove_wake_function;
        __cil_tmp69 = (unsigned long )(& __wait___0) + 24UL;
        __cil_tmp70 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp69) = (struct list_head *)__cil_tmp70;
        __cil_tmp71 = 32;
        __cil_tmp72 = (unsigned long )(& __wait___0) + __cil_tmp71;
        __cil_tmp73 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp72) = (struct list_head *)__cil_tmp73;
        while (1) {
          __cil_tmp74 = (unsigned long )dev_priv;
          __cil_tmp75 = __cil_tmp74 + 2888UL;
          __cil_tmp76 = (wait_queue_head_t *)__cil_tmp75;
          prepare_to_wait(__cil_tmp76, & __wait___0, 2);
          tmp___19 = vmw_seqno_passed(dev_priv, seqno);
          if (tmp___19) {
            goto while_break___2;
          }
          __ret___0 = schedule_timeout(__ret___0);
          if (! __ret___0) {
            goto while_break___2;
          }
        }
        while_break___2: 
        __cil_tmp77 = (unsigned long )dev_priv;
        __cil_tmp78 = __cil_tmp77 + 2888UL;
        __cil_tmp79 = (wait_queue_head_t *)__cil_tmp78;
        finish_wait(__cil_tmp79, & __wait___0);
        goto while_break___1;
      }
      while_break___1: ;
    }
    ret = __ret___0;
  }
  vmw_seqno_waiter_remove(dev_priv);
  __cil_tmp80 = ret == 0L;
  __cil_tmp81 = ! __cil_tmp80;
  __cil_tmp82 = ! __cil_tmp81;
  __cil_tmp83 = (long )__cil_tmp82;
  tmp___22 = ldv__builtin_expect(__cil_tmp83, 0L);
  if (tmp___22) {
    ret = -16L;
  } else {
    __cil_tmp84 = ret > 0L;
    __cil_tmp85 = ! __cil_tmp84;
    __cil_tmp86 = ! __cil_tmp85;
    __cil_tmp87 = (long )__cil_tmp86;
    tmp___21 = ldv__builtin_expect(__cil_tmp87, 1L);
    if (tmp___21) {
      ret = 0L;
    }
  }
  return ((int )ret);
}
}
static struct lock_class_key __key___15  ;
void vmw_irq_preinstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct raw_spinlock *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2156UL;
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
  __cil_tmp8 = __cil_tmp7 & 262144U;
  if (! __cil_tmp8) {
    return;
  }
  while (1) {
    __cil_tmp9 = (unsigned long )dev_priv;
    __cil_tmp10 = __cil_tmp9 + 2984UL;
    __cil_tmp11 = (spinlock_t *)__cil_tmp10;
    spinlock_check(__cil_tmp11);
    while (1) {
      __cil_tmp12 = (unsigned long )dev_priv;
      __cil_tmp13 = __cil_tmp12 + 2984UL;
      __cil_tmp14 = (struct raw_spinlock *)__cil_tmp13;
      __raw_spin_lock_init(__cil_tmp14, "&(&dev_priv->irq_lock)->rlock", & __key___15);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2104UL;
  __cil_tmp17 = *((unsigned int *)__cil_tmp16);
  __cil_tmp18 = __cil_tmp17 + 8U;
  __cil_tmp19 = (int )__cil_tmp18;
  status = inl(__cil_tmp19);
  __cil_tmp20 = (unsigned long )dev_priv;
  __cil_tmp21 = __cil_tmp20 + 2104UL;
  __cil_tmp22 = *((unsigned int *)__cil_tmp21);
  __cil_tmp23 = __cil_tmp22 + 8U;
  __cil_tmp24 = (int )__cil_tmp23;
  outl(status, __cil_tmp24);
  return;
}
}
int vmw_irq_postinstall(struct drm_device *dev ) 
{ 

  {
  return (0);
}
}
void vmw_irq_uninstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  uint32_t status ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct mutex *__cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct mutex *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2156UL;
  __cil_tmp7 = *((uint32_t *)__cil_tmp6);
  __cil_tmp8 = __cil_tmp7 & 262144U;
  if (! __cil_tmp8) {
    return;
  }
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2184UL;
  __cil_tmp11 = (struct mutex *)__cil_tmp10;
  mutex_lock(__cil_tmp11);
  __cil_tmp12 = (uint32_t )0;
  vmw_write(dev_priv, 33U, __cil_tmp12);
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2184UL;
  __cil_tmp15 = (struct mutex *)__cil_tmp14;
  mutex_unlock(__cil_tmp15);
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + 2104UL;
  __cil_tmp18 = *((unsigned int *)__cil_tmp17);
  __cil_tmp19 = __cil_tmp18 + 8U;
  __cil_tmp20 = (int )__cil_tmp19;
  status = inl(__cil_tmp20);
  __cil_tmp21 = (unsigned long )dev_priv;
  __cil_tmp22 = __cil_tmp21 + 2104UL;
  __cil_tmp23 = *((unsigned int *)__cil_tmp22);
  __cil_tmp24 = __cil_tmp23 + 8U;
  __cil_tmp25 = (int )__cil_tmp24;
  outl(status, __cil_tmp25);
  return;
}
}
extern int drm_crtc_init(struct drm_device *dev , struct drm_crtc *crtc , struct drm_crtc_funcs *funcs ) ;
extern int drm_connector_init(struct drm_device *dev , struct drm_connector *connector ,
                              struct drm_connector_funcs *funcs , int connector_type ) ;
extern int drm_encoder_init(struct drm_device *dev , struct drm_encoder *encoder ,
                            struct drm_encoder_funcs *funcs , int encoder_type ) ;
extern int drm_connector_attach_property(struct drm_connector *connector , struct drm_property *property ,
                                         uint64_t init_val ) ;
extern int drm_mode_create_dirty_info_property(struct drm_device *dev ) ;
extern int drm_mode_connector_attach_encoder(struct drm_connector *connector , struct drm_encoder *encoder ) ;
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc , int gamma_size ) ;
extern int drm_vblank_init(struct drm_device *dev , int num_crtcs ) ;
extern void drm_vblank_cleanup(struct drm_device *dev ) ;
static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct list_head *__cil_tmp4 ;
  struct vmw_display_unit *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  __cil_tmp2 = (unsigned long )ldu;
  __cil_tmp3 = __cil_tmp2 + 2072UL;
  __cil_tmp4 = (struct list_head *)__cil_tmp3;
  list_del_init(__cil_tmp4);
  __cil_tmp5 = (struct vmw_display_unit *)ldu;
  vmw_display_unit_cleanup(__cil_tmp5);
  __cil_tmp6 = (void *)ldu;
  kfree(__cil_tmp6);
  return;
}
}
static void vmw_ldu_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc *__mptr ;
  struct vmw_legacy_display_unit *__cil_tmp3 ;
  struct drm_crtc *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  struct vmw_legacy_display_unit *__cil_tmp8 ;

  {
  __mptr = crtc;
  __cil_tmp3 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp4 = (struct drm_crtc *)__cil_tmp3;
  __cil_tmp5 = (unsigned int )__cil_tmp4;
  __cil_tmp6 = (char *)__mptr;
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
  __cil_tmp8 = (struct vmw_legacy_display_unit *)__cil_tmp7;
  vmw_ldu_destroy(__cil_tmp8);
  return;
}
}
static int vmw_ldu_commit_list(struct vmw_private *dev_priv ) 
{ struct vmw_legacy_display *lds ;
  struct vmw_legacy_display_unit *entry ;
  struct vmw_display_unit *du ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int i ;
  int ret ;
  int w ;
  int h ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int _max1 ;
  int _max2 ;
  int tmp___7 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___8 ;
  int tmp___9 ;
  struct list_head *__mptr___1 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  struct list_head *__mptr___2 ;
  struct list_head *__mptr___3 ;
  long tmp___12 ;
  struct list_head *__mptr___4 ;
  struct list_head *__mptr___5 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  struct vmw_legacy_display_unit *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct list_head *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int *__cil_tmp51 ;
  int *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  int *__cil_tmp60 ;
  int __cil_tmp61 ;
  int *__cil_tmp62 ;
  int __cil_tmp63 ;
  int *__cil_tmp64 ;
  int *__cil_tmp65 ;
  int *__cil_tmp66 ;
  int *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  int __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  int *__cil_tmp75 ;
  int __cil_tmp76 ;
  int *__cil_tmp77 ;
  int __cil_tmp78 ;
  int *__cil_tmp79 ;
  int *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  struct vmw_legacy_display_unit *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct list_head *__cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  void *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  int __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  struct list_head *__cil_tmp112 ;
  struct list_head *__cil_tmp113 ;
  struct list_head *__cil_tmp114 ;
  struct vmw_legacy_display_unit *__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  struct list_head *__cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned int __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned int __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  int __cil_tmp139 ;
  unsigned int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  struct list_head *__cil_tmp148 ;
  struct vmw_legacy_display_unit *__cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  struct list_head *__cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  struct list_head *__cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct list_head *__cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  uint32_t __cil_tmp162 ;
  int __cil_tmp163 ;
  uint32_t __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  int __cil_tmp167 ;
  uint32_t __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  int __cil_tmp171 ;
  uint32_t __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  int __cil_tmp176 ;
  uint32_t __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  int __cil_tmp181 ;
  uint32_t __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  struct list_head *__cil_tmp185 ;
  struct vmw_legacy_display_unit *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  struct list_head *__cil_tmp189 ;
  unsigned int __cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned int __cil_tmp195 ;
  unsigned int __cil_tmp196 ;
  int __cil_tmp197 ;
  int __cil_tmp198 ;
  int __cil_tmp199 ;
  long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  struct list_head *__cil_tmp205 ;
  struct vmw_legacy_display_unit *__cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  struct list_head *__cil_tmp209 ;
  unsigned int __cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  struct list_head *__cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  struct list_head *__cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  struct vmw_dma_buffer *__cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  struct vmw_dma_buffer *__cil_tmp224 ;
  u32 __cil_tmp225 ;
  u32 __cil_tmp226 ;
  unsigned long __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  int __cil_tmp229 ;
  u32 __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  int __cil_tmp233 ;
  u32 __cil_tmp234 ;
  unsigned long __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  struct list_head *__cil_tmp237 ;
  struct vmw_legacy_display_unit *__cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  struct list_head *__cil_tmp241 ;
  unsigned int __cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;

  {
  __cil_tmp28 = (unsigned long )dev_priv;
  __cil_tmp29 = __cil_tmp28 + 2608UL;
  lds = *((struct vmw_legacy_display **)__cil_tmp29);
  __cil_tmp30 = (void *)0;
  du = (struct vmw_display_unit *)__cil_tmp30;
  __cil_tmp31 = (void *)0;
  fb = (struct drm_framebuffer *)__cil_tmp31;
  __cil_tmp32 = (void *)0;
  crtc = (struct drm_crtc *)__cil_tmp32;
  i = 0;
  __cil_tmp33 = (unsigned long )dev_priv;
  __cil_tmp34 = __cil_tmp33 + 2156UL;
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
  __cil_tmp36 = __cil_tmp35 & 524288U;
  if (! __cil_tmp36) {
    w = 0;
    h = 0;
    __cil_tmp37 = *((struct list_head **)lds);
    __mptr = __cil_tmp37;
    __cil_tmp38 = (struct vmw_legacy_display_unit *)0;
    __cil_tmp39 = (unsigned long )__cil_tmp38;
    __cil_tmp40 = __cil_tmp39 + 2072UL;
    __cil_tmp41 = (struct list_head *)__cil_tmp40;
    __cil_tmp42 = (unsigned int )__cil_tmp41;
    __cil_tmp43 = (char *)__mptr;
    __cil_tmp44 = __cil_tmp43 - __cil_tmp42;
    entry = (struct vmw_legacy_display_unit *)__cil_tmp44;
    while (1) {
      __cil_tmp45 = (struct list_head *)lds;
      __cil_tmp46 = (unsigned long )__cil_tmp45;
      __cil_tmp47 = (unsigned long )entry;
      __cil_tmp48 = __cil_tmp47 + 2072UL;
      __cil_tmp49 = (struct list_head *)__cil_tmp48;
      __cil_tmp50 = (unsigned long )__cil_tmp49;
      if (! (__cil_tmp50 != __cil_tmp46)) {
        goto while_break;
      }
      crtc = (struct drm_crtc *)entry;
      __cil_tmp51 = & _max1;
      *__cil_tmp51 = w;
      __cil_tmp52 = & _max2;
      __cil_tmp53 = 116;
      __cil_tmp54 = (unsigned long )crtc;
      __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
      __cil_tmp56 = *((int *)__cil_tmp55);
      __cil_tmp57 = (unsigned long )crtc;
      __cil_tmp58 = __cil_tmp57 + 480UL;
      __cil_tmp59 = *((int *)__cil_tmp58);
      *__cil_tmp52 = __cil_tmp59 + __cil_tmp56;
      __cil_tmp60 = & _max2;
      __cil_tmp61 = *__cil_tmp60;
      __cil_tmp62 = & _max1;
      __cil_tmp63 = *__cil_tmp62;
      if (__cil_tmp63 > __cil_tmp61) {
        __cil_tmp64 = & _max1;
        tmp___7 = *__cil_tmp64;
      } else {
        __cil_tmp65 = & _max2;
        tmp___7 = *__cil_tmp65;
      }
      w = tmp___7;
      __cil_tmp66 = & _max1___0;
      *__cil_tmp66 = h;
      __cil_tmp67 = & _max2___0;
      __cil_tmp68 = 136;
      __cil_tmp69 = (unsigned long )crtc;
      __cil_tmp70 = __cil_tmp69 + __cil_tmp68;
      __cil_tmp71 = *((int *)__cil_tmp70);
      __cil_tmp72 = (unsigned long )crtc;
      __cil_tmp73 = __cil_tmp72 + 484UL;
      __cil_tmp74 = *((int *)__cil_tmp73);
      *__cil_tmp67 = __cil_tmp74 + __cil_tmp71;
      __cil_tmp75 = & _max2___0;
      __cil_tmp76 = *__cil_tmp75;
      __cil_tmp77 = & _max1___0;
      __cil_tmp78 = *__cil_tmp77;
      if (__cil_tmp78 > __cil_tmp76) {
        __cil_tmp79 = & _max1___0;
        tmp___8 = *__cil_tmp79;
      } else {
        __cil_tmp80 = & _max2___0;
        tmp___8 = *__cil_tmp80;
      }
      h = tmp___8;
      i ++;
      __cil_tmp81 = (unsigned long )entry;
      __cil_tmp82 = __cil_tmp81 + 2072UL;
      __cil_tmp83 = *((struct list_head **)__cil_tmp82);
      __mptr___0 = __cil_tmp83;
      __cil_tmp84 = (struct vmw_legacy_display_unit *)0;
      __cil_tmp85 = (unsigned long )__cil_tmp84;
      __cil_tmp86 = __cil_tmp85 + 2072UL;
      __cil_tmp87 = (struct list_head *)__cil_tmp86;
      __cil_tmp88 = (unsigned int )__cil_tmp87;
      __cil_tmp89 = (char *)__mptr___0;
      __cil_tmp90 = __cil_tmp89 - __cil_tmp88;
      entry = (struct vmw_legacy_display_unit *)__cil_tmp90;
    }
    while_break: 
    __cil_tmp91 = (void *)0;
    __cil_tmp92 = (unsigned long )__cil_tmp91;
    __cil_tmp93 = (unsigned long )crtc;
    if (__cil_tmp93 == __cil_tmp92) {
      return (0);
    }
    __cil_tmp94 = 32;
    __cil_tmp95 = __cil_tmp94;
    __cil_tmp96 = (unsigned long )entry;
    __cil_tmp97 = __cil_tmp96 + __cil_tmp95;
    fb = *((struct drm_framebuffer **)__cil_tmp97);
    __cil_tmp98 = (unsigned int )w;
    __cil_tmp99 = (unsigned int )h;
    __cil_tmp100 = 0UL;
    __cil_tmp101 = 40UL + __cil_tmp100;
    __cil_tmp102 = (unsigned long )fb;
    __cil_tmp103 = __cil_tmp102 + __cil_tmp101;
    __cil_tmp104 = *((unsigned int *)__cil_tmp103);
    __cil_tmp105 = (unsigned long )fb;
    __cil_tmp106 = __cil_tmp105 + 84UL;
    __cil_tmp107 = *((int *)__cil_tmp106);
    __cil_tmp108 = (unsigned int )__cil_tmp107;
    __cil_tmp109 = (unsigned long )fb;
    __cil_tmp110 = __cil_tmp109 + 80UL;
    __cil_tmp111 = *((unsigned int *)__cil_tmp110);
    tmp___9 = vmw_kms_write_svga(dev_priv, __cil_tmp98, __cil_tmp99, __cil_tmp104,
                                 __cil_tmp108, __cil_tmp111);
    return (tmp___9);
  }
  __cil_tmp112 = (struct list_head *)lds;
  __cil_tmp113 = __cil_tmp112;
  tmp___10 = list_empty(__cil_tmp113);
  if (! tmp___10) {
    __cil_tmp114 = *((struct list_head **)lds);
    __mptr___1 = __cil_tmp114;
    __cil_tmp115 = (struct vmw_legacy_display_unit *)0;
    __cil_tmp116 = (unsigned long )__cil_tmp115;
    __cil_tmp117 = __cil_tmp116 + 2072UL;
    __cil_tmp118 = (struct list_head *)__cil_tmp117;
    __cil_tmp119 = (unsigned int )__cil_tmp118;
    __cil_tmp120 = (char *)__mptr___1;
    __cil_tmp121 = __cil_tmp120 - __cil_tmp119;
    entry = (struct vmw_legacy_display_unit *)__cil_tmp121;
    __cil_tmp122 = 32;
    __cil_tmp123 = __cil_tmp122;
    __cil_tmp124 = (unsigned long )entry;
    __cil_tmp125 = __cil_tmp124 + __cil_tmp123;
    fb = *((struct drm_framebuffer **)__cil_tmp125);
    __cil_tmp126 = (unsigned long )fb;
    __cil_tmp127 = __cil_tmp126 + 72UL;
    __cil_tmp128 = *((unsigned int *)__cil_tmp127);
    __cil_tmp129 = (unsigned long )fb;
    __cil_tmp130 = __cil_tmp129 + 76UL;
    __cil_tmp131 = *((unsigned int *)__cil_tmp130);
    __cil_tmp132 = 0UL;
    __cil_tmp133 = 40UL + __cil_tmp132;
    __cil_tmp134 = (unsigned long )fb;
    __cil_tmp135 = __cil_tmp134 + __cil_tmp133;
    __cil_tmp136 = *((unsigned int *)__cil_tmp135);
    __cil_tmp137 = (unsigned long )fb;
    __cil_tmp138 = __cil_tmp137 + 84UL;
    __cil_tmp139 = *((int *)__cil_tmp138);
    __cil_tmp140 = (unsigned int )__cil_tmp139;
    __cil_tmp141 = (unsigned long )fb;
    __cil_tmp142 = __cil_tmp141 + 80UL;
    __cil_tmp143 = *((unsigned int *)__cil_tmp142);
    vmw_kms_write_svga(dev_priv, __cil_tmp128, __cil_tmp131, __cil_tmp136, __cil_tmp140,
                       __cil_tmp143);
  }
  __cil_tmp144 = (unsigned long )lds;
  __cil_tmp145 = __cil_tmp144 + 16UL;
  if (*((unsigned int *)__cil_tmp145)) {
    __cil_tmp146 = (unsigned long )lds;
    __cil_tmp147 = __cil_tmp146 + 16UL;
    tmp___11 = *((unsigned int *)__cil_tmp147);
  } else {
    tmp___11 = 1U;
  }
  vmw_write(dev_priv, 34U, tmp___11);
  i = 0;
  __cil_tmp148 = *((struct list_head **)lds);
  __mptr___2 = __cil_tmp148;
  __cil_tmp149 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp150 = (unsigned long )__cil_tmp149;
  __cil_tmp151 = __cil_tmp150 + 2072UL;
  __cil_tmp152 = (struct list_head *)__cil_tmp151;
  __cil_tmp153 = (unsigned int )__cil_tmp152;
  __cil_tmp154 = (char *)__mptr___2;
  __cil_tmp155 = __cil_tmp154 - __cil_tmp153;
  entry = (struct vmw_legacy_display_unit *)__cil_tmp155;
  while (1) {
    __cil_tmp156 = (struct list_head *)lds;
    __cil_tmp157 = (unsigned long )__cil_tmp156;
    __cil_tmp158 = (unsigned long )entry;
    __cil_tmp159 = __cil_tmp158 + 2072UL;
    __cil_tmp160 = (struct list_head *)__cil_tmp159;
    __cil_tmp161 = (unsigned long )__cil_tmp160;
    if (! (__cil_tmp161 != __cil_tmp157)) {
      goto while_break___0;
    }
    crtc = (struct drm_crtc *)entry;
    __cil_tmp162 = (uint32_t )i;
    vmw_write(dev_priv, 35U, __cil_tmp162);
    __cil_tmp163 = ! i;
    __cil_tmp164 = (uint32_t )__cil_tmp163;
    vmw_write(dev_priv, 36U, __cil_tmp164);
    __cil_tmp165 = (unsigned long )crtc;
    __cil_tmp166 = __cil_tmp165 + 480UL;
    __cil_tmp167 = *((int *)__cil_tmp166);
    __cil_tmp168 = (uint32_t )__cil_tmp167;
    vmw_write(dev_priv, 37U, __cil_tmp168);
    __cil_tmp169 = (unsigned long )crtc;
    __cil_tmp170 = __cil_tmp169 + 484UL;
    __cil_tmp171 = *((int *)__cil_tmp170);
    __cil_tmp172 = (uint32_t )__cil_tmp171;
    vmw_write(dev_priv, 38U, __cil_tmp172);
    __cil_tmp173 = 116;
    __cil_tmp174 = (unsigned long )crtc;
    __cil_tmp175 = __cil_tmp174 + __cil_tmp173;
    __cil_tmp176 = *((int *)__cil_tmp175);
    __cil_tmp177 = (uint32_t )__cil_tmp176;
    vmw_write(dev_priv, 39U, __cil_tmp177);
    __cil_tmp178 = 136;
    __cil_tmp179 = (unsigned long )crtc;
    __cil_tmp180 = __cil_tmp179 + __cil_tmp178;
    __cil_tmp181 = *((int *)__cil_tmp180);
    __cil_tmp182 = (uint32_t )__cil_tmp181;
    vmw_write(dev_priv, 40U, __cil_tmp182);
    vmw_write(dev_priv, 35U, 4294967295U);
    i ++;
    __cil_tmp183 = (unsigned long )entry;
    __cil_tmp184 = __cil_tmp183 + 2072UL;
    __cil_tmp185 = *((struct list_head **)__cil_tmp184);
    __mptr___3 = __cil_tmp185;
    __cil_tmp186 = (struct vmw_legacy_display_unit *)0;
    __cil_tmp187 = (unsigned long )__cil_tmp186;
    __cil_tmp188 = __cil_tmp187 + 2072UL;
    __cil_tmp189 = (struct list_head *)__cil_tmp188;
    __cil_tmp190 = (unsigned int )__cil_tmp189;
    __cil_tmp191 = (char *)__mptr___3;
    __cil_tmp192 = __cil_tmp191 - __cil_tmp190;
    entry = (struct vmw_legacy_display_unit *)__cil_tmp192;
  }
  while_break___0: ;
  while (1) {
    __cil_tmp193 = (unsigned long )lds;
    __cil_tmp194 = __cil_tmp193 + 16UL;
    __cil_tmp195 = *((unsigned int *)__cil_tmp194);
    __cil_tmp196 = (unsigned int )i;
    __cil_tmp197 = __cil_tmp196 != __cil_tmp195;
    __cil_tmp198 = ! __cil_tmp197;
    __cil_tmp199 = ! __cil_tmp198;
    __cil_tmp200 = (long )__cil_tmp199;
    tmp___12 = ldv__builtin_expect(__cil_tmp200, 0L);
    if (tmp___12) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (130), "i" (12UL));
        while (1) {

        }

        goto while_break___2;
      }
      while_break___2: ;
    }
    goto while_break___1;
  }
  while_break___1: 
  __cil_tmp201 = (unsigned long )lds;
  __cil_tmp202 = __cil_tmp201 + 20UL;
  __cil_tmp203 = (unsigned long )lds;
  __cil_tmp204 = __cil_tmp203 + 16UL;
  *((unsigned int *)__cil_tmp202) = *((unsigned int *)__cil_tmp204);
  __cil_tmp205 = *((struct list_head **)lds);
  __mptr___4 = __cil_tmp205;
  __cil_tmp206 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp207 = (unsigned long )__cil_tmp206;
  __cil_tmp208 = __cil_tmp207 + 2072UL;
  __cil_tmp209 = (struct list_head *)__cil_tmp208;
  __cil_tmp210 = (unsigned int )__cil_tmp209;
  __cil_tmp211 = (char *)__mptr___4;
  __cil_tmp212 = __cil_tmp211 - __cil_tmp210;
  entry = (struct vmw_legacy_display_unit *)__cil_tmp212;
  while (1) {
    __cil_tmp213 = (struct list_head *)lds;
    __cil_tmp214 = (unsigned long )__cil_tmp213;
    __cil_tmp215 = (unsigned long )entry;
    __cil_tmp216 = __cil_tmp215 + 2072UL;
    __cil_tmp217 = (struct list_head *)__cil_tmp216;
    __cil_tmp218 = (unsigned long )__cil_tmp217;
    if (! (__cil_tmp218 != __cil_tmp214)) {
      goto while_break___4;
    }
    du = (struct vmw_display_unit *)entry;
    __cil_tmp219 = (unsigned long )du;
    __cil_tmp220 = __cil_tmp219 + 2000UL;
    __cil_tmp221 = *((struct vmw_dma_buffer **)__cil_tmp220);
    if (! __cil_tmp221) {
      goto __Cont;
    }
    __cil_tmp222 = (unsigned long )du;
    __cil_tmp223 = __cil_tmp222 + 2000UL;
    __cil_tmp224 = *((struct vmw_dma_buffer **)__cil_tmp223);
    __cil_tmp225 = (u32 )64;
    __cil_tmp226 = (u32 )64;
    __cil_tmp227 = (unsigned long )du;
    __cil_tmp228 = __cil_tmp227 + 2024UL;
    __cil_tmp229 = *((int *)__cil_tmp228);
    __cil_tmp230 = (u32 )__cil_tmp229;
    __cil_tmp231 = (unsigned long )du;
    __cil_tmp232 = __cil_tmp231 + 2028UL;
    __cil_tmp233 = *((int *)__cil_tmp232);
    __cil_tmp234 = (u32 )__cil_tmp233;
    ret = vmw_cursor_update_dmabuf(dev_priv, __cil_tmp224, __cil_tmp225, __cil_tmp226,
                                   __cil_tmp230, __cil_tmp234);
    if (ret == 0) {
      goto while_break___4;
    }
    drm_err("vmw_ldu_commit_list", "Could not update cursor image\n");
    __Cont: 
    __cil_tmp235 = (unsigned long )entry;
    __cil_tmp236 = __cil_tmp235 + 2072UL;
    __cil_tmp237 = *((struct list_head **)__cil_tmp236);
    __mptr___5 = __cil_tmp237;
    __cil_tmp238 = (struct vmw_legacy_display_unit *)0;
    __cil_tmp239 = (unsigned long )__cil_tmp238;
    __cil_tmp240 = __cil_tmp239 + 2072UL;
    __cil_tmp241 = (struct list_head *)__cil_tmp240;
    __cil_tmp242 = (unsigned int )__cil_tmp241;
    __cil_tmp243 = (char *)__mptr___5;
    __cil_tmp244 = __cil_tmp243 - __cil_tmp242;
    entry = (struct vmw_legacy_display_unit *)__cil_tmp244;
  }
  while_break___4: ;
  return (0);
}
}
static int vmw_ldu_del_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ) 
{ struct vmw_legacy_display *ld ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_framebuffer *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct vmw_framebuffer *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_framebuffer *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int (*__cil_tmp40)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_framebuffer *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void *__cil_tmp46 ;

  {
  __cil_tmp6 = (unsigned long )vmw_priv___0;
  __cil_tmp7 = __cil_tmp6 + 2608UL;
  ld = *((struct vmw_legacy_display **)__cil_tmp7);
  __cil_tmp8 = (unsigned long )ldu;
  __cil_tmp9 = __cil_tmp8 + 2072UL;
  __cil_tmp10 = (struct list_head *)__cil_tmp9;
  __cil_tmp11 = __cil_tmp10;
  tmp___7 = list_empty(__cil_tmp11);
  if (tmp___7) {
    return (0);
  }
  __cil_tmp12 = (unsigned long )ldu;
  __cil_tmp13 = __cil_tmp12 + 2072UL;
  __cil_tmp14 = (struct list_head *)__cil_tmp13;
  list_del_init(__cil_tmp14);
  __cil_tmp15 = (unsigned long )ld;
  __cil_tmp16 = __cil_tmp15 + 16UL;
  __cil_tmp17 = (unsigned long )ld;
  __cil_tmp18 = __cil_tmp17 + 16UL;
  __cil_tmp19 = *((unsigned int *)__cil_tmp18);
  *((unsigned int *)__cil_tmp16) = __cil_tmp19 - 1U;
  __cil_tmp20 = (unsigned long )ld;
  __cil_tmp21 = __cil_tmp20 + 16UL;
  __cil_tmp22 = *((unsigned int *)__cil_tmp21);
  if (__cil_tmp22 == 0U) {
    while (1) {
      __cil_tmp23 = (unsigned long )ld;
      __cil_tmp24 = __cil_tmp23 + 24UL;
      __cil_tmp25 = *((struct vmw_framebuffer **)__cil_tmp24);
      __cil_tmp26 = ! __cil_tmp25;
      __cil_tmp27 = ! __cil_tmp26;
      __cil_tmp28 = ! __cil_tmp27;
      __cil_tmp29 = (long )__cil_tmp28;
      tmp___8 = ldv__builtin_expect(__cil_tmp29, 0L);
      if (tmp___8) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                               "i" (166), "i" (12UL));
          while (1) {

          }

          goto while_break___0;
        }
        while_break___0: ;
      }
      goto while_break;
    }
    while_break: 
    __cil_tmp30 = (unsigned long )ld;
    __cil_tmp31 = __cil_tmp30 + 24UL;
    __cil_tmp32 = *((struct vmw_framebuffer **)__cil_tmp31);
    __cil_tmp33 = (unsigned long )__cil_tmp32;
    __cil_tmp34 = __cil_tmp33 + 128UL;
    if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp34)) {
      __cil_tmp35 = (unsigned long )ld;
      __cil_tmp36 = __cil_tmp35 + 24UL;
      __cil_tmp37 = *((struct vmw_framebuffer **)__cil_tmp36);
      __cil_tmp38 = (unsigned long )__cil_tmp37;
      __cil_tmp39 = __cil_tmp38 + 128UL;
      __cil_tmp40 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp39);
      __cil_tmp41 = (unsigned long )ld;
      __cil_tmp42 = __cil_tmp41 + 24UL;
      __cil_tmp43 = *((struct vmw_framebuffer **)__cil_tmp42);
      (*__cil_tmp40)(__cil_tmp43);
    }
    __cil_tmp44 = (unsigned long )ld;
    __cil_tmp45 = __cil_tmp44 + 24UL;
    __cil_tmp46 = (void *)0;
    *((struct vmw_framebuffer **)__cil_tmp45) = (struct vmw_framebuffer *)__cil_tmp46;
  }
  return (0);
}
}
static int vmw_ldu_add_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ,
                              struct vmw_framebuffer *vfb ) 
{ struct vmw_legacy_display *ld ;
  struct vmw_legacy_display_unit *entry ;
  struct list_head *at ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_framebuffer *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct vmw_framebuffer *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct vmw_framebuffer *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int (*__cil_tmp37)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct vmw_framebuffer *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int (*__cil_tmp45)(struct vmw_framebuffer *fb ) ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  struct vmw_legacy_display_unit *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct list_head *__cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  struct vmw_legacy_display_unit *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct list_head *__cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct list_head *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned int __cil_tmp93 ;

  {
  __cil_tmp12 = (unsigned long )vmw_priv___0;
  __cil_tmp13 = __cil_tmp12 + 2608UL;
  ld = *((struct vmw_legacy_display **)__cil_tmp13);
  while (1) {
    __cil_tmp14 = (unsigned long )ld;
    __cil_tmp15 = __cil_tmp14 + 16UL;
    __cil_tmp16 = *((unsigned int *)__cil_tmp15);
    if (! __cil_tmp16) {
      __cil_tmp17 = (unsigned long )ld;
      __cil_tmp18 = __cil_tmp17 + 24UL;
      if (*((struct vmw_framebuffer **)__cil_tmp18)) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    __cil_tmp19 = (long )tmp___7;
    tmp___8 = ldv__builtin_expect(__cil_tmp19, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (183), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp20 = (unsigned long )ld;
  __cil_tmp21 = __cil_tmp20 + 24UL;
  __cil_tmp22 = *((struct vmw_framebuffer **)__cil_tmp21);
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = (unsigned long )vfb;
  if (__cil_tmp24 != __cil_tmp23) {
    __cil_tmp25 = (unsigned long )ld;
    __cil_tmp26 = __cil_tmp25 + 24UL;
    if (*((struct vmw_framebuffer **)__cil_tmp26)) {
      __cil_tmp27 = (unsigned long )ld;
      __cil_tmp28 = __cil_tmp27 + 24UL;
      __cil_tmp29 = *((struct vmw_framebuffer **)__cil_tmp28);
      __cil_tmp30 = (unsigned long )__cil_tmp29;
      __cil_tmp31 = __cil_tmp30 + 128UL;
      if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp31)) {
        __cil_tmp32 = (unsigned long )ld;
        __cil_tmp33 = __cil_tmp32 + 24UL;
        __cil_tmp34 = *((struct vmw_framebuffer **)__cil_tmp33);
        __cil_tmp35 = (unsigned long )__cil_tmp34;
        __cil_tmp36 = __cil_tmp35 + 128UL;
        __cil_tmp37 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp36);
        __cil_tmp38 = (unsigned long )ld;
        __cil_tmp39 = __cil_tmp38 + 24UL;
        __cil_tmp40 = *((struct vmw_framebuffer **)__cil_tmp39);
        (*__cil_tmp37)(__cil_tmp40);
      }
    }
    __cil_tmp41 = (unsigned long )vfb;
    __cil_tmp42 = __cil_tmp41 + 120UL;
    if (*((int (**)(struct vmw_framebuffer *fb ))__cil_tmp42)) {
      __cil_tmp43 = (unsigned long )vfb;
      __cil_tmp44 = __cil_tmp43 + 120UL;
      __cil_tmp45 = *((int (**)(struct vmw_framebuffer *fb ))__cil_tmp44);
      (*__cil_tmp45)(vfb);
    }
    __cil_tmp46 = (unsigned long )ld;
    __cil_tmp47 = __cil_tmp46 + 24UL;
    *((struct vmw_framebuffer **)__cil_tmp47) = vfb;
  }
  __cil_tmp48 = (unsigned long )ldu;
  __cil_tmp49 = __cil_tmp48 + 2072UL;
  __cil_tmp50 = (struct list_head *)__cil_tmp49;
  __cil_tmp51 = __cil_tmp50;
  tmp___9 = list_empty(__cil_tmp51);
  if (! tmp___9) {
    return (0);
  }
  at = (struct list_head *)ld;
  __cil_tmp52 = *((struct list_head **)ld);
  __mptr = __cil_tmp52;
  __cil_tmp53 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp54 = (unsigned long )__cil_tmp53;
  __cil_tmp55 = __cil_tmp54 + 2072UL;
  __cil_tmp56 = (struct list_head *)__cil_tmp55;
  __cil_tmp57 = (unsigned int )__cil_tmp56;
  __cil_tmp58 = (char *)__mptr;
  __cil_tmp59 = __cil_tmp58 - __cil_tmp57;
  entry = (struct vmw_legacy_display_unit *)__cil_tmp59;
  while (1) {
    __cil_tmp60 = (struct list_head *)ld;
    __cil_tmp61 = (unsigned long )__cil_tmp60;
    __cil_tmp62 = (unsigned long )entry;
    __cil_tmp63 = __cil_tmp62 + 2072UL;
    __cil_tmp64 = (struct list_head *)__cil_tmp63;
    __cil_tmp65 = (unsigned long )__cil_tmp64;
    if (! (__cil_tmp65 != __cil_tmp61)) {
      goto while_break___2;
    }
    __cil_tmp66 = 2032;
    __cil_tmp67 = (unsigned long )ldu;
    __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
    __cil_tmp69 = *((unsigned int *)__cil_tmp68);
    __cil_tmp70 = 2032;
    __cil_tmp71 = (unsigned long )entry;
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
    __cil_tmp73 = *((unsigned int *)__cil_tmp72);
    if (__cil_tmp73 > __cil_tmp69) {
      goto while_break___2;
    }
    __cil_tmp74 = (unsigned long )entry;
    __cil_tmp75 = __cil_tmp74 + 2072UL;
    at = (struct list_head *)__cil_tmp75;
    __cil_tmp76 = (unsigned long )entry;
    __cil_tmp77 = __cil_tmp76 + 2072UL;
    __cil_tmp78 = *((struct list_head **)__cil_tmp77);
    __mptr___0 = __cil_tmp78;
    __cil_tmp79 = (struct vmw_legacy_display_unit *)0;
    __cil_tmp80 = (unsigned long )__cil_tmp79;
    __cil_tmp81 = __cil_tmp80 + 2072UL;
    __cil_tmp82 = (struct list_head *)__cil_tmp81;
    __cil_tmp83 = (unsigned int )__cil_tmp82;
    __cil_tmp84 = (char *)__mptr___0;
    __cil_tmp85 = __cil_tmp84 - __cil_tmp83;
    entry = (struct vmw_legacy_display_unit *)__cil_tmp85;
  }
  while_break___2: 
  __cil_tmp86 = (unsigned long )ldu;
  __cil_tmp87 = __cil_tmp86 + 2072UL;
  __cil_tmp88 = (struct list_head *)__cil_tmp87;
  list_add(__cil_tmp88, at);
  __cil_tmp89 = (unsigned long )ld;
  __cil_tmp90 = __cil_tmp89 + 16UL;
  __cil_tmp91 = (unsigned long )ld;
  __cil_tmp92 = __cil_tmp91 + 16UL;
  __cil_tmp93 = *((unsigned int *)__cil_tmp92);
  *((unsigned int *)__cil_tmp90) = __cil_tmp93 + 1U;
  return (0);
}
}
static int vmw_ldu_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_legacy_display_unit *ldu ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  struct drm_crtc *__mptr ;
  struct drm_framebuffer *__mptr___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct drm_crtc *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_legacy_display_unit *__cil_tmp20 ;
  struct drm_crtc *__cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct drm_framebuffer *__cil_tmp29 ;
  struct vmw_framebuffer *__cil_tmp30 ;
  struct drm_framebuffer *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  void *__cil_tmp35 ;
  struct drm_device *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  size_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  size_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct drm_connector *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct drm_connector **__cil_tmp50 ;
  struct drm_connector **__cil_tmp51 ;
  struct drm_connector *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  struct drm_connector **__cil_tmp56 ;
  struct drm_connector **__cil_tmp57 ;
  struct drm_connector *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct drm_connector *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct vmw_legacy_display *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct vmw_legacy_display *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct list_head *__cil_tmp76 ;
  struct list_head *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  struct vmw_legacy_display *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  struct vmw_framebuffer *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  size_t __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct drm_display_mode *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct drm_framebuffer *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  void *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  void *__cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned int __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  int __cil_tmp119 ;
  uint32_t __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  uint32_t __cil_tmp123 ;
  uint32_t __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned int __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  int __cil_tmp130 ;
  uint32_t __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  uint32_t __cil_tmp134 ;
  uint32_t __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  uint32_t __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  uint32_t __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;

  {
  if (! set) {
    return (-22);
  }
  __cil_tmp15 = (unsigned long )set;
  __cil_tmp16 = __cil_tmp15 + 24UL;
  __cil_tmp17 = *((struct drm_crtc **)__cil_tmp16);
  if (! __cil_tmp17) {
    return (-22);
  }
  __cil_tmp18 = (unsigned long )set;
  __cil_tmp19 = __cil_tmp18 + 24UL;
  crtc = *((struct drm_crtc **)__cil_tmp19);
  __mptr = crtc;
  __cil_tmp20 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp21 = (struct drm_crtc *)__cil_tmp20;
  __cil_tmp22 = (unsigned int )__cil_tmp21;
  __cil_tmp23 = (char *)__mptr;
  __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
  ldu = (struct vmw_legacy_display_unit *)__cil_tmp24;
  __cil_tmp25 = (unsigned long )set;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  if (*((struct drm_framebuffer **)__cil_tmp26)) {
    __cil_tmp27 = (unsigned long )set;
    __cil_tmp28 = __cil_tmp27 + 16UL;
    __cil_tmp29 = *((struct drm_framebuffer **)__cil_tmp28);
    __mptr___0 = __cil_tmp29;
    __cil_tmp30 = (struct vmw_framebuffer *)0;
    __cil_tmp31 = (struct drm_framebuffer *)__cil_tmp30;
    __cil_tmp32 = (unsigned int )__cil_tmp31;
    __cil_tmp33 = (char *)__mptr___0;
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
    vfb = (struct vmw_framebuffer *)__cil_tmp34;
  } else {
    __cil_tmp35 = (void *)0;
    vfb = (struct vmw_framebuffer *)__cil_tmp35;
  }
  __cil_tmp36 = *((struct drm_device **)crtc);
  dev_priv = vmw_priv(__cil_tmp36);
  __cil_tmp37 = (unsigned long )set;
  __cil_tmp38 = __cil_tmp37 + 56UL;
  __cil_tmp39 = *((size_t *)__cil_tmp38);
  if (__cil_tmp39 > 1UL) {
    drm_err("vmw_ldu_crtc_set_config", "to many connectors\n");
    return (-22);
  }
  __cil_tmp40 = (unsigned long )set;
  __cil_tmp41 = __cil_tmp40 + 56UL;
  __cil_tmp42 = *((size_t *)__cil_tmp41);
  if (__cil_tmp42 == 1UL) {
    __cil_tmp43 = 616;
    __cil_tmp44 = (unsigned long )ldu;
    __cil_tmp45 = __cil_tmp44 + __cil_tmp43;
    __cil_tmp46 = (struct drm_connector *)__cil_tmp45;
    __cil_tmp47 = (unsigned long )__cil_tmp46;
    __cil_tmp48 = (unsigned long )set;
    __cil_tmp49 = __cil_tmp48 + 48UL;
    __cil_tmp50 = *((struct drm_connector ***)__cil_tmp49);
    __cil_tmp51 = __cil_tmp50 + 0;
    __cil_tmp52 = *__cil_tmp51;
    __cil_tmp53 = (unsigned long )__cil_tmp52;
    if (__cil_tmp53 != __cil_tmp47) {
      __cil_tmp54 = (unsigned long )set;
      __cil_tmp55 = __cil_tmp54 + 48UL;
      __cil_tmp56 = *((struct drm_connector ***)__cil_tmp55);
      __cil_tmp57 = __cil_tmp56 + 0;
      __cil_tmp58 = *__cil_tmp57;
      __cil_tmp59 = 616;
      __cil_tmp60 = (unsigned long )ldu;
      __cil_tmp61 = __cil_tmp60 + __cil_tmp59;
      __cil_tmp62 = (struct drm_connector *)__cil_tmp61;
      drm_err("vmw_ldu_crtc_set_config", "connector doesn\'t match %p %p\n", __cil_tmp58,
              __cil_tmp62);
      return (-22);
    }
  }
  __cil_tmp63 = (unsigned long )dev_priv;
  __cil_tmp64 = __cil_tmp63 + 2608UL;
  __cil_tmp65 = *((struct vmw_legacy_display **)__cil_tmp64);
  __cil_tmp66 = (unsigned long )__cil_tmp65;
  __cil_tmp67 = __cil_tmp66 + 24UL;
  if (*((struct vmw_framebuffer **)__cil_tmp67)) {
    if (vfb) {
      __cil_tmp68 = (unsigned long )dev_priv;
      __cil_tmp69 = __cil_tmp68 + 2608UL;
      __cil_tmp70 = *((struct vmw_legacy_display **)__cil_tmp69);
      __cil_tmp71 = (unsigned long )__cil_tmp70;
      __cil_tmp72 = __cil_tmp71 + 16UL;
      __cil_tmp73 = *((unsigned int *)__cil_tmp72);
      if (__cil_tmp73 == 1U) {
        __cil_tmp74 = (unsigned long )ldu;
        __cil_tmp75 = __cil_tmp74 + 2072UL;
        __cil_tmp76 = (struct list_head *)__cil_tmp75;
        __cil_tmp77 = __cil_tmp76;
        tmp___7 = list_empty(__cil_tmp77);
        if (tmp___7) {
          goto _L;
        }
      } else {
        _L: 
        __cil_tmp78 = (unsigned long )vfb;
        __cil_tmp79 = (unsigned long )dev_priv;
        __cil_tmp80 = __cil_tmp79 + 2608UL;
        __cil_tmp81 = *((struct vmw_legacy_display **)__cil_tmp80);
        __cil_tmp82 = (unsigned long )__cil_tmp81;
        __cil_tmp83 = __cil_tmp82 + 24UL;
        __cil_tmp84 = *((struct vmw_framebuffer **)__cil_tmp83);
        __cil_tmp85 = (unsigned long )__cil_tmp84;
        if (__cil_tmp85 != __cil_tmp78) {
          drm_err("vmw_ldu_crtc_set_config", "Multiple framebuffers not supported\n");
          return (-22);
        }
      }
    }
  }
  __cil_tmp86 = 616;
  __cil_tmp87 = (unsigned long )ldu;
  __cil_tmp88 = __cil_tmp87 + __cil_tmp86;
  connector = (struct drm_connector *)__cil_tmp88;
  __cil_tmp89 = 544;
  __cil_tmp90 = (unsigned long )ldu;
  __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
  encoder = (struct drm_encoder *)__cil_tmp91;
  __cil_tmp92 = (unsigned long )set;
  __cil_tmp93 = __cil_tmp92 + 56UL;
  __cil_tmp94 = *((size_t *)__cil_tmp93);
  if (__cil_tmp94 == 0UL) {
    goto _L___0;
  } else {
    __cil_tmp95 = (unsigned long )set;
    __cil_tmp96 = __cil_tmp95 + 32UL;
    __cil_tmp97 = *((struct drm_display_mode **)__cil_tmp96);
    if (! __cil_tmp97) {
      goto _L___0;
    } else {
      __cil_tmp98 = (unsigned long )set;
      __cil_tmp99 = __cil_tmp98 + 16UL;
      __cil_tmp100 = *((struct drm_framebuffer **)__cil_tmp99);
      if (! __cil_tmp100) {
        _L___0: 
        __cil_tmp101 = (unsigned long )connector;
        __cil_tmp102 = __cil_tmp101 + 1208UL;
        __cil_tmp103 = (void *)0;
        *((struct drm_encoder **)__cil_tmp102) = (struct drm_encoder *)__cil_tmp103;
        __cil_tmp104 = (unsigned long )encoder;
        __cil_tmp105 = __cil_tmp104 + 48UL;
        __cil_tmp106 = (void *)0;
        *((struct drm_crtc **)__cil_tmp105) = (struct drm_crtc *)__cil_tmp106;
        __cil_tmp107 = (unsigned long )crtc;
        __cil_tmp108 = __cil_tmp107 + 32UL;
        __cil_tmp109 = (void *)0;
        *((struct drm_framebuffer **)__cil_tmp108) = (struct drm_framebuffer *)__cil_tmp109;
        vmw_ldu_del_active(dev_priv, ldu);
        tmp___8 = vmw_ldu_commit_list(dev_priv);
        return (tmp___8);
      }
    }
  }
  __cil_tmp110 = (unsigned long )set;
  __cil_tmp111 = __cil_tmp110 + 32UL;
  mode = *((struct drm_display_mode **)__cil_tmp111);
  __cil_tmp112 = (unsigned long )set;
  __cil_tmp113 = __cil_tmp112 + 16UL;
  fb = *((struct drm_framebuffer **)__cil_tmp113);
  __cil_tmp114 = (unsigned long )fb;
  __cil_tmp115 = __cil_tmp114 + 72UL;
  __cil_tmp116 = *((unsigned int *)__cil_tmp115);
  __cil_tmp117 = (unsigned long )mode;
  __cil_tmp118 = __cil_tmp117 + 68UL;
  __cil_tmp119 = *((int *)__cil_tmp118);
  __cil_tmp120 = (uint32_t )__cil_tmp119;
  __cil_tmp121 = (unsigned long )set;
  __cil_tmp122 = __cil_tmp121 + 40UL;
  __cil_tmp123 = *((uint32_t *)__cil_tmp122);
  __cil_tmp124 = __cil_tmp123 + __cil_tmp120;
  if (__cil_tmp124 > __cil_tmp116) {
    drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
    return (-22);
  } else {
    __cil_tmp125 = (unsigned long )fb;
    __cil_tmp126 = __cil_tmp125 + 76UL;
    __cil_tmp127 = *((unsigned int *)__cil_tmp126);
    __cil_tmp128 = (unsigned long )mode;
    __cil_tmp129 = __cil_tmp128 + 88UL;
    __cil_tmp130 = *((int *)__cil_tmp129);
    __cil_tmp131 = (uint32_t )__cil_tmp130;
    __cil_tmp132 = (unsigned long )set;
    __cil_tmp133 = __cil_tmp132 + 44UL;
    __cil_tmp134 = *((uint32_t *)__cil_tmp133);
    __cil_tmp135 = __cil_tmp134 + __cil_tmp131;
    if (__cil_tmp135 > __cil_tmp127) {
      drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
      return (-22);
    }
  }
  vmw_fb_off(dev_priv);
  __cil_tmp136 = (unsigned long )crtc;
  __cil_tmp137 = __cil_tmp136 + 32UL;
  *((struct drm_framebuffer **)__cil_tmp137) = fb;
  __cil_tmp138 = (unsigned long )encoder;
  __cil_tmp139 = __cil_tmp138 + 48UL;
  *((struct drm_crtc **)__cil_tmp139) = crtc;
  __cil_tmp140 = (unsigned long )connector;
  __cil_tmp141 = __cil_tmp140 + 1208UL;
  *((struct drm_encoder **)__cil_tmp141) = encoder;
  __cil_tmp142 = (unsigned long )crtc;
  __cil_tmp143 = __cil_tmp142 + 480UL;
  __cil_tmp144 = (unsigned long )set;
  __cil_tmp145 = __cil_tmp144 + 40UL;
  __cil_tmp146 = *((uint32_t *)__cil_tmp145);
  *((int *)__cil_tmp143) = (int )__cil_tmp146;
  __cil_tmp147 = (unsigned long )crtc;
  __cil_tmp148 = __cil_tmp147 + 484UL;
  __cil_tmp149 = (unsigned long )set;
  __cil_tmp150 = __cil_tmp149 + 44UL;
  __cil_tmp151 = *((uint32_t *)__cil_tmp150);
  *((int *)__cil_tmp148) = (int )__cil_tmp151;
  __cil_tmp152 = (unsigned long )crtc;
  __cil_tmp153 = __cil_tmp152 + 48UL;
  *((struct drm_display_mode *)__cil_tmp153) = *mode;
  vmw_ldu_add_active(dev_priv, ldu, vfb);
  tmp___9 = vmw_ldu_commit_list(dev_priv);
  return (tmp___9);
}
}
static struct drm_crtc_funcs vmw_legacy_crtc_funcs  = 
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, (void (*)(struct drm_crtc *crtc ))0,
    & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move, & vmw_du_crtc_gamma_set,
    & vmw_ldu_crtc_destroy, & vmw_ldu_crtc_set_config, (int (*)(struct drm_crtc *crtc ,
                                                                struct drm_framebuffer *fb ,
                                                                struct drm_pending_vblank_event *event ))0};
static void vmw_ldu_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_legacy_display_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_encoder *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_legacy_display_unit *__cil_tmp11 ;

  {
  __mptr = encoder;
  __cil_tmp3 = 544;
  __cil_tmp4 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
  __cil_tmp7 = (struct drm_encoder *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  __cil_tmp11 = (struct vmw_legacy_display_unit *)__cil_tmp10;
  vmw_ldu_destroy(__cil_tmp11);
  return;
}
}
static struct drm_encoder_funcs vmw_legacy_encoder_funcs  =    {(void (*)(struct drm_encoder *encoder ))0, & vmw_ldu_encoder_destroy};
static void vmw_ldu_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_legacy_display_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_connector *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_legacy_display_unit *__cil_tmp11 ;

  {
  __mptr = connector;
  __cil_tmp3 = 616;
  __cil_tmp4 = (struct vmw_legacy_display_unit *)0;
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
  __cil_tmp7 = (struct drm_connector *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  __cil_tmp11 = (struct vmw_legacy_display_unit *)__cil_tmp10;
  vmw_ldu_destroy(__cil_tmp11);
  return;
}
}
static struct drm_connector_funcs vmw_legacy_connector_funcs  = 
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    (void (*)(struct drm_connector *connector ))0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes,
    & vmw_du_connector_set_property, & vmw_ldu_connector_destroy, (void (*)(struct drm_connector *connector ))0};
static int vmw_ldu_init(struct vmw_private *dev_priv ,
                        unsigned int unit ) 
{ struct vmw_legacy_display_unit *ldu ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct drm_connector_funcs *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  bool __cil_tmp47 ;
  struct drm_encoder_funcs *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct drm_crtc_funcs *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct drm_property *__cil_tmp58 ;
  uint64_t __cil_tmp59 ;

  {
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp10);
  tmp___7 = kzalloc(2088UL, 208U);
  ldu = (struct vmw_legacy_display_unit *)tmp___7;
  if (! ldu) {
    return (-12);
  }
  __cil_tmp11 = 2032;
  __cil_tmp12 = (unsigned long )ldu;
  __cil_tmp13 = __cil_tmp12 + __cil_tmp11;
  *((unsigned int *)__cil_tmp13) = unit;
  crtc = (struct drm_crtc *)ldu;
  __cil_tmp14 = 544;
  __cil_tmp15 = (unsigned long )ldu;
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
  encoder = (struct drm_encoder *)__cil_tmp16;
  __cil_tmp17 = 616;
  __cil_tmp18 = (unsigned long )ldu;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  connector = (struct drm_connector *)__cil_tmp19;
  __cil_tmp20 = (unsigned long )ldu;
  __cil_tmp21 = __cil_tmp20 + 2072UL;
  __cil_tmp22 = (struct list_head *)__cil_tmp21;
  INIT_LIST_HEAD(__cil_tmp22);
  __cil_tmp23 = 2044;
  __cil_tmp24 = (unsigned long )ldu;
  __cil_tmp25 = __cil_tmp24 + __cil_tmp23;
  __cil_tmp26 = unit == 0U;
  *((bool *)__cil_tmp25) = (bool )__cil_tmp26;
  __cil_tmp27 = 2036;
  __cil_tmp28 = (unsigned long )ldu;
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
  __cil_tmp30 = (unsigned long )dev_priv;
  __cil_tmp31 = __cil_tmp30 + 2132UL;
  *((unsigned int *)__cil_tmp29) = *((uint32_t *)__cil_tmp31);
  __cil_tmp32 = 2040;
  __cil_tmp33 = (unsigned long )ldu;
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2136UL;
  *((unsigned int *)__cil_tmp34) = *((uint32_t *)__cil_tmp36);
  __cil_tmp37 = 2048;
  __cil_tmp38 = (unsigned long )ldu;
  __cil_tmp39 = __cil_tmp38 + __cil_tmp37;
  __cil_tmp40 = (void *)0;
  *((struct drm_display_mode **)__cil_tmp39) = (struct drm_display_mode *)__cil_tmp40;
  __cil_tmp41 = 2064;
  __cil_tmp42 = (unsigned long )ldu;
  __cil_tmp43 = __cil_tmp42 + __cil_tmp41;
  *((bool *)__cil_tmp43) = (bool )1;
  __cil_tmp44 = & vmw_legacy_connector_funcs;
  drm_connector_init(dev, connector, __cil_tmp44, 15);
  __cil_tmp45 = (unsigned long )connector;
  __cil_tmp46 = __cil_tmp45 + 840UL;
  __cil_tmp47 = (bool )1;
  *((enum drm_connector_status *)__cil_tmp46) = vmw_du_connector_detect(connector,
                                                                        __cil_tmp47);
  __cil_tmp48 = & vmw_legacy_encoder_funcs;
  drm_encoder_init(dev, encoder, __cil_tmp48, 5);
  drm_mode_connector_attach_encoder(connector, encoder);
  __cil_tmp49 = (unsigned long )encoder;
  __cil_tmp50 = __cil_tmp49 + 36UL;
  __cil_tmp51 = 1 << unit;
  *((uint32_t *)__cil_tmp50) = (uint32_t )__cil_tmp51;
  __cil_tmp52 = (unsigned long )encoder;
  __cil_tmp53 = __cil_tmp52 + 40UL;
  *((uint32_t *)__cil_tmp53) = (uint32_t )0;
  __cil_tmp54 = & vmw_legacy_crtc_funcs;
  drm_crtc_init(dev, crtc, __cil_tmp54);
  drm_mode_crtc_set_gamma_size(crtc, 256);
  __cil_tmp55 = 1800;
  __cil_tmp56 = (unsigned long )dev;
  __cil_tmp57 = __cil_tmp56 + __cil_tmp55;
  __cil_tmp58 = *((struct drm_property **)__cil_tmp57);
  __cil_tmp59 = (uint64_t )1;
  drm_connector_attach_property(connector, __cil_tmp58, __cil_tmp59);
  return (0);
}
}
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_legacy_display *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct vmw_legacy_display *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_legacy_display *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct vmw_legacy_display *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_legacy_display *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct vmw_legacy_display *__cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp7);
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2608UL;
  if (*((struct vmw_legacy_display **)__cil_tmp9)) {
    printk("<6>[drm] ldu system already on\n");
    return (-22);
  }
  tmp___7 = kmalloc(32UL, 208U);
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 2608UL;
  *((struct vmw_legacy_display **)__cil_tmp11) = (struct vmw_legacy_display *)tmp___7;
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 2608UL;
  __cil_tmp14 = *((struct vmw_legacy_display **)__cil_tmp13);
  if (! __cil_tmp14) {
    return (-12);
  }
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2608UL;
  __cil_tmp17 = *((struct vmw_legacy_display **)__cil_tmp16);
  __cil_tmp18 = (struct list_head *)__cil_tmp17;
  INIT_LIST_HEAD(__cil_tmp18);
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + 2608UL;
  __cil_tmp21 = *((struct vmw_legacy_display **)__cil_tmp20);
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = __cil_tmp22 + 16UL;
  *((unsigned int *)__cil_tmp23) = 0U;
  __cil_tmp24 = (unsigned long )dev_priv;
  __cil_tmp25 = __cil_tmp24 + 2608UL;
  __cil_tmp26 = *((struct vmw_legacy_display **)__cil_tmp25);
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = __cil_tmp27 + 20UL;
  *((unsigned int *)__cil_tmp28) = 0U;
  __cil_tmp29 = (unsigned long )dev_priv;
  __cil_tmp30 = __cil_tmp29 + 2608UL;
  __cil_tmp31 = *((struct vmw_legacy_display **)__cil_tmp30);
  __cil_tmp32 = (unsigned long )__cil_tmp31;
  __cil_tmp33 = __cil_tmp32 + 24UL;
  __cil_tmp34 = (void *)0;
  *((struct vmw_framebuffer **)__cil_tmp33) = (struct vmw_framebuffer *)__cil_tmp34;
  __cil_tmp35 = (unsigned long )dev_priv;
  __cil_tmp36 = __cil_tmp35 + 2156UL;
  __cil_tmp37 = *((uint32_t *)__cil_tmp36);
  if (__cil_tmp37 & 65536U) {
    ret = drm_vblank_init(dev, 8);
  } else {
    ret = drm_vblank_init(dev, 1);
  }
  if (ret != 0) {
    goto err_free;
  }
  ret = drm_mode_create_dirty_info_property(dev);
  if (ret != 0) {
    goto err_vblank_cleanup;
  }
  __cil_tmp38 = (unsigned long )dev_priv;
  __cil_tmp39 = __cil_tmp38 + 2156UL;
  __cil_tmp40 = *((uint32_t *)__cil_tmp39);
  if (__cil_tmp40 & 65536U) {
    i = 0;
    while (1) {

      if (! (i < 8)) {
        goto while_break;
      }
      __cil_tmp41 = (unsigned int )i;
      vmw_ldu_init(dev_priv, __cil_tmp41);
      i ++;
    }
    while_break: ;
  } else {
    vmw_ldu_init(dev_priv, 0U);
  }
  return (0);
  err_vblank_cleanup: 
  drm_vblank_cleanup(dev);
  err_free: 
  __cil_tmp42 = (unsigned long )dev_priv;
  __cil_tmp43 = __cil_tmp42 + 2608UL;
  __cil_tmp44 = *((struct vmw_legacy_display **)__cil_tmp43);
  __cil_tmp45 = (void *)__cil_tmp44;
  kfree(__cil_tmp45);
  __cil_tmp46 = (unsigned long )dev_priv;
  __cil_tmp47 = __cil_tmp46 + 2608UL;
  __cil_tmp48 = (void *)0;
  *((struct vmw_legacy_display **)__cil_tmp47) = (struct vmw_legacy_display *)__cil_tmp48;
  return (ret);
}
}
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_legacy_display *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct vmw_legacy_display *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_legacy_display *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp7);
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2608UL;
  __cil_tmp10 = *((struct vmw_legacy_display **)__cil_tmp9);
  if (! __cil_tmp10) {
    return (-38);
  }
  drm_vblank_cleanup(dev);
  while (1) {
    __cil_tmp11 = (unsigned long )dev_priv;
    __cil_tmp12 = __cil_tmp11 + 2608UL;
    __cil_tmp13 = *((struct vmw_legacy_display **)__cil_tmp12);
    __cil_tmp14 = (struct list_head *)__cil_tmp13;
    __cil_tmp15 = __cil_tmp14;
    tmp___7 = list_empty(__cil_tmp15);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    __cil_tmp16 = (long )tmp___8;
    tmp___9 = ldv__builtin_expect(__cil_tmp16, 0L);
    if (tmp___9) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c"),
                             "i" (440), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp17 = (unsigned long )dev_priv;
  __cil_tmp18 = __cil_tmp17 + 2608UL;
  __cil_tmp19 = *((struct vmw_legacy_display **)__cil_tmp18);
  __cil_tmp20 = (void *)__cil_tmp19;
  kfree(__cil_tmp20);
  return (0);
}
}
void ldv_main10_sequence_infinite_withcheck_stateful(void) 
{ struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___8 = __VERIFIER_nondet_int();
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = __VERIFIER_nondet_int();
    if (tmp___7 == 0) {
      goto case_0;
    } else
    if (tmp___7 == 1) {
      goto case_1;
    } else
    if (tmp___7 == 2) {
      goto case_2;
    } else
    if (tmp___7 == 3) {
      goto case_3;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_ldu_crtc_destroy(var_group1);
        goto switch_break;
        case_1: 
        vmw_ldu_crtc_set_config(var_group2);
        goto switch_break;
        case_2: 
        vmw_ldu_encoder_destroy(var_group3);
        goto switch_break;
        case_3: 
        vmw_ldu_connector_destroy(var_group4);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: 
  ldv_check_final_state();
  return;
}
}
extern int drm_global_item_ref(struct drm_global_reference *ref ) ;
extern void drm_global_item_unref(struct drm_global_reference *ref ) ;
extern int ttm_bo_mmap(struct file *filp , struct vm_area_struct *vma , struct ttm_bo_device *bdev ) ;
extern int ttm_mem_global_init(struct ttm_mem_global *glob ) ;
extern void ttm_mem_global_release(struct ttm_mem_global *glob ) ;
extern void ttm_bo_global_release(struct drm_global_reference *ref ) ;
extern int ttm_bo_global_init(struct drm_global_reference *ref ) ;
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  long tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct drm_minor *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct drm_device *__cil_tmp22 ;
  struct ttm_bo_device *__cil_tmp23 ;

  {
  __cil_tmp7 = (unsigned long )vma;
  __cil_tmp8 = __cil_tmp7 + 144UL;
  __cil_tmp9 = *((unsigned long *)__cil_tmp8);
  __cil_tmp10 = __cil_tmp9 < 1048576UL;
  __cil_tmp11 = ! __cil_tmp10;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = (long )__cil_tmp12;
  tmp___7 = ldv__builtin_expect(__cil_tmp13, 0L);
  if (tmp___7) {
    drm_err("vmw_mmap", "Illegal attempt to mmap old fifo space.\n");
    return (-22);
  }
  __cil_tmp14 = (unsigned long )filp;
  __cil_tmp15 = __cil_tmp14 + 200UL;
  __cil_tmp16 = *((void **)__cil_tmp15);
  file_priv = (struct drm_file *)__cil_tmp16;
  __cil_tmp17 = (unsigned long )file_priv;
  __cil_tmp18 = __cil_tmp17 + 40UL;
  __cil_tmp19 = *((struct drm_minor **)__cil_tmp18);
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = __cil_tmp20 + 784UL;
  __cil_tmp22 = *((struct drm_device **)__cil_tmp21);
  dev_priv = vmw_priv(__cil_tmp22);
  __cil_tmp23 = (struct ttm_bo_device *)dev_priv;
  tmp___8 = ttm_bo_mmap(filp, vma, __cil_tmp23);
  return (tmp___8);
}
}
static int vmw_ttm_mem_global_init(struct drm_global_reference *ref ) 
{ int tmp___7 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  struct ttm_mem_global *__cil_tmp6 ;

  {
  printk("<6>[drm] global init.\n");
  __cil_tmp3 = (unsigned long )ref;
  __cil_tmp4 = __cil_tmp3 + 16UL;
  __cil_tmp5 = *((void **)__cil_tmp4);
  __cil_tmp6 = (struct ttm_mem_global *)__cil_tmp5;
  tmp___7 = ttm_mem_global_init(__cil_tmp6);
  return (tmp___7);
}
}
static void vmw_ttm_mem_global_release(struct drm_global_reference *ref ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;
  struct ttm_mem_global *__cil_tmp5 ;

  {
  __cil_tmp2 = (unsigned long )ref;
  __cil_tmp3 = __cil_tmp2 + 16UL;
  __cil_tmp4 = *((void **)__cil_tmp3);
  __cil_tmp5 = (struct ttm_mem_global *)__cil_tmp4;
  ttm_mem_global_release(__cil_tmp5);
  return;
}
}
int vmw_ttm_global_init(struct vmw_private *dev_priv ) 
{ struct drm_global_reference *global_ref ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct drm_global_reference *__cil_tmp39 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 1816UL;
  global_ref = (struct drm_global_reference *)__cil_tmp7;
  *((enum drm_global_types *)global_ref) = (enum drm_global_types )0;
  __cil_tmp8 = (unsigned long )global_ref;
  __cil_tmp9 = __cil_tmp8 + 8UL;
  *((size_t *)__cil_tmp9) = 216UL;
  __cil_tmp10 = (unsigned long )global_ref;
  __cil_tmp11 = __cil_tmp10 + 24UL;
  *((int (**)(struct drm_global_reference * ))__cil_tmp11) = & vmw_ttm_mem_global_init;
  __cil_tmp12 = (unsigned long )global_ref;
  __cil_tmp13 = __cil_tmp12 + 32UL;
  *((void (**)(struct drm_global_reference * ))__cil_tmp13) = & vmw_ttm_mem_global_release;
  ret = drm_global_item_ref(global_ref);
  __cil_tmp14 = ret != 0;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = (long )__cil_tmp16;
  tmp___7 = ldv__builtin_expect(__cil_tmp17, 0L);
  if (tmp___7) {
    drm_err("vmw_ttm_global_init", "Failed setting up TTM memory accounting.\n");
    return (ret);
  }
  __cil_tmp18 = 1808;
  __cil_tmp19 = (unsigned long )dev_priv;
  __cil_tmp20 = __cil_tmp19 + __cil_tmp18;
  __cil_tmp21 = 1832;
  __cil_tmp22 = (unsigned long )dev_priv;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  __cil_tmp24 = *((void **)__cil_tmp23);
  *((struct ttm_mem_global **)__cil_tmp20) = (struct ttm_mem_global *)__cil_tmp24;
  __cil_tmp25 = (unsigned long )dev_priv;
  __cil_tmp26 = __cil_tmp25 + 1768UL;
  global_ref = (struct drm_global_reference *)__cil_tmp26;
  *((enum drm_global_types *)global_ref) = (enum drm_global_types )1;
  __cil_tmp27 = (unsigned long )global_ref;
  __cil_tmp28 = __cil_tmp27 + 8UL;
  *((size_t *)__cil_tmp28) = 224UL;
  __cil_tmp29 = (unsigned long )global_ref;
  __cil_tmp30 = __cil_tmp29 + 24UL;
  *((int (**)(struct drm_global_reference * ))__cil_tmp30) = & ttm_bo_global_init;
  __cil_tmp31 = (unsigned long )global_ref;
  __cil_tmp32 = __cil_tmp31 + 32UL;
  *((void (**)(struct drm_global_reference * ))__cil_tmp32) = & ttm_bo_global_release;
  ret = drm_global_item_ref(global_ref);
  __cil_tmp33 = ret != 0;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = (long )__cil_tmp35;
  tmp___8 = ldv__builtin_expect(__cil_tmp36, 0L);
  if (tmp___8) {
    drm_err("vmw_ttm_global_init", "Failed setting up TTM buffer objects.\n");
    goto out_no_bo;
  }
  return (0);
  out_no_bo: 
  __cil_tmp37 = (unsigned long )dev_priv;
  __cil_tmp38 = __cil_tmp37 + 1816UL;
  __cil_tmp39 = (struct drm_global_reference *)__cil_tmp38;
  drm_global_item_unref(__cil_tmp39);
  return (ret);
}
}
void vmw_ttm_global_release(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct drm_global_reference *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_global_reference *__cil_tmp7 ;

  {
  __cil_tmp2 = (unsigned long )dev_priv;
  __cil_tmp3 = __cil_tmp2 + 1768UL;
  __cil_tmp4 = (struct drm_global_reference *)__cil_tmp3;
  drm_global_item_unref(__cil_tmp4);
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 1816UL;
  __cil_tmp7 = (struct drm_global_reference *)__cil_tmp6;
  drm_global_item_unref(__cil_tmp7);
  return;
}
}
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) ;
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) ;
 static void fill_escape(struct vmw_escape_header *header , uint32_t size )  __attribute__((__no_instrument_function__)) ;
 static void fill_escape(struct vmw_escape_header *header , uint32_t size )  __attribute__((__no_instrument_function__)) ;
 static void fill_escape(struct vmw_escape_header *header , uint32_t size ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  *((uint32_t *)header) = (uint32_t )33;
  __cil_tmp3 = (unsigned long )header;
  __cil_tmp4 = __cil_tmp3 + 4UL;
  *((uint32 *)__cil_tmp4) = (uint32 )0;
  __cil_tmp5 = 8;
  __cil_tmp6 = (unsigned long )header;
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
  *((uint32 *)__cil_tmp7) = size;
  return;
}
}
 static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id )  __attribute__((__no_instrument_function__)) ;
 static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id )  __attribute__((__no_instrument_function__)) ;
 static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id ) 
{ struct vmw_escape_header *__cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
  __cil_tmp3 = (struct vmw_escape_header *)cmd;
  __cil_tmp4 = (uint32_t )8UL;
  fill_escape(__cil_tmp3, __cil_tmp4);
  __cil_tmp5 = (unsigned long )cmd;
  __cil_tmp6 = __cil_tmp5 + 12UL;
  *((uint32 *)__cil_tmp6) = (uint32 )131074;
  __cil_tmp7 = 16;
  __cil_tmp8 = (unsigned long )cmd;
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
  *((uint32 *)__cil_tmp9) = stream_id;
  return;
}
}
static int vmw_overlay_send_put(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_escape_video_flush *flush ;
  size_t fifo_size ;
  bool have_so ;
  int tmp___7 ;
  int i ;
  int num_items ;
  SVGAGuestPtr ptr ;
  struct __anonstruct_cmds_440 *cmds ;
  struct __anonstruct_items_442 *items ;
  void *tmp___8 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  struct __anonstruct_cmds_440 *__cil_tmp21 ;
  struct __anonstruct_items_442 *__cil_tmp22 ;
  struct vmw_escape_header *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct __anonstruct_items_442 *__cil_tmp33 ;
  struct ttm_buffer_object *__cil_tmp34 ;
  struct ttm_buffer_object *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32 __cil_tmp41 ;
  struct __anonstruct_items_442 *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct __anonstruct_items_442 *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct __anonstruct_items_442 *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct __anonstruct_items_442 *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int32_t __cil_tmp59 ;
  struct __anonstruct_items_442 *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct __anonstruct_items_442 *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct __anonstruct_items_442 *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  struct __anonstruct_items_442 *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  struct __anonstruct_items_442 *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  int32_t __cil_tmp85 ;
  struct __anonstruct_items_442 *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  int32_t __cil_tmp92 ;
  struct __anonstruct_items_442 *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct __anonstruct_items_442 *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  struct __anonstruct_items_442 *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  int32_t __cil_tmp110 ;
  struct __anonstruct_items_442 *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  int32_t __cil_tmp117 ;
  struct __anonstruct_items_442 *__cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  struct __anonstruct_items_442 *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  struct __anonstruct_items_442 *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  struct __anonstruct_items_442 *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  struct __anonstruct_items_442 *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  struct __anonstruct_items_442 *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  SVGAGuestPtr *__cil_tmp154 ;
  struct __anonstruct_items_442 *__cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  uint32_t __cil_tmp158 ;
  uint32_t __cil_tmp159 ;

  {
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2616UL;
  if (*((struct vmw_screen_object_display **)__cil_tmp16)) {
    tmp___7 = 1;
  } else {
    tmp___7 = 0;
  }
  have_so = (bool )tmp___7;
  if (have_so) {
    num_items = 21;
  } else {
    num_items = 19;
  }
  __cil_tmp17 = (unsigned long )num_items;
  __cil_tmp18 = 8UL * __cil_tmp17;
  __cil_tmp19 = 40UL;
  fifo_size = __cil_tmp19 + __cil_tmp18;
  __cil_tmp20 = (uint32_t )fifo_size;
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp20);
  cmds = (struct __anonstruct_cmds_440 *)tmp___8;
  if (! cmds) {
    return (-12);
  }
  __cil_tmp21 = cmds + 1;
  items = (struct __anonstruct_items_442 *)__cil_tmp21;
  __cil_tmp22 = items + num_items;
  flush = (struct vmw_escape_video_flush *)__cil_tmp22;
  __cil_tmp23 = (struct vmw_escape_header *)cmds;
  __cil_tmp24 = num_items + 1;
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  __cil_tmp26 = 8UL * __cil_tmp25;
  __cil_tmp27 = (uint32_t )__cil_tmp26;
  fill_escape(__cil_tmp23, __cil_tmp27);
  __cil_tmp28 = (unsigned long )cmds;
  __cil_tmp29 = __cil_tmp28 + 12UL;
  *((uint32_t *)__cil_tmp29) = (uint32_t )131073;
  __cil_tmp30 = 16;
  __cil_tmp31 = (unsigned long )cmds;
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
  *((uint32_t *)__cil_tmp32) = *((uint32_t *)arg);
  i = 0;
  while (1) {

    if (! (i < num_items)) {
      goto while_break;
    }
    __cil_tmp33 = items + i;
    *((uint32_t *)__cil_tmp33) = (uint32_t )i;
    i ++;
  }
  while_break: 
  __cil_tmp34 = (struct ttm_buffer_object *)buf;
  __cil_tmp35 = __cil_tmp34;
  vmw_bo_get_guest_ptr(__cil_tmp35, & ptr);
  __cil_tmp36 = (unsigned long )(& ptr) + 4UL;
  __cil_tmp37 = (unsigned long )arg;
  __cil_tmp38 = __cil_tmp37 + 20UL;
  __cil_tmp39 = *((uint32_t *)__cil_tmp38);
  __cil_tmp40 = (unsigned long )(& ptr) + 4UL;
  __cil_tmp41 = *((uint32 *)__cil_tmp40);
  *((uint32 *)__cil_tmp36) = __cil_tmp41 + __cil_tmp39;
  __cil_tmp42 = items + 0;
  __cil_tmp43 = (unsigned long )__cil_tmp42;
  __cil_tmp44 = __cil_tmp43 + 4UL;
  *((uint32_t *)__cil_tmp44) = (uint32_t )1;
  __cil_tmp45 = items + 1;
  __cil_tmp46 = (unsigned long )__cil_tmp45;
  __cil_tmp47 = __cil_tmp46 + 4UL;
  __cil_tmp48 = (unsigned long )arg;
  __cil_tmp49 = __cil_tmp48 + 8UL;
  *((uint32_t *)__cil_tmp47) = *((uint32_t *)__cil_tmp49);
  __cil_tmp50 = items + 2;
  __cil_tmp51 = (unsigned long )__cil_tmp50;
  __cil_tmp52 = __cil_tmp51 + 4UL;
  __cil_tmp53 = (unsigned long )(& ptr) + 4UL;
  *((uint32_t *)__cil_tmp52) = *((uint32 *)__cil_tmp53);
  __cil_tmp54 = items + 3;
  __cil_tmp55 = (unsigned long )__cil_tmp54;
  __cil_tmp56 = __cil_tmp55 + 4UL;
  __cil_tmp57 = (unsigned long )arg;
  __cil_tmp58 = __cil_tmp57 + 24UL;
  __cil_tmp59 = *((int32_t *)__cil_tmp58);
  *((uint32_t *)__cil_tmp56) = (uint32_t )__cil_tmp59;
  __cil_tmp60 = items + 4;
  __cil_tmp61 = (unsigned long )__cil_tmp60;
  __cil_tmp62 = __cil_tmp61 + 4UL;
  __cil_tmp63 = (unsigned long )arg;
  __cil_tmp64 = __cil_tmp63 + 12UL;
  *((uint32_t *)__cil_tmp62) = *((uint32_t *)__cil_tmp64);
  __cil_tmp65 = items + 5;
  __cil_tmp66 = (unsigned long )__cil_tmp65;
  __cil_tmp67 = __cil_tmp66 + 4UL;
  __cil_tmp68 = (unsigned long )arg;
  __cil_tmp69 = __cil_tmp68 + 28UL;
  *((uint32_t *)__cil_tmp67) = *((uint32_t *)__cil_tmp69);
  __cil_tmp70 = items + 6;
  __cil_tmp71 = (unsigned long )__cil_tmp70;
  __cil_tmp72 = __cil_tmp71 + 4UL;
  __cil_tmp73 = (unsigned long )arg;
  __cil_tmp74 = __cil_tmp73 + 32UL;
  *((uint32_t *)__cil_tmp72) = *((uint32_t *)__cil_tmp74);
  __cil_tmp75 = items + 7;
  __cil_tmp76 = (unsigned long )__cil_tmp75;
  __cil_tmp77 = __cil_tmp76 + 4UL;
  __cil_tmp78 = (unsigned long )arg;
  __cil_tmp79 = __cil_tmp78 + 36UL;
  *((uint32_t *)__cil_tmp77) = *((uint32_t *)__cil_tmp79);
  __cil_tmp80 = items + 8;
  __cil_tmp81 = (unsigned long )__cil_tmp80;
  __cil_tmp82 = __cil_tmp81 + 4UL;
  __cil_tmp83 = (unsigned long )arg;
  __cil_tmp84 = __cil_tmp83 + 56UL;
  __cil_tmp85 = *((int32_t *)__cil_tmp84);
  *((uint32_t *)__cil_tmp82) = (uint32_t )__cil_tmp85;
  __cil_tmp86 = items + 9;
  __cil_tmp87 = (unsigned long )__cil_tmp86;
  __cil_tmp88 = __cil_tmp87 + 4UL;
  __cil_tmp89 = 60;
  __cil_tmp90 = (unsigned long )arg;
  __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
  __cil_tmp92 = *((int32_t *)__cil_tmp91);
  *((uint32_t *)__cil_tmp88) = (uint32_t )__cil_tmp92;
  __cil_tmp93 = items + 10;
  __cil_tmp94 = (unsigned long )__cil_tmp93;
  __cil_tmp95 = __cil_tmp94 + 4UL;
  __cil_tmp96 = 64;
  __cil_tmp97 = (unsigned long )arg;
  __cil_tmp98 = __cil_tmp97 + __cil_tmp96;
  *((uint32_t *)__cil_tmp95) = *((uint32_t *)__cil_tmp98);
  __cil_tmp99 = items + 11;
  __cil_tmp100 = (unsigned long )__cil_tmp99;
  __cil_tmp101 = __cil_tmp100 + 4UL;
  __cil_tmp102 = 68;
  __cil_tmp103 = (unsigned long )arg;
  __cil_tmp104 = __cil_tmp103 + __cil_tmp102;
  *((uint32_t *)__cil_tmp101) = *((uint32_t *)__cil_tmp104);
  __cil_tmp105 = items + 12;
  __cil_tmp106 = (unsigned long )__cil_tmp105;
  __cil_tmp107 = __cil_tmp106 + 4UL;
  __cil_tmp108 = (unsigned long )arg;
  __cil_tmp109 = __cil_tmp108 + 72UL;
  __cil_tmp110 = *((int32_t *)__cil_tmp109);
  *((uint32_t *)__cil_tmp107) = (uint32_t )__cil_tmp110;
  __cil_tmp111 = items + 13;
  __cil_tmp112 = (unsigned long )__cil_tmp111;
  __cil_tmp113 = __cil_tmp112 + 4UL;
  __cil_tmp114 = 76;
  __cil_tmp115 = (unsigned long )arg;
  __cil_tmp116 = __cil_tmp115 + __cil_tmp114;
  __cil_tmp117 = *((int32_t *)__cil_tmp116);
  *((uint32_t *)__cil_tmp113) = (uint32_t )__cil_tmp117;
  __cil_tmp118 = items + 14;
  __cil_tmp119 = (unsigned long )__cil_tmp118;
  __cil_tmp120 = __cil_tmp119 + 4UL;
  __cil_tmp121 = 80;
  __cil_tmp122 = (unsigned long )arg;
  __cil_tmp123 = __cil_tmp122 + __cil_tmp121;
  *((uint32_t *)__cil_tmp120) = *((uint32_t *)__cil_tmp123);
  __cil_tmp124 = items + 15;
  __cil_tmp125 = (unsigned long )__cil_tmp124;
  __cil_tmp126 = __cil_tmp125 + 4UL;
  __cil_tmp127 = 84;
  __cil_tmp128 = (unsigned long )arg;
  __cil_tmp129 = __cil_tmp128 + __cil_tmp127;
  *((uint32_t *)__cil_tmp126) = *((uint32_t *)__cil_tmp129);
  __cil_tmp130 = items + 16;
  __cil_tmp131 = (unsigned long )__cil_tmp130;
  __cil_tmp132 = __cil_tmp131 + 4UL;
  __cil_tmp133 = 0UL;
  __cil_tmp134 = 40UL + __cil_tmp133;
  __cil_tmp135 = (unsigned long )arg;
  __cil_tmp136 = __cil_tmp135 + __cil_tmp134;
  *((uint32_t *)__cil_tmp132) = *((uint32_t *)__cil_tmp136);
  __cil_tmp137 = items + 17;
  __cil_tmp138 = (unsigned long )__cil_tmp137;
  __cil_tmp139 = __cil_tmp138 + 4UL;
  __cil_tmp140 = 4UL;
  __cil_tmp141 = 40UL + __cil_tmp140;
  __cil_tmp142 = (unsigned long )arg;
  __cil_tmp143 = __cil_tmp142 + __cil_tmp141;
  *((uint32_t *)__cil_tmp139) = *((uint32_t *)__cil_tmp143);
  __cil_tmp144 = items + 18;
  __cil_tmp145 = (unsigned long )__cil_tmp144;
  __cil_tmp146 = __cil_tmp145 + 4UL;
  __cil_tmp147 = 8UL;
  __cil_tmp148 = 40UL + __cil_tmp147;
  __cil_tmp149 = (unsigned long )arg;
  __cil_tmp150 = __cil_tmp149 + __cil_tmp148;
  *((uint32_t *)__cil_tmp146) = *((uint32_t *)__cil_tmp150);
  if (have_so) {
    __cil_tmp151 = items + 19;
    __cil_tmp152 = (unsigned long )__cil_tmp151;
    __cil_tmp153 = __cil_tmp152 + 4UL;
    __cil_tmp154 = & ptr;
    *((uint32_t *)__cil_tmp153) = *((uint32 *)__cil_tmp154);
    __cil_tmp155 = items + 20;
    __cil_tmp156 = (unsigned long )__cil_tmp155;
    __cil_tmp157 = __cil_tmp156 + 4UL;
    *((uint32_t *)__cil_tmp157) = 4294967295U;
  }
  __cil_tmp158 = *((uint32_t *)arg);
  fill_flush(flush, __cil_tmp158);
  __cil_tmp159 = (uint32_t )fifo_size;
  vmw_fifo_commit(dev_priv, __cil_tmp159);
  return (0);
}
}
static int vmw_overlay_send_stop(struct vmw_private *dev_priv , uint32_t stream_id ,
                                 bool interruptible ) 
{ struct __anonstruct_cmds_443 *cmds ;
  int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  uint32_t __cil_tmp8 ;
  bool __cil_tmp9 ;
  bool __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  struct vmw_escape_header *__cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct vmw_escape_video_flush *__cil_tmp37 ;
  uint32_t __cil_tmp38 ;

  {
  while (1) {
    __cil_tmp8 = (uint32_t )48UL;
    tmp___7 = vmw_fifo_reserve(dev_priv, __cil_tmp8);
    cmds = (struct __anonstruct_cmds_443 *)tmp___7;
    if (cmds) {
      goto while_break;
    }
    __cil_tmp9 = (bool )0;
    __cil_tmp10 = (bool )1;
    __cil_tmp11 = (uint32_t )0;
    ret = vmw_fallback_wait(dev_priv, __cil_tmp9, __cil_tmp10, __cil_tmp11, interruptible,
                            750UL);
    if (interruptible) {
      if (ret == -512) {
        return (ret);
      } else {
        goto _L;
      }
    } else {
      _L: 
      while (1) {
        __cil_tmp12 = ret != 0;
        __cil_tmp13 = ! __cil_tmp12;
        __cil_tmp14 = ! __cil_tmp13;
        __cil_tmp15 = (long )__cil_tmp14;
        tmp___8 = ldv__builtin_expect(__cil_tmp15, 0L);
        if (tmp___8) {
          while (1) {
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                 "i" (205), "i" (12UL));
            while (1) {

            }

            goto while_break___1;
          }
          while_break___1: ;
        }
        goto while_break___0;
      }
      while_break___0: ;
    }
  }
  while_break: 
  __cil_tmp16 = (struct vmw_escape_header *)cmds;
  __cil_tmp17 = (uint32_t )16UL;
  fill_escape(__cil_tmp16, __cil_tmp17);
  __cil_tmp18 = (unsigned long )cmds;
  __cil_tmp19 = __cil_tmp18 + 12UL;
  *((uint32 *)__cil_tmp19) = (uint32 )131073;
  __cil_tmp20 = 4;
  __cil_tmp21 = 12UL + __cil_tmp20;
  __cil_tmp22 = (unsigned long )cmds;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  *((uint32 *)__cil_tmp23) = stream_id;
  __cil_tmp24 = 0UL;
  __cil_tmp25 = 8UL + __cil_tmp24;
  __cil_tmp26 = 12UL + __cil_tmp25;
  __cil_tmp27 = (unsigned long )cmds;
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
  *((uint32 *)__cil_tmp28) = (uint32 )0;
  __cil_tmp29 = 0UL;
  __cil_tmp30 = __cil_tmp29 + 4UL;
  __cil_tmp31 = 8UL + __cil_tmp30;
  __cil_tmp32 = 12UL + __cil_tmp31;
  __cil_tmp33 = (unsigned long )cmds;
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
  *((uint32 *)__cil_tmp34) = (uint32 )0;
  __cil_tmp35 = (unsigned long )cmds;
  __cil_tmp36 = __cil_tmp35 + 28UL;
  __cil_tmp37 = (struct vmw_escape_video_flush *)__cil_tmp36;
  fill_flush(__cil_tmp37, stream_id);
  __cil_tmp38 = (uint32_t )48UL;
  vmw_fifo_commit(dev_priv, __cil_tmp38);
  return (0);
}
}
static int vmw_overlay_move_buffer(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                   bool pin , bool inter ) 
{ int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_screen_object_display *__cil_tmp10 ;
  bool __cil_tmp11 ;
  bool __cil_tmp12 ;

  {
  if (! pin) {
    tmp___7 = vmw_dmabuf_unpin(dev_priv, buf, inter);
    return (tmp___7);
  }
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2616UL;
  __cil_tmp10 = *((struct vmw_screen_object_display **)__cil_tmp9);
  if (! __cil_tmp10) {
    __cil_tmp11 = (bool )1;
    tmp___8 = vmw_dmabuf_to_vram(dev_priv, buf, __cil_tmp11, inter);
    return (tmp___8);
  }
  __cil_tmp12 = (bool )1;
  tmp___9 = vmw_dmabuf_to_vram_or_gmr(dev_priv, buf, __cil_tmp12, inter);
  return (tmp___9);
}
}
static int vmw_overlay_stop(struct vmw_private *dev_priv , uint32_t stream_id , bool pause ,
                            bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_dma_buffer *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  bool __cil_tmp18 ;
  struct vmw_dma_buffer *__cil_tmp19 ;
  bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  struct vmw_dma_buffer **__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;

  {
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp10);
  __cil_tmp11 = (unsigned long )stream_id * 104UL;
  __cil_tmp12 = 72UL + __cil_tmp11;
  __cil_tmp13 = (unsigned long )overlay;
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
  stream = (struct vmw_stream___0 *)__cil_tmp14;
  __cil_tmp15 = *((struct vmw_dma_buffer **)stream);
  if (! __cil_tmp15) {
    return (0);
  }
  __cil_tmp16 = (unsigned long )stream;
  __cil_tmp17 = __cil_tmp16 + 9UL;
  __cil_tmp18 = *((bool *)__cil_tmp17);
  if (! __cil_tmp18) {
    ret = vmw_overlay_send_stop(dev_priv, stream_id, interruptible);
    if (ret) {
      return (ret);
    }
    __cil_tmp19 = *((struct vmw_dma_buffer **)stream);
    __cil_tmp20 = (bool )0;
    ret = vmw_overlay_move_buffer(dev_priv, __cil_tmp19, __cil_tmp20, interruptible);
    if (interruptible) {
      if (ret == -512) {
        return (ret);
      } else {
        goto _L;
      }
    } else {
      _L: 
      while (1) {
        __cil_tmp21 = ret != 0;
        __cil_tmp22 = ! __cil_tmp21;
        __cil_tmp23 = ! __cil_tmp22;
        __cil_tmp24 = (long )__cil_tmp23;
        tmp___7 = ldv__builtin_expect(__cil_tmp24, 0L);
        if (tmp___7) {
          while (1) {
            __asm__  volatile   ("1:\tud2\n"
                                 ".pushsection __bug_table,\"a\"\n"
                                 "2:\t.long 1b - 2b, %c0 - 2b\n"
                                 "\t.word %c1, 0\n"
                                 "\t.org 2b+%c2\n"
                                 ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                 "i" (276), "i" (12UL));
            while (1) {

            }

            goto while_break___0;
          }
          while_break___0: ;
        }
        goto while_break;
      }
      while_break: ;
    }
  }
  if (! pause) {
    __cil_tmp25 = (struct vmw_dma_buffer **)stream;
    vmw_dmabuf_unreference(__cil_tmp25);
    __cil_tmp26 = (unsigned long )stream;
    __cil_tmp27 = __cil_tmp26 + 9UL;
    *((bool *)__cil_tmp27) = (bool )0;
  } else {
    __cil_tmp28 = (unsigned long )stream;
    __cil_tmp29 = __cil_tmp28 + 9UL;
    *((bool *)__cil_tmp29) = (bool )1;
  }
  return (0);
}
}
static int vmw_overlay_update_stream(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                     struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  char *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_dma_buffer *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_dma_buffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  bool __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  bool __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  bool __cil_tmp37 ;
  bool __cil_tmp38 ;
  bool __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct vmw_dma_buffer *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;

  {
  __cil_tmp13 = (unsigned long )dev_priv;
  __cil_tmp14 = __cil_tmp13 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp14);
  __cil_tmp15 = *((uint32_t *)arg);
  __cil_tmp16 = (unsigned long )__cil_tmp15 * 104UL;
  __cil_tmp17 = 72UL + __cil_tmp16;
  __cil_tmp18 = (unsigned long )overlay;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  stream = (struct vmw_stream___0 *)__cil_tmp19;
  ret = 0;
  if (! buf) {
    return (-22);
  }
  while (1) {
    __cil_tmp20 = (unsigned long )stream;
    __cil_tmp21 = __cil_tmp20 + 9UL;
    if (*((bool *)__cil_tmp21)) {
      tmp___7 = "";
    } else {
      tmp___7 = "not ";
    }
    __cil_tmp22 = *((struct vmw_dma_buffer **)stream);
    drm_ut_debug_printk(1U, "drm", "vmw_overlay_update_stream", "   %s: old %p, new %p, %spaused\n",
                        "vmw_overlay_update_stream", __cil_tmp22, buf, tmp___7);
    goto while_break;
  }
  while_break: 
  __cil_tmp23 = (unsigned long )buf;
  __cil_tmp24 = *((struct vmw_dma_buffer **)stream);
  __cil_tmp25 = (unsigned long )__cil_tmp24;
  if (__cil_tmp25 != __cil_tmp23) {
    __cil_tmp26 = *((uint32_t *)arg);
    __cil_tmp27 = (bool )0;
    ret = vmw_overlay_stop(dev_priv, __cil_tmp26, __cil_tmp27, interruptible);
    if (ret) {
      return (ret);
    }
  } else {
    __cil_tmp28 = (unsigned long )stream;
    __cil_tmp29 = __cil_tmp28 + 9UL;
    __cil_tmp30 = *((bool *)__cil_tmp29);
    if (! __cil_tmp30) {
      ret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);
      if (ret == 0) {
        __cil_tmp31 = (unsigned long )stream;
        __cil_tmp32 = __cil_tmp31 + 12UL;
        *((struct drm_vmw_control_stream_arg *)__cil_tmp32) = *arg;
      } else {
        while (1) {
          __cil_tmp33 = ! interruptible;
          __cil_tmp34 = ! __cil_tmp33;
          __cil_tmp35 = ! __cil_tmp34;
          __cil_tmp36 = (long )__cil_tmp35;
          tmp___8 = ldv__builtin_expect(__cil_tmp36, 0L);
          if (tmp___8) {
            while (1) {
              __asm__  volatile   ("1:\tud2\n"
                                   ".pushsection __bug_table,\"a\"\n"
                                   "2:\t.long 1b - 2b, %c0 - 2b\n"
                                   "\t.word %c1, 0\n"
                                   "\t.org 2b+%c2\n"
                                   ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                                   "i" (326), "i" (12UL));
              while (1) {

              }

              goto while_break___1;
            }
            while_break___1: ;
          }
          goto while_break___0;
        }
        while_break___0: ;
      }
      return (ret);
    }
  }
  __cil_tmp37 = (bool )1;
  ret = vmw_overlay_move_buffer(dev_priv, buf, __cil_tmp37, interruptible);
  if (ret) {
    return (ret);
  }
  ret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);
  if (ret) {
    while (1) {
      __cil_tmp38 = (bool )0;
      __cil_tmp39 = (bool )0;
      tmp___9 = vmw_overlay_move_buffer(dev_priv, buf, __cil_tmp38, __cil_tmp39);
      if (tmp___9 != 0) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
      __cil_tmp40 = (long )tmp___10;
      tmp___11 = ldv__builtin_expect(__cil_tmp40, 0L);
      if (tmp___11) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                               "i" (344), "i" (12UL));
          while (1) {

          }

          goto while_break___4;
        }
        while_break___4: ;
      }
      goto while_break___3;
    }
    while_break___3: ;
    return (ret);
  }
  __cil_tmp41 = (unsigned long )buf;
  __cil_tmp42 = *((struct vmw_dma_buffer **)stream);
  __cil_tmp43 = (unsigned long )__cil_tmp42;
  if (__cil_tmp43 != __cil_tmp41) {
    *((struct vmw_dma_buffer **)stream) = vmw_dmabuf_reference(buf);
  }
  __cil_tmp44 = (unsigned long )stream;
  __cil_tmp45 = __cil_tmp44 + 12UL;
  *((struct drm_vmw_control_stream_arg *)__cil_tmp45) = *arg;
  __cil_tmp46 = (unsigned long )stream;
  __cil_tmp47 = __cil_tmp46 + 9UL;
  *((bool *)__cil_tmp47) = (bool )0;
  return (0);
}
}
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct mutex *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_dma_buffer *__cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  bool __cil_tmp17 ;
  bool __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  struct mutex *__cil_tmp28 ;

  {
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp9);
  if (! overlay) {
    return (0);
  }
  __cil_tmp10 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp10);
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp11 = (unsigned long )i * 104UL;
    __cil_tmp12 = 72UL + __cil_tmp11;
    __cil_tmp13 = (unsigned long )overlay;
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
    stream = (struct vmw_stream___0 *)__cil_tmp14;
    __cil_tmp15 = *((struct vmw_dma_buffer **)stream);
    if (! __cil_tmp15) {
      goto __Cont;
    }
    __cil_tmp16 = (uint32_t )i;
    __cil_tmp17 = (bool )0;
    __cil_tmp18 = (bool )0;
    ret = vmw_overlay_stop(dev_priv, __cil_tmp16, __cil_tmp17, __cil_tmp18);
    __cil_tmp19 = ret != 0;
    __cil_tmp20 = ! __cil_tmp19;
    __ret_warn_on = ! __cil_tmp20;
    __cil_tmp21 = ! __ret_warn_on;
    __cil_tmp22 = ! __cil_tmp21;
    __cil_tmp23 = (long )__cil_tmp22;
    tmp___7 = ldv__builtin_expect(__cil_tmp23, 0L);
    if (tmp___7) {
      __cil_tmp24 = 380;
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                         __cil_tmp24);
    }
    __cil_tmp25 = ! __ret_warn_on;
    __cil_tmp26 = ! __cil_tmp25;
    __cil_tmp27 = (long )__cil_tmp26;
    ldv__builtin_expect(__cil_tmp27, 0L);
    __Cont: 
    i ++;
  }
  while_break: 
  __cil_tmp28 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp28);
  return (0);
}
}
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct mutex *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  struct vmw_dma_buffer *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct drm_vmw_control_stream_arg *__cil_tmp19 ;
  bool __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;

  {
  __cil_tmp6 = (unsigned long )dev_priv;
  __cil_tmp7 = __cil_tmp6 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp7);
  if (! overlay) {
    return (0);
  }
  __cil_tmp8 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp8);
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp9 = (unsigned long )i * 104UL;
    __cil_tmp10 = 72UL + __cil_tmp9;
    __cil_tmp11 = (unsigned long )overlay;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    stream = (struct vmw_stream___0 *)__cil_tmp12;
    __cil_tmp13 = (unsigned long )stream;
    __cil_tmp14 = __cil_tmp13 + 9UL;
    __cil_tmp15 = *((bool *)__cil_tmp14);
    if (! __cil_tmp15) {
      goto __Cont;
    }
    __cil_tmp16 = *((struct vmw_dma_buffer **)stream);
    __cil_tmp17 = (unsigned long )stream;
    __cil_tmp18 = __cil_tmp17 + 12UL;
    __cil_tmp19 = (struct drm_vmw_control_stream_arg *)__cil_tmp18;
    __cil_tmp20 = (bool )0;
    ret = vmw_overlay_update_stream(dev_priv, __cil_tmp16, __cil_tmp19, __cil_tmp20);
    if (ret != 0) {
      printk("<6>[drm] %s: *warning* failed to resume stream %i\n", "vmw_overlay_resume_all",
             i);
    }
    __Cont: 
    i ++;
  }
  while_break: 
  __cil_tmp21 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp21);
  return (0);
}
}
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct mutex *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  bool __cil_tmp16 ;
  bool __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  struct mutex *__cil_tmp27 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp8);
  if (! overlay) {
    return (0);
  }
  __cil_tmp9 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp9);
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp10 = (unsigned long )i * 104UL;
    __cil_tmp11 = __cil_tmp10 + 9UL;
    __cil_tmp12 = 72UL + __cil_tmp11;
    __cil_tmp13 = (unsigned long )overlay;
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
    if (*((bool *)__cil_tmp14)) {
      printk("<6>[drm] %s: *warning* stream %i already paused\n", "vmw_overlay_pause_all",
             i);
    }
    __cil_tmp15 = (uint32_t )i;
    __cil_tmp16 = (bool )1;
    __cil_tmp17 = (bool )0;
    ret = vmw_overlay_stop(dev_priv, __cil_tmp15, __cil_tmp16, __cil_tmp17);
    __cil_tmp18 = ret != 0;
    __cil_tmp19 = ! __cil_tmp18;
    __ret_warn_on = ! __cil_tmp19;
    __cil_tmp20 = ! __ret_warn_on;
    __cil_tmp21 = ! __cil_tmp20;
    __cil_tmp22 = (long )__cil_tmp21;
    tmp___7 = ldv__builtin_expect(__cil_tmp22, 0L);
    if (tmp___7) {
      __cil_tmp23 = 444;
      warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                         __cil_tmp23);
    }
    __cil_tmp24 = ! __ret_warn_on;
    __cil_tmp25 = ! __cil_tmp24;
    __cil_tmp26 = (long )__cil_tmp25;
    ldv__builtin_expect(__cil_tmp26, 0L);
    i ++;
  }
  while_break: 
  __cil_tmp27 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp27);
  return (0);
}
}
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  struct vmw_overlay *overlay ;
  struct drm_vmw_control_stream_arg *arg ;
  struct vmw_dma_buffer *buf ;
  struct vmw_resource *res ;
  int ret ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  uint32_t *__cil_tmp17 ;
  struct mutex *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  bool __cil_tmp23 ;
  bool __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  struct vmw_dma_buffer **__cil_tmp28 ;
  struct vmw_dma_buffer *__cil_tmp29 ;
  bool __cil_tmp30 ;
  struct mutex *__cil_tmp31 ;

  {
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp13 = (unsigned long )tmp___7;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp14);
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp15 = (unsigned long )dev_priv;
  __cil_tmp16 = __cil_tmp15 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp16);
  arg = (struct drm_vmw_control_stream_arg *)data;
  if (! overlay) {
    return (-38);
  }
  __cil_tmp17 = (uint32_t *)arg;
  ret = vmw_user_stream_lookup(dev_priv, tfile, __cil_tmp17, & res);
  if (ret) {
    return (ret);
  }
  __cil_tmp18 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp18);
  __cil_tmp19 = (unsigned long )arg;
  __cil_tmp20 = __cil_tmp19 + 4UL;
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
  if (! __cil_tmp21) {
    __cil_tmp22 = *((uint32_t *)arg);
    __cil_tmp23 = (bool )0;
    __cil_tmp24 = (bool )1;
    ret = vmw_overlay_stop(dev_priv, __cil_tmp22, __cil_tmp23, __cil_tmp24);
    goto out_unlock;
  }
  __cil_tmp25 = (unsigned long )arg;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  __cil_tmp27 = *((uint32_t *)__cil_tmp26);
  ret = vmw_user_dmabuf_lookup(tfile, __cil_tmp27, & buf);
  if (ret) {
    goto out_unlock;
  }
  __cil_tmp28 = & buf;
  __cil_tmp29 = *__cil_tmp28;
  __cil_tmp30 = (bool )1;
  ret = vmw_overlay_update_stream(dev_priv, __cil_tmp29, arg, __cil_tmp30);
  vmw_dmabuf_unreference(& buf);
  out_unlock: 
  __cil_tmp31 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp31);
  vmw_resource_unreference(& res);
  return (ret);
}
}
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct vmw_overlay *__cil_tmp4 ;

  {
  __cil_tmp2 = (unsigned long )dev_priv;
  __cil_tmp3 = __cil_tmp2 + 2624UL;
  __cil_tmp4 = *((struct vmw_overlay **)__cil_tmp3);
  if (! __cil_tmp4) {
    return (0);
  }
  return (1);
}
}
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int k ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct mutex *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;

  {
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp6);
  if (! overlay) {
    return (0);
  }
  __cil_tmp7 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp7);
  i = 0;
  k = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp8 = (unsigned long )i * 104UL;
    __cil_tmp9 = __cil_tmp8 + 8UL;
    __cil_tmp10 = 72UL + __cil_tmp9;
    __cil_tmp11 = (unsigned long )overlay;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    __cil_tmp13 = *((bool *)__cil_tmp12);
    if (! __cil_tmp13) {
      k ++;
    }
    i ++;
  }
  while_break: 
  __cil_tmp14 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp14);
  return (k);
}
}
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) 
{ struct vmw_overlay *overlay ;
  int i ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct mutex *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct mutex *__cil_tmp18 ;
  struct mutex *__cil_tmp19 ;

  {
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp6);
  if (! overlay) {
    return (-38);
  }
  __cil_tmp7 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp7);
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp8 = (unsigned long )i * 104UL;
    __cil_tmp9 = __cil_tmp8 + 8UL;
    __cil_tmp10 = 72UL + __cil_tmp9;
    __cil_tmp11 = (unsigned long )overlay;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    if (*((bool *)__cil_tmp12)) {
      goto __Cont;
    }
    __cil_tmp13 = (unsigned long )i * 104UL;
    __cil_tmp14 = __cil_tmp13 + 8UL;
    __cil_tmp15 = 72UL + __cil_tmp14;
    __cil_tmp16 = (unsigned long )overlay;
    __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
    *((bool *)__cil_tmp17) = (bool )1;
    *out = (uint32_t )i;
    __cil_tmp18 = (struct mutex *)overlay;
    mutex_unlock(__cil_tmp18);
    return (0);
    __Cont: 
    i ++;
  }
  while_break: 
  __cil_tmp19 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp19);
  return (-3);
}
}
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) 
{ struct vmw_overlay *overlay ;
  long tmp___7 ;
  int __ret_warn_on ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  struct mutex *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  bool __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  bool __cil_tmp29 ;
  bool __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct mutex *__cil_tmp36 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp8);
  while (1) {
    __cil_tmp9 = stream_id >= 1U;
    __cil_tmp10 = ! __cil_tmp9;
    __cil_tmp11 = ! __cil_tmp10;
    __cil_tmp12 = (long )__cil_tmp11;
    tmp___7 = ldv__builtin_expect(__cil_tmp12, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c"),
                             "i" (549), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  if (! overlay) {
    return (-38);
  }
  __cil_tmp13 = (struct mutex *)overlay;
  mutex_lock(__cil_tmp13);
  __cil_tmp14 = (unsigned long )stream_id * 104UL;
  __cil_tmp15 = __cil_tmp14 + 8UL;
  __cil_tmp16 = 72UL + __cil_tmp15;
  __cil_tmp17 = (unsigned long )overlay;
  __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
  __cil_tmp19 = *((bool *)__cil_tmp18);
  __cil_tmp20 = ! __cil_tmp19;
  __cil_tmp21 = ! __cil_tmp20;
  __ret_warn_on = ! __cil_tmp21;
  __cil_tmp22 = ! __ret_warn_on;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___8) {
    __cil_tmp25 = 556;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                       __cil_tmp25);
  }
  __cil_tmp26 = ! __ret_warn_on;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  ldv__builtin_expect(__cil_tmp28, 0L);
  __cil_tmp29 = (bool )0;
  __cil_tmp30 = (bool )0;
  vmw_overlay_stop(dev_priv, stream_id, __cil_tmp29, __cil_tmp30);
  __cil_tmp31 = (unsigned long )stream_id * 104UL;
  __cil_tmp32 = __cil_tmp31 + 8UL;
  __cil_tmp33 = 72UL + __cil_tmp32;
  __cil_tmp34 = (unsigned long )overlay;
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
  *((bool *)__cil_tmp35) = (bool )0;
  __cil_tmp36 = (struct mutex *)overlay;
  mutex_unlock(__cil_tmp36);
  return (0);
}
}
static struct lock_class_key __key___16  ;
int vmw_overlay_init(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  void *tmp___7 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  struct mutex *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2624UL;
  if (*((struct vmw_overlay **)__cil_tmp6)) {
    return (-22);
  }
  __cil_tmp7 = 1 << 3;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = 1892;
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
  __cil_tmp12 = *((uint32_t *)__cil_tmp11);
  __cil_tmp13 = __cil_tmp12 & __cil_tmp8;
  if (! __cil_tmp13) {
    __cil_tmp14 = 1 << 5;
    __cil_tmp15 = (unsigned int )__cil_tmp14;
    __cil_tmp16 = 1892;
    __cil_tmp17 = (unsigned long )dev_priv;
    __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
    __cil_tmp19 = *((uint32_t *)__cil_tmp18);
    if (__cil_tmp19 & __cil_tmp15) {
      printk("<6>[drm] hardware doesn\'t support overlays\n");
      return (-38);
    }
  }
  tmp___7 = kzalloc(176UL, 208U);
  overlay = (struct vmw_overlay *)tmp___7;
  if (! overlay) {
    return (-12);
  }
  while (1) {
    __cil_tmp20 = (struct mutex *)overlay;
    __mutex_init(__cil_tmp20, "&overlay->mutex", & __key___16);
    goto while_break;
  }
  while_break: 
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break___0;
    }
    __cil_tmp21 = (unsigned long )i * 104UL;
    __cil_tmp22 = 72UL + __cil_tmp21;
    __cil_tmp23 = (unsigned long )overlay;
    __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
    __cil_tmp25 = (void *)0;
    *((struct vmw_dma_buffer **)__cil_tmp24) = (struct vmw_dma_buffer *)__cil_tmp25;
    __cil_tmp26 = (unsigned long )i * 104UL;
    __cil_tmp27 = __cil_tmp26 + 9UL;
    __cil_tmp28 = 72UL + __cil_tmp27;
    __cil_tmp29 = (unsigned long )overlay;
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
    *((bool *)__cil_tmp30) = (bool )0;
    __cil_tmp31 = (unsigned long )i * 104UL;
    __cil_tmp32 = __cil_tmp31 + 8UL;
    __cil_tmp33 = 72UL + __cil_tmp32;
    __cil_tmp34 = (unsigned long )overlay;
    __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
    *((bool *)__cil_tmp35) = (bool )0;
    i ++;
  }
  while_break___0: 
  __cil_tmp36 = (unsigned long )dev_priv;
  __cil_tmp37 = __cil_tmp36 + 2624UL;
  *((struct vmw_overlay **)__cil_tmp37) = overlay;
  return (0);
}
}
int vmw_overlay_close(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  bool forgotten_buffer ;
  int i ;
  int __ret_warn_on ;
  long tmp___7 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  bool __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
  __cil_tmp7 = (unsigned long )dev_priv;
  __cil_tmp8 = __cil_tmp7 + 2624UL;
  overlay = *((struct vmw_overlay **)__cil_tmp8);
  forgotten_buffer = (bool )0;
  if (! overlay) {
    return (-38);
  }
  i = 0;
  while (1) {

    if (! (i < 1)) {
      goto while_break;
    }
    __cil_tmp9 = (unsigned long )i * 104UL;
    __cil_tmp10 = 72UL + __cil_tmp9;
    __cil_tmp11 = (unsigned long )overlay;
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
    if (*((struct vmw_dma_buffer **)__cil_tmp12)) {
      forgotten_buffer = (bool )1;
      __cil_tmp13 = (uint32_t )i;
      __cil_tmp14 = (bool )0;
      __cil_tmp15 = (bool )0;
      vmw_overlay_stop(dev_priv, __cil_tmp13, __cil_tmp14, __cil_tmp15);
    }
    i ++;
  }
  while_break: 
  __cil_tmp16 = ! forgotten_buffer;
  __ret_warn_on = ! __cil_tmp16;
  __cil_tmp17 = ! __ret_warn_on;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = (long )__cil_tmp18;
  tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
  if (tmp___7) {
    __cil_tmp20 = 610;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c",
                       __cil_tmp20);
  }
  __cil_tmp21 = ! __ret_warn_on;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = (long )__cil_tmp22;
  ldv__builtin_expect(__cil_tmp23, 0L);
  __cil_tmp24 = (unsigned long )dev_priv;
  __cil_tmp25 = __cil_tmp24 + 2624UL;
  __cil_tmp26 = (void *)0;
  *((struct vmw_overlay **)__cil_tmp25) = (struct vmw_overlay *)__cil_tmp26;
  __cil_tmp27 = (void *)overlay;
  kfree(__cil_tmp27);
  return (0);
}
}
 static int timespec_compare(struct timespec *lhs , struct timespec *rhs )  __attribute__((__no_instrument_function__)) ;
 static int timespec_compare(struct timespec *lhs , struct timespec *rhs )  __attribute__((__no_instrument_function__)) ;
 static int timespec_compare(struct timespec *lhs , struct timespec *rhs ) 
{ __kernel_time_t __cil_tmp3 ;
  __kernel_time_t __cil_tmp4 ;
  __kernel_time_t __cil_tmp5 ;
  __kernel_time_t __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  long __cil_tmp12 ;
  long __cil_tmp13 ;

  {
  __cil_tmp3 = *((__kernel_time_t *)rhs);
  __cil_tmp4 = *((__kernel_time_t *)lhs);
  if (__cil_tmp4 < __cil_tmp3) {
    return (-1);
  }
  __cil_tmp5 = *((__kernel_time_t *)rhs);
  __cil_tmp6 = *((__kernel_time_t *)lhs);
  if (__cil_tmp6 > __cil_tmp5) {
    return (1);
  }
  __cil_tmp7 = (unsigned long )rhs;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  __cil_tmp9 = *((long *)__cil_tmp8);
  __cil_tmp10 = (unsigned long )lhs;
  __cil_tmp11 = __cil_tmp10 + 8UL;
  __cil_tmp12 = *((long *)__cil_tmp11);
  __cil_tmp13 = __cil_tmp12 - __cil_tmp9;
  return ((int )__cil_tmp13);
}
}
extern void set_normalized_timespec(struct timespec *ts , time_t sec , s64 nsec ) ;
 static struct timespec timespec_sub(__kernel_time_t lhs_tv_sec11 , long lhs_tv_nsec10 ,
                                             __kernel_time_t rhs_tv_sec9 , long rhs_tv_nsec8 )  __attribute__((__no_instrument_function__)) ;
 static struct timespec timespec_sub(__kernel_time_t lhs_tv_sec11 , long lhs_tv_nsec10 ,
                                             __kernel_time_t rhs_tv_sec9 , long rhs_tv_nsec8 )  __attribute__((__no_instrument_function__)) ;
 static struct timespec timespec_sub(__kernel_time_t lhs_tv_sec11 , long lhs_tv_nsec10 ,
                                             __kernel_time_t rhs_tv_sec9 , long rhs_tv_nsec8 ) 
{ struct timespec ts_delta ;
  __kernel_time_t __cil_tmp4 ;
  long __cil_tmp5 ;
  s64 __cil_tmp6 ;
  struct timespec *__cil_tmp7 ;

  {
  __cil_tmp4 = lhs_tv_sec11 - rhs_tv_sec9;
  __cil_tmp5 = lhs_tv_nsec10 - rhs_tv_nsec8;
  __cil_tmp6 = (s64 )__cil_tmp5;
  set_normalized_timespec(& ts_delta, __cil_tmp4, __cil_tmp6);
  __cil_tmp7 = & ts_delta;
  return (*__cil_tmp7);
}
}
extern void getrawmonotonic(struct timespec *ts ) ;
extern struct timespec ns_to_timespec(s64 nsec ) ;
static struct lock_class_key __key___17  ;
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) 
{ struct list_head *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  s64 __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct timespec *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  spinlock_t *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct raw_spinlock *__cil_tmp14 ;

  {
  __cil_tmp2 = (struct list_head *)queue;
  INIT_LIST_HEAD(__cil_tmp2);
  __cil_tmp3 = (unsigned long )queue;
  __cil_tmp4 = __cil_tmp3 + 16UL;
  __cil_tmp5 = (s64 )0;
  *((struct timespec *)__cil_tmp4) = ns_to_timespec(__cil_tmp5);
  __cil_tmp6 = (unsigned long )queue;
  __cil_tmp7 = __cil_tmp6 + 32UL;
  __cil_tmp8 = (struct timespec *)__cil_tmp7;
  getrawmonotonic(__cil_tmp8);
  while (1) {
    __cil_tmp9 = (unsigned long )queue;
    __cil_tmp10 = __cil_tmp9 + 48UL;
    __cil_tmp11 = (spinlock_t *)__cil_tmp10;
    spinlock_check(__cil_tmp11);
    while (1) {
      __cil_tmp12 = (unsigned long )queue;
      __cil_tmp13 = __cil_tmp12 + 48UL;
      __cil_tmp14 = (struct raw_spinlock *)__cil_tmp13;
      __raw_spin_lock_init(__cil_tmp14, "&(&queue->lock)->rlock", & __key___17);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: ;
  return;
}
}
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  spinlock_t *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  struct vmw_marker *__cil_tmp11 ;
  struct list_head *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  struct vmw_marker *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  void *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct vmw_marker *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  spinlock_t *__cil_tmp35 ;

  {
  __cil_tmp7 = (unsigned long )queue;
  __cil_tmp8 = __cil_tmp7 + 48UL;
  __cil_tmp9 = (spinlock_t *)__cil_tmp8;
  spin_lock(__cil_tmp9);
  __cil_tmp10 = *((struct list_head **)queue);
  __mptr = __cil_tmp10;
  __cil_tmp11 = (struct vmw_marker *)0;
  __cil_tmp12 = (struct list_head *)__cil_tmp11;
  __cil_tmp13 = (unsigned int )__cil_tmp12;
  __cil_tmp14 = (char *)__mptr;
  __cil_tmp15 = __cil_tmp14 - __cil_tmp13;
  marker = (struct vmw_marker *)__cil_tmp15;
  __cil_tmp16 = *((struct list_head **)marker);
  __mptr___0 = __cil_tmp16;
  __cil_tmp17 = (struct vmw_marker *)0;
  __cil_tmp18 = (struct list_head *)__cil_tmp17;
  __cil_tmp19 = (unsigned int )__cil_tmp18;
  __cil_tmp20 = (char *)__mptr___0;
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
  next = (struct vmw_marker *)__cil_tmp21;
  while (1) {
    __cil_tmp22 = (struct list_head *)queue;
    __cil_tmp23 = (unsigned long )__cil_tmp22;
    __cil_tmp24 = (struct list_head *)marker;
    __cil_tmp25 = (unsigned long )__cil_tmp24;
    if (! (__cil_tmp25 != __cil_tmp23)) {
      goto while_break;
    }
    __cil_tmp26 = (void *)marker;
    kfree(__cil_tmp26);
    marker = next;
    __cil_tmp27 = *((struct list_head **)next);
    __mptr___1 = __cil_tmp27;
    __cil_tmp28 = (struct vmw_marker *)0;
    __cil_tmp29 = (struct list_head *)__cil_tmp28;
    __cil_tmp30 = (unsigned int )__cil_tmp29;
    __cil_tmp31 = (char *)__mptr___1;
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
    next = (struct vmw_marker *)__cil_tmp32;
  }
  while_break: 
  __cil_tmp33 = (unsigned long )queue;
  __cil_tmp34 = __cil_tmp33 + 48UL;
  __cil_tmp35 = (spinlock_t *)__cil_tmp34;
  spin_unlock(__cil_tmp35);
  return;
}
}
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) 
{ struct vmw_marker *marker ;
  void *tmp___7 ;
  long tmp___8 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct timespec *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;

  {
  tmp___7 = kmalloc(40UL, 208U);
  marker = (struct vmw_marker *)tmp___7;
  __cil_tmp6 = ! marker;
  __cil_tmp7 = ! __cil_tmp6;
  __cil_tmp8 = ! __cil_tmp7;
  __cil_tmp9 = (long )__cil_tmp8;
  tmp___8 = ldv__builtin_expect(__cil_tmp9, 0L);
  if (tmp___8) {
    return (-12);
  }
  __cil_tmp10 = (unsigned long )marker;
  __cil_tmp11 = __cil_tmp10 + 16UL;
  *((uint32_t *)__cil_tmp11) = seqno;
  __cil_tmp12 = (unsigned long )marker;
  __cil_tmp13 = __cil_tmp12 + 24UL;
  __cil_tmp14 = (struct timespec *)__cil_tmp13;
  getrawmonotonic(__cil_tmp14);
  __cil_tmp15 = (unsigned long )queue;
  __cil_tmp16 = __cil_tmp15 + 48UL;
  __cil_tmp17 = (spinlock_t *)__cil_tmp16;
  spin_lock(__cil_tmp17);
  __cil_tmp18 = (struct list_head *)marker;
  __cil_tmp19 = (struct list_head *)queue;
  list_add_tail(__cil_tmp18, __cil_tmp19);
  __cil_tmp20 = (unsigned long )queue;
  __cil_tmp21 = __cil_tmp20 + 48UL;
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
  spin_unlock(__cil_tmp22);
  return (0);
}
}
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct timespec now ;
  bool updated ;
  int tmp___7 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  int tmp___8 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  spinlock_t *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  s64 __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct timespec *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct vmw_marker *__cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  struct vmw_marker *__cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct timespec *__cil_tmp47 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct timespec *__cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  void *__cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  struct vmw_marker *__cil_tmp58 ;
  struct list_head *__cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  spinlock_t *__cil_tmp65 ;
  long __cil_tmp48_tv_nsec66 ;
  __kernel_time_t __cil_tmp48_tv_sec67 ;
  long __cil_tmp51_tv_nsec68 ;
  __kernel_time_t __cil_tmp51_tv_sec69 ;
  __kernel_time_t __cil_tmp70 ;
  long __cil_tmp71 ;
  __kernel_time_t __cil_tmp72 ;
  long __cil_tmp73 ;

  {
  updated = (bool )0;
  __cil_tmp12 = (unsigned long )queue;
  __cil_tmp13 = __cil_tmp12 + 48UL;
  __cil_tmp14 = (spinlock_t *)__cil_tmp13;
  spin_lock(__cil_tmp14);
  getrawmonotonic(& now);
  __cil_tmp15 = (struct list_head *)queue;
  __cil_tmp16 = __cil_tmp15;
  tmp___7 = list_empty(__cil_tmp16);
  if (tmp___7) {
    __cil_tmp17 = (unsigned long )queue;
    __cil_tmp18 = __cil_tmp17 + 16UL;
    __cil_tmp19 = (s64 )0;
    *((struct timespec *)__cil_tmp18) = ns_to_timespec(__cil_tmp19);
    __cil_tmp20 = (unsigned long )queue;
    __cil_tmp21 = __cil_tmp20 + 32UL;
    __cil_tmp22 = & now;
    *((struct timespec *)__cil_tmp21) = *__cil_tmp22;
    updated = (bool )1;
    goto out_unlock;
  }
  __cil_tmp23 = *((struct list_head **)queue);
  __mptr = __cil_tmp23;
  __cil_tmp24 = (struct vmw_marker *)0;
  __cil_tmp25 = (struct list_head *)__cil_tmp24;
  __cil_tmp26 = (unsigned int )__cil_tmp25;
  __cil_tmp27 = (char *)__mptr;
  __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
  marker = (struct vmw_marker *)__cil_tmp28;
  __cil_tmp29 = *((struct list_head **)marker);
  __mptr___0 = __cil_tmp29;
  __cil_tmp30 = (struct vmw_marker *)0;
  __cil_tmp31 = (struct list_head *)__cil_tmp30;
  __cil_tmp32 = (unsigned int )__cil_tmp31;
  __cil_tmp33 = (char *)__mptr___0;
  __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
  next = (struct vmw_marker *)__cil_tmp34;
  while (1) {
    __cil_tmp35 = (struct list_head *)queue;
    __cil_tmp36 = (unsigned long )__cil_tmp35;
    __cil_tmp37 = (struct list_head *)marker;
    __cil_tmp38 = (unsigned long )__cil_tmp37;
    if (! (__cil_tmp38 != __cil_tmp36)) {
      goto while_break;
    }
    __cil_tmp39 = 1 << 30;
    __cil_tmp40 = (uint32_t )__cil_tmp39;
    __cil_tmp41 = (unsigned long )marker;
    __cil_tmp42 = __cil_tmp41 + 16UL;
    __cil_tmp43 = *((uint32_t *)__cil_tmp42);
    __cil_tmp44 = signaled_seqno - __cil_tmp43;
    if (__cil_tmp44 > __cil_tmp40) {
      goto __Cont;
    }
    __cil_tmp45 = (unsigned long )queue;
    __cil_tmp46 = __cil_tmp45 + 16UL;
    __cil_tmp47 = & now;
    __cil_tmp70 = __cil_tmp47->tv_sec;
    __cil_tmp71 = __cil_tmp47->tv_nsec;
    __cil_tmp48_tv_sec67 = __cil_tmp70;
    __cil_tmp48_tv_nsec66 = __cil_tmp71;
    __cil_tmp49 = (unsigned long )marker;
    __cil_tmp50 = __cil_tmp49 + 24UL;
    __cil_tmp72 = ((struct timespec *)__cil_tmp50)->tv_sec;
    __cil_tmp73 = ((struct timespec *)__cil_tmp50)->tv_nsec;
    __cil_tmp51_tv_sec69 = __cil_tmp72;
    __cil_tmp51_tv_nsec68 = __cil_tmp73;
    *((struct timespec *)__cil_tmp46) = timespec_sub(__cil_tmp48_tv_sec67, __cil_tmp48_tv_nsec66,
                                                     __cil_tmp51_tv_sec69, __cil_tmp51_tv_nsec68);
    __cil_tmp52 = (unsigned long )queue;
    __cil_tmp53 = __cil_tmp52 + 32UL;
    __cil_tmp54 = & now;
    *((struct timespec *)__cil_tmp53) = *__cil_tmp54;
    updated = (bool )1;
    __cil_tmp55 = (struct list_head *)marker;
    list_del(__cil_tmp55);
    __cil_tmp56 = (void *)marker;
    kfree(__cil_tmp56);
    __Cont: 
    marker = next;
    __cil_tmp57 = *((struct list_head **)next);
    __mptr___1 = __cil_tmp57;
    __cil_tmp58 = (struct vmw_marker *)0;
    __cil_tmp59 = (struct list_head *)__cil_tmp58;
    __cil_tmp60 = (unsigned int )__cil_tmp59;
    __cil_tmp61 = (char *)__mptr___1;
    __cil_tmp62 = __cil_tmp61 - __cil_tmp60;
    next = (struct vmw_marker *)__cil_tmp62;
  }
  while_break: ;
  out_unlock: 
  __cil_tmp63 = (unsigned long )queue;
  __cil_tmp64 = __cil_tmp63 + 48UL;
  __cil_tmp65 = (spinlock_t *)__cil_tmp64;
  spin_unlock(__cil_tmp65);
  if (updated) {
    tmp___8 = 0;
  } else {
    tmp___8 = -16;
  }
  return (tmp___8);
}
}
static struct timespec vmw_timespec_add(__kernel_time_t t1_tv_sec6 , long t1_tv_nsec5 ,
                                        __kernel_time_t t2_tv_sec4 , long t2_tv_nsec3 ) 
{ struct timespec t1 ;

  {
  t1_tv_sec6 += t2_tv_sec4;
  t1_tv_nsec5 += t2_tv_nsec3;
  if (t1_tv_nsec5 >= 1000000000L) {
    t1_tv_sec6 ++;
    t1_tv_nsec5 -= 1000000000L;
  }
  return (t1);
}
}
static struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue ) 
{ struct timespec now ;
  struct timespec tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  spinlock_t *__cil_tmp6 ;
  struct timespec *__cil_tmp7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct timespec *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  spinlock_t *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  long __cil_tmp8_tv_nsec25 ;
  __kernel_time_t __cil_tmp8_tv_sec26 ;
  long __cil_tmp11_tv_nsec27 ;
  __kernel_time_t __cil_tmp11_tv_sec28 ;
  long __cil_tmp16_tv_nsec29 ;
  __kernel_time_t __cil_tmp16_tv_sec30 ;
  __kernel_time_t __cil_tmp31 ;
  long __cil_tmp32 ;
  __kernel_time_t __cil_tmp33 ;
  long __cil_tmp34 ;
  __kernel_time_t __cil_tmp35 ;
  long __cil_tmp36 ;

  {
  __cil_tmp4 = (unsigned long )queue;
  __cil_tmp5 = __cil_tmp4 + 48UL;
  __cil_tmp6 = (spinlock_t *)__cil_tmp5;
  spin_lock(__cil_tmp6);
  getrawmonotonic(& now);
  __cil_tmp7 = & now;
  __cil_tmp31 = __cil_tmp7->tv_sec;
  __cil_tmp32 = __cil_tmp7->tv_nsec;
  __cil_tmp8_tv_sec26 = __cil_tmp31;
  __cil_tmp8_tv_nsec25 = __cil_tmp32;
  __cil_tmp9 = (unsigned long )queue;
  __cil_tmp10 = __cil_tmp9 + 32UL;
  __cil_tmp33 = ((struct timespec *)__cil_tmp10)->tv_sec;
  __cil_tmp34 = ((struct timespec *)__cil_tmp10)->tv_nsec;
  __cil_tmp11_tv_sec28 = __cil_tmp33;
  __cil_tmp11_tv_nsec27 = __cil_tmp34;
  tmp___7 = timespec_sub(__cil_tmp8_tv_sec26, __cil_tmp8_tv_nsec25, __cil_tmp11_tv_sec28,
                         __cil_tmp11_tv_nsec27);
  __cil_tmp12 = (unsigned long )queue;
  __cil_tmp13 = __cil_tmp12 + 16UL;
  __cil_tmp14 = (unsigned long )queue;
  __cil_tmp15 = __cil_tmp14 + 16UL;
  __cil_tmp35 = ((struct timespec *)__cil_tmp15)->tv_sec;
  __cil_tmp36 = ((struct timespec *)__cil_tmp15)->tv_nsec;
  __cil_tmp16_tv_sec30 = __cil_tmp35;
  __cil_tmp16_tv_nsec29 = __cil_tmp36;
  *((struct timespec *)__cil_tmp13) = vmw_timespec_add(__cil_tmp16_tv_sec30, __cil_tmp16_tv_nsec29,
                                                       tmp___7.tv_sec, tmp___7.tv_nsec);
  __cil_tmp17 = (unsigned long )queue;
  __cil_tmp18 = __cil_tmp17 + 32UL;
  __cil_tmp19 = & now;
  *((struct timespec *)__cil_tmp18) = *__cil_tmp19;
  __cil_tmp20 = (unsigned long )queue;
  __cil_tmp21 = __cil_tmp20 + 48UL;
  __cil_tmp22 = (spinlock_t *)__cil_tmp21;
  spin_unlock(__cil_tmp22);
  __cil_tmp23 = (unsigned long )queue;
  __cil_tmp24 = __cil_tmp23 + 16UL;
  return (*((struct timespec *)__cil_tmp24));
}
}
static bool vmw_lag_lt(struct vmw_marker_queue *queue , uint32_t us ) 
{ struct timespec lag ;
  struct timespec cond ;
  int tmp___7 ;
  struct timespec *__cil_tmp6 ;
  s64 __cil_tmp7 ;
  s64 __cil_tmp8 ;
  s64 __cil_tmp9 ;
  struct timespec *__cil_tmp10 ;
  struct timespec *__cil_tmp11 ;
  struct timespec *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  __cil_tmp6 = & cond;
  __cil_tmp7 = (s64 )us;
  __cil_tmp8 = __cil_tmp7 * 1000LL;
  __cil_tmp9 = __cil_tmp8;
  *__cil_tmp6 = ns_to_timespec(__cil_tmp9);
  __cil_tmp10 = & lag;
  *__cil_tmp10 = vmw_fifo_lag(queue);
  __cil_tmp11 = & lag;
  __cil_tmp12 = & cond;
  tmp___7 = timespec_compare(__cil_tmp11, __cil_tmp12);
  __cil_tmp13 = tmp___7 < 1;
  return ((bool )__cil_tmp13);
}
}
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) 
{ struct vmw_marker *marker ;
  uint32_t seqno ;
  int ret ;
  int tmp___7 ;
  struct list_head *__mptr ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  spinlock_t *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  atomic_t *__cil_tmp19 ;
  atomic_t *__cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct vmw_marker *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  spinlock_t *__cil_tmp31 ;
  bool __cil_tmp32 ;
  bool __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;

  {
  while (1) {
    tmp___10 = vmw_lag_lt(queue, us);
    if (tmp___10) {
      goto while_break;
    }
    __cil_tmp12 = (unsigned long )queue;
    __cil_tmp13 = __cil_tmp12 + 48UL;
    __cil_tmp14 = (spinlock_t *)__cil_tmp13;
    spin_lock(__cil_tmp14);
    __cil_tmp15 = (struct list_head *)queue;
    __cil_tmp16 = __cil_tmp15;
    tmp___8 = list_empty(__cil_tmp16);
    if (tmp___8) {
      __cil_tmp17 = (unsigned long )dev_priv;
      __cil_tmp18 = __cil_tmp17 + 2880UL;
      __cil_tmp19 = (atomic_t *)__cil_tmp18;
      __cil_tmp20 = __cil_tmp19;
      tmp___7 = atomic_read(__cil_tmp20);
      seqno = (uint32_t )tmp___7;
    } else {
      __cil_tmp21 = *((struct list_head **)queue);
      __mptr = __cil_tmp21;
      __cil_tmp22 = (struct vmw_marker *)0;
      __cil_tmp23 = (struct list_head *)__cil_tmp22;
      __cil_tmp24 = (unsigned int )__cil_tmp23;
      __cil_tmp25 = (char *)__mptr;
      __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
      marker = (struct vmw_marker *)__cil_tmp26;
      __cil_tmp27 = (unsigned long )marker;
      __cil_tmp28 = __cil_tmp27 + 16UL;
      seqno = *((uint32_t *)__cil_tmp28);
    }
    __cil_tmp29 = (unsigned long )queue;
    __cil_tmp30 = __cil_tmp29 + 48UL;
    __cil_tmp31 = (spinlock_t *)__cil_tmp30;
    spin_unlock(__cil_tmp31);
    __cil_tmp32 = (bool )0;
    __cil_tmp33 = (bool )1;
    ret = vmw_wait_seqno(dev_priv, __cil_tmp32, seqno, __cil_tmp33, 750UL);
    __cil_tmp34 = ret != 0;
    __cil_tmp35 = ! __cil_tmp34;
    __cil_tmp36 = ! __cil_tmp35;
    __cil_tmp37 = (long )__cil_tmp36;
    tmp___9 = ldv__builtin_expect(__cil_tmp37, 0L);
    if (tmp___9) {
      return (ret);
    }
    vmw_marker_pull(queue, seqno);
  }
  while_break: ;
  return (0);
}
}
extern int ida_pre_get(struct ida *ida , gfp_t gfp_mask ) ;
extern int ida_get_new(struct ida *ida , int *p_id ) ;
extern void ida_remove(struct ida *ida , int id ) ;
extern void ida_destroy(struct ida *ida ) ;
extern void ida_init(struct ida *ida ) ;
static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                                  struct ttm_placement *placement , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;
  int ret ;
  int id ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  spinlock_t *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  spinlock_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct ida *__cil_tmp45 ;
  long __cil_tmp46 ;
  spinlock_t *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ida *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  uint32_t __cil_tmp53 ;
  int *__cil_tmp54 ;
  int __cil_tmp55 ;
  uint32_t __cil_tmp56 ;
  long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct ida *__cil_tmp60 ;
  int *__cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  int *__cil_tmp69 ;
  int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  spinlock_t *__cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  spinlock_t *__cil_tmp87 ;

  {
  __cil_tmp15 = (unsigned long )man;
  __cil_tmp16 = __cil_tmp15 + 48UL;
  __cil_tmp17 = *((void **)__cil_tmp16);
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp17;
  ret = 0;
  *((void **)mem) = (void *)0;
  __cil_tmp18 = (spinlock_t *)gman;
  spin_lock(__cil_tmp18);
  __cil_tmp19 = (unsigned long )gman;
  __cil_tmp20 = __cil_tmp19 + 84UL;
  __cil_tmp21 = *((uint32_t *)__cil_tmp20);
  if (__cil_tmp21 > 0U) {
    __cil_tmp22 = (unsigned long )gman;
    __cil_tmp23 = __cil_tmp22 + 88UL;
    __cil_tmp24 = (unsigned long )bo;
    __cil_tmp25 = __cil_tmp24 + 40UL;
    __cil_tmp26 = *((unsigned long *)__cil_tmp25);
    __cil_tmp27 = (unsigned long )gman;
    __cil_tmp28 = __cil_tmp27 + 88UL;
    __cil_tmp29 = *((uint32_t *)__cil_tmp28);
    __cil_tmp30 = (unsigned long )__cil_tmp29;
    __cil_tmp31 = __cil_tmp30 + __cil_tmp26;
    *((uint32_t *)__cil_tmp23) = (uint32_t )__cil_tmp31;
    __cil_tmp32 = (unsigned long )gman;
    __cil_tmp33 = __cil_tmp32 + 84UL;
    __cil_tmp34 = *((uint32_t *)__cil_tmp33);
    __cil_tmp35 = (unsigned long )gman;
    __cil_tmp36 = __cil_tmp35 + 88UL;
    __cil_tmp37 = *((uint32_t *)__cil_tmp36);
    __cil_tmp38 = __cil_tmp37 > __cil_tmp34;
    __cil_tmp39 = ! __cil_tmp38;
    __cil_tmp40 = ! __cil_tmp39;
    __cil_tmp41 = (long )__cil_tmp40;
    tmp___7 = ldv__builtin_expect(__cil_tmp41, 0L);
    if (tmp___7) {
      goto out_err_locked;
    }
  }
  while (1) {
    __cil_tmp42 = (spinlock_t *)gman;
    spin_unlock(__cil_tmp42);
    __cil_tmp43 = (unsigned long )gman;
    __cil_tmp44 = __cil_tmp43 + 24UL;
    __cil_tmp45 = (struct ida *)__cil_tmp44;
    tmp___8 = ida_pre_get(__cil_tmp45, 208U);
    if (tmp___8 == 0) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    __cil_tmp46 = (long )tmp___9;
    tmp___10 = ldv__builtin_expect(__cil_tmp46, 0L);
    if (tmp___10) {
      ret = -12;
      goto out_err;
    }
    __cil_tmp47 = (spinlock_t *)gman;
    spin_lock(__cil_tmp47);
    __cil_tmp48 = (unsigned long )gman;
    __cil_tmp49 = __cil_tmp48 + 24UL;
    __cil_tmp50 = (struct ida *)__cil_tmp49;
    ret = ida_get_new(__cil_tmp50, & id);
    if (ret == 0) {
      __cil_tmp51 = (unsigned long )gman;
      __cil_tmp52 = __cil_tmp51 + 80UL;
      __cil_tmp53 = *((uint32_t *)__cil_tmp52);
      __cil_tmp54 = & id;
      __cil_tmp55 = *__cil_tmp54;
      __cil_tmp56 = (uint32_t )__cil_tmp55;
      if (__cil_tmp56 >= __cil_tmp53) {
        tmp___11 = 1;
      } else {
        tmp___11 = 0;
      }
    } else {
      tmp___11 = 0;
    }
    __cil_tmp57 = (long )tmp___11;
    tmp___12 = ldv__builtin_expect(__cil_tmp57, 0L);
    if (tmp___12) {
      __cil_tmp58 = (unsigned long )gman;
      __cil_tmp59 = __cil_tmp58 + 24UL;
      __cil_tmp60 = (struct ida *)__cil_tmp59;
      __cil_tmp61 = & id;
      __cil_tmp62 = *__cil_tmp61;
      ida_remove(__cil_tmp60, __cil_tmp62);
      ret = 0;
      goto out_err_locked;
    }
    if (! (ret == -11)) {
      goto while_break;
    }
  }
  while_break: 
  __cil_tmp63 = ret == 0;
  __cil_tmp64 = ! __cil_tmp63;
  __cil_tmp65 = ! __cil_tmp64;
  __cil_tmp66 = (long )__cil_tmp65;
  tmp___13 = ldv__builtin_expect(__cil_tmp66, 1L);
  if (tmp___13) {
    *((void **)mem) = (void *)gman;
    __cil_tmp67 = (unsigned long )mem;
    __cil_tmp68 = __cil_tmp67 + 8UL;
    __cil_tmp69 = & id;
    __cil_tmp70 = *__cil_tmp69;
    *((unsigned long *)__cil_tmp68) = (unsigned long )__cil_tmp70;
    __cil_tmp71 = (unsigned long )mem;
    __cil_tmp72 = __cil_tmp71 + 24UL;
    __cil_tmp73 = (unsigned long )bo;
    __cil_tmp74 = __cil_tmp73 + 40UL;
    *((unsigned long *)__cil_tmp72) = *((unsigned long *)__cil_tmp74);
  } else {
    goto out_err_locked;
  }
  __cil_tmp75 = (spinlock_t *)gman;
  spin_unlock(__cil_tmp75);
  return (0);
  out_err: 
  __cil_tmp76 = (spinlock_t *)gman;
  spin_lock(__cil_tmp76);
  out_err_locked: 
  __cil_tmp77 = (unsigned long )gman;
  __cil_tmp78 = __cil_tmp77 + 88UL;
  __cil_tmp79 = (unsigned long )bo;
  __cil_tmp80 = __cil_tmp79 + 40UL;
  __cil_tmp81 = *((unsigned long *)__cil_tmp80);
  __cil_tmp82 = (unsigned long )gman;
  __cil_tmp83 = __cil_tmp82 + 88UL;
  __cil_tmp84 = *((uint32_t *)__cil_tmp83);
  __cil_tmp85 = (unsigned long )__cil_tmp84;
  __cil_tmp86 = __cil_tmp85 - __cil_tmp81;
  *((uint32_t *)__cil_tmp78) = (uint32_t )__cil_tmp86;
  __cil_tmp87 = (spinlock_t *)gman;
  spin_unlock(__cil_tmp87);
  return (ret);
}
}
static void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  spinlock_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct ida *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  spinlock_t *__cil_tmp25 ;

  {
  __cil_tmp4 = (unsigned long )man;
  __cil_tmp5 = __cil_tmp4 + 48UL;
  __cil_tmp6 = *((void **)__cil_tmp5);
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp6;
  if (*((void **)mem)) {
    __cil_tmp7 = (spinlock_t *)gman;
    spin_lock(__cil_tmp7);
    __cil_tmp8 = (unsigned long )gman;
    __cil_tmp9 = __cil_tmp8 + 24UL;
    __cil_tmp10 = (struct ida *)__cil_tmp9;
    __cil_tmp11 = (unsigned long )mem;
    __cil_tmp12 = __cil_tmp11 + 8UL;
    __cil_tmp13 = *((unsigned long *)__cil_tmp12);
    __cil_tmp14 = (int )__cil_tmp13;
    ida_remove(__cil_tmp10, __cil_tmp14);
    __cil_tmp15 = (unsigned long )gman;
    __cil_tmp16 = __cil_tmp15 + 88UL;
    __cil_tmp17 = (unsigned long )mem;
    __cil_tmp18 = __cil_tmp17 + 24UL;
    __cil_tmp19 = *((unsigned long *)__cil_tmp18);
    __cil_tmp20 = (unsigned long )gman;
    __cil_tmp21 = __cil_tmp20 + 88UL;
    __cil_tmp22 = *((uint32_t *)__cil_tmp21);
    __cil_tmp23 = (unsigned long )__cil_tmp22;
    __cil_tmp24 = __cil_tmp23 - __cil_tmp19;
    *((uint32_t *)__cil_tmp16) = (uint32_t )__cil_tmp24;
    __cil_tmp25 = (spinlock_t *)gman;
    spin_unlock(__cil_tmp25);
    *((void **)mem) = (void *)0;
  }
  return;
}
}
static struct lock_class_key __key___18  ;
static int vmw_gmrid_man_init(struct ttm_mem_type_manager *man , unsigned long p_size ) 
{ struct vmw_private *dev_priv ;
  struct ttm_bo_device *__mptr ;
  struct vmwgfx_gmrid_man *gman ;
  void *tmp___7 ;
  long tmp___8 ;
  struct ttm_bo_device *__cil_tmp8 ;
  struct vmw_private *__cil_tmp9 ;
  struct ttm_bo_device *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  struct raw_spinlock *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct ida *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;

  {
  __cil_tmp8 = *((struct ttm_bo_device **)man);
  __mptr = __cil_tmp8;
  __cil_tmp9 = (struct vmw_private *)0;
  __cil_tmp10 = (struct ttm_bo_device *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  dev_priv = (struct vmw_private *)__cil_tmp13;
  tmp___7 = kzalloc(96UL, 208U);
  gman = (struct vmwgfx_gmrid_man *)tmp___7;
  __cil_tmp14 = (void *)0;
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = (unsigned long )gman;
  __cil_tmp17 = __cil_tmp16 == __cil_tmp15;
  __cil_tmp18 = ! __cil_tmp17;
  __cil_tmp19 = ! __cil_tmp18;
  __cil_tmp20 = (long )__cil_tmp19;
  tmp___8 = ldv__builtin_expect(__cil_tmp20, 0L);
  if (tmp___8) {
    return (-12);
  }
  while (1) {
    __cil_tmp21 = (spinlock_t *)gman;
    spinlock_check(__cil_tmp21);
    while (1) {
      __cil_tmp22 = (struct raw_spinlock *)gman;
      __raw_spin_lock_init(__cil_tmp22, "&(&gman->lock)->rlock", & __key___18);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp23 = (unsigned long )gman;
  __cil_tmp24 = __cil_tmp23 + 84UL;
  __cil_tmp25 = (unsigned long )dev_priv;
  __cil_tmp26 = __cil_tmp25 + 2168UL;
  *((uint32_t *)__cil_tmp24) = *((uint32_t *)__cil_tmp26);
  __cil_tmp27 = (unsigned long )gman;
  __cil_tmp28 = __cil_tmp27 + 88UL;
  *((uint32_t *)__cil_tmp28) = (uint32_t )0;
  __cil_tmp29 = (unsigned long )gman;
  __cil_tmp30 = __cil_tmp29 + 24UL;
  __cil_tmp31 = (struct ida *)__cil_tmp30;
  ida_init(__cil_tmp31);
  __cil_tmp32 = (unsigned long )gman;
  __cil_tmp33 = __cil_tmp32 + 80UL;
  *((uint32_t *)__cil_tmp33) = (uint32_t )p_size;
  __cil_tmp34 = (unsigned long )man;
  __cil_tmp35 = __cil_tmp34 + 48UL;
  *((void **)__cil_tmp35) = (void *)gman;
  return (0);
}
}
static int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man ) 
{ struct vmwgfx_gmrid_man *gman ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct ida *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  __cil_tmp3 = (unsigned long )man;
  __cil_tmp4 = __cil_tmp3 + 48UL;
  __cil_tmp5 = *((void **)__cil_tmp4);
  gman = (struct vmwgfx_gmrid_man *)__cil_tmp5;
  if (gman) {
    __cil_tmp6 = (unsigned long )gman;
    __cil_tmp7 = __cil_tmp6 + 24UL;
    __cil_tmp8 = (struct ida *)__cil_tmp7;
    ida_destroy(__cil_tmp8);
    __cil_tmp9 = (void *)gman;
    kfree(__cil_tmp9);
  }
  return (0);
}
}
static void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man , char *prefix ) 
{ 

  {
  printk("<6>%s: No debug info available for the GMR id manager.\n", prefix);
  return;
}
}
struct ttm_mem_type_manager_func vmw_gmrid_manager_func  =    {& vmw_gmrid_man_init, & vmw_gmrid_man_takedown, & vmw_gmrid_man_get_node, & vmw_gmrid_man_put_node,
    & vmw_gmrid_man_debug};
 static void __list_splice(struct list_head *list , struct list_head *prev ,
                                   struct list_head *next )  __attribute__((__no_instrument_function__)) ;
 static void __list_splice(struct list_head *list , struct list_head *prev ,
                                   struct list_head *next )  __attribute__((__no_instrument_function__)) ;
 static void __list_splice(struct list_head *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct list_head *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;

  {
  __cil_tmp6 = *((struct list_head **)list);
  first = __cil_tmp6;
  __cil_tmp7 = (unsigned long )list;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  __cil_tmp9 = *((struct list_head **)__cil_tmp8);
  last = __cil_tmp9;
  __cil_tmp10 = (unsigned long )first;
  __cil_tmp11 = __cil_tmp10 + 8UL;
  *((struct list_head **)__cil_tmp11) = prev;
  *((struct list_head **)prev) = first;
  *((struct list_head **)last) = next;
  __cil_tmp12 = (unsigned long )next;
  __cil_tmp13 = __cil_tmp12 + 8UL;
  *((struct list_head **)__cil_tmp13) = last;
  return;
}
}
 static void list_splice_init(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_splice_init(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
 static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;
  struct list_head *__cil_tmp4 ;
  struct list_head *__cil_tmp5 ;
  struct list_head *__cil_tmp6 ;

  {
  __cil_tmp4 = list;
  tmp = list_empty(__cil_tmp4);
  if (! tmp) {
    __cil_tmp5 = list;
    __cil_tmp6 = *((struct list_head **)head);
    __list_splice(__cil_tmp5, head, __cil_tmp6);
    INIT_LIST_HEAD(list);
  }
  return;
}
}
extern void _raw_spin_lock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _raw_spin_unlock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
 static void spin_lock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_lock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_lock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct raw_spinlock *)lock;
  _raw_spin_lock_irq(__cil_tmp2);
  return;
}
}
 static void spin_unlock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
 static void spin_unlock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  __cil_tmp2 = (struct raw_spinlock *)lock;
  _raw_spin_unlock_irq(__cil_tmp2);
  return;
}
}
extern void do_gettimeofday(struct timeval *tv ) ;
extern void __init_work(struct work_struct *work , int onstack ) ;
extern int schedule_work(struct work_struct *work ) ;
extern bool cancel_work_sync(struct work_struct *work ) ;
static void vmw_fence_obj_destroy_locked(struct kref *kref ) 
{ struct vmw_fence_obj *fence ;
  struct kref *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned int num_fences ;
  struct vmw_fence_obj *__cil_tmp6 ;
  struct kref *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  spinlock_t *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void (*__cil_tmp25)(struct vmw_fence_obj *fence ) ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  spinlock_t *__cil_tmp29 ;

  {
  __mptr = kref;
  __cil_tmp6 = (struct vmw_fence_obj *)0;
  __cil_tmp7 = (struct kref *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  fence = (struct vmw_fence_obj *)__cil_tmp10;
  __cil_tmp11 = (unsigned long )fence;
  __cil_tmp12 = __cil_tmp11 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp12);
  __cil_tmp13 = (unsigned long )fence;
  __cil_tmp14 = __cil_tmp13 + 16UL;
  __cil_tmp15 = (struct list_head *)__cil_tmp14;
  list_del_init(__cil_tmp15);
  __cil_tmp16 = *((int *)fman);
  *((int *)fman) = __cil_tmp16 - 1;
  __cil_tmp17 = *((int *)fman);
  num_fences = (unsigned int )__cil_tmp17;
  __cil_tmp18 = (unsigned long )fman;
  __cil_tmp19 = __cil_tmp18 + 16UL;
  __cil_tmp20 = (spinlock_t *)__cil_tmp19;
  spin_unlock_irq(__cil_tmp20);
  __cil_tmp21 = (unsigned long )fence;
  __cil_tmp22 = __cil_tmp21 + 56UL;
  if (*((void (**)(struct vmw_fence_obj *fence ))__cil_tmp22)) {
    __cil_tmp23 = (unsigned long )fence;
    __cil_tmp24 = __cil_tmp23 + 56UL;
    __cil_tmp25 = *((void (**)(struct vmw_fence_obj *fence ))__cil_tmp24);
    (*__cil_tmp25)(fence);
  } else {
    __cil_tmp26 = (void *)fence;
    kfree(__cil_tmp26);
  }
  __cil_tmp27 = (unsigned long )fman;
  __cil_tmp28 = __cil_tmp27 + 16UL;
  __cil_tmp29 = (spinlock_t *)__cil_tmp28;
  spin_lock_irq(__cil_tmp29);
  return;
}
}
static void vmw_fence_work_func(struct work_struct *work ) 
{ struct vmw_fence_manager *fman ;
  struct work_struct *__mptr ;
  struct list_head list ;
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  bool seqno_valid ;
  int tmp___7 ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  struct list_head *__mptr___2 ;
  struct vmw_fence_manager *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct work_struct *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct mutex *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  spinlock_t *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  spinlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct vmw_private *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct mutex *__cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  struct vmw_fence_action *__cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  struct vmw_fence_action *__cil_tmp52 ;
  struct list_head *__cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct list_head *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  void (*__cil_tmp65)(struct vmw_fence_action *action ) ;
  struct list_head *__cil_tmp66 ;
  struct vmw_fence_action *__cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  __mptr = work;
  __cil_tmp12 = (struct vmw_fence_manager *)0;
  __cil_tmp13 = (unsigned long )__cil_tmp12;
  __cil_tmp14 = __cil_tmp13 + 56UL;
  __cil_tmp15 = (struct work_struct *)__cil_tmp14;
  __cil_tmp16 = (unsigned int )__cil_tmp15;
  __cil_tmp17 = (char *)__mptr;
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
  fman = (struct vmw_fence_manager *)__cil_tmp18;
  while (1) {
    INIT_LIST_HEAD(& list);
    __cil_tmp19 = (unsigned long )fman;
    __cil_tmp20 = __cil_tmp19 + 128UL;
    __cil_tmp21 = (struct mutex *)__cil_tmp20;
    mutex_lock(__cil_tmp21);
    __cil_tmp22 = (unsigned long )fman;
    __cil_tmp23 = __cil_tmp22 + 16UL;
    __cil_tmp24 = (spinlock_t *)__cil_tmp23;
    spin_lock_irq(__cil_tmp24);
    __cil_tmp25 = (unsigned long )fman;
    __cil_tmp26 = __cil_tmp25 + 104UL;
    __cil_tmp27 = (struct list_head *)__cil_tmp26;
    list_splice_init(__cil_tmp27, & list);
    __cil_tmp28 = (unsigned long )fman;
    __cil_tmp29 = __cil_tmp28 + 201UL;
    seqno_valid = *((bool *)__cil_tmp29);
    __cil_tmp30 = (unsigned long )fman;
    __cil_tmp31 = __cil_tmp30 + 16UL;
    __cil_tmp32 = (spinlock_t *)__cil_tmp31;
    spin_unlock_irq(__cil_tmp32);
    if (! seqno_valid) {
      __cil_tmp33 = (unsigned long )fman;
      __cil_tmp34 = __cil_tmp33 + 200UL;
      if (*((bool *)__cil_tmp34)) {
        __cil_tmp35 = (unsigned long )fman;
        __cil_tmp36 = __cil_tmp35 + 200UL;
        *((bool *)__cil_tmp36) = (bool )0;
        __cil_tmp37 = (unsigned long )fman;
        __cil_tmp38 = __cil_tmp37 + 8UL;
        __cil_tmp39 = *((struct vmw_private **)__cil_tmp38);
        vmw_goal_waiter_remove(__cil_tmp39);
      }
    }
    __cil_tmp40 = (unsigned long )fman;
    __cil_tmp41 = __cil_tmp40 + 128UL;
    __cil_tmp42 = (struct mutex *)__cil_tmp41;
    mutex_unlock(__cil_tmp42);
    __cil_tmp43 = & list;
    tmp___7 = list_empty(__cil_tmp43);
    if (tmp___7) {
      return;
    }
    __cil_tmp44 = & list;
    __cil_tmp45 = *((struct list_head **)__cil_tmp44);
    __mptr___0 = __cil_tmp45;
    __cil_tmp46 = (struct vmw_fence_action *)0;
    __cil_tmp47 = (struct list_head *)__cil_tmp46;
    __cil_tmp48 = (unsigned int )__cil_tmp47;
    __cil_tmp49 = (char *)__mptr___0;
    __cil_tmp50 = __cil_tmp49 - __cil_tmp48;
    action = (struct vmw_fence_action *)__cil_tmp50;
    __cil_tmp51 = *((struct list_head **)action);
    __mptr___1 = __cil_tmp51;
    __cil_tmp52 = (struct vmw_fence_action *)0;
    __cil_tmp53 = (struct list_head *)__cil_tmp52;
    __cil_tmp54 = (unsigned int )__cil_tmp53;
    __cil_tmp55 = (char *)__mptr___1;
    __cil_tmp56 = __cil_tmp55 - __cil_tmp54;
    next_action = (struct vmw_fence_action *)__cil_tmp56;
    while (1) {
      __cil_tmp57 = (unsigned long )(& list);
      __cil_tmp58 = (struct list_head *)action;
      __cil_tmp59 = (unsigned long )__cil_tmp58;
      if (! (__cil_tmp59 != __cil_tmp57)) {
        goto while_break___0;
      }
      __cil_tmp60 = (struct list_head *)action;
      list_del_init(__cil_tmp60);
      __cil_tmp61 = (unsigned long )action;
      __cil_tmp62 = __cil_tmp61 + 32UL;
      if (*((void (**)(struct vmw_fence_action *action ))__cil_tmp62)) {
        __cil_tmp63 = (unsigned long )action;
        __cil_tmp64 = __cil_tmp63 + 32UL;
        __cil_tmp65 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp64);
        (*__cil_tmp65)(action);
      }
      action = next_action;
      __cil_tmp66 = *((struct list_head **)next_action);
      __mptr___2 = __cil_tmp66;
      __cil_tmp67 = (struct vmw_fence_action *)0;
      __cil_tmp68 = (struct list_head *)__cil_tmp67;
      __cil_tmp69 = (unsigned int )__cil_tmp68;
      __cil_tmp70 = (char *)__mptr___2;
      __cil_tmp71 = __cil_tmp70 - __cil_tmp69;
      next_action = (struct vmw_fence_action *)__cil_tmp71;
    }
    while_break___0: ;
  }

  return;
}
}
static struct lock_class_key __key___19  ;
static struct lock_class_key __key___20  ;
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) 
{ struct vmw_fence_manager *fman ;
  void *tmp___7 ;
  long tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct raw_spinlock *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct work_struct *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct mutex *__cil_tmp53 ;
  long __r_expr_0_counter54 ;

  {
  tmp___7 = kzalloc(208UL, 208U);
  fman = (struct vmw_fence_manager *)tmp___7;
  __cil_tmp9 = (void *)0;
  __cil_tmp10 = (unsigned long )__cil_tmp9;
  __cil_tmp11 = (unsigned long )fman;
  __cil_tmp12 = __cil_tmp11 == __cil_tmp10;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = (long )__cil_tmp14;
  tmp___8 = ldv__builtin_expect(__cil_tmp15, 0L);
  if (tmp___8) {
    __cil_tmp16 = (void *)0;
    return ((struct vmw_fence_manager *)__cil_tmp16);
  }
  __cil_tmp17 = (unsigned long )fman;
  __cil_tmp18 = __cil_tmp17 + 8UL;
  *((struct vmw_private **)__cil_tmp18) = dev_priv;
  while (1) {
    __cil_tmp19 = (unsigned long )fman;
    __cil_tmp20 = __cil_tmp19 + 16UL;
    __cil_tmp21 = (spinlock_t *)__cil_tmp20;
    spinlock_check(__cil_tmp21);
    while (1) {
      __cil_tmp22 = (unsigned long )fman;
      __cil_tmp23 = __cil_tmp22 + 16UL;
      __cil_tmp24 = (struct raw_spinlock *)__cil_tmp23;
      __raw_spin_lock_init(__cil_tmp24, "&(&fman->lock)->rlock", & __key___19);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp25 = (unsigned long )fman;
  __cil_tmp26 = __cil_tmp25 + 40UL;
  __cil_tmp27 = (struct list_head *)__cil_tmp26;
  INIT_LIST_HEAD(__cil_tmp27);
  __cil_tmp28 = (unsigned long )fman;
  __cil_tmp29 = __cil_tmp28 + 104UL;
  __cil_tmp30 = (struct list_head *)__cil_tmp29;
  INIT_LIST_HEAD(__cil_tmp30);
  while (1) {

    while (1) {
      __cil_tmp31 = (unsigned long )fman;
      __cil_tmp32 = __cil_tmp31 + 56UL;
      __cil_tmp33 = (struct work_struct *)__cil_tmp32;
      __init_work(__cil_tmp33, 0);
      __r_expr_0_counter54 = 2097664L;
      __cil_tmp34 = (unsigned long )fman;
      __cil_tmp35 = __cil_tmp34 + 56UL;
      ((atomic_long_t *)__cil_tmp35)->counter = __r_expr_0_counter54;
      __cil_tmp36 = 64;
      __cil_tmp37 = (unsigned long )fman;
      __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
      __cil_tmp39 = (struct list_head *)__cil_tmp38;
      INIT_LIST_HEAD(__cil_tmp39);
      while (1) {
        __cil_tmp40 = 80;
        __cil_tmp41 = (unsigned long )fman;
        __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
        *((void (**)(struct work_struct *work ))__cil_tmp42) = & vmw_fence_work_func;
        goto while_break___3;
      }
      while_break___3: ;
      goto while_break___2;
    }
    while_break___2: ;
    goto while_break___1;
  }
  while_break___1: 
  __cil_tmp43 = (unsigned long )fman;
  __cil_tmp44 = __cil_tmp43 + 100UL;
  *((bool *)__cil_tmp44) = (bool )1;
  tmp___9 = ttm_round_pot(168UL);
  __cil_tmp45 = (unsigned long )fman;
  __cil_tmp46 = __cil_tmp45 + 88UL;
  *((u32 *)__cil_tmp46) = (u32 )tmp___9;
  tmp___10 = ttm_round_pot(104UL);
  __cil_tmp47 = (unsigned long )fman;
  __cil_tmp48 = __cil_tmp47 + 92UL;
  *((u32 *)__cil_tmp48) = (u32 )tmp___10;
  tmp___11 = ttm_round_pot(96UL);
  __cil_tmp49 = (unsigned long )fman;
  __cil_tmp50 = __cil_tmp49 + 96UL;
  *((u32 *)__cil_tmp50) = (u32 )tmp___11;
  while (1) {
    __cil_tmp51 = (unsigned long )fman;
    __cil_tmp52 = __cil_tmp51 + 128UL;
    __cil_tmp53 = (struct mutex *)__cil_tmp52;
    __mutex_init(__cil_tmp53, "&fman->goal_irq_mutex", & __key___20);
    goto while_break___4;
  }
  while_break___4: ;
  return (fman);
}
}
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  bool lists_empty ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct work_struct *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  spinlock_t *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  void *__cil_tmp32 ;

  {
  __cil_tmp11 = (unsigned long )fman;
  __cil_tmp12 = __cil_tmp11 + 56UL;
  __cil_tmp13 = (struct work_struct *)__cil_tmp12;
  cancel_work_sync(__cil_tmp13);
  while (1) {

    while (1) {
      __cil_tmp14 = (unsigned long )fman;
      __cil_tmp15 = __cil_tmp14 + 16UL;
      __cil_tmp16 = (spinlock_t *)__cil_tmp15;
      tmp___7 = spinlock_check(__cil_tmp16);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp17 = (unsigned long )fman;
  __cil_tmp18 = __cil_tmp17 + 40UL;
  __cil_tmp19 = (struct list_head *)__cil_tmp18;
  __cil_tmp20 = __cil_tmp19;
  tmp___8 = list_empty(__cil_tmp20);
  if (tmp___8) {
    __cil_tmp21 = (unsigned long )fman;
    __cil_tmp22 = __cil_tmp21 + 104UL;
    __cil_tmp23 = (struct list_head *)__cil_tmp22;
    __cil_tmp24 = __cil_tmp23;
    tmp___9 = list_empty(__cil_tmp24);
    if (tmp___9) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
  } else {
    tmp___10 = 0;
  }
  lists_empty = (bool )tmp___10;
  __cil_tmp25 = (unsigned long )fman;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
  spin_unlock_irqrestore(__cil_tmp27, irq_flags);
  while (1) {
    __cil_tmp28 = ! lists_empty;
    __cil_tmp29 = ! __cil_tmp28;
    __cil_tmp30 = ! __cil_tmp29;
    __cil_tmp31 = (long )__cil_tmp30;
    tmp___11 = ldv__builtin_expect(__cil_tmp31, 0L);
    if (tmp___11) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (205), "i" (12UL));
        while (1) {

        }

        goto while_break___2;
      }
      while_break___2: ;
    }
    goto while_break___1;
  }
  while_break___1: 
  __cil_tmp32 = (void *)fman;
  kfree(__cil_tmp32);
  return;
}
}
static struct lock_class_key __key___21  ;
static int vmw_fence_obj_init(struct vmw_fence_manager *fman , struct vmw_fence_obj *fence ,
                              u32 seqno , uint32_t mask , void (*destroy)(struct vmw_fence_obj *fence ) ) 
{ unsigned long irq_flags ;
  unsigned int num_fences ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct kref *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  wait_queue_head_t *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  spinlock_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  bool __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  spinlock_t *__cil_tmp49 ;

  {
  ret = 0;
  __cil_tmp13 = (unsigned long )fence;
  __cil_tmp14 = __cil_tmp13 + 4UL;
  *((u32 *)__cil_tmp14) = seqno;
  __cil_tmp15 = (unsigned long )fence;
  __cil_tmp16 = __cil_tmp15 + 40UL;
  __cil_tmp17 = (struct list_head *)__cil_tmp16;
  INIT_LIST_HEAD(__cil_tmp17);
  __cil_tmp18 = (unsigned long )fence;
  __cil_tmp19 = __cil_tmp18 + 8UL;
  *((struct vmw_fence_manager **)__cil_tmp19) = fman;
  __cil_tmp20 = (unsigned long )fence;
  __cil_tmp21 = __cil_tmp20 + 32UL;
  *((uint32_t *)__cil_tmp21) = (uint32_t )0;
  __cil_tmp22 = (unsigned long )fence;
  __cil_tmp23 = __cil_tmp22 + 36UL;
  *((uint32_t *)__cil_tmp23) = mask;
  __cil_tmp24 = (struct kref *)fence;
  kref_init(__cil_tmp24);
  __cil_tmp25 = (unsigned long )fence;
  __cil_tmp26 = __cil_tmp25 + 56UL;
  *((void (**)(struct vmw_fence_obj *fence ))__cil_tmp26) = destroy;
  while (1) {
    __cil_tmp27 = (unsigned long )fence;
    __cil_tmp28 = __cil_tmp27 + 64UL;
    __cil_tmp29 = (wait_queue_head_t *)__cil_tmp28;
    __init_waitqueue_head(__cil_tmp29, "&fence->queue", & __key___21);
    goto while_break;
  }
  while_break: ;
  while (1) {

    while (1) {
      __cil_tmp30 = (unsigned long )fman;
      __cil_tmp31 = __cil_tmp30 + 16UL;
      __cil_tmp32 = (spinlock_t *)__cil_tmp31;
      tmp___7 = spinlock_check(__cil_tmp32);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___1;
    }
    while_break___1: ;
    goto while_break___0;
  }
  while_break___0: 
  __cil_tmp33 = (unsigned long )fman;
  __cil_tmp34 = __cil_tmp33 + 100UL;
  __cil_tmp35 = *((bool *)__cil_tmp34);
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = (long )__cil_tmp37;
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 0L);
  if (tmp___8) {
    ret = -16;
    goto out_unlock;
  }
  __cil_tmp39 = (unsigned long )fence;
  __cil_tmp40 = __cil_tmp39 + 16UL;
  __cil_tmp41 = (struct list_head *)__cil_tmp40;
  __cil_tmp42 = (unsigned long )fman;
  __cil_tmp43 = __cil_tmp42 + 40UL;
  __cil_tmp44 = (struct list_head *)__cil_tmp43;
  list_add_tail(__cil_tmp41, __cil_tmp44);
  __cil_tmp45 = *((int *)fman);
  *((int *)fman) = __cil_tmp45 + 1;
  __cil_tmp46 = *((int *)fman);
  num_fences = (unsigned int )__cil_tmp46;
  out_unlock: 
  __cil_tmp47 = (unsigned long )fman;
  __cil_tmp48 = __cil_tmp47 + 16UL;
  __cil_tmp49 = (spinlock_t *)__cil_tmp48;
  spin_unlock_irqrestore(__cil_tmp49, irq_flags);
  return (ret);
}
}
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) 
{ long tmp___7 ;
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  long __cil_tmp9 ;
  void *__cil_tmp10 ;
  struct kref *__cil_tmp11 ;

  {
  __cil_tmp3 = (void *)0;
  __cil_tmp4 = (unsigned long )__cil_tmp3;
  __cil_tmp5 = (unsigned long )fence;
  __cil_tmp6 = __cil_tmp5 == __cil_tmp4;
  __cil_tmp7 = ! __cil_tmp6;
  __cil_tmp8 = ! __cil_tmp7;
  __cil_tmp9 = (long )__cil_tmp8;
  tmp___7 = ldv__builtin_expect(__cil_tmp9, 0L);
  if (tmp___7) {
    __cil_tmp10 = (void *)0;
    return ((struct vmw_fence_obj *)__cil_tmp10);
  }
  __cil_tmp11 = (struct kref *)fence;
  kref_get(__cil_tmp11);
  return (fence);
}
}
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) 
{ struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  spinlock_t *__cil_tmp20 ;
  atomic_t *__cil_tmp21 ;
  atomic_t *__cil_tmp22 ;
  long __cil_tmp23 ;
  struct kref *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;

  {
  fence = *fence_p;
  __cil_tmp8 = (void *)0;
  __cil_tmp9 = (unsigned long )__cil_tmp8;
  __cil_tmp10 = (unsigned long )fence;
  __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp___7) {
    return;
  }
  __cil_tmp15 = (unsigned long )fence;
  __cil_tmp16 = __cil_tmp15 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp16);
  __cil_tmp17 = (void *)0;
  *fence_p = (struct vmw_fence_obj *)__cil_tmp17;
  __cil_tmp18 = (unsigned long )fman;
  __cil_tmp19 = __cil_tmp18 + 16UL;
  __cil_tmp20 = (spinlock_t *)__cil_tmp19;
  spin_lock_irq(__cil_tmp20);
  while (1) {
    __cil_tmp21 = (atomic_t *)fence;
    __cil_tmp22 = __cil_tmp21;
    tmp___8 = atomic_read(__cil_tmp22);
    if (tmp___8 == 0) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
    __cil_tmp23 = (long )tmp___9;
    tmp___10 = ldv__builtin_expect(__cil_tmp23, 0L);
    if (tmp___10) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (269), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp24 = (struct kref *)fence;
  kref_put(__cil_tmp24, & vmw_fence_obj_destroy_locked);
  __cil_tmp25 = (unsigned long )fman;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
  spin_unlock_irq(__cil_tmp27);
  return;
}
}
void vmw_fences_perform_actions(struct vmw_fence_manager *fman , struct list_head *list ) 
{ struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  struct list_head *__cil_tmp8 ;
  struct vmw_fence_action *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct vmw_fence_action *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  enum vmw_action_type __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  enum vmw_action_type __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  void (*__cil_tmp43)(struct vmw_fence_action *action ) ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  void (*__cil_tmp47)(struct vmw_fence_action *action ) ;
  struct list_head *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  struct list_head *__cil_tmp52 ;
  struct vmw_fence_action *__cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  __cil_tmp8 = *((struct list_head **)list);
  __mptr = __cil_tmp8;
  __cil_tmp9 = (struct vmw_fence_action *)0;
  __cil_tmp10 = (struct list_head *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  action = (struct vmw_fence_action *)__cil_tmp13;
  __cil_tmp14 = *((struct list_head **)action);
  __mptr___0 = __cil_tmp14;
  __cil_tmp15 = (struct vmw_fence_action *)0;
  __cil_tmp16 = (struct list_head *)__cil_tmp15;
  __cil_tmp17 = (unsigned int )__cil_tmp16;
  __cil_tmp18 = (char *)__mptr___0;
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
  next_action = (struct vmw_fence_action *)__cil_tmp19;
  while (1) {
    __cil_tmp20 = (unsigned long )list;
    __cil_tmp21 = (struct list_head *)action;
    __cil_tmp22 = (unsigned long )__cil_tmp21;
    if (! (__cil_tmp22 != __cil_tmp20)) {
      goto while_break;
    }
    __cil_tmp23 = (struct list_head *)action;
    list_del_init(__cil_tmp23);
    __cil_tmp24 = (unsigned long )action;
    __cil_tmp25 = __cil_tmp24 + 16UL;
    __cil_tmp26 = *((enum vmw_action_type *)__cil_tmp25);
    __cil_tmp27 = (unsigned long )__cil_tmp26 * 4UL;
    __cil_tmp28 = 120UL + __cil_tmp27;
    __cil_tmp29 = (unsigned long )fman;
    __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
    __cil_tmp31 = (unsigned long )action;
    __cil_tmp32 = __cil_tmp31 + 16UL;
    __cil_tmp33 = *((enum vmw_action_type *)__cil_tmp32);
    __cil_tmp34 = (unsigned long )__cil_tmp33 * 4UL;
    __cil_tmp35 = 120UL + __cil_tmp34;
    __cil_tmp36 = (unsigned long )fman;
    __cil_tmp37 = __cil_tmp36 + __cil_tmp35;
    __cil_tmp38 = *((uint32_t *)__cil_tmp37);
    *((uint32_t *)__cil_tmp30) = __cil_tmp38 - 1U;
    __cil_tmp39 = (void *)0;
    __cil_tmp40 = (unsigned long )__cil_tmp39;
    __cil_tmp41 = (unsigned long )action;
    __cil_tmp42 = __cil_tmp41 + 24UL;
    __cil_tmp43 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp42);
    __cil_tmp44 = (unsigned long )__cil_tmp43;
    if (__cil_tmp44 != __cil_tmp40) {
      __cil_tmp45 = (unsigned long )action;
      __cil_tmp46 = __cil_tmp45 + 24UL;
      __cil_tmp47 = *((void (**)(struct vmw_fence_action *action ))__cil_tmp46);
      (*__cil_tmp47)(action);
    }
    __cil_tmp48 = (struct list_head *)action;
    __cil_tmp49 = (unsigned long )fman;
    __cil_tmp50 = __cil_tmp49 + 104UL;
    __cil_tmp51 = (struct list_head *)__cil_tmp50;
    list_add_tail(__cil_tmp48, __cil_tmp51);
    action = next_action;
    __cil_tmp52 = *((struct list_head **)next_action);
    __mptr___1 = __cil_tmp52;
    __cil_tmp53 = (struct vmw_fence_action *)0;
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
    __cil_tmp55 = (unsigned int )__cil_tmp54;
    __cil_tmp56 = (char *)__mptr___1;
    __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
    next_action = (struct vmw_fence_action *)__cil_tmp57;
  }
  while_break: ;
  return;
}
}
static bool vmw_fence_goal_new_locked(struct vmw_fence_manager *fman , u32 passed_seqno ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  struct vmw_fence_obj *fence ;
  long tmp___7 ;
  long tmp___8 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  int tmp___9 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_private *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  u32 __cil_tmp26 ;
  u32 __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  struct vmw_fence_obj *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  struct list_head *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  u32 __cil_tmp60 ;
  __le32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct list_head *__cil_tmp65 ;
  struct vmw_fence_obj *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct list_head *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
  __cil_tmp11 = (unsigned long )fman;
  __cil_tmp12 = __cil_tmp11 + 201UL;
  __cil_tmp13 = *((bool *)__cil_tmp12);
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = (long )__cil_tmp16;
  tmp___7 = ldv__builtin_expect(__cil_tmp17, 1L);
  if (tmp___7) {
    return ((bool )0);
  }
  __cil_tmp18 = (unsigned long )fman;
  __cil_tmp19 = __cil_tmp18 + 8UL;
  __cil_tmp20 = *((struct vmw_private **)__cil_tmp19);
  __cil_tmp21 = (unsigned long )__cil_tmp20;
  __cil_tmp22 = __cil_tmp21 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp22);
  __cil_tmp23 = fifo_mem + 289;
  __cil_tmp24 = (void *)__cil_tmp23;
  goal_seqno = ioread32(__cil_tmp24);
  __cil_tmp25 = 1 << 31;
  __cil_tmp26 = (u32 )__cil_tmp25;
  __cil_tmp27 = passed_seqno - goal_seqno;
  __cil_tmp28 = __cil_tmp27 >= __cil_tmp26;
  __cil_tmp29 = ! __cil_tmp28;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = (long )__cil_tmp30;
  tmp___8 = ldv__builtin_expect(__cil_tmp31, 1L);
  if (tmp___8) {
    return ((bool )0);
  }
  __cil_tmp32 = (unsigned long )fman;
  __cil_tmp33 = __cil_tmp32 + 201UL;
  *((bool *)__cil_tmp33) = (bool )0;
  __cil_tmp34 = (unsigned long )fman;
  __cil_tmp35 = __cil_tmp34 + 40UL;
  __cil_tmp36 = *((struct list_head **)__cil_tmp35);
  __mptr = __cil_tmp36;
  __cil_tmp37 = (struct vmw_fence_obj *)0;
  __cil_tmp38 = (unsigned long )__cil_tmp37;
  __cil_tmp39 = __cil_tmp38 + 16UL;
  __cil_tmp40 = (struct list_head *)__cil_tmp39;
  __cil_tmp41 = (unsigned int )__cil_tmp40;
  __cil_tmp42 = (char *)__mptr;
  __cil_tmp43 = __cil_tmp42 - __cil_tmp41;
  fence = (struct vmw_fence_obj *)__cil_tmp43;
  while (1) {
    __cil_tmp44 = (unsigned long )fman;
    __cil_tmp45 = __cil_tmp44 + 40UL;
    __cil_tmp46 = (struct list_head *)__cil_tmp45;
    __cil_tmp47 = (unsigned long )__cil_tmp46;
    __cil_tmp48 = (unsigned long )fence;
    __cil_tmp49 = __cil_tmp48 + 16UL;
    __cil_tmp50 = (struct list_head *)__cil_tmp49;
    __cil_tmp51 = (unsigned long )__cil_tmp50;
    if (! (__cil_tmp51 != __cil_tmp47)) {
      goto while_break;
    }
    __cil_tmp52 = (unsigned long )fence;
    __cil_tmp53 = __cil_tmp52 + 40UL;
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
    __cil_tmp55 = __cil_tmp54;
    tmp___9 = list_empty(__cil_tmp55);
    if (! tmp___9) {
      __cil_tmp56 = (unsigned long )fman;
      __cil_tmp57 = __cil_tmp56 + 201UL;
      *((bool *)__cil_tmp57) = (bool )1;
      __cil_tmp58 = (unsigned long )fence;
      __cil_tmp59 = __cil_tmp58 + 4UL;
      __cil_tmp60 = *((u32 *)__cil_tmp59);
      __cil_tmp61 = fifo_mem + 289;
      __cil_tmp62 = (void *)__cil_tmp61;
      iowrite32(__cil_tmp60, __cil_tmp62);
      goto while_break;
    }
    __cil_tmp63 = (unsigned long )fence;
    __cil_tmp64 = __cil_tmp63 + 16UL;
    __cil_tmp65 = *((struct list_head **)__cil_tmp64);
    __mptr___0 = __cil_tmp65;
    __cil_tmp66 = (struct vmw_fence_obj *)0;
    __cil_tmp67 = (unsigned long )__cil_tmp66;
    __cil_tmp68 = __cil_tmp67 + 16UL;
    __cil_tmp69 = (struct list_head *)__cil_tmp68;
    __cil_tmp70 = (unsigned int )__cil_tmp69;
    __cil_tmp71 = (char *)__mptr___0;
    __cil_tmp72 = __cil_tmp71 - __cil_tmp70;
    fence = (struct vmw_fence_obj *)__cil_tmp72;
  }
  while_break: ;
  return ((bool )1);
}
}
static bool vmw_fence_goal_check_locked(struct vmw_fence_obj *fence ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct vmw_fence_manager *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_private *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  __le32 *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct vmw_fence_manager *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  u32 __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  u32 __cil_tmp28 ;
  u32 __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  u32 __cil_tmp33 ;
  __le32 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct vmw_fence_manager *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;

  {
  __cil_tmp6 = (unsigned long )fence;
  __cil_tmp7 = __cil_tmp6 + 32UL;
  __cil_tmp8 = *((uint32_t *)__cil_tmp7);
  if (__cil_tmp8 & 1U) {
    return ((bool )0);
  }
  __cil_tmp9 = (unsigned long )fence;
  __cil_tmp10 = __cil_tmp9 + 8UL;
  __cil_tmp11 = *((struct vmw_fence_manager **)__cil_tmp10);
  __cil_tmp12 = (unsigned long )__cil_tmp11;
  __cil_tmp13 = __cil_tmp12 + 8UL;
  __cil_tmp14 = *((struct vmw_private **)__cil_tmp13);
  __cil_tmp15 = (unsigned long )__cil_tmp14;
  __cil_tmp16 = __cil_tmp15 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp16);
  __cil_tmp17 = fifo_mem + 289;
  __cil_tmp18 = (void *)__cil_tmp17;
  goal_seqno = ioread32(__cil_tmp18);
  __cil_tmp19 = (unsigned long )fence;
  __cil_tmp20 = __cil_tmp19 + 8UL;
  __cil_tmp21 = *((struct vmw_fence_manager **)__cil_tmp20);
  __cil_tmp22 = (unsigned long )__cil_tmp21;
  __cil_tmp23 = __cil_tmp22 + 201UL;
  if (*((bool *)__cil_tmp23)) {
    __cil_tmp24 = 1 << 31;
    __cil_tmp25 = (u32 )__cil_tmp24;
    __cil_tmp26 = (unsigned long )fence;
    __cil_tmp27 = __cil_tmp26 + 4UL;
    __cil_tmp28 = *((u32 *)__cil_tmp27);
    __cil_tmp29 = goal_seqno - __cil_tmp28;
    if (__cil_tmp29 < __cil_tmp25) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  __cil_tmp30 = (long )tmp___7;
  tmp___8 = ldv__builtin_expect(__cil_tmp30, 1L);
  if (tmp___8) {
    return ((bool )0);
  }
  __cil_tmp31 = (unsigned long )fence;
  __cil_tmp32 = __cil_tmp31 + 4UL;
  __cil_tmp33 = *((u32 *)__cil_tmp32);
  __cil_tmp34 = fifo_mem + 289;
  __cil_tmp35 = (void *)__cil_tmp34;
  iowrite32(__cil_tmp33, __cil_tmp35);
  __cil_tmp36 = (unsigned long )fence;
  __cil_tmp37 = __cil_tmp36 + 8UL;
  __cil_tmp38 = *((struct vmw_fence_manager **)__cil_tmp37);
  __cil_tmp39 = (unsigned long )__cil_tmp38;
  __cil_tmp40 = __cil_tmp39 + 201UL;
  *((bool *)__cil_tmp40) = (bool )1;
  return ((bool )1);
}
}
void vmw_fences_update(struct vmw_fence_manager *fman ) 
{ unsigned long flags ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_obj *next_fence ;
  struct list_head action_list ;
  bool needs_rerun ;
  uint32_t seqno ;
  uint32_t new_seqno ;
  __le32 *fifo_mem ;
  raw_spinlock_t *tmp___7 ;
  struct list_head *__mptr ;
  struct list_head *__mptr___0 ;
  struct list_head *__mptr___1 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct vmw_private *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  __le32 *__cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  struct vmw_fence_obj *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  struct vmw_fence_obj *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct list_head *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  u32 __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct list_head *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  struct list_head *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  wait_queue_head_t *__cil_tmp75 ;
  void *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  struct list_head *__cil_tmp79 ;
  struct vmw_fence_obj *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct list_head *__cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct list_head *__cil_tmp89 ;
  struct list_head *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  struct work_struct *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  spinlock_t *__cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  long __cil_tmp99 ;
  __le32 *__cil_tmp100 ;
  void *__cil_tmp101 ;

  {
  __cil_tmp18 = (unsigned long )fman;
  __cil_tmp19 = __cil_tmp18 + 8UL;
  __cil_tmp20 = *((struct vmw_private **)__cil_tmp19);
  __cil_tmp21 = (unsigned long )__cil_tmp20;
  __cil_tmp22 = __cil_tmp21 + 2144UL;
  fifo_mem = *((__le32 **)__cil_tmp22);
  __cil_tmp23 = fifo_mem + 6;
  __cil_tmp24 = (void *)__cil_tmp23;
  seqno = ioread32(__cil_tmp24);
  rerun: 
  while (1) {

    while (1) {
      __cil_tmp25 = (unsigned long )fman;
      __cil_tmp26 = __cil_tmp25 + 16UL;
      __cil_tmp27 = (spinlock_t *)__cil_tmp26;
      tmp___7 = spinlock_check(__cil_tmp27);
      flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp28 = (unsigned long )fman;
  __cil_tmp29 = __cil_tmp28 + 40UL;
  __cil_tmp30 = *((struct list_head **)__cil_tmp29);
  __mptr = __cil_tmp30;
  __cil_tmp31 = (struct vmw_fence_obj *)0;
  __cil_tmp32 = (unsigned long )__cil_tmp31;
  __cil_tmp33 = __cil_tmp32 + 16UL;
  __cil_tmp34 = (struct list_head *)__cil_tmp33;
  __cil_tmp35 = (unsigned int )__cil_tmp34;
  __cil_tmp36 = (char *)__mptr;
  __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
  fence = (struct vmw_fence_obj *)__cil_tmp37;
  __cil_tmp38 = (unsigned long )fence;
  __cil_tmp39 = __cil_tmp38 + 16UL;
  __cil_tmp40 = *((struct list_head **)__cil_tmp39);
  __mptr___0 = __cil_tmp40;
  __cil_tmp41 = (struct vmw_fence_obj *)0;
  __cil_tmp42 = (unsigned long )__cil_tmp41;
  __cil_tmp43 = __cil_tmp42 + 16UL;
  __cil_tmp44 = (struct list_head *)__cil_tmp43;
  __cil_tmp45 = (unsigned int )__cil_tmp44;
  __cil_tmp46 = (char *)__mptr___0;
  __cil_tmp47 = __cil_tmp46 - __cil_tmp45;
  next_fence = (struct vmw_fence_obj *)__cil_tmp47;
  while (1) {
    __cil_tmp48 = (unsigned long )fman;
    __cil_tmp49 = __cil_tmp48 + 40UL;
    __cil_tmp50 = (struct list_head *)__cil_tmp49;
    __cil_tmp51 = (unsigned long )__cil_tmp50;
    __cil_tmp52 = (unsigned long )fence;
    __cil_tmp53 = __cil_tmp52 + 16UL;
    __cil_tmp54 = (struct list_head *)__cil_tmp53;
    __cil_tmp55 = (unsigned long )__cil_tmp54;
    if (! (__cil_tmp55 != __cil_tmp51)) {
      goto while_break___1;
    }
    __cil_tmp56 = 1 << 31;
    __cil_tmp57 = (uint32_t )__cil_tmp56;
    __cil_tmp58 = (unsigned long )fence;
    __cil_tmp59 = __cil_tmp58 + 4UL;
    __cil_tmp60 = *((u32 *)__cil_tmp59);
    __cil_tmp61 = seqno - __cil_tmp60;
    if (__cil_tmp61 < __cil_tmp57) {
      __cil_tmp62 = (unsigned long )fence;
      __cil_tmp63 = __cil_tmp62 + 16UL;
      __cil_tmp64 = (struct list_head *)__cil_tmp63;
      list_del_init(__cil_tmp64);
      __cil_tmp65 = (unsigned long )fence;
      __cil_tmp66 = __cil_tmp65 + 32UL;
      __cil_tmp67 = (unsigned long )fence;
      __cil_tmp68 = __cil_tmp67 + 32UL;
      __cil_tmp69 = *((uint32_t *)__cil_tmp68);
      *((uint32_t *)__cil_tmp66) = __cil_tmp69 | 1U;
      INIT_LIST_HEAD(& action_list);
      __cil_tmp70 = (unsigned long )fence;
      __cil_tmp71 = __cil_tmp70 + 40UL;
      __cil_tmp72 = (struct list_head *)__cil_tmp71;
      list_splice_init(__cil_tmp72, & action_list);
      vmw_fences_perform_actions(fman, & action_list);
      __cil_tmp73 = (unsigned long )fence;
      __cil_tmp74 = __cil_tmp73 + 64UL;
      __cil_tmp75 = (wait_queue_head_t *)__cil_tmp74;
      __cil_tmp76 = (void *)0;
      __wake_up(__cil_tmp75, 3U, 0, __cil_tmp76);
    } else {
      goto while_break___1;
    }
    fence = next_fence;
    __cil_tmp77 = (unsigned long )next_fence;
    __cil_tmp78 = __cil_tmp77 + 16UL;
    __cil_tmp79 = *((struct list_head **)__cil_tmp78);
    __mptr___1 = __cil_tmp79;
    __cil_tmp80 = (struct vmw_fence_obj *)0;
    __cil_tmp81 = (unsigned long )__cil_tmp80;
    __cil_tmp82 = __cil_tmp81 + 16UL;
    __cil_tmp83 = (struct list_head *)__cil_tmp82;
    __cil_tmp84 = (unsigned int )__cil_tmp83;
    __cil_tmp85 = (char *)__mptr___1;
    __cil_tmp86 = __cil_tmp85 - __cil_tmp84;
    next_fence = (struct vmw_fence_obj *)__cil_tmp86;
  }
  while_break___1: 
  needs_rerun = vmw_fence_goal_new_locked(fman, seqno);
  __cil_tmp87 = (unsigned long )fman;
  __cil_tmp88 = __cil_tmp87 + 104UL;
  __cil_tmp89 = (struct list_head *)__cil_tmp88;
  __cil_tmp90 = __cil_tmp89;
  tmp___8 = list_empty(__cil_tmp90);
  if (! tmp___8) {
    __cil_tmp91 = (unsigned long )fman;
    __cil_tmp92 = __cil_tmp91 + 56UL;
    __cil_tmp93 = (struct work_struct *)__cil_tmp92;
    schedule_work(__cil_tmp93);
  }
  __cil_tmp94 = (unsigned long )fman;
  __cil_tmp95 = __cil_tmp94 + 16UL;
  __cil_tmp96 = (spinlock_t *)__cil_tmp95;
  spin_unlock_irqrestore(__cil_tmp96, flags);
  __cil_tmp97 = ! needs_rerun;
  __cil_tmp98 = ! __cil_tmp97;
  __cil_tmp99 = (long )__cil_tmp98;
  tmp___9 = ldv__builtin_expect(__cil_tmp99, 0L);
  if (tmp___9) {
    __cil_tmp100 = fifo_mem + 6;
    __cil_tmp101 = (void *)__cil_tmp100;
    new_seqno = ioread32(__cil_tmp101);
    if (new_seqno != seqno) {
      seqno = new_seqno;
      goto rerun;
    }
  }
  return;
}
}
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  uint32_t signaled ;
  raw_spinlock_t *tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  spinlock_t *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  spinlock_t *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  spinlock_t *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
  __cil_tmp12 = (unsigned long )fence;
  __cil_tmp13 = __cil_tmp12 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp13);
  while (1) {

    while (1) {
      __cil_tmp14 = (unsigned long )fman;
      __cil_tmp15 = __cil_tmp14 + 16UL;
      __cil_tmp16 = (spinlock_t *)__cil_tmp15;
      tmp___7 = spinlock_check(__cil_tmp16);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp17 = (unsigned long )fence;
  __cil_tmp18 = __cil_tmp17 + 32UL;
  signaled = *((uint32_t *)__cil_tmp18);
  __cil_tmp19 = (unsigned long )fman;
  __cil_tmp20 = __cil_tmp19 + 16UL;
  __cil_tmp21 = (spinlock_t *)__cil_tmp20;
  spin_unlock_irqrestore(__cil_tmp21, irq_flags);
  __cil_tmp22 = (unsigned long )fence;
  __cil_tmp23 = __cil_tmp22 + 36UL;
  __cil_tmp24 = *((uint32_t *)__cil_tmp23);
  flags &= __cil_tmp24;
  __cil_tmp25 = signaled & flags;
  if (__cil_tmp25 == flags) {
    return ((bool )1);
  }
  __cil_tmp26 = signaled & 1U;
  if (__cil_tmp26 == 0U) {
    vmw_fences_update(fman);
  }
  while (1) {

    while (1) {
      __cil_tmp27 = (unsigned long )fman;
      __cil_tmp28 = __cil_tmp27 + 16UL;
      __cil_tmp29 = (spinlock_t *)__cil_tmp28;
      tmp___8 = spinlock_check(__cil_tmp29);
      irq_flags = _raw_spin_lock_irqsave(tmp___8);
      goto while_break___2;
    }
    while_break___2: ;
    goto while_break___1;
  }
  while_break___1: 
  __cil_tmp30 = (unsigned long )fence;
  __cil_tmp31 = __cil_tmp30 + 32UL;
  signaled = *((uint32_t *)__cil_tmp31);
  __cil_tmp32 = (unsigned long )fman;
  __cil_tmp33 = __cil_tmp32 + 16UL;
  __cil_tmp34 = (spinlock_t *)__cil_tmp33;
  spin_unlock_irqrestore(__cil_tmp34, irq_flags);
  __cil_tmp35 = signaled & flags;
  __cil_tmp36 = __cil_tmp35 == flags;
  return ((bool )__cil_tmp36);
}
}
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) 
{ struct vmw_private *dev_priv ;
  long ret ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___10 ;
  bool tmp___11 ;
  struct task_struct *tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_fence_manager *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  wait_queue_t *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  wait_queue_head_t *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  wait_queue_head_t *__cil_tmp45 ;
  wait_queue_t *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  wait_queue_head_t *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  wait_queue_head_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  long __cil_tmp67 ;

  {
  __cil_tmp25 = (unsigned long )fence;
  __cil_tmp26 = __cil_tmp25 + 8UL;
  __cil_tmp27 = *((struct vmw_fence_manager **)__cil_tmp26);
  __cil_tmp28 = (unsigned long )__cil_tmp27;
  __cil_tmp29 = __cil_tmp28 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp29);
  tmp___7 = vmw_fence_obj_signaled(fence, flags);
  if (tmp___7) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  __cil_tmp30 = (long )tmp___8;
  tmp___9 = ldv__builtin_expect(__cil_tmp30, 1L);
  if (tmp___9) {
    return (0);
  }
  __cil_tmp31 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp31);
  vmw_seqno_waiter_add(dev_priv);
  if (interruptible) {
    __ret = (long )timeout;
    tmp___14 = vmw_fence_obj_signaled(fence, flags);
    if (! tmp___14) {
      while (1) {
        tmp___10 = get_current();
        __cil_tmp32 = & __wait;
        *((unsigned int *)__cil_tmp32) = 0U;
        __cil_tmp33 = (unsigned long )(& __wait) + 8UL;
        *((void **)__cil_tmp33) = (void *)tmp___10;
        __cil_tmp34 = (unsigned long )(& __wait) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp34) = & autoremove_wake_function;
        __cil_tmp35 = (unsigned long )(& __wait) + 24UL;
        __cil_tmp36 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp35) = (struct list_head *)__cil_tmp36;
        __cil_tmp37 = 32;
        __cil_tmp38 = (unsigned long )(& __wait) + __cil_tmp37;
        __cil_tmp39 = (unsigned long )(& __wait) + 24UL;
        *((struct list_head **)__cil_tmp38) = (struct list_head *)__cil_tmp39;
        while (1) {
          __cil_tmp40 = (unsigned long )fence;
          __cil_tmp41 = __cil_tmp40 + 64UL;
          __cil_tmp42 = (wait_queue_head_t *)__cil_tmp41;
          prepare_to_wait(__cil_tmp42, & __wait, 1);
          tmp___11 = vmw_fence_obj_signaled(fence, flags);
          if (tmp___11) {
            goto while_break___0;
          }
          tmp___12 = get_current();
          tmp___13 = signal_pending(tmp___12);
          if (! tmp___13) {
            __ret = schedule_timeout(__ret);
            if (! __ret) {
              goto while_break___0;
            }
            goto __Cont;
          }
          __ret = -512L;
          goto while_break___0;
          __Cont: ;
        }
        while_break___0: 
        __cil_tmp43 = (unsigned long )fence;
        __cil_tmp44 = __cil_tmp43 + 64UL;
        __cil_tmp45 = (wait_queue_head_t *)__cil_tmp44;
        finish_wait(__cil_tmp45, & __wait);
        goto while_break;
      }
      while_break: ;
    }
    ret = __ret;
  } else {
    __ret___0 = (long )timeout;
    tmp___17 = vmw_fence_obj_signaled(fence, flags);
    if (! tmp___17) {
      while (1) {
        tmp___15 = get_current();
        __cil_tmp46 = & __wait___0;
        *((unsigned int *)__cil_tmp46) = 0U;
        __cil_tmp47 = (unsigned long )(& __wait___0) + 8UL;
        *((void **)__cil_tmp47) = (void *)tmp___15;
        __cil_tmp48 = (unsigned long )(& __wait___0) + 16UL;
        *((int (**)(wait_queue_t *wait , unsigned int mode , int flags , void *key ))__cil_tmp48) = & autoremove_wake_function;
        __cil_tmp49 = (unsigned long )(& __wait___0) + 24UL;
        __cil_tmp50 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp49) = (struct list_head *)__cil_tmp50;
        __cil_tmp51 = 32;
        __cil_tmp52 = (unsigned long )(& __wait___0) + __cil_tmp51;
        __cil_tmp53 = (unsigned long )(& __wait___0) + 24UL;
        *((struct list_head **)__cil_tmp52) = (struct list_head *)__cil_tmp53;
        while (1) {
          __cil_tmp54 = (unsigned long )fence;
          __cil_tmp55 = __cil_tmp54 + 64UL;
          __cil_tmp56 = (wait_queue_head_t *)__cil_tmp55;
          prepare_to_wait(__cil_tmp56, & __wait___0, 2);
          tmp___16 = vmw_fence_obj_signaled(fence, flags);
          if (tmp___16) {
            goto while_break___2;
          }
          __ret___0 = schedule_timeout(__ret___0);
          if (! __ret___0) {
            goto while_break___2;
          }
        }
        while_break___2: 
        __cil_tmp57 = (unsigned long )fence;
        __cil_tmp58 = __cil_tmp57 + 64UL;
        __cil_tmp59 = (wait_queue_head_t *)__cil_tmp58;
        finish_wait(__cil_tmp59, & __wait___0);
        goto while_break___1;
      }
      while_break___1: ;
    }
    ret = __ret___0;
  }
  vmw_seqno_waiter_remove(dev_priv);
  __cil_tmp60 = ret == 0L;
  __cil_tmp61 = ! __cil_tmp60;
  __cil_tmp62 = ! __cil_tmp61;
  __cil_tmp63 = (long )__cil_tmp62;
  tmp___19 = ldv__builtin_expect(__cil_tmp63, 0L);
  if (tmp___19) {
    ret = -16L;
  } else {
    __cil_tmp64 = ret > 0L;
    __cil_tmp65 = ! __cil_tmp64;
    __cil_tmp66 = ! __cil_tmp65;
    __cil_tmp67 = (long )__cil_tmp66;
    tmp___18 = ldv__builtin_expect(__cil_tmp67, 1L);
    if (tmp___18) {
      ret = 0L;
    }
  }
  return ((int )ret);
}
}
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) 
{ struct vmw_private *dev_priv ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct vmw_fence_manager *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  __cil_tmp3 = (unsigned long )fence;
  __cil_tmp4 = __cil_tmp3 + 8UL;
  __cil_tmp5 = *((struct vmw_fence_manager **)__cil_tmp4);
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = __cil_tmp6 + 8UL;
  dev_priv = *((struct vmw_private **)__cil_tmp7);
  __cil_tmp8 = (uint32_t )1;
  vmw_fifo_ping_host(dev_priv, __cil_tmp8);
  return;
}
}
static void vmw_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_private *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  u32 __cil_tmp12 ;
  uint64_t __cil_tmp13 ;

  {
  __cil_tmp4 = (unsigned long )fence;
  __cil_tmp5 = __cil_tmp4 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp5);
  __cil_tmp6 = (void *)fence;
  kfree(__cil_tmp6);
  __cil_tmp7 = (unsigned long )fman;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  __cil_tmp9 = *((struct vmw_private **)__cil_tmp8);
  tmp___7 = vmw_mem_glob(__cil_tmp9);
  __cil_tmp10 = (unsigned long )fman;
  __cil_tmp11 = __cil_tmp10 + 92UL;
  __cil_tmp12 = *((u32 *)__cil_tmp11);
  __cil_tmp13 = (uint64_t )__cil_tmp12;
  ttm_mem_global_free(tmp___7, __cil_tmp13);
  return;
}
}
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) 
{ struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_fence_obj *fence ;
  int ret ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct vmw_private *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  u32 __cil_tmp18 ;
  uint64_t __cil_tmp19 ;
  bool __cil_tmp20 ;
  bool __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  u32 __cil_tmp40 ;
  uint64_t __cil_tmp41 ;

  {
  __cil_tmp13 = (unsigned long )fman;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  __cil_tmp15 = *((struct vmw_private **)__cil_tmp14);
  tmp___7 = vmw_mem_glob(__cil_tmp15);
  mem_glob = tmp___7;
  __cil_tmp16 = (unsigned long )fman;
  __cil_tmp17 = __cil_tmp16 + 92UL;
  __cil_tmp18 = *((u32 *)__cil_tmp17);
  __cil_tmp19 = (uint64_t )__cil_tmp18;
  __cil_tmp20 = (bool )0;
  __cil_tmp21 = (bool )0;
  ret = ttm_mem_global_alloc(mem_glob, __cil_tmp19, __cil_tmp20, __cil_tmp21);
  __cil_tmp22 = ret != 0;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = (long )__cil_tmp24;
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 0L);
  if (tmp___8) {
    return (ret);
  }
  tmp___9 = kzalloc(104UL, 208U);
  fence = (struct vmw_fence_obj *)tmp___9;
  __cil_tmp26 = (void *)0;
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  __cil_tmp28 = (unsigned long )fence;
  __cil_tmp29 = __cil_tmp28 == __cil_tmp27;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = (long )__cil_tmp31;
  tmp___10 = ldv__builtin_expect(__cil_tmp32, 0L);
  if (tmp___10) {
    ret = -12;
    goto out_no_object;
  }
  ret = vmw_fence_obj_init(fman, fence, seqno, mask, & vmw_fence_destroy);
  __cil_tmp33 = ret != 0;
  __cil_tmp34 = ! __cil_tmp33;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = (long )__cil_tmp35;
  tmp___11 = ldv__builtin_expect(__cil_tmp36, 0L);
  if (tmp___11) {
    goto out_err_init;
  }
  *p_fence = fence;
  return (0);
  out_err_init: 
  __cil_tmp37 = (void *)fence;
  kfree(__cil_tmp37);
  out_no_object: 
  __cil_tmp38 = (unsigned long )fman;
  __cil_tmp39 = __cil_tmp38 + 92UL;
  __cil_tmp40 = *((u32 *)__cil_tmp39);
  __cil_tmp41 = (uint64_t )__cil_tmp40;
  ttm_mem_global_free(mem_glob, __cil_tmp41);
  return (ret);
}
}
static void vmw_user_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *__mptr ;
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp___7 ;
  struct vmw_user_fence *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_fence_obj *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_private *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  u32 __cil_tmp21 ;
  uint64_t __cil_tmp22 ;

  {
  __mptr = fence;
  __cil_tmp6 = (struct vmw_user_fence *)0;
  __cil_tmp7 = (unsigned long )__cil_tmp6;
  __cil_tmp8 = __cil_tmp7 + 64UL;
  __cil_tmp9 = (struct vmw_fence_obj *)__cil_tmp8;
  __cil_tmp10 = (unsigned int )__cil_tmp9;
  __cil_tmp11 = (char *)__mptr;
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
  ufence = (struct vmw_user_fence *)__cil_tmp12;
  __cil_tmp13 = (unsigned long )fence;
  __cil_tmp14 = __cil_tmp13 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp14);
  __cil_tmp15 = (void *)ufence;
  kfree(__cil_tmp15);
  __cil_tmp16 = (unsigned long )fman;
  __cil_tmp17 = __cil_tmp16 + 8UL;
  __cil_tmp18 = *((struct vmw_private **)__cil_tmp17);
  tmp___7 = vmw_mem_glob(__cil_tmp18);
  __cil_tmp19 = (unsigned long )fman;
  __cil_tmp20 = __cil_tmp19 + 88UL;
  __cil_tmp21 = *((u32 *)__cil_tmp20);
  __cil_tmp22 = (uint64_t )__cil_tmp21;
  ttm_mem_global_free(tmp___7, __cil_tmp22);
  return;
}
}
static void vmw_user_fence_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_fence *ufence ;
  struct ttm_base_object *__mptr ;
  struct vmw_fence_obj *fence ;
  struct vmw_user_fence *__cil_tmp6 ;
  struct ttm_base_object *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_fence_obj **__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  base = *p_base;
  __mptr = base;
  __cil_tmp6 = (struct vmw_user_fence *)0;
  __cil_tmp7 = (struct ttm_base_object *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  ufence = (struct vmw_user_fence *)__cil_tmp10;
  __cil_tmp11 = & fence;
  __cil_tmp12 = (unsigned long )ufence;
  __cil_tmp13 = __cil_tmp12 + 64UL;
  *__cil_tmp11 = (struct vmw_fence_obj *)__cil_tmp13;
  __cil_tmp14 = (void *)0;
  *p_base = (struct ttm_base_object *)__cil_tmp14;
  vmw_fence_obj_unreference(& fence);
  return;
}
}
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *tmp___8 ;
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___9 ;
  int ret ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_private *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  u32 __cil_tmp26 ;
  uint64_t __cil_tmp27 ;
  bool __cil_tmp28 ;
  bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_fence_obj *__cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  void *__cil_tmp48 ;
  struct vmw_fence_obj **__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct vmw_fence_obj *__cil_tmp52 ;
  struct ttm_base_object *__cil_tmp53 ;
  bool __cil_tmp54 ;
  enum ttm_object_type __cil_tmp55 ;
  void *__cil_tmp56 ;
  void (*__cil_tmp57)(struct ttm_base_object * , enum ttm_ref_type ref_type ) ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct vmw_fence_obj **__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  u32 __cil_tmp74 ;
  uint64_t __cil_tmp75 ;

  {
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp19 = (unsigned long )tmp___7;
  __cil_tmp20 = __cil_tmp19 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp20);
  __cil_tmp21 = (unsigned long )fman;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  __cil_tmp23 = *((struct vmw_private **)__cil_tmp22);
  tmp___9 = vmw_mem_glob(__cil_tmp23);
  mem_glob = tmp___9;
  __cil_tmp24 = (unsigned long )fman;
  __cil_tmp25 = __cil_tmp24 + 88UL;
  __cil_tmp26 = *((u32 *)__cil_tmp25);
  __cil_tmp27 = (uint64_t )__cil_tmp26;
  __cil_tmp28 = (bool )0;
  __cil_tmp29 = (bool )0;
  ret = ttm_mem_global_alloc(mem_glob, __cil_tmp27, __cil_tmp28, __cil_tmp29);
  __cil_tmp30 = ret != 0;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___10 = ldv__builtin_expect(__cil_tmp33, 0L);
  if (tmp___10) {
    return (ret);
  }
  tmp___11 = kzalloc(168UL, 208U);
  ufence = (struct vmw_user_fence *)tmp___11;
  __cil_tmp34 = (void *)0;
  __cil_tmp35 = (unsigned long )__cil_tmp34;
  __cil_tmp36 = (unsigned long )ufence;
  __cil_tmp37 = __cil_tmp36 == __cil_tmp35;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = (long )__cil_tmp39;
  tmp___12 = ldv__builtin_expect(__cil_tmp40, 0L);
  if (tmp___12) {
    ret = -12;
    goto out_no_object;
  }
  __cil_tmp41 = (unsigned long )ufence;
  __cil_tmp42 = __cil_tmp41 + 64UL;
  __cil_tmp43 = (struct vmw_fence_obj *)__cil_tmp42;
  ret = vmw_fence_obj_init(fman, __cil_tmp43, seqno, mask, & vmw_user_fence_destroy);
  __cil_tmp44 = ret != 0;
  __cil_tmp45 = ! __cil_tmp44;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = (long )__cil_tmp46;
  tmp___13 = ldv__builtin_expect(__cil_tmp47, 0L);
  if (tmp___13) {
    __cil_tmp48 = (void *)ufence;
    kfree(__cil_tmp48);
    goto out_no_object;
  }
  __cil_tmp49 = & tmp___8;
  __cil_tmp50 = (unsigned long )ufence;
  __cil_tmp51 = __cil_tmp50 + 64UL;
  __cil_tmp52 = (struct vmw_fence_obj *)__cil_tmp51;
  *__cil_tmp49 = vmw_fence_obj_reference(__cil_tmp52);
  __cil_tmp53 = (struct ttm_base_object *)ufence;
  __cil_tmp54 = (bool )0;
  __cil_tmp55 = (enum ttm_object_type )259;
  __cil_tmp56 = (void *)0;
  __cil_tmp57 = (void (*)(struct ttm_base_object * , enum ttm_ref_type ref_type ))__cil_tmp56;
  ret = ttm_base_object_init(tfile, __cil_tmp53, __cil_tmp54, __cil_tmp55, & vmw_user_fence_base_release,
                             __cil_tmp57);
  __cil_tmp58 = ret != 0;
  __cil_tmp59 = ! __cil_tmp58;
  __cil_tmp60 = ! __cil_tmp59;
  __cil_tmp61 = (long )__cil_tmp60;
  tmp___14 = ldv__builtin_expect(__cil_tmp61, 0L);
  if (tmp___14) {
    vmw_fence_obj_unreference(& tmp___8);
    goto out_err;
  }
  __cil_tmp62 = (unsigned long )ufence;
  __cil_tmp63 = __cil_tmp62 + 64UL;
  *p_fence = (struct vmw_fence_obj *)__cil_tmp63;
  __cil_tmp64 = 16;
  __cil_tmp65 = __cil_tmp64;
  __cil_tmp66 = (unsigned long )ufence;
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
  __cil_tmp68 = *((unsigned long *)__cil_tmp67);
  *p_handle = (uint32_t )__cil_tmp68;
  return (0);
  out_err: 
  __cil_tmp69 = & tmp___8;
  __cil_tmp70 = (unsigned long )ufence;
  __cil_tmp71 = __cil_tmp70 + 64UL;
  *__cil_tmp69 = (struct vmw_fence_obj *)__cil_tmp71;
  vmw_fence_obj_unreference(& tmp___8);
  out_no_object: 
  __cil_tmp72 = (unsigned long )fman;
  __cil_tmp73 = __cil_tmp72 + 88UL;
  __cil_tmp74 = *((u32 *)__cil_tmp73);
  __cil_tmp75 = (uint64_t )__cil_tmp74;
  ttm_mem_global_free(mem_glob, __cil_tmp75);
  return (ret);
}
}
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  struct list_head action_list ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_fence_obj *fence ;
  struct list_head *__mptr ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct vmw_fence_obj *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  struct kref *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  spinlock_t *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  bool __cil_tmp42 ;
  bool __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  wait_queue_head_t *__cil_tmp61 ;
  void *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  spinlock_t *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct list_head *__cil_tmp68 ;
  struct list_head *__cil_tmp69 ;
  long __cil_tmp70 ;
  struct kref *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  spinlock_t *__cil_tmp74 ;

  {
  while (1) {

    while (1) {
      __cil_tmp15 = (unsigned long )fman;
      __cil_tmp16 = __cil_tmp15 + 16UL;
      __cil_tmp17 = (spinlock_t *)__cil_tmp16;
      tmp___7 = spinlock_check(__cil_tmp17);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp18 = (unsigned long )fman;
  __cil_tmp19 = __cil_tmp18 + 100UL;
  *((bool *)__cil_tmp19) = (bool )1;
  while (1) {
    __cil_tmp20 = (unsigned long )fman;
    __cil_tmp21 = __cil_tmp20 + 40UL;
    __cil_tmp22 = (struct list_head *)__cil_tmp21;
    __cil_tmp23 = __cil_tmp22;
    tmp___12 = list_empty(__cil_tmp23);
    if (tmp___12) {
      goto while_break___1;
    }
    __cil_tmp24 = 48;
    __cil_tmp25 = (unsigned long )fman;
    __cil_tmp26 = __cil_tmp25 + __cil_tmp24;
    __cil_tmp27 = *((struct list_head **)__cil_tmp26);
    __mptr = __cil_tmp27;
    __cil_tmp28 = (struct vmw_fence_obj *)0;
    __cil_tmp29 = (unsigned long )__cil_tmp28;
    __cil_tmp30 = __cil_tmp29 + 16UL;
    __cil_tmp31 = (struct list_head *)__cil_tmp30;
    __cil_tmp32 = (unsigned int )__cil_tmp31;
    __cil_tmp33 = (char *)__mptr;
    __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
    fence = (struct vmw_fence_obj *)__cil_tmp34;
    __cil_tmp35 = (struct kref *)fence;
    kref_get(__cil_tmp35);
    __cil_tmp36 = (unsigned long )fman;
    __cil_tmp37 = __cil_tmp36 + 16UL;
    __cil_tmp38 = (spinlock_t *)__cil_tmp37;
    spin_unlock_irq(__cil_tmp38);
    __cil_tmp39 = (unsigned long )fence;
    __cil_tmp40 = __cil_tmp39 + 36UL;
    __cil_tmp41 = *((uint32_t *)__cil_tmp40);
    __cil_tmp42 = (bool )0;
    __cil_tmp43 = (bool )0;
    ret = vmw_fence_obj_wait(fence, __cil_tmp41, __cil_tmp42, __cil_tmp43, 1250UL);
    __cil_tmp44 = ret != 0;
    __cil_tmp45 = ! __cil_tmp44;
    __cil_tmp46 = ! __cil_tmp45;
    __cil_tmp47 = (long )__cil_tmp46;
    tmp___8 = ldv__builtin_expect(__cil_tmp47, 0L);
    if (tmp___8) {
      __cil_tmp48 = (unsigned long )fence;
      __cil_tmp49 = __cil_tmp48 + 16UL;
      __cil_tmp50 = (struct list_head *)__cil_tmp49;
      list_del_init(__cil_tmp50);
      __cil_tmp51 = (unsigned long )fence;
      __cil_tmp52 = __cil_tmp51 + 32UL;
      __cil_tmp53 = (unsigned long )fence;
      __cil_tmp54 = __cil_tmp53 + 32UL;
      __cil_tmp55 = *((uint32_t *)__cil_tmp54);
      *((uint32_t *)__cil_tmp52) = __cil_tmp55 | 1U;
      INIT_LIST_HEAD(& action_list);
      __cil_tmp56 = (unsigned long )fence;
      __cil_tmp57 = __cil_tmp56 + 40UL;
      __cil_tmp58 = (struct list_head *)__cil_tmp57;
      list_splice_init(__cil_tmp58, & action_list);
      vmw_fences_perform_actions(fman, & action_list);
      __cil_tmp59 = (unsigned long )fence;
      __cil_tmp60 = __cil_tmp59 + 64UL;
      __cil_tmp61 = (wait_queue_head_t *)__cil_tmp60;
      __cil_tmp62 = (void *)0;
      __wake_up(__cil_tmp61, 3U, 0, __cil_tmp62);
    }
    __cil_tmp63 = (unsigned long )fman;
    __cil_tmp64 = __cil_tmp63 + 16UL;
    __cil_tmp65 = (spinlock_t *)__cil_tmp64;
    spin_lock_irq(__cil_tmp65);
    while (1) {
      __cil_tmp66 = (unsigned long )fence;
      __cil_tmp67 = __cil_tmp66 + 16UL;
      __cil_tmp68 = (struct list_head *)__cil_tmp67;
      __cil_tmp69 = __cil_tmp68;
      tmp___9 = list_empty(__cil_tmp69);
      if (tmp___9) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      __cil_tmp70 = (long )tmp___10;
      tmp___11 = ldv__builtin_expect(__cil_tmp70, 0L);
      if (tmp___11) {
        while (1) {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b - 2b, %c0 - 2b\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                               "i" (666), "i" (12UL));
          while (1) {

          }

          goto while_break___3;
        }
        while_break___3: ;
      }
      goto while_break___2;
    }
    while_break___2: 
    __cil_tmp71 = (struct kref *)fence;
    kref_put(__cil_tmp71, & vmw_fence_obj_destroy_locked);
  }
  while_break___1: 
  __cil_tmp72 = (unsigned long )fman;
  __cil_tmp73 = __cil_tmp72 + 16UL;
  __cil_tmp74 = (spinlock_t *)__cil_tmp73;
  spin_unlock_irqrestore(__cil_tmp74, irq_flags);
  return;
}
}
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  spinlock_t *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;

  {
  while (1) {

    while (1) {
      __cil_tmp6 = (unsigned long )fman;
      __cil_tmp7 = __cil_tmp6 + 16UL;
      __cil_tmp8 = (spinlock_t *)__cil_tmp7;
      tmp___7 = spinlock_check(__cil_tmp8);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp9 = (unsigned long )fman;
  __cil_tmp10 = __cil_tmp9 + 100UL;
  *((bool *)__cil_tmp10) = (bool )0;
  __cil_tmp11 = (unsigned long )fman;
  __cil_tmp12 = __cil_tmp11 + 16UL;
  __cil_tmp13 = (spinlock_t *)__cil_tmp12;
  spin_unlock_irqrestore(__cil_tmp13, irq_flags);
  return;
}
}
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_wait_arg *arg ;
  unsigned long timeout ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  int ret ;
  uint64_t wait_timeout ;
  long tmp___8 ;
  struct ttm_base_object *__mptr ;
  bool tmp___10 ;
  int tmp___11 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  uint64_t __cil_tmp25 ;
  uint64_t __cil_tmp26 ;
  uint64_t __cil_tmp27 ;
  uint64_t __cil_tmp28 ;
  uint64_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  uint64_t __cil_tmp37 ;
  struct ttm_base_object **__cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct ttm_base_object **__cil_tmp42 ;
  struct ttm_base_object *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct ttm_base_object **__cil_tmp51 ;
  struct ttm_base_object *__cil_tmp52 ;
  struct vmw_user_fence *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  struct vmw_user_fence *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  uint64_t __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  long __cil_tmp65 ;
  long __cil_tmp66 ;
  long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int32_t __cil_tmp70 ;
  uint32_t __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  uint64_t __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  int32_t __cil_tmp78 ;
  uint32_t __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  int32_t __cil_tmp82 ;
  bool __cil_tmp83 ;
  bool __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  int32_t __cil_tmp87 ;
  uint32_t __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  enum ttm_ref_type __cil_tmp90 ;

  {
  arg = (struct drm_vmw_fence_wait_arg *)data;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp21 = (unsigned long )tmp___7;
  __cil_tmp22 = __cil_tmp21 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp22);
  __cil_tmp23 = (unsigned long )arg;
  __cil_tmp24 = __cil_tmp23 + 16UL;
  __cil_tmp25 = *((uint64_t *)__cil_tmp24);
  wait_timeout = __cil_tmp25 * 250ULL;
  __cil_tmp26 = wait_timeout >> 26;
  __cil_tmp27 = wait_timeout >> 24;
  __cil_tmp28 = wait_timeout >> 20;
  __cil_tmp29 = __cil_tmp28 + __cil_tmp27;
  wait_timeout = __cil_tmp29 - __cil_tmp26;
  __cil_tmp30 = (unsigned long )arg;
  __cil_tmp31 = __cil_tmp30 + 4UL;
  __cil_tmp32 = *((int32_t *)__cil_tmp31);
  if (! __cil_tmp32) {
    __cil_tmp33 = (unsigned long )arg;
    __cil_tmp34 = __cil_tmp33 + 4UL;
    *((int32_t *)__cil_tmp34) = 1;
    __cil_tmp35 = (unsigned long )arg;
    __cil_tmp36 = __cil_tmp35 + 8UL;
    __cil_tmp37 = (uint64_t )jiffies;
    *((uint64_t *)__cil_tmp36) = __cil_tmp37 + wait_timeout;
  }
  __cil_tmp38 = & base;
  __cil_tmp39 = *((uint32_t *)arg);
  *__cil_tmp38 = ttm_base_object_lookup(tfile, __cil_tmp39);
  __cil_tmp40 = (void *)0;
  __cil_tmp41 = (unsigned long )__cil_tmp40;
  __cil_tmp42 = & base;
  __cil_tmp43 = *__cil_tmp42;
  __cil_tmp44 = (unsigned long )__cil_tmp43;
  __cil_tmp45 = __cil_tmp44 == __cil_tmp41;
  __cil_tmp46 = ! __cil_tmp45;
  __cil_tmp47 = ! __cil_tmp46;
  __cil_tmp48 = (long )__cil_tmp47;
  tmp___8 = ldv__builtin_expect(__cil_tmp48, 0L);
  if (tmp___8) {
    __cil_tmp49 = *((uint32_t *)arg);
    __cil_tmp50 = (unsigned long )__cil_tmp49;
    printk("<3>Wait invalid fence object handle 0x%08lx.\n", __cil_tmp50);
    return (-22);
  }
  __cil_tmp51 = & base;
  __cil_tmp52 = *__cil_tmp51;
  __mptr = __cil_tmp52;
  __cil_tmp53 = (struct vmw_user_fence *)0;
  __cil_tmp54 = (struct ttm_base_object *)__cil_tmp53;
  __cil_tmp55 = (unsigned int )__cil_tmp54;
  __cil_tmp56 = (char *)__mptr;
  __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
  __cil_tmp58 = (struct vmw_user_fence *)__cil_tmp57;
  __cil_tmp59 = (unsigned long )__cil_tmp58;
  __cil_tmp60 = __cil_tmp59 + 64UL;
  fence = (struct vmw_fence_obj *)__cil_tmp60;
  timeout = (unsigned long )jiffies;
  __cil_tmp61 = (unsigned long )arg;
  __cil_tmp62 = __cil_tmp61 + 8UL;
  __cil_tmp63 = *((uint64_t *)__cil_tmp62);
  __cil_tmp64 = (unsigned long )__cil_tmp63;
  __cil_tmp65 = (long )__cil_tmp64;
  __cil_tmp66 = (long )timeout;
  __cil_tmp67 = __cil_tmp66 - __cil_tmp65;
  if (__cil_tmp67 >= 0L) {
    __cil_tmp68 = (unsigned long )arg;
    __cil_tmp69 = __cil_tmp68 + 28UL;
    __cil_tmp70 = *((int32_t *)__cil_tmp69);
    __cil_tmp71 = (uint32_t )__cil_tmp70;
    tmp___10 = vmw_fence_obj_signaled(fence, __cil_tmp71);
    if (tmp___10) {
      ret = 0;
    } else {
      ret = -16;
    }
    goto out;
  }
  __cil_tmp72 = (unsigned long )arg;
  __cil_tmp73 = __cil_tmp72 + 8UL;
  __cil_tmp74 = *((uint64_t *)__cil_tmp73);
  __cil_tmp75 = (unsigned long )__cil_tmp74;
  timeout = __cil_tmp75 - timeout;
  __cil_tmp76 = (unsigned long )arg;
  __cil_tmp77 = __cil_tmp76 + 28UL;
  __cil_tmp78 = *((int32_t *)__cil_tmp77);
  __cil_tmp79 = (uint32_t )__cil_tmp78;
  __cil_tmp80 = (unsigned long )arg;
  __cil_tmp81 = __cil_tmp80 + 24UL;
  __cil_tmp82 = *((int32_t *)__cil_tmp81);
  __cil_tmp83 = (bool )__cil_tmp82;
  __cil_tmp84 = (bool )1;
  ret = vmw_fence_obj_wait(fence, __cil_tmp79, __cil_tmp83, __cil_tmp84, timeout);
  out: 
  ttm_base_object_unref(& base);
  if (ret == 0) {
    __cil_tmp85 = (unsigned long )arg;
    __cil_tmp86 = __cil_tmp85 + 32UL;
    __cil_tmp87 = *((int32_t *)__cil_tmp86);
    if (__cil_tmp87 & 1) {
      __cil_tmp88 = *((uint32_t *)arg);
      __cil_tmp89 = (unsigned long )__cil_tmp88;
      __cil_tmp90 = (enum ttm_ref_type )0;
      tmp___11 = ttm_ref_object_base_unref(tfile, __cil_tmp89, __cil_tmp90);
      return (tmp___11);
    }
  }
  return (ret);
}
}
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_signaled_arg *arg ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___7 ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___8 ;
  long tmp___9 ;
  struct ttm_base_object *__mptr ;
  bool tmp___10 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct ttm_base_object **__cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct ttm_base_object **__cil_tmp21 ;
  struct ttm_base_object *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct ttm_base_object **__cil_tmp30 ;
  struct ttm_base_object *__cil_tmp31 ;
  struct vmw_user_fence *__cil_tmp32 ;
  struct ttm_base_object *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  struct vmw_user_fence *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  spinlock_t *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  spinlock_t *__cil_tmp60 ;

  {
  arg = (struct drm_vmw_fence_signaled_arg *)data;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp15 = (unsigned long )tmp___7;
  __cil_tmp16 = __cil_tmp15 + 8UL;
  tfile = *((struct ttm_object_file **)__cil_tmp16);
  tmp___8 = vmw_priv(dev);
  dev_priv = tmp___8;
  __cil_tmp17 = & base;
  __cil_tmp18 = *((uint32_t *)arg);
  *__cil_tmp17 = ttm_base_object_lookup(tfile, __cil_tmp18);
  __cil_tmp19 = (void *)0;
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = & base;
  __cil_tmp22 = *__cil_tmp21;
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = __cil_tmp23 == __cil_tmp20;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = (long )__cil_tmp26;
  tmp___9 = ldv__builtin_expect(__cil_tmp27, 0L);
  if (tmp___9) {
    __cil_tmp28 = *((uint32_t *)arg);
    __cil_tmp29 = (unsigned long )__cil_tmp28;
    printk("<3>Fence signaled invalid fence object handle 0x%08lx.\n", __cil_tmp29);
    return (-22);
  }
  __cil_tmp30 = & base;
  __cil_tmp31 = *__cil_tmp30;
  __mptr = __cil_tmp31;
  __cil_tmp32 = (struct vmw_user_fence *)0;
  __cil_tmp33 = (struct ttm_base_object *)__cil_tmp32;
  __cil_tmp34 = (unsigned int )__cil_tmp33;
  __cil_tmp35 = (char *)__mptr;
  __cil_tmp36 = __cil_tmp35 - __cil_tmp34;
  __cil_tmp37 = (struct vmw_user_fence *)__cil_tmp36;
  __cil_tmp38 = (unsigned long )__cil_tmp37;
  __cil_tmp39 = __cil_tmp38 + 64UL;
  fence = (struct vmw_fence_obj *)__cil_tmp39;
  __cil_tmp40 = (unsigned long )fence;
  __cil_tmp41 = __cil_tmp40 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp41);
  __cil_tmp42 = (unsigned long )arg;
  __cil_tmp43 = __cil_tmp42 + 4UL;
  __cil_tmp44 = *((uint32_t *)__cil_tmp43);
  tmp___10 = vmw_fence_obj_signaled(fence, __cil_tmp44);
  __cil_tmp45 = (unsigned long )arg;
  __cil_tmp46 = __cil_tmp45 + 8UL;
  *((int32_t *)__cil_tmp46) = (int32_t )tmp___10;
  __cil_tmp47 = (unsigned long )fman;
  __cil_tmp48 = __cil_tmp47 + 16UL;
  __cil_tmp49 = (spinlock_t *)__cil_tmp48;
  spin_lock_irq(__cil_tmp49);
  __cil_tmp50 = (unsigned long )arg;
  __cil_tmp51 = __cil_tmp50 + 16UL;
  __cil_tmp52 = (unsigned long )fence;
  __cil_tmp53 = __cil_tmp52 + 32UL;
  *((uint32_t *)__cil_tmp51) = *((uint32_t *)__cil_tmp53);
  __cil_tmp54 = (unsigned long )arg;
  __cil_tmp55 = __cil_tmp54 + 12UL;
  __cil_tmp56 = (unsigned long )dev_priv;
  __cil_tmp57 = __cil_tmp56 + 2980UL;
  *((uint32_t *)__cil_tmp55) = *((uint32_t *)__cil_tmp57);
  __cil_tmp58 = (unsigned long )fman;
  __cil_tmp59 = __cil_tmp58 + 16UL;
  __cil_tmp60 = (spinlock_t *)__cil_tmp59;
  spin_unlock_irq(__cil_tmp60);
  ttm_base_object_unref(& base);
  return (0);
}
}
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_arg *arg ;
  struct vmw_fpriv *tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct ttm_object_file *__cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  enum ttm_ref_type __cil_tmp12 ;

  {
  arg = (struct drm_vmw_fence_arg *)data;
  tmp___7 = vmw_fpriv(file_priv);
  __cil_tmp7 = (unsigned long )tmp___7;
  __cil_tmp8 = __cil_tmp7 + 8UL;
  __cil_tmp9 = *((struct ttm_object_file **)__cil_tmp8);
  __cil_tmp10 = *((uint32_t *)arg);
  __cil_tmp11 = (unsigned long )__cil_tmp10;
  __cil_tmp12 = (enum ttm_ref_type )0;
  tmp___8 = ttm_ref_object_base_unref(__cil_tmp9, __cil_tmp11, __cil_tmp12);
  return (tmp___8);
}
}
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) 
{ struct vmw_event_fence_action *eaction ;
  struct drm_pending_event *event ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  struct list_head *__mptr ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct vmw_event_fence_action *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  spinlock_t *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  void (*__cil_tmp36)(struct drm_pending_event *event ) ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  spinlock_t *__cil_tmp39 ;

  {
  while (1) {

    while (1) {

      while (1) {
        __cil_tmp11 = (unsigned long )fman;
        __cil_tmp12 = __cil_tmp11 + 16UL;
        __cil_tmp13 = (spinlock_t *)__cil_tmp12;
        tmp___7 = spinlock_check(__cil_tmp13);
        irq_flags = _raw_spin_lock_irqsave(tmp___7);
        goto while_break___1;
      }
      while_break___1: ;
      goto while_break___0;
    }
    while_break___0: 
    __cil_tmp14 = event_list;
    tmp___8 = list_empty(__cil_tmp14);
    if (tmp___8) {
      goto out_unlock;
    }
    __cil_tmp15 = *((struct list_head **)event_list);
    __mptr = __cil_tmp15;
    __cil_tmp16 = (struct vmw_event_fence_action *)0;
    __cil_tmp17 = (unsigned long )__cil_tmp16;
    __cil_tmp18 = __cil_tmp17 + 40UL;
    __cil_tmp19 = (struct list_head *)__cil_tmp18;
    __cil_tmp20 = (unsigned int )__cil_tmp19;
    __cil_tmp21 = (char *)__mptr;
    __cil_tmp22 = __cil_tmp21 - __cil_tmp20;
    eaction = (struct vmw_event_fence_action *)__cil_tmp22;
    __cil_tmp23 = (unsigned long )eaction;
    __cil_tmp24 = __cil_tmp23 + 40UL;
    __cil_tmp25 = (struct list_head *)__cil_tmp24;
    list_del_init(__cil_tmp25);
    __cil_tmp26 = (unsigned long )eaction;
    __cil_tmp27 = __cil_tmp26 + 56UL;
    event = *((struct drm_pending_event **)__cil_tmp27);
    __cil_tmp28 = (unsigned long )eaction;
    __cil_tmp29 = __cil_tmp28 + 56UL;
    __cil_tmp30 = (void *)0;
    *((struct drm_pending_event **)__cil_tmp29) = (struct drm_pending_event *)__cil_tmp30;
    __cil_tmp31 = (unsigned long )fman;
    __cil_tmp32 = __cil_tmp31 + 16UL;
    __cil_tmp33 = (spinlock_t *)__cil_tmp32;
    spin_unlock_irqrestore(__cil_tmp33, irq_flags);
    __cil_tmp34 = (unsigned long )event;
    __cil_tmp35 = __cil_tmp34 + 40UL;
    __cil_tmp36 = *((void (**)(struct drm_pending_event *event ))__cil_tmp35);
    (*__cil_tmp36)(event);
  }

  out_unlock: 
  __cil_tmp37 = (unsigned long )fman;
  __cil_tmp38 = __cil_tmp37 + 16UL;
  __cil_tmp39 = (spinlock_t *)__cil_tmp38;
  spin_unlock_irqrestore(__cil_tmp39, irq_flags);
  return;
}
}
static void vmw_event_fence_action_seq_passed(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action *__mptr ;
  struct drm_device *dev ;
  struct drm_pending_event *event ;
  struct drm_file *file_priv ;
  unsigned long irq_flags ;
  long tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  struct timeval tv ;
  long tmp___9 ;
  struct vmw_event_fence_action *__cil_tmp14 ;
  struct vmw_fence_action *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  spinlock_t *__cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  uint32_t *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  uint32_t *__cil_tmp47 ;
  struct timeval *__cil_tmp48 ;
  __kernel_time_t __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  uint32_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  __kernel_suseconds_t __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  struct drm_pending_event *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  struct list_head *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct list_head *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  void *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  wait_queue_head_t *__cil_tmp72 ;
  void *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  spinlock_t *__cil_tmp76 ;

  {
  __mptr = action;
  __cil_tmp14 = (struct vmw_event_fence_action *)0;
  __cil_tmp15 = (struct vmw_fence_action *)__cil_tmp14;
  __cil_tmp16 = (unsigned int )__cil_tmp15;
  __cil_tmp17 = (char *)__mptr;
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
  eaction = (struct vmw_event_fence_action *)__cil_tmp18;
  __cil_tmp19 = (unsigned long )eaction;
  __cil_tmp20 = __cil_tmp19 + 72UL;
  dev = *((struct drm_device **)__cil_tmp20);
  __cil_tmp21 = (unsigned long )eaction;
  __cil_tmp22 = __cil_tmp21 + 56UL;
  event = *((struct drm_pending_event **)__cil_tmp22);
  __cil_tmp23 = (void *)0;
  __cil_tmp24 = (unsigned long )__cil_tmp23;
  __cil_tmp25 = (unsigned long )event;
  __cil_tmp26 = __cil_tmp25 == __cil_tmp24;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = ! __cil_tmp27;
  __cil_tmp29 = (long )__cil_tmp28;
  tmp___7 = ldv__builtin_expect(__cil_tmp29, 0L);
  if (tmp___7) {
    return;
  }
  __cil_tmp30 = (unsigned long )event;
  __cil_tmp31 = __cil_tmp30 + 24UL;
  file_priv = *((struct drm_file **)__cil_tmp31);
  while (1) {

    while (1) {
      __cil_tmp32 = (unsigned long )dev;
      __cil_tmp33 = __cil_tmp32 + 872UL;
      __cil_tmp34 = (spinlock_t *)__cil_tmp33;
      tmp___8 = spinlock_check(__cil_tmp34);
      irq_flags = _raw_spin_lock_irqsave(tmp___8);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp35 = (void *)0;
  __cil_tmp36 = (unsigned long )__cil_tmp35;
  __cil_tmp37 = (unsigned long )eaction;
  __cil_tmp38 = __cil_tmp37 + 80UL;
  __cil_tmp39 = *((uint32_t **)__cil_tmp38);
  __cil_tmp40 = (unsigned long )__cil_tmp39;
  __cil_tmp41 = __cil_tmp40 != __cil_tmp36;
  __cil_tmp42 = ! __cil_tmp41;
  __cil_tmp43 = ! __cil_tmp42;
  __cil_tmp44 = (long )__cil_tmp43;
  tmp___9 = ldv__builtin_expect(__cil_tmp44, 1L);
  if (tmp___9) {
    do_gettimeofday(& tv);
    __cil_tmp45 = (unsigned long )eaction;
    __cil_tmp46 = __cil_tmp45 + 80UL;
    __cil_tmp47 = *((uint32_t **)__cil_tmp46);
    __cil_tmp48 = & tv;
    __cil_tmp49 = *((__kernel_time_t *)__cil_tmp48);
    *__cil_tmp47 = (uint32_t )__cil_tmp49;
    __cil_tmp50 = (unsigned long )eaction;
    __cil_tmp51 = __cil_tmp50 + 88UL;
    __cil_tmp52 = *((uint32_t **)__cil_tmp51);
    __cil_tmp53 = (unsigned long )(& tv) + 8UL;
    __cil_tmp54 = *((__kernel_suseconds_t *)__cil_tmp53);
    *__cil_tmp52 = (uint32_t )__cil_tmp54;
  }
  __cil_tmp55 = (unsigned long )eaction;
  __cil_tmp56 = __cil_tmp55 + 40UL;
  __cil_tmp57 = (struct list_head *)__cil_tmp56;
  list_del_init(__cil_tmp57);
  __cil_tmp58 = (unsigned long )eaction;
  __cil_tmp59 = __cil_tmp58 + 56UL;
  __cil_tmp60 = *((struct drm_pending_event **)__cil_tmp59);
  __cil_tmp61 = (unsigned long )__cil_tmp60;
  __cil_tmp62 = __cil_tmp61 + 8UL;
  __cil_tmp63 = (struct list_head *)__cil_tmp62;
  __cil_tmp64 = (unsigned long )file_priv;
  __cil_tmp65 = __cil_tmp64 + 216UL;
  __cil_tmp66 = (struct list_head *)__cil_tmp65;
  list_add_tail(__cil_tmp63, __cil_tmp66);
  __cil_tmp67 = (unsigned long )eaction;
  __cil_tmp68 = __cil_tmp67 + 56UL;
  __cil_tmp69 = (void *)0;
  *((struct drm_pending_event **)__cil_tmp68) = (struct drm_pending_event *)__cil_tmp69;
  __cil_tmp70 = (unsigned long )file_priv;
  __cil_tmp71 = __cil_tmp70 + 176UL;
  __cil_tmp72 = (wait_queue_head_t *)__cil_tmp71;
  __cil_tmp73 = (void *)0;
  __wake_up(__cil_tmp72, 3U, 0, __cil_tmp73);
  __cil_tmp74 = (unsigned long )dev;
  __cil_tmp75 = __cil_tmp74 + 872UL;
  __cil_tmp76 = (spinlock_t *)__cil_tmp75;
  spin_unlock_irqrestore(__cil_tmp76, irq_flags);
  return;
}
}
static void vmw_event_fence_action_cleanup(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp___7 ;
  struct vmw_event_fence_action *__cil_tmp9 ;
  struct vmw_fence_action *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_fence_obj *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  spinlock_t *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_fence_obj **__cil_tmp30 ;
  void *__cil_tmp31 ;

  {
  __mptr = action;
  __cil_tmp9 = (struct vmw_event_fence_action *)0;
  __cil_tmp10 = (struct vmw_fence_action *)__cil_tmp9;
  __cil_tmp11 = (unsigned int )__cil_tmp10;
  __cil_tmp12 = (char *)__mptr;
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
  eaction = (struct vmw_event_fence_action *)__cil_tmp13;
  __cil_tmp14 = (unsigned long )eaction;
  __cil_tmp15 = __cil_tmp14 + 64UL;
  __cil_tmp16 = *((struct vmw_fence_obj **)__cil_tmp15);
  __cil_tmp17 = (unsigned long )__cil_tmp16;
  __cil_tmp18 = __cil_tmp17 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp18);
  while (1) {

    while (1) {
      __cil_tmp19 = (unsigned long )fman;
      __cil_tmp20 = __cil_tmp19 + 16UL;
      __cil_tmp21 = (spinlock_t *)__cil_tmp20;
      tmp___7 = spinlock_check(__cil_tmp21);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp22 = (unsigned long )eaction;
  __cil_tmp23 = __cil_tmp22 + 40UL;
  __cil_tmp24 = (struct list_head *)__cil_tmp23;
  list_del(__cil_tmp24);
  __cil_tmp25 = (unsigned long )fman;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  __cil_tmp27 = (spinlock_t *)__cil_tmp26;
  spin_unlock_irqrestore(__cil_tmp27, irq_flags);
  __cil_tmp28 = (unsigned long )eaction;
  __cil_tmp29 = __cil_tmp28 + 64UL;
  __cil_tmp30 = (struct vmw_fence_obj **)__cil_tmp29;
  vmw_fence_obj_unreference(__cil_tmp30);
  __cil_tmp31 = (void *)eaction;
  kfree(__cil_tmp31);
  return;
}
}
void vmw_fence_obj_add_action(struct vmw_fence_obj *fence , struct vmw_fence_action *action ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  bool run_update ;
  raw_spinlock_t *tmp___7 ;
  struct list_head action_list ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct mutex *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  spinlock_t *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  enum vmw_action_type __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  enum vmw_action_type __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  spinlock_t *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  bool __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct vmw_private *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  struct mutex *__cil_tmp54 ;

  {
  __cil_tmp10 = (unsigned long )fence;
  __cil_tmp11 = __cil_tmp10 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp11);
  run_update = (bool )0;
  __cil_tmp12 = (unsigned long )fman;
  __cil_tmp13 = __cil_tmp12 + 128UL;
  __cil_tmp14 = (struct mutex *)__cil_tmp13;
  mutex_lock(__cil_tmp14);
  while (1) {

    while (1) {
      __cil_tmp15 = (unsigned long )fman;
      __cil_tmp16 = __cil_tmp15 + 16UL;
      __cil_tmp17 = (spinlock_t *)__cil_tmp16;
      tmp___7 = spinlock_check(__cil_tmp17);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp18 = (unsigned long )action;
  __cil_tmp19 = __cil_tmp18 + 16UL;
  __cil_tmp20 = *((enum vmw_action_type *)__cil_tmp19);
  __cil_tmp21 = (unsigned long )__cil_tmp20 * 4UL;
  __cil_tmp22 = 120UL + __cil_tmp21;
  __cil_tmp23 = (unsigned long )fman;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = (unsigned long )action;
  __cil_tmp26 = __cil_tmp25 + 16UL;
  __cil_tmp27 = *((enum vmw_action_type *)__cil_tmp26);
  __cil_tmp28 = (unsigned long )__cil_tmp27 * 4UL;
  __cil_tmp29 = 120UL + __cil_tmp28;
  __cil_tmp30 = (unsigned long )fman;
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
  __cil_tmp32 = *((uint32_t *)__cil_tmp31);
  *((uint32_t *)__cil_tmp24) = __cil_tmp32 + 1U;
  __cil_tmp33 = (unsigned long )fence;
  __cil_tmp34 = __cil_tmp33 + 32UL;
  __cil_tmp35 = *((uint32_t *)__cil_tmp34);
  if (__cil_tmp35 & 1U) {
    INIT_LIST_HEAD(& action_list);
    __cil_tmp36 = (struct list_head *)action;
    list_add_tail(__cil_tmp36, & action_list);
    vmw_fences_perform_actions(fman, & action_list);
  } else {
    __cil_tmp37 = (struct list_head *)action;
    __cil_tmp38 = (unsigned long )fence;
    __cil_tmp39 = __cil_tmp38 + 40UL;
    __cil_tmp40 = (struct list_head *)__cil_tmp39;
    list_add_tail(__cil_tmp37, __cil_tmp40);
    run_update = vmw_fence_goal_check_locked(fence);
  }
  __cil_tmp41 = (unsigned long )fman;
  __cil_tmp42 = __cil_tmp41 + 16UL;
  __cil_tmp43 = (spinlock_t *)__cil_tmp42;
  spin_unlock_irqrestore(__cil_tmp43, irq_flags);
  if (run_update) {
    __cil_tmp44 = (unsigned long )fman;
    __cil_tmp45 = __cil_tmp44 + 200UL;
    __cil_tmp46 = *((bool *)__cil_tmp45);
    if (! __cil_tmp46) {
      __cil_tmp47 = (unsigned long )fman;
      __cil_tmp48 = __cil_tmp47 + 200UL;
      *((bool *)__cil_tmp48) = (bool )1;
      __cil_tmp49 = (unsigned long )fman;
      __cil_tmp50 = __cil_tmp49 + 8UL;
      __cil_tmp51 = *((struct vmw_private **)__cil_tmp50);
      vmw_goal_waiter_add(__cil_tmp51);
    }
    vmw_fences_update(fman);
  }
  __cil_tmp52 = (unsigned long )fman;
  __cil_tmp53 = __cil_tmp52 + 128UL;
  __cil_tmp54 = (struct mutex *)__cil_tmp53;
  mutex_unlock(__cil_tmp54);
  return;
}
}
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_manager *fman ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___7 ;
  unsigned long irq_flags ;
  void *tmp___8 ;
  long tmp___9 ;
  raw_spinlock_t *tmp___10 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct vmw_private *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  spinlock_t *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct list_head *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  spinlock_t *__cil_tmp61 ;
  struct vmw_fence_action *__cil_tmp62 ;

  {
  __cil_tmp17 = (unsigned long )fence;
  __cil_tmp18 = __cil_tmp17 + 8UL;
  fman = *((struct vmw_fence_manager **)__cil_tmp18);
  tmp___7 = vmw_fpriv(file_priv);
  vmw_fp = tmp___7;
  tmp___8 = kzalloc(96UL, 208U);
  eaction = (struct vmw_event_fence_action *)tmp___8;
  __cil_tmp19 = (void *)0;
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = (unsigned long )eaction;
  __cil_tmp22 = __cil_tmp21 == __cil_tmp20;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = (long )__cil_tmp24;
  tmp___9 = ldv__builtin_expect(__cil_tmp25, 0L);
  if (tmp___9) {
    return (-12);
  }
  __cil_tmp26 = (unsigned long )eaction;
  __cil_tmp27 = __cil_tmp26 + 56UL;
  *((struct drm_pending_event **)__cil_tmp27) = event;
  __cil_tmp28 = 24;
  __cil_tmp29 = (unsigned long )eaction;
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
  *((void (**)(struct vmw_fence_action *action ))__cil_tmp30) = & vmw_event_fence_action_seq_passed;
  __cil_tmp31 = 32;
  __cil_tmp32 = (unsigned long )eaction;
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
  *((void (**)(struct vmw_fence_action *action ))__cil_tmp33) = & vmw_event_fence_action_cleanup;
  __cil_tmp34 = 16;
  __cil_tmp35 = (unsigned long )eaction;
  __cil_tmp36 = __cil_tmp35 + __cil_tmp34;
  *((enum vmw_action_type *)__cil_tmp36) = (enum vmw_action_type )0;
  __cil_tmp37 = (unsigned long )eaction;
  __cil_tmp38 = __cil_tmp37 + 64UL;
  *((struct vmw_fence_obj **)__cil_tmp38) = vmw_fence_obj_reference(fence);
  __cil_tmp39 = (unsigned long )eaction;
  __cil_tmp40 = __cil_tmp39 + 72UL;
  __cil_tmp41 = (unsigned long )fman;
  __cil_tmp42 = __cil_tmp41 + 8UL;
  __cil_tmp43 = *((struct vmw_private **)__cil_tmp42);
  __cil_tmp44 = (unsigned long )__cil_tmp43;
  __cil_tmp45 = __cil_tmp44 + 2088UL;
  *((struct drm_device **)__cil_tmp40) = *((struct drm_device **)__cil_tmp45);
  __cil_tmp46 = (unsigned long )eaction;
  __cil_tmp47 = __cil_tmp46 + 80UL;
  *((uint32_t **)__cil_tmp47) = tv_sec;
  __cil_tmp48 = (unsigned long )eaction;
  __cil_tmp49 = __cil_tmp48 + 88UL;
  *((uint32_t **)__cil_tmp49) = tv_usec;
  while (1) {

    while (1) {
      __cil_tmp50 = (unsigned long )fman;
      __cil_tmp51 = __cil_tmp50 + 16UL;
      __cil_tmp52 = (spinlock_t *)__cil_tmp51;
      tmp___10 = spinlock_check(__cil_tmp52);
      irq_flags = _raw_spin_lock_irqsave(tmp___10);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp53 = (unsigned long )eaction;
  __cil_tmp54 = __cil_tmp53 + 40UL;
  __cil_tmp55 = (struct list_head *)__cil_tmp54;
  __cil_tmp56 = (unsigned long )vmw_fp;
  __cil_tmp57 = __cil_tmp56 + 16UL;
  __cil_tmp58 = (struct list_head *)__cil_tmp57;
  list_add_tail(__cil_tmp55, __cil_tmp58);
  __cil_tmp59 = (unsigned long )fman;
  __cil_tmp60 = __cil_tmp59 + 16UL;
  __cil_tmp61 = (spinlock_t *)__cil_tmp60;
  spin_unlock_irqrestore(__cil_tmp61, irq_flags);
  __cil_tmp62 = (struct vmw_fence_action *)eaction;
  vmw_fence_obj_add_action(fence, __cil_tmp62);
  return (0);
}
}
int vmw_event_fence_action_create(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                  uint32_t flags , uint64_t user_data , bool interruptible ) 
{ struct vmw_event_fence_pending *event ;
  struct drm_device *dev ;
  unsigned long irq_flags ;
  int ret ;
  raw_spinlock_t *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  raw_spinlock_t *tmp___12 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct vmw_fence_manager *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct vmw_private *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  spinlock_t *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  spinlock_t *__cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  long __cil_tmp52 ;
  void *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct drm_pending_event *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  uint32_t *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  uint32_t *__cil_tmp85 ;
  struct drm_pending_event *__cil_tmp86 ;
  void *__cil_tmp87 ;
  uint32_t *__cil_tmp88 ;
  void *__cil_tmp89 ;
  uint32_t *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  void (*__cil_tmp94)(struct drm_pending_event *event ) ;
  struct drm_pending_event *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  spinlock_t *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  int __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  spinlock_t *__cil_tmp108 ;

  {
  __cil_tmp20 = (unsigned long )fence;
  __cil_tmp21 = __cil_tmp20 + 8UL;
  __cil_tmp22 = *((struct vmw_fence_manager **)__cil_tmp21);
  __cil_tmp23 = (unsigned long )__cil_tmp22;
  __cil_tmp24 = __cil_tmp23 + 8UL;
  __cil_tmp25 = *((struct vmw_private **)__cil_tmp24);
  __cil_tmp26 = (unsigned long )__cil_tmp25;
  __cil_tmp27 = __cil_tmp26 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp27);
  while (1) {

    while (1) {
      __cil_tmp28 = (unsigned long )dev;
      __cil_tmp29 = __cil_tmp28 + 872UL;
      __cil_tmp30 = (spinlock_t *)__cil_tmp29;
      tmp___7 = spinlock_check(__cil_tmp30);
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      goto while_break___0;
    }
    while_break___0: ;
    goto while_break;
  }
  while_break: 
  __cil_tmp31 = (unsigned long )file_priv;
  __cil_tmp32 = __cil_tmp31 + 232UL;
  __cil_tmp33 = *((int *)__cil_tmp32);
  __cil_tmp34 = (unsigned long )__cil_tmp33;
  if (__cil_tmp34 < 24UL) {
    ret = -16;
  } else {
    ret = 0;
  }
  __cil_tmp35 = ret == 0;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = (long )__cil_tmp37;
  tmp___8 = ldv__builtin_expect(__cil_tmp38, 1L);
  if (tmp___8) {
    __cil_tmp39 = (unsigned long )file_priv;
    __cil_tmp40 = __cil_tmp39 + 232UL;
    __cil_tmp41 = (unsigned long )file_priv;
    __cil_tmp42 = __cil_tmp41 + 232UL;
    __cil_tmp43 = *((int *)__cil_tmp42);
    __cil_tmp44 = (unsigned long )__cil_tmp43;
    __cil_tmp45 = __cil_tmp44 - 24UL;
    *((int *)__cil_tmp40) = (int )__cil_tmp45;
  }
  __cil_tmp46 = (unsigned long )dev;
  __cil_tmp47 = __cil_tmp46 + 872UL;
  __cil_tmp48 = (spinlock_t *)__cil_tmp47;
  spin_unlock_irqrestore(__cil_tmp48, irq_flags);
  __cil_tmp49 = ret != 0;
  __cil_tmp50 = ! __cil_tmp49;
  __cil_tmp51 = ! __cil_tmp50;
  __cil_tmp52 = (long )__cil_tmp51;
  tmp___9 = ldv__builtin_expect(__cil_tmp52, 0L);
  if (tmp___9) {
    drm_err("vmw_event_fence_action_create", "Failed to allocate event space for this file.\n");
    goto out_no_space;
  }
  tmp___10 = kzalloc(24UL, 208U);
  event = (struct vmw_event_fence_pending *)tmp___10;
  __cil_tmp53 = (void *)0;
  __cil_tmp54 = (unsigned long )__cil_tmp53;
  __cil_tmp55 = (unsigned long )event;
  __cil_tmp56 = __cil_tmp55 == __cil_tmp54;
  __cil_tmp57 = ! __cil_tmp56;
  __cil_tmp58 = ! __cil_tmp57;
  __cil_tmp59 = (long )__cil_tmp58;
  tmp___11 = ldv__builtin_expect(__cil_tmp59, 0L);
  if (tmp___11) {
    drm_err("vmw_event_fence_action_create", "Failed to allocate an event.\n");
    ret = -12;
    goto out_no_event;
  }
  __cil_tmp60 = (unsigned long )event;
  __cil_tmp61 = __cil_tmp60 + 48UL;
  *((__u32 *)__cil_tmp61) = (__u32 )(-0x7FFFFFFF-1);
  __cil_tmp62 = 4;
  __cil_tmp63 = 48UL + __cil_tmp62;
  __cil_tmp64 = (unsigned long )event;
  __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
  *((__u32 *)__cil_tmp65) = (__u32 )72UL;
  __cil_tmp66 = 56;
  __cil_tmp67 = (unsigned long )event;
  __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
  *((uint64_t *)__cil_tmp68) = user_data;
  __cil_tmp69 = (unsigned long )event;
  __cil_tmp70 = __cil_tmp69 + 48UL;
  *((struct drm_event **)event) = (struct drm_event *)__cil_tmp70;
  __cil_tmp71 = 24;
  __cil_tmp72 = (unsigned long )event;
  __cil_tmp73 = __cil_tmp72 + __cil_tmp71;
  *((struct drm_file **)__cil_tmp73) = file_priv;
  __cil_tmp74 = 40;
  __cil_tmp75 = (unsigned long )event;
  __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
  *((void (**)(struct drm_pending_event *event ))__cil_tmp76) = (void (*)(struct drm_pending_event * ))(& kfree);
  if (flags & 1U) {
    __cil_tmp77 = (struct drm_pending_event *)event;
    __cil_tmp78 = 64;
    __cil_tmp79 = (unsigned long )event;
    __cil_tmp80 = __cil_tmp79 + __cil_tmp78;
    __cil_tmp81 = (uint32_t *)__cil_tmp80;
    __cil_tmp82 = 68;
    __cil_tmp83 = (unsigned long )event;
    __cil_tmp84 = __cil_tmp83 + __cil_tmp82;
    __cil_tmp85 = (uint32_t *)__cil_tmp84;
    ret = vmw_event_fence_action_queue(file_priv, fence, __cil_tmp77, __cil_tmp81,
                                       __cil_tmp85, interruptible);
  } else {
    __cil_tmp86 = (struct drm_pending_event *)event;
    __cil_tmp87 = (void *)0;
    __cil_tmp88 = (uint32_t *)__cil_tmp87;
    __cil_tmp89 = (void *)0;
    __cil_tmp90 = (uint32_t *)__cil_tmp89;
    ret = vmw_event_fence_action_queue(file_priv, fence, __cil_tmp86, __cil_tmp88,
                                       __cil_tmp90, interruptible);
  }
  if (ret != 0) {
    goto out_no_queue;
  }
  out_no_queue: 
  __cil_tmp91 = 40;
  __cil_tmp92 = (unsigned long )event;
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
  __cil_tmp94 = *((void (**)(struct drm_pending_event *event ))__cil_tmp93);
  __cil_tmp95 = (struct drm_pending_event *)event;
  (*__cil_tmp94)(__cil_tmp95);
  out_no_event: 
  while (1) {

    while (1) {
      __cil_tmp96 = (unsigned long )dev;
      __cil_tmp97 = __cil_tmp96 + 872UL;
      __cil_tmp98 = (spinlock_t *)__cil_tmp97;
      tmp___12 = spinlock_check(__cil_tmp98);
      irq_flags = _raw_spin_lock_irqsave(tmp___12);
      goto while_break___2;
    }
    while_break___2: ;
    goto while_break___1;
  }
  while_break___1: 
  __cil_tmp99 = (unsigned long )file_priv;
  __cil_tmp100 = __cil_tmp99 + 232UL;
  __cil_tmp101 = (unsigned long )file_priv;
  __cil_tmp102 = __cil_tmp101 + 232UL;
  __cil_tmp103 = *((int *)__cil_tmp102);
  __cil_tmp104 = (unsigned long )__cil_tmp103;
  __cil_tmp105 = __cil_tmp104 + 72UL;
  *((int *)__cil_tmp100) = (int )__cil_tmp105;
  __cil_tmp106 = (unsigned long )dev;
  __cil_tmp107 = __cil_tmp106 + 872UL;
  __cil_tmp108 = (spinlock_t *)__cil_tmp107;
  spin_unlock_irqrestore(__cil_tmp108, irq_flags);
  out_no_space: 
  return (ret);
}
}
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp___7 ;
  struct drm_vmw_fence_event_arg *arg ;
  struct vmw_fence_obj *fence ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___8 ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  uint32_t handle ;
  int ret ;
  struct ttm_base_object *base ;
  struct ttm_base_object *tmp___9 ;
  long tmp___10 ;
  struct ttm_base_object *__mptr ;
  bool existed ;
  long tmp___11 ;
  uint32_t *tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  struct vmw_fpriv *tmp___16 ;
  struct vmw_fence_obj **__cil_tmp24 ;
  void *__cil_tmp25 ;
  uint64_t __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct ttm_object_file *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  struct ttm_base_object **__cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct ttm_base_object **__cil_tmp39 ;
  struct ttm_base_object *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  struct ttm_base_object **__cil_tmp50 ;
  struct ttm_base_object *__cil_tmp51 ;
  struct vmw_fence_obj **__cil_tmp52 ;
  struct vmw_user_fence *__cil_tmp53 ;
  struct ttm_base_object *__cil_tmp54 ;
  unsigned int __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  struct vmw_user_fence *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct vmw_fence_obj **__cil_tmp61 ;
  struct vmw_fence_obj *__cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct ttm_object_file *__cil_tmp68 ;
  struct ttm_base_object **__cil_tmp69 ;
  struct ttm_base_object *__cil_tmp70 ;
  enum ttm_ref_type __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  long __cil_tmp75 ;
  uint32_t *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct ttm_base_object **__cil_tmp78 ;
  struct ttm_base_object *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct vmw_fence_obj **__cil_tmp83 ;
  struct vmw_fence_obj *__cil_tmp84 ;
  void *__cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  long __cil_tmp89 ;
  void *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  struct vmw_fence_obj **__cil_tmp92 ;
  struct vmw_fence_obj *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  uint32_t __cil_tmp101 ;
  struct vmw_fence_obj **__cil_tmp102 ;
  struct vmw_fence_obj *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  uint32_t __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  uint64_t __cil_tmp109 ;
  bool __cil_tmp110 ;
  struct vmw_fence_obj **__cil_tmp111 ;
  struct vmw_fence_obj *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  uint32_t __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  uint64_t __cil_tmp118 ;
  bool __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  long __cil_tmp123 ;
  struct vmw_fence_obj **__cil_tmp124 ;
  struct vmw_fence_obj *__cil_tmp125 ;
  uint32_t *__cil_tmp126 ;
  uint32_t __cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  struct ttm_object_file *__cil_tmp133 ;
  uint32_t *__cil_tmp134 ;
  uint32_t __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  enum ttm_ref_type __cil_tmp137 ;

  {
  tmp___7 = vmw_priv(dev);
  dev_priv = tmp___7;
  arg = (struct drm_vmw_fence_event_arg *)data;
  __cil_tmp24 = & fence;
  __cil_tmp25 = (void *)0;
  *__cil_tmp24 = (struct vmw_fence_obj *)__cil_tmp25;
  tmp___8 = vmw_fpriv(file_priv);
  vmw_fp = tmp___8;
  __cil_tmp26 = *((uint64_t *)arg);
  __cil_tmp27 = (unsigned long )__cil_tmp26;
  user_fence_rep = (struct drm_vmw_fence_rep *)__cil_tmp27;
  __cil_tmp28 = (unsigned long )arg;
  __cil_tmp29 = __cil_tmp28 + 16UL;
  if (*((uint32_t *)__cil_tmp29)) {
    __cil_tmp30 = (unsigned long )vmw_fp;
    __cil_tmp31 = __cil_tmp30 + 8UL;
    __cil_tmp32 = *((struct ttm_object_file **)__cil_tmp31);
    __cil_tmp33 = (unsigned long )arg;
    __cil_tmp34 = __cil_tmp33 + 16UL;
    __cil_tmp35 = *((uint32_t *)__cil_tmp34);
    tmp___9 = ttm_base_object_lookup(__cil_tmp32, __cil_tmp35);
    __cil_tmp36 = & base;
    *__cil_tmp36 = tmp___9;
    __cil_tmp37 = (void *)0;
    __cil_tmp38 = (unsigned long )__cil_tmp37;
    __cil_tmp39 = & base;
    __cil_tmp40 = *__cil_tmp39;
    __cil_tmp41 = (unsigned long )__cil_tmp40;
    __cil_tmp42 = __cil_tmp41 == __cil_tmp38;
    __cil_tmp43 = ! __cil_tmp42;
    __cil_tmp44 = ! __cil_tmp43;
    __cil_tmp45 = (long )__cil_tmp44;
    tmp___10 = ldv__builtin_expect(__cil_tmp45, 0L);
    if (tmp___10) {
      __cil_tmp46 = (unsigned long )arg;
      __cil_tmp47 = __cil_tmp46 + 16UL;
      __cil_tmp48 = *((uint32_t *)__cil_tmp47);
      __cil_tmp49 = (unsigned long )__cil_tmp48;
      drm_err("vmw_fence_event_ioctl", "Fence event invalid fence object handle 0x%08lx.\n",
              __cil_tmp49);
      return (-22);
    }
    __cil_tmp50 = & base;
    __cil_tmp51 = *__cil_tmp50;
    __mptr = __cil_tmp51;
    __cil_tmp52 = & fence;
    __cil_tmp53 = (struct vmw_user_fence *)0;
    __cil_tmp54 = (struct ttm_base_object *)__cil_tmp53;
    __cil_tmp55 = (unsigned int )__cil_tmp54;
    __cil_tmp56 = (char *)__mptr;
    __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
    __cil_tmp58 = (struct vmw_user_fence *)__cil_tmp57;
    __cil_tmp59 = (unsigned long )__cil_tmp58;
    __cil_tmp60 = __cil_tmp59 + 64UL;
    *__cil_tmp52 = (struct vmw_fence_obj *)__cil_tmp60;
    __cil_tmp61 = & fence;
    __cil_tmp62 = *__cil_tmp61;
    vmw_fence_obj_reference(__cil_tmp62);
    __cil_tmp63 = (void *)0;
    __cil_tmp64 = (unsigned long )__cil_tmp63;
    __cil_tmp65 = (unsigned long )user_fence_rep;
    if (__cil_tmp65 != __cil_tmp64) {
      __cil_tmp66 = (unsigned long )vmw_fp;
      __cil_tmp67 = __cil_tmp66 + 8UL;
      __cil_tmp68 = *((struct ttm_object_file **)__cil_tmp67);
      __cil_tmp69 = & base;
      __cil_tmp70 = *__cil_tmp69;
      __cil_tmp71 = (enum ttm_ref_type )0;
      ret = ttm_ref_object_add(__cil_tmp68, __cil_tmp70, __cil_tmp71, & existed);
      __cil_tmp72 = ret != 0;
      __cil_tmp73 = ! __cil_tmp72;
      __cil_tmp74 = ! __cil_tmp73;
      __cil_tmp75 = (long )__cil_tmp74;
      tmp___11 = ldv__builtin_expect(__cil_tmp75, 0L);
      if (tmp___11) {
        drm_err("vmw_fence_event_ioctl", "Failed to reference a fence object.\n");
        goto out_no_ref_obj;
      }
      __cil_tmp76 = & handle;
      __cil_tmp77 = 16;
      __cil_tmp78 = & base;
      __cil_tmp79 = *__cil_tmp78;
      __cil_tmp80 = (unsigned long )__cil_tmp79;
      __cil_tmp81 = __cil_tmp80 + __cil_tmp77;
      __cil_tmp82 = *((unsigned long *)__cil_tmp81);
      *__cil_tmp76 = (uint32_t )__cil_tmp82;
    }
    ttm_base_object_unref(& base);
  }
  __cil_tmp83 = & fence;
  __cil_tmp84 = *__cil_tmp83;
  if (! __cil_tmp84) {
    if (user_fence_rep) {
      tmp___12 = & handle;
    } else {
      __cil_tmp85 = (void *)0;
      tmp___12 = (uint32_t *)__cil_tmp85;
    }
    ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___12);
    __cil_tmp86 = ret != 0;
    __cil_tmp87 = ! __cil_tmp86;
    __cil_tmp88 = ! __cil_tmp87;
    __cil_tmp89 = (long )__cil_tmp88;
    tmp___13 = ldv__builtin_expect(__cil_tmp89, 0L);
    if (tmp___13) {
      drm_err("vmw_fence_event_ioctl", "Fence event failed to create fence.\n");
      return (ret);
    }
  }
  while (1) {
    __cil_tmp90 = (void *)0;
    __cil_tmp91 = (unsigned long )__cil_tmp90;
    __cil_tmp92 = & fence;
    __cil_tmp93 = *__cil_tmp92;
    __cil_tmp94 = (unsigned long )__cil_tmp93;
    __cil_tmp95 = __cil_tmp94 == __cil_tmp91;
    __cil_tmp96 = ! __cil_tmp95;
    __cil_tmp97 = ! __cil_tmp96;
    __cil_tmp98 = (long )__cil_tmp97;
    tmp___14 = ldv__builtin_expect(__cil_tmp98, 0L);
    if (tmp___14) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c"),
                             "i" (1124), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp99 = (unsigned long )arg;
  __cil_tmp100 = __cil_tmp99 + 20UL;
  __cil_tmp101 = *((uint32_t *)__cil_tmp100);
  if (__cil_tmp101 & 1U) {
    __cil_tmp102 = & fence;
    __cil_tmp103 = *__cil_tmp102;
    __cil_tmp104 = (unsigned long )arg;
    __cil_tmp105 = __cil_tmp104 + 20UL;
    __cil_tmp106 = *((uint32_t *)__cil_tmp105);
    __cil_tmp107 = (unsigned long )arg;
    __cil_tmp108 = __cil_tmp107 + 8UL;
    __cil_tmp109 = *((uint64_t *)__cil_tmp108);
    __cil_tmp110 = (bool )1;
    ret = vmw_event_fence_action_create(file_priv, __cil_tmp103, __cil_tmp106, __cil_tmp109,
                                        __cil_tmp110);
  } else {
    __cil_tmp111 = & fence;
    __cil_tmp112 = *__cil_tmp111;
    __cil_tmp113 = (unsigned long )arg;
    __cil_tmp114 = __cil_tmp113 + 20UL;
    __cil_tmp115 = *((uint32_t *)__cil_tmp114);
    __cil_tmp116 = (unsigned long )arg;
    __cil_tmp117 = __cil_tmp116 + 8UL;
    __cil_tmp118 = *((uint64_t *)__cil_tmp117);
    __cil_tmp119 = (bool )1;
    ret = vmw_event_fence_action_create(file_priv, __cil_tmp112, __cil_tmp115, __cil_tmp118,
                                        __cil_tmp119);
  }
  __cil_tmp120 = ret != 0;
  __cil_tmp121 = ! __cil_tmp120;
  __cil_tmp122 = ! __cil_tmp121;
  __cil_tmp123 = (long )__cil_tmp122;
  tmp___15 = ldv__builtin_expect(__cil_tmp123, 0L);
  if (tmp___15) {
    if (ret != -512) {
      drm_err("vmw_fence_event_ioctl", "Failed to attach event to fence.\n");
    }
    goto out_no_create;
  }
  __cil_tmp124 = & fence;
  __cil_tmp125 = *__cil_tmp124;
  __cil_tmp126 = & handle;
  __cil_tmp127 = *__cil_tmp126;
  vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, __cil_tmp125, __cil_tmp127);
  vmw_fence_obj_unreference(& fence);
  return (0);
  out_no_create: 
  __cil_tmp128 = (void *)0;
  __cil_tmp129 = (unsigned long )__cil_tmp128;
  __cil_tmp130 = (unsigned long )user_fence_rep;
  if (__cil_tmp130 != __cil_tmp129) {
    tmp___16 = vmw_fpriv(file_priv);
    __cil_tmp131 = (unsigned long )tmp___16;
    __cil_tmp132 = __cil_tmp131 + 8UL;
    __cil_tmp133 = *((struct ttm_object_file **)__cil_tmp132);
    __cil_tmp134 = & handle;
    __cil_tmp135 = *__cil_tmp134;
    __cil_tmp136 = (unsigned long )__cil_tmp135;
    __cil_tmp137 = (enum ttm_ref_type )0;
    ttm_ref_object_base_unref(__cil_tmp133, __cil_tmp136, __cil_tmp137);
  }
  out_no_ref_obj: 
  vmw_fence_obj_unreference(& fence);
  return (ret);
}
}
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) ;
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct ttm_lock *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  bool __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  bool __cil_tmp19 ;
  bool __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  bool __cil_tmp26 ;
  bool __cil_tmp27 ;
  struct ttm_lock *__cil_tmp28 ;

  {
  __cil_tmp10 = (unsigned long )dev_priv;
  __cil_tmp11 = __cil_tmp10 + 134384UL;
  vmaster = *((struct vmw_master **)__cil_tmp11);
  bo = (struct ttm_buffer_object *)buf;
  __cil_tmp12 = (struct ttm_lock *)vmaster;
  ret = ttm_write_lock(__cil_tmp12, interruptible);
  __cil_tmp13 = ret != 0;
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = (long )__cil_tmp15;
  tmp___7 = ldv__builtin_expect(__cil_tmp16, 0L);
  if (tmp___7) {
    return (ret);
  }
  __cil_tmp17 = (bool )0;
  __cil_tmp18 = (uint32_t )0;
  vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp17, __cil_tmp18);
  __cil_tmp19 = (bool )0;
  __cil_tmp20 = (bool )0;
  __cil_tmp21 = (uint32_t )0;
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp19, __cil_tmp20, __cil_tmp21);
  __cil_tmp22 = ret != 0;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = (long )__cil_tmp24;
  tmp___8 = ldv__builtin_expect(__cil_tmp25, 0L);
  if (tmp___8) {
    goto err;
  }
  __cil_tmp26 = (bool )0;
  __cil_tmp27 = (bool )0;
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp26, __cil_tmp27);
  ttm_bo_unreserve(bo);
  err: 
  __cil_tmp28 = (struct ttm_lock *)vmaster;
  ttm_write_unlock(__cil_tmp28);
  return (ret);
}
}
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement *placement ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct ttm_lock *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  bool __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  bool __cil_tmp21 ;
  bool __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  long __cil_tmp27 ;
  bool __cil_tmp28 ;
  bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  long __cil_tmp33 ;
  bool __cil_tmp34 ;
  bool __cil_tmp35 ;
  struct ttm_lock *__cil_tmp36 ;

  {
  __cil_tmp12 = (unsigned long )dev_priv;
  __cil_tmp13 = __cil_tmp12 + 134384UL;
  vmaster = *((struct vmw_master **)__cil_tmp13);
  bo = (struct ttm_buffer_object *)buf;
  __cil_tmp14 = (struct ttm_lock *)vmaster;
  ret = ttm_write_lock(__cil_tmp14, interruptible);
  __cil_tmp15 = ret != 0;
  __cil_tmp16 = ! __cil_tmp15;
  __cil_tmp17 = ! __cil_tmp16;
  __cil_tmp18 = (long )__cil_tmp17;
  tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
  if (tmp___7) {
    return (ret);
  }
  if (pin) {
    __cil_tmp19 = (bool )0;
    __cil_tmp20 = (uint32_t )0;
    vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp19, __cil_tmp20);
  }
  __cil_tmp21 = (bool )0;
  __cil_tmp22 = (bool )0;
  __cil_tmp23 = (uint32_t )0;
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp21, __cil_tmp22, __cil_tmp23);
  __cil_tmp24 = ret != 0;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = (long )__cil_tmp26;
  tmp___8 = ldv__builtin_expect(__cil_tmp27, 0L);
  if (tmp___8) {
    goto err;
  }
  if (pin) {
    placement = & vmw_vram_gmr_ne_placement;
  } else {
    placement = & vmw_vram_gmr_placement;
  }
  __cil_tmp28 = (bool )0;
  __cil_tmp29 = (bool )0;
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp28, __cil_tmp29);
  __cil_tmp30 = ret == 0;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = ! __cil_tmp31;
  __cil_tmp33 = (long )__cil_tmp32;
  tmp___9 = ldv__builtin_expect(__cil_tmp33, 1L);
  if (tmp___9) {
    goto err_unreserve;
  } else
  if (ret == -512) {
    goto err_unreserve;
  }
  if (pin) {
    placement = & vmw_vram_ne_placement;
  } else {
    placement = & vmw_vram_placement;
  }
  __cil_tmp34 = (bool )0;
  __cil_tmp35 = (bool )0;
  ret = ttm_bo_validate(bo, placement, interruptible, __cil_tmp34, __cil_tmp35);
  err_unreserve: 
  ttm_bo_unreserve(bo);
  err: 
  __cil_tmp36 = (struct ttm_lock *)vmaster;
  ttm_write_unlock(__cil_tmp36);
  return (ret);
}
}
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) 
{ struct ttm_placement *placement ;
  int tmp___7 ;

  {
  if (pin) {
    placement = & vmw_vram_ne_placement;
  } else {
    placement = & vmw_vram_placement;
  }
  tmp___7 = vmw_dmabuf_to_placement(dev_priv, buf, placement, interruptible);
  return (tmp___7);
}
}
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement placement ;
  int ret ;
  long tmp___7 ;
  long tmp___8 ;
  int __ret_warn_on ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct ttm_placement *__cil_tmp16 ;
  struct ttm_placement *__cil_tmp17 ;
  struct ttm_placement *__cil_tmp18 ;
  struct ttm_placement *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct ttm_lock *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  bool __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  bool __cil_tmp31 ;
  bool __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  bool __cil_tmp53 ;
  bool __cil_tmp54 ;
  bool __cil_tmp55 ;
  bool __cil_tmp56 ;
  bool __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  long __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  long __cil_tmp67 ;
  struct ttm_lock *__cil_tmp68 ;

  {
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 134384UL;
  vmaster = *((struct vmw_master **)__cil_tmp15);
  bo = (struct ttm_buffer_object *)buf;
  ret = 0;
  if (pin) {
    __cil_tmp16 = & placement;
    __cil_tmp17 = & vmw_vram_ne_placement;
    *__cil_tmp16 = *__cil_tmp17;
  } else {
    __cil_tmp18 = & placement;
    __cil_tmp19 = & vmw_vram_placement;
    *__cil_tmp18 = *__cil_tmp19;
  }
  __cil_tmp20 = (unsigned long )(& placement) + 4UL;
  __cil_tmp21 = (unsigned long )bo;
  __cil_tmp22 = __cil_tmp21 + 40UL;
  __cil_tmp23 = *((unsigned long *)__cil_tmp22);
  *((unsigned int *)__cil_tmp20) = (unsigned int )__cil_tmp23;
  __cil_tmp24 = (struct ttm_lock *)vmaster;
  ret = ttm_write_lock(__cil_tmp24, interruptible);
  __cil_tmp25 = ret != 0;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___7 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___7) {
    return (ret);
  }
  if (pin) {
    __cil_tmp29 = (bool )0;
    __cil_tmp30 = (uint32_t )0;
    vmw_execbuf_release_pinned_bo(dev_priv, __cil_tmp29, __cil_tmp30);
  }
  __cil_tmp31 = (bool )0;
  __cil_tmp32 = (bool )0;
  __cil_tmp33 = (uint32_t )0;
  ret = ttm_bo_reserve(bo, interruptible, __cil_tmp31, __cil_tmp32, __cil_tmp33);
  __cil_tmp34 = ret != 0;
  __cil_tmp35 = ! __cil_tmp34;
  __cil_tmp36 = ! __cil_tmp35;
  __cil_tmp37 = (long )__cil_tmp36;
  tmp___8 = ldv__builtin_expect(__cil_tmp37, 0L);
  if (tmp___8) {
    goto err_unlock;
  }
  __cil_tmp38 = 148;
  __cil_tmp39 = (unsigned long )bo;
  __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
  __cil_tmp41 = *((uint32_t *)__cil_tmp40);
  if (__cil_tmp41 == 2U) {
    __cil_tmp42 = (unsigned long )bo;
    __cil_tmp43 = __cil_tmp42 + 40UL;
    __cil_tmp44 = *((unsigned long *)__cil_tmp43);
    __cil_tmp45 = 120;
    __cil_tmp46 = (unsigned long )bo;
    __cil_tmp47 = __cil_tmp46 + __cil_tmp45;
    __cil_tmp48 = *((unsigned long *)__cil_tmp47);
    if (__cil_tmp48 < __cil_tmp44) {
      __cil_tmp49 = 120;
      __cil_tmp50 = (unsigned long )bo;
      __cil_tmp51 = __cil_tmp50 + __cil_tmp49;
      __cil_tmp52 = *((unsigned long *)__cil_tmp51);
      if (__cil_tmp52 > 0UL) {
        __cil_tmp53 = (bool )0;
        __cil_tmp54 = (bool )0;
        __cil_tmp55 = (bool )0;
        ttm_bo_validate(bo, & vmw_sys_placement, __cil_tmp53, __cil_tmp54, __cil_tmp55);
      }
    }
  }
  __cil_tmp56 = (bool )0;
  __cil_tmp57 = (bool )0;
  ret = ttm_bo_validate(bo, & placement, interruptible, __cil_tmp56, __cil_tmp57);
  if (ret == 0) {
    __cil_tmp58 = (unsigned long )bo;
    __cil_tmp59 = __cil_tmp58 + 368UL;
    __cil_tmp60 = *((unsigned long *)__cil_tmp59);
    if (__cil_tmp60 != 0UL) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  __ret_warn_on = tmp___9;
  __cil_tmp61 = ! __ret_warn_on;
  __cil_tmp62 = ! __cil_tmp61;
  __cil_tmp63 = (long )__cil_tmp62;
  tmp___10 = ldv__builtin_expect(__cil_tmp63, 0L);
  if (tmp___10) {
    __cil_tmp64 = 233;
    warn_slowpath_null("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c",
                       __cil_tmp64);
  }
  __cil_tmp65 = ! __ret_warn_on;
  __cil_tmp66 = ! __cil_tmp65;
  __cil_tmp67 = (long )__cil_tmp66;
  ldv__builtin_expect(__cil_tmp67, 0L);
  ttm_bo_unreserve(bo);
  err_unlock: 
  __cil_tmp68 = (struct ttm_lock *)vmaster;
  ttm_write_unlock(__cil_tmp68);
  return (ret);
}
}
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) 
{ int tmp___7 ;

  {
  tmp___7 = vmw_dmabuf_to_placement(dev_priv, buf, & vmw_evictable_placement, interruptible);
  return (tmp___7);
}
}
void vmw_bo_get_guest_ptr(struct ttm_buffer_object *bo , SVGAGuestPtr *ptr ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  __cil_tmp3 = 148;
  __cil_tmp4 = (unsigned long )bo;
  __cil_tmp5 = __cil_tmp4 + __cil_tmp3;
  __cil_tmp6 = *((uint32_t *)__cil_tmp5);
  if (__cil_tmp6 == 2U) {
    *((uint32 *)ptr) = (uint32 )-2;
    __cil_tmp7 = (unsigned long )ptr;
    __cil_tmp8 = __cil_tmp7 + 4UL;
    __cil_tmp9 = (unsigned long )bo;
    __cil_tmp10 = __cil_tmp9 + 368UL;
    __cil_tmp11 = *((unsigned long *)__cil_tmp10);
    *((uint32 *)__cil_tmp8) = (uint32 )__cil_tmp11;
  } else {
    __cil_tmp12 = 120;
    __cil_tmp13 = (unsigned long )bo;
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
    __cil_tmp15 = *((unsigned long *)__cil_tmp14);
    *((uint32 *)ptr) = (uint32 )__cil_tmp15;
    __cil_tmp16 = (unsigned long )ptr;
    __cil_tmp17 = __cil_tmp16 + 4UL;
    *((uint32 *)__cil_tmp17) = (uint32 )0;
  }
  return;
}
}
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) 
{ uint32_t pl_flags ;
  struct ttm_placement placement ;
  uint32_t old_mem_type ;
  int ret ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  atomic_t *__cil_tmp19 ;
  atomic_t *__cil_tmp20 ;
  long __cil_tmp21 ;
  int __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  long __cil_tmp24 ;
  uint32_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t *__cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  uint32_t *__cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  void *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  bool __cil_tmp39 ;
  bool __cil_tmp40 ;
  bool __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  long __cil_tmp46 ;

  {
  __cil_tmp14 = 148;
  __cil_tmp15 = (unsigned long )bo;
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
  old_mem_type = *((uint32_t *)__cil_tmp16);
  while (1) {
    __cil_tmp17 = (unsigned long )bo;
    __cil_tmp18 = __cil_tmp17 + 304UL;
    __cil_tmp19 = (atomic_t *)__cil_tmp18;
    __cil_tmp20 = __cil_tmp19;
    tmp___7 = atomic_read(__cil_tmp20);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    __cil_tmp21 = (long )tmp___8;
    tmp___9 = ldv__builtin_expect(__cil_tmp21, 0L);
    if (tmp___9) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (307), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: ;
  while (1) {

    if (old_mem_type != 2U) {
      __cil_tmp22 = 1 << 3;
      __cil_tmp23 = (uint32_t )__cil_tmp22;
      if (old_mem_type != __cil_tmp23) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
    } else {
      tmp___10 = 0;
    }
    __cil_tmp24 = (long )tmp___10;
    tmp___11 = ldv__builtin_expect(__cil_tmp24, 0L);
    if (tmp___11) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (309), "i" (12UL));
        while (1) {

        }

        goto while_break___3;
      }
      while_break___3: ;
    }
    goto while_break___2;
  }
  while_break___2: 
  __cil_tmp25 = & pl_flags;
  __cil_tmp26 = 1 << 16;
  __cil_tmp27 = 1 << 3;
  __cil_tmp28 = 1 << 2;
  __cil_tmp29 = __cil_tmp28 | __cil_tmp27;
  __cil_tmp30 = __cil_tmp29 | __cil_tmp26;
  *__cil_tmp25 = (uint32_t )__cil_tmp30;
  if (pin) {
    __cil_tmp31 = & pl_flags;
    __cil_tmp32 = 1 << 21;
    __cil_tmp33 = (unsigned int )__cil_tmp32;
    __cil_tmp34 = & pl_flags;
    __cil_tmp35 = *__cil_tmp34;
    *__cil_tmp31 = __cil_tmp35 | __cil_tmp33;
  }
  __cil_tmp36 = (void *)(& placement);
  memset(__cil_tmp36, 0, 40UL);
  __cil_tmp37 = (unsigned long )(& placement) + 8UL;
  *((unsigned int *)__cil_tmp37) = 1U;
  __cil_tmp38 = (unsigned long )(& placement) + 16UL;
  *((uint32_t **)__cil_tmp38) = & pl_flags;
  __cil_tmp39 = (bool )0;
  __cil_tmp40 = (bool )1;
  __cil_tmp41 = (bool )1;
  ret = ttm_bo_validate(bo, & placement, __cil_tmp39, __cil_tmp40, __cil_tmp41);
  while (1) {

    if (ret != 0) {
      tmp___12 = 1;
    } else {
      __cil_tmp42 = 148;
      __cil_tmp43 = (unsigned long )bo;
      __cil_tmp44 = __cil_tmp43 + __cil_tmp42;
      __cil_tmp45 = *((uint32_t *)__cil_tmp44);
      if (__cil_tmp45 != old_mem_type) {
        tmp___12 = 1;
      } else {
        tmp___12 = 0;
      }
    }
    __cil_tmp46 = (long )tmp___12;
    tmp___13 = ldv__builtin_expect(__cil_tmp46, 0L);
    if (tmp___13) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c"),
                             "i" (321), "i" (12UL));
        while (1) {

        }

        goto while_break___6;
      }
      while_break___6: ;
    }
    goto while_break___5;
  }
  while_break___5: ;
  return;
}
}
static void vmw_sou_destroy(struct vmw_screen_object_unit *sou ) 
{ struct vmw_display_unit *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  __cil_tmp2 = (struct vmw_display_unit *)sou;
  vmw_display_unit_cleanup(__cil_tmp2);
  __cil_tmp3 = (void *)sou;
  kfree(__cil_tmp3);
  return;
}
}
static void vmw_sou_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc *__mptr ;
  struct vmw_screen_object_unit *__cil_tmp3 ;
  struct drm_crtc *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  struct vmw_screen_object_unit *__cil_tmp8 ;

  {
  __mptr = crtc;
  __cil_tmp3 = (struct vmw_screen_object_unit *)0;
  __cil_tmp4 = (struct drm_crtc *)__cil_tmp3;
  __cil_tmp5 = (unsigned int )__cil_tmp4;
  __cil_tmp6 = (char *)__mptr;
  __cil_tmp7 = __cil_tmp6 - __cil_tmp5;
  __cil_tmp8 = (struct vmw_screen_object_unit *)__cil_tmp7;
  vmw_sou_destroy(__cil_tmp8);
  return;
}
}
static void vmw_sou_del_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ) 
{ struct vmw_screen_object_display *ld ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;

  {
  __cil_tmp4 = (unsigned long )vmw_priv___0;
  __cil_tmp5 = __cil_tmp4 + 2616UL;
  ld = *((struct vmw_screen_object_display **)__cil_tmp5);
  __cil_tmp6 = (unsigned long )sou;
  __cil_tmp7 = __cil_tmp6 + 2089UL;
  if (*((bool *)__cil_tmp7)) {
    __cil_tmp8 = *((unsigned int *)ld);
    *((unsigned int *)ld) = __cil_tmp8 - 1U;
    __cil_tmp9 = *((unsigned int *)ld);
    if (__cil_tmp9 == 0U) {
      __cil_tmp10 = (unsigned long )ld;
      __cil_tmp11 = __cil_tmp10 + 8UL;
      __cil_tmp12 = (void *)0;
      *((struct vmw_framebuffer **)__cil_tmp11) = (struct vmw_framebuffer *)__cil_tmp12;
    }
    __cil_tmp13 = (unsigned long )sou;
    __cil_tmp14 = __cil_tmp13 + 2089UL;
    *((bool *)__cil_tmp14) = (bool )0;
  }
  return;
}
}
static void vmw_sou_add_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ,
                               struct vmw_framebuffer *vfb ) 
{ struct vmw_screen_object_display *ld ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
  __cil_tmp7 = (unsigned long )vmw_priv___0;
  __cil_tmp8 = __cil_tmp7 + 2616UL;
  ld = *((struct vmw_screen_object_display **)__cil_tmp8);
  while (1) {
    __cil_tmp9 = *((unsigned int *)ld);
    if (! __cil_tmp9) {
      __cil_tmp10 = (unsigned long )ld;
      __cil_tmp11 = __cil_tmp10 + 8UL;
      if (*((struct vmw_framebuffer **)__cil_tmp11)) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    __cil_tmp12 = (long )tmp___7;
    tmp___8 = ldv__builtin_expect(__cil_tmp12, 0L);
    if (tmp___8) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (92), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp13 = (unsigned long )sou;
  __cil_tmp14 = __cil_tmp13 + 2089UL;
  __cil_tmp15 = *((bool *)__cil_tmp14);
  if (! __cil_tmp15) {
    __cil_tmp16 = 2064;
    __cil_tmp17 = (unsigned long )sou;
    __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
    if (*((bool *)__cil_tmp18)) {
      __cil_tmp19 = (unsigned long )ld;
      __cil_tmp20 = __cil_tmp19 + 8UL;
      *((struct vmw_framebuffer **)__cil_tmp20) = vfb;
      __cil_tmp21 = (unsigned long )sou;
      __cil_tmp22 = __cil_tmp21 + 2089UL;
      *((bool *)__cil_tmp22) = (bool )1;
      __cil_tmp23 = *((unsigned int *)ld);
      *((unsigned int *)ld) = __cil_tmp23 + 1U;
    }
  }
  return;
}
}
static int vmw_sou_fifo_create(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                               uint32_t x , uint32_t y , struct drm_display_mode *mode ) 
{ size_t fifo_size ;
  struct __anonstruct_cmd_429___3 *cmd ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct vmw_dma_buffer *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  long __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  long __cil_tmp26 ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  struct vmw_dma_buffer *__cil_tmp82 ;
  struct ttm_buffer_object *__cil_tmp83 ;
  struct ttm_buffer_object *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  SVGAGuestPtr *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  uint32_t __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;

  {
  while (1) {
    __cil_tmp12 = (unsigned long )sou;
    __cil_tmp13 = __cil_tmp12 + 2080UL;
    __cil_tmp14 = *((struct vmw_dma_buffer **)__cil_tmp13);
    __cil_tmp15 = ! __cil_tmp14;
    __cil_tmp16 = ! __cil_tmp15;
    __cil_tmp17 = ! __cil_tmp16;
    __cil_tmp18 = (long )__cil_tmp17;
    tmp___7 = ldv__builtin_expect(__cil_tmp18, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (118), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  fifo_size = 48UL;
  __cil_tmp19 = (uint32_t )fifo_size;
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp19);
  cmd = (struct __anonstruct_cmd_429___3 *)tmp___8;
  __cil_tmp20 = (void *)0;
  __cil_tmp21 = (unsigned long )__cil_tmp20;
  __cil_tmp22 = (unsigned long )cmd;
  __cil_tmp23 = __cil_tmp22 == __cil_tmp21;
  __cil_tmp24 = ! __cil_tmp23;
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = (long )__cil_tmp25;
  tmp___9 = ldv__builtin_expect(__cil_tmp26, 0L);
  if (tmp___9) {
    drm_err("vmw_sou_fifo_create", "Fifo reserve failed.\n");
    return (-12);
  }
  __cil_tmp27 = (void *)cmd;
  memset(__cil_tmp27, 0, fifo_size);
  *((uint32_t *)cmd) = (uint32_t )34;
  __cil_tmp28 = (unsigned long )cmd;
  __cil_tmp29 = __cil_tmp28 + 4UL;
  *((uint32 *)__cil_tmp29) = (uint32 )44UL;
  __cil_tmp30 = 8;
  __cil_tmp31 = (unsigned long )cmd;
  __cil_tmp32 = __cil_tmp31 + __cil_tmp30;
  __cil_tmp33 = 2032;
  __cil_tmp34 = (unsigned long )sou;
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
  *((uint32 *)__cil_tmp32) = *((unsigned int *)__cil_tmp35);
  __cil_tmp36 = 2032;
  __cil_tmp37 = (unsigned long )sou;
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
  __cil_tmp39 = *((unsigned int *)__cil_tmp38);
  if (__cil_tmp39 == 0U) {
    tmp___10 = 1 << 1;
  } else {
    tmp___10 = 0;
  }
  __cil_tmp40 = 12;
  __cil_tmp41 = (unsigned long )cmd;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  __cil_tmp43 = 1 | tmp___10;
  *((uint32 *)__cil_tmp42) = (uint32 )__cil_tmp43;
  __cil_tmp44 = 16;
  __cil_tmp45 = (unsigned long )cmd;
  __cil_tmp46 = __cil_tmp45 + __cil_tmp44;
  __cil_tmp47 = (unsigned long )mode;
  __cil_tmp48 = __cil_tmp47 + 68UL;
  __cil_tmp49 = *((int *)__cil_tmp48);
  *((uint32 *)__cil_tmp46) = (uint32 )__cil_tmp49;
  __cil_tmp50 = 16;
  __cil_tmp51 = 4UL + __cil_tmp50;
  __cil_tmp52 = (unsigned long )cmd;
  __cil_tmp53 = __cil_tmp52 + __cil_tmp51;
  __cil_tmp54 = (unsigned long )mode;
  __cil_tmp55 = __cil_tmp54 + 88UL;
  __cil_tmp56 = *((int *)__cil_tmp55);
  *((uint32 *)__cil_tmp53) = (uint32 )__cil_tmp56;
  __cil_tmp57 = 2064;
  __cil_tmp58 = (unsigned long )sou;
  __cil_tmp59 = __cil_tmp58 + __cil_tmp57;
  if (*((bool *)__cil_tmp59)) {
    __cil_tmp60 = 24;
    __cil_tmp61 = (unsigned long )cmd;
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
    *((int32 *)__cil_tmp62) = (int32 )x;
    __cil_tmp63 = 24;
    __cil_tmp64 = 4UL + __cil_tmp63;
    __cil_tmp65 = (unsigned long )cmd;
    __cil_tmp66 = __cil_tmp65 + __cil_tmp64;
    *((int32 *)__cil_tmp66) = (int32 )y;
  } else {
    __cil_tmp67 = 24;
    __cil_tmp68 = (unsigned long )cmd;
    __cil_tmp69 = __cil_tmp68 + __cil_tmp67;
    __cil_tmp70 = 2056;
    __cil_tmp71 = (unsigned long )sou;
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
    *((int32 *)__cil_tmp69) = *((int *)__cil_tmp72);
    __cil_tmp73 = 24;
    __cil_tmp74 = 4UL + __cil_tmp73;
    __cil_tmp75 = (unsigned long )cmd;
    __cil_tmp76 = __cil_tmp75 + __cil_tmp74;
    __cil_tmp77 = 2060;
    __cil_tmp78 = (unsigned long )sou;
    __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
    *((int32 *)__cil_tmp76) = *((int *)__cil_tmp79);
  }
  __cil_tmp80 = (unsigned long )sou;
  __cil_tmp81 = __cil_tmp80 + 2080UL;
  __cil_tmp82 = *((struct vmw_dma_buffer **)__cil_tmp81);
  __cil_tmp83 = (struct ttm_buffer_object *)__cil_tmp82;
  __cil_tmp84 = __cil_tmp83;
  __cil_tmp85 = 32;
  __cil_tmp86 = (unsigned long )cmd;
  __cil_tmp87 = __cil_tmp86 + __cil_tmp85;
  __cil_tmp88 = (SVGAGuestPtr *)__cil_tmp87;
  vmw_bo_get_guest_ptr(__cil_tmp84, __cil_tmp88);
  __cil_tmp89 = 36;
  __cil_tmp90 = 4UL + __cil_tmp89;
  __cil_tmp91 = (unsigned long )cmd;
  __cil_tmp92 = __cil_tmp91 + __cil_tmp90;
  __cil_tmp93 = (unsigned long )mode;
  __cil_tmp94 = __cil_tmp93 + 68UL;
  __cil_tmp95 = *((int *)__cil_tmp94);
  __cil_tmp96 = __cil_tmp95 * 4;
  *((uint32 *)__cil_tmp92) = (uint32 )__cil_tmp96;
  __cil_tmp97 = (uint32_t )fifo_size;
  vmw_fifo_commit(dev_priv, __cil_tmp97);
  __cil_tmp98 = (unsigned long )sou;
  __cil_tmp99 = __cil_tmp98 + 2088UL;
  *((bool *)__cil_tmp99) = (bool )1;
  return (0);
}
}
static int vmw_sou_fifo_destroy(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_431___0 *cmd ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  bool __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  bool __cil_tmp32 ;
  bool __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  bool __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;

  {
  __cil_tmp10 = (unsigned long )sou;
  __cil_tmp11 = __cil_tmp10 + 2088UL;
  __cil_tmp12 = *((bool *)__cil_tmp11);
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = ! __cil_tmp13;
  __cil_tmp15 = ! __cil_tmp14;
  __cil_tmp16 = (long )__cil_tmp15;
  tmp___7 = ldv__builtin_expect(__cil_tmp16, 0L);
  if (tmp___7) {
    return (0);
  }
  fifo_size = 8UL;
  __cil_tmp17 = (uint32_t )fifo_size;
  tmp___8 = vmw_fifo_reserve(dev_priv, __cil_tmp17);
  cmd = (struct __anonstruct_cmd_431___0 *)tmp___8;
  __cil_tmp18 = (void *)0;
  __cil_tmp19 = (unsigned long )__cil_tmp18;
  __cil_tmp20 = (unsigned long )cmd;
  __cil_tmp21 = __cil_tmp20 == __cil_tmp19;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___9 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___9) {
    drm_err("vmw_sou_fifo_destroy", "Fifo reserve failed.\n");
    return (-12);
  }
  __cil_tmp25 = (void *)cmd;
  memset(__cil_tmp25, 0, fifo_size);
  *((uint32_t *)cmd) = (uint32_t )35;
  __cil_tmp26 = (unsigned long )cmd;
  __cil_tmp27 = __cil_tmp26 + 4UL;
  __cil_tmp28 = 2032;
  __cil_tmp29 = (unsigned long )sou;
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
  *((uint32 *)__cil_tmp27) = *((unsigned int *)__cil_tmp30);
  __cil_tmp31 = (uint32_t )fifo_size;
  vmw_fifo_commit(dev_priv, __cil_tmp31);
  __cil_tmp32 = (bool )0;
  __cil_tmp33 = (bool )1;
  __cil_tmp34 = (uint32_t )0;
  __cil_tmp35 = (bool )0;
  ret = vmw_fallback_wait(dev_priv, __cil_tmp32, __cil_tmp33, __cil_tmp34, __cil_tmp35,
                          750UL);
  __cil_tmp36 = ret != 0;
  __cil_tmp37 = ! __cil_tmp36;
  __cil_tmp38 = ! __cil_tmp37;
  __cil_tmp39 = (long )__cil_tmp38;
  tmp___10 = ldv__builtin_expect(__cil_tmp39, 0L);
  if (tmp___10) {
    drm_err("vmw_sou_fifo_destroy", "Failed to sync with HW");
  } else {
    __cil_tmp40 = (unsigned long )sou;
    __cil_tmp41 = __cil_tmp40 + 2088UL;
    *((bool *)__cil_tmp41) = (bool )0;
  }
  return (ret);
}
}
static void vmw_sou_backing_free(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ struct ttm_buffer_object *bo ;
  long tmp___7 ;
  void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct vmw_dma_buffer *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct ttm_buffer_object **__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct vmw_dma_buffer *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;

  {
  __cil_tmp5 = (void *)0;
  __cil_tmp6 = (unsigned long )__cil_tmp5;
  __cil_tmp7 = (unsigned long )sou;
  __cil_tmp8 = __cil_tmp7 + 2080UL;
  __cil_tmp9 = *((struct vmw_dma_buffer **)__cil_tmp8);
  __cil_tmp10 = (unsigned long )__cil_tmp9;
  __cil_tmp11 = __cil_tmp10 == __cil_tmp6;
  __cil_tmp12 = ! __cil_tmp11;
  __cil_tmp13 = ! __cil_tmp12;
  __cil_tmp14 = (long )__cil_tmp13;
  tmp___7 = ldv__builtin_expect(__cil_tmp14, 0L);
  if (tmp___7) {
    return;
  }
  __cil_tmp15 = & bo;
  __cil_tmp16 = (unsigned long )sou;
  __cil_tmp17 = __cil_tmp16 + 2080UL;
  __cil_tmp18 = *((struct vmw_dma_buffer **)__cil_tmp17);
  *__cil_tmp15 = (struct ttm_buffer_object *)__cil_tmp18;
  ttm_bo_unref(& bo);
  __cil_tmp19 = (unsigned long )sou;
  __cil_tmp20 = __cil_tmp19 + 2080UL;
  __cil_tmp21 = (void *)0;
  *((struct vmw_dma_buffer **)__cil_tmp20) = (struct vmw_dma_buffer *)__cil_tmp21;
  __cil_tmp22 = (unsigned long )sou;
  __cil_tmp23 = __cil_tmp22 + 2072UL;
  *((unsigned long *)__cil_tmp23) = 0UL;
  return;
}
}
static int vmw_sou_backing_alloc(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                                 unsigned long size ) 
{ int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct vmw_dma_buffer *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_dma_buffer *__cil_tmp27 ;
  bool __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  void *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;

  {
  __cil_tmp8 = (unsigned long )sou;
  __cil_tmp9 = __cil_tmp8 + 2072UL;
  __cil_tmp10 = *((unsigned long *)__cil_tmp9);
  if (__cil_tmp10 == size) {
    return (0);
  }
  __cil_tmp11 = (unsigned long )sou;
  __cil_tmp12 = __cil_tmp11 + 2080UL;
  if (*((struct vmw_dma_buffer **)__cil_tmp12)) {
    vmw_sou_backing_free(dev_priv, sou);
  }
  tmp___7 = kzalloc(416UL, 208U);
  __cil_tmp13 = (unsigned long )sou;
  __cil_tmp14 = __cil_tmp13 + 2080UL;
  *((struct vmw_dma_buffer **)__cil_tmp14) = (struct vmw_dma_buffer *)tmp___7;
  __cil_tmp15 = (void *)0;
  __cil_tmp16 = (unsigned long )__cil_tmp15;
  __cil_tmp17 = (unsigned long )sou;
  __cil_tmp18 = __cil_tmp17 + 2080UL;
  __cil_tmp19 = *((struct vmw_dma_buffer **)__cil_tmp18);
  __cil_tmp20 = (unsigned long )__cil_tmp19;
  __cil_tmp21 = __cil_tmp20 == __cil_tmp16;
  __cil_tmp22 = ! __cil_tmp21;
  __cil_tmp23 = ! __cil_tmp22;
  __cil_tmp24 = (long )__cil_tmp23;
  tmp___8 = ldv__builtin_expect(__cil_tmp24, 0L);
  if (tmp___8) {
    return (-12);
  }
  vmw_overlay_pause_all(dev_priv);
  __cil_tmp25 = (unsigned long )sou;
  __cil_tmp26 = __cil_tmp25 + 2080UL;
  __cil_tmp27 = *((struct vmw_dma_buffer **)__cil_tmp26);
  __cil_tmp28 = (bool )0;
  ret = vmw_dmabuf_init(dev_priv, __cil_tmp27, size, & vmw_vram_ne_placement, __cil_tmp28,
                        & vmw_dmabuf_bo_free);
  vmw_overlay_resume_all(dev_priv);
  __cil_tmp29 = ret != 0;
  __cil_tmp30 = ! __cil_tmp29;
  __cil_tmp31 = ! __cil_tmp30;
  __cil_tmp32 = (long )__cil_tmp31;
  tmp___9 = ldv__builtin_expect(__cil_tmp32, 0L);
  if (tmp___9) {
    __cil_tmp33 = (unsigned long )sou;
    __cil_tmp34 = __cil_tmp33 + 2080UL;
    __cil_tmp35 = (void *)0;
    *((struct vmw_dma_buffer **)__cil_tmp34) = (struct vmw_dma_buffer *)__cil_tmp35;
  } else {
    __cil_tmp36 = (unsigned long )sou;
    __cil_tmp37 = __cil_tmp36 + 2072UL;
    *((unsigned long *)__cil_tmp37) = size;
  }
  return (ret);
}
}
static int vmw_sou_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_screen_object_unit *sou ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int ret ;
  struct drm_crtc *__mptr ;
  struct drm_framebuffer *__mptr___0 ;
  long tmp___7 ;
  long tmp___8 ;
  size_t size ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct drm_crtc *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct vmw_screen_object_unit *__cil_tmp23 ;
  struct drm_crtc *__cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  struct drm_framebuffer *__cil_tmp32 ;
  struct vmw_framebuffer *__cil_tmp33 ;
  struct drm_framebuffer *__cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  struct drm_device *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  size_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  size_t __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct drm_connector *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_connector **__cil_tmp53 ;
  struct drm_connector **__cil_tmp54 ;
  struct drm_connector *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct drm_connector **__cil_tmp59 ;
  struct drm_connector **__cil_tmp60 ;
  struct drm_connector *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  struct drm_connector *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  struct vmw_screen_object_display *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  struct vmw_screen_object_display *__cil_tmp76 ;
  unsigned int __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  struct vmw_screen_object_display *__cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct vmw_framebuffer *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  size_t __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  struct drm_display_mode *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  struct drm_framebuffer *__cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  void *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  void *__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned int __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  int __cil_tmp129 ;
  uint32_t __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  uint32_t __cil_tmp133 ;
  uint32_t __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned int __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  int __cil_tmp140 ;
  uint32_t __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  uint32_t __cil_tmp144 ;
  uint32_t __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  int __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  int __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  int __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  int __cil_tmp159 ;
  int __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  struct vmw_dma_buffer *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  int __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  int __cil_tmp172 ;
  int __cil_tmp173 ;
  int __cil_tmp174 ;
  int __cil_tmp175 ;
  int __cil_tmp176 ;
  int __cil_tmp177 ;
  long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  uint32_t __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  int __cil_tmp185 ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  void *__cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  void *__cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  void *__cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned long __cil_tmp215 ;
  uint32_t __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  uint32_t __cil_tmp221 ;

  {
  ret = 0;
  if (! set) {
    return (-22);
  }
  __cil_tmp18 = (unsigned long )set;
  __cil_tmp19 = __cil_tmp18 + 24UL;
  __cil_tmp20 = *((struct drm_crtc **)__cil_tmp19);
  if (! __cil_tmp20) {
    return (-22);
  }
  __cil_tmp21 = (unsigned long )set;
  __cil_tmp22 = __cil_tmp21 + 24UL;
  crtc = *((struct drm_crtc **)__cil_tmp22);
  __mptr = crtc;
  __cil_tmp23 = (struct vmw_screen_object_unit *)0;
  __cil_tmp24 = (struct drm_crtc *)__cil_tmp23;
  __cil_tmp25 = (unsigned int )__cil_tmp24;
  __cil_tmp26 = (char *)__mptr;
  __cil_tmp27 = __cil_tmp26 - __cil_tmp25;
  sou = (struct vmw_screen_object_unit *)__cil_tmp27;
  __cil_tmp28 = (unsigned long )set;
  __cil_tmp29 = __cil_tmp28 + 16UL;
  if (*((struct drm_framebuffer **)__cil_tmp29)) {
    __cil_tmp30 = (unsigned long )set;
    __cil_tmp31 = __cil_tmp30 + 16UL;
    __cil_tmp32 = *((struct drm_framebuffer **)__cil_tmp31);
    __mptr___0 = __cil_tmp32;
    __cil_tmp33 = (struct vmw_framebuffer *)0;
    __cil_tmp34 = (struct drm_framebuffer *)__cil_tmp33;
    __cil_tmp35 = (unsigned int )__cil_tmp34;
    __cil_tmp36 = (char *)__mptr___0;
    __cil_tmp37 = __cil_tmp36 - __cil_tmp35;
    vfb = (struct vmw_framebuffer *)__cil_tmp37;
  } else {
    __cil_tmp38 = (void *)0;
    vfb = (struct vmw_framebuffer *)__cil_tmp38;
  }
  __cil_tmp39 = *((struct drm_device **)crtc);
  dev_priv = vmw_priv(__cil_tmp39);
  __cil_tmp40 = (unsigned long )set;
  __cil_tmp41 = __cil_tmp40 + 56UL;
  __cil_tmp42 = *((size_t *)__cil_tmp41);
  if (__cil_tmp42 > 1UL) {
    drm_err("vmw_sou_crtc_set_config", "to many connectors\n");
    return (-22);
  }
  __cil_tmp43 = (unsigned long )set;
  __cil_tmp44 = __cil_tmp43 + 56UL;
  __cil_tmp45 = *((size_t *)__cil_tmp44);
  if (__cil_tmp45 == 1UL) {
    __cil_tmp46 = 616;
    __cil_tmp47 = (unsigned long )sou;
    __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
    __cil_tmp49 = (struct drm_connector *)__cil_tmp48;
    __cil_tmp50 = (unsigned long )__cil_tmp49;
    __cil_tmp51 = (unsigned long )set;
    __cil_tmp52 = __cil_tmp51 + 48UL;
    __cil_tmp53 = *((struct drm_connector ***)__cil_tmp52);
    __cil_tmp54 = __cil_tmp53 + 0;
    __cil_tmp55 = *__cil_tmp54;
    __cil_tmp56 = (unsigned long )__cil_tmp55;
    if (__cil_tmp56 != __cil_tmp50) {
      __cil_tmp57 = (unsigned long )set;
      __cil_tmp58 = __cil_tmp57 + 48UL;
      __cil_tmp59 = *((struct drm_connector ***)__cil_tmp58);
      __cil_tmp60 = __cil_tmp59 + 0;
      __cil_tmp61 = *__cil_tmp60;
      __cil_tmp62 = 616;
      __cil_tmp63 = (unsigned long )sou;
      __cil_tmp64 = __cil_tmp63 + __cil_tmp62;
      __cil_tmp65 = (struct drm_connector *)__cil_tmp64;
      drm_err("vmw_sou_crtc_set_config", "connector doesn\'t match %p %p\n", __cil_tmp61,
              __cil_tmp65);
      return (-22);
    }
  }
  __cil_tmp66 = 2064;
  __cil_tmp67 = (unsigned long )sou;
  __cil_tmp68 = __cil_tmp67 + __cil_tmp66;
  if (*((bool *)__cil_tmp68)) {
    __cil_tmp69 = (unsigned long )dev_priv;
    __cil_tmp70 = __cil_tmp69 + 2616UL;
    __cil_tmp71 = *((struct vmw_screen_object_display **)__cil_tmp70);
    __cil_tmp72 = (unsigned long )__cil_tmp71;
    __cil_tmp73 = __cil_tmp72 + 8UL;
    if (*((struct vmw_framebuffer **)__cil_tmp73)) {
      if (vfb) {
        __cil_tmp74 = (unsigned long )dev_priv;
        __cil_tmp75 = __cil_tmp74 + 2616UL;
        __cil_tmp76 = *((struct vmw_screen_object_display **)__cil_tmp75);
        __cil_tmp77 = *((unsigned int *)__cil_tmp76);
        if (__cil_tmp77 == 1U) {
          __cil_tmp78 = (unsigned long )sou;
          __cil_tmp79 = __cil_tmp78 + 2089UL;
          if (! *((bool *)__cil_tmp79)) {
            goto _L;
          }
        } else {
          _L: 
          __cil_tmp80 = (unsigned long )vfb;
          __cil_tmp81 = (unsigned long )dev_priv;
          __cil_tmp82 = __cil_tmp81 + 2616UL;
          __cil_tmp83 = *((struct vmw_screen_object_display **)__cil_tmp82);
          __cil_tmp84 = (unsigned long )__cil_tmp83;
          __cil_tmp85 = __cil_tmp84 + 8UL;
          __cil_tmp86 = *((struct vmw_framebuffer **)__cil_tmp85);
          __cil_tmp87 = (unsigned long )__cil_tmp86;
          if (__cil_tmp87 != __cil_tmp80) {
            drm_err("vmw_sou_crtc_set_config", "Multiple framebuffers not supported\n");
            return (-22);
          }
        }
      }
    }
  }
  __cil_tmp88 = 616;
  __cil_tmp89 = (unsigned long )sou;
  __cil_tmp90 = __cil_tmp89 + __cil_tmp88;
  connector = (struct drm_connector *)__cil_tmp90;
  __cil_tmp91 = 544;
  __cil_tmp92 = (unsigned long )sou;
  __cil_tmp93 = __cil_tmp92 + __cil_tmp91;
  encoder = (struct drm_encoder *)__cil_tmp93;
  __cil_tmp94 = (unsigned long )set;
  __cil_tmp95 = __cil_tmp94 + 56UL;
  __cil_tmp96 = *((size_t *)__cil_tmp95);
  if (__cil_tmp96 == 0UL) {
    goto _L___0;
  } else {
    __cil_tmp97 = (unsigned long )set;
    __cil_tmp98 = __cil_tmp97 + 32UL;
    __cil_tmp99 = *((struct drm_display_mode **)__cil_tmp98);
    if (! __cil_tmp99) {
      goto _L___0;
    } else {
      __cil_tmp100 = (unsigned long )set;
      __cil_tmp101 = __cil_tmp100 + 16UL;
      __cil_tmp102 = *((struct drm_framebuffer **)__cil_tmp101);
      if (! __cil_tmp102) {
        _L___0: 
        ret = vmw_sou_fifo_destroy(dev_priv, sou);
        __cil_tmp103 = ret != 0;
        __cil_tmp104 = ! __cil_tmp103;
        __cil_tmp105 = ! __cil_tmp104;
        __cil_tmp106 = (long )__cil_tmp105;
        tmp___7 = ldv__builtin_expect(__cil_tmp106, 0L);
        if (tmp___7) {
          return (ret);
        }
        __cil_tmp107 = (unsigned long )connector;
        __cil_tmp108 = __cil_tmp107 + 1208UL;
        __cil_tmp109 = (void *)0;
        *((struct drm_encoder **)__cil_tmp108) = (struct drm_encoder *)__cil_tmp109;
        __cil_tmp110 = (unsigned long )encoder;
        __cil_tmp111 = __cil_tmp110 + 48UL;
        __cil_tmp112 = (void *)0;
        *((struct drm_crtc **)__cil_tmp111) = (struct drm_crtc *)__cil_tmp112;
        __cil_tmp113 = (unsigned long )crtc;
        __cil_tmp114 = __cil_tmp113 + 32UL;
        __cil_tmp115 = (void *)0;
        *((struct drm_framebuffer **)__cil_tmp114) = (struct drm_framebuffer *)__cil_tmp115;
        __cil_tmp116 = (unsigned long )crtc;
        __cil_tmp117 = __cil_tmp116 + 480UL;
        *((int *)__cil_tmp117) = 0;
        __cil_tmp118 = (unsigned long )crtc;
        __cil_tmp119 = __cil_tmp118 + 484UL;
        *((int *)__cil_tmp119) = 0;
        vmw_sou_del_active(dev_priv, sou);
        vmw_sou_backing_free(dev_priv, sou);
        return (0);
      }
    }
  }
  __cil_tmp120 = (unsigned long )set;
  __cil_tmp121 = __cil_tmp120 + 32UL;
  mode = *((struct drm_display_mode **)__cil_tmp121);
  __cil_tmp122 = (unsigned long )set;
  __cil_tmp123 = __cil_tmp122 + 16UL;
  fb = *((struct drm_framebuffer **)__cil_tmp123);
  __cil_tmp124 = (unsigned long )fb;
  __cil_tmp125 = __cil_tmp124 + 72UL;
  __cil_tmp126 = *((unsigned int *)__cil_tmp125);
  __cil_tmp127 = (unsigned long )mode;
  __cil_tmp128 = __cil_tmp127 + 68UL;
  __cil_tmp129 = *((int *)__cil_tmp128);
  __cil_tmp130 = (uint32_t )__cil_tmp129;
  __cil_tmp131 = (unsigned long )set;
  __cil_tmp132 = __cil_tmp131 + 40UL;
  __cil_tmp133 = *((uint32_t *)__cil_tmp132);
  __cil_tmp134 = __cil_tmp133 + __cil_tmp130;
  if (__cil_tmp134 > __cil_tmp126) {
    drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
    return (-22);
  } else {
    __cil_tmp135 = (unsigned long )fb;
    __cil_tmp136 = __cil_tmp135 + 76UL;
    __cil_tmp137 = *((unsigned int *)__cil_tmp136);
    __cil_tmp138 = (unsigned long )mode;
    __cil_tmp139 = __cil_tmp138 + 88UL;
    __cil_tmp140 = *((int *)__cil_tmp139);
    __cil_tmp141 = (uint32_t )__cil_tmp140;
    __cil_tmp142 = (unsigned long )set;
    __cil_tmp143 = __cil_tmp142 + 44UL;
    __cil_tmp144 = *((uint32_t *)__cil_tmp143);
    __cil_tmp145 = __cil_tmp144 + __cil_tmp141;
    if (__cil_tmp145 > __cil_tmp137) {
      drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
      return (-22);
    }
  }
  vmw_fb_off(dev_priv);
  __cil_tmp146 = 116;
  __cil_tmp147 = (unsigned long )crtc;
  __cil_tmp148 = __cil_tmp147 + __cil_tmp146;
  __cil_tmp149 = *((int *)__cil_tmp148);
  __cil_tmp150 = (unsigned long )mode;
  __cil_tmp151 = __cil_tmp150 + 68UL;
  __cil_tmp152 = *((int *)__cil_tmp151);
  if (__cil_tmp152 != __cil_tmp149) {
    goto _L___1;
  } else {
    __cil_tmp153 = 136;
    __cil_tmp154 = (unsigned long )crtc;
    __cil_tmp155 = __cil_tmp154 + __cil_tmp153;
    __cil_tmp156 = *((int *)__cil_tmp155);
    __cil_tmp157 = (unsigned long )mode;
    __cil_tmp158 = __cil_tmp157 + 88UL;
    __cil_tmp159 = *((int *)__cil_tmp158);
    if (__cil_tmp159 != __cil_tmp156) {
      _L___1: 
      ret = vmw_sou_fifo_destroy(dev_priv, sou);
      __cil_tmp160 = ret != 0;
      __cil_tmp161 = ! __cil_tmp160;
      __cil_tmp162 = ! __cil_tmp161;
      __cil_tmp163 = (long )__cil_tmp162;
      tmp___8 = ldv__builtin_expect(__cil_tmp163, 0L);
      if (tmp___8) {
        return (ret);
      }
      vmw_sou_backing_free(dev_priv, sou);
    }
  }
  __cil_tmp164 = (unsigned long )sou;
  __cil_tmp165 = __cil_tmp164 + 2080UL;
  __cil_tmp166 = *((struct vmw_dma_buffer **)__cil_tmp165);
  if (! __cil_tmp166) {
    __cil_tmp167 = (unsigned long )mode;
    __cil_tmp168 = __cil_tmp167 + 88UL;
    __cil_tmp169 = *((int *)__cil_tmp168);
    __cil_tmp170 = (unsigned long )mode;
    __cil_tmp171 = __cil_tmp170 + 68UL;
    __cil_tmp172 = *((int *)__cil_tmp171);
    __cil_tmp173 = __cil_tmp172 * __cil_tmp169;
    __cil_tmp174 = __cil_tmp173 * 4;
    size = (size_t )__cil_tmp174;
    ret = vmw_sou_backing_alloc(dev_priv, sou, size);
    __cil_tmp175 = ret != 0;
    __cil_tmp176 = ! __cil_tmp175;
    __cil_tmp177 = ! __cil_tmp176;
    __cil_tmp178 = (long )__cil_tmp177;
    tmp___9 = ldv__builtin_expect(__cil_tmp178, 0L);
    if (tmp___9) {
      return (ret);
    }
  }
  __cil_tmp179 = (unsigned long )set;
  __cil_tmp180 = __cil_tmp179 + 40UL;
  __cil_tmp181 = *((uint32_t *)__cil_tmp180);
  __cil_tmp182 = (unsigned long )set;
  __cil_tmp183 = __cil_tmp182 + 44UL;
  __cil_tmp184 = *((uint32_t *)__cil_tmp183);
  ret = vmw_sou_fifo_create(dev_priv, sou, __cil_tmp181, __cil_tmp184, mode);
  __cil_tmp185 = ret != 0;
  __cil_tmp186 = ! __cil_tmp185;
  __cil_tmp187 = ! __cil_tmp186;
  __cil_tmp188 = (long )__cil_tmp187;
  tmp___10 = ldv__builtin_expect(__cil_tmp188, 0L);
  if (tmp___10) {
    __cil_tmp189 = (unsigned long )sou;
    __cil_tmp190 = __cil_tmp189 + 2088UL;
    if (*((bool *)__cil_tmp190)) {
      return (ret);
    }
    __cil_tmp191 = (unsigned long )connector;
    __cil_tmp192 = __cil_tmp191 + 1208UL;
    __cil_tmp193 = (void *)0;
    *((struct drm_encoder **)__cil_tmp192) = (struct drm_encoder *)__cil_tmp193;
    __cil_tmp194 = (unsigned long )encoder;
    __cil_tmp195 = __cil_tmp194 + 48UL;
    __cil_tmp196 = (void *)0;
    *((struct drm_crtc **)__cil_tmp195) = (struct drm_crtc *)__cil_tmp196;
    __cil_tmp197 = (unsigned long )crtc;
    __cil_tmp198 = __cil_tmp197 + 32UL;
    __cil_tmp199 = (void *)0;
    *((struct drm_framebuffer **)__cil_tmp198) = (struct drm_framebuffer *)__cil_tmp199;
    __cil_tmp200 = (unsigned long )crtc;
    __cil_tmp201 = __cil_tmp200 + 480UL;
    *((int *)__cil_tmp201) = 0;
    __cil_tmp202 = (unsigned long )crtc;
    __cil_tmp203 = __cil_tmp202 + 484UL;
    *((int *)__cil_tmp203) = 0;
    return (ret);
  }
  vmw_sou_add_active(dev_priv, sou, vfb);
  __cil_tmp204 = (unsigned long )connector;
  __cil_tmp205 = __cil_tmp204 + 1208UL;
  *((struct drm_encoder **)__cil_tmp205) = encoder;
  __cil_tmp206 = (unsigned long )encoder;
  __cil_tmp207 = __cil_tmp206 + 48UL;
  *((struct drm_crtc **)__cil_tmp207) = crtc;
  __cil_tmp208 = (unsigned long )crtc;
  __cil_tmp209 = __cil_tmp208 + 48UL;
  *((struct drm_display_mode *)__cil_tmp209) = *mode;
  __cil_tmp210 = (unsigned long )crtc;
  __cil_tmp211 = __cil_tmp210 + 32UL;
  *((struct drm_framebuffer **)__cil_tmp211) = fb;
  __cil_tmp212 = (unsigned long )crtc;
  __cil_tmp213 = __cil_tmp212 + 480UL;
  __cil_tmp214 = (unsigned long )set;
  __cil_tmp215 = __cil_tmp214 + 40UL;
  __cil_tmp216 = *((uint32_t *)__cil_tmp215);
  *((int *)__cil_tmp213) = (int )__cil_tmp216;
  __cil_tmp217 = (unsigned long )crtc;
  __cil_tmp218 = __cil_tmp217 + 484UL;
  __cil_tmp219 = (unsigned long )set;
  __cil_tmp220 = __cil_tmp219 + 44UL;
  __cil_tmp221 = *((uint32_t *)__cil_tmp220);
  *((int *)__cil_tmp218) = (int )__cil_tmp221;
  return (0);
}
}
static struct drm_crtc_funcs vmw_screen_object_crtc_funcs  = 
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, (void (*)(struct drm_crtc *crtc ))0,
    & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move, & vmw_du_crtc_gamma_set,
    & vmw_sou_crtc_destroy, & vmw_sou_crtc_set_config, & vmw_du_page_flip};
static void vmw_sou_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_screen_object_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_encoder *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_screen_object_unit *__cil_tmp11 ;

  {
  __mptr = encoder;
  __cil_tmp3 = 544;
  __cil_tmp4 = (struct vmw_screen_object_unit *)0;
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
  __cil_tmp7 = (struct drm_encoder *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  __cil_tmp11 = (struct vmw_screen_object_unit *)__cil_tmp10;
  vmw_sou_destroy(__cil_tmp11);
  return;
}
}
static struct drm_encoder_funcs vmw_screen_object_encoder_funcs  =    {(void (*)(struct drm_encoder *encoder ))0, & vmw_sou_encoder_destroy};
static void vmw_sou_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector *__mptr ;
  unsigned long __cil_tmp3 ;
  struct vmw_screen_object_unit *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct drm_connector *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct vmw_screen_object_unit *__cil_tmp11 ;

  {
  __mptr = connector;
  __cil_tmp3 = 616;
  __cil_tmp4 = (struct vmw_screen_object_unit *)0;
  __cil_tmp5 = (unsigned long )__cil_tmp4;
  __cil_tmp6 = __cil_tmp5 + __cil_tmp3;
  __cil_tmp7 = (struct drm_connector *)__cil_tmp6;
  __cil_tmp8 = (unsigned int )__cil_tmp7;
  __cil_tmp9 = (char *)__mptr;
  __cil_tmp10 = __cil_tmp9 - __cil_tmp8;
  __cil_tmp11 = (struct vmw_screen_object_unit *)__cil_tmp10;
  vmw_sou_destroy(__cil_tmp11);
  return;
}
}
static struct drm_connector_funcs vmw_legacy_connector_funcs___0  = 
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    (void (*)(struct drm_connector *connector ))0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes,
    & vmw_du_connector_set_property, & vmw_sou_connector_destroy, (void (*)(struct drm_connector *connector ))0};
static int vmw_sou_init(struct vmw_private *dev_priv ,
                        unsigned int unit ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp___7 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  struct drm_connector_funcs *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  bool __cil_tmp46 ;
  struct drm_encoder_funcs *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct drm_crtc_funcs *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct drm_property *__cil_tmp57 ;
  uint64_t __cil_tmp58 ;

  {
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp10);
  tmp___7 = kzalloc(2096UL, 208U);
  sou = (struct vmw_screen_object_unit *)tmp___7;
  if (! sou) {
    return (-12);
  }
  __cil_tmp11 = 2032;
  __cil_tmp12 = (unsigned long )sou;
  __cil_tmp13 = __cil_tmp12 + __cil_tmp11;
  *((unsigned int *)__cil_tmp13) = unit;
  crtc = (struct drm_crtc *)sou;
  __cil_tmp14 = 544;
  __cil_tmp15 = (unsigned long )sou;
  __cil_tmp16 = __cil_tmp15 + __cil_tmp14;
  encoder = (struct drm_encoder *)__cil_tmp16;
  __cil_tmp17 = 616;
  __cil_tmp18 = (unsigned long )sou;
  __cil_tmp19 = __cil_tmp18 + __cil_tmp17;
  connector = (struct drm_connector *)__cil_tmp19;
  __cil_tmp20 = (unsigned long )sou;
  __cil_tmp21 = __cil_tmp20 + 2089UL;
  *((bool *)__cil_tmp21) = (bool )0;
  __cil_tmp22 = 2044;
  __cil_tmp23 = (unsigned long )sou;
  __cil_tmp24 = __cil_tmp23 + __cil_tmp22;
  __cil_tmp25 = unit == 0U;
  *((bool *)__cil_tmp24) = (bool )__cil_tmp25;
  __cil_tmp26 = 2036;
  __cil_tmp27 = (unsigned long )sou;
  __cil_tmp28 = __cil_tmp27 + __cil_tmp26;
  __cil_tmp29 = (unsigned long )dev_priv;
  __cil_tmp30 = __cil_tmp29 + 2132UL;
  *((unsigned int *)__cil_tmp28) = *((uint32_t *)__cil_tmp30);
  __cil_tmp31 = 2040;
  __cil_tmp32 = (unsigned long )sou;
  __cil_tmp33 = __cil_tmp32 + __cil_tmp31;
  __cil_tmp34 = (unsigned long )dev_priv;
  __cil_tmp35 = __cil_tmp34 + 2136UL;
  *((unsigned int *)__cil_tmp33) = *((uint32_t *)__cil_tmp35);
  __cil_tmp36 = 2048;
  __cil_tmp37 = (unsigned long )sou;
  __cil_tmp38 = __cil_tmp37 + __cil_tmp36;
  __cil_tmp39 = (void *)0;
  *((struct drm_display_mode **)__cil_tmp38) = (struct drm_display_mode *)__cil_tmp39;
  __cil_tmp40 = 2064;
  __cil_tmp41 = (unsigned long )sou;
  __cil_tmp42 = __cil_tmp41 + __cil_tmp40;
  *((bool *)__cil_tmp42) = (bool )1;
  __cil_tmp43 = & vmw_legacy_connector_funcs___0;
  drm_connector_init(dev, connector, __cil_tmp43, 15);
  __cil_tmp44 = (unsigned long )connector;
  __cil_tmp45 = __cil_tmp44 + 840UL;
  __cil_tmp46 = (bool )1;
  *((enum drm_connector_status *)__cil_tmp45) = vmw_du_connector_detect(connector,
                                                                        __cil_tmp46);
  __cil_tmp47 = & vmw_screen_object_encoder_funcs;
  drm_encoder_init(dev, encoder, __cil_tmp47, 5);
  drm_mode_connector_attach_encoder(connector, encoder);
  __cil_tmp48 = (unsigned long )encoder;
  __cil_tmp49 = __cil_tmp48 + 36UL;
  __cil_tmp50 = 1 << unit;
  *((uint32_t *)__cil_tmp49) = (uint32_t )__cil_tmp50;
  __cil_tmp51 = (unsigned long )encoder;
  __cil_tmp52 = __cil_tmp51 + 40UL;
  *((uint32_t *)__cil_tmp52) = (uint32_t )0;
  __cil_tmp53 = & vmw_screen_object_crtc_funcs;
  drm_crtc_init(dev, crtc, __cil_tmp53);
  drm_mode_crtc_set_gamma_size(crtc, 256);
  __cil_tmp54 = 1800;
  __cil_tmp55 = (unsigned long )dev;
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
  __cil_tmp57 = *((struct drm_property **)__cil_tmp56);
  __cil_tmp58 = (uint64_t )1;
  drm_connector_attach_property(connector, __cil_tmp57, __cil_tmp58);
  return (0);
}
}
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct vmw_screen_object_display *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct vmw_screen_object_display *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct vmw_screen_object_display *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  long __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct vmw_screen_object_display *__cil_tmp49 ;
  void *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  void *__cil_tmp53 ;

  {
  __cil_tmp9 = (unsigned long )dev_priv;
  __cil_tmp10 = __cil_tmp9 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp10);
  __cil_tmp11 = (unsigned long )dev_priv;
  __cil_tmp12 = __cil_tmp11 + 2616UL;
  if (*((struct vmw_screen_object_display **)__cil_tmp12)) {
    printk("<6>[drm] sou system already on\n");
    return (-22);
  }
  __cil_tmp13 = 1 << 9;
  __cil_tmp14 = (unsigned int )__cil_tmp13;
  __cil_tmp15 = 1892;
  __cil_tmp16 = (unsigned long )dev_priv;
  __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
  __cil_tmp18 = *((uint32_t *)__cil_tmp17);
  __cil_tmp19 = __cil_tmp18 & __cil_tmp14;
  if (! __cil_tmp19) {
    printk("<6>[drm] Not using screen objects, missing cap SCREEN_OBJECT_2\n");
    return (-38);
  }
  ret = -12;
  tmp___7 = kmalloc(16UL, 208U);
  __cil_tmp20 = (unsigned long )dev_priv;
  __cil_tmp21 = __cil_tmp20 + 2616UL;
  *((struct vmw_screen_object_display **)__cil_tmp21) = (struct vmw_screen_object_display *)tmp___7;
  __cil_tmp22 = (unsigned long )dev_priv;
  __cil_tmp23 = __cil_tmp22 + 2616UL;
  __cil_tmp24 = *((struct vmw_screen_object_display **)__cil_tmp23);
  __cil_tmp25 = ! __cil_tmp24;
  __cil_tmp26 = ! __cil_tmp25;
  __cil_tmp27 = ! __cil_tmp26;
  __cil_tmp28 = (long )__cil_tmp27;
  tmp___8 = ldv__builtin_expect(__cil_tmp28, 0L);
  if (tmp___8) {
    goto err_no_mem;
  }
  __cil_tmp29 = (unsigned long )dev_priv;
  __cil_tmp30 = __cil_tmp29 + 2616UL;
  __cil_tmp31 = *((struct vmw_screen_object_display **)__cil_tmp30);
  *((unsigned int *)__cil_tmp31) = 0U;
  __cil_tmp32 = (unsigned long )dev_priv;
  __cil_tmp33 = __cil_tmp32 + 2616UL;
  __cil_tmp34 = *((struct vmw_screen_object_display **)__cil_tmp33);
  __cil_tmp35 = (unsigned long )__cil_tmp34;
  __cil_tmp36 = __cil_tmp35 + 8UL;
  __cil_tmp37 = (void *)0;
  *((struct vmw_framebuffer **)__cil_tmp36) = (struct vmw_framebuffer *)__cil_tmp37;
  ret = drm_vblank_init(dev, 8);
  __cil_tmp38 = ret != 0;
  __cil_tmp39 = ! __cil_tmp38;
  __cil_tmp40 = ! __cil_tmp39;
  __cil_tmp41 = (long )__cil_tmp40;
  tmp___9 = ldv__builtin_expect(__cil_tmp41, 0L);
  if (tmp___9) {
    goto err_free;
  }
  ret = drm_mode_create_dirty_info_property(dev);
  __cil_tmp42 = ret != 0;
  __cil_tmp43 = ! __cil_tmp42;
  __cil_tmp44 = ! __cil_tmp43;
  __cil_tmp45 = (long )__cil_tmp44;
  tmp___10 = ldv__builtin_expect(__cil_tmp45, 0L);
  if (tmp___10) {
    goto err_vblank_cleanup;
  }
  i = 0;
  while (1) {

    if (! (i < 8)) {
      goto while_break;
    }
    __cil_tmp46 = (unsigned int )i;
    vmw_sou_init(dev_priv, __cil_tmp46);
    i ++;
  }
  while_break: 
  printk("<6>[drm] Screen objects system initialized\n");
  return (0);
  err_vblank_cleanup: 
  drm_vblank_cleanup(dev);
  err_free: 
  __cil_tmp47 = (unsigned long )dev_priv;
  __cil_tmp48 = __cil_tmp47 + 2616UL;
  __cil_tmp49 = *((struct vmw_screen_object_display **)__cil_tmp48);
  __cil_tmp50 = (void *)__cil_tmp49;
  kfree(__cil_tmp50);
  __cil_tmp51 = (unsigned long )dev_priv;
  __cil_tmp52 = __cil_tmp51 + 2616UL;
  __cil_tmp53 = (void *)0;
  *((struct vmw_screen_object_display **)__cil_tmp52) = (struct vmw_screen_object_display *)__cil_tmp53;
  err_no_mem: 
  return (ret);
}
}
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct vmw_screen_object_display *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct vmw_screen_object_display *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  __cil_tmp3 = (unsigned long )dev_priv;
  __cil_tmp4 = __cil_tmp3 + 2088UL;
  dev = *((struct drm_device **)__cil_tmp4);
  __cil_tmp5 = (unsigned long )dev_priv;
  __cil_tmp6 = __cil_tmp5 + 2616UL;
  __cil_tmp7 = *((struct vmw_screen_object_display **)__cil_tmp6);
  if (! __cil_tmp7) {
    return (-38);
  }
  drm_vblank_cleanup(dev);
  __cil_tmp8 = (unsigned long )dev_priv;
  __cil_tmp9 = __cil_tmp8 + 2616UL;
  __cil_tmp10 = *((struct vmw_screen_object_display **)__cil_tmp9);
  __cil_tmp11 = (void *)__cil_tmp10;
  kfree(__cil_tmp11);
  return (0);
}
}
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc *__mptr ;
  struct vmw_screen_object_unit *__cil_tmp5 ;
  struct drm_crtc *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  bool __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct vmw_screen_object_display *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
  __mptr = crtc;
  __cil_tmp5 = (struct vmw_screen_object_unit *)0;
  __cil_tmp6 = (struct drm_crtc *)__cil_tmp5;
  __cil_tmp7 = (unsigned int )__cil_tmp6;
  __cil_tmp8 = (char *)__mptr;
  __cil_tmp9 = __cil_tmp8 - __cil_tmp7;
  sou = (struct vmw_screen_object_unit *)__cil_tmp9;
  __cil_tmp10 = 2064;
  __cil_tmp11 = (unsigned long )sou;
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
  __cil_tmp13 = *((bool *)__cil_tmp12);
  if (! __cil_tmp13) {
    return ((bool )1);
  }
  __cil_tmp14 = (unsigned long )dev_priv;
  __cil_tmp15 = __cil_tmp14 + 2616UL;
  __cil_tmp16 = *((struct vmw_screen_object_display **)__cil_tmp15);
  __cil_tmp17 = *((unsigned int *)__cil_tmp16);
  if (__cil_tmp17 != 1U) {
    return ((bool )0);
  }
  return ((bool )1);
}
}
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc *__mptr ;
  long tmp___7 ;
  struct drm_framebuffer *__mptr___0 ;
  struct vmw_screen_object_unit *__cil_tmp7 ;
  struct drm_crtc *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  bool __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct drm_framebuffer *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct vmw_screen_object_display *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct vmw_framebuffer *__cil_tmp30 ;
  struct drm_framebuffer *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  __mptr = crtc;
  __cil_tmp7 = (struct vmw_screen_object_unit *)0;
  __cil_tmp8 = (struct drm_crtc *)__cil_tmp7;
  __cil_tmp9 = (unsigned int )__cil_tmp8;
  __cil_tmp10 = (char *)__mptr;
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
  sou = (struct vmw_screen_object_unit *)__cil_tmp11;
  while (1) {
    __cil_tmp12 = 2064;
    __cil_tmp13 = (unsigned long )sou;
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
    __cil_tmp15 = *((bool *)__cil_tmp14);
    __cil_tmp16 = ! __cil_tmp15;
    __cil_tmp17 = ! __cil_tmp16;
    __cil_tmp18 = ! __cil_tmp17;
    __cil_tmp19 = (long )__cil_tmp18;
    tmp___7 = ldv__builtin_expect(__cil_tmp19, 0L);
    if (tmp___7) {
      while (1) {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--32_1--X--cpachecker/linux-3.4/csd_deg_dscv/6447/dscv_tempdir/dscv/ri/32_1/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c"),
                             "i" (568), "i" (12UL));
        while (1) {

        }

        goto while_break___0;
      }
      while_break___0: ;
    }
    goto while_break;
  }
  while_break: 
  __cil_tmp20 = 32;
  __cil_tmp21 = __cil_tmp20;
  __cil_tmp22 = (unsigned long )sou;
  __cil_tmp23 = __cil_tmp22 + __cil_tmp21;
  __cil_tmp24 = *((struct drm_framebuffer **)__cil_tmp23);
  __mptr___0 = __cil_tmp24;
  __cil_tmp25 = (unsigned long )dev_priv;
  __cil_tmp26 = __cil_tmp25 + 2616UL;
  __cil_tmp27 = *((struct vmw_screen_object_display **)__cil_tmp26);
  __cil_tmp28 = (unsigned long )__cil_tmp27;
  __cil_tmp29 = __cil_tmp28 + 8UL;
  __cil_tmp30 = (struct vmw_framebuffer *)0;
  __cil_tmp31 = (struct drm_framebuffer *)__cil_tmp30;
  __cil_tmp32 = (unsigned int )__cil_tmp31;
  __cil_tmp33 = (char *)__mptr___0;
  __cil_tmp34 = __cil_tmp33 - __cil_tmp32;
  *((struct vmw_framebuffer **)__cil_tmp29) = (struct vmw_framebuffer *)__cil_tmp34;
  return;
}
}
void ldv_main17_sequence_infinite_withcheck_stateful(void) 
{ struct drm_crtc *var_group1 ;
  struct drm_mode_set *var_group2 ;
  struct drm_encoder *var_group3 ;
  struct drm_connector *var_group4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___8 = __VERIFIER_nondet_int();
    if (! tmp___8) {
      goto while_break;
    }
    tmp___7 = __VERIFIER_nondet_int();
    if (tmp___7 == 0) {
      goto case_0;
    } else
    if (tmp___7 == 1) {
      goto case_1;
    } else
    if (tmp___7 == 2) {
      goto case_2;
    } else
    if (tmp___7 == 3) {
      goto case_3;
    } else {
      goto switch_default;
      if (0) {
        case_0: 
        vmw_sou_crtc_destroy(var_group1);
        goto switch_break;
        case_1: 
        vmw_sou_crtc_set_config(var_group2);
        goto switch_break;
        case_2: 
        vmw_sou_encoder_destroy(var_group3);
        goto switch_break;
        case_3: 
        vmw_sou_connector_destroy(var_group4);
        goto switch_break;
        switch_default: 
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break: 
  ldv_check_final_state();
  return;
}
}
