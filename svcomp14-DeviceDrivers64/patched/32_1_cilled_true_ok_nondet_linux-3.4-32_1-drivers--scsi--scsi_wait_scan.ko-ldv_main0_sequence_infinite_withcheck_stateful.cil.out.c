extern void __VERIFIER_error() __attribute__ ((__noreturn__)); /* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned short u16;
typedef unsigned int u32;
struct __anonstruct_atomic_t_7 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct arch_spinlock;
struct arch_spinlock;
struct arch_spinlock;
struct task_struct;
struct task_struct;
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
union __anonunion____missing_field_name_36 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
struct arch_spinlock {
   union __anonunion____missing_field_name_36 __annonCompField17 ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct task_struct;
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
union __anonunion____missing_field_name_39 {
   struct raw_spinlock rlock ;
};
struct spinlock {
   union __anonunion____missing_field_name_39 __annonCompField19 ;
};
typedef struct spinlock spinlock_t;
struct task_struct;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
};
struct task_struct;
long ldv__builtin_expect(long val , long res ) ;
void mutex_lock(struct mutex *lock ) ;
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) ;
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) ;
int mutex_trylock(struct mutex *lock ) ;
void mutex_unlock(struct mutex *lock ) ;
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) ;
int init_module(void) ;
void cleanup_module(void) ;
extern void wait_for_device_probe(void) ;
 static int scsi_complete_async_scans(void)  __attribute__((__no_instrument_function__)) ;
 static int scsi_complete_async_scans(void)  __attribute__((__no_instrument_function__)) ;
 static int scsi_complete_async_scans(void) 
{ 

  {
  return (0);
}
}
static int wait_scan_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int wait_scan_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int wait_scan_init(void) 
{ 

  {
  wait_for_device_probe();
  scsi_complete_async_scans();
  return (0);
}
}
static void wait_scan_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
static void wait_scan_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
static void wait_scan_exit(void) 
{ 

  {
  return;
}
}
static char const   __mod_description38[32]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'S',      (char const   )'C',      (char const   )'S',      (char const   )'I', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'i', 
        (char const   )'t',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'s',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'\000'};
static char const   __mod_author39[23]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'J', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'B',      (char const   )'o',      (char const   )'t', 
        (char const   )'t',      (char const   )'o',      (char const   )'m',      (char const   )'l', 
        (char const   )'e',      (char const   )'y',      (char const   )'\000'};
static char const   __mod_license40[12]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
int init_module(void) 
{ int tmp ;

  {
  tmp = wait_scan_init();
  return (tmp);
}
}
void cleanup_module(void) 
{ 

  {
  wait_scan_exit();
  return;
}
}
void ldv_check_final_state(void) ;
extern void ldv_initialize(void) ;
extern int __VERIFIER_nondet_int(void) ;
int LDV_IN_INTERRUPT  ;
int main(void) 
{ int tmp ;
  int tmp___0 ;

  {
  LDV_IN_INTERRUPT = 1;
  ldv_initialize();
  while (1) {
    tmp___0 = __VERIFIER_nondet_int();
    if (! tmp___0) {
      goto while_break;
    }
    tmp = __VERIFIER_nondet_int();
    goto switch_default;
    if (0) {
      switch_default: 
      goto switch_break;
    } else {
      switch_break: ;
    }
  }
  while_break: 
  wait_scan_exit();
  ldv_check_final_state();
  return;
}
}
void ldv_blast_assert(void) 
{ 

  {
  ERROR: __VERIFIER_error(); 
  goto ERROR;
}
}
int ldv_mutex  =    1;
int __attribute__((__warn_unused_result__))  mutex_lock_interruptible(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int __attribute__((__warn_unused_result__))  mutex_lock_killable(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex = 2;
    return (1);
  }
  return (0);
}
}
void mutex_lock(struct mutex *lock ) 
{ 

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  ldv_mutex = 2;
  return;
}
}
int mutex_trylock(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex = 2;
    return (1);
  } else {
    return (0);
  }
}
}
void mutex_unlock(struct mutex *lock ) 
{ 

  {
  if (! (ldv_mutex == 2)) {
    ldv_blast_assert();
  }
  ldv_mutex = 1;
  return;
}
}
void ldv_check_final_state(void) 
{ 

  {
  if (! (ldv_mutex == 1)) {
    ldv_blast_assert();
  }
  return;
}
}
long ldv__builtin_expect(long val , long res ) 
{ 

  {
  return (val);
}
}
