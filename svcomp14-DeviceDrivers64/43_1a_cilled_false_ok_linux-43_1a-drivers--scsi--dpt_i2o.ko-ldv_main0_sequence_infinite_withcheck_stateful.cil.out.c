/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_nlink_t;
#line 31 "include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 52 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 53 "include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 75 "include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 76 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 90 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 91 "include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 92 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 93 "include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 94 "include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 95 "include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 27 "include/linux/types.h"
typedef unsigned short umode_t;
#line 28 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 29 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 30 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 35 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 38 "include/linux/types.h"
typedef _Bool bool;
#line 40 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 41 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 54 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 63 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 68 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 78 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 100 "include/linux/types.h"
typedef unsigned int uint;
#line 101 "include/linux/types.h"
typedef unsigned long ulong;
#line 111 "include/linux/types.h"
typedef __s32 int32_t;
#line 117 "include/linux/types.h"
typedef __u32 uint32_t;
#line 142 "include/linux/types.h"
typedef unsigned long sector_t;
#line 143 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 202 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 203 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 206 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 211 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 221 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 221 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 226 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 226 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 227 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 232
struct hlist_node;
#line 232 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 236 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 247 "include/linux/types.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head * ) ;
};
#line 55 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/alternative.h"
struct module;
#line 55
struct module;
#line 146 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 46 "include/linux/dynamic_debug.h"
struct device;
#line 46
struct device;
#line 57
struct completion;
#line 57
struct completion;
#line 58
struct pt_regs;
#line 58
struct pt_regs;
#line 348 "include/linux/kernel.h"
struct pid;
#line 348
struct pid;
#line 112 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/stat.h"
struct timespec;
#line 112
struct timespec;
#line 58 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/page_types.h"
struct page;
#line 58
struct page;
#line 26 "include/asm-generic/getorder.h"
struct task_struct;
#line 26
struct task_struct;
#line 28
struct mm_struct;
#line 28
struct mm_struct;
#line 268 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/segment.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 125 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2180_13 {
   unsigned int a ;
   unsigned int b ;
};
#line 125 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2195_14 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 125 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2196_12 {
   struct __anonstruct_ldv_2180_13 ldv_2180 ;
   struct __anonstruct_ldv_2195_14 ldv_2195 ;
};
#line 125 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2196_12 ldv_2196 ;
};
#line 13 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 192 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 194 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_16 {
   pgdval_t pgd ;
};
#line 194 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_16 pgd_t;
#line 282 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 290
struct file;
#line 290
struct file;
#line 305
struct seq_file;
#line 305
struct seq_file;
#line 337
struct thread_struct;
#line 337
struct thread_struct;
#line 339
struct cpumask;
#line 339
struct cpumask;
#line 340 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 327
struct arch_spinlock;
#line 300 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/ptrace.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 203 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2824_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 203 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2824_19 ldv_2824 ;
};
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 89 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 637 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 234 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 234
struct static_key;
#line 287 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 305 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5180_24 {
   u64 rip ;
   u64 rdp ;
};
#line 305 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5186_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 305 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5187_23 {
   struct __anonstruct_ldv_5180_24 ldv_5180 ;
   struct __anonstruct_ldv_5186_25 ldv_5186 ;
};
#line 305 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5196_26 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 305 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5187_23 ldv_5187 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5196_26 ldv_5196 ;
};
#line 339 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 360 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 365 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 371 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 377 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 385 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 433
struct kmem_cache;
#line 434
struct perf_event;
#line 434
struct perf_event;
#line 435 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 14 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_5907_29 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_5907_29 ldv_5907 ;
};
#line 27 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_5914_31 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_30 {
   s64 lock ;
   struct __anonstruct_ldv_5914_31 ldv_5914 ;
};
#line 33 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_30 arch_rwlock_t;
#line 34
struct lockdep_map;
#line 34
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char    *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char    *name ;
   int cpu ;
   unsigned long ip ;
};
#line 187 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 556 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6122_33 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6123_32 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6122_33 ldv_6122 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6123_32 ldv_6123 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_34 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_34 rwlock_t;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 286 "include/linux/time.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 27 "include/linux/wait.h"
struct __wait_queue;
#line 27 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 30 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 48 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 53 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 670 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char    *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 171
struct rw_semaphore;
#line 171
struct rw_semaphore;
#line 172 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 128 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 139 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char    *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 181 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 181
struct pci_dev;
#line 312 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 341
struct tvec_base;
#line 341
struct tvec_base;
#line 342 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 289 "include/linux/timer.h"
struct hrtimer;
#line 289
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 301
struct workqueue_struct;
#line 301
struct workqueue_struct;
#line 302
struct work_struct;
#line 302
struct work_struct;
#line 45 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 86 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 102 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos_request;
#line 499
struct pm_qos_raints;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   ktime_t suspend_time ;
   s64 max_time_suspended_ns ;
   struct dev_pm_qos_request *pq_req ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_raints *raints ;
};
#line 558 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 173 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 173
struct pci_bus;
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 18
struct vm_area_struct;
#line 68 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/xen/hypervisor.h"
struct bio_vec;
#line 68
struct bio_vec;
#line 18 "include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 835 "include/linux/sysctl.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 108 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 176
struct nsproxy;
#line 176
struct nsproxy;
#line 37 "include/linux/kmod.h"
struct cred;
#line 37
struct cred;
#line 18 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 19 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 23 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 24 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 193 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 201 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 445
struct sock;
#line 445
struct sock;
#line 446
struct kobject;
#line 446
struct kobject;
#line 447
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 453 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void    *(*netlink_ns)(struct sock * ) ;
   void    *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char    *name ;
   umode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 33 "include/linux/sysfs.h"
struct attribute_group {
   char    *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 62 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 98 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char    * , size_t  ) ;
   void    *(*namespace)(struct kobject * , struct attribute    * ) ;
};
#line 117
struct sysfs_dirent;
#line 117
struct sysfs_dirent;
#line 182 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char    *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops    *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations    *(*child_ns_type)(struct kobject * ) ;
   void    *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*   filter)(struct kset * , struct kobject * ) ;
   char    *(*   name)(struct kset * , struct kobject * ) ;
   int (*   uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops    *uevent_ops ;
};
#line 215
struct kernel_param;
#line 215
struct kernel_param;
#line 216 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char    * , struct kernel_param    * ) ;
   int (*get)(char * , struct kernel_param    * ) ;
   void (*free)(void * ) ;
};
#line 49 "include/linux/moduleparam.h"
struct kparam_string;
#line 49
struct kparam_array;
#line 49 "include/linux/moduleparam.h"
union __anonunion_ldv_13363_134 {
   void *arg ;
   struct kparam_string    *str ;
   struct kparam_array    *arr ;
};
#line 49 "include/linux/moduleparam.h"
struct kernel_param {
   char    *name ;
   struct kernel_param_ops    *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_13363_134 ldv_13363 ;
};
#line 61 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 67 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops    *ops ;
   void *elem ;
};
#line 458 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 225 "include/linux/jump_label.h"
struct tracepoint;
#line 225
struct tracepoint;
#line 226 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char    *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char    *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 34 "include/linux/module.h"
struct module_param_attrs;
#line 34 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 43 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char    * ,
                    size_t  ) ;
   void (*setup)(struct module * , char    * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 69
struct exception_table_entry;
#line 69
struct exception_table_entry;
#line 198
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 204 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 219
struct module_sect_attrs;
#line 219
struct module_notes_attrs;
#line 219
struct ftrace_event_call;
#line 219 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char    *version ;
   char    *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol    *syms ;
   unsigned long    *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol    *gpl_syms ;
   unsigned long    *gpl_crcs ;
   struct kernel_symbol    *unused_syms ;
   unsigned long    *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol    *unused_gpl_syms ;
   unsigned long    *unused_gpl_crcs ;
   struct kernel_symbol    *gpl_future_syms ;
   unsigned long    *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint *   *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char    **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[26U] ;
};
#line 55 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 66 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 76 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char    *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 51 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 215 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 584
struct klist_node;
#line 584
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct dma_map_ops;
#line 67 "include/linux/klist.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 17 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct device_private;
#line 17
struct device_private;
#line 18
struct device_driver;
#line 18
struct device_driver;
#line 19
struct driver_private;
#line 19
struct driver_private;
#line 20
struct class;
#line 20
struct class;
#line 21
struct subsys_private;
#line 21
struct subsys_private;
#line 22
struct bus_type;
#line 22
struct bus_type;
#line 23
struct device_node;
#line 23
struct device_node;
#line 24
struct iommu_ops;
#line 24
struct iommu_ops;
#line 25 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char    * , size_t  ) ;
};
#line 51 "include/linux/device.h"
struct device_attribute;
#line 51
struct driver_attribute;
#line 51 "include/linux/device.h"
struct bus_type {
   char    *name ;
   char    *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops    *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 125
struct device_type;
#line 182 "include/linux/device.h"
struct device_driver {
   char    *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char    *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id    *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group    **groups ;
   struct dev_pm_ops    *pm ;
   struct driver_private *p ;
};
#line 245 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char    * , size_t  ) ;
};
#line 299
struct class_attribute;
#line 299 "include/linux/device.h"
struct class {
   char    *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations    *ns_type ;
   void    *(*namespace)(struct device * ) ;
   struct dev_pm_ops    *pm ;
   struct subsys_private *p ;
};
#line 394 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char    * , size_t  ) ;
   void    *(*namespace)(struct class * , struct class_attribute    * ) ;
};
#line 447 "include/linux/device.h"
struct device_type {
   char    *name ;
   struct attribute_group    **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops    *pm ;
};
#line 474 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char    * ,
                    size_t  ) ;
};
#line 557 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 567
struct dma_coherent_mem;
#line 567 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char    *init_name ;
   struct device_type    *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group    **groups ;
   void (*release)(struct device * ) ;
};
#line 681 "include/linux/device.h"
struct wakeup_source {
   char    *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned char active : 1 ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 117 "include/linux/pci.h"
typedef int pci_power_t;
#line 143 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 144
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 169 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 186 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 229
struct pcie_link_state;
#line 229
struct pcie_link_state;
#line 230
struct pci_vpd;
#line 230
struct pci_vpd;
#line 231
struct pci_sriov;
#line 231
struct pci_sriov;
#line 232
struct pci_ats;
#line 232
struct pci_ats;
#line 233
struct proc_dir_entry;
#line 233
struct pci_driver;
#line 233 "include/linux/pci.h"
union __anonunion_ldv_15472_136 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 233 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_type : 4 ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_15472_136 ldv_15472 ;
   struct pci_ats *ats ;
};
#line 403
struct pci_ops;
#line 403 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 455 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 490 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 503 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 512 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 540 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char    *name ;
   struct pci_device_id    *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id    * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 986 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 1134
struct prio_tree_node;
#line 1134 "include/linux/pci.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 19 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 27 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 116
struct address_space;
#line 116
struct address_space;
#line 117 "include/linux/prio_tree.h"
union __anonunion_ldv_16344_138 {
   unsigned long index ;
   void *freelist ;
};
#line 117 "include/linux/prio_tree.h"
struct __anonstruct_ldv_16354_142 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 117 "include/linux/prio_tree.h"
union __anonunion_ldv_16355_141 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_16354_142 ldv_16354 ;
};
#line 117 "include/linux/prio_tree.h"
struct __anonstruct_ldv_16357_140 {
   union __anonunion_ldv_16355_141 ldv_16355 ;
   atomic_t _count ;
};
#line 117 "include/linux/prio_tree.h"
union __anonunion_ldv_16358_139 {
   unsigned long counters ;
   struct __anonstruct_ldv_16357_140 ldv_16357 ;
};
#line 117 "include/linux/prio_tree.h"
struct __anonstruct_ldv_16359_137 {
   union __anonunion_ldv_16344_138 ldv_16344 ;
   union __anonunion_ldv_16358_139 ldv_16358 ;
};
#line 117 "include/linux/prio_tree.h"
struct __anonstruct_ldv_16366_144 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 117 "include/linux/prio_tree.h"
union __anonunion_ldv_16367_143 {
   struct list_head lru ;
   struct __anonstruct_ldv_16366_144 ldv_16366 ;
};
#line 117 "include/linux/prio_tree.h"
union __anonunion_ldv_16372_145 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 117 "include/linux/prio_tree.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_16359_137 ldv_16359 ;
   union __anonunion_ldv_16367_143 ldv_16367 ;
   union __anonunion_ldv_16372_145 ldv_16372 ;
   unsigned long debug_flags ;
};
#line 192 "include/linux/mm_types.h"
struct __anonstruct_vm_set_147 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 192 "include/linux/mm_types.h"
union __anonunion_shared_146 {
   struct __anonstruct_vm_set_147 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 192
struct anon_vma;
#line 192
struct vm_operations_struct;
#line 192
struct mempolicy;
#line 192 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_146 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct    *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 255 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 261 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 274 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 287
struct linux_binfmt;
#line 287
struct mmu_notifier_mm;
#line 287 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct file_ra_state;
#line 43
struct file_ra_state;
#line 44
struct user_struct;
#line 44
struct user_struct;
#line 45
struct writeback_control;
#line 45
struct writeback_control;
#line 178 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 195 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t    * , nodemask_t    * ,
                  unsigned long  ) ;
};
#line 244
struct inode;
#line 244
struct inode;
#line 31 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 67 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 74 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 268 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1723 "include/linux/pci.h"
struct bio;
#line 1723
struct bio;
#line 1724
struct bio_integrity_payload;
#line 1724
struct bio_integrity_payload;
#line 1725
struct block_device;
#line 1725
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 18 "include/linux/blk_types.h"
typedef void bio_destructor_t(struct bio * );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned int bi_phys_segments ;
   unsigned int bi_size ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   unsigned int bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct bio_integrity_payload *bi_integrity ;
   bio_destructor_t *bi_destructor ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 427 "include/linux/rculist.h"
struct hlist_bl_node;
#line 427 "include/linux/rculist.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 114
struct nameidata;
#line 115
struct path;
#line 115
struct path;
#line 116
struct vfsmount;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char    *name ;
};
#line 72 "include/linux/dcache.h"
struct dentry_operations;
#line 72
struct super_block;
#line 72 "include/linux/dcache.h"
union __anonunion_d_u_148 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 72 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations    *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_148 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 123 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry    * , struct inode    * , struct qstr * ) ;
   int (*d_compare)(struct dentry    * , struct inode    * , struct dentry  const  * ,
                    struct inode    * , unsigned int  , char    * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry    * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 402 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 377
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 384
struct pid_namespace;
#line 384 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct rcu_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 93 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 96 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 104
struct user_namespace;
#line 104
struct user_namespace;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "include/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct export_operations;
#line 44
struct export_operations;
#line 45
struct hd_geometry;
#line 45
struct hd_geometry;
#line 46
struct iovec;
#line 46
struct iovec;
#line 47
struct kiocb;
#line 47
struct kiocb;
#line 48
struct pipe_inode_info;
#line 48
struct pipe_inode_info;
#line 49
struct poll_table_struct;
#line 49
struct poll_table_struct;
#line 50
struct kstatfs;
#line 50
struct kstatfs;
#line 435 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 119 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152 "include/linux/quota.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 165
struct dquot;
#line 185 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "include/linux/quota.h"
typedef long long qsize_t;
#line 189 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 211
struct quota_format_type;
#line 211
struct quota_format_type;
#line 212 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 275 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 303 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 314 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 328 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 344 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops    *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 390 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops    *ops[2U] ;
};
#line 585 "include/linux/fs.h"
union __anonunion_arg_151 {
   char *buf ;
   void *data ;
};
#line 585 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_150 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_151 arg ;
   int error ;
};
#line 585 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_150 read_descriptor_t;
#line 588 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec    * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 642
struct backing_dev_info;
#line 642
struct backing_dev_info;
#line 643 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations    *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
};
#line 664
struct request_queue;
#line 664
struct request_queue;
#line 665
struct hd_struct;
#line 665
struct gendisk;
#line 665 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 737
struct posix_acl;
#line 737
struct posix_acl;
#line 738
struct inode_operations;
#line 738 "include/linux/fs.h"
union __anonunion_ldv_21493_152 {
   unsigned int    i_nlink ;
   unsigned int __i_nlink ;
};
#line 738 "include/linux/fs.h"
union __anonunion_ldv_21512_153 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 738
struct file_operations;
#line 738
struct file_lock;
#line 738
struct cdev;
#line 738 "include/linux/fs.h"
union __anonunion_ldv_21530_154 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 738 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   uid_t i_uid ;
   gid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations    *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_21493_152 ldv_21493 ;
   dev_t i_rdev ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   blkcnt_t i_blocks ;
   loff_t i_size ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_21512_153 ldv_21512 ;
   atomic_t i_count ;
   unsigned int i_blkbits ;
   u64 i_version ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations    *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_21530_154 ldv_21530 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 941 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 949 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 972 "include/linux/fs.h"
union __anonunion_f_u_155 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 972 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_155 f_u ;
   struct path f_path ;
   struct file_operations    *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred    *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1111
struct files_struct;
#line 1111 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1112 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1117 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 1134
struct nlm_lockowner;
#line 1134
struct nlm_lockowner;
#line 1135 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 14
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_157 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_156 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_157 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations    *fl_ops ;
   struct lock_manager_operations    *fl_lmops ;
   union __anonunion_fl_u_156 fl_u ;
};
#line 1221 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1417
struct file_system_type;
#line 1417
struct super_operations;
#line 1417
struct xattr_handler;
#line 1417
struct mtd_info;
#line 1417 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations    *s_op ;
   struct dquot_operations    *dq_op ;
   struct quotactl_ops    *s_qcop ;
   struct export_operations    *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler    **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations    *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1563 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1601
struct block_device_operations;
#line 1601
struct block_device_operations;
#line 1602 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char    * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec    * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec    * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char    * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
};
#line 1637 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char    * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char    * , void    * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char    * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char    * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
};
#line 1682 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char    * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1834 "include/linux/fs.h"
struct file_system_type {
   char    *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char    * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 46 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 48 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char    * , unsigned long  , void * );
#line 49 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations    *proc_iops ;
   struct file_operations    *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[0U] ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 98 "include/linux/sem.h"
struct sem_undo_list;
#line 98 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 107
struct siginfo;
#line 107
struct siginfo;
#line 32 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_158 {
   unsigned long sig[1U] ;
};
#line 32 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_158 sigset_t;
#line 17 "include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 126 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 173 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 185 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_160 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_161 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_162 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_163 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_164 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_165 {
   long _band ;
   int _fd ;
};
#line 11 "include/asm-generic/siginfo.h"
union __anonunion__sifields_159 {
   int _pad[28U] ;
   struct __anonstruct__kill_160 _kill ;
   struct __anonstruct__timer_161 _timer ;
   struct __anonstruct__rt_162 _rt ;
   struct __anonstruct__sigchld_163 _sigchld ;
   struct __anonstruct__sigfault_164 _sigfault ;
   struct __anonstruct__sigpoll_165 _sigpoll ;
};
#line 11 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_159 _sifields ;
};
#line 102 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 45 "include/linux/proportions.h"
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   raw_spinlock_t lock ;
};
#line 10 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_168 {
   int mode ;
};
#line 10 "include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_168 seccomp_t;
#line 26 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 38
struct rt_mutex_waiter;
#line 41 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 85 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 452 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 29 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 33
struct key;
#line 33
struct key;
#line 34
struct signal_struct;
#line 34
struct signal_struct;
#line 35
struct key_type;
#line 35
struct key_type;
#line 37
struct keyring_list;
#line 37
struct keyring_list;
#line 115
struct key_user;
#line 115 "include/linux/key.h"
union __anonunion_ldv_24499_169 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 115 "include/linux/key.h"
union __anonunion_type_data_170 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 115 "include/linux/key.h"
union __anonunion_payload_171 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 115 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_24499_169 ldv_24499 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_170 type_data ;
   union __anonunion_payload_171 payload ;
};
#line 316
struct audit_context;
#line 316
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32U] ;
   gid_t *blocks[0U] ;
};
#line 77 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 91 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 264
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 190
struct blk_plug;
#line 149 "include/linux/sched.h"
struct cfs_rq;
#line 149
struct cfs_rq;
#line 44 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "include/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 54 "include/linux/uio.h"
struct kioctx;
#line 54
struct kioctx;
#line 55 "include/linux/uio.h"
union __anonunion_ki_obj_172 {
   void *user ;
   struct task_struct *tsk ;
};
#line 55
struct eventfd_ctx;
#line 55 "include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_172 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 162 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 178 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 406 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 449 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 457 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 464 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 481 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 517
struct autogroup;
#line 517
struct autogroup;
#line 518
struct tty_struct;
#line 518
struct taskstats;
#line 518
struct tty_audit_buf;
#line 518 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 699 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
#line 744
struct reclaim_state;
#line 744
struct reclaim_state;
#line 745 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 760 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1069
struct io_context;
#line 1069
struct io_context;
#line 1098
struct rq;
#line 1098
struct rq;
#line 1099 "include/linux/sched.h"
struct sched_class {
   struct sched_class    *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask    * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1165 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1170 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1205 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1231
struct rt_rq;
#line 1231 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1255
struct mem_cgroup;
#line 1255 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1616
struct css_set;
#line 1616
struct compat_robust_list_head;
#line 1616 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class    *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char irq_thread : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred    *real_cred ;
   struct cred    *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
#line 81 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 90 "include/linux/genhd.h"
struct partition_meta_info {
   u8 uuid[16U] ;
   u8 volname[64U] ;
};
#line 98 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct rcu_head rcu_head ;
};
#line 146 "include/linux/genhd.h"
struct disk_part_tbl {
   struct rcu_head rcu_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[0U] ;
};
#line 153
struct disk_events;
#line 153
struct disk_events;
#line 154
struct timer_rand_state;
#line 154
struct blk_integrity;
#line 154 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations    *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 11 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 54 "include/linux/writeback.h"
struct writeback_control {
   enum writeback_sync_modes sync_mode ;
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
};
#line 80
struct bdi_writeback;
#line 80
struct bdi_writeback;
#line 38 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 47 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   unsigned long last_active ;
   struct task_struct *task ;
   struct timer_list wakeup_timer ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 64 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct prop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 79 "include/linux/mempool.h"
union __anonunion_ldv_28580_175 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 79 "include/linux/mempool.h"
union __anonunion_ldv_28584_176 {
   struct hlist_node ioc_node ;
   struct rcu_head __rcu_head ;
};
#line 79 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_ldv_28580_175 ldv_28580 ;
   union __anonunion_ldv_28584_176 ldv_28584 ;
   unsigned int flags ;
};
#line 96 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 91 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   sector_t bip_sector ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned int bip_size ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_idx ;
   struct work_struct bip_work ;
   struct bio_vec bip_vec[0U] ;
};
#line 366 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 63 "include/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 81
struct elevator_queue;
#line 81
struct elevator_queue;
#line 84
struct request;
#line 84
struct request;
#line 86
struct bsg_job;
#line 86
struct bsg_job;
#line 40 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 41 "include/linux/blkdev.h"
struct request_list {
   int count[2U] ;
   int starved[2U] ;
   int elvpriv ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
};
#line 53
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 65 "include/linux/blkdev.h"
union __anonunion_ldv_29007_177 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 65 "include/linux/blkdev.h"
struct __anonstruct_elv_179 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 65 "include/linux/blkdev.h"
struct __anonstruct_flush_180 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 65 "include/linux/blkdev.h"
union __anonunion_ldv_29018_178 {
   struct __anonstruct_elv_179 elv ;
   struct __anonstruct_flush_180 flush ;
};
#line 65 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct call_single_data csd ;
   struct request_queue *q ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion_ldv_29007_177 ldv_29007 ;
   union __anonunion_ldv_29018_178 ldv_29018 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   int ref_count ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 10 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 13 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 17 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 19 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 22 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 24 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 25 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 26 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 29 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 30 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 31 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , gfp_t  );
#line 32 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 33 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 34 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 36 "include/linux/elevator.h"
typedef void *elevator_init_fn(struct request_queue * );
#line 37 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 38 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 68 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char    * , size_t  ) ;
};
#line 76 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 97 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   struct hlist_head *hash ;
   unsigned char registered : 1 ;
};
#line 202 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 203 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 204 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 205 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 206 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 214 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 216 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 217 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 218 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 219 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 220
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 227 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 233 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 242 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
};
#line 270 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   struct request_list rq ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   unsigned char flush_queue_delayed : 1 ;
   unsigned char flush_pending_idx : 1 ;
   unsigned char flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2U] ;
   struct list_head flush_data_in_flight ;
   struct request flush_rq ;
   struct mutex sysfs_lock ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
};
#line 876 "include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head cb_list ;
   unsigned int should_sort ;
};
#line 1208 "include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char    *disk_name ;
};
#line 1229 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1230 "include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1231 "include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1232 "include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1233 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char    *name ;
   struct kobject kobj ;
};
#line 1292 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   int (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 19 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/emergency-restart.h"
struct scsi_cmnd;
#line 19
struct scsi_cmnd;
#line 564 "include/scsi/scsi.h"
struct Scsi_Host;
#line 564
struct Scsi_Host;
#line 565
struct scsi_device;
#line 565
struct scsi_device;
#line 567 "include/scsi/scsi.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 37 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 53 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   unsigned char tag ;
};
#line 313
struct scsi_sense_hdr;
#line 313
struct scsi_sense_hdr;
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_BLOCK = 7,
    SDEV_CREATED_BLOCK = 8
} ;
#line 63
struct scsi_target;
#line 63
struct scsi_dh_data;
#line 63 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   unsigned int device_busy ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int lun ;
   unsigned int channel ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char    *vendor ;
   char    *model ;
   char    *rev ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned char writeable : 1 ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char ordered_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char is_visible : 1 ;
   unsigned long supported_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int device_blocked ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 179 "include/scsi/scsi_device.h"
struct scsi_dh_devlist {
   char *vendor ;
   char *model ;
};
#line 186 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char    *name ;
   struct scsi_dh_devlist    *devlist ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   int (*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char    * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 202 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
   char buf[0U] ;
};
#line 209
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 215 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   unsigned int reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned int target_busy ;
   unsigned int can_queue ;
   unsigned int target_blocked ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   struct execute_work ew ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 481
struct scsi_host_cmd_pool;
#line 481
struct scsi_host_cmd_pool;
#line 482
struct scsi_transport_template;
#line 482
struct scsi_transport_template;
#line 490 "include/scsi/scsi_device.h"
struct scsi_host_template {
   struct module *module ;
   char    *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char    *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*transfer_response)(struct scsi_cmnd * , void (*)(struct scsi_cmnd * ) ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  , int  ) ;
   int (*change_queue_type)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*proc_info)(struct Scsi_Host * , char * , char ** , off_t  , int  , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char    *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
};
#line 518 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 528 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   struct blk_queue_tag *bqt ;
   unsigned int host_busy ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int resetting ;
   unsigned long last_reset ;
   unsigned int max_id ;
   unsigned int max_lun ;
   unsigned int max_channel ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char use_blk_tcq : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   unsigned int host_blocked ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 34 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dptsig.h"
typedef unsigned char sigBYTE;
#line 35 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dptsig.h"
typedef unsigned short sigWORD;
#line 36 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dptsig.h"
typedef unsigned int sigINT;
#line 37 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dptsig.h"
struct dpt_sig {
   char dsSignature[6U] ;
   sigBYTE dsSigVersion ;
   sigBYTE dsProcessorFamily ;
   sigBYTE dsProcessor ;
   sigBYTE dsFiletype ;
   sigBYTE dsFiletypeFlags ;
   sigBYTE dsOEM ;
   sigINT dsOS ;
   sigWORD dsCapabilities ;
   sigWORD dsDeviceSupp ;
   sigWORD dsAdapterSupp ;
   sigWORD dsApplication ;
   sigBYTE dsRequirements ;
   sigBYTE dsVersion ;
   sigBYTE dsRevision ;
   sigBYTE dsSubRevision ;
   sigBYTE dsMonth ;
   sigBYTE dsDay ;
   sigBYTE dsYear ;
   char dsDescription[50U] ;
};
#line 314 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dptsig.h"
typedef struct dpt_sig dpt_sig_S;
#line 185 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/osd_util.h"
typedef unsigned char uCHAR;
#line 186 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/osd_util.h"
typedef unsigned short uSHORT;
#line 187 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/osd_util.h"
typedef unsigned int uINT;
#line 97 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/sys_info.h"
struct __anonstruct_driveParam_S_183 {
   uSHORT cylinders ;
   uCHAR heads ;
   uCHAR sectors ;
};
#line 97 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/sys_info.h"
typedef struct __anonstruct_driveParam_S_183 driveParam_S;
#line 175 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/sys_info.h"
struct __anonstruct_sysInfo_S_184 {
   uCHAR drive0CMOS ;
   uCHAR drive1CMOS ;
   uCHAR numDrives ;
   uCHAR processorFamily ;
   uCHAR processorType ;
   uCHAR smartROMMajorVersion ;
   uCHAR smartROMMinorVersion ;
   uCHAR smartROMRevision ;
   uSHORT flags ;
   uSHORT conventionalMemSize ;
   uINT extendedMemSize ;
   uINT osType ;
   uCHAR osMajorVersion ;
   uCHAR osMinorVersion ;
   uCHAR osRevision ;
   uCHAR osSubRevision ;
   uCHAR busType ;
   uCHAR pad[3U] ;
   driveParam_S drives[16U] ;
};
#line 175 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/sys_info.h"
typedef struct __anonstruct_sysInfo_S_184 sysInfo_S;
#line 120 "include/linux/i2o-dev.h"
struct _i2o_pci_bus {
   __u8 PciFunctionNumber ;
   __u8 PciDeviceNumber ;
   __u8 PciBusNumber ;
   __u8 reserved ;
   __u16 PciVendorID ;
   __u16 PciDeviceID ;
};
#line 141 "include/linux/i2o-dev.h"
typedef struct _i2o_pci_bus i2o_pci_bus;
#line 142 "include/linux/i2o-dev.h"
struct _i2o_local_bus {
   __u16 LbBaseIOPort ;
   __u16 reserved ;
   __u32 LbBaseMemoryAddress ;
};
#line 147 "include/linux/i2o-dev.h"
typedef struct _i2o_local_bus i2o_local_bus;
#line 148 "include/linux/i2o-dev.h"
struct _i2o_isa_bus {
   __u16 IsaBaseIOPort ;
   __u8 CSN ;
   __u8 reserved ;
   __u32 IsaBaseMemoryAddress ;
};
#line 154 "include/linux/i2o-dev.h"
typedef struct _i2o_isa_bus i2o_isa_bus;
#line 155 "include/linux/i2o-dev.h"
struct _i2o_eisa_bus_info {
   __u16 EisaBaseIOPort ;
   __u8 reserved ;
   __u8 EisaSlotNumber ;
   __u32 EisaBaseMemoryAddress ;
};
#line 161 "include/linux/i2o-dev.h"
typedef struct _i2o_eisa_bus_info i2o_eisa_bus;
#line 162 "include/linux/i2o-dev.h"
struct _i2o_mca_bus {
   __u16 McaBaseIOPort ;
   __u8 reserved ;
   __u8 McaSlotNumber ;
   __u32 McaBaseMemoryAddress ;
};
#line 168 "include/linux/i2o-dev.h"
typedef struct _i2o_mca_bus i2o_mca_bus;
#line 169 "include/linux/i2o-dev.h"
struct _i2o_other_bus {
   __u16 BaseIOPort ;
   __u16 reserved ;
   __u32 BaseMemoryAddress ;
};
#line 174 "include/linux/i2o-dev.h"
typedef struct _i2o_other_bus i2o_other_bus;
#line 175 "include/linux/i2o-dev.h"
union __anonunion_bus_191 {
   i2o_pci_bus pci_bus ;
   i2o_local_bus local_bus ;
   i2o_isa_bus isa_bus ;
   i2o_eisa_bus eisa_bus ;
   i2o_mca_bus mca_bus ;
   i2o_other_bus other_bus ;
};
#line 175 "include/linux/i2o-dev.h"
struct _i2o_hrt_entry {
   __u32 adapter_id ;
   unsigned short parent_tid : 12 ;
   unsigned char state : 4 ;
   unsigned char bus_num ;
   unsigned char bus_type ;
   union __anonunion_bus_191 bus ;
};
#line 190 "include/linux/i2o-dev.h"
typedef struct _i2o_hrt_entry i2o_hrt_entry;
#line 191 "include/linux/i2o-dev.h"
struct _i2o_hrt {
   __u16 num_entries ;
   __u8 entry_len ;
   __u8 hrt_version ;
   __u32 change_ind ;
   i2o_hrt_entry hrt_entry[1U] ;
};
#line 198 "include/linux/i2o-dev.h"
typedef struct _i2o_hrt i2o_hrt;
#line 199 "include/linux/i2o-dev.h"
struct _i2o_lct_entry {
   unsigned short entry_size ;
   unsigned short tid : 12 ;
   unsigned char reserved : 4 ;
   __u32 change_ind ;
   __u32 device_flags ;
   unsigned short class_id : 12 ;
   unsigned char version : 4 ;
   unsigned short vendor_id ;
   __u32 sub_class ;
   unsigned short user_tid : 12 ;
   unsigned short parent_tid : 12 ;
   unsigned char bios_info ;
   __u8 identity_tag[8U] ;
   __u32 event_capabilities ;
};
#line 215 "include/linux/i2o-dev.h"
typedef struct _i2o_lct_entry i2o_lct_entry;
#line 216 "include/linux/i2o-dev.h"
struct _i2o_lct {
   unsigned short table_size ;
   unsigned short boot_tid : 12 ;
   unsigned char lct_ver : 4 ;
   __u32 iop_flags ;
   __u32 change_ind ;
   i2o_lct_entry lct_entry[1U] ;
};
#line 224 "include/linux/i2o-dev.h"
typedef struct _i2o_lct i2o_lct;
#line 225 "include/linux/i2o-dev.h"
struct _i2o_status_block {
   __u16 org_id ;
   __u16 reserved ;
   unsigned short iop_id : 12 ;
   unsigned char reserved1 : 4 ;
   __u16 host_unit_id ;
   unsigned short segment_number : 12 ;
   unsigned char i2o_version : 4 ;
   __u8 iop_state ;
   __u8 msg_type ;
   __u16 inbound_frame_size ;
   __u8 init_code ;
   __u8 reserved2 ;
   __u32 max_inbound_frames ;
   __u32 cur_inbound_frames ;
   __u32 max_outbound_frames ;
   char product_id[24U] ;
   __u32 expected_lct_size ;
   __u32 iop_capabilities ;
   __u32 desired_mem_size ;
   __u32 current_mem_size ;
   __u32 current_mem_base ;
   __u32 desired_io_size ;
   __u32 current_io_size ;
   __u32 current_io_base ;
   unsigned int reserved3 : 24 ;
   unsigned char cmd_status ;
};
#line 253 "include/linux/i2o-dev.h"
typedef struct _i2o_status_block i2o_status_block;
#line 49 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_i2o.h"
typedef wait_queue_head_t adpt_wait_queue_head_t;
#line 67
struct adpt_device;
#line 67
struct adpt_device;
#line 68
struct _adpt_hba;
#line 68
struct _adpt_hba;
#line 69 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_i2o.h"
struct i2o_device {
   struct i2o_device *next ;
   struct i2o_device *prev ;
   char dev_name[8U] ;
   i2o_lct_entry lct_data ;
   u32 flags ;
   struct proc_dir_entry *proc_entry ;
   struct adpt_device *owner ;
   struct _adpt_hba *controller ;
};
#line 100 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_i2o.h"
struct i2o_sys_tbl_entry {
   u16 org_id ;
   u16 reserved1 ;
   unsigned short iop_id : 12 ;
   unsigned int reserved2 : 20 ;
   unsigned short seg_num : 12 ;
   unsigned char i2o_version : 4 ;
   u8 iop_state ;
   u8 msg_type ;
   u16 frame_size ;
   u16 reserved3 ;
   u32 last_changed ;
   u32 iop_capabilities ;
   u32 inbound_low ;
   u32 inbound_high ;
};
#line 122 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_i2o.h"
struct i2o_sys_tbl {
   u8 num_entries ;
   u8 version ;
   u16 reserved1 ;
   u32 change_ind ;
   u32 reserved2 ;
   u32 reserved3 ;
   struct i2o_sys_tbl_entry iops[0U] ;
};
#line 128 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_ioctl.h"
struct __anonstruct_drvrHBAinfo_S_193 {
   uSHORT length ;
   uSHORT drvrHBAnum ;
   uINT baseAddr ;
   uSHORT blinkState ;
   uCHAR pciBusNum ;
   uCHAR pciDeviceNum ;
   uSHORT hbaFlags ;
   uSHORT Interrupt ;
   uINT reserved1 ;
   uINT reserved2 ;
   uINT reserved3 ;
};
#line 128 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_ioctl.h"
typedef struct __anonstruct_drvrHBAinfo_S_193 drvrHBAinfo_S;
#line 137 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpt/dpti_ioctl.h"
struct adpt_device {
   struct adpt_device *next_lun ;
   u32 flags ;
   u32 type ;
   u32 capacity ;
   u32 block_size ;
   u8 scsi_channel ;
   u8 scsi_id ;
   u8 scsi_lun ;
   u8 state ;
   u16 tid ;
   struct i2o_device *pI2o_dev ;
   struct scsi_device *pScsi_dev ;
};
#line 193 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpti.h"
struct adpt_channel {
   struct adpt_device *device[128U] ;
   u8 scsi_id ;
   u8 type ;
   u16 tid ;
   u32 state ;
   struct i2o_device *pI2o_dev ;
};
#line 202 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpti.h"
struct _adpt_hba {
   struct _adpt_hba *next ;
   struct pci_dev *pDev ;
   struct Scsi_Host *host ;
   u32 state ;
   spinlock_t state_lock ;
   int unit ;
   int host_no ;
   u8 initialized ;
   u8 in_use ;
   char name[32U] ;
   char detail[55U] ;
   void *base_addr_virt ;
   void *msg_addr_virt ;
   ulong base_addr_phys ;
   void *post_port ;
   void *reply_port ;
   void *irq_mask ;
   u16 post_count ;
   u32 post_fifo_size ;
   u32 reply_fifo_size ;
   u32 *reply_pool ;
   dma_addr_t reply_pool_pa ;
   u32 sg_tablesize ;
   u8 top_scsi_channel ;
   u8 top_scsi_id ;
   u8 top_scsi_lun ;
   u8 dma64 ;
   i2o_status_block *status_block ;
   dma_addr_t status_block_pa ;
   i2o_hrt *hrt ;
   dma_addr_t hrt_pa ;
   i2o_lct *lct ;
   dma_addr_t lct_pa ;
   uint lct_size ;
   struct i2o_device *devices ;
   struct adpt_channel channel[5U] ;
   struct proc_dir_entry *proc_entry ;
   void *FwDebugBuffer_P ;
   u32 FwDebugBufferSize ;
   void *FwDebugStrLength_P ;
   void *FwDebugFlags_P ;
   void *FwDebugBLEDflag_P ;
   void *FwDebugBLEDvalue_P ;
   u32 FwDebugFlags ;
   u32 *ioctl_reply_context[4U] ;
};
#line 257 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpti.h"
typedef struct _adpt_hba adpt_hba;
#line 258 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpti.h"
struct sg_simple_element {
   u32 flag_count ;
   u32 addr_bus ;
};
#line 141 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
struct adpt_i2o_post_wait_data {
   int status ;
   u32 id ;
   adpt_wait_queue_head_t *wq ;
   struct adpt_i2o_post_wait_data *next ;
};
#line 1 "<compiler builtins>"

#line 1

#line 1

#line 1
#line 2 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 4
int ldv_spin_trylock(void) ;
#line 101 "include/linux/printk.h"
extern int printk(char    *  , ...) ;
#line 192 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 320
extern int sprintf(char * , char    *  , ...) ;
#line 356 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 88 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *pfo_ret__ ;

  {
#line 14
  if (8 == 1) {
#line 14
    goto case_1;
  } else
#line 14
  if (8 == 2) {
#line 14
    goto case_2;
  } else
#line 14
  if (8 == 4) {
#line 14
    goto case_4;
  } else
#line 14
  if (8 == 8) {
#line 14
    goto case_8;
  } else {
    {
#line 14
    goto switch_default;
#line 14
    if (0) {
      case_1: /* CIL Label */ 
#line 14
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
      goto ldv_2918;
      case_2: /* CIL Label */ 
#line 14
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto ldv_2918;
      case_4: /* CIL Label */ 
#line 14
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto ldv_2918;
      case_8: /* CIL Label */ 
#line 14
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
      goto ldv_2918;
      switch_default: /* CIL Label */ 
      {
#line 14
      __bad_percpu_size();
      }
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_2918: ;
#line 14
  return (pfo_ret__);
}
}
#line 34 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void    * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 65 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char    * , int     , char const   *  , ...) ;
#line 70
extern void warn_slowpath_null(char    * , int     ) ;
#line 861 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct pv_irq_ops *__cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct pv_irq_ops *__cil_tmp15 ;

  {
  {
#line 863
  __edi = __edi;
#line 863
  __esi = __esi;
#line 863
  __edx = __edx;
#line 863
  __ecx = __ecx;
#line 863
  __eax = __eax;
#line 863
  __cil_tmp8 = (void *)0;
#line 863
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 863
  __cil_tmp10 = & pv_irq_ops;
#line 863
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 863
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 863
  __cil_tmp13 = __cil_tmp12 == __cil_tmp9;
#line 863
  __cil_tmp14 = (long )__cil_tmp13;
#line 863
  tmp = __builtin_expect(__cil_tmp14, 0L);
  }
#line 863
  if (tmp != 0L) {
#line 863
    ldv_4790: ;
#line 863
    goto ldv_4790;
  } else {

  }
#line 863
  __cil_tmp15 = & pv_irq_ops;
#line 863
  __ret = __eax;
#line 863
  return (__ret);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void    *ptr ) 
{ long tmp ;
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  long __cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp3 = (unsigned long )ptr;
#line 34
  __cil_tmp4 = __cil_tmp3 > 0xfffffffffffff000UL;
#line 34
  __cil_tmp5 = (long )__cil_tmp4;
#line 34
  tmp = __builtin_expect(__cil_tmp5, 0L);
  }
#line 34
  return (tmp);
}
}
#line 155 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ unsigned long __cil_tmp2 ;

  {
  {
#line 157
  __cil_tmp2 = flags & 512UL;
#line 157
  return (__cil_tmp2 == 0UL);
  }
}
}
#line 11 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char    * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 29
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return ((struct raw_spinlock *)lock);
}
}
#line 283 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_1(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 285
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 285
  _raw_spin_lock(__cil_tmp2);
  }
#line 286
  return;
}
}
#line 283
__inline static void spin_lock(spinlock_t *lock ) ;
#line 308 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_irq_4(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 310
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 310
  _raw_spin_lock_irq(__cil_tmp2);
  }
#line 311
  return;
}
}
#line 308
__inline static void spin_lock_irq(spinlock_t *lock ) ;
#line 323 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_5(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 325
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 325
  _raw_spin_unlock(__cil_tmp2);
  }
#line 326
  return;
}
}
#line 323
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 341 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irq_7(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 343
  __cil_tmp2 = (struct raw_spinlock *)lock;
#line 343
  _raw_spin_unlock_irq(__cil_tmp2);
  }
#line 344
  return;
}
}
#line 341
__inline static void spin_unlock_irq(spinlock_t *lock ) ;
#line 350 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_8(spinlock_t *lock , unsigned long flags ) 
{ struct raw_spinlock *__cil_tmp5 ;

  {
  {
#line 352
  __cil_tmp5 = (struct raw_spinlock *)lock;
#line 352
  _raw_spin_unlock_irqrestore(__cil_tmp5, flags);
  }
#line 353
  return;
}
}
#line 350
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 29 "include/linux/wait.h"
extern int default_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 79
extern void __init_waitqueue_head(wait_queue_head_t * , char    * , struct lock_class_key * ) ;
#line 117
extern void add_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
#line 119
extern void remove_wait_queue(wait_queue_head_t * , wait_queue_t * ) ;
#line 155
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 134 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 169
extern void mutex_unlock(struct mutex * ) ;
#line 82 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 53 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void  volatile   *addr ) 
{ unsigned char ret ;
  unsigned char volatile   *__cil_tmp3 ;

  {
#line 53
  __cil_tmp3 = (unsigned char volatile   *)addr;
#line 53
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*__cil_tmp3): "memory");
#line 53
  return (ret);
}
}
#line 55 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void  volatile   *addr ) 
{ unsigned int ret ;
  unsigned int volatile   *__cil_tmp3 ;

  {
#line 55
  __cil_tmp3 = (unsigned int volatile   *)addr;
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*__cil_tmp3): "memory");
#line 55
  return (ret);
}
}
#line 63 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ unsigned int volatile   *__cil_tmp3 ;

  {
#line 63
  __cil_tmp3 = (unsigned int volatile   *)addr;
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*__cil_tmp3): "memory");
#line 64
  return;
}
}
#line 129 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void *phys_to_virt(phys_addr_t address ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 131
  __cil_tmp2 = (unsigned long )address;
#line 131
  __cil_tmp3 = __cil_tmp2 + 0xffff880000000000UL;
#line 131
  return ((void *)__cil_tmp3);
  }
}
}
#line 174
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
  {
#line 184
  tmp = ioremap_nocache(offset, size);
  }
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 209 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void  volatile   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void    *__cil_tmp6 ;

  {
  {
#line 211
  __len = count;
#line 211
  __cil_tmp6 = (void    *)src;
#line 211
  __ret = __builtin_memcpy(dst, __cil_tmp6, __len);
  }
#line 213
  return;
}
}
#line 215 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void    *src , size_t count ) 
{ size_t __len ;
  void *__ret ;
  void *__cil_tmp6 ;

  {
  {
#line 217
  __len = count;
#line 217
  __cil_tmp6 = (void *)dst;
#line 217
  __ret = __builtin_memcpy(__cil_tmp6, src, __len);
  }
#line 219
  return;
}
}
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 161 "include/linux/slab.h"
extern void kfree(void    * ) ;
#line 220 "include/linux/slub_def.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 223
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) ;
#line 225
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 268 "include/linux/slub_def.h"
__inline static void *ldv_kmalloc_12(size_t size , gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
#line 283
  tmp___2 = __kmalloc(size, flags);
  }
#line 283
  return (tmp___2);
}
}
#line 268
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 353 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 10 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
extern void *__VERIFIER_nondet_pointer(void) ;
#line 11
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_check_alloc_nonatomic(void) ;
#line 14
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) ;
#line 40 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void    * , unsigned int  ) ;
#line 42
extern unsigned long _copy_from_user(void * , void    * , unsigned int  ) ;
#line 46 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void    *from , unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void    *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  int    __cil_tmp21 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;

  {
  {
#line 50
  __cil_tmp10 = (void    *)to;
#line 50
  __cil_tmp11 = (void *)__cil_tmp10;
#line 50
  tmp = __builtin_object_size(__cil_tmp11, 0);
#line 50
  sz = (int )tmp;
#line 52
  might_fault();
#line 53
  __cil_tmp12 = sz == -1;
#line 53
  __cil_tmp13 = (long )__cil_tmp12;
#line 53
  tmp___1 = __builtin_expect(__cil_tmp13, 1L);
  }
#line 53
  if (tmp___1 != 0L) {
    {
#line 54
    __cil_tmp14 = (unsigned int )n;
#line 54
    n = _copy_from_user(to, from, __cil_tmp14);
    }
  } else {
    {
#line 53
    __cil_tmp15 = (unsigned long )sz;
#line 53
    __cil_tmp16 = __cil_tmp15 >= n;
#line 53
    __cil_tmp17 = (long )__cil_tmp16;
#line 53
    tmp___2 = __builtin_expect(__cil_tmp17, 1L);
    }
#line 53
    if (tmp___2 != 0L) {
      {
#line 54
      __cil_tmp18 = (unsigned int )n;
#line 54
      n = _copy_from_user(to, from, __cil_tmp18);
      }
    } else {
      {
#line 57
      __ret_warn_on = 1;
#line 57
      __cil_tmp19 = __ret_warn_on != 0;
#line 57
      __cil_tmp20 = (long )__cil_tmp19;
#line 57
      tmp___0 = __builtin_expect(__cil_tmp20, 0L);
      }
#line 57
      if (tmp___0 != 0L) {
        {
#line 57
        __cil_tmp21 = (int    )57;
#line 57
        warn_slowpath_fmt("/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h",
                          __cil_tmp21, "Buffer overflow detected!\n");
        }
      } else {

      }
      {
#line 57
      __cil_tmp22 = __ret_warn_on != 0;
#line 57
      __cil_tmp23 = (long )__cil_tmp22;
#line 57
      __builtin_expect(__cil_tmp23, 0L);
      }
    }
  }
#line 59
  return (n);
}
}
#line 63 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void    *src , unsigned int size ) 
{ unsigned long tmp ;

  {
  {
#line 65
  might_fault();
#line 67
  tmp = _copy_to_user(dst, src, size);
  }
#line 67
  return ((int )tmp);
}
}
#line 443 "include/linux/device.h"
extern struct class *__class_create(struct module * , char    * , struct lock_class_key * ) ;
#line 446
extern void class_destroy(struct class * ) ;
#line 835
extern struct device *device_create(struct class * , struct device * , dev_t  , void * ,
                                    char    *  , ...) ;
#line 838
extern void device_destroy(struct class * , dev_t  ) ;
#line 686 "include/linux/pci.h"
extern struct pci_dev *pci_dev_get(struct pci_dev * ) ;
#line 687
extern void pci_dev_put(struct pci_dev * ) ;
#line 716
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 773
extern int pci_enable_device(struct pci_dev * ) ;
#line 793
extern void pci_set_master(struct pci_dev * ) ;
#line 904
extern int pci_request_regions(struct pci_dev * , char    * ) ;
#line 906
extern void pci_release_regions(struct pci_dev * ) ;
#line 204 "include/linux/scatterlist.h"
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 67 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ int tmp ;
  u64 *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  u64 *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  u64 *__cil_tmp11 ;
  u64 __cil_tmp12 ;

  {
  {
#line 69
  __cil_tmp3 = (u64 *)0;
#line 69
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 69
  __cil_tmp5 = (unsigned long )dev;
#line 69
  __cil_tmp6 = __cil_tmp5 + 920;
#line 69
  __cil_tmp7 = *((u64 **)__cil_tmp6);
#line 69
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 69
  if (__cil_tmp8 != __cil_tmp4) {
    {
#line 69
    __cil_tmp9 = (unsigned long )dev;
#line 69
    __cil_tmp10 = __cil_tmp9 + 920;
#line 69
    __cil_tmp11 = *((u64 **)__cil_tmp10);
#line 69
    __cil_tmp12 = *__cil_tmp11;
#line 69
    if (__cil_tmp12 != 0ULL) {
#line 69
      tmp = 1;
    } else {
#line 69
      tmp = 0;
    }
    }
  } else {
#line 69
    tmp = 0;
  }
  }
#line 69
  return (tmp);
}
}
#line 51 "include/linux/dma-debug.h"
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 54
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 26 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 29
extern struct dma_map_ops *dma_ops ;
#line 31 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ long tmp ;
  struct device *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  long __cil_tmp7 ;
  struct dma_map_ops *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct dma_map_ops *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  {
#line 36
  __cil_tmp3 = (struct device *)0;
#line 36
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 36
  __cil_tmp5 = (unsigned long )dev;
#line 36
  __cil_tmp6 = __cil_tmp5 == __cil_tmp4;
#line 36
  __cil_tmp7 = (long )__cil_tmp6;
#line 36
  tmp = __builtin_expect(__cil_tmp7, 0L);
  }
#line 36
  if (tmp != 0L) {
#line 37
    return (dma_ops);
  } else {
    {
#line 36
    __cil_tmp8 = (struct dma_map_ops *)0;
#line 36
    __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 36
    __cil_tmp10 = 968 + 8;
#line 36
    __cil_tmp11 = (unsigned long )dev;
#line 36
    __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 36
    __cil_tmp13 = *((struct dma_map_ops **)__cil_tmp12);
#line 36
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 36
    if (__cil_tmp14 == __cil_tmp9) {
#line 37
      return (dma_ops);
    } else {
      {
#line 39
      __cil_tmp15 = 968 + 8;
#line 39
      __cil_tmp16 = (unsigned long )dev;
#line 39
      __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 39
      return (*((struct dma_map_ops **)__cil_tmp17));
      }
    }
    }
  }
}
}
#line 58
extern int dma_supported(struct device * , u64  ) ;
#line 59
extern int dma_set_mask(struct device * , u64  ) ;
#line 90 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  u64 __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 93
  dma_mask = 0UL;
#line 95
  __cil_tmp4 = (unsigned long )dev;
#line 95
  __cil_tmp5 = __cil_tmp4 + 928;
#line 95
  __cil_tmp6 = *((u64 *)__cil_tmp5);
#line 95
  dma_mask = (unsigned long )__cil_tmp6;
#line 96
  if (dma_mask == 0UL) {
    {
#line 97
    __cil_tmp7 = (int )gfp;
#line 97
    if (__cil_tmp7 & 1) {
#line 97
      dma_mask = 16777215UL;
    } else {
#line 97
      dma_mask = 4294967295UL;
    }
    }
  } else {

  }
#line 99
  return (dma_mask);
}
}
#line 102 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;
  unsigned long long __cil_tmp5 ;
  unsigned long long __cil_tmp6 ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 104
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 104
  dma_mask = tmp;
  }
  {
#line 106
  __cil_tmp5 = (unsigned long long )dma_mask;
#line 106
  if (__cil_tmp5 <= 16777215ULL) {
#line 107
    gfp = gfp | 1U;
  } else {

  }
  }
  {
#line 109
  __cil_tmp6 = (unsigned long long )dma_mask;
#line 109
  if (__cil_tmp6 <= 4294967295ULL) {
    {
#line 109
    __cil_tmp7 = gfp & 1U;
#line 109
    if (__cil_tmp7 == 0U) {
#line 110
      gfp = gfp | 4U;
    } else {

    }
    }
  } else {

  }
  }
#line 112
  return (gfp);
}
}
#line 118 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;
  struct device *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *(*__cil_tmp14)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
  unsigned long __cil_tmp15 ;
  void *(*__cil_tmp16)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
  unsigned long __cil_tmp17 ;
  void *(*__cil_tmp18)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
  dma_addr_t __cil_tmp19 ;

  {
  {
#line 121
  tmp = get_dma_ops(dev);
#line 121
  ops = tmp;
#line 124
  gfp = gfp & 4294967288U;
  }
  {
#line 129
  __cil_tmp11 = (struct device *)0;
#line 129
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 129
  __cil_tmp13 = (unsigned long )dev;
#line 129
  if (__cil_tmp13 == __cil_tmp12) {
#line 130
    dev = & x86_dma_fallback_dev;
  } else {

  }
  }
  {
#line 132
  tmp___0 = is_device_dma_capable(dev);
  }
#line 132
  if (tmp___0 == 0) {
#line 133
    return ((void *)0);
  } else {

  }
  {
#line 135
  __cil_tmp14 = (void *(*)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ))0;
#line 135
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 135
  __cil_tmp16 = *((void *(**)(struct device * , size_t  , dma_addr_t * , gfp_t  ,
                              struct dma_attrs * ))ops);
#line 135
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 135
  if (__cil_tmp17 == __cil_tmp15) {
#line 136
    return ((void *)0);
  } else {

  }
  }
  {
#line 138
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 138
  __cil_tmp18 = *((void *(**)(struct device * , size_t  , dma_addr_t * , gfp_t  ,
                              struct dma_attrs * ))ops);
#line 138
  memory = (*__cil_tmp18)(dev, size, dma_handle, tmp___1, attrs);
#line 140
  __cil_tmp19 = *dma_handle;
#line 140
  debug_dma_alloc_coherent(dev, size, __cil_tmp19, memory);
  }
#line 142
  return (memory);
}
}
#line 147 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  int    __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  void (*__cil_tmp21)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void (*__cil_tmp25)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void (*__cil_tmp29)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;

  {
  {
#line 151
  tmp = get_dma_ops(dev);
#line 151
  ops = tmp;
#line 153
  _flags = arch_local_save_flags();
#line 153
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 153
  __ret_warn_on = tmp___0 != 0;
#line 153
  __cil_tmp16 = __ret_warn_on != 0;
#line 153
  __cil_tmp17 = (long )__cil_tmp16;
#line 153
  tmp___1 = __builtin_expect(__cil_tmp17, 0L);
  }
#line 153
  if (tmp___1 != 0L) {
    {
#line 153
    __cil_tmp18 = (int    )153;
#line 153
    warn_slowpath_null("/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/arch/x86/include/asm/dma-mapping.h",
                       __cil_tmp18);
    }
  } else {

  }
  {
#line 153
  __cil_tmp19 = __ret_warn_on != 0;
#line 153
  __cil_tmp20 = (long )__cil_tmp19;
#line 153
  __builtin_expect(__cil_tmp20, 0L);
#line 158
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
  {
#line 159
  __cil_tmp21 = (void (*)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ))0;
#line 159
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 159
  __cil_tmp23 = (unsigned long )ops;
#line 159
  __cil_tmp24 = __cil_tmp23 + 8;
#line 159
  __cil_tmp25 = *((void (**)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ))__cil_tmp24);
#line 159
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 159
  if (__cil_tmp26 != __cil_tmp22) {
    {
#line 160
    __cil_tmp27 = (unsigned long )ops;
#line 160
    __cil_tmp28 = __cil_tmp27 + 8;
#line 160
    __cil_tmp29 = *((void (**)(struct device * , size_t  , void * , dma_addr_t  ,
                               struct dma_attrs * ))__cil_tmp28);
#line 160
    (*__cil_tmp29)(dev, size, vaddr, bus, attrs);
    }
  } else {

  }
  }
#line 161
  return;
}
}
#line 88 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ int tmp ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 90
  tmp = dma_supported(dev, mask);
  }
#line 90
  if (tmp == 0) {
#line 91
    return (-5);
  } else {

  }
#line 92
  __cil_tmp4 = (unsigned long )dev;
#line 92
  __cil_tmp5 = __cil_tmp4 + 928;
#line 92
  *((u64 *)__cil_tmp5) = mask;
#line 93
  return (0);
}
}
#line 97
extern u64 dma_get_required_mask(struct device * ) ;
#line 105 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct device *__cil_tmp6 ;

  {
  {
#line 107
  __cil_tmp4 = (unsigned long )dev;
#line 107
  __cil_tmp5 = __cil_tmp4 + 144;
#line 107
  __cil_tmp6 = (struct device *)__cil_tmp5;
#line 107
  tmp = dma_set_mask(__cil_tmp6, mask);
  }
#line 107
  return (tmp);
}
}
#line 110 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ int tmp ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct device *__cil_tmp6 ;

  {
  {
#line 112
  __cil_tmp4 = (unsigned long )dev;
#line 112
  __cil_tmp5 = __cil_tmp4 + 144;
#line 112
  __cil_tmp6 = (struct device *)__cil_tmp5;
#line 112
  tmp = dma_set_coherent_mask(__cil_tmp6, mask);
  }
#line 112
  return (tmp);
}
}
#line 930 "include/linux/fs.h"
__inline static unsigned int iminor(struct inode    *inode ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  dev_t    __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 932
  __cil_tmp2 = (unsigned long )inode;
#line 932
  __cil_tmp3 = __cil_tmp2 + 76;
#line 932
  __cil_tmp4 = *((dev_t    *)__cil_tmp3);
#line 932
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 932
  return (__cil_tmp5 & 1048575U);
  }
}
}
#line 2116
extern int __register_chrdev(unsigned int  , unsigned int  , unsigned int  , char    * ,
                             struct file_operations    * ) ;
#line 2119
extern void __unregister_chrdev(unsigned int  , unsigned int  , unsigned int  , char    * ) ;
#line 2124 "include/linux/fs.h"
__inline static int register_chrdev(unsigned int major , char    *name , struct file_operations    *fops ) 
{ int tmp ;

  {
  {
#line 2127
  tmp = __register_chrdev(major, 0U, 256U, name, fops);
  }
#line 2127
  return (tmp);
}
}
#line 2130 "include/linux/fs.h"
__inline static void unregister_chrdev(unsigned int major , char    *name ) 
{ 

  {
  {
#line 2132
  __unregister_chrdev(major, 0U, 256U, name);
  }
#line 2133
  return;
}
}
#line 2401
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 358 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 361
extern long schedule_timeout_uninterruptible(long  ) ;
#line 362
extern void schedule(void) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char    * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char    *name , void *dev ) 
{ int tmp ;
  irqreturn_t (*__cil_tmp7)(int  , void * ) ;

  {
  {
#line 135
  __cil_tmp7 = (irqreturn_t (*)(int  , void * ))0;
#line 135
  tmp = request_threaded_irq(irq, handler, __cil_tmp7, flags, name, dev);
  }
#line 135
  return (tmp);
}
}
#line 184
extern void free_irq(unsigned int  , void * ) ;
#line 157 "include/scsi/scsi_cmnd.h"
extern int scsi_dma_map(struct scsi_cmnd * ) ;
#line 158
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 168 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 170
  __cil_tmp2 = (unsigned long )cmd;
#line 170
  __cil_tmp3 = __cil_tmp2 + 88;
#line 170
  return (*((struct scatterlist **)__cil_tmp3));
  }
}
}
#line 173 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 175
  __cil_tmp2 = 88 + 16;
#line 175
  __cil_tmp3 = (unsigned long )cmd;
#line 175
  __cil_tmp4 = __cil_tmp3 + __cil_tmp2;
#line 175
  return (*((unsigned int *)__cil_tmp4));
  }
}
}
#line 178 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 180
  __cil_tmp3 = 88 + 20;
#line 180
  __cil_tmp4 = (unsigned long )cmd;
#line 180
  __cil_tmp5 = __cil_tmp4 + __cil_tmp3;
#line 180
  *((int *)__cil_tmp5) = resid;
#line 181
  return;
}
}
#line 293 "include/scsi/scsi_device.h"
extern void scsi_device_put(struct scsi_device * ) ;
#line 309
extern struct scsi_device *__scsi_iterate_devices(struct Scsi_Host * , struct scsi_device * ) ;
#line 342
extern void scsi_adjust_queue_depth(struct scsi_device * , int  , int  ) ;
#line 360
extern int scsi_device_set_state(struct scsi_device * , enum scsi_device_state  ) ;
#line 420 "include/scsi/scsi_device.h"
__inline static int scsi_device_online(struct scsi_device *sdev ) 
{ int tmp ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  enum scsi_device_state __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  enum scsi_device_state __cil_tmp9 ;
  unsigned int __cil_tmp10 ;

  {
  {
#line 422
  __cil_tmp3 = (unsigned long )sdev;
#line 422
  __cil_tmp4 = __cil_tmp3 + 2904;
#line 422
  __cil_tmp5 = *((enum scsi_device_state *)__cil_tmp4);
#line 422
  __cil_tmp6 = (unsigned int )__cil_tmp5;
#line 422
  if (__cil_tmp6 != 6U) {
    {
#line 422
    __cil_tmp7 = (unsigned long )sdev;
#line 422
    __cil_tmp8 = __cil_tmp7 + 2904;
#line 422
    __cil_tmp9 = *((enum scsi_device_state *)__cil_tmp8);
#line 422
    __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 422
    if (__cil_tmp10 != 4U) {
#line 422
      tmp = 1;
    } else {
#line 422
      tmp = 0;
    }
    }
  } else {
#line 422
    tmp = 0;
  }
  }
#line 422
  return (tmp);
}
}
#line 778 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 779
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 782
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 784
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 789
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 793 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ int tmp ;

  {
  {
#line 796
  tmp = scsi_add_host_with_dma(host, dev, dev);
  }
#line 796
  return (tmp);
}
}
#line 918
extern void scsi_unregister(struct Scsi_Host * ) ;
#line 31 "/home/zakharov/launch/inst/current/envs/linux-3.4/linux-3.4/drivers/scsi/dpti.h"
static int adpt_detect(struct scsi_host_template *sht ) ;
#line 32
static int adpt_queue(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) ;
#line 33
static int adpt_abort(struct scsi_cmnd *cmd ) ;
#line 34
static int adpt_reset(struct scsi_cmnd *cmd ) ;
#line 35
static int adpt_release(struct Scsi_Host *host ) ;
#line 36
static int adpt_slave_configure(struct scsi_device *device ) ;
#line 38
static char    *adpt_info(struct Scsi_Host *host ) ;
#line 39
static int adpt_bios_param(struct scsi_device *sdev , struct block_device *dev , sector_t capacity ,
                           int *geom ) ;
#line 42
static int adpt_bus_reset(struct scsi_cmnd *cmd ) ;
#line 43
static int adpt_device_reset(struct scsi_cmnd *cmd ) ;
#line 268
static void adpt_i2o_sys_shutdown(void) ;
#line 269
static int adpt_init(void) ;
#line 270
static int adpt_i2o_build_sys_table(void) ;
#line 271
static irqreturn_t adpt_isr(int irq , void *dev_id ) ;
#line 273
static void adpt_i2o_report_hba_unit(adpt_hba *pHba , struct i2o_device *d ) ;
#line 274
static int adpt_i2o_query_scalar(adpt_hba *pHba , int tid , int group , int field ,
                                 void *buf , int buflen ) ;
#line 279
static int adpt_i2o_issue_params(int cmd , adpt_hba *pHba , int tid , void *opblk_va ,
                                 dma_addr_t opblk_pa , int oplen , void *resblk_va ,
                                 dma_addr_t resblk_pa , int reslen ) ;
#line 282
static int adpt_i2o_post_wait(adpt_hba *pHba , u32 *msg , int len , int timeout ) ;
#line 283
static int adpt_i2o_lct_get(adpt_hba *pHba ) ;
#line 284
static int adpt_i2o_parse_lct(adpt_hba *pHba ) ;
#line 285
static int adpt_i2o_activate_hba(adpt_hba *pHba ) ;
#line 286
static int adpt_i2o_enable_hba(adpt_hba *pHba ) ;
#line 287
static int adpt_i2o_install_device(adpt_hba *pHba , struct i2o_device *d ) ;
#line 288
static s32 adpt_i2o_post_this(adpt_hba *pHba , u32 *data , int len ) ;
#line 289
static s32 adpt_i2o_quiesce_hba(adpt_hba *pHba ) ;
#line 290
static s32 adpt_i2o_status_get(adpt_hba *pHba ) ;
#line 291
static s32 adpt_i2o_init_outbound_q(adpt_hba *pHba ) ;
#line 292
static s32 adpt_i2o_hrt_get(adpt_hba *pHba ) ;
#line 293
static s32 adpt_scsi_to_i2o(adpt_hba *pHba , struct scsi_cmnd *cmd , struct adpt_device *d ) ;
#line 294
static s32 adpt_i2o_to_scsi(void *reply , struct scsi_cmnd *cmd ) ;
#line 295
static s32 adpt_scsi_host_alloc(adpt_hba *pHba , struct scsi_host_template *sht ) ;
#line 296
static int adpt_hba_reset(adpt_hba *pHba ) ;
#line 297
static s32 adpt_i2o_reset_hba(adpt_hba *pHba ) ;
#line 298
static s32 adpt_rescan(adpt_hba *pHba ) ;
#line 299
static s32 adpt_i2o_reparse_lct(adpt_hba *pHba ) ;
#line 300
static s32 adpt_send_nop(adpt_hba *pHba , u32 m ) ;
#line 301
static void adpt_i2o_delete_hba(adpt_hba *pHba ) ;
#line 302
static void adpt_inquiry(adpt_hba *pHba ) ;
#line 303
static void adpt_fail_posted_scbs(adpt_hba *pHba ) ;
#line 304
static struct adpt_device *adpt_find_device(adpt_hba *pHba , u32 chan , u32 id , u32 lun ) ;
#line 305
static int adpt_install_hba(struct scsi_host_template *sht , struct pci_dev *pDev ) ;
#line 306
static int adpt_i2o_online_hba(adpt_hba *pHba ) ;
#line 307
static void adpt_i2o_post_wait_complete(u32 context , int status ) ;
#line 308
static int adpt_i2o_systab_send(adpt_hba *pHba ) ;
#line 310
static int adpt_ioctl(struct inode *inode , struct file *file , uint cmd , ulong arg ) ;
#line 311
static int adpt_open(struct inode *inode , struct file *file ) ;
#line 312
static int adpt_close(struct inode *inode , struct file *file ) ;
#line 93 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct mutex adpt_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)0xffffffffffffffffUL, {(struct lock_class_key *)0,
                                                                             {(struct lock_class *)0,
                                                                              (struct lock_class *)0},
                                                                             "adpt_mutex.wait_lock",
                                                                             0, 0UL}}}},
    {& adpt_mutex.wait_list, & adpt_mutex.wait_list}, (struct task_struct *)0, (char    *)0,
    (void *)(& adpt_mutex), {(struct lock_class_key *)0, {(struct lock_class *)0,
                                                          (struct lock_class *)0},
                             "adpt_mutex", 0, 0UL}};
#line 94 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static dpt_sig_S DPTI_sig  = 
#line 94
     {{(char)100, (char)80, (char)116, (char)83, (char)105, (char)71}, (sigBYTE )1U,
    (sigBYTE )255U, (sigBYTE )255U, (sigBYTE )2U, (sigBYTE )0U, (sigBYTE )0U, 16777216U,
    (sigWORD )64U, (sigWORD )65535U, (sigWORD )1024U, (sigWORD )0U, (sigBYTE )0U,
    (sigBYTE )2U, (sigBYTE )52U, (sigBYTE )53U, (sigBYTE )8U, (sigBYTE )7U, (sigBYTE )21U,
    {(char )'A', (char )'d', (char )'a', (char )'p', (char )'t', (char )'e', (char )'c',
     (char )' ', (char )'L', (char )'i', (char )'n', (char )'u', (char )'x', (char )' ',
     (char )'I', (char )'2', (char )'O', (char )' ', (char )'R', (char )'A', (char )'I',
     (char )'D', (char )' ', (char )'D', (char )'r', (char )'i', (char )'v', (char )'e',
     (char )'r', (char )'\000'}};
#line 120 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct mutex adpt_configuration_lock  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)0xffffffffffffffffUL, {(struct lock_class_key *)0,
                                                                             {(struct lock_class *)0,
                                                                              (struct lock_class *)0},
                                                                             "adpt_configuration_lock.wait_lock",
                                                                             0, 0UL}}}},
    {& adpt_configuration_lock.wait_list, & adpt_configuration_lock.wait_list}, (struct task_struct *)0,
    (char    *)0, (void *)(& adpt_configuration_lock), {(struct lock_class_key *)0,
                                                             {(struct lock_class *)0,
                                                              (struct lock_class *)0},
                                                             "adpt_configuration_lock",
                                                             0, 0UL}};
#line 122 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct i2o_sys_tbl *sys_tbl  ;
#line 123 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static dma_addr_t sys_tbl_pa  ;
#line 124 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int sys_tbl_ind  ;
#line 125 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int sys_tbl_len  ;
#line 127 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static adpt_hba *hba_chain  =    (adpt_hba *)0;
#line 128 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int hba_count  =    0;
#line 130 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct class *adpt_sysfs_class  ;
#line 132
static long adpt_unlocked_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
#line 134
static long compat_adpt_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
#line 137 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct file_operations    adpt_fops  = 
#line 137
     {(struct module *)0, & noop_llseek, (ssize_t (*)(struct file * , char * , size_t  ,
                                                    loff_t * ))0, (ssize_t (*)(struct file * ,
                                                                               char    * ,
                                                                               size_t  ,
                                                                               loff_t * ))0,
    (ssize_t (*)(struct kiocb * , struct iovec    * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec    * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char    * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    & adpt_unlocked_ioctl, & compat_adpt_ioctl, (int (*)(struct file * , struct vm_area_struct * ))0,
    & adpt_open, (int (*)(struct file * , fl_owner_t  ))0, & adpt_close, (int (*)(struct file * ,
                                                                                  loff_t  ,
                                                                                  loff_t  ,
                                                                                  int  ))0,
    (int (*)(struct kiocb * , int  ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (long (*)(struct file * ,
                                                                        int  , loff_t  ,
                                                                        loff_t  ))0};
#line 158 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct adpt_i2o_post_wait_data *adpt_post_wait_queue  =    (struct adpt_i2o_post_wait_data *)0;
#line 159 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static u32 adpt_post_wait_id  =    0U;
#line 160 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static spinlock_t adpt_post_wait_lock  =    {{{{{0U}}, 3735899821U, 4294967295U, (void *)0xffffffffffffffffUL, {(struct lock_class_key *)0,
                                                                       {(struct lock_class *)0,
                                                                        (struct lock_class *)0},
                                                                       "adpt_post_wait_lock",
                                                                       0, 0UL}}}};
#line 168 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static int dpt_dma64(adpt_hba *pHba ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  u8 __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 170
  __cil_tmp2 = (unsigned long )pHba;
#line 170
  __cil_tmp3 = __cil_tmp2 + 295;
#line 170
  __cil_tmp4 = *((u8 *)__cil_tmp3);
#line 170
  __cil_tmp5 = (unsigned int )__cil_tmp4;
#line 170
  return (__cil_tmp5 != 0U);
  }
}
}
#line 173 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static u32 dma_high(dma_addr_t addr ) 
{ dma_addr_t __cil_tmp2 ;

  {
  {
#line 175
  __cil_tmp2 = addr >> 32ULL;
#line 175
  return ((u32 )__cil_tmp2);
  }
}
}
#line 178 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static u32 dma_low(dma_addr_t addr ) 
{ 

  {
#line 180
  return ((u32 )addr);
}
}
#line 183 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static u8 adpt_read_blink_led(adpt_hba *host ) 
{ unsigned char tmp ;
  unsigned char tmp___0 ;
  void *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  void  volatile   *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  void  volatile   *__cil_tmp18 ;

  {
  {
#line 185
  __cil_tmp4 = (void *)0;
#line 185
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 185
  __cil_tmp6 = (unsigned long )host;
#line 185
  __cil_tmp7 = __cil_tmp6 + 5600;
#line 185
  __cil_tmp8 = *((void **)__cil_tmp7);
#line 185
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 185
  if (__cil_tmp9 != __cil_tmp5) {
    {
#line 186
    __cil_tmp10 = (unsigned long )host;
#line 186
    __cil_tmp11 = __cil_tmp10 + 5600;
#line 186
    __cil_tmp12 = *((void **)__cil_tmp11);
#line 186
    __cil_tmp13 = (void  volatile   *)__cil_tmp12;
#line 186
    tmp___0 = readb(__cil_tmp13);
    }
    {
#line 186
    __cil_tmp14 = (unsigned int )tmp___0;
#line 186
    if (__cil_tmp14 == 188U) {
      {
#line 187
      __cil_tmp15 = (unsigned long )host;
#line 187
      __cil_tmp16 = __cil_tmp15 + 5608;
#line 187
      __cil_tmp17 = *((void **)__cil_tmp16);
#line 187
      __cil_tmp18 = (void  volatile   *)__cil_tmp17;
#line 187
      tmp = readb(__cil_tmp18);
      }
#line 187
      return (tmp);
    } else {

    }
    }
  } else {

  }
  }
#line 190
  return ((u8 )0U);
}
}
#line 203 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
struct pci_device_id    __mod_pci_device_table  ;
#line 205 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_detect(struct scsi_host_template *sht ) 
{ struct pci_dev *pDev ;
  adpt_hba *pHba ;
  adpt_hba *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct lock_class_key __key ;
  struct class *tmp___5 ;
  long tmp___6 ;
  s32 tmp___7 ;
  struct device *dev ;
  struct device *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned short __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  struct pci_dev *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  adpt_hba *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  adpt_hba *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  adpt_hba *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  char (*__cil_tmp41)[32U] ;
  char *__cil_tmp42 ;
  adpt_hba *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void    *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  u32 __cil_tmp53 ;
  struct class *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct device *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  dev_t __cil_tmp62 ;
  void *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  int __cil_tmp66 ;
  void    *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int __cil_tmp70 ;
  adpt_hba *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;

  {
  {
#line 207
  pDev = (struct pci_dev *)0;
#line 211
  printk("<6>Detecting Adaptec I2O RAID controllers...\n");
  }
#line 214
  goto ldv_32103;
  ldv_32102: ;
  {
#line 215
  __cil_tmp19 = (unsigned long )pDev;
#line 215
  __cil_tmp20 = __cil_tmp19 + 62;
#line 215
  __cil_tmp21 = *((unsigned short *)__cil_tmp20);
#line 215
  __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 215
  if (__cil_tmp22 == 42241U) {
#line 215
    goto _L;
  } else {
    {
#line 215
    __cil_tmp23 = (unsigned long )pDev;
#line 215
    __cil_tmp24 = __cil_tmp23 + 62;
#line 215
    __cil_tmp25 = *((unsigned short *)__cil_tmp24);
#line 215
    __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 215
    if (__cil_tmp26 == 42257U) {
      _L: /* CIL Label */ 
      {
#line 217
      tmp = adpt_install_hba(sht, pDev);
      }
#line 217
      if (tmp != 0) {
        {
#line 218
        printk("<3>Could not Init an I2O RAID device\n");
#line 219
        printk("<3>Will not try to detect others.\n");
        }
#line 220
        return (hba_count + -1);
      } else {

      }
      {
#line 222
      pci_dev_get(pDev);
      }
    } else {

    }
    }
  }
  }
  ldv_32103: 
  {
#line 214
  pDev = pci_get_device(4164U, 4294967295U, pDev);
  }
  {
#line 214
  __cil_tmp27 = (struct pci_dev *)0;
#line 214
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 214
  __cil_tmp29 = (unsigned long )pDev;
#line 214
  if (__cil_tmp29 != __cil_tmp28) {
#line 215
    goto ldv_32102;
  } else {
#line 217
    goto ldv_32104;
  }
  }
  ldv_32104: 
#line 227
  pHba = hba_chain;
#line 227
  goto ldv_32106;
  ldv_32105: 
  {
#line 228
  next = *((struct _adpt_hba **)pHba);
#line 230
  tmp___0 = adpt_i2o_activate_hba(pHba);
  }
#line 230
  if (tmp___0 < 0) {
    {
#line 231
    adpt_i2o_delete_hba(pHba);
    }
  } else {

  }
#line 227
  pHba = next;
  ldv_32106: ;
  {
#line 227
  __cil_tmp30 = (adpt_hba *)0;
#line 227
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 227
  __cil_tmp32 = (unsigned long )pHba;
#line 227
  if (__cil_tmp32 != __cil_tmp31) {
#line 228
    goto ldv_32105;
  } else {
#line 230
    goto ldv_32107;
  }
  }
  ldv_32107: ;
  rebuild_sys_tab: ;
  {
#line 239
  __cil_tmp33 = (adpt_hba *)0;
#line 239
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 239
  __cil_tmp35 = (unsigned long )hba_chain;
#line 239
  if (__cil_tmp35 == __cil_tmp34) {
#line 240
    return (0);
  } else {

  }
  }
  {
#line 246
  tmp___1 = adpt_i2o_build_sys_table();
  }
#line 246
  if (tmp___1 < 0) {
    {
#line 247
    adpt_i2o_sys_shutdown();
    }
#line 248
    return (0);
  } else {

  }
#line 254
  pHba = hba_chain;
#line 254
  goto ldv_32110;
  ldv_32109: 
  {
#line 255
  tmp___2 = adpt_i2o_online_hba(pHba);
  }
#line 255
  if (tmp___2 < 0) {
    {
#line 256
    adpt_i2o_delete_hba(pHba);
    }
#line 257
    goto rebuild_sys_tab;
  } else {

  }
#line 254
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32110: ;
  {
#line 254
  __cil_tmp36 = (adpt_hba *)0;
#line 254
  __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 254
  __cil_tmp38 = (unsigned long )pHba;
#line 254
  if (__cil_tmp38 != __cil_tmp37) {
#line 255
    goto ldv_32109;
  } else {
#line 257
    goto ldv_32111;
  }
  }
  ldv_32111: 
  {
#line 264
  printk("dpti: If you have a lot of devices this could take a few minutes.\n");
#line 265
  pHba = hba_chain;
  }
#line 265
  goto ldv_32114;
  ldv_32113: 
  {
#line 266
  next = *((struct _adpt_hba **)pHba);
#line 267
  __cil_tmp39 = (unsigned long )pHba;
#line 267
  __cil_tmp40 = __cil_tmp39 + 114;
#line 267
  __cil_tmp41 = (char (*)[32U])__cil_tmp40;
#line 267
  __cil_tmp42 = (char *)__cil_tmp41;
#line 267
  printk("<6>%s: Reading the hardware resource table.\n", __cil_tmp42);
#line 268
  tmp___3 = adpt_i2o_lct_get(pHba);
  }
#line 268
  if (tmp___3 < 0) {
    {
#line 269
    adpt_i2o_delete_hba(pHba);
    }
#line 270
    goto ldv_32112;
  } else {

  }
  {
#line 273
  tmp___4 = adpt_i2o_parse_lct(pHba);
  }
#line 273
  if (tmp___4 < 0) {
    {
#line 274
    adpt_i2o_delete_hba(pHba);
    }
#line 275
    goto ldv_32112;
  } else {

  }
  {
#line 277
  adpt_inquiry(pHba);
  }
  ldv_32112: 
#line 265
  pHba = next;
  ldv_32114: ;
  {
#line 265
  __cil_tmp43 = (adpt_hba *)0;
#line 265
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 265
  __cil_tmp45 = (unsigned long )pHba;
#line 265
  if (__cil_tmp45 != __cil_tmp44) {
#line 266
    goto ldv_32113;
  } else {
#line 268
    goto ldv_32115;
  }
  }
  ldv_32115: 
  {
#line 280
  tmp___5 = __class_create(& __this_module, "dpt_i2o", & __key);
#line 280
  adpt_sysfs_class = tmp___5;
#line 281
  __cil_tmp46 = (void    *)adpt_sysfs_class;
#line 281
  tmp___6 = IS_ERR(__cil_tmp46);
  }
#line 281
  if (tmp___6 != 0L) {
    {
#line 282
    printk("<4>dpti: unable to create dpt_i2o class\n");
#line 283
    adpt_sysfs_class = (struct class *)0;
    }
  } else {

  }
#line 286
  pHba = hba_chain;
#line 286
  goto ldv_32121;
  ldv_32120: 
  {
#line 287
  next = *((struct _adpt_hba **)pHba);
#line 288
  tmp___7 = adpt_scsi_host_alloc(pHba, sht);
  }
#line 288
  if (tmp___7 < 0) {
    {
#line 289
    adpt_i2o_delete_hba(pHba);
    }
#line 290
    goto ldv_32118;
  } else {

  }
#line 292
  __cil_tmp47 = (unsigned long )pHba;
#line 292
  __cil_tmp48 = __cil_tmp47 + 112;
#line 292
  *((u8 *)__cil_tmp48) = (u8 )1U;
#line 293
  __cil_tmp49 = (unsigned long )pHba;
#line 293
  __cil_tmp50 = __cil_tmp49 + 24;
#line 293
  __cil_tmp51 = (unsigned long )pHba;
#line 293
  __cil_tmp52 = __cil_tmp51 + 24;
#line 293
  __cil_tmp53 = *((u32 *)__cil_tmp52);
#line 293
  *((u32 *)__cil_tmp50) = __cil_tmp53 & 4294967294U;
  {
#line 294
  __cil_tmp54 = (struct class *)0;
#line 294
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 294
  __cil_tmp56 = (unsigned long )adpt_sysfs_class;
#line 294
  if (__cil_tmp56 != __cil_tmp55) {
    {
#line 295
    __cil_tmp57 = (struct device *)0;
#line 295
    __cil_tmp58 = (unsigned long )pHba;
#line 295
    __cil_tmp59 = __cil_tmp58 + 104;
#line 295
    __cil_tmp60 = *((int *)__cil_tmp59);
#line 295
    __cil_tmp61 = __cil_tmp60 | 158334976;
#line 295
    __cil_tmp62 = (dev_t )__cil_tmp61;
#line 295
    __cil_tmp63 = (void *)0;
#line 295
    __cil_tmp64 = (unsigned long )pHba;
#line 295
    __cil_tmp65 = __cil_tmp64 + 104;
#line 295
    __cil_tmp66 = *((int *)__cil_tmp65);
#line 295
    tmp___8 = device_create(adpt_sysfs_class, __cil_tmp57, __cil_tmp62, __cil_tmp63,
                            "dpti%d", __cil_tmp66);
#line 295
    dev = tmp___8;
#line 298
    __cil_tmp67 = (void    *)dev;
#line 298
    tmp___9 = IS_ERR(__cil_tmp67);
    }
#line 298
    if (tmp___9 != 0L) {
      {
#line 299
      __cil_tmp68 = (unsigned long )pHba;
#line 299
      __cil_tmp69 = __cil_tmp68 + 104;
#line 299
      __cil_tmp70 = *((int *)__cil_tmp69);
#line 299
      printk("<4>dpti%d: unable to create device in dpt_i2o class\n", __cil_tmp70);
      }
    } else {

    }
  } else {

  }
  }
  ldv_32118: 
#line 286
  pHba = next;
  ldv_32121: ;
  {
#line 286
  __cil_tmp71 = (adpt_hba *)0;
#line 286
  __cil_tmp72 = (unsigned long )__cil_tmp71;
#line 286
  __cil_tmp73 = (unsigned long )pHba;
#line 286
  if (__cil_tmp73 != __cil_tmp72) {
#line 287
    goto ldv_32120;
  } else {
#line 289
    goto ldv_32122;
  }
  }
  ldv_32122: ;
#line 309
  if (hba_count != 0) {
    {
#line 309
    tmp___10 = register_chrdev(151U, "dpt_i2o", & adpt_fops);
    }
#line 309
    if (tmp___10 != 0) {
      {
#line 310
      adpt_i2o_sys_shutdown();
      }
#line 311
      return (0);
    } else {

    }
  } else {

  }
#line 313
  return (hba_count);
}
}
#line 320 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_release(struct Scsi_Host *host ) 
{ adpt_hba *pHba ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 322
  __cil_tmp3 = 0 * 8UL;
#line 322
  __cil_tmp4 = 3048 + __cil_tmp3;
#line 322
  __cil_tmp5 = (unsigned long )host;
#line 322
  __cil_tmp6 = __cil_tmp5 + __cil_tmp4;
#line 322
  __cil_tmp7 = *((unsigned long *)__cil_tmp6);
#line 322
  pHba = (adpt_hba *)__cil_tmp7;
#line 324
  adpt_i2o_delete_hba(pHba);
#line 325
  scsi_unregister(host);
  }
#line 326
  return (0);
}
}
#line 330 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_inquiry(adpt_hba *pHba ) 
{ u32 msg[17U] ;
  u32 *mptr ;
  u32 *lenptr ;
  int direction ;
  int scsidir ;
  u32 len ;
  u32 reqlen ;
  u8 *buf ;
  dma_addr_t addr ;
  u8 scb[16U] ;
  s32 rcode ;
  void *tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  u32 *tmp___3 ;
  u32 *tmp___4 ;
  u32 *tmp___5 ;
  u32 *tmp___6 ;
  u32 *tmp___7 ;
  u32 *tmp___8 ;
  int tmp___9 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  void *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct pci_dev *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  struct device *__cil_tmp42 ;
  struct dma_attrs *__cil_tmp43 ;
  u8 *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  char (*__cil_tmp49)[32U] ;
  char *__cil_tmp50 ;
  void *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  u32 __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  u32 *__cil_tmp68 ;
  void *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  void *__cil_tmp82 ;
  void    *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void    *__cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  dma_addr_t *__cil_tmp88 ;
  dma_addr_t __cil_tmp89 ;
  dma_addr_t *__cil_tmp90 ;
  dma_addr_t __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  dma_addr_t *__cil_tmp94 ;
  dma_addr_t __cil_tmp95 ;
  u32 *__cil_tmp96 ;
  u32 __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  char (*__cil_tmp101)[55U] ;
  char *__cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  char (*__cil_tmp105)[32U] ;
  char *__cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  struct pci_dev *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  struct device *__cil_tmp112 ;
  void *__cil_tmp113 ;
  dma_addr_t *__cil_tmp114 ;
  dma_addr_t __cil_tmp115 ;
  struct dma_attrs *__cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  char (*__cil_tmp119)[55U] ;
  void *__cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  char (*__cil_tmp123)[55U] ;
  void *__cil_tmp124 ;
  void    *__cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  char (*__cil_tmp128)[55U] ;
  void *__cil_tmp129 ;
  void    *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  char (*__cil_tmp133)[55U] ;
  void *__cil_tmp134 ;
  void *__cil_tmp135 ;
  void    *__cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  char (*__cil_tmp139)[55U] ;
  void *__cil_tmp140 ;
  void *__cil_tmp141 ;
  void    *__cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  char (*__cil_tmp145)[55U] ;
  void *__cil_tmp146 ;
  void *__cil_tmp147 ;
  void    *__cil_tmp148 ;
  void    *__cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  char (*__cil_tmp152)[55U] ;
  void *__cil_tmp153 ;
  void *__cil_tmp154 ;
  void    *__cil_tmp155 ;
  void    *__cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  char (*__cil_tmp159)[55U] ;
  void *__cil_tmp160 ;
  void *__cil_tmp161 ;
  void    *__cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  char (*__cil_tmp165)[55U] ;
  void *__cil_tmp166 ;
  void *__cil_tmp167 ;
  void    *__cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  char (*__cil_tmp171)[55U] ;
  void *__cil_tmp172 ;
  void *__cil_tmp173 ;
  void    *__cil_tmp174 ;
  void    *__cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  char (*__cil_tmp178)[55U] ;
  void *__cil_tmp179 ;
  void *__cil_tmp180 ;
  void    *__cil_tmp181 ;
  void    *__cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  struct pci_dev *__cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  struct device *__cil_tmp192 ;
  void *__cil_tmp193 ;
  dma_addr_t *__cil_tmp194 ;
  dma_addr_t __cil_tmp195 ;
  struct dma_attrs *__cil_tmp196 ;

  {
  {
#line 344
  __cil_tmp36 = (void *)(& msg);
#line 344
  memset(__cil_tmp36, 0, 68UL);
#line 345
  __cil_tmp37 = (unsigned long )pHba;
#line 345
  __cil_tmp38 = __cil_tmp37 + 8;
#line 345
  __cil_tmp39 = *((struct pci_dev **)__cil_tmp38);
#line 345
  __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 345
  __cil_tmp41 = __cil_tmp40 + 144;
#line 345
  __cil_tmp42 = (struct device *)__cil_tmp41;
#line 345
  __cil_tmp43 = (struct dma_attrs *)0;
#line 345
  tmp = dma_alloc_attrs(__cil_tmp42, 80UL, & addr, 208U, __cil_tmp43);
#line 345
  buf = (u8 *)tmp;
  }
  {
#line 346
  __cil_tmp44 = (u8 *)0;
#line 346
  __cil_tmp45 = (unsigned long )__cil_tmp44;
#line 346
  __cil_tmp46 = (unsigned long )buf;
#line 346
  if (__cil_tmp46 == __cil_tmp45) {
    {
#line 347
    __cil_tmp47 = (unsigned long )pHba;
#line 347
    __cil_tmp48 = __cil_tmp47 + 114;
#line 347
    __cil_tmp49 = (char (*)[32U])__cil_tmp48;
#line 347
    __cil_tmp50 = (char *)__cil_tmp49;
#line 347
    printk("<3>%s: Could not allocate buffer\n", __cil_tmp50);
    }
#line 348
    return;
  } else {

  }
  }
  {
#line 350
  __cil_tmp51 = (void *)buf;
#line 350
  memset(__cil_tmp51, 0, 36UL);
#line 352
  len = 36U;
#line 353
  direction = 0;
#line 354
  scsidir = 1073741824;
#line 356
  tmp___0 = dpt_dma64(pHba);
  }
#line 356
  if (tmp___0 != 0) {
#line 357
    reqlen = 17U;
  } else {
#line 359
    reqlen = 14U;
  }
  {
#line 361
  __cil_tmp52 = 0 * 4UL;
#line 361
  __cil_tmp53 = (unsigned long )(msg) + __cil_tmp52;
#line 361
  __cil_tmp54 = reqlen << 16;
#line 361
  *((u32 *)__cil_tmp53) = __cil_tmp54 | 193U;
#line 362
  __cil_tmp55 = 1 * 4UL;
#line 362
  __cil_tmp56 = (unsigned long )(msg) + __cil_tmp55;
#line 362
  *((u32 *)__cil_tmp56) = 4278194176U;
#line 363
  __cil_tmp57 = 2 * 4UL;
#line 363
  __cil_tmp58 = (unsigned long )(msg) + __cil_tmp57;
#line 363
  *((u32 *)__cil_tmp58) = 0U;
#line 364
  __cil_tmp59 = 3 * 4UL;
#line 364
  __cil_tmp60 = (unsigned long )(msg) + __cil_tmp59;
#line 364
  *((u32 *)__cil_tmp60) = 0U;
#line 366
  __cil_tmp61 = 4 * 4UL;
#line 366
  __cil_tmp62 = (unsigned long )(msg) + __cil_tmp61;
#line 366
  *((u32 *)__cil_tmp62) = 1769601U;
#line 367
  __cil_tmp63 = 5 * 4UL;
#line 367
  __cil_tmp64 = (unsigned long )(msg) + __cil_tmp63;
#line 367
  *((u32 *)__cil_tmp64) = 65536U;
#line 372
  __cil_tmp65 = 6 * 4UL;
#line 372
  __cil_tmp66 = (unsigned long )(msg) + __cil_tmp65;
#line 372
  __cil_tmp67 = scsidir | 547356678;
#line 372
  *((u32 *)__cil_tmp66) = (u32 )__cil_tmp67;
#line 374
  __cil_tmp68 = (u32 *)(& msg);
#line 374
  mptr = __cil_tmp68 + 7UL;
#line 376
  __cil_tmp69 = (void *)(& scb);
#line 376
  memset(__cil_tmp69, 0, 16UL);
#line 378
  __cil_tmp70 = 0 * 1UL;
#line 378
  __cil_tmp71 = (unsigned long )(scb) + __cil_tmp70;
#line 378
  *((u8 *)__cil_tmp71) = (u8 )18U;
#line 379
  __cil_tmp72 = 1 * 1UL;
#line 379
  __cil_tmp73 = (unsigned long )(scb) + __cil_tmp72;
#line 379
  *((u8 *)__cil_tmp73) = (u8 )0U;
#line 380
  __cil_tmp74 = 2 * 1UL;
#line 380
  __cil_tmp75 = (unsigned long )(scb) + __cil_tmp74;
#line 380
  *((u8 *)__cil_tmp75) = (u8 )0U;
#line 381
  __cil_tmp76 = 3 * 1UL;
#line 381
  __cil_tmp77 = (unsigned long )(scb) + __cil_tmp76;
#line 381
  *((u8 *)__cil_tmp77) = (u8 )0U;
#line 382
  __cil_tmp78 = 4 * 1UL;
#line 382
  __cil_tmp79 = (unsigned long )(scb) + __cil_tmp78;
#line 382
  *((u8 *)__cil_tmp79) = (u8 )36U;
#line 383
  __cil_tmp80 = 5 * 1UL;
#line 383
  __cil_tmp81 = (unsigned long )(scb) + __cil_tmp80;
#line 383
  *((u8 *)__cil_tmp81) = (u8 )0U;
#line 386
  __len = 16UL;
  }
#line 386
  if (__len > 63UL) {
    {
#line 386
    __cil_tmp82 = (void *)mptr;
#line 386
    __cil_tmp83 = (void    *)(& scb);
#line 386
    __ret = __memcpy(__cil_tmp82, __cil_tmp83, __len);
    }
  } else {
    {
#line 386
    __cil_tmp84 = (void *)mptr;
#line 386
    __cil_tmp85 = (void    *)(& scb);
#line 386
    __ret = __builtin_memcpy(__cil_tmp84, __cil_tmp85, __len);
    }
  }
  {
#line 387
  mptr = mptr + 4UL;
#line 388
  tmp___1 = mptr;
#line 388
  mptr = mptr + 1;
#line 388
  lenptr = tmp___1;
#line 391
  *lenptr = len;
#line 392
  tmp___9 = dpt_dma64(pHba);
  }
#line 392
  if (tmp___9 != 0) {
    {
#line 393
    tmp___2 = mptr;
#line 393
    mptr = mptr + 1;
#line 393
    *tmp___2 = 2080505858U;
#line 394
    tmp___3 = mptr;
#line 394
    mptr = mptr + 1;
#line 394
    *tmp___3 = 4096U;
#line 395
    tmp___4 = mptr;
#line 395
    mptr = mptr + 1;
#line 395
    __cil_tmp86 = (unsigned int )direction;
#line 395
    __cil_tmp87 = __cil_tmp86 | len;
#line 395
    *tmp___4 = __cil_tmp87 | 3489660928U;
#line 396
    tmp___5 = mptr;
#line 396
    mptr = mptr + 1;
#line 396
    __cil_tmp88 = & addr;
#line 396
    __cil_tmp89 = *__cil_tmp88;
#line 396
    *tmp___5 = dma_low(__cil_tmp89);
#line 397
    tmp___6 = mptr;
#line 397
    mptr = mptr + 1;
#line 397
    __cil_tmp90 = & addr;
#line 397
    __cil_tmp91 = *__cil_tmp90;
#line 397
    *tmp___6 = dma_high(__cil_tmp91);
    }
  } else {
#line 399
    tmp___7 = mptr;
#line 399
    mptr = mptr + 1;
#line 399
    __cil_tmp92 = (unsigned int )direction;
#line 399
    __cil_tmp93 = __cil_tmp92 | len;
#line 399
    *tmp___7 = __cil_tmp93 | 3489660928U;
#line 400
    tmp___8 = mptr;
#line 400
    mptr = mptr + 1;
#line 400
    __cil_tmp94 = & addr;
#line 400
    __cil_tmp95 = *__cil_tmp94;
#line 400
    *tmp___8 = (u32 )__cil_tmp95;
  }
  {
#line 404
  __cil_tmp96 = (u32 *)(& msg);
#line 404
  __cil_tmp97 = reqlen << 2;
#line 404
  __cil_tmp98 = (int )__cil_tmp97;
#line 404
  rcode = adpt_i2o_post_wait(pHba, __cil_tmp96, __cil_tmp98, 120);
  }
#line 405
  if (rcode != 0) {
    {
#line 406
    __cil_tmp99 = (unsigned long )pHba;
#line 406
    __cil_tmp100 = __cil_tmp99 + 146;
#line 406
    __cil_tmp101 = (char (*)[55U])__cil_tmp100;
#line 406
    __cil_tmp102 = (char *)__cil_tmp101;
#line 406
    sprintf(__cil_tmp102, "Adaptec I2O RAID");
#line 407
    __cil_tmp103 = (unsigned long )pHba;
#line 407
    __cil_tmp104 = __cil_tmp103 + 114;
#line 407
    __cil_tmp105 = (char (*)[32U])__cil_tmp104;
#line 407
    __cil_tmp106 = (char *)__cil_tmp105;
#line 407
    printk("<6>%s: Inquiry Error (%d)\n", __cil_tmp106, rcode);
    }
#line 408
    if (rcode != -62) {
#line 408
      if (rcode != -4) {
        {
#line 409
        __cil_tmp107 = (unsigned long )pHba;
#line 409
        __cil_tmp108 = __cil_tmp107 + 8;
#line 409
        __cil_tmp109 = *((struct pci_dev **)__cil_tmp108);
#line 409
        __cil_tmp110 = (unsigned long )__cil_tmp109;
#line 409
        __cil_tmp111 = __cil_tmp110 + 144;
#line 409
        __cil_tmp112 = (struct device *)__cil_tmp111;
#line 409
        __cil_tmp113 = (void *)buf;
#line 409
        __cil_tmp114 = & addr;
#line 409
        __cil_tmp115 = *__cil_tmp114;
#line 409
        __cil_tmp116 = (struct dma_attrs *)0;
#line 409
        dma_free_attrs(__cil_tmp112, 80UL, __cil_tmp113, __cil_tmp115, __cil_tmp116);
        }
      } else {

      }
    } else {

    }
  } else {
    {
#line 411
    __cil_tmp117 = (unsigned long )pHba;
#line 411
    __cil_tmp118 = __cil_tmp117 + 146;
#line 411
    __cil_tmp119 = (char (*)[55U])__cil_tmp118;
#line 411
    __cil_tmp120 = (void *)__cil_tmp119;
#line 411
    memset(__cil_tmp120, 0, 55UL);
#line 412
    __len___0 = 16UL;
    }
#line 412
    if (__len___0 > 63UL) {
      {
#line 412
      __cil_tmp121 = (unsigned long )pHba;
#line 412
      __cil_tmp122 = __cil_tmp121 + 146;
#line 412
      __cil_tmp123 = (char (*)[55U])__cil_tmp122;
#line 412
      __cil_tmp124 = (void *)__cil_tmp123;
#line 412
      __cil_tmp125 = (void    *)"Vendor: Adaptec ";
#line 412
      __ret___0 = __memcpy(__cil_tmp124, __cil_tmp125, __len___0);
      }
    } else {
      {
#line 412
      __cil_tmp126 = (unsigned long )pHba;
#line 412
      __cil_tmp127 = __cil_tmp126 + 146;
#line 412
      __cil_tmp128 = (char (*)[55U])__cil_tmp127;
#line 412
      __cil_tmp129 = (void *)__cil_tmp128;
#line 412
      __cil_tmp130 = (void    *)"Vendor: Adaptec ";
#line 412
      __ret___0 = __builtin_memcpy(__cil_tmp129, __cil_tmp130, __len___0);
      }
    }
#line 413
    __len___1 = 8UL;
#line 413
    if (__len___1 > 63UL) {
      {
#line 413
      __cil_tmp131 = (unsigned long )pHba;
#line 413
      __cil_tmp132 = __cil_tmp131 + 146;
#line 413
      __cil_tmp133 = (char (*)[55U])__cil_tmp132;
#line 413
      __cil_tmp134 = (void *)__cil_tmp133;
#line 413
      __cil_tmp135 = __cil_tmp134 + 16U;
#line 413
      __cil_tmp136 = (void    *)" Model: ";
#line 413
      __ret___1 = __memcpy(__cil_tmp135, __cil_tmp136, __len___1);
      }
    } else {
      {
#line 413
      __cil_tmp137 = (unsigned long )pHba;
#line 413
      __cil_tmp138 = __cil_tmp137 + 146;
#line 413
      __cil_tmp139 = (char (*)[55U])__cil_tmp138;
#line 413
      __cil_tmp140 = (void *)__cil_tmp139;
#line 413
      __cil_tmp141 = __cil_tmp140 + 16U;
#line 413
      __cil_tmp142 = (void    *)" Model: ";
#line 413
      __ret___1 = __builtin_memcpy(__cil_tmp141, __cil_tmp142, __len___1);
      }
    }
#line 414
    __len___2 = 16UL;
#line 414
    if (__len___2 > 63UL) {
      {
#line 414
      __cil_tmp143 = (unsigned long )pHba;
#line 414
      __cil_tmp144 = __cil_tmp143 + 146;
#line 414
      __cil_tmp145 = (char (*)[55U])__cil_tmp144;
#line 414
      __cil_tmp146 = (void *)__cil_tmp145;
#line 414
      __cil_tmp147 = __cil_tmp146 + 24U;
#line 414
      __cil_tmp148 = (void    *)buf;
#line 414
      __cil_tmp149 = __cil_tmp148 + 16U;
#line 414
      __ret___2 = __memcpy(__cil_tmp147, __cil_tmp149, __len___2);
      }
    } else {
      {
#line 414
      __cil_tmp150 = (unsigned long )pHba;
#line 414
      __cil_tmp151 = __cil_tmp150 + 146;
#line 414
      __cil_tmp152 = (char (*)[55U])__cil_tmp151;
#line 414
      __cil_tmp153 = (void *)__cil_tmp152;
#line 414
      __cil_tmp154 = __cil_tmp153 + 24U;
#line 414
      __cil_tmp155 = (void    *)buf;
#line 414
      __cil_tmp156 = __cil_tmp155 + 16U;
#line 414
      __ret___2 = __builtin_memcpy(__cil_tmp154, __cil_tmp156, __len___2);
      }
    }
#line 415
    __len___3 = 4UL;
#line 415
    if (__len___3 > 63UL) {
      {
#line 415
      __cil_tmp157 = (unsigned long )pHba;
#line 415
      __cil_tmp158 = __cil_tmp157 + 146;
#line 415
      __cil_tmp159 = (char (*)[55U])__cil_tmp158;
#line 415
      __cil_tmp160 = (void *)__cil_tmp159;
#line 415
      __cil_tmp161 = __cil_tmp160 + 40U;
#line 415
      __cil_tmp162 = (void    *)" FW: ";
#line 415
      __ret___3 = __memcpy(__cil_tmp161, __cil_tmp162, __len___3);
      }
    } else {
      {
#line 415
      __cil_tmp163 = (unsigned long )pHba;
#line 415
      __cil_tmp164 = __cil_tmp163 + 146;
#line 415
      __cil_tmp165 = (char (*)[55U])__cil_tmp164;
#line 415
      __cil_tmp166 = (void *)__cil_tmp165;
#line 415
      __cil_tmp167 = __cil_tmp166 + 40U;
#line 415
      __cil_tmp168 = (void    *)" FW: ";
#line 415
      __ret___3 = __builtin_memcpy(__cil_tmp167, __cil_tmp168, __len___3);
      }
    }
#line 416
    __len___4 = 4UL;
#line 416
    if (__len___4 > 63UL) {
      {
#line 416
      __cil_tmp169 = (unsigned long )pHba;
#line 416
      __cil_tmp170 = __cil_tmp169 + 146;
#line 416
      __cil_tmp171 = (char (*)[55U])__cil_tmp170;
#line 416
      __cil_tmp172 = (void *)__cil_tmp171;
#line 416
      __cil_tmp173 = __cil_tmp172 + 44U;
#line 416
      __cil_tmp174 = (void    *)buf;
#line 416
      __cil_tmp175 = __cil_tmp174 + 32U;
#line 416
      __ret___4 = __memcpy(__cil_tmp173, __cil_tmp175, __len___4);
      }
    } else {
      {
#line 416
      __cil_tmp176 = (unsigned long )pHba;
#line 416
      __cil_tmp177 = __cil_tmp176 + 146;
#line 416
      __cil_tmp178 = (char (*)[55U])__cil_tmp177;
#line 416
      __cil_tmp179 = (void *)__cil_tmp178;
#line 416
      __cil_tmp180 = __cil_tmp179 + 44U;
#line 416
      __cil_tmp181 = (void    *)buf;
#line 416
      __cil_tmp182 = __cil_tmp181 + 32U;
#line 416
      __ret___4 = __builtin_memcpy(__cil_tmp180, __cil_tmp182, __len___4);
      }
    }
    {
#line 417
    __cil_tmp183 = 48 * 1UL;
#line 417
    __cil_tmp184 = 146 + __cil_tmp183;
#line 417
    __cil_tmp185 = (unsigned long )pHba;
#line 417
    __cil_tmp186 = __cil_tmp185 + __cil_tmp184;
#line 417
    *((char *)__cil_tmp186) = (char)0;
#line 418
    __cil_tmp187 = (unsigned long )pHba;
#line 418
    __cil_tmp188 = __cil_tmp187 + 8;
#line 418
    __cil_tmp189 = *((struct pci_dev **)__cil_tmp188);
#line 418
    __cil_tmp190 = (unsigned long )__cil_tmp189;
#line 418
    __cil_tmp191 = __cil_tmp190 + 144;
#line 418
    __cil_tmp192 = (struct device *)__cil_tmp191;
#line 418
    __cil_tmp193 = (void *)buf;
#line 418
    __cil_tmp194 = & addr;
#line 418
    __cil_tmp195 = *__cil_tmp194;
#line 418
    __cil_tmp196 = (struct dma_attrs *)0;
#line 418
    dma_free_attrs(__cil_tmp192, 80UL, __cil_tmp193, __cil_tmp195, __cil_tmp196);
    }
  }
  {
#line 420
  adpt_i2o_status_get(pHba);
  }
#line 421
  return;
}
}
#line 425 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_slave_configure(struct scsi_device *device ) 
{ struct Scsi_Host *host ;
  adpt_hba *pHba ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  unsigned char __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 427
  host = *((struct Scsi_Host **)device);
#line 430
  __cil_tmp4 = 0 * 8UL;
#line 430
  __cil_tmp5 = 3048 + __cil_tmp4;
#line 430
  __cil_tmp6 = (unsigned long )host;
#line 430
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
#line 430
  __cil_tmp8 = *((unsigned long *)__cil_tmp7);
#line 430
  pHba = (adpt_hba *)__cil_tmp8;
  {
#line 432
  __cil_tmp9 = (unsigned long )host;
#line 432
  __cil_tmp10 = __cil_tmp9 + 592;
#line 432
  __cil_tmp11 = *((int *)__cil_tmp10);
#line 432
  if (__cil_tmp11 != 0) {
    {
#line 432
    __cil_tmp12 = (unsigned char *)device;
#line 432
    __cil_tmp13 = __cil_tmp12 + 293UL;
#line 432
    __cil_tmp14 = *__cil_tmp13;
#line 432
    __cil_tmp15 = (unsigned int )__cil_tmp14;
#line 432
    if (__cil_tmp15 != 0U) {
      {
#line 433
      __cil_tmp16 = (unsigned long )host;
#line 433
      __cil_tmp17 = __cil_tmp16 + 592;
#line 433
      __cil_tmp18 = *((int *)__cil_tmp17);
#line 433
      __cil_tmp19 = __cil_tmp18 + -1;
#line 433
      scsi_adjust_queue_depth(device, 32, __cil_tmp19);
      }
    } else {
      {
#line 436
      scsi_adjust_queue_depth(device, 0, 1);
      }
    }
    }
  } else {
    {
#line 436
    scsi_adjust_queue_depth(device, 0, 1);
    }
  }
  }
#line 438
  return (0);
}
}
#line 441 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_queue_lck(struct scsi_cmnd *cmd , void (*done)(struct scsi_cmnd * ) ) 
{ adpt_hba *pHba ;
  struct adpt_device *pDev ;
  s32 tmp ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  unsigned char __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  unsigned char __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  void (*__cil_tmp22)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct scsi_device *__cil_tmp25 ;
  struct Scsi_Host *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  adpt_hba *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  u32 __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct Scsi_Host *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct Scsi_Host *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  u32 __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct Scsi_Host *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct Scsi_Host *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct scsi_device *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  void *__cil_tmp64 ;
  struct adpt_device *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct scsi_device *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  struct scsi_device *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  struct scsi_device *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  struct adpt_device *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  void (*__cil_tmp87)(struct scsi_cmnd * ) ;
  struct scsi_device *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  u8 __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;

  {
#line 443
  pHba = (adpt_hba *)0;
#line 444
  pDev = (struct adpt_device *)0;
#line 446
  __cil_tmp6 = (unsigned long )cmd;
#line 446
  __cil_tmp7 = __cil_tmp6 + 144;
#line 446
  *((void (**)(struct scsi_cmnd * ))__cil_tmp7) = done;
  {
#line 454
  __cil_tmp8 = (unsigned long )cmd;
#line 454
  __cil_tmp9 = __cil_tmp8 + 80;
#line 454
  __cil_tmp10 = *((unsigned char **)__cil_tmp9);
#line 454
  __cil_tmp11 = *__cil_tmp10;
#line 454
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 454
  if (__cil_tmp12 == 3U) {
    {
#line 454
    __cil_tmp13 = (unsigned long )cmd;
#line 454
    __cil_tmp14 = __cil_tmp13 + 136;
#line 454
    __cil_tmp15 = *((unsigned char **)__cil_tmp14);
#line 454
    __cil_tmp16 = *__cil_tmp15;
#line 454
    __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 454
    if (__cil_tmp17 != 0U) {
      {
#line 455
      __cil_tmp18 = (unsigned long )cmd;
#line 455
      __cil_tmp19 = __cil_tmp18 + 224;
#line 455
      *((int *)__cil_tmp19) = 0;
#line 456
      __cil_tmp20 = (unsigned long )cmd;
#line 456
      __cil_tmp21 = __cil_tmp20 + 144;
#line 456
      __cil_tmp22 = *((void (**)(struct scsi_cmnd * ))__cil_tmp21);
#line 456
      (*__cil_tmp22)(cmd);
      }
#line 457
      return (0);
    } else {

    }
    }
  } else {

  }
  }
#line 460
  __cil_tmp23 = 0 * 8UL;
#line 460
  __cil_tmp24 = 3048 + __cil_tmp23;
#line 460
  __cil_tmp25 = *((struct scsi_device **)cmd);
#line 460
  __cil_tmp26 = *((struct Scsi_Host **)__cil_tmp25);
#line 460
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 460
  __cil_tmp28 = __cil_tmp27 + __cil_tmp24;
#line 460
  __cil_tmp29 = *((unsigned long *)__cil_tmp28);
#line 460
  pHba = (adpt_hba *)__cil_tmp29;
  {
#line 461
  __cil_tmp30 = (adpt_hba *)0;
#line 461
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 461
  __cil_tmp32 = (unsigned long )pHba;
#line 461
  if (__cil_tmp32 == __cil_tmp31) {
#line 462
    return (8195);
  } else {

  }
  }
#line 465
  __asm__  volatile   ("lfence": : : "memory");
  {
#line 474
  __cil_tmp33 = (unsigned long )pHba;
#line 474
  __cil_tmp34 = __cil_tmp33 + 24;
#line 474
  __cil_tmp35 = *((u32 *)__cil_tmp34);
#line 474
  __cil_tmp36 = __cil_tmp35 & 2U;
#line 474
  if (__cil_tmp36 != 0U) {
#line 475
    __cil_tmp37 = (unsigned long )pHba;
#line 475
    __cil_tmp38 = __cil_tmp37 + 16;
#line 475
    __cil_tmp39 = *((struct Scsi_Host **)__cil_tmp38);
#line 475
    __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 475
    __cil_tmp41 = __cil_tmp40 + 560;
#line 475
    *((unsigned long *)__cil_tmp41) = (unsigned long )jiffies;
#line 476
    __cil_tmp42 = (unsigned long )pHba;
#line 476
    __cil_tmp43 = __cil_tmp42 + 16;
#line 476
    __cil_tmp44 = *((struct Scsi_Host **)__cil_tmp43);
#line 476
    __cil_tmp45 = (unsigned long )__cil_tmp44;
#line 476
    __cil_tmp46 = __cil_tmp45 + 552;
#line 476
    *((int *)__cil_tmp46) = 1;
#line 477
    return (1);
  } else {
    {
#line 474
    __cil_tmp47 = (unsigned long )pHba;
#line 474
    __cil_tmp48 = __cil_tmp47 + 24;
#line 474
    __cil_tmp49 = *((u32 *)__cil_tmp48);
#line 474
    __cil_tmp50 = (int )__cil_tmp49;
#line 474
    if (__cil_tmp50 & 1) {
#line 475
      __cil_tmp51 = (unsigned long )pHba;
#line 475
      __cil_tmp52 = __cil_tmp51 + 16;
#line 475
      __cil_tmp53 = *((struct Scsi_Host **)__cil_tmp52);
#line 475
      __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 475
      __cil_tmp55 = __cil_tmp54 + 560;
#line 475
      *((unsigned long *)__cil_tmp55) = (unsigned long )jiffies;
#line 476
      __cil_tmp56 = (unsigned long )pHba;
#line 476
      __cil_tmp57 = __cil_tmp56 + 16;
#line 476
      __cil_tmp58 = *((struct Scsi_Host **)__cil_tmp57);
#line 476
      __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 476
      __cil_tmp60 = __cil_tmp59 + 552;
#line 476
      *((int *)__cil_tmp60) = 1;
#line 477
      return (1);
    } else {

    }
    }
  }
  }
#line 482
  __cil_tmp61 = *((struct scsi_device **)cmd);
#line 482
  __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 482
  __cil_tmp63 = __cil_tmp62 + 224;
#line 482
  __cil_tmp64 = *((void **)__cil_tmp63);
#line 482
  pDev = (struct adpt_device *)__cil_tmp64;
  {
#line 482
  __cil_tmp65 = (struct adpt_device *)0;
#line 482
  __cil_tmp66 = (unsigned long )__cil_tmp65;
#line 482
  __cil_tmp67 = (unsigned long )pDev;
#line 482
  if (__cil_tmp67 == __cil_tmp66) {
    {
#line 488
    __cil_tmp68 = *((struct scsi_device **)cmd);
#line 488
    __cil_tmp69 = (unsigned long )__cil_tmp68;
#line 488
    __cil_tmp70 = __cil_tmp69 + 208;
#line 488
    __cil_tmp71 = *((unsigned int *)__cil_tmp70);
#line 488
    __cil_tmp72 = *((struct scsi_device **)cmd);
#line 488
    __cil_tmp73 = (unsigned long )__cil_tmp72;
#line 488
    __cil_tmp74 = __cil_tmp73 + 200;
#line 488
    __cil_tmp75 = *((unsigned int *)__cil_tmp74);
#line 488
    __cil_tmp76 = *((struct scsi_device **)cmd);
#line 488
    __cil_tmp77 = (unsigned long )__cil_tmp76;
#line 488
    __cil_tmp78 = __cil_tmp77 + 204;
#line 488
    __cil_tmp79 = *((unsigned int *)__cil_tmp78);
#line 488
    pDev = adpt_find_device(pHba, __cil_tmp71, __cil_tmp75, __cil_tmp79);
    }
    {
#line 488
    __cil_tmp80 = (struct adpt_device *)0;
#line 488
    __cil_tmp81 = (unsigned long )__cil_tmp80;
#line 488
    __cil_tmp82 = (unsigned long )pDev;
#line 488
    if (__cil_tmp82 == __cil_tmp81) {
      {
#line 491
      __cil_tmp83 = (unsigned long )cmd;
#line 491
      __cil_tmp84 = __cil_tmp83 + 224;
#line 491
      *((int *)__cil_tmp84) = 65536;
#line 492
      __cil_tmp85 = (unsigned long )cmd;
#line 492
      __cil_tmp86 = __cil_tmp85 + 144;
#line 492
      __cil_tmp87 = *((void (**)(struct scsi_cmnd * ))__cil_tmp86);
#line 492
      (*__cil_tmp87)(cmd);
      }
#line 493
      return (0);
    } else {

    }
    }
#line 495
    __cil_tmp88 = *((struct scsi_device **)cmd);
#line 495
    __cil_tmp89 = (unsigned long )__cil_tmp88;
#line 495
    __cil_tmp90 = __cil_tmp89 + 224;
#line 495
    *((void **)__cil_tmp90) = (void *)pDev;
  } else {

  }
  }
#line 497
  __cil_tmp91 = (unsigned long )pDev;
#line 497
  __cil_tmp92 = __cil_tmp91 + 40;
#line 497
  *((struct scsi_device **)__cil_tmp92) = *((struct scsi_device **)cmd);
  {
#line 503
  __cil_tmp93 = (unsigned long )pDev;
#line 503
  __cil_tmp94 = __cil_tmp93 + 27;
#line 503
  __cil_tmp95 = *((u8 *)__cil_tmp94);
#line 503
  __cil_tmp96 = (int )__cil_tmp95;
#line 503
  __cil_tmp97 = __cil_tmp96 & 2;
#line 503
  if (__cil_tmp97 != 0) {
#line 504
    return (8195);
  } else {

  }
  }
  {
#line 506
  tmp = adpt_scsi_to_i2o(pHba, cmd, pDev);
  }
#line 506
  return (tmp);
}
}
#line 509 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_queue(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ unsigned long irq_flags ;
  int rc ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  void (*__cil_tmp7)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  spinlock_t *__cil_tmp10 ;

  {
  {
#line 509
  ldv_spin_lock();
#line 509
  scsi_cmd_get_serial(shost, cmd);
#line 509
  __cil_tmp5 = (unsigned long )cmd;
#line 509
  __cil_tmp6 = __cil_tmp5 + 144;
#line 509
  __cil_tmp7 = *((void (**)(struct scsi_cmnd * ))__cil_tmp6);
#line 509
  rc = adpt_queue_lck(cmd, __cil_tmp7);
#line 509
  __cil_tmp8 = (unsigned long )shost;
#line 509
  __cil_tmp9 = __cil_tmp8 + 216;
#line 509
  __cil_tmp10 = *((spinlock_t **)__cil_tmp9);
#line 509
  spin_unlock_irqrestore(__cil_tmp10, irq_flags);
  }
#line 509
  return (rc);
}
}
#line 511 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_bios_param(struct scsi_device *sdev , struct block_device *dev , sector_t capacity ,
                           int *geom ) 
{ int heads ;
  int sectors ;
  int cylinders ;
  int _res ;
  int __cil_tmp9 ;
  sector_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  sector_t __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  char __cil_tmp16 ;
  signed char __cil_tmp17 ;
  int __cil_tmp18 ;
  int *__cil_tmp19 ;
  int *__cil_tmp20 ;

  {
#line 514
  heads = -1;
#line 515
  sectors = -1;
#line 516
  cylinders = -1;
#line 521
  if (capacity <= 8191UL) {
#line 522
    heads = 18;
#line 523
    sectors = 2;
  } else
#line 526
  if (capacity <= 131071UL) {
#line 527
    heads = 64;
#line 528
    sectors = 32;
  } else
#line 531
  if (capacity <= 262143UL) {
#line 532
    heads = 65;
#line 533
    sectors = 63;
  } else
#line 536
  if (capacity <= 524287UL) {
#line 537
    heads = 128;
#line 538
    sectors = 63;
  } else {
#line 542
    heads = 255;
#line 543
    sectors = 63;
  }
#line 545
  __cil_tmp9 = heads * sectors;
#line 545
  __cil_tmp10 = (sector_t )__cil_tmp9;
#line 545
  __cil_tmp11 = capacity % __cil_tmp10;
#line 545
  _res = (int )__cil_tmp11;
#line 545
  __cil_tmp12 = heads * sectors;
#line 545
  __cil_tmp13 = (sector_t )__cil_tmp12;
#line 545
  capacity = capacity / __cil_tmp13;
#line 545
  cylinders = _res;
  {
#line 548
  __cil_tmp14 = (unsigned long )sdev;
#line 548
  __cil_tmp15 = __cil_tmp14 + 232;
#line 548
  __cil_tmp16 = *((char *)__cil_tmp15);
#line 548
  __cil_tmp17 = (signed char )__cil_tmp16;
#line 548
  __cil_tmp18 = (int )__cil_tmp17;
#line 548
  if (__cil_tmp18 == 5) {
#line 549
    heads = 252;
#line 550
    sectors = 63;
#line 551
    cylinders = 1111;
  } else {

  }
  }
#line 554
  *geom = heads;
#line 555
  __cil_tmp19 = geom + 1UL;
#line 555
  *__cil_tmp19 = sectors;
#line 556
  __cil_tmp20 = geom + 2UL;
#line 556
  *__cil_tmp20 = cylinders;
#line 559
  return (0);
}
}
#line 563 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static char    *adpt_info(struct Scsi_Host *host ) 
{ adpt_hba *pHba ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char (*__cil_tmp10)[55U] ;

  {
#line 567
  __cil_tmp3 = 0 * 8UL;
#line 567
  __cil_tmp4 = 3048 + __cil_tmp3;
#line 567
  __cil_tmp5 = (unsigned long )host;
#line 567
  __cil_tmp6 = __cil_tmp5 + __cil_tmp4;
#line 567
  __cil_tmp7 = *((unsigned long *)__cil_tmp6);
#line 567
  pHba = (adpt_hba *)__cil_tmp7;
  {
#line 568
  __cil_tmp8 = (unsigned long )pHba;
#line 568
  __cil_tmp9 = __cil_tmp8 + 146;
#line 568
  __cil_tmp10 = (char (*)[55U])__cil_tmp9;
#line 568
  return ((char    *)__cil_tmp10);
  }
}
}
#line 571 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_proc_info(struct Scsi_Host *host , char *buffer , char **start , off_t offset ,
                          int length , int inout ) 
{ struct adpt_device *d ;
  int id ;
  int chan ;
  int len ;
  int begin ;
  int pos ;
  adpt_hba *pHba ;
  int unit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  struct Scsi_Host *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  adpt_hba *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  adpt_hba *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  char *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  char *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  char (*__cil_tmp43)[55U] ;
  char *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  char *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct Scsi_Host *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  char (*__cil_tmp55)[32U] ;
  char *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  char *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  u32 __cil_tmp67 ;
  int __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned short __cil_tmp71 ;
  int __cil_tmp72 ;
  off_t __cil_tmp73 ;
  off_t __cil_tmp74 ;
  off_t __cil_tmp75 ;
  off_t __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  char *__cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  char *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct scsi_device *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  char    *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  char *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct scsi_device *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  char    *__cil_tmp101 ;
  off_t __cil_tmp102 ;
  off_t __cil_tmp103 ;
  off_t __cil_tmp104 ;
  off_t __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  struct i2o_device *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned short __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  struct scsi_device *__cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  char *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  u8 __cil_tmp120 ;
  int __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  u8 __cil_tmp124 ;
  int __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  u8 __cil_tmp128 ;
  int __cil_tmp129 ;
  off_t __cil_tmp130 ;
  off_t __cil_tmp131 ;
  off_t __cil_tmp132 ;
  off_t __cil_tmp133 ;
  struct adpt_device *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  char *__cil_tmp138 ;
  off_t __cil_tmp139 ;
  off_t __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned int __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  unsigned int __cil_tmp144 ;
  unsigned int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  char *__cil_tmp147 ;

  {
#line 577
  len = 0;
#line 578
  begin = 0;
#line 579
  pos = 0;
#line 583
  *start = buffer;
#line 584
  if (inout == 1) {
#line 592
    return (-22);
  } else {

  }
  {
#line 602
  mutex_lock_nested(& adpt_configuration_lock, 0U);
#line 603
  pHba = hba_chain;
  }
#line 603
  goto ldv_32210;
  ldv_32209: ;
  {
#line 604
  __cil_tmp25 = (unsigned long )host;
#line 604
  __cil_tmp26 = (unsigned long )pHba;
#line 604
  __cil_tmp27 = __cil_tmp26 + 16;
#line 604
  __cil_tmp28 = *((struct Scsi_Host **)__cil_tmp27);
#line 604
  __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 604
  if (__cil_tmp29 == __cil_tmp25) {
#line 605
    goto ldv_32208;
  } else {

  }
  }
#line 603
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32210: ;
  {
#line 603
  __cil_tmp30 = (adpt_hba *)0;
#line 603
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 603
  __cil_tmp32 = (unsigned long )pHba;
#line 603
  if (__cil_tmp32 != __cil_tmp31) {
#line 604
    goto ldv_32209;
  } else {
#line 606
    goto ldv_32208;
  }
  }
  ldv_32208: 
  {
#line 608
  mutex_unlock(& adpt_configuration_lock);
  }
  {
#line 609
  __cil_tmp33 = (adpt_hba *)0;
#line 609
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 609
  __cil_tmp35 = (unsigned long )pHba;
#line 609
  if (__cil_tmp35 == __cil_tmp34) {
#line 610
    return (0);
  } else {

  }
  }
  {
#line 612
  __cil_tmp36 = (unsigned long )pHba;
#line 612
  __cil_tmp37 = __cil_tmp36 + 16;
#line 612
  host = *((struct Scsi_Host **)__cil_tmp37);
#line 614
  __cil_tmp38 = (char *)"2.4 Build 5go";
#line 614
  len = sprintf(buffer, "Adaptec I2O RAID Driver Version: %s\n\n", __cil_tmp38);
#line 615
  __cil_tmp39 = (unsigned long )len;
#line 615
  __cil_tmp40 = buffer + __cil_tmp39;
#line 615
  __cil_tmp41 = (unsigned long )pHba;
#line 615
  __cil_tmp42 = __cil_tmp41 + 146;
#line 615
  __cil_tmp43 = (char (*)[55U])__cil_tmp42;
#line 615
  __cil_tmp44 = (char *)__cil_tmp43;
#line 615
  tmp = sprintf(__cil_tmp40, "%s\n", __cil_tmp44);
#line 615
  len = tmp + len;
#line 616
  __cil_tmp45 = (unsigned long )len;
#line 616
  __cil_tmp46 = buffer + __cil_tmp45;
#line 616
  __cil_tmp47 = (unsigned long )pHba;
#line 616
  __cil_tmp48 = __cil_tmp47 + 16;
#line 616
  __cil_tmp49 = *((struct Scsi_Host **)__cil_tmp48);
#line 616
  __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 616
  __cil_tmp51 = __cil_tmp50 + 548;
#line 616
  __cil_tmp52 = *((unsigned int *)__cil_tmp51);
#line 616
  __cil_tmp53 = (unsigned long )pHba;
#line 616
  __cil_tmp54 = __cil_tmp53 + 114;
#line 616
  __cil_tmp55 = (char (*)[32U])__cil_tmp54;
#line 616
  __cil_tmp56 = (char *)__cil_tmp55;
#line 616
  __cil_tmp57 = (unsigned long )host;
#line 616
  __cil_tmp58 = __cil_tmp57 + 700;
#line 616
  __cil_tmp59 = *((unsigned int *)__cil_tmp58);
#line 616
  tmp___0 = sprintf(__cil_tmp46, "SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n",
                    __cil_tmp52, __cil_tmp56, __cil_tmp59);
#line 616
  len = tmp___0 + len;
#line 618
  __cil_tmp60 = (unsigned long )len;
#line 618
  __cil_tmp61 = buffer + __cil_tmp60;
#line 618
  __cil_tmp62 = (unsigned long )host;
#line 618
  __cil_tmp63 = __cil_tmp62 + 592;
#line 618
  __cil_tmp64 = *((int *)__cil_tmp63);
#line 618
  __cil_tmp65 = (unsigned long )pHba;
#line 618
  __cil_tmp66 = __cil_tmp65 + 264;
#line 618
  __cil_tmp67 = *((u32 *)__cil_tmp66);
#line 618
  __cil_tmp68 = (int )__cil_tmp67;
#line 618
  __cil_tmp69 = (unsigned long )host;
#line 618
  __cil_tmp70 = __cil_tmp69 + 598;
#line 618
  __cil_tmp71 = *((unsigned short *)__cil_tmp70);
#line 618
  __cil_tmp72 = (int )__cil_tmp71;
#line 618
  tmp___1 = sprintf(__cil_tmp61, "\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n",
                    __cil_tmp64, __cil_tmp68, __cil_tmp72);
#line 618
  len = tmp___1 + len;
#line 621
  pos = begin + len;
  }
  {
#line 624
  __cil_tmp73 = (off_t )length;
#line 624
  __cil_tmp74 = __cil_tmp73 + offset;
#line 624
  __cil_tmp75 = (off_t )pos;
#line 624
  if (__cil_tmp75 > __cil_tmp74) {
#line 625
    goto stop_output;
  } else {

  }
  }
  {
#line 627
  __cil_tmp76 = (off_t )pos;
#line 627
  if (__cil_tmp76 <= offset) {
#line 633
    len = 0;
#line 634
    begin = pos;
  } else {

  }
  }
  {
#line 636
  __cil_tmp77 = (unsigned long )len;
#line 636
  __cil_tmp78 = buffer + __cil_tmp77;
#line 636
  tmp___2 = sprintf(__cil_tmp78, "Devices:\n");
#line 636
  len = tmp___2 + len;
#line 637
  chan = 0;
  }
#line 637
  goto ldv_32219;
  ldv_32218: 
#line 638
  id = 0;
#line 638
  goto ldv_32216;
  ldv_32215: 
#line 639
  __cil_tmp79 = id * 8UL;
#line 639
  __cil_tmp80 = 0 + __cil_tmp79;
#line 639
  __cil_tmp81 = chan * 1040UL;
#line 639
  __cil_tmp82 = __cil_tmp81 + __cil_tmp80;
#line 639
  __cil_tmp83 = 360 + __cil_tmp82;
#line 639
  __cil_tmp84 = (unsigned long )pHba;
#line 639
  __cil_tmp85 = __cil_tmp84 + __cil_tmp83;
#line 639
  d = *((struct adpt_device **)__cil_tmp85);
#line 640
  goto ldv_32213;
  ldv_32212: 
  {
#line 641
  __cil_tmp86 = (unsigned long )len;
#line 641
  __cil_tmp87 = buffer + __cil_tmp86;
#line 641
  __cil_tmp88 = (unsigned long )d;
#line 641
  __cil_tmp89 = __cil_tmp88 + 40;
#line 641
  __cil_tmp90 = *((struct scsi_device **)__cil_tmp89);
#line 641
  __cil_tmp91 = (unsigned long )__cil_tmp90;
#line 641
  __cil_tmp92 = __cil_tmp91 + 248;
#line 641
  __cil_tmp93 = *((char    **)__cil_tmp92);
#line 641
  tmp___3 = sprintf(__cil_tmp87, "\t%-24.24s", __cil_tmp93);
#line 641
  len = tmp___3 + len;
#line 642
  __cil_tmp94 = (unsigned long )len;
#line 642
  __cil_tmp95 = buffer + __cil_tmp94;
#line 642
  __cil_tmp96 = (unsigned long )d;
#line 642
  __cil_tmp97 = __cil_tmp96 + 40;
#line 642
  __cil_tmp98 = *((struct scsi_device **)__cil_tmp97);
#line 642
  __cil_tmp99 = (unsigned long )__cil_tmp98;
#line 642
  __cil_tmp100 = __cil_tmp99 + 264;
#line 642
  __cil_tmp101 = *((char    **)__cil_tmp100);
#line 642
  tmp___4 = sprintf(__cil_tmp95, " Rev: %-8.8s\n", __cil_tmp101);
#line 642
  len = tmp___4 + len;
#line 643
  pos = begin + len;
  }
  {
#line 647
  __cil_tmp102 = (off_t )length;
#line 647
  __cil_tmp103 = __cil_tmp102 + offset;
#line 647
  __cil_tmp104 = (off_t )pos;
#line 647
  if (__cil_tmp104 > __cil_tmp103) {
#line 648
    goto stop_output;
  } else {

  }
  }
  {
#line 650
  __cil_tmp105 = (off_t )pos;
#line 650
  if (__cil_tmp105 <= offset) {
#line 651
    len = 0;
#line 652
    begin = pos;
  } else {

  }
  }
  {
#line 655
  __cil_tmp106 = 24 + 2;
#line 655
  __cil_tmp107 = (unsigned long )d;
#line 655
  __cil_tmp108 = __cil_tmp107 + 32;
#line 655
  __cil_tmp109 = *((struct i2o_device **)__cil_tmp108);
#line 655
  __cil_tmp110 = (unsigned long )__cil_tmp109;
#line 655
  __cil_tmp111 = __cil_tmp110 + __cil_tmp106;
#line 655
  __cil_tmp112 = *((unsigned short *)__cil_tmp111);
#line 655
  unit = (int )__cil_tmp112;
#line 656
  __cil_tmp113 = (unsigned long )d;
#line 656
  __cil_tmp114 = __cil_tmp113 + 40;
#line 656
  __cil_tmp115 = *((struct scsi_device **)__cil_tmp114);
#line 656
  tmp___7 = scsi_device_online(__cil_tmp115);
  }
#line 656
  if (tmp___7 != 0) {
#line 656
    tmp___6 = (char *)"online";
  } else {
#line 656
    tmp___6 = (char *)"offline";
  }
  {
#line 656
  __cil_tmp116 = (unsigned long )len;
#line 656
  __cil_tmp117 = buffer + __cil_tmp116;
#line 656
  __cil_tmp118 = (unsigned long )d;
#line 656
  __cil_tmp119 = __cil_tmp118 + 24;
#line 656
  __cil_tmp120 = *((u8 *)__cil_tmp119);
#line 656
  __cil_tmp121 = (int )__cil_tmp120;
#line 656
  __cil_tmp122 = (unsigned long )d;
#line 656
  __cil_tmp123 = __cil_tmp122 + 25;
#line 656
  __cil_tmp124 = *((u8 *)__cil_tmp123);
#line 656
  __cil_tmp125 = (int )__cil_tmp124;
#line 656
  __cil_tmp126 = (unsigned long )d;
#line 656
  __cil_tmp127 = __cil_tmp126 + 26;
#line 656
  __cil_tmp128 = *((u8 *)__cil_tmp127);
#line 656
  __cil_tmp129 = (int )__cil_tmp128;
#line 656
  tmp___8 = sprintf(__cil_tmp117, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
                    unit, __cil_tmp121, __cil_tmp125, __cil_tmp129, tmp___6);
#line 656
  len = tmp___8 + len;
#line 659
  pos = begin + len;
  }
  {
#line 662
  __cil_tmp130 = (off_t )length;
#line 662
  __cil_tmp131 = __cil_tmp130 + offset;
#line 662
  __cil_tmp132 = (off_t )pos;
#line 662
  if (__cil_tmp132 > __cil_tmp131) {
#line 663
    goto stop_output;
  } else {

  }
  }
  {
#line 665
  __cil_tmp133 = (off_t )pos;
#line 665
  if (__cil_tmp133 <= offset) {
#line 666
    len = 0;
#line 667
    begin = pos;
  } else {

  }
  }
#line 670
  d = *((struct adpt_device **)d);
  ldv_32213: ;
  {
#line 640
  __cil_tmp134 = (struct adpt_device *)0;
#line 640
  __cil_tmp135 = (unsigned long )__cil_tmp134;
#line 640
  __cil_tmp136 = (unsigned long )d;
#line 640
  if (__cil_tmp136 != __cil_tmp135) {
#line 641
    goto ldv_32212;
  } else {
#line 643
    goto ldv_32214;
  }
  }
  ldv_32214: 
#line 638
  id = id + 1;
  ldv_32216: ;
#line 638
  if (id <= 127) {
#line 639
    goto ldv_32215;
  } else {
#line 641
    goto ldv_32217;
  }
  ldv_32217: 
#line 637
  chan = chan + 1;
  ldv_32219: ;
#line 637
  if (chan <= 4) {
#line 638
    goto ldv_32218;
  } else {
#line 640
    goto ldv_32220;
  }
  ldv_32220: ;
  stop_output: 
#line 683
  __cil_tmp137 = (unsigned long )len;
#line 683
  __cil_tmp138 = buffer + __cil_tmp137;
#line 683
  *__cil_tmp138 = (char)0;
#line 685
  __cil_tmp139 = (off_t )begin;
#line 685
  __cil_tmp140 = offset - __cil_tmp139;
#line 685
  __cil_tmp141 = (unsigned long )__cil_tmp140;
#line 685
  *start = buffer + __cil_tmp141;
#line 686
  __cil_tmp142 = (unsigned int )len;
#line 686
  __cil_tmp143 = (unsigned int )offset;
#line 686
  __cil_tmp144 = (unsigned int )begin;
#line 686
  __cil_tmp145 = __cil_tmp144 - __cil_tmp143;
#line 686
  __cil_tmp146 = __cil_tmp145 + __cil_tmp142;
#line 686
  len = (int )__cil_tmp146;
#line 687
  if (len > length) {
#line 688
    len = length;
  } else
#line 689
  if (len < 0) {
#line 690
    len = 0;
#line 691
    __cil_tmp147 = *start;
#line 691
    *__cil_tmp147 = (char)0;
  } else {

  }
#line 693
  return (len);
}
}
#line 699 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static u32 adpt_cmd_to_context(struct scsi_cmnd *cmd ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 701
  __cil_tmp2 = (unsigned long )cmd;
#line 701
  __cil_tmp3 = __cil_tmp2 + 48;
#line 701
  __cil_tmp4 = *((unsigned long *)__cil_tmp3);
#line 701
  return ((u32 )__cil_tmp4);
  }
}
}
#line 709 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct scsi_cmnd *adpt_cmd_from_context(adpt_hba *pHba , u32 context ) 
{ struct scsi_cmnd *cmd ;
  struct scsi_device *d ;
  unsigned long flags ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct Scsi_Host *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct Scsi_Host *__cil_tmp16 ;
  struct scsi_device *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  struct scsi_cmnd *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  spinlock_t *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct Scsi_Host *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  spinlock_t *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  struct scsi_cmnd *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  spinlock_t *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct Scsi_Host *__cil_tmp52 ;
  struct scsi_device *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct Scsi_Host *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  spinlock_t *__cil_tmp61 ;

  {
#line 714
  if (context == 0U) {
#line 715
    return ((struct scsi_cmnd *)0);
  } else {

  }
  {
#line 717
  __cil_tmp8 = (unsigned long )pHba;
#line 717
  __cil_tmp9 = __cil_tmp8 + 16;
#line 717
  __cil_tmp10 = *((struct Scsi_Host **)__cil_tmp9);
#line 717
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 717
  __cil_tmp12 = __cil_tmp11 + 216;
#line 717
  __cil_tmp13 = *((spinlock_t **)__cil_tmp12);
#line 717
  spin_unlock(__cil_tmp13);
#line 718
  __cil_tmp14 = (unsigned long )pHba;
#line 718
  __cil_tmp15 = __cil_tmp14 + 16;
#line 718
  __cil_tmp16 = *((struct Scsi_Host **)__cil_tmp15);
#line 718
  __cil_tmp17 = (struct scsi_device *)0;
#line 718
  d = __scsi_iterate_devices(__cil_tmp16, __cil_tmp17);
  }
#line 718
  goto ldv_32239;
  ldv_32238: 
  {
#line 720
  ldv_spin_lock();
#line 721
  __cil_tmp18 = (unsigned long )d;
#line 721
  __cil_tmp19 = __cil_tmp18 + 128;
#line 721
  __cil_tmp20 = *((struct list_head **)__cil_tmp19);
#line 721
  __mptr = (struct list_head    *)__cil_tmp20;
#line 721
  __cil_tmp21 = (struct scsi_cmnd *)__mptr;
#line 721
  cmd = __cil_tmp21 + 0xfffffffffffffff8UL;
  }
#line 721
  goto ldv_32236;
  ldv_32235: ;
  {
#line 722
  __cil_tmp22 = (unsigned long )cmd;
#line 722
  __cil_tmp23 = __cil_tmp22 + 48;
#line 722
  __cil_tmp24 = *((unsigned long *)__cil_tmp23);
#line 722
  __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 722
  if (__cil_tmp25 == context) {
    {
#line 723
    __cil_tmp26 = (unsigned long )d;
#line 723
    __cil_tmp27 = __cil_tmp26 + 56;
#line 723
    __cil_tmp28 = (spinlock_t *)__cil_tmp27;
#line 723
    spin_unlock_irqrestore(__cil_tmp28, flags);
#line 724
    scsi_device_put(d);
#line 725
    __cil_tmp29 = (unsigned long )pHba;
#line 725
    __cil_tmp30 = __cil_tmp29 + 16;
#line 725
    __cil_tmp31 = *((struct Scsi_Host **)__cil_tmp30);
#line 725
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 725
    __cil_tmp33 = __cil_tmp32 + 216;
#line 725
    __cil_tmp34 = *((spinlock_t **)__cil_tmp33);
#line 725
    spin_lock(__cil_tmp34);
    }
#line 726
    return (cmd);
  } else {

  }
  }
#line 721
  __cil_tmp35 = (unsigned long )cmd;
#line 721
  __cil_tmp36 = __cil_tmp35 + 8;
#line 721
  __cil_tmp37 = *((struct list_head **)__cil_tmp36);
#line 721
  __mptr___0 = (struct list_head    *)__cil_tmp37;
#line 721
  __cil_tmp38 = (struct scsi_cmnd *)__mptr___0;
#line 721
  cmd = __cil_tmp38 + 0xfffffffffffffff8UL;
  ldv_32236: ;
  {
#line 721
  __cil_tmp39 = (unsigned long )d;
#line 721
  __cil_tmp40 = __cil_tmp39 + 128;
#line 721
  __cil_tmp41 = (struct list_head *)__cil_tmp40;
#line 721
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 721
  __cil_tmp43 = (unsigned long )cmd;
#line 721
  __cil_tmp44 = __cil_tmp43 + 8;
#line 721
  __cil_tmp45 = (struct list_head *)__cil_tmp44;
#line 721
  __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 721
  if (__cil_tmp46 != __cil_tmp42) {
#line 722
    goto ldv_32235;
  } else {
#line 724
    goto ldv_32237;
  }
  }
  ldv_32237: 
  {
#line 729
  __cil_tmp47 = (unsigned long )d;
#line 729
  __cil_tmp48 = __cil_tmp47 + 56;
#line 729
  __cil_tmp49 = (spinlock_t *)__cil_tmp48;
#line 729
  spin_unlock_irqrestore(__cil_tmp49, flags);
#line 718
  __cil_tmp50 = (unsigned long )pHba;
#line 718
  __cil_tmp51 = __cil_tmp50 + 16;
#line 718
  __cil_tmp52 = *((struct Scsi_Host **)__cil_tmp51);
#line 718
  d = __scsi_iterate_devices(__cil_tmp52, d);
  }
  ldv_32239: ;
  {
#line 718
  __cil_tmp53 = (struct scsi_device *)0;
#line 718
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 718
  __cil_tmp55 = (unsigned long )d;
#line 718
  if (__cil_tmp55 != __cil_tmp54) {
#line 719
    goto ldv_32238;
  } else {
#line 721
    goto ldv_32240;
  }
  }
  ldv_32240: 
  {
#line 731
  __cil_tmp56 = (unsigned long )pHba;
#line 731
  __cil_tmp57 = __cil_tmp56 + 16;
#line 731
  __cil_tmp58 = *((struct Scsi_Host **)__cil_tmp57);
#line 731
  __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 731
  __cil_tmp60 = __cil_tmp59 + 216;
#line 731
  __cil_tmp61 = *((spinlock_t **)__cil_tmp60);
#line 731
  spin_lock(__cil_tmp61);
  }
#line 733
  return ((struct scsi_cmnd *)0);
}
}
#line 739 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static u32 adpt_ioctl_to_context(adpt_hba *pHba , void *reply ) 
{ ulong flags ;
  u32 nr ;
  u32 i ;
  u32 *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  u32 *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  struct Scsi_Host *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  spinlock_t *__cil_tmp23 ;
  void    *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  char (*__cil_tmp27)[32U] ;
  char *__cil_tmp28 ;

  {
  {
#line 744
  flags = 0UL;
#line 747
  ldv_spin_lock();
#line 748
  nr = 4U;
#line 749
  i = 0U;
  }
#line 749
  goto ldv_32252;
  ldv_32251: ;
  {
#line 750
  __cil_tmp6 = (u32 *)0;
#line 750
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 750
  __cil_tmp8 = i * 8UL;
#line 750
  __cil_tmp9 = 5624 + __cil_tmp8;
#line 750
  __cil_tmp10 = (unsigned long )pHba;
#line 750
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
#line 750
  __cil_tmp12 = *((u32 **)__cil_tmp11);
#line 750
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 750
  if (__cil_tmp13 == __cil_tmp7) {
#line 751
    __cil_tmp14 = i * 8UL;
#line 751
    __cil_tmp15 = 5624 + __cil_tmp14;
#line 751
    __cil_tmp16 = (unsigned long )pHba;
#line 751
    __cil_tmp17 = __cil_tmp16 + __cil_tmp15;
#line 751
    *((u32 **)__cil_tmp17) = (u32 *)reply;
#line 752
    goto ldv_32250;
  } else {

  }
  }
#line 749
  i = i + 1U;
  ldv_32252: ;
#line 749
  if (i < nr) {
#line 750
    goto ldv_32251;
  } else {
#line 752
    goto ldv_32250;
  }
  ldv_32250: 
  {
#line 755
  __cil_tmp18 = (unsigned long )pHba;
#line 755
  __cil_tmp19 = __cil_tmp18 + 16;
#line 755
  __cil_tmp20 = *((struct Scsi_Host **)__cil_tmp19);
#line 755
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 755
  __cil_tmp22 = __cil_tmp21 + 216;
#line 755
  __cil_tmp23 = *((spinlock_t **)__cil_tmp22);
#line 755
  spin_unlock_irqrestore(__cil_tmp23, flags);
  }
#line 756
  if (i >= nr) {
    {
#line 757
    __cil_tmp24 = (void    *)reply;
#line 757
    kfree(__cil_tmp24);
#line 758
    __cil_tmp25 = (unsigned long )pHba;
#line 758
    __cil_tmp26 = __cil_tmp25 + 114;
#line 758
    __cil_tmp27 = (char (*)[32U])__cil_tmp26;
#line 758
    __cil_tmp28 = (char *)__cil_tmp27;
#line 758
    printk("<4>%s: Too many outstanding ioctl commands\n", __cil_tmp28);
    }
#line 760
    return (4294967295U);
  } else {

  }
#line 763
  return (i);
}
}
#line 770 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void *adpt_ioctl_from_context(adpt_hba *pHba , u32 context ) 
{ void *p ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  u32 *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;

  {
#line 775
  __cil_tmp4 = context * 8UL;
#line 775
  __cil_tmp5 = 5624 + __cil_tmp4;
#line 775
  __cil_tmp6 = (unsigned long )pHba;
#line 775
  __cil_tmp7 = __cil_tmp6 + __cil_tmp5;
#line 775
  __cil_tmp8 = *((u32 **)__cil_tmp7);
#line 775
  p = (void *)__cil_tmp8;
#line 776
  __cil_tmp9 = context * 8UL;
#line 776
  __cil_tmp10 = 5624 + __cil_tmp9;
#line 776
  __cil_tmp11 = (unsigned long )pHba;
#line 776
  __cil_tmp12 = __cil_tmp11 + __cil_tmp10;
#line 776
  *((u32 **)__cil_tmp12) = (u32 *)0;
#line 778
  return (p);
}
}
#line 787 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_abort(struct scsi_cmnd *cmd ) 
{ adpt_hba *pHba ;
  struct adpt_device *dptdevice ;
  u32 msg[5U] ;
  int rcode ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct scsi_device *__cil_tmp11 ;
  struct Scsi_Host *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  char (*__cil_tmp18)[32U] ;
  char *__cil_tmp19 ;
  struct scsi_device *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  struct adpt_device *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  char (*__cil_tmp29)[32U] ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  u16 __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct Scsi_Host *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct Scsi_Host *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  struct Scsi_Host *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  spinlock_t *__cil_tmp58 ;
  u32 *__cil_tmp59 ;
  struct Scsi_Host *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  struct Scsi_Host *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct Scsi_Host *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  spinlock_t *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  char (*__cil_tmp74)[32U] ;
  char *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  char (*__cil_tmp78)[32U] ;
  char *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  char (*__cil_tmp82)[32U] ;
  char *__cil_tmp83 ;

  {
#line 789
  pHba = (adpt_hba *)0;
  {
#line 794
  __cil_tmp6 = (unsigned long )cmd;
#line 794
  __cil_tmp7 = __cil_tmp6 + 48;
#line 794
  __cil_tmp8 = *((unsigned long *)__cil_tmp7);
#line 794
  if (__cil_tmp8 == 0UL) {
#line 795
    return (8195);
  } else {

  }
  }
  {
#line 797
  __cil_tmp9 = 0 * 8UL;
#line 797
  __cil_tmp10 = 3048 + __cil_tmp9;
#line 797
  __cil_tmp11 = *((struct scsi_device **)cmd);
#line 797
  __cil_tmp12 = *((struct Scsi_Host **)__cil_tmp11);
#line 797
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 797
  __cil_tmp14 = __cil_tmp13 + __cil_tmp10;
#line 797
  __cil_tmp15 = *((unsigned long *)__cil_tmp14);
#line 797
  pHba = (adpt_hba *)__cil_tmp15;
#line 798
  __cil_tmp16 = (unsigned long )pHba;
#line 798
  __cil_tmp17 = __cil_tmp16 + 114;
#line 798
  __cil_tmp18 = (char (*)[32U])__cil_tmp17;
#line 798
  __cil_tmp19 = (char *)__cil_tmp18;
#line 798
  printk("<6>%s: Trying to Abort\n", __cil_tmp19);
#line 799
  __cil_tmp20 = *((struct scsi_device **)cmd);
#line 799
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 799
  __cil_tmp22 = __cil_tmp21 + 224;
#line 799
  __cil_tmp23 = *((void **)__cil_tmp22);
#line 799
  dptdevice = (struct adpt_device *)__cil_tmp23;
  }
  {
#line 799
  __cil_tmp24 = (struct adpt_device *)0;
#line 799
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 799
  __cil_tmp26 = (unsigned long )dptdevice;
#line 799
  if (__cil_tmp26 == __cil_tmp25) {
    {
#line 800
    __cil_tmp27 = (unsigned long )pHba;
#line 800
    __cil_tmp28 = __cil_tmp27 + 114;
#line 800
    __cil_tmp29 = (char (*)[32U])__cil_tmp28;
#line 800
    __cil_tmp30 = (char *)__cil_tmp29;
#line 800
    printk("<3>%s: Unable to abort: No device in cmnd\n", __cil_tmp30);
    }
#line 801
    return (8195);
  } else {

  }
  }
  {
#line 804
  __cil_tmp31 = (void *)(& msg);
#line 804
  memset(__cil_tmp31, 0, 20UL);
#line 805
  __cil_tmp32 = 0 * 4UL;
#line 805
  __cil_tmp33 = (unsigned long )(msg) + __cil_tmp32;
#line 805
  *((u32 *)__cil_tmp33) = 327681U;
#line 806
  __cil_tmp34 = 1 * 4UL;
#line 806
  __cil_tmp35 = (unsigned long )(msg) + __cil_tmp34;
#line 806
  __cil_tmp36 = (unsigned long )dptdevice;
#line 806
  __cil_tmp37 = __cil_tmp36 + 28;
#line 806
  __cil_tmp38 = *((u16 *)__cil_tmp37);
#line 806
  __cil_tmp39 = (int )__cil_tmp38;
#line 806
  __cil_tmp40 = __cil_tmp39 | -2097147904;
#line 806
  *((u32 *)__cil_tmp35) = (u32 )__cil_tmp40;
#line 807
  __cil_tmp41 = 2 * 4UL;
#line 807
  __cil_tmp42 = (unsigned long )(msg) + __cil_tmp41;
#line 807
  *((u32 *)__cil_tmp42) = 0U;
#line 808
  __cil_tmp43 = 3 * 4UL;
#line 808
  __cil_tmp44 = (unsigned long )(msg) + __cil_tmp43;
#line 808
  *((u32 *)__cil_tmp44) = 0U;
#line 809
  __cil_tmp45 = 4 * 4UL;
#line 809
  __cil_tmp46 = (unsigned long )(msg) + __cil_tmp45;
#line 809
  *((u32 *)__cil_tmp46) = adpt_cmd_to_context(cmd);
  }
  {
#line 810
  __cil_tmp47 = (struct Scsi_Host *)0;
#line 810
  __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 810
  __cil_tmp49 = (unsigned long )pHba;
#line 810
  __cil_tmp50 = __cil_tmp49 + 16;
#line 810
  __cil_tmp51 = *((struct Scsi_Host **)__cil_tmp50);
#line 810
  __cil_tmp52 = (unsigned long )__cil_tmp51;
#line 810
  if (__cil_tmp52 != __cil_tmp48) {
    {
#line 811
    __cil_tmp53 = (unsigned long )pHba;
#line 811
    __cil_tmp54 = __cil_tmp53 + 16;
#line 811
    __cil_tmp55 = *((struct Scsi_Host **)__cil_tmp54);
#line 811
    __cil_tmp56 = (unsigned long )__cil_tmp55;
#line 811
    __cil_tmp57 = __cil_tmp56 + 216;
#line 811
    __cil_tmp58 = *((spinlock_t **)__cil_tmp57);
#line 811
    spin_lock_irq(__cil_tmp58);
    }
  } else {

  }
  }
  {
#line 812
  __cil_tmp59 = (u32 *)(& msg);
#line 812
  rcode = adpt_i2o_post_wait(pHba, __cil_tmp59, 20, 0);
  }
  {
#line 813
  __cil_tmp60 = (struct Scsi_Host *)0;
#line 813
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 813
  __cil_tmp62 = (unsigned long )pHba;
#line 813
  __cil_tmp63 = __cil_tmp62 + 16;
#line 813
  __cil_tmp64 = *((struct Scsi_Host **)__cil_tmp63);
#line 813
  __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 813
  if (__cil_tmp65 != __cil_tmp61) {
    {
#line 814
    __cil_tmp66 = (unsigned long )pHba;
#line 814
    __cil_tmp67 = __cil_tmp66 + 16;
#line 814
    __cil_tmp68 = *((struct Scsi_Host **)__cil_tmp67);
#line 814
    __cil_tmp69 = (unsigned long )__cil_tmp68;
#line 814
    __cil_tmp70 = __cil_tmp69 + 216;
#line 814
    __cil_tmp71 = *((spinlock_t **)__cil_tmp70);
#line 814
    spin_unlock_irq(__cil_tmp71);
    }
  } else {

  }
  }
#line 815
  if (rcode != 0) {
#line 816
    if (rcode == -95) {
      {
#line 817
      __cil_tmp72 = (unsigned long )pHba;
#line 817
      __cil_tmp73 = __cil_tmp72 + 114;
#line 817
      __cil_tmp74 = (char (*)[32U])__cil_tmp73;
#line 817
      __cil_tmp75 = (char *)__cil_tmp74;
#line 817
      printk("<6>%s: Abort cmd not supported\n", __cil_tmp75);
      }
#line 818
      return (8195);
    } else {

    }
    {
#line 820
    __cil_tmp76 = (unsigned long )pHba;
#line 820
    __cil_tmp77 = __cil_tmp76 + 114;
#line 820
    __cil_tmp78 = (char (*)[32U])__cil_tmp77;
#line 820
    __cil_tmp79 = (char *)__cil_tmp78;
#line 820
    printk("<6>%s: Abort failed.\n", __cil_tmp79);
    }
#line 821
    return (8195);
  } else {

  }
  {
#line 823
  __cil_tmp80 = (unsigned long )pHba;
#line 823
  __cil_tmp81 = __cil_tmp80 + 114;
#line 823
  __cil_tmp82 = (char (*)[32U])__cil_tmp81;
#line 823
  __cil_tmp83 = (char *)__cil_tmp82;
#line 823
  printk("<6>%s: Abort complete.\n", __cil_tmp83);
  }
#line 824
  return (8194);
}
}
#line 832 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_device_reset(struct scsi_cmnd *cmd ) 
{ adpt_hba *pHba ;
  u32 msg[4U] ;
  u32 rcode ;
  int old_state ;
  struct adpt_device *d ;
  int tmp ;
  struct scsi_device *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct scsi_device *__cil_tmp14 ;
  struct Scsi_Host *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  char (*__cil_tmp21)[32U] ;
  char *__cil_tmp22 ;
  struct adpt_device *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  char (*__cil_tmp28)[32U] ;
  char *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  u16 __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  struct Scsi_Host *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  struct Scsi_Host *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct Scsi_Host *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  spinlock_t *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  u8 __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  u8 __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  u32 *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct Scsi_Host *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  struct Scsi_Host *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  struct Scsi_Host *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  spinlock_t *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  char (*__cil_tmp83)[32U] ;
  char *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  char (*__cil_tmp87)[32U] ;
  char *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  char (*__cil_tmp91)[32U] ;
  char *__cil_tmp92 ;

  {
  {
#line 838
  __cil_tmp8 = *((struct scsi_device **)cmd);
#line 838
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 838
  __cil_tmp10 = __cil_tmp9 + 224;
#line 838
  __cil_tmp11 = *((void **)__cil_tmp10);
#line 838
  d = (struct adpt_device *)__cil_tmp11;
#line 840
  __cil_tmp12 = 0 * 8UL;
#line 840
  __cil_tmp13 = 3048 + __cil_tmp12;
#line 840
  __cil_tmp14 = *((struct scsi_device **)cmd);
#line 840
  __cil_tmp15 = *((struct Scsi_Host **)__cil_tmp14);
#line 840
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 840
  __cil_tmp17 = __cil_tmp16 + __cil_tmp13;
#line 840
  __cil_tmp18 = *((unsigned long *)__cil_tmp17);
#line 840
  pHba = (adpt_hba *)__cil_tmp18;
#line 841
  __cil_tmp19 = (unsigned long )pHba;
#line 841
  __cil_tmp20 = __cil_tmp19 + 114;
#line 841
  __cil_tmp21 = (char (*)[32U])__cil_tmp20;
#line 841
  __cil_tmp22 = (char *)__cil_tmp21;
#line 841
  printk("<6>%s: Trying to reset device\n", __cil_tmp22);
  }
  {
#line 842
  __cil_tmp23 = (struct adpt_device *)0;
#line 842
  __cil_tmp24 = (unsigned long )__cil_tmp23;
#line 842
  __cil_tmp25 = (unsigned long )d;
#line 842
  if (__cil_tmp25 == __cil_tmp24) {
    {
#line 843
    __cil_tmp26 = (unsigned long )pHba;
#line 843
    __cil_tmp27 = __cil_tmp26 + 114;
#line 843
    __cil_tmp28 = (char (*)[32U])__cil_tmp27;
#line 843
    __cil_tmp29 = (char *)__cil_tmp28;
#line 843
    printk("<6>%s: Reset Device: Device Not found\n", __cil_tmp29);
    }
#line 844
    return (8195);
  } else {

  }
  }
  {
#line 846
  __cil_tmp30 = (void *)(& msg);
#line 846
  memset(__cil_tmp30, 0, 16UL);
#line 847
  __cil_tmp31 = 0 * 4UL;
#line 847
  __cil_tmp32 = (unsigned long )(msg) + __cil_tmp31;
#line 847
  *((u32 *)__cil_tmp32) = 262145U;
#line 848
  __cil_tmp33 = 1 * 4UL;
#line 848
  __cil_tmp34 = (unsigned long )(msg) + __cil_tmp33;
#line 848
  __cil_tmp35 = (unsigned long )d;
#line 848
  __cil_tmp36 = __cil_tmp35 + 28;
#line 848
  __cil_tmp37 = *((u16 *)__cil_tmp36);
#line 848
  __cil_tmp38 = (int )__cil_tmp37;
#line 848
  __cil_tmp39 = __cil_tmp38 | 654315520;
#line 848
  *((u32 *)__cil_tmp34) = (u32 )__cil_tmp39;
#line 849
  __cil_tmp40 = 2 * 4UL;
#line 849
  __cil_tmp41 = (unsigned long )(msg) + __cil_tmp40;
#line 849
  *((u32 *)__cil_tmp41) = 0U;
#line 850
  __cil_tmp42 = 3 * 4UL;
#line 850
  __cil_tmp43 = (unsigned long )(msg) + __cil_tmp42;
#line 850
  *((u32 *)__cil_tmp43) = 0U;
  }
  {
#line 852
  __cil_tmp44 = (struct Scsi_Host *)0;
#line 852
  __cil_tmp45 = (unsigned long )__cil_tmp44;
#line 852
  __cil_tmp46 = (unsigned long )pHba;
#line 852
  __cil_tmp47 = __cil_tmp46 + 16;
#line 852
  __cil_tmp48 = *((struct Scsi_Host **)__cil_tmp47);
#line 852
  __cil_tmp49 = (unsigned long )__cil_tmp48;
#line 852
  if (__cil_tmp49 != __cil_tmp45) {
    {
#line 853
    __cil_tmp50 = (unsigned long )pHba;
#line 853
    __cil_tmp51 = __cil_tmp50 + 16;
#line 853
    __cil_tmp52 = *((struct Scsi_Host **)__cil_tmp51);
#line 853
    __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 853
    __cil_tmp54 = __cil_tmp53 + 216;
#line 853
    __cil_tmp55 = *((spinlock_t **)__cil_tmp54);
#line 853
    spin_lock_irq(__cil_tmp55);
    }
  } else {

  }
  }
  {
#line 854
  __cil_tmp56 = (unsigned long )d;
#line 854
  __cil_tmp57 = __cil_tmp56 + 27;
#line 854
  __cil_tmp58 = *((u8 *)__cil_tmp57);
#line 854
  old_state = (int )__cil_tmp58;
#line 855
  __cil_tmp59 = (unsigned long )d;
#line 855
  __cil_tmp60 = __cil_tmp59 + 27;
#line 855
  __cil_tmp61 = (unsigned long )d;
#line 855
  __cil_tmp62 = __cil_tmp61 + 27;
#line 855
  __cil_tmp63 = *((u8 *)__cil_tmp62);
#line 855
  __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 855
  __cil_tmp65 = __cil_tmp64 | 2U;
#line 855
  *((u8 *)__cil_tmp60) = (u8 )__cil_tmp65;
#line 856
  __cil_tmp66 = (u32 *)(& msg);
#line 856
  tmp = adpt_i2o_post_wait(pHba, __cil_tmp66, 16, 0);
#line 856
  rcode = (u32 )tmp;
#line 857
  __cil_tmp67 = (unsigned long )d;
#line 857
  __cil_tmp68 = __cil_tmp67 + 27;
#line 857
  *((u8 *)__cil_tmp68) = (u8 )old_state;
  }
  {
#line 858
  __cil_tmp69 = (struct Scsi_Host *)0;
#line 858
  __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 858
  __cil_tmp71 = (unsigned long )pHba;
#line 858
  __cil_tmp72 = __cil_tmp71 + 16;
#line 858
  __cil_tmp73 = *((struct Scsi_Host **)__cil_tmp72);
#line 858
  __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 858
  if (__cil_tmp74 != __cil_tmp70) {
    {
#line 859
    __cil_tmp75 = (unsigned long )pHba;
#line 859
    __cil_tmp76 = __cil_tmp75 + 16;
#line 859
    __cil_tmp77 = *((struct Scsi_Host **)__cil_tmp76);
#line 859
    __cil_tmp78 = (unsigned long )__cil_tmp77;
#line 859
    __cil_tmp79 = __cil_tmp78 + 216;
#line 859
    __cil_tmp80 = *((spinlock_t **)__cil_tmp79);
#line 859
    spin_unlock_irq(__cil_tmp80);
    }
  } else {

  }
  }
#line 860
  if (rcode != 0U) {
#line 861
    if (rcode == 4294967201U) {
      {
#line 862
      __cil_tmp81 = (unsigned long )pHba;
#line 862
      __cil_tmp82 = __cil_tmp81 + 114;
#line 862
      __cil_tmp83 = (char (*)[32U])__cil_tmp82;
#line 862
      __cil_tmp84 = (char *)__cil_tmp83;
#line 862
      printk("<6>%s: Device reset not supported\n", __cil_tmp84);
      }
#line 863
      return (8195);
    } else {

    }
    {
#line 865
    __cil_tmp85 = (unsigned long )pHba;
#line 865
    __cil_tmp86 = __cil_tmp85 + 114;
#line 865
    __cil_tmp87 = (char (*)[32U])__cil_tmp86;
#line 865
    __cil_tmp88 = (char *)__cil_tmp87;
#line 865
    printk("<6>%s: Device reset failed\n", __cil_tmp88);
    }
#line 866
    return (8195);
  } else {
    {
#line 868
    __cil_tmp89 = (unsigned long )pHba;
#line 868
    __cil_tmp90 = __cil_tmp89 + 114;
#line 868
    __cil_tmp91 = (char (*)[32U])__cil_tmp90;
#line 868
    __cil_tmp92 = (char *)__cil_tmp91;
#line 868
    printk("<6>%s: Device reset successful\n", __cil_tmp92);
    }
#line 869
    return (8194);
  }
}
}
#line 876 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_bus_reset(struct scsi_cmnd *cmd ) 
{ adpt_hba *pHba ;
  u32 msg[4U] ;
  u32 rcode ;
  int tmp ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct scsi_device *__cil_tmp8 ;
  struct Scsi_Host *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  char (*__cil_tmp16)[32U] ;
  char *__cil_tmp17 ;
  struct scsi_device *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  struct scsi_device *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  u16 __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct scsi_device *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  u16 __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct Scsi_Host *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  struct Scsi_Host *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  struct Scsi_Host *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  spinlock_t *__cil_tmp64 ;
  u32 *__cil_tmp65 ;
  struct Scsi_Host *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  struct Scsi_Host *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  struct Scsi_Host *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  spinlock_t *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  char (*__cil_tmp80)[32U] ;
  char *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  char (*__cil_tmp84)[32U] ;
  char *__cil_tmp85 ;

  {
  {
#line 882
  __cil_tmp6 = 0 * 8UL;
#line 882
  __cil_tmp7 = 3048 + __cil_tmp6;
#line 882
  __cil_tmp8 = *((struct scsi_device **)cmd);
#line 882
  __cil_tmp9 = *((struct Scsi_Host **)__cil_tmp8);
#line 882
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 882
  __cil_tmp11 = __cil_tmp10 + __cil_tmp7;
#line 882
  __cil_tmp12 = *((unsigned long *)__cil_tmp11);
#line 882
  pHba = (adpt_hba *)__cil_tmp12;
#line 883
  __cil_tmp13 = (void *)(& msg);
#line 883
  memset(__cil_tmp13, 0, 16UL);
#line 884
  __cil_tmp14 = (unsigned long )pHba;
#line 884
  __cil_tmp15 = __cil_tmp14 + 114;
#line 884
  __cil_tmp16 = (char (*)[32U])__cil_tmp15;
#line 884
  __cil_tmp17 = (char *)__cil_tmp16;
#line 884
  __cil_tmp18 = *((struct scsi_device **)cmd);
#line 884
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 884
  __cil_tmp20 = __cil_tmp19 + 208;
#line 884
  __cil_tmp21 = *((unsigned int *)__cil_tmp20);
#line 884
  __cil_tmp22 = *((struct scsi_device **)cmd);
#line 884
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 884
  __cil_tmp24 = __cil_tmp23 + 208;
#line 884
  __cil_tmp25 = *((unsigned int *)__cil_tmp24);
#line 884
  __cil_tmp26 = __cil_tmp25 * 1040UL;
#line 884
  __cil_tmp27 = __cil_tmp26 + 1026;
#line 884
  __cil_tmp28 = 360 + __cil_tmp27;
#line 884
  __cil_tmp29 = (unsigned long )pHba;
#line 884
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 884
  __cil_tmp31 = *((u16 *)__cil_tmp30);
#line 884
  __cil_tmp32 = (int )__cil_tmp31;
#line 884
  printk("<4>%s: Bus reset: SCSI Bus %d: tid: %d\n", __cil_tmp17, __cil_tmp21, __cil_tmp32);
#line 885
  __cil_tmp33 = 0 * 4UL;
#line 885
  __cil_tmp34 = (unsigned long )(msg) + __cil_tmp33;
#line 885
  *((u32 *)__cil_tmp34) = 262145U;
#line 886
  __cil_tmp35 = 1 * 4UL;
#line 886
  __cil_tmp36 = (unsigned long )(msg) + __cil_tmp35;
#line 886
  __cil_tmp37 = *((struct scsi_device **)cmd);
#line 886
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 886
  __cil_tmp39 = __cil_tmp38 + 208;
#line 886
  __cil_tmp40 = *((unsigned int *)__cil_tmp39);
#line 886
  __cil_tmp41 = __cil_tmp40 * 1040UL;
#line 886
  __cil_tmp42 = __cil_tmp41 + 1026;
#line 886
  __cil_tmp43 = 360 + __cil_tmp42;
#line 886
  __cil_tmp44 = (unsigned long )pHba;
#line 886
  __cil_tmp45 = __cil_tmp44 + __cil_tmp43;
#line 886
  __cil_tmp46 = *((u16 *)__cil_tmp45);
#line 886
  __cil_tmp47 = (int )__cil_tmp46;
#line 886
  __cil_tmp48 = __cil_tmp47 | -2030039040;
#line 886
  *((u32 *)__cil_tmp36) = (u32 )__cil_tmp48;
#line 887
  __cil_tmp49 = 2 * 4UL;
#line 887
  __cil_tmp50 = (unsigned long )(msg) + __cil_tmp49;
#line 887
  *((u32 *)__cil_tmp50) = 0U;
#line 888
  __cil_tmp51 = 3 * 4UL;
#line 888
  __cil_tmp52 = (unsigned long )(msg) + __cil_tmp51;
#line 888
  *((u32 *)__cil_tmp52) = 0U;
  }
  {
#line 889
  __cil_tmp53 = (struct Scsi_Host *)0;
#line 889
  __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 889
  __cil_tmp55 = (unsigned long )pHba;
#line 889
  __cil_tmp56 = __cil_tmp55 + 16;
#line 889
  __cil_tmp57 = *((struct Scsi_Host **)__cil_tmp56);
#line 889
  __cil_tmp58 = (unsigned long )__cil_tmp57;
#line 889
  if (__cil_tmp58 != __cil_tmp54) {
    {
#line 890
    __cil_tmp59 = (unsigned long )pHba;
#line 890
    __cil_tmp60 = __cil_tmp59 + 16;
#line 890
    __cil_tmp61 = *((struct Scsi_Host **)__cil_tmp60);
#line 890
    __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 890
    __cil_tmp63 = __cil_tmp62 + 216;
#line 890
    __cil_tmp64 = *((spinlock_t **)__cil_tmp63);
#line 890
    spin_lock_irq(__cil_tmp64);
    }
  } else {

  }
  }
  {
#line 891
  __cil_tmp65 = (u32 *)(& msg);
#line 891
  tmp = adpt_i2o_post_wait(pHba, __cil_tmp65, 16, 0);
#line 891
  rcode = (u32 )tmp;
  }
  {
#line 892
  __cil_tmp66 = (struct Scsi_Host *)0;
#line 892
  __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 892
  __cil_tmp68 = (unsigned long )pHba;
#line 892
  __cil_tmp69 = __cil_tmp68 + 16;
#line 892
  __cil_tmp70 = *((struct Scsi_Host **)__cil_tmp69);
#line 892
  __cil_tmp71 = (unsigned long )__cil_tmp70;
#line 892
  if (__cil_tmp71 != __cil_tmp67) {
    {
#line 893
    __cil_tmp72 = (unsigned long )pHba;
#line 893
    __cil_tmp73 = __cil_tmp72 + 16;
#line 893
    __cil_tmp74 = *((struct Scsi_Host **)__cil_tmp73);
#line 893
    __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 893
    __cil_tmp76 = __cil_tmp75 + 216;
#line 893
    __cil_tmp77 = *((spinlock_t **)__cil_tmp76);
#line 893
    spin_unlock_irq(__cil_tmp77);
    }
  } else {

  }
  }
#line 894
  if (rcode != 0U) {
    {
#line 895
    __cil_tmp78 = (unsigned long )pHba;
#line 895
    __cil_tmp79 = __cil_tmp78 + 114;
#line 895
    __cil_tmp80 = (char (*)[32U])__cil_tmp79;
#line 895
    __cil_tmp81 = (char *)__cil_tmp80;
#line 895
    printk("<4>%s: Bus reset failed.\n", __cil_tmp81);
    }
#line 896
    return (8195);
  } else {
    {
#line 898
    __cil_tmp82 = (unsigned long )pHba;
#line 898
    __cil_tmp83 = __cil_tmp82 + 114;
#line 898
    __cil_tmp84 = (char (*)[32U])__cil_tmp83;
#line 898
    __cil_tmp85 = (char *)__cil_tmp84;
#line 898
    printk("<4>%s: Bus reset success.\n", __cil_tmp85);
    }
#line 899
    return (8194);
  }
}
}
#line 904 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int __adpt_reset(struct scsi_cmnd *cmd ) 
{ adpt_hba *pHba ;
  int rcode ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  struct scsi_device *__cil_tmp6 ;
  struct Scsi_Host *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char (*__cil_tmp13)[32U] ;
  char *__cil_tmp14 ;
  struct scsi_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  struct scsi_device *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  u16 __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  char (*__cil_tmp32)[32U] ;
  char *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  char (*__cil_tmp36)[32U] ;
  char *__cil_tmp37 ;

  {
  {
#line 908
  __cil_tmp4 = 0 * 8UL;
#line 908
  __cil_tmp5 = 3048 + __cil_tmp4;
#line 908
  __cil_tmp6 = *((struct scsi_device **)cmd);
#line 908
  __cil_tmp7 = *((struct Scsi_Host **)__cil_tmp6);
#line 908
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 908
  __cil_tmp9 = __cil_tmp8 + __cil_tmp5;
#line 908
  __cil_tmp10 = *((unsigned long *)__cil_tmp9);
#line 908
  pHba = (adpt_hba *)__cil_tmp10;
#line 909
  __cil_tmp11 = (unsigned long )pHba;
#line 909
  __cil_tmp12 = __cil_tmp11 + 114;
#line 909
  __cil_tmp13 = (char (*)[32U])__cil_tmp12;
#line 909
  __cil_tmp14 = (char *)__cil_tmp13;
#line 909
  __cil_tmp15 = *((struct scsi_device **)cmd);
#line 909
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 909
  __cil_tmp17 = __cil_tmp16 + 208;
#line 909
  __cil_tmp18 = *((unsigned int *)__cil_tmp17);
#line 909
  __cil_tmp19 = *((struct scsi_device **)cmd);
#line 909
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 909
  __cil_tmp21 = __cil_tmp20 + 208;
#line 909
  __cil_tmp22 = *((unsigned int *)__cil_tmp21);
#line 909
  __cil_tmp23 = __cil_tmp22 * 1040UL;
#line 909
  __cil_tmp24 = __cil_tmp23 + 1026;
#line 909
  __cil_tmp25 = 360 + __cil_tmp24;
#line 909
  __cil_tmp26 = (unsigned long )pHba;
#line 909
  __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
#line 909
  __cil_tmp28 = *((u16 *)__cil_tmp27);
#line 909
  __cil_tmp29 = (int )__cil_tmp28;
#line 909
  printk("<4>%s: Hba Reset: scsi id %d: tid: %d\n", __cil_tmp14, __cil_tmp18, __cil_tmp29);
#line 910
  rcode = adpt_hba_reset(pHba);
  }
#line 911
  if (rcode == 0) {
    {
#line 912
    __cil_tmp30 = (unsigned long )pHba;
#line 912
    __cil_tmp31 = __cil_tmp30 + 114;
#line 912
    __cil_tmp32 = (char (*)[32U])__cil_tmp31;
#line 912
    __cil_tmp33 = (char *)__cil_tmp32;
#line 912
    printk("<4>%s: HBA reset complete\n", __cil_tmp33);
    }
#line 913
    return (8194);
  } else {
    {
#line 915
    __cil_tmp34 = (unsigned long )pHba;
#line 915
    __cil_tmp35 = __cil_tmp34 + 114;
#line 915
    __cil_tmp36 = (char (*)[32U])__cil_tmp35;
#line 915
    __cil_tmp37 = (char *)__cil_tmp36;
#line 915
    printk("<4>%s: HBA reset failed (%x)\n", __cil_tmp37, rcode);
    }
#line 916
    return (8195);
  }
}
}
#line 920 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_reset(struct scsi_cmnd *cmd ) 
{ int rc ;
  struct scsi_device *__cil_tmp3 ;
  struct Scsi_Host *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  spinlock_t *__cil_tmp7 ;
  struct scsi_device *__cil_tmp8 ;
  struct Scsi_Host *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  spinlock_t *__cil_tmp12 ;

  {
  {
#line 924
  __cil_tmp3 = *((struct scsi_device **)cmd);
#line 924
  __cil_tmp4 = *((struct Scsi_Host **)__cil_tmp3);
#line 924
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 924
  __cil_tmp6 = __cil_tmp5 + 216;
#line 924
  __cil_tmp7 = *((spinlock_t **)__cil_tmp6);
#line 924
  spin_lock_irq(__cil_tmp7);
#line 925
  rc = __adpt_reset(cmd);
#line 926
  __cil_tmp8 = *((struct scsi_device **)cmd);
#line 926
  __cil_tmp9 = *((struct Scsi_Host **)__cil_tmp8);
#line 926
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 926
  __cil_tmp11 = __cil_tmp10 + 216;
#line 926
  __cil_tmp12 = *((spinlock_t **)__cil_tmp11);
#line 926
  spin_unlock_irq(__cil_tmp12);
  }
#line 928
  return (rc);
}
}
#line 932 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_hba_reset(adpt_hba *pHba ) 
{ int rcode ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  u32 __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char (*__cil_tmp10)[32U] ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  u32 __cil_tmp16 ;

  {
  {
#line 936
  __cil_tmp3 = (unsigned long )pHba;
#line 936
  __cil_tmp4 = __cil_tmp3 + 24;
#line 936
  __cil_tmp5 = (unsigned long )pHba;
#line 936
  __cil_tmp6 = __cil_tmp5 + 24;
#line 936
  __cil_tmp7 = *((u32 *)__cil_tmp6);
#line 936
  *((u32 *)__cil_tmp4) = __cil_tmp7 | 1U;
#line 939
  rcode = adpt_i2o_activate_hba(pHba);
  }
#line 939
  if (rcode < 0) {
    {
#line 940
    __cil_tmp8 = (unsigned long )pHba;
#line 940
    __cil_tmp9 = __cil_tmp8 + 114;
#line 940
    __cil_tmp10 = (char (*)[32U])__cil_tmp9;
#line 940
    __cil_tmp11 = (char *)__cil_tmp10;
#line 940
    printk("<3>%s: Could not activate\n", __cil_tmp11);
#line 941
    adpt_i2o_delete_hba(pHba);
    }
#line 942
    return (rcode);
  } else {

  }
  {
#line 945
  rcode = adpt_i2o_build_sys_table();
  }
#line 945
  if (rcode < 0) {
    {
#line 946
    adpt_i2o_delete_hba(pHba);
    }
#line 947
    return (rcode);
  } else {

  }
  {
#line 951
  rcode = adpt_i2o_online_hba(pHba);
  }
#line 951
  if (rcode < 0) {
    {
#line 952
    adpt_i2o_delete_hba(pHba);
    }
#line 953
    return (rcode);
  } else {

  }
  {
#line 957
  rcode = adpt_i2o_lct_get(pHba);
  }
#line 957
  if (rcode < 0) {
    {
#line 958
    adpt_i2o_delete_hba(pHba);
    }
#line 959
    return (rcode);
  } else {

  }
  {
#line 962
  rcode = adpt_i2o_reparse_lct(pHba);
  }
#line 962
  if (rcode < 0) {
    {
#line 963
    adpt_i2o_delete_hba(pHba);
    }
#line 964
    return (rcode);
  } else {

  }
  {
#line 966
  __cil_tmp12 = (unsigned long )pHba;
#line 966
  __cil_tmp13 = __cil_tmp12 + 24;
#line 966
  __cil_tmp14 = (unsigned long )pHba;
#line 966
  __cil_tmp15 = __cil_tmp14 + 24;
#line 966
  __cil_tmp16 = *((u32 *)__cil_tmp15);
#line 966
  *((u32 *)__cil_tmp13) = __cil_tmp16 & 4294967294U;
#line 968
  adpt_fail_posted_scbs(pHba);
  }
#line 969
  return (0);
}
}
#line 978 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_i2o_sys_shutdown(void) 
{ adpt_hba *pHba ;
  adpt_hba *pNext ;
  struct adpt_i2o_post_wait_data *p1 ;
  struct adpt_i2o_post_wait_data *old ;
  adpt_hba *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void    *__cil_tmp10 ;
  struct adpt_i2o_post_wait_data *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;

  {
  {
#line 983
  printk("<6>Shutting down Adaptec I2O controllers.\n");
#line 984
  printk("<6>   This could take a few minutes if there are many devices attached\n");
#line 989
  pHba = hba_chain;
  }
#line 989
  goto ldv_32300;
  ldv_32299: 
  {
#line 990
  pNext = *((struct _adpt_hba **)pHba);
#line 991
  adpt_i2o_delete_hba(pHba);
#line 989
  pHba = pNext;
  }
  ldv_32300: ;
  {
#line 989
  __cil_tmp5 = (adpt_hba *)0;
#line 989
  __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 989
  __cil_tmp7 = (unsigned long )pHba;
#line 989
  if (__cil_tmp7 != __cil_tmp6) {
#line 990
    goto ldv_32299;
  } else {
#line 992
    goto ldv_32301;
  }
  }
  ldv_32301: 
#line 999
  p1 = adpt_post_wait_queue;
#line 999
  goto ldv_32303;
  ldv_32302: 
  {
#line 1000
  old = p1;
#line 1001
  __cil_tmp8 = (unsigned long )p1;
#line 1001
  __cil_tmp9 = __cil_tmp8 + 16;
#line 1001
  p1 = *((struct adpt_i2o_post_wait_data **)__cil_tmp9);
#line 1002
  __cil_tmp10 = (void    *)old;
#line 1002
  kfree(__cil_tmp10);
  }
  ldv_32303: ;
  {
#line 999
  __cil_tmp11 = (struct adpt_i2o_post_wait_data *)0;
#line 999
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 999
  __cil_tmp13 = (unsigned long )p1;
#line 999
  if (__cil_tmp13 != __cil_tmp12) {
#line 1000
    goto ldv_32302;
  } else {
#line 1002
    goto ldv_32304;
  }
  }
  ldv_32304: 
  {
#line 1005
  adpt_post_wait_queue = (struct adpt_i2o_post_wait_data *)0;
#line 1007
  printk("<6>Adaptec I2O controllers down.\n");
  }
#line 1008
  return;
}
}
#line 1010 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_install_hba(struct scsi_host_template *sht , struct pci_dev *pDev ) 
{ adpt_hba *pHba ;
  adpt_hba *p ;
  ulong base_addr0_phys ;
  ulong base_addr1_phys ;
  u32 hba_map0_area_size ;
  u32 hba_map1_area_size ;
  void *base_addr_virt ;
  void *msg_addr_virt ;
  int dma64 ;
  int raptorFlag ;
  int tmp ;
  int tmp___0 ;
  u64 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct device *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  resource_size_t __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  resource_size_t __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  resource_size_t __cil_tmp41 ;
  u32 __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  resource_size_t __cil_tmp48 ;
  u32 __cil_tmp49 ;
  u32 __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  resource_size_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  resource_size_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  resource_size_t __cil_tmp66 ;
  u32 __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  resource_size_t __cil_tmp73 ;
  u32 __cil_tmp74 ;
  u32 __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned short __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned short __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned short __cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  resource_size_t __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  resource_size_t __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  resource_size_t __cil_tmp102 ;
  u32 __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  resource_size_t __cil_tmp109 ;
  u32 __cil_tmp110 ;
  u32 __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  resource_size_t __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  resource_size_t __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  resource_size_t __cil_tmp127 ;
  u32 __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  resource_size_t __cil_tmp134 ;
  u32 __cil_tmp135 ;
  u32 __cil_tmp136 ;
  resource_size_t __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  void *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  resource_size_t __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  void *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  void volatile   *__cil_tmp147 ;
  adpt_hba *__cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  void volatile   *__cil_tmp153 ;
  void volatile   *__cil_tmp154 ;
  adpt_hba *__cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  struct _adpt_hba *__cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct _adpt_hba *__cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  char (*__cil_tmp166)[32U] ;
  char *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  spinlock_t *__cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  struct raw_spinlock *__cil_tmp205 ;
  spinlock_t *__cil_tmp206 ;
  struct raw_spinlock *__cil_tmp207 ;
  int __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned int __cil_tmp211 ;
  int __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  unsigned int __cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned int __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  char (*__cil_tmp221)[32U] ;
  char    *__cil_tmp222 ;
  void *__cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  char (*__cil_tmp226)[32U] ;
  char *__cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned int __cil_tmp230 ;

  {
  {
#line 1013
  pHba = (adpt_hba *)0;
#line 1014
  p = (adpt_hba *)0;
#line 1015
  base_addr0_phys = 0UL;
#line 1016
  base_addr1_phys = 0UL;
#line 1017
  hba_map0_area_size = 0U;
#line 1018
  hba_map1_area_size = 0U;
#line 1019
  base_addr_virt = (void *)0;
#line 1020
  msg_addr_virt = (void *)0;
#line 1021
  dma64 = 0;
#line 1023
  raptorFlag = 0;
#line 1025
  tmp = pci_enable_device(pDev);
  }
#line 1025
  if (tmp != 0) {
#line 1026
    return (-22);
  } else {

  }
  {
#line 1029
  tmp___0 = pci_request_regions(pDev, "dpt_i2o");
  }
#line 1029
  if (tmp___0 != 0) {
    {
#line 1030
    printk("<3>dpti: adpt_config_hba: pci request region failed\n");
    }
#line 1031
    return (-22);
  } else {

  }
  {
#line 1034
  pci_set_master(pDev);
#line 1039
  tmp___2 = pci_set_dma_mask(pDev, 0xffffffffffffffffULL);
  }
#line 1039
  if (tmp___2 == 0) {
    {
#line 1041
    __cil_tmp24 = (unsigned long )pDev;
#line 1041
    __cil_tmp25 = __cil_tmp24 + 144;
#line 1041
    __cil_tmp26 = (struct device *)__cil_tmp25;
#line 1041
    tmp___1 = dma_get_required_mask(__cil_tmp26);
    }
#line 1041
    if (tmp___1 > 4294967295ULL) {
#line 1042
      dma64 = 1;
    } else {

    }
  } else {

  }
#line 1044
  if (dma64 == 0) {
    {
#line 1044
    tmp___3 = pci_set_dma_mask(pDev, 4294967295ULL);
    }
#line 1044
    if (tmp___3 != 0) {
#line 1045
      return (-22);
    } else {

    }
  } else {

  }
  {
#line 1048
  pci_set_consistent_dma_mask(pDev, 4294967295ULL);
#line 1050
  __cil_tmp27 = 0 * 56UL;
#line 1050
  __cil_tmp28 = 1304 + __cil_tmp27;
#line 1050
  __cil_tmp29 = (unsigned long )pDev;
#line 1050
  __cil_tmp30 = __cil_tmp29 + __cil_tmp28;
#line 1050
  __cil_tmp31 = *((resource_size_t *)__cil_tmp30);
#line 1050
  base_addr0_phys = (ulong )__cil_tmp31;
  }
  {
#line 1051
  __cil_tmp32 = 0 * 56UL;
#line 1051
  __cil_tmp33 = 1304 + __cil_tmp32;
#line 1051
  __cil_tmp34 = (unsigned long )pDev;
#line 1051
  __cil_tmp35 = __cil_tmp34 + __cil_tmp33;
#line 1051
  __cil_tmp36 = *((resource_size_t *)__cil_tmp35);
#line 1051
  if (__cil_tmp36 != 0ULL) {
#line 1051
    __cil_tmp37 = 0 * 56UL;
#line 1051
    __cil_tmp38 = 1304 + __cil_tmp37;
#line 1051
    __cil_tmp39 = (unsigned long )pDev;
#line 1051
    __cil_tmp40 = __cil_tmp39 + __cil_tmp38;
#line 1051
    __cil_tmp41 = *((resource_size_t *)__cil_tmp40);
#line 1051
    __cil_tmp42 = (u32 )__cil_tmp41;
#line 1051
    __cil_tmp43 = 0 * 56UL;
#line 1051
    __cil_tmp44 = __cil_tmp43 + 8;
#line 1051
    __cil_tmp45 = 1304 + __cil_tmp44;
#line 1051
    __cil_tmp46 = (unsigned long )pDev;
#line 1051
    __cil_tmp47 = __cil_tmp46 + __cil_tmp45;
#line 1051
    __cil_tmp48 = *((resource_size_t *)__cil_tmp47);
#line 1051
    __cil_tmp49 = (u32 )__cil_tmp48;
#line 1051
    __cil_tmp50 = __cil_tmp49 - __cil_tmp42;
#line 1051
    hba_map0_area_size = __cil_tmp50 + 1U;
  } else {
    {
#line 1051
    __cil_tmp51 = 0 * 56UL;
#line 1051
    __cil_tmp52 = 1304 + __cil_tmp51;
#line 1051
    __cil_tmp53 = (unsigned long )pDev;
#line 1051
    __cil_tmp54 = __cil_tmp53 + __cil_tmp52;
#line 1051
    __cil_tmp55 = *((resource_size_t *)__cil_tmp54);
#line 1051
    __cil_tmp56 = 0 * 56UL;
#line 1051
    __cil_tmp57 = __cil_tmp56 + 8;
#line 1051
    __cil_tmp58 = 1304 + __cil_tmp57;
#line 1051
    __cil_tmp59 = (unsigned long )pDev;
#line 1051
    __cil_tmp60 = __cil_tmp59 + __cil_tmp58;
#line 1051
    __cil_tmp61 = *((resource_size_t *)__cil_tmp60);
#line 1051
    if (__cil_tmp61 != __cil_tmp55) {
#line 1051
      __cil_tmp62 = 0 * 56UL;
#line 1051
      __cil_tmp63 = 1304 + __cil_tmp62;
#line 1051
      __cil_tmp64 = (unsigned long )pDev;
#line 1051
      __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
#line 1051
      __cil_tmp66 = *((resource_size_t *)__cil_tmp65);
#line 1051
      __cil_tmp67 = (u32 )__cil_tmp66;
#line 1051
      __cil_tmp68 = 0 * 56UL;
#line 1051
      __cil_tmp69 = __cil_tmp68 + 8;
#line 1051
      __cil_tmp70 = 1304 + __cil_tmp69;
#line 1051
      __cil_tmp71 = (unsigned long )pDev;
#line 1051
      __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 1051
      __cil_tmp73 = *((resource_size_t *)__cil_tmp72);
#line 1051
      __cil_tmp74 = (u32 )__cil_tmp73;
#line 1051
      __cil_tmp75 = __cil_tmp74 - __cil_tmp67;
#line 1051
      hba_map0_area_size = __cil_tmp75 + 1U;
    } else {
#line 1051
      hba_map0_area_size = 0U;
    }
    }
  }
  }
  {
#line 1054
  __cil_tmp76 = (unsigned long )pDev;
#line 1054
  __cil_tmp77 = __cil_tmp76 + 62;
#line 1054
  __cil_tmp78 = *((unsigned short *)__cil_tmp77);
#line 1054
  __cil_tmp79 = (unsigned int )__cil_tmp78;
#line 1054
  if (__cil_tmp79 == 42241U) {
    {
#line 1055
    __cil_tmp80 = (unsigned long )pDev;
#line 1055
    __cil_tmp81 = __cil_tmp80 + 66;
#line 1055
    __cil_tmp82 = *((unsigned short *)__cil_tmp81);
#line 1055
    __cil_tmp83 = (unsigned int )__cil_tmp82;
#line 1055
    if (__cil_tmp83 > 49201U) {
      {
#line 1055
      __cil_tmp84 = (unsigned long )pDev;
#line 1055
      __cil_tmp85 = __cil_tmp84 + 66;
#line 1055
      __cil_tmp86 = *((unsigned short *)__cil_tmp85);
#line 1055
      __cil_tmp87 = (unsigned int )__cil_tmp86;
#line 1055
      if (__cil_tmp87 <= 49211U) {
#line 1057
        hba_map0_area_size = 4194304U;
      } else {
#line 1055
        goto _L;
      }
      }
    } else
    _L: /* CIL Label */ 
#line 1059
    if (hba_map0_area_size > 1048576U) {
#line 1060
      hba_map0_area_size = 1048576U;
    } else {
#line 1065
      __cil_tmp88 = 1 * 56UL;
#line 1065
      __cil_tmp89 = 1304 + __cil_tmp88;
#line 1065
      __cil_tmp90 = (unsigned long )pDev;
#line 1065
      __cil_tmp91 = __cil_tmp90 + __cil_tmp89;
#line 1065
      __cil_tmp92 = *((resource_size_t *)__cil_tmp91);
#line 1065
      base_addr1_phys = (ulong )__cil_tmp92;
      {
#line 1066
      __cil_tmp93 = 1 * 56UL;
#line 1066
      __cil_tmp94 = 1304 + __cil_tmp93;
#line 1066
      __cil_tmp95 = (unsigned long )pDev;
#line 1066
      __cil_tmp96 = __cil_tmp95 + __cil_tmp94;
#line 1066
      __cil_tmp97 = *((resource_size_t *)__cil_tmp96);
#line 1066
      if (__cil_tmp97 != 0ULL) {
#line 1066
        __cil_tmp98 = 1 * 56UL;
#line 1066
        __cil_tmp99 = 1304 + __cil_tmp98;
#line 1066
        __cil_tmp100 = (unsigned long )pDev;
#line 1066
        __cil_tmp101 = __cil_tmp100 + __cil_tmp99;
#line 1066
        __cil_tmp102 = *((resource_size_t *)__cil_tmp101);
#line 1066
        __cil_tmp103 = (u32 )__cil_tmp102;
#line 1066
        __cil_tmp104 = 1 * 56UL;
#line 1066
        __cil_tmp105 = __cil_tmp104 + 8;
#line 1066
        __cil_tmp106 = 1304 + __cil_tmp105;
#line 1066
        __cil_tmp107 = (unsigned long )pDev;
#line 1066
        __cil_tmp108 = __cil_tmp107 + __cil_tmp106;
#line 1066
        __cil_tmp109 = *((resource_size_t *)__cil_tmp108);
#line 1066
        __cil_tmp110 = (u32 )__cil_tmp109;
#line 1066
        __cil_tmp111 = __cil_tmp110 - __cil_tmp103;
#line 1066
        hba_map1_area_size = __cil_tmp111 + 1U;
      } else {
        {
#line 1066
        __cil_tmp112 = 1 * 56UL;
#line 1066
        __cil_tmp113 = 1304 + __cil_tmp112;
#line 1066
        __cil_tmp114 = (unsigned long )pDev;
#line 1066
        __cil_tmp115 = __cil_tmp114 + __cil_tmp113;
#line 1066
        __cil_tmp116 = *((resource_size_t *)__cil_tmp115);
#line 1066
        __cil_tmp117 = 1 * 56UL;
#line 1066
        __cil_tmp118 = __cil_tmp117 + 8;
#line 1066
        __cil_tmp119 = 1304 + __cil_tmp118;
#line 1066
        __cil_tmp120 = (unsigned long )pDev;
#line 1066
        __cil_tmp121 = __cil_tmp120 + __cil_tmp119;
#line 1066
        __cil_tmp122 = *((resource_size_t *)__cil_tmp121);
#line 1066
        if (__cil_tmp122 != __cil_tmp116) {
#line 1066
          __cil_tmp123 = 1 * 56UL;
#line 1066
          __cil_tmp124 = 1304 + __cil_tmp123;
#line 1066
          __cil_tmp125 = (unsigned long )pDev;
#line 1066
          __cil_tmp126 = __cil_tmp125 + __cil_tmp124;
#line 1066
          __cil_tmp127 = *((resource_size_t *)__cil_tmp126);
#line 1066
          __cil_tmp128 = (u32 )__cil_tmp127;
#line 1066
          __cil_tmp129 = 1 * 56UL;
#line 1066
          __cil_tmp130 = __cil_tmp129 + 8;
#line 1066
          __cil_tmp131 = 1304 + __cil_tmp130;
#line 1066
          __cil_tmp132 = (unsigned long )pDev;
#line 1066
          __cil_tmp133 = __cil_tmp132 + __cil_tmp131;
#line 1066
          __cil_tmp134 = *((resource_size_t *)__cil_tmp133);
#line 1066
          __cil_tmp135 = (u32 )__cil_tmp134;
#line 1066
          __cil_tmp136 = __cil_tmp135 - __cil_tmp128;
#line 1066
          hba_map1_area_size = __cil_tmp136 + 1U;
        } else {
#line 1066
          hba_map1_area_size = 0U;
        }
        }
      }
      }
#line 1067
      raptorFlag = 1;
    }
    }
  } else {

  }
  }
#line 1078
  if (raptorFlag == 1) {
#line 1079
    if (hba_map0_area_size > 128U) {
#line 1080
      hba_map0_area_size = 128U;
    } else {

    }
#line 1081
    if (hba_map1_area_size > 524288U) {
#line 1082
      hba_map1_area_size = 524288U;
    } else {

    }
  } else
#line 1084
  if (hba_map0_area_size > 524288U) {
#line 1085
    hba_map0_area_size = 524288U;
  } else {

  }
  {
#line 1089
  __cil_tmp137 = (resource_size_t )base_addr0_phys;
#line 1089
  __cil_tmp138 = (unsigned long )hba_map0_area_size;
#line 1089
  base_addr_virt = ioremap(__cil_tmp137, __cil_tmp138);
  }
  {
#line 1090
  __cil_tmp139 = (void *)0;
#line 1090
  __cil_tmp140 = (unsigned long )__cil_tmp139;
#line 1090
  __cil_tmp141 = (unsigned long )base_addr_virt;
#line 1090
  if (__cil_tmp141 == __cil_tmp140) {
    {
#line 1091
    pci_release_regions(pDev);
#line 1092
    printk("<3>dpti: adpt_config_hba: io remap failed\n");
    }
#line 1093
    return (-22);
  } else {

  }
  }
#line 1096
  if (raptorFlag == 1) {
    {
#line 1097
    __cil_tmp142 = (resource_size_t )base_addr1_phys;
#line 1097
    __cil_tmp143 = (unsigned long )hba_map1_area_size;
#line 1097
    msg_addr_virt = ioremap(__cil_tmp142, __cil_tmp143);
    }
    {
#line 1098
    __cil_tmp144 = (void *)0;
#line 1098
    __cil_tmp145 = (unsigned long )__cil_tmp144;
#line 1098
    __cil_tmp146 = (unsigned long )msg_addr_virt;
#line 1098
    if (__cil_tmp146 == __cil_tmp145) {
      {
#line 1099
      printk("<3>dpti: adpt_config_hba: io remap failed on BAR1\n");
#line 1100
      __cil_tmp147 = (void volatile   *)base_addr_virt;
#line 1100
      iounmap(__cil_tmp147);
#line 1101
      pci_release_regions(pDev);
      }
#line 1102
      return (-22);
    } else {

    }
    }
  } else {
#line 1105
    msg_addr_virt = base_addr_virt;
  }
  {
#line 1109
  tmp___4 = kzalloc(5656UL, 208U);
#line 1109
  pHba = (adpt_hba *)tmp___4;
  }
  {
#line 1110
  __cil_tmp148 = (adpt_hba *)0;
#line 1110
  __cil_tmp149 = (unsigned long )__cil_tmp148;
#line 1110
  __cil_tmp150 = (unsigned long )pHba;
#line 1110
  if (__cil_tmp150 == __cil_tmp149) {
    {
#line 1111
    __cil_tmp151 = (unsigned long )base_addr_virt;
#line 1111
    __cil_tmp152 = (unsigned long )msg_addr_virt;
#line 1111
    if (__cil_tmp152 != __cil_tmp151) {
      {
#line 1112
      __cil_tmp153 = (void volatile   *)msg_addr_virt;
#line 1112
      iounmap(__cil_tmp153);
      }
    } else {

    }
    }
    {
#line 1113
    __cil_tmp154 = (void volatile   *)base_addr_virt;
#line 1113
    iounmap(__cil_tmp154);
#line 1114
    pci_release_regions(pDev);
    }
#line 1115
    return (-12);
  } else {

  }
  }
  {
#line 1118
  mutex_lock_nested(& adpt_configuration_lock, 0U);
  }
  {
#line 1120
  __cil_tmp155 = (adpt_hba *)0;
#line 1120
  __cil_tmp156 = (unsigned long )__cil_tmp155;
#line 1120
  __cil_tmp157 = (unsigned long )hba_chain;
#line 1120
  if (__cil_tmp157 != __cil_tmp156) {
#line 1121
    p = hba_chain;
#line 1121
    goto ldv_32320;
    ldv_32319: 
#line 1121
    p = *((struct _adpt_hba **)p);
    ldv_32320: ;
    {
#line 1121
    __cil_tmp158 = (struct _adpt_hba *)0;
#line 1121
    __cil_tmp159 = (unsigned long )__cil_tmp158;
#line 1121
    __cil_tmp160 = *((struct _adpt_hba **)p);
#line 1121
    __cil_tmp161 = (unsigned long )__cil_tmp160;
#line 1121
    if (__cil_tmp161 != __cil_tmp159) {
#line 1122
      goto ldv_32319;
    } else {
#line 1124
      goto ldv_32321;
    }
    }
    ldv_32321: 
#line 1122
    *((struct _adpt_hba **)p) = pHba;
  } else {
#line 1124
    hba_chain = pHba;
  }
  }
  {
#line 1126
  *((struct _adpt_hba **)pHba) = (struct _adpt_hba *)0;
#line 1127
  __cil_tmp162 = (unsigned long )pHba;
#line 1127
  __cil_tmp163 = __cil_tmp162 + 104;
#line 1127
  *((int *)__cil_tmp163) = hba_count;
#line 1128
  __cil_tmp164 = (unsigned long )pHba;
#line 1128
  __cil_tmp165 = __cil_tmp164 + 114;
#line 1128
  __cil_tmp166 = (char (*)[32U])__cil_tmp165;
#line 1128
  __cil_tmp167 = (char *)__cil_tmp166;
#line 1128
  sprintf(__cil_tmp167, "dpti%d", hba_count);
#line 1129
  hba_count = hba_count + 1;
#line 1131
  mutex_unlock(& adpt_configuration_lock);
#line 1133
  __cil_tmp168 = (unsigned long )pHba;
#line 1133
  __cil_tmp169 = __cil_tmp168 + 8;
#line 1133
  *((struct pci_dev **)__cil_tmp169) = pDev;
#line 1134
  __cil_tmp170 = (unsigned long )pHba;
#line 1134
  __cil_tmp171 = __cil_tmp170 + 224;
#line 1134
  *((ulong *)__cil_tmp171) = base_addr0_phys;
#line 1137
  __cil_tmp172 = (unsigned long )pHba;
#line 1137
  __cil_tmp173 = __cil_tmp172 + 208;
#line 1137
  *((void **)__cil_tmp173) = base_addr_virt;
#line 1138
  __cil_tmp174 = (unsigned long )pHba;
#line 1138
  __cil_tmp175 = __cil_tmp174 + 216;
#line 1138
  *((void **)__cil_tmp175) = msg_addr_virt;
#line 1139
  __cil_tmp176 = (unsigned long )pHba;
#line 1139
  __cil_tmp177 = __cil_tmp176 + 248;
#line 1139
  *((void **)__cil_tmp177) = base_addr_virt + 48UL;
#line 1140
  __cil_tmp178 = (unsigned long )pHba;
#line 1140
  __cil_tmp179 = __cil_tmp178 + 232;
#line 1140
  *((void **)__cil_tmp179) = base_addr_virt + 64UL;
#line 1141
  __cil_tmp180 = (unsigned long )pHba;
#line 1141
  __cil_tmp181 = __cil_tmp180 + 240;
#line 1141
  *((void **)__cil_tmp181) = base_addr_virt + 68UL;
#line 1143
  __cil_tmp182 = (unsigned long )pHba;
#line 1143
  __cil_tmp183 = __cil_tmp182 + 312;
#line 1143
  *((i2o_hrt **)__cil_tmp183) = (i2o_hrt *)0;
#line 1144
  __cil_tmp184 = (unsigned long )pHba;
#line 1144
  __cil_tmp185 = __cil_tmp184 + 328;
#line 1144
  *((i2o_lct **)__cil_tmp185) = (i2o_lct *)0;
#line 1145
  __cil_tmp186 = (unsigned long )pHba;
#line 1145
  __cil_tmp187 = __cil_tmp186 + 344;
#line 1145
  *((uint *)__cil_tmp187) = 0U;
#line 1146
  __cil_tmp188 = (unsigned long )pHba;
#line 1146
  __cil_tmp189 = __cil_tmp188 + 296;
#line 1146
  *((i2o_status_block **)__cil_tmp189) = (i2o_status_block *)0;
#line 1147
  __cil_tmp190 = (unsigned long )pHba;
#line 1147
  __cil_tmp191 = __cil_tmp190 + 256;
#line 1147
  *((u16 *)__cil_tmp191) = (u16 )0U;
#line 1148
  __cil_tmp192 = (unsigned long )pHba;
#line 1148
  __cil_tmp193 = __cil_tmp192 + 24;
#line 1148
  *((u32 *)__cil_tmp193) = 1U;
#line 1149
  __cil_tmp194 = (unsigned long )pHba;
#line 1149
  __cil_tmp195 = __cil_tmp194 + 8;
#line 1149
  *((struct pci_dev **)__cil_tmp195) = pDev;
#line 1150
  __cil_tmp196 = (unsigned long )pHba;
#line 1150
  __cil_tmp197 = __cil_tmp196 + 352;
#line 1150
  *((struct i2o_device **)__cil_tmp197) = (struct i2o_device *)0;
#line 1151
  __cil_tmp198 = (unsigned long )pHba;
#line 1151
  __cil_tmp199 = __cil_tmp198 + 295;
#line 1151
  *((u8 *)__cil_tmp199) = (u8 )dma64;
#line 1154
  __cil_tmp200 = (unsigned long )pHba;
#line 1154
  __cil_tmp201 = __cil_tmp200 + 32;
#line 1154
  __cil_tmp202 = (spinlock_t *)__cil_tmp201;
#line 1154
  spinlock_check(__cil_tmp202);
#line 1154
  __cil_tmp203 = (unsigned long )pHba;
#line 1154
  __cil_tmp204 = __cil_tmp203 + 32;
#line 1154
  __cil_tmp205 = (struct raw_spinlock *)__cil_tmp204;
#line 1154
  __raw_spin_lock_init(__cil_tmp205, "&(&pHba->state_lock)->rlock", & __key);
#line 1155
  spinlock_check(& adpt_post_wait_lock);
#line 1155
  __cil_tmp206 = & adpt_post_wait_lock;
#line 1155
  __cil_tmp207 = (struct raw_spinlock *)__cil_tmp206;
#line 1155
  __raw_spin_lock_init(__cil_tmp207, "&(&adpt_post_wait_lock)->rlock", & __key___0);
  }
#line 1157
  if (raptorFlag == 0) {
#line 1158
    if (dma64 != 0) {
#line 1158
      tmp___5 = (char *)" (64-bit DMA)";
    } else {
#line 1158
      tmp___5 = (char *)"";
    }
    {
#line 1158
    __cil_tmp208 = hba_count + -1;
#line 1158
    __cil_tmp209 = (unsigned long )pDev;
#line 1158
    __cil_tmp210 = __cil_tmp209 + 1300;
#line 1158
    __cil_tmp211 = *((unsigned int *)__cil_tmp210);
#line 1158
    printk("<6>Adaptec I2O RAID controller %d at %p size=%x irq=%d%s\n", __cil_tmp208,
           base_addr_virt, hba_map0_area_size, __cil_tmp211, tmp___5);
    }
  } else {
#line 1164
    if (dma64 != 0) {
#line 1164
      tmp___6 = (char *)" (64-bit DMA)";
    } else {
#line 1164
      tmp___6 = (char *)"";
    }
    {
#line 1164
    __cil_tmp212 = hba_count + -1;
#line 1164
    __cil_tmp213 = (unsigned long )pDev;
#line 1164
    __cil_tmp214 = __cil_tmp213 + 1300;
#line 1164
    __cil_tmp215 = *((unsigned int *)__cil_tmp214);
#line 1164
    printk("<6>Adaptec I2O RAID controller %d irq=%d%s\n", __cil_tmp212, __cil_tmp215,
           tmp___6);
#line 1167
    printk("<6>     BAR0 %p - size= %x\n", base_addr_virt, hba_map0_area_size);
#line 1168
    printk("<6>     BAR1 %p - size= %x\n", msg_addr_virt, hba_map1_area_size);
    }
  }
  {
#line 1171
  __cil_tmp216 = (unsigned long )pDev;
#line 1171
  __cil_tmp217 = __cil_tmp216 + 1300;
#line 1171
  __cil_tmp218 = *((unsigned int *)__cil_tmp217);
#line 1171
  __cil_tmp219 = (unsigned long )pHba;
#line 1171
  __cil_tmp220 = __cil_tmp219 + 114;
#line 1171
  __cil_tmp221 = (char (*)[32U])__cil_tmp220;
#line 1171
  __cil_tmp222 = (char    *)__cil_tmp221;
#line 1171
  __cil_tmp223 = (void *)pHba;
#line 1171
  tmp___7 = request_irq(__cil_tmp218, & adpt_isr, 128UL, __cil_tmp222, __cil_tmp223);
  }
#line 1171
  if (tmp___7 != 0) {
    {
#line 1172
    __cil_tmp224 = (unsigned long )pHba;
#line 1172
    __cil_tmp225 = __cil_tmp224 + 114;
#line 1172
    __cil_tmp226 = (char (*)[32U])__cil_tmp225;
#line 1172
    __cil_tmp227 = (char *)__cil_tmp226;
#line 1172
    __cil_tmp228 = (unsigned long )pDev;
#line 1172
    __cil_tmp229 = __cil_tmp228 + 1300;
#line 1172
    __cil_tmp230 = *((unsigned int *)__cil_tmp229);
#line 1172
    printk("<3>%s: Couldn\'t register IRQ %d\n", __cil_tmp227, __cil_tmp230);
#line 1173
    adpt_i2o_delete_hba(pHba);
    }
#line 1174
    return (-22);
  } else {

  }
#line 1177
  return (0);
}
}
#line 1181 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_i2o_delete_hba(adpt_hba *pHba ) 
{ adpt_hba *p1 ;
  adpt_hba *p2 ;
  struct i2o_device *d ;
  struct i2o_device *next ;
  int i ;
  int j ;
  struct adpt_device *pDev ;
  struct adpt_device *pNext ;
  struct Scsi_Host *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct Scsi_Host *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct Scsi_Host *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  void *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  adpt_hba *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  adpt_hba *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  void volatile   *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct pci_dev *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  void *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  void *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  void volatile   *__cil_tmp49 ;
  void *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  void *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  void *__cil_tmp58 ;
  void volatile   *__cil_tmp59 ;
  i2o_hrt *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  i2o_hrt *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  struct pci_dev *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  struct device *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  i2o_hrt *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  __u8 __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  i2o_hrt *__cil_tmp81 ;
  __u16 __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  size_t __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  i2o_hrt *__cil_tmp89 ;
  void *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  dma_addr_t __cil_tmp93 ;
  struct dma_attrs *__cil_tmp94 ;
  i2o_lct *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  i2o_lct *__cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  struct pci_dev *__cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct device *__cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  uint __cil_tmp109 ;
  size_t __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  i2o_lct *__cil_tmp113 ;
  void *__cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  dma_addr_t __cil_tmp117 ;
  struct dma_attrs *__cil_tmp118 ;
  i2o_status_block *__cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  i2o_status_block *__cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  struct pci_dev *__cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  struct device *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  i2o_status_block *__cil_tmp133 ;
  void *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  dma_addr_t __cil_tmp137 ;
  struct dma_attrs *__cil_tmp138 ;
  u32 *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  u32 *__cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  struct pci_dev *__cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  struct device *__cil_tmp150 ;
  unsigned long __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  u32 __cil_tmp153 ;
  u32 __cil_tmp154 ;
  size_t __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  u32 *__cil_tmp158 ;
  void *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  dma_addr_t __cil_tmp162 ;
  struct dma_attrs *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  void    *__cil_tmp166 ;
  struct i2o_device *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  struct adpt_device *__cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  struct adpt_device *__cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  void    *__cil_tmp188 ;
  struct adpt_device *__cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  u8 __cil_tmp194 ;
  int __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  struct pci_dev *__cil_tmp198 ;
  struct class *__cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  int __cil_tmp204 ;
  int __cil_tmp205 ;
  dev_t __cil_tmp206 ;
  void    *__cil_tmp207 ;
  struct class *__cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  unsigned long __cil_tmp210 ;

  {
  {
#line 1193
  mutex_lock_nested(& adpt_configuration_lock, 0U);
  }
  {
#line 1196
  __cil_tmp10 = (struct Scsi_Host *)0;
#line 1196
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1196
  __cil_tmp12 = (unsigned long )pHba;
#line 1196
  __cil_tmp13 = __cil_tmp12 + 16;
#line 1196
  __cil_tmp14 = *((struct Scsi_Host **)__cil_tmp13);
#line 1196
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 1196
  if (__cil_tmp15 != __cil_tmp11) {
    {
#line 1197
    __cil_tmp16 = (unsigned long )pHba;
#line 1197
    __cil_tmp17 = __cil_tmp16 + 16;
#line 1197
    __cil_tmp18 = *((struct Scsi_Host **)__cil_tmp17);
#line 1197
    __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 1197
    __cil_tmp20 = __cil_tmp19 + 700;
#line 1197
    __cil_tmp21 = *((unsigned int *)__cil_tmp20);
#line 1197
    __cil_tmp22 = (void *)pHba;
#line 1197
    free_irq(__cil_tmp21, __cil_tmp22);
    }
  } else {

  }
  }
#line 1199
  p2 = (adpt_hba *)0;
#line 1200
  p1 = hba_chain;
#line 1200
  goto ldv_32337;
  ldv_32336: ;
  {
#line 1201
  __cil_tmp23 = (unsigned long )pHba;
#line 1201
  __cil_tmp24 = (unsigned long )p1;
#line 1201
  if (__cil_tmp24 == __cil_tmp23) {
    {
#line 1202
    __cil_tmp25 = (adpt_hba *)0;
#line 1202
    __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 1202
    __cil_tmp27 = (unsigned long )p2;
#line 1202
    if (__cil_tmp27 != __cil_tmp26) {
#line 1203
      *((struct _adpt_hba **)p2) = *((struct _adpt_hba **)p1);
    } else {
#line 1205
      hba_chain = *((struct _adpt_hba **)p1);
    }
    }
#line 1207
    goto ldv_32335;
  } else {

  }
  }
#line 1200
  p2 = p1;
#line 1200
  p1 = *((struct _adpt_hba **)p1);
  ldv_32337: ;
  {
#line 1200
  __cil_tmp28 = (adpt_hba *)0;
#line 1200
  __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 1200
  __cil_tmp30 = (unsigned long )p1;
#line 1200
  if (__cil_tmp30 != __cil_tmp29) {
#line 1201
    goto ldv_32336;
  } else {
#line 1203
    goto ldv_32335;
  }
  }
  ldv_32335: 
  {
#line 1211
  hba_count = hba_count - 1;
#line 1212
  mutex_unlock(& adpt_configuration_lock);
#line 1214
  __cil_tmp31 = (unsigned long )pHba;
#line 1214
  __cil_tmp32 = __cil_tmp31 + 208;
#line 1214
  __cil_tmp33 = *((void **)__cil_tmp32);
#line 1214
  __cil_tmp34 = (void volatile   *)__cil_tmp33;
#line 1214
  iounmap(__cil_tmp34);
#line 1215
  __cil_tmp35 = (unsigned long )pHba;
#line 1215
  __cil_tmp36 = __cil_tmp35 + 8;
#line 1215
  __cil_tmp37 = *((struct pci_dev **)__cil_tmp36);
#line 1215
  pci_release_regions(__cil_tmp37);
  }
  {
#line 1216
  __cil_tmp38 = (unsigned long )pHba;
#line 1216
  __cil_tmp39 = __cil_tmp38 + 208;
#line 1216
  __cil_tmp40 = *((void **)__cil_tmp39);
#line 1216
  __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 1216
  __cil_tmp42 = (unsigned long )pHba;
#line 1216
  __cil_tmp43 = __cil_tmp42 + 216;
#line 1216
  __cil_tmp44 = *((void **)__cil_tmp43);
#line 1216
  __cil_tmp45 = (unsigned long )__cil_tmp44;
#line 1216
  if (__cil_tmp45 != __cil_tmp41) {
    {
#line 1217
    __cil_tmp46 = (unsigned long )pHba;
#line 1217
    __cil_tmp47 = __cil_tmp46 + 216;
#line 1217
    __cil_tmp48 = *((void **)__cil_tmp47);
#line 1217
    __cil_tmp49 = (void volatile   *)__cil_tmp48;
#line 1217
    iounmap(__cil_tmp49);
    }
  } else {

  }
  }
  {
#line 1219
  __cil_tmp50 = (void *)0;
#line 1219
  __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 1219
  __cil_tmp52 = (unsigned long )pHba;
#line 1219
  __cil_tmp53 = __cil_tmp52 + 5568;
#line 1219
  __cil_tmp54 = *((void **)__cil_tmp53);
#line 1219
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 1219
  if (__cil_tmp55 != __cil_tmp51) {
    {
#line 1220
    __cil_tmp56 = (unsigned long )pHba;
#line 1220
    __cil_tmp57 = __cil_tmp56 + 5568;
#line 1220
    __cil_tmp58 = *((void **)__cil_tmp57);
#line 1220
    __cil_tmp59 = (void volatile   *)__cil_tmp58;
#line 1220
    iounmap(__cil_tmp59);
    }
  } else {

  }
  }
  {
#line 1221
  __cil_tmp60 = (i2o_hrt *)0;
#line 1221
  __cil_tmp61 = (unsigned long )__cil_tmp60;
#line 1221
  __cil_tmp62 = (unsigned long )pHba;
#line 1221
  __cil_tmp63 = __cil_tmp62 + 312;
#line 1221
  __cil_tmp64 = *((i2o_hrt **)__cil_tmp63);
#line 1221
  __cil_tmp65 = (unsigned long )__cil_tmp64;
#line 1221
  if (__cil_tmp65 != __cil_tmp61) {
    {
#line 1222
    __cil_tmp66 = (unsigned long )pHba;
#line 1222
    __cil_tmp67 = __cil_tmp66 + 8;
#line 1222
    __cil_tmp68 = *((struct pci_dev **)__cil_tmp67);
#line 1222
    __cil_tmp69 = (unsigned long )__cil_tmp68;
#line 1222
    __cil_tmp70 = __cil_tmp69 + 144;
#line 1222
    __cil_tmp71 = (struct device *)__cil_tmp70;
#line 1222
    __cil_tmp72 = (unsigned long )pHba;
#line 1222
    __cil_tmp73 = __cil_tmp72 + 312;
#line 1222
    __cil_tmp74 = *((i2o_hrt **)__cil_tmp73);
#line 1222
    __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 1222
    __cil_tmp76 = __cil_tmp75 + 2;
#line 1222
    __cil_tmp77 = *((__u8 *)__cil_tmp76);
#line 1222
    __cil_tmp78 = (int )__cil_tmp77;
#line 1222
    __cil_tmp79 = (unsigned long )pHba;
#line 1222
    __cil_tmp80 = __cil_tmp79 + 312;
#line 1222
    __cil_tmp81 = *((i2o_hrt **)__cil_tmp80);
#line 1222
    __cil_tmp82 = *((__u16 *)__cil_tmp81);
#line 1222
    __cil_tmp83 = (int )__cil_tmp82;
#line 1222
    __cil_tmp84 = __cil_tmp83 * __cil_tmp78;
#line 1222
    __cil_tmp85 = __cil_tmp84 << 2;
#line 1222
    __cil_tmp86 = (size_t )__cil_tmp85;
#line 1222
    __cil_tmp87 = (unsigned long )pHba;
#line 1222
    __cil_tmp88 = __cil_tmp87 + 312;
#line 1222
    __cil_tmp89 = *((i2o_hrt **)__cil_tmp88);
#line 1222
    __cil_tmp90 = (void *)__cil_tmp89;
#line 1222
    __cil_tmp91 = (unsigned long )pHba;
#line 1222
    __cil_tmp92 = __cil_tmp91 + 320;
#line 1222
    __cil_tmp93 = *((dma_addr_t *)__cil_tmp92);
#line 1222
    __cil_tmp94 = (struct dma_attrs *)0;
#line 1222
    dma_free_attrs(__cil_tmp71, __cil_tmp86, __cil_tmp90, __cil_tmp93, __cil_tmp94);
    }
  } else {

  }
  }
  {
#line 1226
  __cil_tmp95 = (i2o_lct *)0;
#line 1226
  __cil_tmp96 = (unsigned long )__cil_tmp95;
#line 1226
  __cil_tmp97 = (unsigned long )pHba;
#line 1226
  __cil_tmp98 = __cil_tmp97 + 328;
#line 1226
  __cil_tmp99 = *((i2o_lct **)__cil_tmp98);
#line 1226
  __cil_tmp100 = (unsigned long )__cil_tmp99;
#line 1226
  if (__cil_tmp100 != __cil_tmp96) {
    {
#line 1227
    __cil_tmp101 = (unsigned long )pHba;
#line 1227
    __cil_tmp102 = __cil_tmp101 + 8;
#line 1227
    __cil_tmp103 = *((struct pci_dev **)__cil_tmp102);
#line 1227
    __cil_tmp104 = (unsigned long )__cil_tmp103;
#line 1227
    __cil_tmp105 = __cil_tmp104 + 144;
#line 1227
    __cil_tmp106 = (struct device *)__cil_tmp105;
#line 1227
    __cil_tmp107 = (unsigned long )pHba;
#line 1227
    __cil_tmp108 = __cil_tmp107 + 344;
#line 1227
    __cil_tmp109 = *((uint *)__cil_tmp108);
#line 1227
    __cil_tmp110 = (size_t )__cil_tmp109;
#line 1227
    __cil_tmp111 = (unsigned long )pHba;
#line 1227
    __cil_tmp112 = __cil_tmp111 + 328;
#line 1227
    __cil_tmp113 = *((i2o_lct **)__cil_tmp112);
#line 1227
    __cil_tmp114 = (void *)__cil_tmp113;
#line 1227
    __cil_tmp115 = (unsigned long )pHba;
#line 1227
    __cil_tmp116 = __cil_tmp115 + 336;
#line 1227
    __cil_tmp117 = *((dma_addr_t *)__cil_tmp116);
#line 1227
    __cil_tmp118 = (struct dma_attrs *)0;
#line 1227
    dma_free_attrs(__cil_tmp106, __cil_tmp110, __cil_tmp114, __cil_tmp117, __cil_tmp118);
    }
  } else {

  }
  }
  {
#line 1230
  __cil_tmp119 = (i2o_status_block *)0;
#line 1230
  __cil_tmp120 = (unsigned long )__cil_tmp119;
#line 1230
  __cil_tmp121 = (unsigned long )pHba;
#line 1230
  __cil_tmp122 = __cil_tmp121 + 296;
#line 1230
  __cil_tmp123 = *((i2o_status_block **)__cil_tmp122);
#line 1230
  __cil_tmp124 = (unsigned long )__cil_tmp123;
#line 1230
  if (__cil_tmp124 != __cil_tmp120) {
    {
#line 1231
    __cil_tmp125 = (unsigned long )pHba;
#line 1231
    __cil_tmp126 = __cil_tmp125 + 8;
#line 1231
    __cil_tmp127 = *((struct pci_dev **)__cil_tmp126);
#line 1231
    __cil_tmp128 = (unsigned long )__cil_tmp127;
#line 1231
    __cil_tmp129 = __cil_tmp128 + 144;
#line 1231
    __cil_tmp130 = (struct device *)__cil_tmp129;
#line 1231
    __cil_tmp131 = (unsigned long )pHba;
#line 1231
    __cil_tmp132 = __cil_tmp131 + 296;
#line 1231
    __cil_tmp133 = *((i2o_status_block **)__cil_tmp132);
#line 1231
    __cil_tmp134 = (void *)__cil_tmp133;
#line 1231
    __cil_tmp135 = (unsigned long )pHba;
#line 1231
    __cil_tmp136 = __cil_tmp135 + 304;
#line 1231
    __cil_tmp137 = *((dma_addr_t *)__cil_tmp136);
#line 1231
    __cil_tmp138 = (struct dma_attrs *)0;
#line 1231
    dma_free_attrs(__cil_tmp130, 88UL, __cil_tmp134, __cil_tmp137, __cil_tmp138);
    }
  } else {

  }
  }
  {
#line 1234
  __cil_tmp139 = (u32 *)0;
#line 1234
  __cil_tmp140 = (unsigned long )__cil_tmp139;
#line 1234
  __cil_tmp141 = (unsigned long )pHba;
#line 1234
  __cil_tmp142 = __cil_tmp141 + 272;
#line 1234
  __cil_tmp143 = *((u32 **)__cil_tmp142);
#line 1234
  __cil_tmp144 = (unsigned long )__cil_tmp143;
#line 1234
  if (__cil_tmp144 != __cil_tmp140) {
    {
#line 1235
    __cil_tmp145 = (unsigned long )pHba;
#line 1235
    __cil_tmp146 = __cil_tmp145 + 8;
#line 1235
    __cil_tmp147 = *((struct pci_dev **)__cil_tmp146);
#line 1235
    __cil_tmp148 = (unsigned long )__cil_tmp147;
#line 1235
    __cil_tmp149 = __cil_tmp148 + 144;
#line 1235
    __cil_tmp150 = (struct device *)__cil_tmp149;
#line 1235
    __cil_tmp151 = (unsigned long )pHba;
#line 1235
    __cil_tmp152 = __cil_tmp151 + 264;
#line 1235
    __cil_tmp153 = *((u32 *)__cil_tmp152);
#line 1235
    __cil_tmp154 = __cil_tmp153 * 68U;
#line 1235
    __cil_tmp155 = (size_t )__cil_tmp154;
#line 1235
    __cil_tmp156 = (unsigned long )pHba;
#line 1235
    __cil_tmp157 = __cil_tmp156 + 272;
#line 1235
    __cil_tmp158 = *((u32 **)__cil_tmp157);
#line 1235
    __cil_tmp159 = (void *)__cil_tmp158;
#line 1235
    __cil_tmp160 = (unsigned long )pHba;
#line 1235
    __cil_tmp161 = __cil_tmp160 + 280;
#line 1235
    __cil_tmp162 = *((dma_addr_t *)__cil_tmp161);
#line 1235
    __cil_tmp163 = (struct dma_attrs *)0;
#line 1235
    dma_free_attrs(__cil_tmp150, __cil_tmp155, __cil_tmp159, __cil_tmp162, __cil_tmp163);
    }
  } else {

  }
  }
#line 1240
  __cil_tmp164 = (unsigned long )pHba;
#line 1240
  __cil_tmp165 = __cil_tmp164 + 352;
#line 1240
  d = *((struct i2o_device **)__cil_tmp165);
#line 1240
  goto ldv_32339;
  ldv_32338: 
  {
#line 1241
  next = *((struct i2o_device **)d);
#line 1242
  __cil_tmp166 = (void    *)d;
#line 1242
  kfree(__cil_tmp166);
#line 1240
  d = next;
  }
  ldv_32339: ;
  {
#line 1240
  __cil_tmp167 = (struct i2o_device *)0;
#line 1240
  __cil_tmp168 = (unsigned long )__cil_tmp167;
#line 1240
  __cil_tmp169 = (unsigned long )d;
#line 1240
  if (__cil_tmp169 != __cil_tmp168) {
#line 1241
    goto ldv_32338;
  } else {
#line 1243
    goto ldv_32340;
  }
  }
  ldv_32340: 
#line 1244
  i = 0;
#line 1244
  goto ldv_32348;
  ldv_32347: 
#line 1245
  j = 0;
#line 1245
  goto ldv_32345;
  ldv_32344: ;
  {
#line 1246
  __cil_tmp170 = (struct adpt_device *)0;
#line 1246
  __cil_tmp171 = (unsigned long )__cil_tmp170;
#line 1246
  __cil_tmp172 = j * 8UL;
#line 1246
  __cil_tmp173 = 0 + __cil_tmp172;
#line 1246
  __cil_tmp174 = i * 1040UL;
#line 1246
  __cil_tmp175 = __cil_tmp174 + __cil_tmp173;
#line 1246
  __cil_tmp176 = 360 + __cil_tmp175;
#line 1246
  __cil_tmp177 = (unsigned long )pHba;
#line 1246
  __cil_tmp178 = __cil_tmp177 + __cil_tmp176;
#line 1246
  __cil_tmp179 = *((struct adpt_device **)__cil_tmp178);
#line 1246
  __cil_tmp180 = (unsigned long )__cil_tmp179;
#line 1246
  if (__cil_tmp180 != __cil_tmp171) {
#line 1247
    __cil_tmp181 = j * 8UL;
#line 1247
    __cil_tmp182 = 0 + __cil_tmp181;
#line 1247
    __cil_tmp183 = i * 1040UL;
#line 1247
    __cil_tmp184 = __cil_tmp183 + __cil_tmp182;
#line 1247
    __cil_tmp185 = 360 + __cil_tmp184;
#line 1247
    __cil_tmp186 = (unsigned long )pHba;
#line 1247
    __cil_tmp187 = __cil_tmp186 + __cil_tmp185;
#line 1247
    pDev = *((struct adpt_device **)__cil_tmp187);
#line 1247
    goto ldv_32342;
    ldv_32341: 
    {
#line 1248
    pNext = *((struct adpt_device **)pDev);
#line 1249
    __cil_tmp188 = (void    *)pDev;
#line 1249
    kfree(__cil_tmp188);
#line 1247
    pDev = pNext;
    }
    ldv_32342: ;
    {
#line 1247
    __cil_tmp189 = (struct adpt_device *)0;
#line 1247
    __cil_tmp190 = (unsigned long )__cil_tmp189;
#line 1247
    __cil_tmp191 = (unsigned long )pDev;
#line 1247
    if (__cil_tmp191 != __cil_tmp190) {
#line 1248
      goto ldv_32341;
    } else {
#line 1250
      goto ldv_32343;
    }
    }
    ldv_32343: ;
  } else {

  }
  }
#line 1245
  j = j + 1;
  ldv_32345: ;
#line 1245
  if (j <= 127) {
#line 1246
    goto ldv_32344;
  } else {
#line 1248
    goto ldv_32346;
  }
  ldv_32346: 
#line 1244
  i = i + 1;
  ldv_32348: ;
  {
#line 1244
  __cil_tmp192 = (unsigned long )pHba;
#line 1244
  __cil_tmp193 = __cil_tmp192 + 292;
#line 1244
  __cil_tmp194 = *((u8 *)__cil_tmp193);
#line 1244
  __cil_tmp195 = (int )__cil_tmp194;
#line 1244
  if (__cil_tmp195 > i) {
#line 1245
    goto ldv_32347;
  } else {
#line 1247
    goto ldv_32349;
  }
  }
  ldv_32349: 
  {
#line 1254
  __cil_tmp196 = (unsigned long )pHba;
#line 1254
  __cil_tmp197 = __cil_tmp196 + 8;
#line 1254
  __cil_tmp198 = *((struct pci_dev **)__cil_tmp197);
#line 1254
  pci_dev_put(__cil_tmp198);
  }
  {
#line 1255
  __cil_tmp199 = (struct class *)0;
#line 1255
  __cil_tmp200 = (unsigned long )__cil_tmp199;
#line 1255
  __cil_tmp201 = (unsigned long )adpt_sysfs_class;
#line 1255
  if (__cil_tmp201 != __cil_tmp200) {
    {
#line 1256
    __cil_tmp202 = (unsigned long )pHba;
#line 1256
    __cil_tmp203 = __cil_tmp202 + 104;
#line 1256
    __cil_tmp204 = *((int *)__cil_tmp203);
#line 1256
    __cil_tmp205 = __cil_tmp204 | 158334976;
#line 1256
    __cil_tmp206 = (dev_t )__cil_tmp205;
#line 1256
    device_destroy(adpt_sysfs_class, __cil_tmp206);
    }
  } else {

  }
  }
  {
#line 1258
  __cil_tmp207 = (void    *)pHba;
#line 1258
  kfree(__cil_tmp207);
  }
#line 1260
  if (hba_count <= 0) {
    {
#line 1261
    unregister_chrdev(151U, "dpt_i2o");
    }
    {
#line 1262
    __cil_tmp208 = (struct class *)0;
#line 1262
    __cil_tmp209 = (unsigned long )__cil_tmp208;
#line 1262
    __cil_tmp210 = (unsigned long )adpt_sysfs_class;
#line 1262
    if (__cil_tmp210 != __cil_tmp209) {
      {
#line 1263
      class_destroy(adpt_sysfs_class);
#line 1264
      adpt_sysfs_class = (struct class *)0;
      }
    } else {

    }
    }
  } else {

  }
#line 1267
  return;
}
}
#line 1269 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct adpt_device *adpt_find_device(adpt_hba *pHba , u32 chan , u32 id , u32 lun ) 
{ struct adpt_device *d ;
  struct adpt_device **__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct adpt_device *(*__cil_tmp12)[128U] ;
  struct adpt_device **__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct adpt_device *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  u16 __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  u8 __cil_tmp31 ;
  u32 __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  u8 __cil_tmp35 ;
  u32 __cil_tmp36 ;
  struct adpt_device *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;

  {
#line 1273
  if (chan > 4U) {
#line 1274
    return ((struct adpt_device *)0);
  } else {

  }
  {
#line 1276
  __cil_tmp6 = (struct adpt_device **)0;
#line 1276
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 1276
  __cil_tmp8 = chan * 1040UL;
#line 1276
  __cil_tmp9 = 360 + __cil_tmp8;
#line 1276
  __cil_tmp10 = (unsigned long )pHba;
#line 1276
  __cil_tmp11 = __cil_tmp10 + __cil_tmp9;
#line 1276
  __cil_tmp12 = (struct adpt_device *(*)[128U])__cil_tmp11;
#line 1276
  __cil_tmp13 = (struct adpt_device **)__cil_tmp12;
#line 1276
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1276
  if (__cil_tmp14 == __cil_tmp7) {
    {
#line 1277
    printk("<7>Adaptec I2O RAID: Trying to find device before they are allocated\n");
    }
#line 1278
    return ((struct adpt_device *)0);
  } else {

  }
  }
#line 1281
  __cil_tmp15 = id * 8UL;
#line 1281
  __cil_tmp16 = 0 + __cil_tmp15;
#line 1281
  __cil_tmp17 = chan * 1040UL;
#line 1281
  __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 1281
  __cil_tmp19 = 360 + __cil_tmp18;
#line 1281
  __cil_tmp20 = (unsigned long )pHba;
#line 1281
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 1281
  d = *((struct adpt_device **)__cil_tmp21);
  {
#line 1282
  __cil_tmp22 = (struct adpt_device *)0;
#line 1282
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1282
  __cil_tmp24 = (unsigned long )d;
#line 1282
  if (__cil_tmp24 == __cil_tmp23) {
#line 1283
    return ((struct adpt_device *)0);
  } else {
    {
#line 1282
    __cil_tmp25 = (unsigned long )d;
#line 1282
    __cil_tmp26 = __cil_tmp25 + 28;
#line 1282
    __cil_tmp27 = *((u16 *)__cil_tmp26);
#line 1282
    __cil_tmp28 = (unsigned int )__cil_tmp27;
#line 1282
    if (__cil_tmp28 == 0U) {
#line 1283
      return ((struct adpt_device *)0);
    } else {

    }
    }
  }
  }
  {
#line 1287
  __cil_tmp29 = (unsigned long )d;
#line 1287
  __cil_tmp30 = __cil_tmp29 + 26;
#line 1287
  __cil_tmp31 = *((u8 *)__cil_tmp30);
#line 1287
  __cil_tmp32 = (u32 )__cil_tmp31;
#line 1287
  if (__cil_tmp32 == lun) {
#line 1288
    return (d);
  } else {

  }
  }
#line 1292
  d = *((struct adpt_device **)d);
#line 1292
  goto ldv_32358;
  ldv_32357: ;
  {
#line 1293
  __cil_tmp33 = (unsigned long )d;
#line 1293
  __cil_tmp34 = __cil_tmp33 + 26;
#line 1293
  __cil_tmp35 = *((u8 *)__cil_tmp34);
#line 1293
  __cil_tmp36 = (u32 )__cil_tmp35;
#line 1293
  if (__cil_tmp36 == lun) {
#line 1294
    return (d);
  } else {

  }
  }
#line 1292
  d = *((struct adpt_device **)d);
  ldv_32358: ;
  {
#line 1292
  __cil_tmp37 = (struct adpt_device *)0;
#line 1292
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 1292
  __cil_tmp39 = (unsigned long )d;
#line 1292
  if (__cil_tmp39 != __cil_tmp38) {
#line 1293
    goto ldv_32357;
  } else {
#line 1295
    goto ldv_32359;
  }
  }
  ldv_32359: ;
#line 1297
  return ((struct adpt_device *)0);
}
}
#line 1301 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_post_wait(adpt_hba *pHba , u32 *msg , int len , int timeout ) 
{ wait_queue_head_t adpt_wq_i2o_post ;
  struct lock_class_key __key ;
  int status ;
  ulong flags ;
  struct adpt_i2o_post_wait_data *p1 ;
  struct adpt_i2o_post_wait_data *p2 ;
  struct adpt_i2o_post_wait_data *wait_data ;
  void *tmp ;
  wait_queue_t wait ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long tmp___5 ;
  wait_queue_head_t *__cil_tmp21 ;
  wait_queue_head_t *__cil_tmp22 ;
  wait_queue_t *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct adpt_i2o_post_wait_data *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  u32 *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  u32 __cil_tmp41 ;
  u32 *__cil_tmp42 ;
  u32 __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  struct Scsi_Host *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct Scsi_Host *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  struct Scsi_Host *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  spinlock_t *__cil_tmp56 ;
  long __cil_tmp57 ;
  struct Scsi_Host *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct Scsi_Host *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  struct Scsi_Host *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  spinlock_t *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  int __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  int __cil_tmp75 ;
  struct adpt_i2o_post_wait_data *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct adpt_i2o_post_wait_data *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  void    *__cil_tmp90 ;

  {
  {
#line 1306
  __init_waitqueue_head(& adpt_wq_i2o_post, "&adpt_wq_i2o_post", & __key);
#line 1306
  __cil_tmp21 = & adpt_wq_i2o_post;
#line 1306
  __cil_tmp22 = & adpt_wq_i2o_post;
#line 1306
  *__cil_tmp21 = *__cil_tmp22;
#line 1307
  status = 0;
#line 1308
  flags = 0UL;
#line 1310
  tmp = kmalloc(24UL, 32U);
#line 1310
  wait_data = (struct adpt_i2o_post_wait_data *)tmp;
#line 1312
  tmp___0 = get_current();
#line 1312
  __cil_tmp23 = & wait;
#line 1312
  *((unsigned int *)__cil_tmp23) = 0U;
#line 1312
  __cil_tmp24 = (unsigned long )(& wait) + 8;
#line 1312
  *((void **)__cil_tmp24) = (void *)tmp___0;
#line 1312
  __cil_tmp25 = (unsigned long )(& wait) + 16;
#line 1312
  *((int (**)(wait_queue_t * , unsigned int  , int  , void * ))__cil_tmp25) = & default_wake_function;
#line 1312
  __cil_tmp26 = (unsigned long )(& wait) + 24;
#line 1312
  *((struct list_head **)__cil_tmp26) = (struct list_head *)0;
#line 1312
  __cil_tmp27 = 24 + 8;
#line 1312
  __cil_tmp28 = (unsigned long )(& wait) + __cil_tmp27;
#line 1312
  *((struct list_head **)__cil_tmp28) = (struct list_head *)0;
  }
  {
#line 1314
  __cil_tmp29 = (struct adpt_i2o_post_wait_data *)0;
#line 1314
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 1314
  __cil_tmp31 = (unsigned long )wait_data;
#line 1314
  if (__cil_tmp31 == __cil_tmp30) {
#line 1315
    return (-12);
  } else {

  }
  }
  {
#line 1321
  ldv_spin_lock();
#line 1324
  __cil_tmp32 = (unsigned long )wait_data;
#line 1324
  __cil_tmp33 = __cil_tmp32 + 16;
#line 1324
  *((struct adpt_i2o_post_wait_data **)__cil_tmp33) = adpt_post_wait_queue;
#line 1325
  adpt_post_wait_queue = wait_data;
#line 1326
  adpt_post_wait_id = adpt_post_wait_id + 1U;
#line 1327
  adpt_post_wait_id = adpt_post_wait_id & 32767U;
#line 1328
  __cil_tmp34 = (unsigned long )wait_data;
#line 1328
  __cil_tmp35 = __cil_tmp34 + 4;
#line 1328
  *((u32 *)__cil_tmp35) = adpt_post_wait_id;
#line 1329
  spin_unlock_irqrestore(& adpt_post_wait_lock, flags);
#line 1331
  __cil_tmp36 = (unsigned long )wait_data;
#line 1331
  __cil_tmp37 = __cil_tmp36 + 8;
#line 1331
  *((adpt_wait_queue_head_t **)__cil_tmp37) = & adpt_wq_i2o_post;
#line 1332
  *((int *)wait_data) = -110;
#line 1334
  add_wait_queue(& adpt_wq_i2o_post, & wait);
#line 1336
  __cil_tmp38 = msg + 2UL;
#line 1336
  __cil_tmp39 = (unsigned long )wait_data;
#line 1336
  __cil_tmp40 = __cil_tmp39 + 4;
#line 1336
  __cil_tmp41 = *((u32 *)__cil_tmp40);
#line 1336
  __cil_tmp42 = msg + 2UL;
#line 1336
  __cil_tmp43 = *__cil_tmp42;
#line 1336
  __cil_tmp44 = __cil_tmp43 | __cil_tmp41;
#line 1336
  *__cil_tmp38 = __cil_tmp44 | 2147483648U;
#line 1337
  timeout = timeout * 250;
#line 1338
  status = adpt_i2o_post_this(pHba, msg, len);
  }
#line 1338
  if (status == 0) {
#line 1339
    __ret = (long volatile   )1L;
#line 1339
    if (8 == 1) {
#line 1339
      goto case_1;
    } else
#line 1339
    if (8 == 2) {
#line 1339
      goto case_2;
    } else
#line 1339
    if (8 == 4) {
#line 1339
      goto case_4;
    } else
#line 1339
    if (8 == 8) {
#line 1339
      goto case_8;
    } else {
      {
#line 1339
      goto switch_default;
#line 1339
      if (0) {
        case_1: /* CIL Label */ 
        {
#line 1339
        tmp___1 = get_current();
#line 1339
        __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (*((long volatile   *)tmp___1)): : "memory",
                             "cc");
        }
#line 1339
        goto ldv_32377;
        case_2: /* CIL Label */ 
        {
#line 1339
        tmp___2 = get_current();
#line 1339
        __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (*((long volatile   *)tmp___2)): : "memory",
                             "cc");
        }
#line 1339
        goto ldv_32377;
        case_4: /* CIL Label */ 
        {
#line 1339
        tmp___3 = get_current();
#line 1339
        __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (*((long volatile   *)tmp___3)): : "memory",
                             "cc");
        }
#line 1339
        goto ldv_32377;
        case_8: /* CIL Label */ 
        {
#line 1339
        tmp___4 = get_current();
#line 1339
        __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (*((long volatile   *)tmp___4)): : "memory",
                             "cc");
        }
#line 1339
        goto ldv_32377;
        switch_default: /* CIL Label */ 
        {
#line 1339
        __xchg_wrong_size();
        }
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
    ldv_32377: ;
    {
#line 1340
    __cil_tmp45 = (struct Scsi_Host *)0;
#line 1340
    __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 1340
    __cil_tmp47 = (unsigned long )pHba;
#line 1340
    __cil_tmp48 = __cil_tmp47 + 16;
#line 1340
    __cil_tmp49 = *((struct Scsi_Host **)__cil_tmp48);
#line 1340
    __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 1340
    if (__cil_tmp50 != __cil_tmp46) {
      {
#line 1341
      __cil_tmp51 = (unsigned long )pHba;
#line 1341
      __cil_tmp52 = __cil_tmp51 + 16;
#line 1341
      __cil_tmp53 = *((struct Scsi_Host **)__cil_tmp52);
#line 1341
      __cil_tmp54 = (unsigned long )__cil_tmp53;
#line 1341
      __cil_tmp55 = __cil_tmp54 + 216;
#line 1341
      __cil_tmp56 = *((spinlock_t **)__cil_tmp55);
#line 1341
      spin_unlock_irq(__cil_tmp56);
      }
    } else {

    }
    }
#line 1342
    if (timeout == 0) {
      {
#line 1343
      schedule();
      }
    } else {
      {
#line 1345
      __cil_tmp57 = (long )timeout;
#line 1345
      tmp___5 = schedule_timeout(__cil_tmp57);
#line 1345
      timeout = (int )tmp___5;
      }
#line 1346
      if (timeout == 0) {
#line 1350
        status = -62;
      } else {

      }
    }
    {
#line 1353
    __cil_tmp58 = (struct Scsi_Host *)0;
#line 1353
    __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 1353
    __cil_tmp60 = (unsigned long )pHba;
#line 1353
    __cil_tmp61 = __cil_tmp60 + 16;
#line 1353
    __cil_tmp62 = *((struct Scsi_Host **)__cil_tmp61);
#line 1353
    __cil_tmp63 = (unsigned long )__cil_tmp62;
#line 1353
    if (__cil_tmp63 != __cil_tmp59) {
      {
#line 1354
      __cil_tmp64 = (unsigned long )pHba;
#line 1354
      __cil_tmp65 = __cil_tmp64 + 16;
#line 1354
      __cil_tmp66 = *((struct Scsi_Host **)__cil_tmp65);
#line 1354
      __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 1354
      __cil_tmp68 = __cil_tmp67 + 216;
#line 1354
      __cil_tmp69 = *((spinlock_t **)__cil_tmp68);
#line 1354
      spin_lock_irq(__cil_tmp69);
      }
    } else {

    }
    }
  } else {

  }
  {
#line 1356
  remove_wait_queue(& adpt_wq_i2o_post, & wait);
  }
#line 1358
  if (status == -110) {
    {
#line 1359
    __cil_tmp70 = (unsigned long )pHba;
#line 1359
    __cil_tmp71 = __cil_tmp70 + 104;
#line 1359
    __cil_tmp72 = *((int *)__cil_tmp71);
#line 1359
    printk("<6>dpti%d: POST WAIT TIMEOUT\n", __cil_tmp72);
    }
#line 1361
    return (status);
  } else {

  }
  {
#line 1365
  p2 = (struct adpt_i2o_post_wait_data *)0;
#line 1366
  ldv_spin_lock();
#line 1367
  p1 = adpt_post_wait_queue;
  }
#line 1367
  goto ldv_32385;
  ldv_32384: ;
  {
#line 1368
  __cil_tmp73 = (unsigned long )wait_data;
#line 1368
  __cil_tmp74 = (unsigned long )p1;
#line 1368
  if (__cil_tmp74 == __cil_tmp73) {
    {
#line 1369
    __cil_tmp75 = *((int *)p1);
#line 1369
    if (__cil_tmp75 == 10) {
#line 1370
      status = -95;
    } else {

    }
    }
    {
#line 1372
    __cil_tmp76 = (struct adpt_i2o_post_wait_data *)0;
#line 1372
    __cil_tmp77 = (unsigned long )__cil_tmp76;
#line 1372
    __cil_tmp78 = (unsigned long )p2;
#line 1372
    if (__cil_tmp78 != __cil_tmp77) {
#line 1373
      __cil_tmp79 = (unsigned long )p2;
#line 1373
      __cil_tmp80 = __cil_tmp79 + 16;
#line 1373
      __cil_tmp81 = (unsigned long )p1;
#line 1373
      __cil_tmp82 = __cil_tmp81 + 16;
#line 1373
      *((struct adpt_i2o_post_wait_data **)__cil_tmp80) = *((struct adpt_i2o_post_wait_data **)__cil_tmp82);
    } else {
#line 1375
      __cil_tmp83 = (unsigned long )p1;
#line 1375
      __cil_tmp84 = __cil_tmp83 + 16;
#line 1375
      adpt_post_wait_queue = *((struct adpt_i2o_post_wait_data **)__cil_tmp84);
    }
    }
#line 1377
    goto ldv_32383;
  } else {

  }
  }
#line 1367
  p2 = p1;
#line 1367
  __cil_tmp85 = (unsigned long )p1;
#line 1367
  __cil_tmp86 = __cil_tmp85 + 16;
#line 1367
  p1 = *((struct adpt_i2o_post_wait_data **)__cil_tmp86);
  ldv_32385: ;
  {
#line 1367
  __cil_tmp87 = (struct adpt_i2o_post_wait_data *)0;
#line 1367
  __cil_tmp88 = (unsigned long )__cil_tmp87;
#line 1367
  __cil_tmp89 = (unsigned long )p1;
#line 1367
  if (__cil_tmp89 != __cil_tmp88) {
#line 1368
    goto ldv_32384;
  } else {
#line 1370
    goto ldv_32383;
  }
  }
  ldv_32383: 
  {
#line 1380
  spin_unlock_irqrestore(& adpt_post_wait_lock, flags);
#line 1382
  __cil_tmp90 = (void    *)wait_data;
#line 1382
  kfree(__cil_tmp90);
  }
#line 1384
  return (status);
}
}
#line 1388 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_post_this(adpt_hba *pHba , u32 *data , int len ) 
{ u32 m ;
  u32 *msg ;
  ulong timeout ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  void  volatile   *__cil_tmp15 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  u32 *__cil_tmp26 ;
  void volatile   *__cil_tmp27 ;
  void    *__cil_tmp28 ;
  size_t __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  void *__cil_tmp32 ;
  void volatile   *__cil_tmp33 ;

  {
#line 1391
  m = 4294967295U;
#line 1393
  __cil_tmp11 = (unsigned long )jiffies;
#line 1393
  timeout = __cil_tmp11 + 7500UL;
  ldv_32401: 
  {
#line 1395
  __asm__  volatile   ("lfence": : : "memory");
#line 1396
  __cil_tmp12 = (unsigned long )pHba;
#line 1396
  __cil_tmp13 = __cil_tmp12 + 232;
#line 1396
  __cil_tmp14 = *((void **)__cil_tmp13);
#line 1396
  __cil_tmp15 = (void  volatile   *)__cil_tmp14;
#line 1396
  m = readl(__cil_tmp15);
  }
#line 1397
  if (m != 4294967295U) {
#line 1398
    goto ldv_32394;
  } else {

  }
  {
#line 1400
  __cil_tmp16 = (long )jiffies;
#line 1400
  __cil_tmp17 = (long )timeout;
#line 1400
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 1400
  if (__cil_tmp18 < 0L) {
    {
#line 1401
    __cil_tmp19 = (unsigned long )pHba;
#line 1401
    __cil_tmp20 = __cil_tmp19 + 104;
#line 1401
    __cil_tmp21 = *((int *)__cil_tmp20);
#line 1401
    printk("<4>dpti%d: Timeout waiting for message frame!\n", __cil_tmp21);
    }
#line 1402
    return (-110);
  } else {

  }
  }
  {
#line 1404
  schedule_timeout_uninterruptible(1L);
  }
#line 1405
  if (m == 4294967295U) {
#line 1406
    goto ldv_32401;
  } else {
#line 1408
    goto ldv_32394;
  }
  ldv_32394: 
  {
#line 1407
  __cil_tmp22 = (unsigned long )m;
#line 1407
  __cil_tmp23 = (unsigned long )pHba;
#line 1407
  __cil_tmp24 = __cil_tmp23 + 216;
#line 1407
  __cil_tmp25 = *((void **)__cil_tmp24);
#line 1407
  __cil_tmp26 = (u32 *)__cil_tmp25;
#line 1407
  msg = __cil_tmp26 + __cil_tmp22;
#line 1408
  __cil_tmp27 = (void volatile   *)msg;
#line 1408
  __cil_tmp28 = (void    *)data;
#line 1408
  __cil_tmp29 = (size_t )len;
#line 1408
  memcpy_toio(__cil_tmp27, __cil_tmp28, __cil_tmp29);
#line 1409
  __asm__  volatile   ("sfence": : : "memory");
#line 1412
  __cil_tmp30 = (unsigned long )pHba;
#line 1412
  __cil_tmp31 = __cil_tmp30 + 232;
#line 1412
  __cil_tmp32 = *((void **)__cil_tmp31);
#line 1412
  __cil_tmp33 = (void volatile   *)__cil_tmp32;
#line 1412
  writel(m, __cil_tmp33);
#line 1413
  __asm__  volatile   ("sfence": : : "memory");
  }
#line 1415
  return (0);
}
}
#line 1419 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_i2o_post_wait_complete(u32 context , int status ) 
{ struct adpt_i2o_post_wait_data *p1 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  u32 __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  adpt_wait_queue_head_t *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct adpt_i2o_post_wait_data *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  u32 __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct adpt_i2o_post_wait_data *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;

  {
  {
#line 1421
  p1 = (struct adpt_i2o_post_wait_data *)0;
#line 1435
  context = context & 32767U;
#line 1437
  spin_lock(& adpt_post_wait_lock);
#line 1438
  p1 = adpt_post_wait_queue;
  }
#line 1438
  goto ldv_32408;
  ldv_32407: ;
  {
#line 1439
  __cil_tmp4 = (unsigned long )p1;
#line 1439
  __cil_tmp5 = __cil_tmp4 + 4;
#line 1439
  __cil_tmp6 = *((u32 *)__cil_tmp5);
#line 1439
  if (__cil_tmp6 == context) {
    {
#line 1440
    *((int *)p1) = status;
#line 1441
    spin_unlock(& adpt_post_wait_lock);
#line 1442
    __cil_tmp7 = (unsigned long )p1;
#line 1442
    __cil_tmp8 = __cil_tmp7 + 8;
#line 1442
    __cil_tmp9 = *((adpt_wait_queue_head_t **)__cil_tmp8);
#line 1442
    __cil_tmp10 = (void *)0;
#line 1442
    __wake_up(__cil_tmp9, 1U, 1, __cil_tmp10);
    }
#line 1443
    return;
  } else {

  }
  }
#line 1438
  __cil_tmp11 = (unsigned long )p1;
#line 1438
  __cil_tmp12 = __cil_tmp11 + 16;
#line 1438
  p1 = *((struct adpt_i2o_post_wait_data **)__cil_tmp12);
  ldv_32408: ;
  {
#line 1438
  __cil_tmp13 = (struct adpt_i2o_post_wait_data *)0;
#line 1438
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1438
  __cil_tmp15 = (unsigned long )p1;
#line 1438
  if (__cil_tmp15 != __cil_tmp14) {
#line 1439
    goto ldv_32407;
  } else {
#line 1441
    goto ldv_32409;
  }
  }
  ldv_32409: 
  {
#line 1446
  spin_unlock(& adpt_post_wait_lock);
#line 1448
  printk("<7>dpti: Could Not find task %d in wait queue\n", context);
#line 1449
  printk("<7>      Tasks in wait queue:\n");
#line 1450
  p1 = adpt_post_wait_queue;
  }
#line 1450
  goto ldv_32411;
  ldv_32410: 
  {
#line 1451
  __cil_tmp16 = (unsigned long )p1;
#line 1451
  __cil_tmp17 = __cil_tmp16 + 4;
#line 1451
  __cil_tmp18 = *((u32 *)__cil_tmp17);
#line 1451
  printk("<7>           %d\n", __cil_tmp18);
#line 1450
  __cil_tmp19 = (unsigned long )p1;
#line 1450
  __cil_tmp20 = __cil_tmp19 + 16;
#line 1450
  p1 = *((struct adpt_i2o_post_wait_data **)__cil_tmp20);
  }
  ldv_32411: ;
  {
#line 1450
  __cil_tmp21 = (struct adpt_i2o_post_wait_data *)0;
#line 1450
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 1450
  __cil_tmp23 = (unsigned long )p1;
#line 1450
  if (__cil_tmp23 != __cil_tmp22) {
#line 1451
    goto ldv_32410;
  } else {
#line 1453
    goto ldv_32412;
  }
  }
  ldv_32412: ;
#line 1453
  return;
}
}
#line 1456 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_reset_hba(adpt_hba *pHba ) 
{ u32 msg[8U] ;
  u8 *status ;
  dma_addr_t addr ;
  u32 m ;
  ulong timeout ;
  void *tmp ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  u8 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  void *__cil_tmp28 ;
  void  volatile   *__cil_tmp29 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  struct pci_dev *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct device *__cil_tmp38 ;
  struct dma_attrs *__cil_tmp39 ;
  u8 *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  void *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  dma_addr_t *__cil_tmp58 ;
  dma_addr_t __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  dma_addr_t *__cil_tmp62 ;
  dma_addr_t __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  void *__cil_tmp67 ;
  void volatile   *__cil_tmp68 ;
  void volatile   *__cil_tmp69 ;
  void    *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  void *__cil_tmp73 ;
  void volatile   *__cil_tmp74 ;
  long __cil_tmp75 ;
  long __cil_tmp76 ;
  long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  char (*__cil_tmp80)[32U] ;
  char *__cil_tmp81 ;
  u8 __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  u8 __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  void *__cil_tmp88 ;
  void  volatile   *__cil_tmp89 ;
  long __cil_tmp90 ;
  long __cil_tmp91 ;
  long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  char (*__cil_tmp95)[32U] ;
  char *__cil_tmp96 ;
  u8 __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  char (*__cil_tmp101)[32U] ;
  char *__cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  i2o_status_block *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  __u8 __cil_tmp108 ;
  unsigned int __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  char (*__cil_tmp112)[32U] ;
  char *__cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  struct pci_dev *__cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  struct device *__cil_tmp119 ;
  void *__cil_tmp120 ;
  dma_addr_t *__cil_tmp121 ;
  dma_addr_t __cil_tmp122 ;
  struct dma_attrs *__cil_tmp123 ;

  {
#line 1461
  m = 4294967295U;
#line 1462
  __cil_tmp20 = (unsigned long )jiffies;
#line 1462
  timeout = __cil_tmp20 + 90000UL;
  {
#line 1464
  __cil_tmp21 = (unsigned long )pHba;
#line 1464
  __cil_tmp22 = __cil_tmp21 + 112;
#line 1464
  __cil_tmp23 = *((u8 *)__cil_tmp22);
#line 1464
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 1464
  if (__cil_tmp24 == 0U) {
#line 1465
    __cil_tmp25 = (unsigned long )jiffies;
#line 1465
    timeout = __cil_tmp25 + 6250UL;
  } else {
    {
#line 1467
    adpt_i2o_quiesce_hba(pHba);
    }
  }
  }
  ldv_32428: 
  {
#line 1471
  __asm__  volatile   ("lfence": : : "memory");
#line 1472
  __cil_tmp26 = (unsigned long )pHba;
#line 1472
  __cil_tmp27 = __cil_tmp26 + 232;
#line 1472
  __cil_tmp28 = *((void **)__cil_tmp27);
#line 1472
  __cil_tmp29 = (void  volatile   *)__cil_tmp28;
#line 1472
  m = readl(__cil_tmp29);
  }
#line 1473
  if (m != 4294967295U) {
#line 1474
    goto ldv_32421;
  } else {

  }
  {
#line 1476
  __cil_tmp30 = (long )jiffies;
#line 1476
  __cil_tmp31 = (long )timeout;
#line 1476
  __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 1476
  if (__cil_tmp32 < 0L) {
    {
#line 1477
    printk("<4>Timeout waiting for message!\n");
    }
#line 1478
    return (-110);
  } else {

  }
  }
  {
#line 1480
  schedule_timeout_uninterruptible(1L);
  }
#line 1481
  if (m == 4294967295U) {
#line 1482
    goto ldv_32428;
  } else {
#line 1484
    goto ldv_32421;
  }
  ldv_32421: 
  {
#line 1483
  __cil_tmp33 = (unsigned long )pHba;
#line 1483
  __cil_tmp34 = __cil_tmp33 + 8;
#line 1483
  __cil_tmp35 = *((struct pci_dev **)__cil_tmp34);
#line 1483
  __cil_tmp36 = (unsigned long )__cil_tmp35;
#line 1483
  __cil_tmp37 = __cil_tmp36 + 144;
#line 1483
  __cil_tmp38 = (struct device *)__cil_tmp37;
#line 1483
  __cil_tmp39 = (struct dma_attrs *)0;
#line 1483
  tmp = dma_alloc_attrs(__cil_tmp38, 4UL, & addr, 208U, __cil_tmp39);
#line 1483
  status = (u8 *)tmp;
  }
  {
#line 1484
  __cil_tmp40 = (u8 *)0;
#line 1484
  __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 1484
  __cil_tmp42 = (unsigned long )status;
#line 1484
  if (__cil_tmp42 == __cil_tmp41) {
    {
#line 1485
    adpt_send_nop(pHba, m);
#line 1486
    printk("<3>IOP reset failed - no free memory.\n");
    }
#line 1487
    return (-12);
  } else {

  }
  }
  {
#line 1489
  __cil_tmp43 = (void *)status;
#line 1489
  memset(__cil_tmp43, 0, 4UL);
#line 1491
  __cil_tmp44 = 0 * 4UL;
#line 1491
  __cil_tmp45 = (unsigned long )(msg) + __cil_tmp44;
#line 1491
  *((u32 *)__cil_tmp45) = 524289U;
#line 1492
  __cil_tmp46 = 1 * 4UL;
#line 1492
  __cil_tmp47 = (unsigned long )(msg) + __cil_tmp46;
#line 1492
  *((u32 *)__cil_tmp47) = 3170897920U;
#line 1493
  __cil_tmp48 = 2 * 4UL;
#line 1493
  __cil_tmp49 = (unsigned long )(msg) + __cil_tmp48;
#line 1493
  *((u32 *)__cil_tmp49) = 0U;
#line 1494
  __cil_tmp50 = 3 * 4UL;
#line 1494
  __cil_tmp51 = (unsigned long )(msg) + __cil_tmp50;
#line 1494
  *((u32 *)__cil_tmp51) = 0U;
#line 1495
  __cil_tmp52 = 4 * 4UL;
#line 1495
  __cil_tmp53 = (unsigned long )(msg) + __cil_tmp52;
#line 1495
  *((u32 *)__cil_tmp53) = 0U;
#line 1496
  __cil_tmp54 = 5 * 4UL;
#line 1496
  __cil_tmp55 = (unsigned long )(msg) + __cil_tmp54;
#line 1496
  *((u32 *)__cil_tmp55) = 0U;
#line 1497
  __cil_tmp56 = 6 * 4UL;
#line 1497
  __cil_tmp57 = (unsigned long )(msg) + __cil_tmp56;
#line 1497
  __cil_tmp58 = & addr;
#line 1497
  __cil_tmp59 = *__cil_tmp58;
#line 1497
  *((u32 *)__cil_tmp57) = dma_low(__cil_tmp59);
#line 1498
  __cil_tmp60 = 7 * 4UL;
#line 1498
  __cil_tmp61 = (unsigned long )(msg) + __cil_tmp60;
#line 1498
  __cil_tmp62 = & addr;
#line 1498
  __cil_tmp63 = *__cil_tmp62;
#line 1498
  *((u32 *)__cil_tmp61) = dma_high(__cil_tmp63);
#line 1500
  __cil_tmp64 = (unsigned long )m;
#line 1500
  __cil_tmp65 = (unsigned long )pHba;
#line 1500
  __cil_tmp66 = __cil_tmp65 + 216;
#line 1500
  __cil_tmp67 = *((void **)__cil_tmp66);
#line 1500
  __cil_tmp68 = (void volatile   *)__cil_tmp67;
#line 1500
  __cil_tmp69 = __cil_tmp68 + __cil_tmp64;
#line 1500
  __cil_tmp70 = (void    *)(& msg);
#line 1500
  memcpy_toio(__cil_tmp69, __cil_tmp70, 32UL);
#line 1501
  __asm__  volatile   ("sfence": : : "memory");
#line 1502
  __cil_tmp71 = (unsigned long )pHba;
#line 1502
  __cil_tmp72 = __cil_tmp71 + 232;
#line 1502
  __cil_tmp73 = *((void **)__cil_tmp72);
#line 1502
  __cil_tmp74 = (void volatile   *)__cil_tmp73;
#line 1502
  writel(m, __cil_tmp74);
#line 1503
  __asm__  volatile   ("sfence": : : "memory");
  }
#line 1505
  goto ldv_32436;
  ldv_32435: ;
  {
#line 1506
  __cil_tmp75 = (long )jiffies;
#line 1506
  __cil_tmp76 = (long )timeout;
#line 1506
  __cil_tmp77 = __cil_tmp76 - __cil_tmp75;
#line 1506
  if (__cil_tmp77 < 0L) {
    {
#line 1507
    __cil_tmp78 = (unsigned long )pHba;
#line 1507
    __cil_tmp79 = __cil_tmp78 + 114;
#line 1507
    __cil_tmp80 = (char (*)[32U])__cil_tmp79;
#line 1507
    __cil_tmp81 = (char *)__cil_tmp80;
#line 1507
    printk("<4>%s: IOP Reset Timeout\n", __cil_tmp81);
    }
#line 1512
    return (-110);
  } else {

  }
  }
  {
#line 1514
  __asm__  volatile   ("lfence": : : "memory");
#line 1515
  schedule_timeout_uninterruptible(1L);
  }
  ldv_32436: ;
  {
#line 1505
  __cil_tmp82 = *status;
#line 1505
  __cil_tmp83 = (unsigned int )__cil_tmp82;
#line 1505
  if (__cil_tmp83 == 0U) {
#line 1506
    goto ldv_32435;
  } else {
#line 1508
    goto ldv_32437;
  }
  }
  ldv_32437: ;
  {
#line 1518
  __cil_tmp84 = *status;
#line 1518
  __cil_tmp85 = (unsigned int )__cil_tmp84;
#line 1518
  if (__cil_tmp85 == 1U) {
    ldv_32445: 
    {
#line 1523
    __asm__  volatile   ("lfence": : : "memory");
#line 1524
    __cil_tmp86 = (unsigned long )pHba;
#line 1524
    __cil_tmp87 = __cil_tmp86 + 232;
#line 1524
    __cil_tmp88 = *((void **)__cil_tmp87);
#line 1524
    __cil_tmp89 = (void  volatile   *)__cil_tmp88;
#line 1524
    m = readl(__cil_tmp89);
    }
#line 1525
    if (m != 4294967295U) {
#line 1526
      goto ldv_32438;
    } else {

    }
    {
#line 1528
    __cil_tmp90 = (long )jiffies;
#line 1528
    __cil_tmp91 = (long )timeout;
#line 1528
    __cil_tmp92 = __cil_tmp91 - __cil_tmp90;
#line 1528
    if (__cil_tmp92 < 0L) {
      {
#line 1529
      __cil_tmp93 = (unsigned long )pHba;
#line 1529
      __cil_tmp94 = __cil_tmp93 + 114;
#line 1529
      __cil_tmp95 = (char (*)[32U])__cil_tmp94;
#line 1529
      __cil_tmp96 = (char *)__cil_tmp95;
#line 1529
      printk("<3>%s:Timeout waiting for IOP Reset.\n", __cil_tmp96);
      }
#line 1534
      return (-110);
    } else {

    }
    }
    {
#line 1536
    schedule_timeout_uninterruptible(1L);
    }
#line 1537
    if (m == 4294967295U) {
#line 1538
      goto ldv_32445;
    } else {
#line 1540
      goto ldv_32438;
    }
    ldv_32438: 
    {
#line 1539
    adpt_send_nop(pHba, m);
    }
  } else {

  }
  }
  {
#line 1541
  adpt_i2o_status_get(pHba);
  }
  {
#line 1542
  __cil_tmp97 = *status;
#line 1542
  __cil_tmp98 = (unsigned int )__cil_tmp97;
#line 1542
  if (__cil_tmp98 == 2U) {
    {
#line 1544
    __cil_tmp99 = (unsigned long )pHba;
#line 1544
    __cil_tmp100 = __cil_tmp99 + 114;
#line 1544
    __cil_tmp101 = (char (*)[32U])__cil_tmp100;
#line 1544
    __cil_tmp102 = (char *)__cil_tmp101;
#line 1544
    printk("<4>%s: Reset reject, trying to clear\n", __cil_tmp102);
    }
  } else {
    {
#line 1542
    __cil_tmp103 = (unsigned long )pHba;
#line 1542
    __cil_tmp104 = __cil_tmp103 + 296;
#line 1542
    __cil_tmp105 = *((i2o_status_block **)__cil_tmp104);
#line 1542
    __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 1542
    __cil_tmp107 = __cil_tmp106 + 10;
#line 1542
    __cil_tmp108 = *((__u8 *)__cil_tmp107);
#line 1542
    __cil_tmp109 = (unsigned int )__cil_tmp108;
#line 1542
    if (__cil_tmp109 != 2U) {
      {
#line 1544
      __cil_tmp110 = (unsigned long )pHba;
#line 1544
      __cil_tmp111 = __cil_tmp110 + 114;
#line 1544
      __cil_tmp112 = (char (*)[32U])__cil_tmp111;
#line 1544
      __cil_tmp113 = (char *)__cil_tmp112;
#line 1544
      printk("<4>%s: Reset reject, trying to clear\n", __cil_tmp113);
      }
    } else {

    }
    }
  }
  }
  {
#line 1550
  __cil_tmp114 = (unsigned long )pHba;
#line 1550
  __cil_tmp115 = __cil_tmp114 + 8;
#line 1550
  __cil_tmp116 = *((struct pci_dev **)__cil_tmp115);
#line 1550
  __cil_tmp117 = (unsigned long )__cil_tmp116;
#line 1550
  __cil_tmp118 = __cil_tmp117 + 144;
#line 1550
  __cil_tmp119 = (struct device *)__cil_tmp118;
#line 1550
  __cil_tmp120 = (void *)status;
#line 1550
  __cil_tmp121 = & addr;
#line 1550
  __cil_tmp122 = *__cil_tmp121;
#line 1550
  __cil_tmp123 = (struct dma_attrs *)0;
#line 1550
  dma_free_attrs(__cil_tmp119, 4UL, __cil_tmp120, __cil_tmp122, __cil_tmp123);
  }
#line 1556
  return (0);
}
}
#line 1560 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_parse_lct(adpt_hba *pHba ) 
{ int i ;
  int max ;
  int tid ;
  struct i2o_device *d ;
  i2o_lct *lct ;
  u8 bus_no ;
  s16 scsi_id ;
  s16 scsi_lun ;
  u32 buf[10U] ;
  struct adpt_device *pDev ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  i2o_lct *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  char (*__cil_tmp27)[32U] ;
  char *__cil_tmp28 ;
  unsigned short __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned short __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned short __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned short __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned short __cil_tmp63 ;
  void *__cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  u32 __cil_tmp67 ;
  u32 __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  u32 __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  u32 __cil_tmp74 ;
  u32 __cil_tmp75 ;
  s16 __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  char (*__cil_tmp82)[32U] ;
  char *__cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  char (*__cil_tmp88)[32U] ;
  char *__cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  u8 __cil_tmp94 ;
  int __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  u8 __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  u8 __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  struct i2o_device *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  char (*__cil_tmp117)[32U] ;
  char *__cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  i2o_lct_entry *__cil_tmp123 ;
  void *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  i2o_lct_entry (*__cil_tmp128)[1U] ;
  void    *__cil_tmp129 ;
  void    *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  i2o_lct_entry *__cil_tmp133 ;
  void *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  i2o_lct_entry (*__cil_tmp138)[1U] ;
  void    *__cil_tmp139 ;
  void    *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned short __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned short *__cil_tmp149 ;
  unsigned short *__cil_tmp150 ;
  unsigned short __cil_tmp151 ;
  unsigned int __cil_tmp152 ;
  unsigned short *__cil_tmp153 ;
  unsigned short *__cil_tmp154 ;
  unsigned short __cil_tmp155 ;
  unsigned int __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  unsigned short __cil_tmp160 ;
  int __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  u8 __cil_tmp164 ;
  int __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  int __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned short __cil_tmp177 ;
  int __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  void *__cil_tmp184 ;
  int __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  u32 __cil_tmp193 ;
  int __cil_tmp194 ;
  int __cil_tmp195 ;
  unsigned int __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  char (*__cil_tmp199)[32U] ;
  char *__cil_tmp200 ;
  int __cil_tmp201 ;
  struct i2o_device *__cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned short *__cil_tmp207 ;
  unsigned short *__cil_tmp208 ;
  unsigned short __cil_tmp209 ;
  unsigned int __cil_tmp210 ;
  unsigned short *__cil_tmp211 ;
  unsigned short *__cil_tmp212 ;
  unsigned short __cil_tmp213 ;
  unsigned int __cil_tmp214 ;
  unsigned short *__cil_tmp215 ;
  unsigned short *__cil_tmp216 ;
  unsigned short __cil_tmp217 ;
  unsigned int __cil_tmp218 ;
  unsigned long __cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  unsigned long __cil_tmp221 ;
  unsigned short __cil_tmp222 ;
  void *__cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  u32 __cil_tmp226 ;
  u32 __cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  u32 __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  u32 __cil_tmp233 ;
  u32 __cil_tmp234 ;
  s16 __cil_tmp235 ;
  int __cil_tmp236 ;
  int __cil_tmp237 ;
  unsigned int __cil_tmp238 ;
  int __cil_tmp239 ;
  struct adpt_device *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  int __cil_tmp242 ;
  unsigned long __cil_tmp243 ;
  unsigned long __cil_tmp244 ;
  int __cil_tmp245 ;
  unsigned long __cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  unsigned long __cil_tmp250 ;
  struct adpt_device *__cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  struct adpt_device *__cil_tmp253 ;
  unsigned long __cil_tmp254 ;
  unsigned long __cil_tmp255 ;
  int __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  int __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned long __cil_tmp261 ;
  unsigned long __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  int __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  unsigned long __cil_tmp267 ;
  int __cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  unsigned long __cil_tmp272 ;
  unsigned long __cil_tmp273 ;
  struct adpt_device *__cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  struct adpt_device *__cil_tmp276 ;
  unsigned long __cil_tmp277 ;
  struct adpt_device *__cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  struct adpt_device *__cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  unsigned long __cil_tmp282 ;
  unsigned long __cil_tmp283 ;
  unsigned long __cil_tmp284 ;
  unsigned long __cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  unsigned long __cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  unsigned long __cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  unsigned long __cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  u32 __cil_tmp298 ;
  unsigned long __cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  u32 __cil_tmp303 ;
  u32 __cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  unsigned long __cil_tmp306 ;
  u8 __cil_tmp307 ;
  int __cil_tmp308 ;
  int __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  unsigned long __cil_tmp311 ;
  unsigned long __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  u8 __cil_tmp314 ;
  int __cil_tmp315 ;
  int __cil_tmp316 ;
  unsigned long __cil_tmp317 ;
  unsigned long __cil_tmp318 ;
  int __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  unsigned long __cil_tmp321 ;
  unsigned long __cil_tmp322 ;
  __u8 (*__cil_tmp323)[8U] ;
  __u8 *__cil_tmp324 ;
  struct i2o_device *__cil_tmp325 ;
  unsigned long __cil_tmp326 ;
  unsigned long __cil_tmp327 ;

  {
#line 1566
  __cil_tmp20 = (unsigned long )pHba;
#line 1566
  __cil_tmp21 = __cil_tmp20 + 328;
#line 1566
  lct = *((i2o_lct **)__cil_tmp21);
#line 1567
  bus_no = (u8 )0U;
  {
#line 1573
  __cil_tmp22 = (i2o_lct *)0;
#line 1573
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 1573
  __cil_tmp24 = (unsigned long )lct;
#line 1573
  if (__cil_tmp24 == __cil_tmp23) {
    {
#line 1574
    __cil_tmp25 = (unsigned long )pHba;
#line 1574
    __cil_tmp26 = __cil_tmp25 + 114;
#line 1574
    __cil_tmp27 = (char (*)[32U])__cil_tmp26;
#line 1574
    __cil_tmp28 = (char *)__cil_tmp27;
#line 1574
    printk("<3>%s: LCT is empty???\n", __cil_tmp28);
    }
#line 1575
    return (-1);
  } else {

  }
  }
#line 1578
  __cil_tmp29 = *((unsigned short *)lct);
#line 1578
  max = (int )__cil_tmp29;
#line 1579
  max = max + -3;
#line 1580
  max = max / 9;
#line 1582
  i = 0;
#line 1582
  goto ldv_32464;
  ldv_32463: ;
  {
#line 1583
  __cil_tmp30 = i * 40UL;
#line 1583
  __cil_tmp31 = __cil_tmp30 + 20;
#line 1583
  __cil_tmp32 = 12 + __cil_tmp31;
#line 1583
  __cil_tmp33 = (unsigned long )lct;
#line 1583
  __cil_tmp34 = __cil_tmp33 + __cil_tmp32;
#line 1583
  __cil_tmp35 = *((unsigned short *)__cil_tmp34);
#line 1583
  __cil_tmp36 = (unsigned int )__cil_tmp35;
#line 1583
  if (__cil_tmp36 != 4095U) {
    {
#line 1591
    __cil_tmp37 = i * 40UL;
#line 1591
    __cil_tmp38 = __cil_tmp37 + 12;
#line 1591
    __cil_tmp39 = 12 + __cil_tmp38;
#line 1591
    __cil_tmp40 = (unsigned long )lct;
#line 1591
    __cil_tmp41 = __cil_tmp40 + __cil_tmp39;
#line 1591
    __cil_tmp42 = *((unsigned short *)__cil_tmp41);
#line 1591
    __cil_tmp43 = (unsigned int )__cil_tmp42;
#line 1591
    if (__cil_tmp43 != 16U) {
      {
#line 1591
      __cil_tmp44 = i * 40UL;
#line 1591
      __cil_tmp45 = __cil_tmp44 + 12;
#line 1591
      __cil_tmp46 = 12 + __cil_tmp45;
#line 1591
      __cil_tmp47 = (unsigned long )lct;
#line 1591
      __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 1591
      __cil_tmp49 = *((unsigned short *)__cil_tmp48);
#line 1591
      __cil_tmp50 = (unsigned int )__cil_tmp49;
#line 1591
      if (__cil_tmp50 != 81U) {
        {
#line 1591
        __cil_tmp51 = i * 40UL;
#line 1591
        __cil_tmp52 = __cil_tmp51 + 12;
#line 1591
        __cil_tmp53 = 12 + __cil_tmp52;
#line 1591
        __cil_tmp54 = (unsigned long )lct;
#line 1591
        __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
#line 1591
        __cil_tmp56 = *((unsigned short *)__cil_tmp55);
#line 1591
        __cil_tmp57 = (unsigned int )__cil_tmp56;
#line 1591
        if (__cil_tmp57 != 65U) {
#line 1594
          goto ldv_32459;
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
    }
    {
#line 1596
    __cil_tmp58 = i * 40UL;
#line 1596
    __cil_tmp59 = __cil_tmp58 + 2;
#line 1596
    __cil_tmp60 = 12 + __cil_tmp59;
#line 1596
    __cil_tmp61 = (unsigned long )lct;
#line 1596
    __cil_tmp62 = __cil_tmp61 + __cil_tmp60;
#line 1596
    __cil_tmp63 = *((unsigned short *)__cil_tmp62);
#line 1596
    tid = (int )__cil_tmp63;
#line 1598
    __cil_tmp64 = (void *)(& buf);
#line 1598
    tmp = adpt_i2o_query_scalar(pHba, tid, 32768, -1, __cil_tmp64, 32);
    }
#line 1598
    if (tmp < 0) {
#line 1599
      goto ldv_32459;
    } else {

    }
#line 1601
    __cil_tmp65 = 0 * 4UL;
#line 1601
    __cil_tmp66 = (unsigned long )(buf) + __cil_tmp65;
#line 1601
    __cil_tmp67 = *((u32 *)__cil_tmp66);
#line 1601
    __cil_tmp68 = __cil_tmp67 >> 16;
#line 1601
    bus_no = (u8 )__cil_tmp68;
#line 1602
    __cil_tmp69 = 1 * 4UL;
#line 1602
    __cil_tmp70 = (unsigned long )(buf) + __cil_tmp69;
#line 1602
    __cil_tmp71 = *((u32 *)__cil_tmp70);
#line 1602
    scsi_id = (s16 )__cil_tmp71;
#line 1603
    __cil_tmp72 = 2 * 4UL;
#line 1603
    __cil_tmp73 = (unsigned long )(buf) + __cil_tmp72;
#line 1603
    __cil_tmp74 = *((u32 *)__cil_tmp73);
#line 1603
    __cil_tmp75 = __cil_tmp74 >> 8;
#line 1603
    __cil_tmp76 = (s16 )__cil_tmp75;
#line 1603
    __cil_tmp77 = (int )__cil_tmp76;
#line 1603
    __cil_tmp78 = __cil_tmp77 & 255;
#line 1603
    scsi_lun = (s16 )__cil_tmp78;
    {
#line 1604
    __cil_tmp79 = (unsigned int )bus_no;
#line 1604
    if (__cil_tmp79 > 4U) {
      {
#line 1605
      __cil_tmp80 = (unsigned long )pHba;
#line 1605
      __cil_tmp81 = __cil_tmp80 + 114;
#line 1605
      __cil_tmp82 = (char (*)[32U])__cil_tmp81;
#line 1605
      __cil_tmp83 = (char *)__cil_tmp82;
#line 1605
      __cil_tmp84 = (int )bus_no;
#line 1605
      printk("<4>%s: Channel number %d out of range \n", __cil_tmp83, __cil_tmp84);
      }
#line 1606
      goto ldv_32459;
    } else {

    }
    }
    {
#line 1608
    __cil_tmp85 = (int )scsi_id;
#line 1608
    if (__cil_tmp85 > 127) {
      {
#line 1609
      __cil_tmp86 = (unsigned long )pHba;
#line 1609
      __cil_tmp87 = __cil_tmp86 + 114;
#line 1609
      __cil_tmp88 = (char (*)[32U])__cil_tmp87;
#line 1609
      __cil_tmp89 = (char *)__cil_tmp88;
#line 1609
      __cil_tmp90 = (int )bus_no;
#line 1609
      printk("<4>%s: SCSI ID %d out of range \n", __cil_tmp89, __cil_tmp90);
      }
#line 1610
      goto ldv_32459;
    } else {

    }
    }
    {
#line 1612
    __cil_tmp91 = (int )bus_no;
#line 1612
    __cil_tmp92 = (unsigned long )pHba;
#line 1612
    __cil_tmp93 = __cil_tmp92 + 292;
#line 1612
    __cil_tmp94 = *((u8 *)__cil_tmp93);
#line 1612
    __cil_tmp95 = (int )__cil_tmp94;
#line 1612
    if (__cil_tmp95 < __cil_tmp91) {
#line 1613
      __cil_tmp96 = (unsigned long )pHba;
#line 1613
      __cil_tmp97 = __cil_tmp96 + 292;
#line 1613
      *((u8 *)__cil_tmp97) = bus_no;
    } else {

    }
    }
    {
#line 1615
    __cil_tmp98 = (unsigned long )pHba;
#line 1615
    __cil_tmp99 = __cil_tmp98 + 293;
#line 1615
    __cil_tmp100 = *((u8 *)__cil_tmp99);
#line 1615
    __cil_tmp101 = (int )__cil_tmp100;
#line 1615
    __cil_tmp102 = (int )scsi_id;
#line 1615
    if (__cil_tmp102 > __cil_tmp101) {
#line 1616
      __cil_tmp103 = (unsigned long )pHba;
#line 1616
      __cil_tmp104 = __cil_tmp103 + 293;
#line 1616
      *((u8 *)__cil_tmp104) = (u8 )scsi_id;
    } else {

    }
    }
    {
#line 1618
    __cil_tmp105 = (unsigned long )pHba;
#line 1618
    __cil_tmp106 = __cil_tmp105 + 294;
#line 1618
    __cil_tmp107 = *((u8 *)__cil_tmp106);
#line 1618
    __cil_tmp108 = (int )__cil_tmp107;
#line 1618
    __cil_tmp109 = (int )scsi_lun;
#line 1618
    if (__cil_tmp109 > __cil_tmp108) {
#line 1619
      __cil_tmp110 = (unsigned long )pHba;
#line 1619
      __cil_tmp111 = __cil_tmp110 + 294;
#line 1619
      *((u8 *)__cil_tmp111) = (u8 )scsi_lun;
    } else {

    }
    }
#line 1621
    goto ldv_32459;
  } else {

  }
  }
  {
#line 1623
  tmp___0 = kmalloc(88UL, 208U);
#line 1623
  d = (struct i2o_device *)tmp___0;
  }
  {
#line 1624
  __cil_tmp112 = (struct i2o_device *)0;
#line 1624
  __cil_tmp113 = (unsigned long )__cil_tmp112;
#line 1624
  __cil_tmp114 = (unsigned long )d;
#line 1624
  if (__cil_tmp114 == __cil_tmp113) {
    {
#line 1626
    __cil_tmp115 = (unsigned long )pHba;
#line 1626
    __cil_tmp116 = __cil_tmp115 + 114;
#line 1626
    __cil_tmp117 = (char (*)[32U])__cil_tmp116;
#line 1626
    __cil_tmp118 = (char *)__cil_tmp117;
#line 1626
    printk("<2>%s: Out of memory for I2O device data.\n", __cil_tmp118);
    }
#line 1627
    return (-12);
  } else {

  }
  }
#line 1630
  __cil_tmp119 = (unsigned long )d;
#line 1630
  __cil_tmp120 = __cil_tmp119 + 88;
#line 1630
  *((struct _adpt_hba **)__cil_tmp120) = pHba;
#line 1631
  *((struct i2o_device **)d) = (struct i2o_device *)0;
#line 1633
  __len = 36UL;
#line 1633
  if (__len > 63UL) {
    {
#line 1633
    __cil_tmp121 = (unsigned long )d;
#line 1633
    __cil_tmp122 = __cil_tmp121 + 24;
#line 1633
    __cil_tmp123 = (i2o_lct_entry *)__cil_tmp122;
#line 1633
    __cil_tmp124 = (void *)__cil_tmp123;
#line 1633
    __cil_tmp125 = (unsigned long )i;
#line 1633
    __cil_tmp126 = (unsigned long )lct;
#line 1633
    __cil_tmp127 = __cil_tmp126 + 12;
#line 1633
    __cil_tmp128 = (i2o_lct_entry (*)[1U])__cil_tmp127;
#line 1633
    __cil_tmp129 = (void    *)__cil_tmp128;
#line 1633
    __cil_tmp130 = __cil_tmp129 + __cil_tmp125;
#line 1633
    __ret = __memcpy(__cil_tmp124, __cil_tmp130, __len);
    }
  } else {
    {
#line 1633
    __cil_tmp131 = (unsigned long )d;
#line 1633
    __cil_tmp132 = __cil_tmp131 + 24;
#line 1633
    __cil_tmp133 = (i2o_lct_entry *)__cil_tmp132;
#line 1633
    __cil_tmp134 = (void *)__cil_tmp133;
#line 1633
    __cil_tmp135 = (unsigned long )i;
#line 1633
    __cil_tmp136 = (unsigned long )lct;
#line 1633
    __cil_tmp137 = __cil_tmp136 + 12;
#line 1633
    __cil_tmp138 = (i2o_lct_entry (*)[1U])__cil_tmp137;
#line 1633
    __cil_tmp139 = (void    *)__cil_tmp138;
#line 1633
    __cil_tmp140 = __cil_tmp139 + __cil_tmp135;
#line 1633
    __ret = __builtin_memcpy(__cil_tmp134, __cil_tmp140, __len);
    }
  }
  {
#line 1635
  __cil_tmp141 = (unsigned long )d;
#line 1635
  __cil_tmp142 = __cil_tmp141 + 64;
#line 1635
  *((u32 *)__cil_tmp142) = 0U;
#line 1636
  __cil_tmp143 = 24 + 2;
#line 1636
  __cil_tmp144 = (unsigned long )d;
#line 1636
  __cil_tmp145 = __cil_tmp144 + __cil_tmp143;
#line 1636
  __cil_tmp146 = *((unsigned short *)__cil_tmp145);
#line 1636
  tid = (int )__cil_tmp146;
#line 1637
  adpt_i2o_report_hba_unit(pHba, d);
#line 1638
  adpt_i2o_install_device(pHba, d);
  }
  ldv_32459: 
#line 1582
  i = i + 1;
  ldv_32464: ;
#line 1582
  if (i < max) {
#line 1583
    goto ldv_32463;
  } else {
#line 1585
    goto ldv_32465;
  }
  ldv_32465: 
#line 1640
  bus_no = (u8 )0U;
#line 1641
  __cil_tmp147 = (unsigned long )pHba;
#line 1641
  __cil_tmp148 = __cil_tmp147 + 352;
#line 1641
  d = *((struct i2o_device **)__cil_tmp148);
#line 1641
  goto ldv_32468;
  ldv_32467: ;
  {
#line 1642
  __cil_tmp149 = (unsigned short *)d;
#line 1642
  __cil_tmp150 = __cil_tmp149 + 18UL;
#line 1642
  __cil_tmp151 = *__cil_tmp150;
#line 1642
  __cil_tmp152 = (unsigned int )__cil_tmp151;
#line 1642
  if (__cil_tmp152 == 128U) {
#line 1642
    goto _L;
  } else {
    {
#line 1642
    __cil_tmp153 = (unsigned short *)d;
#line 1642
    __cil_tmp154 = __cil_tmp153 + 18UL;
#line 1642
    __cil_tmp155 = *__cil_tmp154;
#line 1642
    __cil_tmp156 = (unsigned int )__cil_tmp155;
#line 1642
    if (__cil_tmp156 == 64U) {
      _L: /* CIL Label */ 
#line 1644
      __cil_tmp157 = 24 + 2;
#line 1644
      __cil_tmp158 = (unsigned long )d;
#line 1644
      __cil_tmp159 = __cil_tmp158 + __cil_tmp157;
#line 1644
      __cil_tmp160 = *((unsigned short *)__cil_tmp159);
#line 1644
      tid = (int )__cil_tmp160;
      {
#line 1647
      __cil_tmp161 = (int )bus_no;
#line 1647
      __cil_tmp162 = (unsigned long )pHba;
#line 1647
      __cil_tmp163 = __cil_tmp162 + 292;
#line 1647
      __cil_tmp164 = *((u8 *)__cil_tmp163);
#line 1647
      __cil_tmp165 = (int )__cil_tmp164;
#line 1647
      if (__cil_tmp165 < __cil_tmp161) {
#line 1648
        __cil_tmp166 = (unsigned long )pHba;
#line 1648
        __cil_tmp167 = __cil_tmp166 + 292;
#line 1648
        *((u8 *)__cil_tmp167) = bus_no;
      } else {

      }
      }
      {
#line 1650
      __cil_tmp168 = (int )bus_no;
#line 1650
      __cil_tmp169 = __cil_tmp168 * 1040UL;
#line 1650
      __cil_tmp170 = __cil_tmp169 + 1025;
#line 1650
      __cil_tmp171 = 360 + __cil_tmp170;
#line 1650
      __cil_tmp172 = (unsigned long )pHba;
#line 1650
      __cil_tmp173 = __cil_tmp172 + __cil_tmp171;
#line 1650
      __cil_tmp174 = 24 + 12;
#line 1650
      __cil_tmp175 = (unsigned long )d;
#line 1650
      __cil_tmp176 = __cil_tmp175 + __cil_tmp174;
#line 1650
      __cil_tmp177 = *((unsigned short *)__cil_tmp176);
#line 1650
      *((u8 *)__cil_tmp173) = (u8 )__cil_tmp177;
#line 1651
      __cil_tmp178 = (int )bus_no;
#line 1651
      __cil_tmp179 = __cil_tmp178 * 1040UL;
#line 1651
      __cil_tmp180 = __cil_tmp179 + 1026;
#line 1651
      __cil_tmp181 = 360 + __cil_tmp180;
#line 1651
      __cil_tmp182 = (unsigned long )pHba;
#line 1651
      __cil_tmp183 = __cil_tmp182 + __cil_tmp181;
#line 1651
      *((u16 *)__cil_tmp183) = (u16 )tid;
#line 1652
      __cil_tmp184 = (void *)(& buf);
#line 1652
      tmp___1 = adpt_i2o_query_scalar(pHba, tid, 512, -1, __cil_tmp184, 28);
      }
#line 1652
      if (tmp___1 >= 0) {
#line 1654
        __cil_tmp185 = (int )bus_no;
#line 1654
        __cil_tmp186 = __cil_tmp185 * 1040UL;
#line 1654
        __cil_tmp187 = __cil_tmp186 + 1024;
#line 1654
        __cil_tmp188 = 360 + __cil_tmp187;
#line 1654
        __cil_tmp189 = (unsigned long )pHba;
#line 1654
        __cil_tmp190 = __cil_tmp189 + __cil_tmp188;
#line 1654
        __cil_tmp191 = 1 * 4UL;
#line 1654
        __cil_tmp192 = (unsigned long )(buf) + __cil_tmp191;
#line 1654
        __cil_tmp193 = *((u32 *)__cil_tmp192);
#line 1654
        *((u8 *)__cil_tmp190) = (u8 )__cil_tmp193;
      } else {

      }
#line 1658
      __cil_tmp194 = (int )bus_no;
#line 1658
      __cil_tmp195 = __cil_tmp194 + 1;
#line 1658
      bus_no = (u8 )__cil_tmp195;
      {
#line 1659
      __cil_tmp196 = (unsigned int )bus_no;
#line 1659
      if (__cil_tmp196 > 4U) {
        {
#line 1660
        __cil_tmp197 = (unsigned long )pHba;
#line 1660
        __cil_tmp198 = __cil_tmp197 + 114;
#line 1660
        __cil_tmp199 = (char (*)[32U])__cil_tmp198;
#line 1660
        __cil_tmp200 = (char *)__cil_tmp199;
#line 1660
        __cil_tmp201 = (int )bus_no;
#line 1660
        printk("<4>%s: Channel number %d out of range - LCT\n", __cil_tmp200, __cil_tmp201);
        }
#line 1661
        goto ldv_32466;
      } else {

      }
      }
    } else {

    }
    }
  }
  }
#line 1641
  d = *((struct i2o_device **)d);
  ldv_32468: ;
  {
#line 1641
  __cil_tmp202 = (struct i2o_device *)0;
#line 1641
  __cil_tmp203 = (unsigned long )__cil_tmp202;
#line 1641
  __cil_tmp204 = (unsigned long )d;
#line 1641
  if (__cil_tmp204 != __cil_tmp203) {
#line 1642
    goto ldv_32467;
  } else {
#line 1644
    goto ldv_32466;
  }
  }
  ldv_32466: 
#line 1667
  __cil_tmp205 = (unsigned long )pHba;
#line 1667
  __cil_tmp206 = __cil_tmp205 + 352;
#line 1667
  d = *((struct i2o_device **)__cil_tmp206);
#line 1667
  goto ldv_32474;
  ldv_32473: ;
  {
#line 1668
  __cil_tmp207 = (unsigned short *)d;
#line 1668
  __cil_tmp208 = __cil_tmp207 + 18UL;
#line 1668
  __cil_tmp209 = *__cil_tmp208;
#line 1668
  __cil_tmp210 = (unsigned int )__cil_tmp209;
#line 1668
  if (__cil_tmp210 == 16U) {
#line 1668
    goto _L___0;
  } else {
    {
#line 1668
    __cil_tmp211 = (unsigned short *)d;
#line 1668
    __cil_tmp212 = __cil_tmp211 + 18UL;
#line 1668
    __cil_tmp213 = *__cil_tmp212;
#line 1668
    __cil_tmp214 = (unsigned int )__cil_tmp213;
#line 1668
    if (__cil_tmp214 == 81U) {
#line 1668
      goto _L___0;
    } else {
      {
#line 1668
      __cil_tmp215 = (unsigned short *)d;
#line 1668
      __cil_tmp216 = __cil_tmp215 + 18UL;
#line 1668
      __cil_tmp217 = *__cil_tmp216;
#line 1668
      __cil_tmp218 = (unsigned int )__cil_tmp217;
#line 1668
      if (__cil_tmp218 == 65U) {
        _L___0: /* CIL Label */ 
        {
#line 1672
        __cil_tmp219 = 24 + 2;
#line 1672
        __cil_tmp220 = (unsigned long )d;
#line 1672
        __cil_tmp221 = __cil_tmp220 + __cil_tmp219;
#line 1672
        __cil_tmp222 = *((unsigned short *)__cil_tmp221);
#line 1672
        tid = (int )__cil_tmp222;
#line 1673
        scsi_id = (s16 )-1;
#line 1675
        __cil_tmp223 = (void *)(& buf);
#line 1675
        tmp___4 = adpt_i2o_query_scalar(pHba, tid, 32768, -1, __cil_tmp223, 32);
        }
#line 1675
        if (tmp___4 >= 0) {
#line 1676
          __cil_tmp224 = 0 * 4UL;
#line 1676
          __cil_tmp225 = (unsigned long )(buf) + __cil_tmp224;
#line 1676
          __cil_tmp226 = *((u32 *)__cil_tmp225);
#line 1676
          __cil_tmp227 = __cil_tmp226 >> 16;
#line 1676
          bus_no = (u8 )__cil_tmp227;
#line 1677
          __cil_tmp228 = 1 * 4UL;
#line 1677
          __cil_tmp229 = (unsigned long )(buf) + __cil_tmp228;
#line 1677
          __cil_tmp230 = *((u32 *)__cil_tmp229);
#line 1677
          scsi_id = (s16 )__cil_tmp230;
#line 1678
          __cil_tmp231 = 2 * 4UL;
#line 1678
          __cil_tmp232 = (unsigned long )(buf) + __cil_tmp231;
#line 1678
          __cil_tmp233 = *((u32 *)__cil_tmp232);
#line 1678
          __cil_tmp234 = __cil_tmp233 >> 8;
#line 1678
          __cil_tmp235 = (s16 )__cil_tmp234;
#line 1678
          __cil_tmp236 = (int )__cil_tmp235;
#line 1678
          __cil_tmp237 = __cil_tmp236 & 255;
#line 1678
          scsi_lun = (s16 )__cil_tmp237;
          {
#line 1679
          __cil_tmp238 = (unsigned int )bus_no;
#line 1679
          if (__cil_tmp238 > 4U) {
#line 1680
            goto ldv_32469;
          } else {

          }
          }
          {
#line 1682
          __cil_tmp239 = (int )scsi_id;
#line 1682
          if (__cil_tmp239 > 127) {
#line 1683
            goto ldv_32469;
          } else {

          }
          }
          {
#line 1685
          __cil_tmp240 = (struct adpt_device *)0;
#line 1685
          __cil_tmp241 = (unsigned long )__cil_tmp240;
#line 1685
          __cil_tmp242 = (int )scsi_id;
#line 1685
          __cil_tmp243 = __cil_tmp242 * 8UL;
#line 1685
          __cil_tmp244 = 0 + __cil_tmp243;
#line 1685
          __cil_tmp245 = (int )bus_no;
#line 1685
          __cil_tmp246 = __cil_tmp245 * 1040UL;
#line 1685
          __cil_tmp247 = __cil_tmp246 + __cil_tmp244;
#line 1685
          __cil_tmp248 = 360 + __cil_tmp247;
#line 1685
          __cil_tmp249 = (unsigned long )pHba;
#line 1685
          __cil_tmp250 = __cil_tmp249 + __cil_tmp248;
#line 1685
          __cil_tmp251 = *((struct adpt_device **)__cil_tmp250);
#line 1685
          __cil_tmp252 = (unsigned long )__cil_tmp251;
#line 1685
          if (__cil_tmp252 == __cil_tmp241) {
            {
#line 1686
            tmp___2 = kzalloc(48UL, 208U);
#line 1686
            pDev = (struct adpt_device *)tmp___2;
            }
            {
#line 1687
            __cil_tmp253 = (struct adpt_device *)0;
#line 1687
            __cil_tmp254 = (unsigned long )__cil_tmp253;
#line 1687
            __cil_tmp255 = (unsigned long )pDev;
#line 1687
            if (__cil_tmp255 == __cil_tmp254) {
#line 1688
              return (-12);
            } else {

            }
            }
#line 1690
            __cil_tmp256 = (int )scsi_id;
#line 1690
            __cil_tmp257 = __cil_tmp256 * 8UL;
#line 1690
            __cil_tmp258 = 0 + __cil_tmp257;
#line 1690
            __cil_tmp259 = (int )bus_no;
#line 1690
            __cil_tmp260 = __cil_tmp259 * 1040UL;
#line 1690
            __cil_tmp261 = __cil_tmp260 + __cil_tmp258;
#line 1690
            __cil_tmp262 = 360 + __cil_tmp261;
#line 1690
            __cil_tmp263 = (unsigned long )pHba;
#line 1690
            __cil_tmp264 = __cil_tmp263 + __cil_tmp262;
#line 1690
            *((struct adpt_device **)__cil_tmp264) = pDev;
          } else {
#line 1692
            __cil_tmp265 = (int )scsi_id;
#line 1692
            __cil_tmp266 = __cil_tmp265 * 8UL;
#line 1692
            __cil_tmp267 = 0 + __cil_tmp266;
#line 1692
            __cil_tmp268 = (int )bus_no;
#line 1692
            __cil_tmp269 = __cil_tmp268 * 1040UL;
#line 1692
            __cil_tmp270 = __cil_tmp269 + __cil_tmp267;
#line 1692
            __cil_tmp271 = 360 + __cil_tmp270;
#line 1692
            __cil_tmp272 = (unsigned long )pHba;
#line 1692
            __cil_tmp273 = __cil_tmp272 + __cil_tmp271;
#line 1692
            pDev = *((struct adpt_device **)__cil_tmp273);
#line 1692
            goto ldv_32471;
            ldv_32470: 
#line 1693
            pDev = *((struct adpt_device **)pDev);
            ldv_32471: ;
            {
#line 1692
            __cil_tmp274 = (struct adpt_device *)0;
#line 1692
            __cil_tmp275 = (unsigned long )__cil_tmp274;
#line 1692
            __cil_tmp276 = *((struct adpt_device **)pDev);
#line 1692
            __cil_tmp277 = (unsigned long )__cil_tmp276;
#line 1692
            if (__cil_tmp277 != __cil_tmp275) {
#line 1694
              goto ldv_32470;
            } else {
#line 1696
              goto ldv_32472;
            }
            }
            ldv_32472: 
            {
#line 1695
            tmp___3 = kzalloc(48UL, 208U);
#line 1695
            *((struct adpt_device **)pDev) = (struct adpt_device *)tmp___3;
            }
            {
#line 1696
            __cil_tmp278 = (struct adpt_device *)0;
#line 1696
            __cil_tmp279 = (unsigned long )__cil_tmp278;
#line 1696
            __cil_tmp280 = *((struct adpt_device **)pDev);
#line 1696
            __cil_tmp281 = (unsigned long )__cil_tmp280;
#line 1696
            if (__cil_tmp281 == __cil_tmp279) {
#line 1697
              return (-12);
            } else {

            }
            }
#line 1699
            pDev = *((struct adpt_device **)pDev);
          }
          }
#line 1701
          __cil_tmp282 = (unsigned long )pDev;
#line 1701
          __cil_tmp283 = __cil_tmp282 + 28;
#line 1701
          *((u16 *)__cil_tmp283) = (u16 )tid;
#line 1702
          __cil_tmp284 = (unsigned long )pDev;
#line 1702
          __cil_tmp285 = __cil_tmp284 + 24;
#line 1702
          *((u8 *)__cil_tmp285) = bus_no;
#line 1703
          __cil_tmp286 = (unsigned long )pDev;
#line 1703
          __cil_tmp287 = __cil_tmp286 + 25;
#line 1703
          *((u8 *)__cil_tmp287) = (u8 )scsi_id;
#line 1704
          __cil_tmp288 = (unsigned long )pDev;
#line 1704
          __cil_tmp289 = __cil_tmp288 + 26;
#line 1704
          *((u8 *)__cil_tmp289) = (u8 )scsi_lun;
#line 1705
          __cil_tmp290 = (unsigned long )pDev;
#line 1705
          __cil_tmp291 = __cil_tmp290 + 32;
#line 1705
          *((struct i2o_device **)__cil_tmp291) = d;
#line 1706
          __cil_tmp292 = (unsigned long )d;
#line 1706
          __cil_tmp293 = __cil_tmp292 + 80;
#line 1706
          *((struct adpt_device **)__cil_tmp293) = pDev;
#line 1707
          __cil_tmp294 = (unsigned long )pDev;
#line 1707
          __cil_tmp295 = __cil_tmp294 + 12;
#line 1707
          __cil_tmp296 = 0 * 4UL;
#line 1707
          __cil_tmp297 = (unsigned long )(buf) + __cil_tmp296;
#line 1707
          __cil_tmp298 = *((u32 *)__cil_tmp297);
#line 1707
          *((u32 *)__cil_tmp295) = __cil_tmp298 & 255U;
#line 1708
          __cil_tmp299 = (unsigned long )pDev;
#line 1708
          __cil_tmp300 = __cil_tmp299 + 8;
#line 1708
          __cil_tmp301 = 0 * 4UL;
#line 1708
          __cil_tmp302 = (unsigned long )(buf) + __cil_tmp301;
#line 1708
          __cil_tmp303 = *((u32 *)__cil_tmp302);
#line 1708
          __cil_tmp304 = __cil_tmp303 >> 8;
#line 1708
          *((u32 *)__cil_tmp300) = __cil_tmp304 & 255U;
          {
#line 1709
          __cil_tmp305 = (unsigned long )pHba;
#line 1709
          __cil_tmp306 = __cil_tmp305 + 293;
#line 1709
          __cil_tmp307 = *((u8 *)__cil_tmp306);
#line 1709
          __cil_tmp308 = (int )__cil_tmp307;
#line 1709
          __cil_tmp309 = (int )scsi_id;
#line 1709
          if (__cil_tmp309 > __cil_tmp308) {
#line 1710
            __cil_tmp310 = (unsigned long )pHba;
#line 1710
            __cil_tmp311 = __cil_tmp310 + 293;
#line 1710
            *((u8 *)__cil_tmp311) = (u8 )scsi_id;
          } else {

          }
          }
          {
#line 1712
          __cil_tmp312 = (unsigned long )pHba;
#line 1712
          __cil_tmp313 = __cil_tmp312 + 294;
#line 1712
          __cil_tmp314 = *((u8 *)__cil_tmp313);
#line 1712
          __cil_tmp315 = (int )__cil_tmp314;
#line 1712
          __cil_tmp316 = (int )scsi_lun;
#line 1712
          if (__cil_tmp316 > __cil_tmp315) {
#line 1713
            __cil_tmp317 = (unsigned long )pHba;
#line 1713
            __cil_tmp318 = __cil_tmp317 + 294;
#line 1713
            *((u8 *)__cil_tmp318) = (u8 )scsi_lun;
          } else {

          }
          }
        } else {

        }
        {
#line 1716
        __cil_tmp319 = (int )scsi_id;
#line 1716
        if (__cil_tmp319 == -1) {
          {
#line 1717
          __cil_tmp320 = 24 + 25;
#line 1717
          __cil_tmp321 = (unsigned long )d;
#line 1717
          __cil_tmp322 = __cil_tmp321 + __cil_tmp320;
#line 1717
          __cil_tmp323 = (__u8 (*)[8U])__cil_tmp322;
#line 1717
          __cil_tmp324 = (__u8 *)__cil_tmp323;
#line 1717
          printk("<4>Could not find SCSI ID for %s\n", __cil_tmp324);
          }
        } else {

        }
        }
      } else {

      }
      }
    }
    }
  }
  }
  ldv_32469: 
#line 1667
  d = *((struct i2o_device **)d);
  ldv_32474: ;
  {
#line 1667
  __cil_tmp325 = (struct i2o_device *)0;
#line 1667
  __cil_tmp326 = (unsigned long )__cil_tmp325;
#line 1667
  __cil_tmp327 = (unsigned long )d;
#line 1667
  if (__cil_tmp327 != __cil_tmp326) {
#line 1668
    goto ldv_32473;
  } else {
#line 1670
    goto ldv_32475;
  }
  }
  ldv_32475: ;
#line 1722
  return (0);
}
}
#line 1731 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_install_device(adpt_hba *pHba , struct i2o_device *d ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct i2o_device *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct i2o_device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  struct i2o_device *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char (*__cil_tmp26)[8U] ;
  char *__cil_tmp27 ;

  {
  {
#line 1733
  mutex_lock_nested(& adpt_configuration_lock, 0U);
#line 1734
  __cil_tmp3 = (unsigned long )d;
#line 1734
  __cil_tmp4 = __cil_tmp3 + 88;
#line 1734
  *((struct _adpt_hba **)__cil_tmp4) = pHba;
#line 1735
  __cil_tmp5 = (unsigned long )d;
#line 1735
  __cil_tmp6 = __cil_tmp5 + 80;
#line 1735
  *((struct adpt_device **)__cil_tmp6) = (struct adpt_device *)0;
#line 1736
  __cil_tmp7 = (unsigned long )pHba;
#line 1736
  __cil_tmp8 = __cil_tmp7 + 352;
#line 1736
  *((struct i2o_device **)d) = *((struct i2o_device **)__cil_tmp8);
#line 1737
  __cil_tmp9 = (unsigned long )d;
#line 1737
  __cil_tmp10 = __cil_tmp9 + 8;
#line 1737
  *((struct i2o_device **)__cil_tmp10) = (struct i2o_device *)0;
  }
  {
#line 1738
  __cil_tmp11 = (struct i2o_device *)0;
#line 1738
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 1738
  __cil_tmp13 = (unsigned long )pHba;
#line 1738
  __cil_tmp14 = __cil_tmp13 + 352;
#line 1738
  __cil_tmp15 = *((struct i2o_device **)__cil_tmp14);
#line 1738
  __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 1738
  if (__cil_tmp16 != __cil_tmp12) {
#line 1739
    __cil_tmp17 = (unsigned long )pHba;
#line 1739
    __cil_tmp18 = __cil_tmp17 + 352;
#line 1739
    __cil_tmp19 = *((struct i2o_device **)__cil_tmp18);
#line 1739
    __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 1739
    __cil_tmp21 = __cil_tmp20 + 8;
#line 1739
    *((struct i2o_device **)__cil_tmp21) = d;
  } else {

  }
  }
  {
#line 1741
  __cil_tmp22 = (unsigned long )pHba;
#line 1741
  __cil_tmp23 = __cil_tmp22 + 352;
#line 1741
  *((struct i2o_device **)__cil_tmp23) = d;
#line 1742
  __cil_tmp24 = (unsigned long )d;
#line 1742
  __cil_tmp25 = __cil_tmp24 + 16;
#line 1742
  __cil_tmp26 = (char (*)[8U])__cil_tmp25;
#line 1742
  __cil_tmp27 = (char *)__cil_tmp26;
#line 1742
  *__cil_tmp27 = (char)0;
#line 1744
  mutex_unlock(& adpt_configuration_lock);
  }
#line 1745
  return (0);
}
}
#line 1748 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_open(struct inode *inode , struct file *file ) 
{ int minor ;
  adpt_hba *pHba ;
  unsigned int tmp ;
  struct inode    *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  adpt_hba *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  adpt_hba *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  {
#line 1753
  mutex_lock_nested(& adpt_mutex, 0U);
#line 1756
  __cil_tmp6 = (struct inode    *)inode;
#line 1756
  tmp = iminor(__cil_tmp6);
#line 1756
  minor = (int )tmp;
  }
#line 1757
  if (minor >= hba_count) {
    {
#line 1758
    mutex_unlock(& adpt_mutex);
    }
#line 1759
    return (-6);
  } else {

  }
  {
#line 1761
  mutex_lock_nested(& adpt_configuration_lock, 0U);
#line 1762
  pHba = hba_chain;
  }
#line 1762
  goto ldv_32488;
  ldv_32487: ;
  {
#line 1763
  __cil_tmp7 = (unsigned long )pHba;
#line 1763
  __cil_tmp8 = __cil_tmp7 + 104;
#line 1763
  __cil_tmp9 = *((int *)__cil_tmp8);
#line 1763
  if (__cil_tmp9 == minor) {
#line 1764
    goto ldv_32486;
  } else {

  }
  }
#line 1762
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32488: ;
  {
#line 1762
  __cil_tmp10 = (adpt_hba *)0;
#line 1762
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1762
  __cil_tmp12 = (unsigned long )pHba;
#line 1762
  if (__cil_tmp12 != __cil_tmp11) {
#line 1763
    goto ldv_32487;
  } else {
#line 1765
    goto ldv_32486;
  }
  }
  ldv_32486: ;
  {
#line 1767
  __cil_tmp13 = (adpt_hba *)0;
#line 1767
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1767
  __cil_tmp15 = (unsigned long )pHba;
#line 1767
  if (__cil_tmp15 == __cil_tmp14) {
    {
#line 1768
    mutex_unlock(& adpt_configuration_lock);
#line 1769
    mutex_unlock(& adpt_mutex);
    }
#line 1770
    return (-6);
  } else {

  }
  }
  {
#line 1778
  __cil_tmp16 = (unsigned long )pHba;
#line 1778
  __cil_tmp17 = __cil_tmp16 + 113;
#line 1778
  *((u8 *)__cil_tmp17) = (u8 )1U;
#line 1779
  mutex_unlock(& adpt_configuration_lock);
#line 1780
  mutex_unlock(& adpt_mutex);
  }
#line 1782
  return (0);
}
}
#line 1785 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_close(struct inode *inode , struct file *file ) 
{ int minor ;
  adpt_hba *pHba ;
  unsigned int tmp ;
  struct inode    *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  adpt_hba *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  adpt_hba *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
  {
#line 1790
  __cil_tmp6 = (struct inode    *)inode;
#line 1790
  tmp = iminor(__cil_tmp6);
#line 1790
  minor = (int )tmp;
  }
#line 1791
  if (minor >= hba_count) {
#line 1792
    return (-6);
  } else {

  }
  {
#line 1794
  mutex_lock_nested(& adpt_configuration_lock, 0U);
#line 1795
  pHba = hba_chain;
  }
#line 1795
  goto ldv_32497;
  ldv_32496: ;
  {
#line 1796
  __cil_tmp7 = (unsigned long )pHba;
#line 1796
  __cil_tmp8 = __cil_tmp7 + 104;
#line 1796
  __cil_tmp9 = *((int *)__cil_tmp8);
#line 1796
  if (__cil_tmp9 == minor) {
#line 1797
    goto ldv_32495;
  } else {

  }
  }
#line 1795
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32497: ;
  {
#line 1795
  __cil_tmp10 = (adpt_hba *)0;
#line 1795
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1795
  __cil_tmp12 = (unsigned long )pHba;
#line 1795
  if (__cil_tmp12 != __cil_tmp11) {
#line 1796
    goto ldv_32496;
  } else {
#line 1798
    goto ldv_32495;
  }
  }
  ldv_32495: 
  {
#line 1800
  mutex_unlock(& adpt_configuration_lock);
  }
  {
#line 1801
  __cil_tmp13 = (adpt_hba *)0;
#line 1801
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1801
  __cil_tmp15 = (unsigned long )pHba;
#line 1801
  if (__cil_tmp15 == __cil_tmp14) {
#line 1802
    return (-6);
  } else {

  }
  }
#line 1805
  __cil_tmp16 = (unsigned long )pHba;
#line 1805
  __cil_tmp17 = __cil_tmp16 + 113;
#line 1805
  *((u8 *)__cil_tmp17) = (u8 )0U;
#line 1807
  return (0);
}
}
#line 1811 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_passthru(adpt_hba *pHba , u32 *arg ) 
{ u32 msg[128U] ;
  u32 *reply ;
  u32 size ;
  u32 reply_size ;
  u32 *user_msg ;
  u32 *user_reply ;
  void **sg_list ;
  unsigned long __lengthofsg_list ;
  void *tmp ;
  u32 sg_offset ;
  u32 sg_count ;
  int sg_index ;
  u32 i ;
  u32 rcode ;
  void *p ;
  dma_addr_t addr ;
  ulong flags ;
  int __ret_gu ;
  unsigned long __val_gu ;
  unsigned long tmp___0 ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  void *tmp___1 ;
  struct sg_simple_element *sg ;
  int sg_size ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  u32 j ;
  struct sg_simple_element *sg___0 ;
  int sg_size___0 ;
  int __ret_gu___1 ;
  unsigned long __val_gu___1 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  struct sg_simple_element *sg___1 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  u32 __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  void ***__cil_tmp46 ;
  void *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  void *__cil_tmp49 ;
  void    *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  u32 *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  char (*__cil_tmp57)[32U] ;
  char *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  u32 __cil_tmp61 ;
  u32 __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  void *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  u32 __cil_tmp70 ;
  void *__cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  struct sg_simple_element *__cil_tmp78 ;
  u32 __cil_tmp79 ;
  u32 __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  u32 __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  char (*__cil_tmp86)[32U] ;
  char *__cil_tmp87 ;
  void    *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct sg_simple_element *__cil_tmp90 ;
  u32 __cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  char (*__cil_tmp95)[32U] ;
  char *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct sg_simple_element *__cil_tmp98 ;
  u32 __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  struct sg_simple_element *__cil_tmp101 ;
  u32 __cil_tmp102 ;
  int __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  struct pci_dev *__cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  struct device *__cil_tmp109 ;
  size_t __cil_tmp110 ;
  struct dma_attrs *__cil_tmp111 ;
  void *__cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  char (*__cil_tmp117)[32U] ;
  char *__cil_tmp118 ;
  void ***__cil_tmp119 ;
  void **__cil_tmp120 ;
  void **__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  struct sg_simple_element *__cil_tmp123 ;
  u32 __cil_tmp124 ;
  unsigned int __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  struct sg_simple_element *__cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  u32 __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  void    *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  char (*__cil_tmp136)[32U] ;
  char *__cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  struct sg_simple_element *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  dma_addr_t *__cil_tmp142 ;
  dma_addr_t __cil_tmp143 ;
  struct Scsi_Host *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  struct Scsi_Host *__cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  u32 *__cil_tmp150 ;
  int __cil_tmp151 ;
  struct Scsi_Host *__cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  struct Scsi_Host *__cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  struct Scsi_Host *__cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  spinlock_t *__cil_tmp163 ;
  void *__cil_tmp164 ;
  void *__cil_tmp165 ;
  void    *__cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  u32 __cil_tmp168 ;
  u32 __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  struct sg_simple_element *__cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  struct sg_simple_element *__cil_tmp173 ;
  u32 __cil_tmp174 ;
  unsigned int __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  struct sg_simple_element *__cil_tmp177 ;
  u32 __cil_tmp178 ;
  int __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  struct sg_simple_element *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  u32 __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  void *__cil_tmp186 ;
  void ***__cil_tmp187 ;
  void **__cil_tmp188 ;
  void **__cil_tmp189 ;
  void *__cil_tmp190 ;
  void    *__cil_tmp191 ;
  unsigned int __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  char (*__cil_tmp195)[32U] ;
  char *__cil_tmp196 ;
  void ***__cil_tmp197 ;
  void **__cil_tmp198 ;
  void **__cil_tmp199 ;
  void *__cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  struct sg_simple_element *__cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  u32 __cil_tmp205 ;
  void *__cil_tmp206 ;
  void *__cil_tmp207 ;
  void    *__cil_tmp208 ;
  void    *__cil_tmp209 ;
  unsigned long __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  char (*__cil_tmp212)[32U] ;
  char *__cil_tmp213 ;
  void *__cil_tmp214 ;
  void    *__cil_tmp215 ;
  unsigned long __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  char (*__cil_tmp218)[32U] ;
  char *__cil_tmp219 ;
  unsigned long __cil_tmp220 ;
  struct sg_simple_element *__cil_tmp221 ;
  void    *__cil_tmp222 ;
  void *__cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  void ***__cil_tmp225 ;
  void **__cil_tmp226 ;
  void **__cil_tmp227 ;
  void *__cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  unsigned long __cil_tmp231 ;
  struct pci_dev *__cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  unsigned long __cil_tmp234 ;
  struct device *__cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  struct sg_simple_element *__cil_tmp237 ;
  u32 __cil_tmp238 ;
  size_t __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  void ***__cil_tmp241 ;
  void **__cil_tmp242 ;
  void **__cil_tmp243 ;
  void *__cil_tmp244 ;
  unsigned long __cil_tmp245 ;
  struct sg_simple_element *__cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  u32 __cil_tmp249 ;
  dma_addr_t __cil_tmp250 ;
  struct dma_attrs *__cil_tmp251 ;

  {
  {
#line 1814
  reply = (u32 *)0;
#line 1815
  size = 0U;
#line 1816
  reply_size = 0U;
#line 1817
  user_msg = arg;
#line 1818
  user_reply = (u32 *)0;
#line 1819
  __cil_tmp41 = (unsigned long )pHba;
#line 1819
  __cil_tmp42 = __cil_tmp41 + 288;
#line 1819
  __cil_tmp43 = *((u32 *)__cil_tmp42);
#line 1819
  __cil_tmp44 = (long )__cil_tmp43;
#line 1819
  __lengthofsg_list = (unsigned long )__cil_tmp44;
#line 1819
  __cil_tmp45 = 8UL * __lengthofsg_list;
#line 1819
  tmp = __builtin_alloca(__cil_tmp45);
#line 1819
  __cil_tmp46 = & sg_list;
#line 1819
  *__cil_tmp46 = (void **)tmp;
#line 1820
  sg_offset = 0U;
#line 1821
  sg_count = 0U;
#line 1822
  sg_index = 0;
#line 1823
  i = 0U;
#line 1824
  rcode = 0U;
#line 1825
  p = (void *)0;
#line 1827
  flags = 0UL;
#line 1829
  __cil_tmp47 = (void *)(& msg);
#line 1829
  memset(__cil_tmp47, 0, 512UL);
#line 1831
  might_fault();
  }
#line 1831
  if (4 == 1) {
#line 1831
    goto case_1;
  } else
#line 1831
  if (4 == 2) {
#line 1831
    goto case_2;
  } else
#line 1831
  if (4 == 4) {
#line 1831
    goto case_4;
  } else
#line 1831
  if (4 == 8) {
#line 1831
    goto case_8;
  } else {
    {
#line 1831
    goto switch_default;
#line 1831
    if (0) {
      case_1: /* CIL Label */ 
#line 1831
      __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (user_msg));
#line 1831
      goto ldv_32520;
      case_2: /* CIL Label */ 
#line 1831
      __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (user_msg));
#line 1831
      goto ldv_32520;
      case_4: /* CIL Label */ 
#line 1831
      __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (user_msg));
#line 1831
      goto ldv_32520;
      case_8: /* CIL Label */ 
#line 1831
      __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (user_msg));
#line 1831
      goto ldv_32520;
      switch_default: /* CIL Label */ 
#line 1831
      __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (user_msg));
#line 1831
      goto ldv_32520;
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_32520: 
#line 1831
  size = (unsigned int )__val_gu;
#line 1831
  if (__ret_gu != 0) {
#line 1832
    return (-14);
  } else {

  }
#line 1834
  size = size >> 16;
#line 1836
  __cil_tmp48 = (unsigned long )size;
#line 1836
  user_reply = user_msg + __cil_tmp48;
#line 1837
  if (size > 128U) {
#line 1838
    return (-14);
  } else {

  }
  {
#line 1840
  size = size * 4U;
#line 1843
  __cil_tmp49 = (void *)(& msg);
#line 1843
  __cil_tmp50 = (void    *)user_msg;
#line 1843
  __cil_tmp51 = (unsigned long )size;
#line 1843
  tmp___0 = copy_from_user(__cil_tmp49, __cil_tmp50, __cil_tmp51);
  }
#line 1843
  if (tmp___0 != 0UL) {
#line 1844
    return (-14);
  } else {

  }
  {
#line 1846
  might_fault();
  }
#line 1846
  if (4 == 1) {
#line 1846
    goto case_1___0;
  } else
#line 1846
  if (4 == 2) {
#line 1846
    goto case_2___0;
  } else
#line 1846
  if (4 == 4) {
#line 1846
    goto case_4___0;
  } else
#line 1846
  if (4 == 8) {
#line 1846
    goto case_8___0;
  } else {
    {
#line 1846
    goto switch_default___0;
#line 1846
    if (0) {
      case_1___0: /* CIL Label */ 
#line 1846
      __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (user_reply));
#line 1846
      goto ldv_32529;
      case_2___0: /* CIL Label */ 
#line 1846
      __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (user_reply));
#line 1846
      goto ldv_32529;
      case_4___0: /* CIL Label */ 
#line 1846
      __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (user_reply));
#line 1846
      goto ldv_32529;
      case_8___0: /* CIL Label */ 
#line 1846
      __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (user_reply));
#line 1846
      goto ldv_32529;
      switch_default___0: /* CIL Label */ 
#line 1846
      __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (user_reply));
#line 1846
      goto ldv_32529;
    } else {
      switch_break___0: /* CIL Label */ ;
    }
    }
  }
  ldv_32529: 
#line 1846
  reply_size = (unsigned int )__val_gu___0;
#line 1847
  reply_size = reply_size >> 16;
#line 1848
  if (reply_size > 17U) {
#line 1849
    reply_size = 17U;
  } else {

  }
  {
#line 1851
  reply_size = reply_size * 4U;
#line 1852
  tmp___1 = kzalloc(68UL, 208U);
#line 1852
  reply = (u32 *)tmp___1;
  }
  {
#line 1853
  __cil_tmp52 = (u32 *)0;
#line 1853
  __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 1853
  __cil_tmp54 = (unsigned long )reply;
#line 1853
  if (__cil_tmp54 == __cil_tmp53) {
    {
#line 1854
    __cil_tmp55 = (unsigned long )pHba;
#line 1854
    __cil_tmp56 = __cil_tmp55 + 114;
#line 1854
    __cil_tmp57 = (char (*)[32U])__cil_tmp56;
#line 1854
    __cil_tmp58 = (char *)__cil_tmp57;
#line 1854
    printk("<4>%s: Could not allocate reply buffer\n", __cil_tmp58);
    }
#line 1855
    return (-12);
  } else {

  }
  }
  {
#line 1857
  __cil_tmp59 = 0 * 4UL;
#line 1857
  __cil_tmp60 = (unsigned long )(msg) + __cil_tmp59;
#line 1857
  __cil_tmp61 = *((u32 *)__cil_tmp60);
#line 1857
  __cil_tmp62 = __cil_tmp61 >> 4;
#line 1857
  sg_offset = __cil_tmp62 & 15U;
#line 1858
  __cil_tmp63 = 2 * 4UL;
#line 1858
  __cil_tmp64 = (unsigned long )(msg) + __cil_tmp63;
#line 1858
  *((u32 *)__cil_tmp64) = 1073741824U;
#line 1859
  __cil_tmp65 = 3 * 4UL;
#line 1859
  __cil_tmp66 = (unsigned long )(msg) + __cil_tmp65;
#line 1859
  __cil_tmp67 = (void *)reply;
#line 1859
  *((u32 *)__cil_tmp66) = adpt_ioctl_to_context(pHba, __cil_tmp67);
  }
  {
#line 1860
  __cil_tmp68 = 3 * 4UL;
#line 1860
  __cil_tmp69 = (unsigned long )(msg) + __cil_tmp68;
#line 1860
  __cil_tmp70 = *((u32 *)__cil_tmp69);
#line 1860
  if (__cil_tmp70 == 4294967295U) {
#line 1861
    return (-16);
  } else {

  }
  }
  {
#line 1863
  __cil_tmp71 = (void *)(& sg_list);
#line 1863
  __cil_tmp72 = (unsigned long )pHba;
#line 1863
  __cil_tmp73 = __cil_tmp72 + 288;
#line 1863
  __cil_tmp74 = *((u32 *)__cil_tmp73);
#line 1863
  __cil_tmp75 = (unsigned long )__cil_tmp74;
#line 1863
  __cil_tmp76 = __cil_tmp75 * 8UL;
#line 1863
  memset(__cil_tmp71, 0, __cil_tmp76);
  }
#line 1864
  if (sg_offset != 0U) {
#line 1866
    __cil_tmp77 = (unsigned long )sg_offset;
#line 1866
    __cil_tmp78 = (struct sg_simple_element *)(& msg);
#line 1866
    sg = __cil_tmp78 + __cil_tmp77;
#line 1867
    __cil_tmp79 = sg_offset * 4U;
#line 1867
    __cil_tmp80 = size - __cil_tmp79;
#line 1867
    sg_count = __cil_tmp80 / 8U;
    {
#line 1868
    __cil_tmp81 = (unsigned long )pHba;
#line 1868
    __cil_tmp82 = __cil_tmp81 + 288;
#line 1868
    __cil_tmp83 = *((u32 *)__cil_tmp82);
#line 1868
    if (__cil_tmp83 < sg_count) {
      {
#line 1869
      __cil_tmp84 = (unsigned long )pHba;
#line 1869
      __cil_tmp85 = __cil_tmp84 + 114;
#line 1869
      __cil_tmp86 = (char (*)[32U])__cil_tmp85;
#line 1869
      __cil_tmp87 = (char *)__cil_tmp86;
#line 1869
      printk("<7>%s:IOCTL SG List too large (%u)\n", __cil_tmp87, sg_count);
#line 1870
      __cil_tmp88 = (void    *)reply;
#line 1870
      kfree(__cil_tmp88);
      }
#line 1871
      return (-22);
    } else {

    }
    }
#line 1874
    i = 0U;
#line 1874
    goto ldv_32539;
    ldv_32538: ;
    {
#line 1877
    __cil_tmp89 = (unsigned long )i;
#line 1877
    __cil_tmp90 = sg + __cil_tmp89;
#line 1877
    __cil_tmp91 = *((u32 *)__cil_tmp90);
#line 1877
    __cil_tmp92 = __cil_tmp91 & 268435456U;
#line 1877
    if (__cil_tmp92 == 0U) {
      {
#line 1878
      __cil_tmp93 = (unsigned long )pHba;
#line 1878
      __cil_tmp94 = __cil_tmp93 + 114;
#line 1878
      __cil_tmp95 = (char (*)[32U])__cil_tmp94;
#line 1878
      __cil_tmp96 = (char *)__cil_tmp95;
#line 1878
      __cil_tmp97 = (unsigned long )i;
#line 1878
      __cil_tmp98 = sg + __cil_tmp97;
#line 1878
      __cil_tmp99 = *((u32 *)__cil_tmp98);
#line 1878
      printk("<7>%s:Bad SG element %d - not simple (%x)\n", __cil_tmp96, i, __cil_tmp99);
#line 1879
      rcode = 4294967274U;
      }
#line 1880
      goto cleanup;
    } else {

    }
    }
    {
#line 1882
    __cil_tmp100 = (unsigned long )i;
#line 1882
    __cil_tmp101 = sg + __cil_tmp100;
#line 1882
    __cil_tmp102 = *((u32 *)__cil_tmp101);
#line 1882
    __cil_tmp103 = (int )__cil_tmp102;
#line 1882
    sg_size = __cil_tmp103 & 16777215;
#line 1884
    __cil_tmp104 = (unsigned long )pHba;
#line 1884
    __cil_tmp105 = __cil_tmp104 + 8;
#line 1884
    __cil_tmp106 = *((struct pci_dev **)__cil_tmp105);
#line 1884
    __cil_tmp107 = (unsigned long )__cil_tmp106;
#line 1884
    __cil_tmp108 = __cil_tmp107 + 144;
#line 1884
    __cil_tmp109 = (struct device *)__cil_tmp108;
#line 1884
    __cil_tmp110 = (size_t )sg_size;
#line 1884
    __cil_tmp111 = (struct dma_attrs *)0;
#line 1884
    p = dma_alloc_attrs(__cil_tmp109, __cil_tmp110, & addr, 208U, __cil_tmp111);
    }
    {
#line 1885
    __cil_tmp112 = (void *)0;
#line 1885
    __cil_tmp113 = (unsigned long )__cil_tmp112;
#line 1885
    __cil_tmp114 = (unsigned long )p;
#line 1885
    if (__cil_tmp114 == __cil_tmp113) {
      {
#line 1886
      __cil_tmp115 = (unsigned long )pHba;
#line 1886
      __cil_tmp116 = __cil_tmp115 + 114;
#line 1886
      __cil_tmp117 = (char (*)[32U])__cil_tmp116;
#line 1886
      __cil_tmp118 = (char *)__cil_tmp117;
#line 1886
      printk("<7>%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
             __cil_tmp118, sg_size, i, sg_count);
#line 1888
      rcode = 4294967284U;
      }
#line 1889
      goto cleanup;
    } else {

    }
    }
#line 1891
    tmp___2 = sg_index;
#line 1891
    sg_index = sg_index + 1;
#line 1891
    __cil_tmp119 = & sg_list;
#line 1891
    __cil_tmp120 = *__cil_tmp119;
#line 1891
    __cil_tmp121 = __cil_tmp120 + tmp___2;
#line 1891
    *__cil_tmp121 = p;
    {
#line 1893
    __cil_tmp122 = (unsigned long )i;
#line 1893
    __cil_tmp123 = sg + __cil_tmp122;
#line 1893
    __cil_tmp124 = *((u32 *)__cil_tmp123);
#line 1893
    __cil_tmp125 = __cil_tmp124 & 67108864U;
#line 1893
    if (__cil_tmp125 != 0U) {
      {
#line 1895
      __cil_tmp126 = (unsigned long )i;
#line 1895
      __cil_tmp127 = sg + __cil_tmp126;
#line 1895
      __cil_tmp128 = (unsigned long )__cil_tmp127;
#line 1895
      __cil_tmp129 = __cil_tmp128 + 4;
#line 1895
      __cil_tmp130 = *((u32 *)__cil_tmp129);
#line 1895
      __cil_tmp131 = (unsigned long )__cil_tmp130;
#line 1895
      __cil_tmp132 = (void    *)__cil_tmp131;
#line 1895
      __cil_tmp133 = (unsigned long )sg_size;
#line 1895
      tmp___3 = copy_from_user(p, __cil_tmp132, __cil_tmp133);
      }
#line 1895
      if (tmp___3 != 0UL) {
        {
#line 1896
        __cil_tmp134 = (unsigned long )pHba;
#line 1896
        __cil_tmp135 = __cil_tmp134 + 114;
#line 1896
        __cil_tmp136 = (char (*)[32U])__cil_tmp135;
#line 1896
        __cil_tmp137 = (char *)__cil_tmp136;
#line 1896
        printk("<7>%s: Could not copy SG buf %d FROM user\n", __cil_tmp137, i);
#line 1897
        rcode = 4294967282U;
        }
#line 1898
        goto cleanup;
      } else {

      }
    } else {

    }
    }
#line 1902
    __cil_tmp138 = (unsigned long )i;
#line 1902
    __cil_tmp139 = sg + __cil_tmp138;
#line 1902
    __cil_tmp140 = (unsigned long )__cil_tmp139;
#line 1902
    __cil_tmp141 = __cil_tmp140 + 4;
#line 1902
    __cil_tmp142 = & addr;
#line 1902
    __cil_tmp143 = *__cil_tmp142;
#line 1902
    *((u32 *)__cil_tmp141) = (u32 )__cil_tmp143;
#line 1874
    i = i + 1U;
    ldv_32539: ;
#line 1874
    if (i < sg_count) {
#line 1875
      goto ldv_32538;
    } else {
#line 1877
      goto ldv_32540;
    }
    ldv_32540: ;
  } else {

  }
  ldv_32541: ;
  {
#line 1907
  __cil_tmp144 = (struct Scsi_Host *)0;
#line 1907
  __cil_tmp145 = (unsigned long )__cil_tmp144;
#line 1907
  __cil_tmp146 = (unsigned long )pHba;
#line 1907
  __cil_tmp147 = __cil_tmp146 + 16;
#line 1907
  __cil_tmp148 = *((struct Scsi_Host **)__cil_tmp147);
#line 1907
  __cil_tmp149 = (unsigned long )__cil_tmp148;
#line 1907
  if (__cil_tmp149 != __cil_tmp145) {
    {
#line 1908
    ldv_spin_lock();
    }
  } else {

  }
  }
  {
#line 1914
  __cil_tmp150 = (u32 *)(& msg);
#line 1914
  __cil_tmp151 = (int )size;
#line 1914
  tmp___4 = adpt_i2o_post_wait(pHba, __cil_tmp150, __cil_tmp151, 0);
#line 1914
  rcode = (u32 )tmp___4;
  }
#line 1915
  if (rcode != 0U) {
    {
#line 1916
    printk("adpt_i2o_passthru: post wait failed %d %p\n", rcode, reply);
    }
  } else {

  }
  {
#line 1919
  __cil_tmp152 = (struct Scsi_Host *)0;
#line 1919
  __cil_tmp153 = (unsigned long )__cil_tmp152;
#line 1919
  __cil_tmp154 = (unsigned long )pHba;
#line 1919
  __cil_tmp155 = __cil_tmp154 + 16;
#line 1919
  __cil_tmp156 = *((struct Scsi_Host **)__cil_tmp155);
#line 1919
  __cil_tmp157 = (unsigned long )__cil_tmp156;
#line 1919
  if (__cil_tmp157 != __cil_tmp153) {
    {
#line 1920
    __cil_tmp158 = (unsigned long )pHba;
#line 1920
    __cil_tmp159 = __cil_tmp158 + 16;
#line 1920
    __cil_tmp160 = *((struct Scsi_Host **)__cil_tmp159);
#line 1920
    __cil_tmp161 = (unsigned long )__cil_tmp160;
#line 1920
    __cil_tmp162 = __cil_tmp161 + 216;
#line 1920
    __cil_tmp163 = *((spinlock_t **)__cil_tmp162);
#line 1920
    spin_unlock_irqrestore(__cil_tmp163, flags);
    }
  } else {

  }
  }
#line 1921
  if (rcode == 4294967186U) {
#line 1922
    goto ldv_32541;
  } else {
#line 1924
    goto ldv_32542;
  }
  ldv_32542: ;
#line 1923
  if (rcode != 0U) {
#line 1924
    goto cleanup;
  } else {

  }
#line 1927
  if (sg_offset != 0U) {
    {
#line 1935
    __cil_tmp164 = (void *)(& msg);
#line 1935
    memset(__cil_tmp164, 0, 512UL);
#line 1937
    might_fault();
    }
#line 1937
    if (4 == 1) {
#line 1937
      goto case_1___1;
    } else
#line 1937
    if (4 == 2) {
#line 1937
      goto case_2___1;
    } else
#line 1937
    if (4 == 4) {
#line 1937
      goto case_4___1;
    } else
#line 1937
    if (4 == 8) {
#line 1937
      goto case_8___1;
    } else {
      {
#line 1937
      goto switch_default___1;
#line 1937
      if (0) {
        case_1___1: /* CIL Label */ 
#line 1937
        __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (user_msg));
#line 1937
        goto ldv_32549;
        case_2___1: /* CIL Label */ 
#line 1937
        __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (user_msg));
#line 1937
        goto ldv_32549;
        case_4___1: /* CIL Label */ 
#line 1937
        __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (user_msg));
#line 1937
        goto ldv_32549;
        case_8___1: /* CIL Label */ 
#line 1937
        __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (user_msg));
#line 1937
        goto ldv_32549;
        switch_default___1: /* CIL Label */ 
#line 1937
        __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (user_msg));
#line 1937
        goto ldv_32549;
      } else {
        switch_break___1: /* CIL Label */ ;
      }
      }
    }
    ldv_32549: 
#line 1937
    size = (unsigned int )__val_gu___1;
#line 1937
    if (__ret_gu___1 != 0) {
#line 1938
      rcode = 4294967282U;
#line 1939
      goto cleanup;
    } else {

    }
#line 1941
    size = size >> 16;
#line 1942
    size = size * 4U;
#line 1943
    if (size > 128U) {
#line 1944
      rcode = 4294967274U;
#line 1945
      goto cleanup;
    } else {

    }
    {
#line 1948
    __cil_tmp165 = (void *)(& msg);
#line 1948
    __cil_tmp166 = (void    *)user_msg;
#line 1948
    __cil_tmp167 = (unsigned long )size;
#line 1948
    tmp___5 = copy_from_user(__cil_tmp165, __cil_tmp166, __cil_tmp167);
    }
#line 1948
    if (tmp___5 != 0UL) {
#line 1949
      rcode = 4294967282U;
#line 1950
      goto cleanup;
    } else {

    }
#line 1952
    __cil_tmp168 = sg_offset * 4U;
#line 1952
    __cil_tmp169 = size - __cil_tmp168;
#line 1952
    sg_count = __cil_tmp169 / 8U;
#line 1955
    __cil_tmp170 = (unsigned long )sg_offset;
#line 1955
    __cil_tmp171 = (struct sg_simple_element *)(& msg);
#line 1955
    sg___0 = __cil_tmp171 + __cil_tmp170;
#line 1956
    j = 0U;
#line 1956
    goto ldv_32556;
    ldv_32555: ;
    {
#line 1958
    __cil_tmp172 = (unsigned long )j;
#line 1958
    __cil_tmp173 = sg___0 + __cil_tmp172;
#line 1958
    __cil_tmp174 = *((u32 *)__cil_tmp173);
#line 1958
    __cil_tmp175 = __cil_tmp174 & 67108864U;
#line 1958
    if (__cil_tmp175 == 0U) {
      {
#line 1959
      __cil_tmp176 = (unsigned long )j;
#line 1959
      __cil_tmp177 = sg___0 + __cil_tmp176;
#line 1959
      __cil_tmp178 = *((u32 *)__cil_tmp177);
#line 1959
      __cil_tmp179 = (int )__cil_tmp178;
#line 1959
      sg_size___0 = __cil_tmp179 & 16777215;
#line 1961
      __cil_tmp180 = (unsigned long )j;
#line 1961
      __cil_tmp181 = sg___0 + __cil_tmp180;
#line 1961
      __cil_tmp182 = (unsigned long )__cil_tmp181;
#line 1961
      __cil_tmp183 = __cil_tmp182 + 4;
#line 1961
      __cil_tmp184 = *((u32 *)__cil_tmp183);
#line 1961
      __cil_tmp185 = (unsigned long )__cil_tmp184;
#line 1961
      __cil_tmp186 = (void *)__cil_tmp185;
#line 1961
      __cil_tmp187 = & sg_list;
#line 1961
      __cil_tmp188 = *__cil_tmp187;
#line 1961
      __cil_tmp189 = __cil_tmp188 + j;
#line 1961
      __cil_tmp190 = *__cil_tmp189;
#line 1961
      __cil_tmp191 = (void    *)__cil_tmp190;
#line 1961
      __cil_tmp192 = (unsigned int )sg_size___0;
#line 1961
      tmp___6 = copy_to_user(__cil_tmp186, __cil_tmp191, __cil_tmp192);
      }
#line 1961
      if (tmp___6 != 0) {
        {
#line 1962
        __cil_tmp193 = (unsigned long )pHba;
#line 1962
        __cil_tmp194 = __cil_tmp193 + 114;
#line 1962
        __cil_tmp195 = (char (*)[32U])__cil_tmp194;
#line 1962
        __cil_tmp196 = (char *)__cil_tmp195;
#line 1962
        __cil_tmp197 = & sg_list;
#line 1962
        __cil_tmp198 = *__cil_tmp197;
#line 1962
        __cil_tmp199 = __cil_tmp198 + j;
#line 1962
        __cil_tmp200 = *__cil_tmp199;
#line 1962
        __cil_tmp201 = (unsigned long )j;
#line 1962
        __cil_tmp202 = sg___0 + __cil_tmp201;
#line 1962
        __cil_tmp203 = (unsigned long )__cil_tmp202;
#line 1962
        __cil_tmp204 = __cil_tmp203 + 4;
#line 1962
        __cil_tmp205 = *((u32 *)__cil_tmp204);
#line 1962
        printk("<4>%s: Could not copy %p TO user %x\n", __cil_tmp196, __cil_tmp200,
               __cil_tmp205);
#line 1963
        rcode = 4294967282U;
        }
#line 1964
        goto cleanup;
      } else {

      }
    } else {

    }
    }
#line 1956
    j = j + 1U;
    ldv_32556: ;
#line 1956
    if (j < sg_count) {
#line 1957
      goto ldv_32555;
    } else {
#line 1959
      goto ldv_32557;
    }
    ldv_32557: ;
  } else {

  }
#line 1971
  if (reply_size != 0U) {
    {
#line 1973
    __cil_tmp206 = (void *)reply;
#line 1973
    __cil_tmp207 = __cil_tmp206 + 2U;
#line 1973
    __cil_tmp208 = (void    *)user_msg;
#line 1973
    __cil_tmp209 = __cil_tmp208 + 2U;
#line 1973
    tmp___7 = copy_from_user(__cil_tmp207, __cil_tmp209, 8UL);
    }
#line 1973
    if (tmp___7 != 0UL) {
      {
#line 1974
      __cil_tmp210 = (unsigned long )pHba;
#line 1974
      __cil_tmp211 = __cil_tmp210 + 114;
#line 1974
      __cil_tmp212 = (char (*)[32U])__cil_tmp211;
#line 1974
      __cil_tmp213 = (char *)__cil_tmp212;
#line 1974
      printk("<4>%s: Could not copy message context FROM user\n", __cil_tmp213);
#line 1975
      rcode = 4294967282U;
      }
    } else {

    }
    {
#line 1977
    __cil_tmp214 = (void *)user_reply;
#line 1977
    __cil_tmp215 = (void    *)reply;
#line 1977
    tmp___8 = copy_to_user(__cil_tmp214, __cil_tmp215, reply_size);
    }
#line 1977
    if (tmp___8 != 0) {
      {
#line 1978
      __cil_tmp216 = (unsigned long )pHba;
#line 1978
      __cil_tmp217 = __cil_tmp216 + 114;
#line 1978
      __cil_tmp218 = (char (*)[32U])__cil_tmp217;
#line 1978
      __cil_tmp219 = (char *)__cil_tmp218;
#line 1978
      printk("<4>%s: Could not copy reply TO user\n", __cil_tmp219);
#line 1979
      rcode = 4294967282U;
      }
    } else {

    }
  } else {

  }
  cleanup: ;
#line 1985
  if (rcode != 4294967234U) {
#line 1985
    if (rcode != 4294967292U) {
      {
#line 1986
      __cil_tmp220 = (unsigned long )sg_offset;
#line 1986
      __cil_tmp221 = (struct sg_simple_element *)(& msg);
#line 1986
      sg___1 = __cil_tmp221 + __cil_tmp220;
#line 1988
      __cil_tmp222 = (void    *)reply;
#line 1988
      kfree(__cil_tmp222);
      }
#line 1989
      goto ldv_32560;
      ldv_32559: 
#line 1990
      sg_index = sg_index - 1;
      {
#line 1990
      __cil_tmp223 = (void *)0;
#line 1990
      __cil_tmp224 = (unsigned long )__cil_tmp223;
#line 1990
      __cil_tmp225 = & sg_list;
#line 1990
      __cil_tmp226 = *__cil_tmp225;
#line 1990
      __cil_tmp227 = __cil_tmp226 + sg_index;
#line 1990
      __cil_tmp228 = *__cil_tmp227;
#line 1990
      __cil_tmp229 = (unsigned long )__cil_tmp228;
#line 1990
      if (__cil_tmp229 != __cil_tmp224) {
        {
#line 1991
        __cil_tmp230 = (unsigned long )pHba;
#line 1991
        __cil_tmp231 = __cil_tmp230 + 8;
#line 1991
        __cil_tmp232 = *((struct pci_dev **)__cil_tmp231);
#line 1991
        __cil_tmp233 = (unsigned long )__cil_tmp232;
#line 1991
        __cil_tmp234 = __cil_tmp233 + 144;
#line 1991
        __cil_tmp235 = (struct device *)__cil_tmp234;
#line 1991
        __cil_tmp236 = (unsigned long )sg_index;
#line 1991
        __cil_tmp237 = sg___1 + __cil_tmp236;
#line 1991
        __cil_tmp238 = *((u32 *)__cil_tmp237);
#line 1991
        __cil_tmp239 = (size_t )__cil_tmp238;
#line 1991
        __cil_tmp240 = __cil_tmp239 & 16777215UL;
#line 1991
        __cil_tmp241 = & sg_list;
#line 1991
        __cil_tmp242 = *__cil_tmp241;
#line 1991
        __cil_tmp243 = __cil_tmp242 + sg_index;
#line 1991
        __cil_tmp244 = *__cil_tmp243;
#line 1991
        __cil_tmp245 = (unsigned long )sg_index;
#line 1991
        __cil_tmp246 = sg___1 + __cil_tmp245;
#line 1991
        __cil_tmp247 = (unsigned long )__cil_tmp246;
#line 1991
        __cil_tmp248 = __cil_tmp247 + 4;
#line 1991
        __cil_tmp249 = *((u32 *)__cil_tmp248);
#line 1991
        __cil_tmp250 = (dma_addr_t )__cil_tmp249;
#line 1991
        __cil_tmp251 = (struct dma_attrs *)0;
#line 1991
        dma_free_attrs(__cil_tmp235, __cil_tmp240, __cil_tmp244, __cil_tmp250, __cil_tmp251);
        }
      } else {

      }
      }
      ldv_32560: ;
#line 1989
      if (sg_index != 0) {
#line 1990
        goto ldv_32559;
      } else {
#line 1992
        goto ldv_32561;
      }
      ldv_32561: ;
    } else {

    }
  } else {

  }
#line 1998
  return ((int )rcode);
}
}
#line 2059 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_system_info(void *buffer ) 
{ sysInfo_S si ;
  int tmp ;
  void *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void    *__cil_tmp13 ;

  {
  {
#line 2063
  __cil_tmp4 = (void *)(& si);
#line 2063
  memset(__cil_tmp4, 0, 92UL);
#line 2065
  __cil_tmp5 = (unsigned long )(& si) + 16;
#line 2065
  *((uINT *)__cil_tmp5) = 16777216U;
#line 2066
  __cil_tmp6 = (unsigned long )(& si) + 20;
#line 2066
  *((uCHAR *)__cil_tmp6) = (uCHAR )0U;
#line 2067
  __cil_tmp7 = (unsigned long )(& si) + 21;
#line 2067
  *((uCHAR *)__cil_tmp7) = (uCHAR )0U;
#line 2068
  __cil_tmp8 = (unsigned long )(& si) + 22;
#line 2068
  *((uCHAR *)__cil_tmp8) = (uCHAR )0U;
#line 2069
  __cil_tmp9 = (unsigned long )(& si) + 24;
#line 2069
  *((uCHAR *)__cil_tmp9) = (uCHAR )4U;
#line 2070
  __cil_tmp10 = (unsigned long )(& si) + 3;
#line 2070
  __cil_tmp11 = (unsigned long )(& DPTI_sig) + 7;
#line 2070
  *((uCHAR *)__cil_tmp10) = *((sigBYTE *)__cil_tmp11);
#line 2081
  __cil_tmp12 = (unsigned long )(& si) + 4;
#line 2081
  *((uCHAR *)__cil_tmp12) = (uCHAR )255U;
#line 2083
  __cil_tmp13 = (void    *)(& si);
#line 2083
  tmp = copy_to_user(buffer, __cil_tmp13, 92U);
  }
#line 2083
  if (tmp != 0) {
    {
#line 2084
    printk("<4>dpti: Could not copy buffer TO user\n");
    }
#line 2085
    return (-14);
  } else {

  }
#line 2088
  return (0);
}
}
#line 2091 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_ioctl(struct inode *inode , struct file *file , uint cmd , ulong arg ) 
{ int minor ;
  int error ;
  adpt_hba *pHba ;
  ulong flags ;
  void *argp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  drvrHBAinfo_S HbaInfo ;
  u8 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u32 value ;
  u8 tmp___5 ;
  int tmp___6 ;
  struct inode    *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  adpt_hba *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  adpt_hba *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  u32 __cil_tmp32 ;
  int __cil_tmp33 ;
  void    *__cil_tmp34 ;
  u32 *__cil_tmp35 ;
  void *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  ulong __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct pci_dev *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct pci_bus *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  struct pci_dev *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  uCHAR __cil_tmp63 ;
  unsigned int __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  struct pci_dev *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned int __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  void    *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  char (*__cil_tmp77)[32U] ;
  char *__cil_tmp78 ;
  u32 *__cil_tmp79 ;
  void    *__cil_tmp80 ;
  struct Scsi_Host *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  struct Scsi_Host *__cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct Scsi_Host *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  struct Scsi_Host *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  struct Scsi_Host *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  spinlock_t *__cil_tmp98 ;

  {
  {
#line 2094
  error = 0;
#line 2096
  flags = 0UL;
#line 2097
  argp = (void *)arg;
#line 2099
  __cil_tmp20 = (struct inode    *)inode;
#line 2099
  tmp = iminor(__cil_tmp20);
#line 2099
  minor = (int )tmp;
  }
#line 2100
  if (minor > 15) {
#line 2101
    return (-6);
  } else {

  }
  {
#line 2103
  mutex_lock_nested(& adpt_configuration_lock, 0U);
#line 2104
  pHba = hba_chain;
  }
#line 2104
  goto ldv_32579;
  ldv_32578: ;
  {
#line 2105
  __cil_tmp21 = (unsigned long )pHba;
#line 2105
  __cil_tmp22 = __cil_tmp21 + 104;
#line 2105
  __cil_tmp23 = *((int *)__cil_tmp22);
#line 2105
  if (__cil_tmp23 == minor) {
#line 2106
    goto ldv_32577;
  } else {

  }
  }
#line 2104
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32579: ;
  {
#line 2104
  __cil_tmp24 = (adpt_hba *)0;
#line 2104
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 2104
  __cil_tmp26 = (unsigned long )pHba;
#line 2104
  if (__cil_tmp26 != __cil_tmp25) {
#line 2105
    goto ldv_32578;
  } else {
#line 2107
    goto ldv_32577;
  }
  }
  ldv_32577: 
  {
#line 2109
  mutex_unlock(& adpt_configuration_lock);
  }
  {
#line 2110
  __cil_tmp27 = (adpt_hba *)0;
#line 2110
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 2110
  __cil_tmp29 = (unsigned long )pHba;
#line 2110
  if (__cil_tmp29 == __cil_tmp28) {
#line 2111
    return (-6);
  } else {

  }
  }
#line 2114
  goto ldv_32581;
  ldv_32580: 
  {
#line 2115
  schedule_timeout_uninterruptible(2L);
  }
  ldv_32581: ;
  {
#line 2114
  __cil_tmp30 = (unsigned long )pHba;
#line 2114
  __cil_tmp31 = __cil_tmp30 + 24;
#line 2114
  __cil_tmp32 = *((u32 *)__cil_tmp31);
#line 2114
  __cil_tmp33 = (int )__cil_tmp32;
#line 2114
  if (__cil_tmp33 & 1) {
#line 2115
    goto ldv_32580;
  } else {
#line 2117
    goto ldv_32582;
  }
  }
  ldv_32582: ;
#line 2119
  if ((int )cmd == -2142157757) {
#line 2119
    goto case_neg_2142157757;
  } else
#line 2124
  if ((int )cmd == 17484) {
#line 2124
    goto case_17484;
  } else
#line 2127
  if ((int )cmd == -2143796155) {
#line 2127
    goto case_neg_2143796155;
  } else
#line 2147
  if ((int )cmd == -2141436856) {
#line 2147
    goto case_neg_2141436856;
  } else
#line 2149
  if ((int )cmd == -2147204021) {
#line 2149
    goto case_neg_2147204021;
  } else
#line 2157
  if ((int )cmd == 17486) {
#line 2157
    goto case_17486;
  } else
#line 2164
  if ((int )cmd == 17485) {
#line 2164
    goto case_17485;
  } else {
    {
#line 2167
    goto switch_default;
#line 2117
    if (0) {
      case_neg_2142157757: /* CIL Label */ 
      {
#line 2120
      __cil_tmp34 = (void    *)(& DPTI_sig);
#line 2120
      tmp___0 = copy_to_user(argp, __cil_tmp34, 81U);
      }
#line 2120
      if (tmp___0 != 0) {
#line 2121
        return (-14);
      } else {

      }
#line 2123
      goto ldv_32584;
      case_17484: /* CIL Label */ 
      {
#line 2125
      __cil_tmp35 = (u32 *)argp;
#line 2125
      tmp___1 = adpt_i2o_passthru(pHba, __cil_tmp35);
      }
#line 2125
      return (tmp___1);
      case_neg_2143796155: /* CIL Label */ 
      {
#line 2133
      __cil_tmp36 = (void *)(& HbaInfo);
#line 2133
      memset(__cil_tmp36, 0, 28UL);
#line 2134
      __cil_tmp37 = (unsigned long )(& HbaInfo) + 2;
#line 2134
      __cil_tmp38 = (unsigned long )pHba;
#line 2134
      __cil_tmp39 = __cil_tmp38 + 104;
#line 2134
      __cil_tmp40 = *((int *)__cil_tmp39);
#line 2134
      *((uSHORT *)__cil_tmp37) = (uSHORT )__cil_tmp40;
#line 2135
      __cil_tmp41 = (unsigned long )(& HbaInfo) + 4;
#line 2135
      __cil_tmp42 = (unsigned long )pHba;
#line 2135
      __cil_tmp43 = __cil_tmp42 + 224;
#line 2135
      __cil_tmp44 = *((ulong *)__cil_tmp43);
#line 2135
      *((uINT *)__cil_tmp41) = (uINT )__cil_tmp44;
#line 2136
      tmp___2 = adpt_read_blink_led(pHba);
#line 2136
      __cil_tmp45 = (unsigned long )(& HbaInfo) + 8;
#line 2136
      *((uSHORT *)__cil_tmp45) = (uSHORT )tmp___2;
#line 2137
      __cil_tmp46 = (unsigned long )(& HbaInfo) + 10;
#line 2137
      __cil_tmp47 = (unsigned long )pHba;
#line 2137
      __cil_tmp48 = __cil_tmp47 + 8;
#line 2137
      __cil_tmp49 = *((struct pci_dev **)__cil_tmp48);
#line 2137
      __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 2137
      __cil_tmp51 = __cil_tmp50 + 16;
#line 2137
      __cil_tmp52 = *((struct pci_bus **)__cil_tmp51);
#line 2137
      __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 2137
      __cil_tmp54 = __cil_tmp53 + 152;
#line 2137
      *((uCHAR *)__cil_tmp46) = *((unsigned char *)__cil_tmp54);
#line 2138
      __cil_tmp55 = (unsigned long )(& HbaInfo) + 11;
#line 2138
      __cil_tmp56 = (unsigned long )pHba;
#line 2138
      __cil_tmp57 = __cil_tmp56 + 8;
#line 2138
      __cil_tmp58 = *((struct pci_dev **)__cil_tmp57);
#line 2138
      __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 2138
      __cil_tmp60 = __cil_tmp59 + 56;
#line 2138
      __cil_tmp61 = *((unsigned int *)__cil_tmp60);
#line 2138
      __cil_tmp62 = __cil_tmp61 >> 3;
#line 2138
      __cil_tmp63 = (uCHAR )__cil_tmp62;
#line 2138
      __cil_tmp64 = (unsigned int )__cil_tmp63;
#line 2138
      __cil_tmp65 = __cil_tmp64 & 31U;
#line 2138
      *((uCHAR *)__cil_tmp55) = (uCHAR )__cil_tmp65;
#line 2139
      __cil_tmp66 = (unsigned long )(& HbaInfo) + 14;
#line 2139
      __cil_tmp67 = (unsigned long )pHba;
#line 2139
      __cil_tmp68 = __cil_tmp67 + 8;
#line 2139
      __cil_tmp69 = *((struct pci_dev **)__cil_tmp68);
#line 2139
      __cil_tmp70 = (unsigned long )__cil_tmp69;
#line 2139
      __cil_tmp71 = __cil_tmp70 + 1300;
#line 2139
      __cil_tmp72 = *((unsigned int *)__cil_tmp71);
#line 2139
      *((uSHORT *)__cil_tmp66) = (uSHORT )__cil_tmp72;
#line 2140
      __cil_tmp73 = (unsigned long )(& HbaInfo) + 12;
#line 2140
      *((uSHORT *)__cil_tmp73) = (uSHORT )7U;
#line 2141
      __cil_tmp74 = (void    *)(& HbaInfo);
#line 2141
      tmp___3 = copy_to_user(argp, __cil_tmp74, 28U);
      }
#line 2141
      if (tmp___3 != 0) {
        {
#line 2142
        __cil_tmp75 = (unsigned long )pHba;
#line 2142
        __cil_tmp76 = __cil_tmp75 + 114;
#line 2142
        __cil_tmp77 = (char (*)[32U])__cil_tmp76;
#line 2142
        __cil_tmp78 = (char *)__cil_tmp77;
#line 2142
        printk("<4>%s: Could not copy HbaInfo TO user\n", __cil_tmp78);
        }
#line 2143
        return (-14);
      } else {

      }
#line 2145
      goto ldv_32584;
      case_neg_2141436856: /* CIL Label */ 
      {
#line 2148
      tmp___4 = adpt_system_info(argp);
      }
#line 2148
      return (tmp___4);
      case_neg_2147204021: /* CIL Label */ 
      {
#line 2151
      tmp___5 = adpt_read_blink_led(pHba);
#line 2151
      __cil_tmp79 = & value;
#line 2151
      *__cil_tmp79 = (unsigned int )tmp___5;
#line 2152
      __cil_tmp80 = (void    *)(& value);
#line 2152
      tmp___6 = copy_to_user(argp, __cil_tmp80, 4U);
      }
#line 2152
      if (tmp___6 != 0) {
#line 2153
        return (-14);
      } else {

      }
#line 2155
      goto ldv_32584;
      case_17486: /* CIL Label */ ;
      {
#line 2158
      __cil_tmp81 = (struct Scsi_Host *)0;
#line 2158
      __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 2158
      __cil_tmp83 = (unsigned long )pHba;
#line 2158
      __cil_tmp84 = __cil_tmp83 + 16;
#line 2158
      __cil_tmp85 = *((struct Scsi_Host **)__cil_tmp84);
#line 2158
      __cil_tmp86 = (unsigned long )__cil_tmp85;
#line 2158
      if (__cil_tmp86 != __cil_tmp82) {
        {
#line 2159
        ldv_spin_lock();
        }
      } else {

      }
      }
      {
#line 2160
      adpt_hba_reset(pHba);
      }
      {
#line 2161
      __cil_tmp87 = (struct Scsi_Host *)0;
#line 2161
      __cil_tmp88 = (unsigned long )__cil_tmp87;
#line 2161
      __cil_tmp89 = (unsigned long )pHba;
#line 2161
      __cil_tmp90 = __cil_tmp89 + 16;
#line 2161
      __cil_tmp91 = *((struct Scsi_Host **)__cil_tmp90);
#line 2161
      __cil_tmp92 = (unsigned long )__cil_tmp91;
#line 2161
      if (__cil_tmp92 != __cil_tmp88) {
        {
#line 2162
        __cil_tmp93 = (unsigned long )pHba;
#line 2162
        __cil_tmp94 = __cil_tmp93 + 16;
#line 2162
        __cil_tmp95 = *((struct Scsi_Host **)__cil_tmp94);
#line 2162
        __cil_tmp96 = (unsigned long )__cil_tmp95;
#line 2162
        __cil_tmp97 = __cil_tmp96 + 216;
#line 2162
        __cil_tmp98 = *((spinlock_t **)__cil_tmp97);
#line 2162
        spin_unlock_irqrestore(__cil_tmp98, flags);
        }
      } else {

      }
      }
#line 2163
      goto ldv_32584;
      case_17485: /* CIL Label */ 
      {
#line 2165
      adpt_rescan(pHba);
      }
#line 2166
      goto ldv_32584;
      switch_default: /* CIL Label */ ;
#line 2168
      return (-22);
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_32584: ;
#line 2171
  return (error);
}
}
#line 2174 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static long adpt_unlocked_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ struct inode *inode ;
  long ret ;
  int tmp ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct dentry *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;

  {
  {
#line 2179
  __cil_tmp7 = 16 + 8;
#line 2179
  __cil_tmp8 = (unsigned long )file;
#line 2179
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
#line 2179
  __cil_tmp10 = *((struct dentry **)__cil_tmp9);
#line 2179
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 2179
  __cil_tmp12 = __cil_tmp11 + 48;
#line 2179
  inode = *((struct inode **)__cil_tmp12);
#line 2181
  mutex_lock_nested(& adpt_mutex, 0U);
#line 2182
  tmp = adpt_ioctl(inode, file, cmd, arg);
#line 2182
  ret = (long )tmp;
#line 2183
  mutex_unlock(& adpt_mutex);
  }
#line 2185
  return (ret);
}
}
#line 2189 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static long compat_adpt_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ struct inode *inode ;
  long ret ;
  int tmp ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct dentry *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;

  {
  {
#line 2195
  __cil_tmp7 = 16 + 8;
#line 2195
  __cil_tmp8 = (unsigned long )file;
#line 2195
  __cil_tmp9 = __cil_tmp8 + __cil_tmp7;
#line 2195
  __cil_tmp10 = *((struct dentry **)__cil_tmp9);
#line 2195
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 2195
  __cil_tmp12 = __cil_tmp11 + 48;
#line 2195
  inode = *((struct inode **)__cil_tmp12);
#line 2197
  mutex_lock_nested(& adpt_mutex, 0U);
  }
#line 2200
  if ((int )cmd == -2142157757) {
#line 2200
    goto case_neg_2142157757;
  } else
#line 2201
  if ((int )cmd == 17484) {
#line 2201
    goto case_17484;
  } else
#line 2202
  if ((int )cmd == -2143796155) {
#line 2202
    goto case_neg_2143796155;
  } else
#line 2203
  if ((int )cmd == -2141436856) {
#line 2203
    goto case_neg_2141436856;
  } else
#line 2204
  if ((int )cmd == -2147204021) {
#line 2204
    goto case_neg_2147204021;
  } else
#line 2205
  if ((int )cmd == 17486) {
#line 2205
    goto case_17486;
  } else
#line 2206
  if ((int )cmd == 17485) {
#line 2206
    goto case_17485;
  } else
#line 2207
  if ((int )cmd == 17487) {
#line 2207
    goto case_17487;
  } else
#line 2208
  if ((int )cmd == -2145369009) {
#line 2208
    goto case_neg_2145369009;
  } else {
    {
#line 2211
    goto switch_default;
#line 2199
    if (0) {
      case_neg_2142157757: /* CIL Label */ ;
      case_17484: /* CIL Label */ ;
      case_neg_2143796155: /* CIL Label */ ;
      case_neg_2141436856: /* CIL Label */ ;
      case_neg_2147204021: /* CIL Label */ ;
      case_17486: /* CIL Label */ ;
      case_17485: /* CIL Label */ ;
      case_17487: /* CIL Label */ ;
      case_neg_2145369009: /* CIL Label */ 
      {
#line 2209
      tmp = adpt_ioctl(inode, file, cmd, arg);
#line 2209
      ret = (long )tmp;
      }
#line 2210
      goto ldv_32617;
      switch_default: /* CIL Label */ 
#line 2212
      ret = -515L;
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_32617: 
  {
#line 2215
  mutex_unlock(& adpt_mutex);
  }
#line 2217
  return (ret);
}
}
#line 2221 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static irqreturn_t adpt_isr(int irq , void *dev_id ) 
{ struct scsi_cmnd *cmd ;
  adpt_hba *pHba ;
  u32 m ;
  void *reply ;
  u32 status ;
  u32 context ;
  ulong flags ;
  int handled ;
  u32 old_m ;
  unsigned int tmp ;
  void *msg ;
  u32 old_context ;
  unsigned int tmp___0 ;
  void *p ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  adpt_hba *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct Scsi_Host *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct Scsi_Host *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  void  volatile   *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  void  volatile   *__cil_tmp38 ;
  dma_addr_t __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  dma_addr_t __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  u32 __cil_tmp45 ;
  u32 __cil_tmp46 ;
  dma_addr_t __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  dma_addr_t __cil_tmp50 ;
  dma_addr_t __cil_tmp51 ;
  dma_addr_t __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  dma_addr_t __cil_tmp55 ;
  dma_addr_t __cil_tmp56 ;
  dma_addr_t __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  u32 *__cil_tmp61 ;
  void *__cil_tmp62 ;
  phys_addr_t __cil_tmp63 ;
  phys_addr_t __cil_tmp64 ;
  void  volatile   *__cil_tmp65 ;
  unsigned int __cil_tmp66 ;
  void  volatile   *__cil_tmp67 ;
  void  volatile   *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  char (*__cil_tmp71)[32U] ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  void *__cil_tmp75 ;
  void volatile   *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  void *__cil_tmp80 ;
  void  volatile   *__cil_tmp81 ;
  void  volatile   *__cil_tmp82 ;
  void volatile   *__cil_tmp83 ;
  void volatile   *__cil_tmp84 ;
  void  volatile   *__cil_tmp85 ;
  void  volatile   *__cil_tmp86 ;
  unsigned int __cil_tmp87 ;
  void  volatile   *__cil_tmp88 ;
  void  volatile   *__cil_tmp89 ;
  void *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  void  volatile   *__cil_tmp93 ;
  int __cil_tmp94 ;
  void  volatile   *__cil_tmp95 ;
  void  volatile   *__cil_tmp96 ;
  u32 __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  void  volatile   *__cil_tmp99 ;
  void  volatile   *__cil_tmp100 ;
  struct scsi_cmnd *__cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  char (*__cil_tmp106)[32U] ;
  char *__cil_tmp107 ;
  int __cil_tmp108 ;
  void  volatile   *__cil_tmp109 ;
  void  volatile   *__cil_tmp110 ;
  struct scsi_cmnd *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  void *__cil_tmp119 ;
  void volatile   *__cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  void *__cil_tmp123 ;
  void  volatile   *__cil_tmp124 ;
  unsigned int __cil_tmp125 ;
  struct Scsi_Host *__cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  struct Scsi_Host *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  struct Scsi_Host *__cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  spinlock_t *__cil_tmp137 ;
  int __cil_tmp138 ;

  {
#line 2224
  pHba = (adpt_hba *)dev_id;
#line 2227
  status = 0U;
#line 2229
  flags = 0UL;
#line 2230
  handled = 0;
  {
#line 2232
  __cil_tmp22 = (adpt_hba *)0;
#line 2232
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 2232
  __cil_tmp24 = (unsigned long )pHba;
#line 2232
  if (__cil_tmp24 == __cil_tmp23) {
    {
#line 2233
    printk("<4>adpt_isr: NULL dev_id\n");
    }
#line 2234
    return ((irqreturn_t )0);
  } else {

  }
  }
  {
#line 2236
  __cil_tmp25 = (struct Scsi_Host *)0;
#line 2236
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 2236
  __cil_tmp27 = (unsigned long )pHba;
#line 2236
  __cil_tmp28 = __cil_tmp27 + 16;
#line 2236
  __cil_tmp29 = *((struct Scsi_Host **)__cil_tmp28);
#line 2236
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 2236
  if (__cil_tmp30 != __cil_tmp26) {
    {
#line 2237
    ldv_spin_lock();
    }
  } else {

  }
  }
#line 2239
  goto ldv_32635;
  ldv_32637: 
  {
#line 2240
  __cil_tmp31 = (unsigned long )pHba;
#line 2240
  __cil_tmp32 = __cil_tmp31 + 240;
#line 2240
  __cil_tmp33 = *((void **)__cil_tmp32);
#line 2240
  __cil_tmp34 = (void  volatile   *)__cil_tmp33;
#line 2240
  m = readl(__cil_tmp34);
  }
#line 2241
  if (m == 4294967295U) {
    {
#line 2243
    __asm__  volatile   ("lfence": : : "memory");
#line 2244
    __cil_tmp35 = (unsigned long )pHba;
#line 2244
    __cil_tmp36 = __cil_tmp35 + 240;
#line 2244
    __cil_tmp37 = *((void **)__cil_tmp36);
#line 2244
    __cil_tmp38 = (void  volatile   *)__cil_tmp37;
#line 2244
    m = readl(__cil_tmp38);
    }
#line 2245
    if (m == 4294967295U) {
      {
#line 2247
      printk("<3>dpti: Could not get reply frame\n");
      }
#line 2248
      goto out;
    } else {

    }
  } else {

  }
  {
#line 2251
  __cil_tmp39 = (dma_addr_t )m;
#line 2251
  __cil_tmp40 = (unsigned long )pHba;
#line 2251
  __cil_tmp41 = __cil_tmp40 + 280;
#line 2251
  __cil_tmp42 = *((dma_addr_t *)__cil_tmp41);
#line 2251
  if (__cil_tmp42 <= __cil_tmp39) {
    {
#line 2251
    __cil_tmp43 = (unsigned long )pHba;
#line 2251
    __cil_tmp44 = __cil_tmp43 + 264;
#line 2251
    __cil_tmp45 = *((u32 *)__cil_tmp44);
#line 2251
    __cil_tmp46 = __cil_tmp45 * 68U;
#line 2251
    __cil_tmp47 = (dma_addr_t )__cil_tmp46;
#line 2251
    __cil_tmp48 = (unsigned long )pHba;
#line 2251
    __cil_tmp49 = __cil_tmp48 + 280;
#line 2251
    __cil_tmp50 = *((dma_addr_t *)__cil_tmp49);
#line 2251
    __cil_tmp51 = __cil_tmp50 + __cil_tmp47;
#line 2251
    __cil_tmp52 = (dma_addr_t )m;
#line 2251
    if (__cil_tmp52 < __cil_tmp51) {
#line 2254
      __cil_tmp53 = (unsigned long )pHba;
#line 2254
      __cil_tmp54 = __cil_tmp53 + 280;
#line 2254
      __cil_tmp55 = *((dma_addr_t *)__cil_tmp54);
#line 2254
      __cil_tmp56 = (dma_addr_t )m;
#line 2254
      __cil_tmp57 = __cil_tmp56 - __cil_tmp55;
#line 2254
      __cil_tmp58 = (unsigned long )__cil_tmp57;
#line 2254
      __cil_tmp59 = (unsigned long )pHba;
#line 2254
      __cil_tmp60 = __cil_tmp59 + 272;
#line 2254
      __cil_tmp61 = *((u32 **)__cil_tmp60);
#line 2254
      __cil_tmp62 = (void *)__cil_tmp61;
#line 2254
      reply = __cil_tmp62 + __cil_tmp58;
    } else {
      {
#line 2258
      printk("<3>dpti: reply frame not from pool\n");
#line 2259
      __cil_tmp63 = (phys_addr_t )m;
#line 2259
      reply = phys_to_virt(__cil_tmp63);
      }
    }
    }
  } else {
    {
#line 2258
    printk("<3>dpti: reply frame not from pool\n");
#line 2259
    __cil_tmp64 = (phys_addr_t )m;
#line 2259
    reply = phys_to_virt(__cil_tmp64);
    }
  }
  }
  {
#line 2262
  __cil_tmp65 = (void  volatile   *)reply;
#line 2262
  tmp___0 = readl(__cil_tmp65);
  }
  {
#line 2262
  __cil_tmp66 = tmp___0 & 8192U;
#line 2262
  if (__cil_tmp66 != 0U) {
    {
#line 2263
    __cil_tmp67 = (void  volatile   *)reply;
#line 2263
    __cil_tmp68 = __cil_tmp67 + 28U;
#line 2263
    tmp = readl(__cil_tmp68);
#line 2263
    old_m = tmp;
    }
#line 2267
    if (old_m > 1048575U) {
      {
#line 2268
      __cil_tmp69 = (unsigned long )pHba;
#line 2268
      __cil_tmp70 = __cil_tmp69 + 114;
#line 2268
      __cil_tmp71 = (char (*)[32U])__cil_tmp70;
#line 2268
      __cil_tmp72 = (char *)__cil_tmp71;
#line 2268
      printk("<3>%s: Bad preserved MFA (%x)- dropping frame\n", __cil_tmp72, old_m);
#line 2269
      __cil_tmp73 = (unsigned long )pHba;
#line 2269
      __cil_tmp74 = __cil_tmp73 + 240;
#line 2269
      __cil_tmp75 = *((void **)__cil_tmp74);
#line 2269
      __cil_tmp76 = (void volatile   *)__cil_tmp75;
#line 2269
      writel(m, __cil_tmp76);
      }
#line 2270
      goto ldv_32635;
    } else {

    }
    {
#line 2273
    __cil_tmp77 = (unsigned long )old_m;
#line 2273
    __cil_tmp78 = (unsigned long )pHba;
#line 2273
    __cil_tmp79 = __cil_tmp78 + 216;
#line 2273
    __cil_tmp80 = *((void **)__cil_tmp79);
#line 2273
    msg = __cil_tmp80 + __cil_tmp77;
#line 2274
    __cil_tmp81 = (void  volatile   *)msg;
#line 2274
    __cil_tmp82 = __cil_tmp81 + 12U;
#line 2274
    old_context = readl(__cil_tmp82);
#line 2275
    __cil_tmp83 = (void volatile   *)reply;
#line 2275
    __cil_tmp84 = __cil_tmp83 + 12U;
#line 2275
    writel(old_context, __cil_tmp84);
#line 2276
    adpt_send_nop(pHba, old_m);
    }
  } else {

  }
  }
  {
#line 2278
  __cil_tmp85 = (void  volatile   *)reply;
#line 2278
  __cil_tmp86 = __cil_tmp85 + 8U;
#line 2278
  context = readl(__cil_tmp86);
  }
  {
#line 2279
  __cil_tmp87 = context & 1073741824U;
#line 2279
  if (__cil_tmp87 != 0U) {
    {
#line 2280
    __cil_tmp88 = (void  volatile   *)reply;
#line 2280
    __cil_tmp89 = __cil_tmp88 + 12U;
#line 2280
    tmp___1 = readl(__cil_tmp89);
#line 2280
    tmp___2 = adpt_ioctl_from_context(pHba, tmp___1);
#line 2280
    p = tmp___2;
    }
    {
#line 2281
    __cil_tmp90 = (void *)0;
#line 2281
    __cil_tmp91 = (unsigned long )__cil_tmp90;
#line 2281
    __cil_tmp92 = (unsigned long )p;
#line 2281
    if (__cil_tmp92 != __cil_tmp91) {
      {
#line 2282
      __cil_tmp93 = (void  volatile   *)reply;
#line 2282
      memcpy_fromio(p, __cil_tmp93, 68UL);
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 2286
  __cil_tmp94 = (int )context;
#line 2286
  if (__cil_tmp94 < 0) {
    {
#line 2287
    __cil_tmp95 = (void  volatile   *)reply;
#line 2287
    __cil_tmp96 = __cil_tmp95 + 16U;
#line 2287
    status = readl(__cil_tmp96);
    }
    {
#line 2288
    __cil_tmp97 = status >> 24;
#line 2288
    if (__cil_tmp97 != 0U) {
#line 2289
      status = status & 65535U;
    } else {
#line 2291
      status = 0U;
    }
    }
    {
#line 2293
    __cil_tmp98 = context & 1073741824U;
#line 2293
    if (__cil_tmp98 == 0U) {
      {
#line 2294
      __cil_tmp99 = (void  volatile   *)reply;
#line 2294
      __cil_tmp100 = __cil_tmp99 + 12U;
#line 2294
      tmp___3 = readl(__cil_tmp100);
#line 2294
      cmd = adpt_cmd_from_context(pHba, tmp___3);
      }
      {
#line 2296
      __cil_tmp101 = (struct scsi_cmnd *)0;
#line 2296
      __cil_tmp102 = (unsigned long )__cil_tmp101;
#line 2296
      __cil_tmp103 = (unsigned long )cmd;
#line 2296
      if (__cil_tmp103 != __cil_tmp102) {
        {
#line 2297
        __cil_tmp104 = (unsigned long )pHba;
#line 2297
        __cil_tmp105 = __cil_tmp104 + 114;
#line 2297
        __cil_tmp106 = (char (*)[32U])__cil_tmp105;
#line 2297
        __cil_tmp107 = (char *)__cil_tmp106;
#line 2297
        printk("<4>%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n",
               __cil_tmp107, cmd, context);
        }
      } else {

      }
      }
    } else {

    }
    }
    {
#line 2300
    __cil_tmp108 = (int )status;
#line 2300
    adpt_i2o_post_wait_complete(context, __cil_tmp108);
    }
  } else {
    {
#line 2302
    __cil_tmp109 = (void  volatile   *)reply;
#line 2302
    __cil_tmp110 = __cil_tmp109 + 12U;
#line 2302
    tmp___4 = readl(__cil_tmp110);
#line 2302
    cmd = adpt_cmd_from_context(pHba, tmp___4);
    }
    {
#line 2303
    __cil_tmp111 = (struct scsi_cmnd *)0;
#line 2303
    __cil_tmp112 = (unsigned long )__cil_tmp111;
#line 2303
    __cil_tmp113 = (unsigned long )cmd;
#line 2303
    if (__cil_tmp113 != __cil_tmp112) {
      {
#line 2304
      scsi_dma_unmap(cmd);
      }
      {
#line 2305
      __cil_tmp114 = (unsigned long )cmd;
#line 2305
      __cil_tmp115 = __cil_tmp114 + 48;
#line 2305
      __cil_tmp116 = *((unsigned long *)__cil_tmp115);
#line 2305
      if (__cil_tmp116 != 0UL) {
        {
#line 2306
        adpt_i2o_to_scsi(reply, cmd);
        }
      } else {

      }
      }
    } else {

    }
    }
  }
  }
  {
#line 2310
  __cil_tmp117 = (unsigned long )pHba;
#line 2310
  __cil_tmp118 = __cil_tmp117 + 240;
#line 2310
  __cil_tmp119 = *((void **)__cil_tmp118);
#line 2310
  __cil_tmp120 = (void volatile   *)__cil_tmp119;
#line 2310
  writel(m, __cil_tmp120);
#line 2311
  __asm__  volatile   ("sfence": : : "memory");
#line 2312
  __asm__  volatile   ("lfence": : : "memory");
  }
  ldv_32635: 
  {
#line 2239
  __cil_tmp121 = (unsigned long )pHba;
#line 2239
  __cil_tmp122 = __cil_tmp121 + 248;
#line 2239
  __cil_tmp123 = *((void **)__cil_tmp122);
#line 2239
  __cil_tmp124 = (void  volatile   *)__cil_tmp123;
#line 2239
  tmp___5 = readl(__cil_tmp124);
  }
  {
#line 2239
  __cil_tmp125 = tmp___5 & 8U;
#line 2239
  if (__cil_tmp125 != 0U) {
#line 2240
    goto ldv_32637;
  } else {
#line 2242
    goto ldv_32638;
  }
  }
  ldv_32638: 
#line 2314
  handled = 1;
  out: ;
  {
#line 2315
  __cil_tmp126 = (struct Scsi_Host *)0;
#line 2315
  __cil_tmp127 = (unsigned long )__cil_tmp126;
#line 2315
  __cil_tmp128 = (unsigned long )pHba;
#line 2315
  __cil_tmp129 = __cil_tmp128 + 16;
#line 2315
  __cil_tmp130 = *((struct Scsi_Host **)__cil_tmp129);
#line 2315
  __cil_tmp131 = (unsigned long )__cil_tmp130;
#line 2315
  if (__cil_tmp131 != __cil_tmp127) {
    {
#line 2316
    __cil_tmp132 = (unsigned long )pHba;
#line 2316
    __cil_tmp133 = __cil_tmp132 + 16;
#line 2316
    __cil_tmp134 = *((struct Scsi_Host **)__cil_tmp133);
#line 2316
    __cil_tmp135 = (unsigned long )__cil_tmp134;
#line 2316
    __cil_tmp136 = __cil_tmp135 + 216;
#line 2316
    __cil_tmp137 = *((spinlock_t **)__cil_tmp136);
#line 2316
    spin_unlock_irqrestore(__cil_tmp137, flags);
    }
  } else {

  }
  }
  {
#line 2317
  __cil_tmp138 = handled != 0;
#line 2317
  return ((irqreturn_t )__cil_tmp138);
  }
}
}
#line 2320 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_scsi_to_i2o(adpt_hba *pHba , struct scsi_cmnd *cmd , struct adpt_device *d ) 
{ int i ;
  u32 msg[128U] ;
  u32 *mptr ;
  u32 *lptr ;
  u32 *lenptr ;
  int direction ;
  int scsidir ;
  int nseg ;
  u32 len ;
  u32 reqlen ;
  s32 rcode ;
  dma_addr_t addr ;
  size_t __len ;
  void *__ret ;
  u32 *tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  struct scatterlist *sg ;
  u32 *tmp___4 ;
  u32 *tmp___5 ;
  u32 *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  enum dma_data_direction __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  char (*__cil_tmp36)[32U] ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  unsigned char __cil_tmp41 ;
  int __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  void (*__cil_tmp47)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  u16 __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  u16 __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned short __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  u32 *__cil_tmp74 ;
  void *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned short __cil_tmp78 ;
  void *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned char *__cil_tmp82 ;
  void    *__cil_tmp83 ;
  int __cil_tmp84 ;
  long __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned int __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  int __cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  long __cil_tmp102 ;
  long __cil_tmp103 ;
  long __cil_tmp104 ;
  long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned int __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  u32 __cil_tmp117 ;
  u32 *__cil_tmp118 ;
  u32 __cil_tmp119 ;
  int __cil_tmp120 ;

  {
  {
#line 2335
  __cil_tmp29 = (void *)(& msg);
#line 2335
  memset(__cil_tmp29, 0, 512UL);
#line 2336
  len = scsi_bufflen(cmd);
#line 2337
  direction = 0;
#line 2339
  scsidir = 0;
  }
#line 2340
  if (len != 0U) {
    {
#line 2347
    __cil_tmp30 = (unsigned long )cmd;
#line 2347
    __cil_tmp31 = __cil_tmp30 + 76;
#line 2347
    __cil_tmp32 = *((enum dma_data_direction *)__cil_tmp31);
#line 2347
    __cil_tmp33 = (unsigned int )__cil_tmp32;
#line 2348
    if ((int )__cil_tmp33 == 2) {
#line 2348
      goto case_2;
    } else
#line 2351
    if ((int )__cil_tmp33 == 1) {
#line 2351
      goto case_1;
    } else
#line 2355
    if ((int )__cil_tmp33 == 3) {
#line 2355
      goto case_3;
    } else
#line 2357
    if ((int )__cil_tmp33 == 0) {
#line 2357
      goto case_0;
    } else {
      {
#line 2361
      goto switch_default;
#line 2347
      if (0) {
        case_2: /* CIL Label */ 
#line 2349
        scsidir = 1073741824;
#line 2350
        goto ldv_32657;
        case_1: /* CIL Label */ 
#line 2352
        direction = 67108864;
#line 2353
        scsidir = (-0x7FFFFFFF-1);
#line 2354
        goto ldv_32657;
        case_3: /* CIL Label */ ;
#line 2356
        goto ldv_32657;
        case_0: /* CIL Label */ 
#line 2358
        scsidir = 1073741824;
#line 2360
        goto ldv_32657;
        switch_default: /* CIL Label */ 
        {
#line 2362
        __cil_tmp34 = (unsigned long )pHba;
#line 2362
        __cil_tmp35 = __cil_tmp34 + 114;
#line 2362
        __cil_tmp36 = (char (*)[32U])__cil_tmp35;
#line 2362
        __cil_tmp37 = (char *)__cil_tmp36;
#line 2362
        __cil_tmp38 = (unsigned long )cmd;
#line 2362
        __cil_tmp39 = __cil_tmp38 + 80;
#line 2362
        __cil_tmp40 = *((unsigned char **)__cil_tmp39);
#line 2362
        __cil_tmp41 = *__cil_tmp40;
#line 2362
        __cil_tmp42 = (int )__cil_tmp41;
#line 2362
        printk("<4>%s: scsi opcode 0x%x not supported.\n", __cil_tmp37, __cil_tmp42);
#line 2364
        __cil_tmp43 = (unsigned long )cmd;
#line 2364
        __cil_tmp44 = __cil_tmp43 + 224;
#line 2364
        *((int *)__cil_tmp44) = 1280;
#line 2365
        __cil_tmp45 = (unsigned long )cmd;
#line 2365
        __cil_tmp46 = __cil_tmp45 + 144;
#line 2365
        __cil_tmp47 = *((void (**)(struct scsi_cmnd * ))__cil_tmp46);
#line 2365
        (*__cil_tmp47)(cmd);
        }
#line 2366
        return (0);
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
    }
    ldv_32657: ;
  } else {

  }
  {
#line 2371
  __cil_tmp48 = 1 * 4UL;
#line 2371
  __cil_tmp49 = (unsigned long )(msg) + __cil_tmp48;
#line 2371
  __cil_tmp50 = (unsigned long )d;
#line 2371
  __cil_tmp51 = __cil_tmp50 + 28;
#line 2371
  __cil_tmp52 = *((u16 *)__cil_tmp51);
#line 2371
  __cil_tmp53 = (int )__cil_tmp52;
#line 2371
  __cil_tmp54 = __cil_tmp53 | -16773120;
#line 2371
  *((u32 *)__cil_tmp49) = (u32 )__cil_tmp54;
#line 2372
  __cil_tmp55 = 2 * 4UL;
#line 2372
  __cil_tmp56 = (unsigned long )(msg) + __cil_tmp55;
#line 2372
  *((u32 *)__cil_tmp56) = 0U;
#line 2373
  __cil_tmp57 = 3 * 4UL;
#line 2373
  __cil_tmp58 = (unsigned long )(msg) + __cil_tmp57;
#line 2373
  *((u32 *)__cil_tmp58) = adpt_cmd_to_context(cmd);
#line 2376
  __cil_tmp59 = 4 * 4UL;
#line 2376
  __cil_tmp60 = (unsigned long )(msg) + __cil_tmp59;
#line 2376
  *((u32 *)__cil_tmp60) = 1769601U;
#line 2377
  __cil_tmp61 = 5 * 4UL;
#line 2377
  __cil_tmp62 = (unsigned long )(msg) + __cil_tmp61;
#line 2377
  __cil_tmp63 = (unsigned long )d;
#line 2377
  __cil_tmp64 = __cil_tmp63 + 28;
#line 2377
  __cil_tmp65 = *((u16 *)__cil_tmp64);
#line 2377
  *((u32 *)__cil_tmp62) = (u32 )__cil_tmp65;
#line 2382
  __cil_tmp66 = 6 * 4UL;
#line 2382
  __cil_tmp67 = (unsigned long )(msg) + __cil_tmp66;
#line 2382
  __cil_tmp68 = (unsigned long )cmd;
#line 2382
  __cil_tmp69 = __cil_tmp68 + 74;
#line 2382
  __cil_tmp70 = *((unsigned short *)__cil_tmp69);
#line 2382
  __cil_tmp71 = (int )__cil_tmp70;
#line 2382
  __cil_tmp72 = scsidir | 547356672;
#line 2382
  __cil_tmp73 = __cil_tmp72 | __cil_tmp71;
#line 2382
  *((u32 *)__cil_tmp67) = (u32 )__cil_tmp73;
#line 2384
  __cil_tmp74 = (u32 *)(& msg);
#line 2384
  mptr = __cil_tmp74 + 7UL;
#line 2387
  __cil_tmp75 = (void *)mptr;
#line 2387
  memset(__cil_tmp75, 0, 16UL);
#line 2388
  __cil_tmp76 = (unsigned long )cmd;
#line 2388
  __cil_tmp77 = __cil_tmp76 + 74;
#line 2388
  __cil_tmp78 = *((unsigned short *)__cil_tmp77);
#line 2388
  __len = (size_t )__cil_tmp78;
#line 2388
  __cil_tmp79 = (void *)mptr;
#line 2388
  __cil_tmp80 = (unsigned long )cmd;
#line 2388
  __cil_tmp81 = __cil_tmp80 + 80;
#line 2388
  __cil_tmp82 = *((unsigned char **)__cil_tmp81);
#line 2388
  __cil_tmp83 = (void    *)__cil_tmp82;
#line 2388
  __ret = __builtin_memcpy(__cil_tmp79, __cil_tmp83, __len);
#line 2389
  mptr = mptr + 4UL;
#line 2390
  tmp = mptr;
#line 2390
  mptr = mptr + 1;
#line 2390
  lenptr = tmp;
#line 2391
  tmp___2 = dpt_dma64(pHba);
  }
#line 2391
  if (tmp___2 != 0) {
#line 2392
    reqlen = 16U;
#line 2393
    tmp___0 = mptr;
#line 2393
    mptr = mptr + 1;
#line 2393
    *tmp___0 = 2080505858U;
#line 2394
    tmp___1 = mptr;
#line 2394
    mptr = mptr + 1;
#line 2394
    *tmp___1 = 4096U;
  } else {
#line 2396
    reqlen = 14U;
  }
  {
#line 2400
  nseg = scsi_dma_map(cmd);
#line 2401
  __cil_tmp84 = nseg < 0;
#line 2401
  __cil_tmp85 = (long )__cil_tmp84;
#line 2401
  tmp___3 = __builtin_expect(__cil_tmp85, 0L);
  }
#line 2401
  if (tmp___3 != 0L) {
#line 2401
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"),
                         "i" (2401), "i" (12UL));
    ldv_32665: ;
#line 2401
    goto ldv_32665;
  } else {

  }
#line 2402
  if (nseg != 0) {
    {
#line 2405
    len = 0U;
#line 2406
    i = 0;
#line 2406
    sg = scsi_sglist(cmd);
    }
#line 2406
    goto ldv_32668;
    ldv_32667: 
    {
#line 2407
    lptr = mptr;
#line 2408
    tmp___4 = mptr;
#line 2408
    mptr = mptr + 1;
#line 2408
    __cil_tmp86 = (unsigned int )direction;
#line 2408
    __cil_tmp87 = (unsigned long )sg;
#line 2408
    __cil_tmp88 = __cil_tmp87 + 32;
#line 2408
    __cil_tmp89 = *((unsigned int *)__cil_tmp88);
#line 2408
    __cil_tmp90 = __cil_tmp89 | __cil_tmp86;
#line 2408
    *tmp___4 = __cil_tmp90 | 268435456U;
#line 2409
    __cil_tmp91 = (unsigned long )sg;
#line 2409
    __cil_tmp92 = __cil_tmp91 + 32;
#line 2409
    __cil_tmp93 = *((unsigned int *)__cil_tmp92);
#line 2409
    len = __cil_tmp93 + len;
#line 2410
    __cil_tmp94 = (unsigned long )sg;
#line 2410
    __cil_tmp95 = __cil_tmp94 + 24;
#line 2410
    addr = *((dma_addr_t *)__cil_tmp95);
#line 2411
    tmp___5 = mptr;
#line 2411
    mptr = mptr + 1;
#line 2411
    *tmp___5 = dma_low(addr);
#line 2412
    tmp___7 = dpt_dma64(pHba);
    }
#line 2412
    if (tmp___7 != 0) {
      {
#line 2413
      tmp___6 = mptr;
#line 2413
      mptr = mptr + 1;
#line 2413
      *tmp___6 = dma_high(addr);
      }
    } else {

    }
    {
#line 2415
    __cil_tmp96 = nseg + -1;
#line 2415
    if (__cil_tmp96 == i) {
#line 2416
      __cil_tmp97 = (unsigned int )direction;
#line 2416
      __cil_tmp98 = (unsigned long )sg;
#line 2416
      __cil_tmp99 = __cil_tmp98 + 32;
#line 2416
      __cil_tmp100 = *((unsigned int *)__cil_tmp99);
#line 2416
      __cil_tmp101 = __cil_tmp100 | __cil_tmp97;
#line 2416
      *lptr = __cil_tmp101 | 3489660928U;
    } else {

    }
    }
    {
#line 2406
    i = i + 1;
#line 2406
    sg = sg_next(sg);
    }
    ldv_32668: ;
#line 2406
    if (i < nseg) {
#line 2407
      goto ldv_32667;
    } else {
#line 2409
      goto ldv_32669;
    }
    ldv_32669: 
#line 2418
    __cil_tmp102 = (long )(& msg);
#line 2418
    __cil_tmp103 = (long )mptr;
#line 2418
    __cil_tmp104 = __cil_tmp103 - __cil_tmp102;
#line 2418
    __cil_tmp105 = __cil_tmp104 / 4L;
#line 2418
    reqlen = (u32 )__cil_tmp105;
#line 2419
    *lenptr = len;
    {
#line 2421
    __cil_tmp106 = (unsigned long )cmd;
#line 2421
    __cil_tmp107 = __cil_tmp106 + 120;
#line 2421
    __cil_tmp108 = *((unsigned int *)__cil_tmp107);
#line 2421
    if (__cil_tmp108 != 0U) {
      {
#line 2421
      __cil_tmp109 = (unsigned long )cmd;
#line 2421
      __cil_tmp110 = __cil_tmp109 + 120;
#line 2421
      __cil_tmp111 = *((unsigned int *)__cil_tmp110);
#line 2421
      if (__cil_tmp111 != len) {
        {
#line 2422
        __cil_tmp112 = (unsigned long )cmd;
#line 2422
        __cil_tmp113 = __cil_tmp112 + 120;
#line 2422
        __cil_tmp114 = *((unsigned int *)__cil_tmp113);
#line 2422
        printk("<4>Cmd len %08X Cmd underflow %08X\n", len, __cil_tmp114);
        }
      } else {

      }
      }
    } else {

    }
    }
  } else {
#line 2426
    len = 0U;
#line 2426
    *lenptr = len;
#line 2427
    reqlen = 12U;
  }
#line 2431
  if (reqlen > 12U) {
#line 2431
    tmp___8 = 193U;
  } else {
#line 2431
    tmp___8 = 1U;
  }
  {
#line 2431
  __cil_tmp115 = 0 * 4UL;
#line 2431
  __cil_tmp116 = (unsigned long )(msg) + __cil_tmp115;
#line 2431
  __cil_tmp117 = reqlen << 16;
#line 2431
  *((u32 *)__cil_tmp116) = __cil_tmp117 | tmp___8;
#line 2434
  __cil_tmp118 = (u32 *)(& msg);
#line 2434
  __cil_tmp119 = reqlen << 2;
#line 2434
  __cil_tmp120 = (int )__cil_tmp119;
#line 2434
  rcode = adpt_i2o_post_this(pHba, __cil_tmp118, __cil_tmp120);
  }
#line 2435
  if (rcode == 0) {
#line 2436
    return (0);
  } else {

  }
#line 2438
  return (rcode);
}
}
#line 2442 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_scsi_host_alloc(adpt_hba *pHba , struct scsi_host_template *sht ) 
{ struct Scsi_Host *host ;
  struct Scsi_Host *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char (*__cil_tmp9)[32U] ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct pci_dev *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  u8 __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  dma_addr_t *__cil_tmp47 ;
  dma_addr_t __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  u32 __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  u32 __cil_tmp59 ;

  {
  {
#line 2446
  host = scsi_host_alloc(sht, 8);
  }
  {
#line 2447
  __cil_tmp4 = (struct Scsi_Host *)0;
#line 2447
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 2447
  __cil_tmp6 = (unsigned long )host;
#line 2447
  if (__cil_tmp6 == __cil_tmp5) {
    {
#line 2448
    __cil_tmp7 = (unsigned long )pHba;
#line 2448
    __cil_tmp8 = __cil_tmp7 + 114;
#line 2448
    __cil_tmp9 = (char (*)[32U])__cil_tmp8;
#line 2448
    __cil_tmp10 = (char *)__cil_tmp9;
#line 2448
    printk("%s: scsi_host_alloc returned NULL\n", __cil_tmp10);
    }
#line 2449
    return (-1);
  } else {

  }
  }
#line 2451
  __cil_tmp11 = 0 * 8UL;
#line 2451
  __cil_tmp12 = 3048 + __cil_tmp11;
#line 2451
  __cil_tmp13 = (unsigned long )host;
#line 2451
  __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 2451
  *((unsigned long *)__cil_tmp14) = (unsigned long )pHba;
#line 2452
  __cil_tmp15 = (unsigned long )pHba;
#line 2452
  __cil_tmp16 = __cil_tmp15 + 16;
#line 2452
  *((struct Scsi_Host **)__cil_tmp16) = host;
#line 2454
  __cil_tmp17 = (unsigned long )host;
#line 2454
  __cil_tmp18 = __cil_tmp17 + 700;
#line 2454
  __cil_tmp19 = (unsigned long )pHba;
#line 2454
  __cil_tmp20 = __cil_tmp19 + 8;
#line 2454
  __cil_tmp21 = *((struct pci_dev **)__cil_tmp20);
#line 2454
  __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 2454
  __cil_tmp23 = __cil_tmp22 + 1300;
#line 2454
  *((unsigned int *)__cil_tmp18) = *((unsigned int *)__cil_tmp23);
#line 2458
  __cil_tmp24 = (unsigned long )host;
#line 2458
  __cil_tmp25 = __cil_tmp24 + 688;
#line 2458
  *((unsigned long *)__cil_tmp25) = 0UL;
#line 2459
  __cil_tmp26 = (unsigned long )host;
#line 2459
  __cil_tmp27 = __cil_tmp26 + 696;
#line 2459
  *((unsigned char *)__cil_tmp27) = (unsigned char)0;
#line 2461
  __cil_tmp28 = (unsigned long )host;
#line 2461
  __cil_tmp29 = __cil_tmp28 + 568;
#line 2461
  *((unsigned int *)__cil_tmp29) = 16U;
#line 2462
  __cil_tmp30 = (unsigned long )host;
#line 2462
  __cil_tmp31 = __cil_tmp30 + 572;
#line 2462
  *((unsigned int *)__cil_tmp31) = 256U;
#line 2463
  __cil_tmp32 = (unsigned long )host;
#line 2463
  __cil_tmp33 = __cil_tmp32 + 576;
#line 2463
  __cil_tmp34 = (unsigned long )pHba;
#line 2463
  __cil_tmp35 = __cil_tmp34 + 292;
#line 2463
  __cil_tmp36 = *((u8 *)__cil_tmp35);
#line 2463
  __cil_tmp37 = (int )__cil_tmp36;
#line 2463
  __cil_tmp38 = __cil_tmp37 + 1;
#line 2463
  *((unsigned int *)__cil_tmp33) = (unsigned int )__cil_tmp38;
#line 2464
  __cil_tmp39 = (unsigned long )host;
#line 2464
  __cil_tmp40 = __cil_tmp39 + 596;
#line 2464
  *((short *)__cil_tmp40) = (short)1;
#line 2465
  __cil_tmp41 = (unsigned long )host;
#line 2465
  __cil_tmp42 = __cil_tmp41 + 580;
#line 2465
  __cil_tmp43 = (unsigned long )pHba;
#line 2465
  __cil_tmp44 = __cil_tmp43 + 104;
#line 2465
  __cil_tmp45 = *((int *)__cil_tmp44);
#line 2465
  __cil_tmp46 = (unsigned int )__cil_tmp45;
#line 2465
  __cil_tmp47 = & sys_tbl_pa;
#line 2465
  __cil_tmp48 = *__cil_tmp47;
#line 2465
  __cil_tmp49 = (unsigned int )__cil_tmp48;
#line 2465
  *((unsigned int *)__cil_tmp42) = __cil_tmp49 + __cil_tmp46;
#line 2466
  __cil_tmp50 = (unsigned long )host;
#line 2466
  __cil_tmp51 = __cil_tmp50 + 598;
#line 2466
  __cil_tmp52 = (unsigned long )pHba;
#line 2466
  __cil_tmp53 = __cil_tmp52 + 288;
#line 2466
  __cil_tmp54 = *((u32 *)__cil_tmp53);
#line 2466
  *((unsigned short *)__cil_tmp51) = (unsigned short )__cil_tmp54;
#line 2467
  __cil_tmp55 = (unsigned long )host;
#line 2467
  __cil_tmp56 = __cil_tmp55 + 592;
#line 2467
  __cil_tmp57 = (unsigned long )pHba;
#line 2467
  __cil_tmp58 = __cil_tmp57 + 260;
#line 2467
  __cil_tmp59 = *((u32 *)__cil_tmp58);
#line 2467
  *((int *)__cil_tmp56) = (int )__cil_tmp59;
#line 2469
  return (0);
}
}
#line 2473 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_to_scsi(void *reply , struct scsi_cmnd *cmd ) 
{ adpt_hba *pHba ;
  u32 hba_status ;
  u32 dev_status ;
  u32 reply_flags ;
  unsigned int tmp ;
  u16 detailed_status ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  u32 len ;
  int _min1 ;
  int _min2 ;
  int tmp___4 ;
  void  volatile   *__cil_tmp17 ;
  void  volatile   *__cil_tmp18 ;
  void  volatile   *__cil_tmp19 ;
  u32 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void  volatile   *__cil_tmp23 ;
  void  volatile   *__cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct scsi_device *__cil_tmp29 ;
  struct Scsi_Host *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void  volatile   *__cil_tmp41 ;
  void  volatile   *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  char (*__cil_tmp50)[32U] ;
  char *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  char (*__cil_tmp56)[32U] ;
  char *__cil_tmp57 ;
  struct scsi_device *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  struct scsi_device *__cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  struct scsi_device *__cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  unsigned char __cil_tmp73 ;
  int __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  char (*__cil_tmp83)[32U] ;
  char *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  char (*__cil_tmp89)[32U] ;
  char *__cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  struct scsi_device *__cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  struct scsi_device *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  struct scsi_device *__cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned char *__cil_tmp107 ;
  unsigned char __cil_tmp108 ;
  int __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned char *__cil_tmp114 ;
  void *__cil_tmp115 ;
  void  volatile   *__cil_tmp116 ;
  void  volatile   *__cil_tmp117 ;
  size_t __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned char *__cil_tmp121 ;
  unsigned char __cil_tmp122 ;
  unsigned int __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned char *__cil_tmp126 ;
  unsigned char *__cil_tmp127 ;
  unsigned char __cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  char (*__cil_tmp134)[32U] ;
  char *__cil_tmp135 ;
  struct scsi_device *__cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned int __cil_tmp139 ;
  struct scsi_device *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned int __cil_tmp143 ;
  struct scsi_device *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned int __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned char *__cil_tmp150 ;
  unsigned char __cil_tmp151 ;
  int __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  char (*__cil_tmp157)[32U] ;
  char *__cil_tmp158 ;
  struct scsi_device *__cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned int __cil_tmp162 ;
  struct scsi_device *__cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned int __cil_tmp166 ;
  struct scsi_device *__cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned int __cil_tmp170 ;
  struct scsi_device *__cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  void *__cil_tmp174 ;
  struct adpt_device *__cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  u16 __cil_tmp178 ;
  int __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned char *__cil_tmp182 ;
  unsigned char __cil_tmp183 ;
  int __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  int __cil_tmp189 ;
  u32 __cil_tmp190 ;
  unsigned int __cil_tmp191 ;
  void (*__cil_tmp192)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  void (*__cil_tmp196)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  void (*__cil_tmp200)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;

  {
  {
#line 2478
  __cil_tmp17 = (void  volatile   *)reply;
#line 2478
  tmp = readl(__cil_tmp17);
#line 2478
  reply_flags = tmp & 65280U;
#line 2482
  __cil_tmp18 = (void  volatile   *)reply;
#line 2482
  __cil_tmp19 = __cil_tmp18 + 16U;
#line 2482
  tmp___0 = readl(__cil_tmp19);
#line 2482
  detailed_status = (u16 )tmp___0;
#line 2483
  __cil_tmp20 = (u32 )detailed_status;
#line 2483
  dev_status = __cil_tmp20 & 255U;
#line 2484
  __cil_tmp21 = (int )detailed_status;
#line 2484
  __cil_tmp22 = __cil_tmp21 >> 8;
#line 2484
  hba_status = (u32 )__cil_tmp22;
#line 2487
  tmp___1 = scsi_bufflen(cmd);
#line 2487
  __cil_tmp23 = (void  volatile   *)reply;
#line 2487
  __cil_tmp24 = __cil_tmp23 + 20U;
#line 2487
  tmp___2 = readl(__cil_tmp24);
#line 2487
  __cil_tmp25 = tmp___1 - tmp___2;
#line 2487
  __cil_tmp26 = (int )__cil_tmp25;
#line 2487
  scsi_set_resid(cmd, __cil_tmp26);
#line 2489
  __cil_tmp27 = 0 * 8UL;
#line 2489
  __cil_tmp28 = 3048 + __cil_tmp27;
#line 2489
  __cil_tmp29 = *((struct scsi_device **)cmd);
#line 2489
  __cil_tmp30 = *((struct Scsi_Host **)__cil_tmp29);
#line 2489
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 2489
  __cil_tmp32 = __cil_tmp31 + __cil_tmp28;
#line 2489
  __cil_tmp33 = *((unsigned long *)__cil_tmp32);
#line 2489
  pHba = (adpt_hba *)__cil_tmp33;
#line 2491
  __cil_tmp34 = (unsigned long )cmd;
#line 2491
  __cil_tmp35 = __cil_tmp34 + 136;
#line 2491
  __cil_tmp36 = *((unsigned char **)__cil_tmp35);
#line 2491
  *__cil_tmp36 = (unsigned char)0;
  }
  {
#line 2493
  __cil_tmp37 = reply_flags & 8192U;
#line 2493
  if (__cil_tmp37 == 0U) {
    {
#line 2494
    __cil_tmp38 = (int )detailed_status;
#line 2495
    if ((__cil_tmp38 & 65280) == 0) {
#line 2495
      goto case_0;
    } else
#line 2503
    if ((__cil_tmp38 & 65280) == 512) {
#line 2503
      goto case_512;
    } else
#line 2506
    if ((__cil_tmp38 & 65280) == 1792) {
#line 2506
      goto case_1792;
    } else
#line 2507
    if ((__cil_tmp38 & 65280) == 2048) {
#line 2507
      goto case_2048;
    } else
#line 2508
    if ((__cil_tmp38 & 65280) == 2560) {
#line 2508
      goto case_2560;
    } else
#line 2509
    if ((__cil_tmp38 & 65280) == 2816) {
#line 2509
      goto case_2816;
    } else
#line 2510
    if ((__cil_tmp38 & 65280) == 4352) {
#line 2510
      goto case_4352;
    } else
#line 2511
    if ((__cil_tmp38 & 65280) == 13312) {
#line 2511
      goto case_13312;
    } else
#line 2516
    if ((__cil_tmp38 & 65280) == 1280) {
#line 2516
      goto case_1280;
    } else
#line 2517
    if ((__cil_tmp38 & 65280) == 16128) {
#line 2517
      goto case_16128;
    } else
#line 2520
    if ((__cil_tmp38 & 65280) == 3584) {
#line 2520
      goto case_3584;
    } else
#line 2521
    if ((__cil_tmp38 & 65280) == 5888) {
#line 2521
      goto case_5888;
    } else
#line 2524
    if ((__cil_tmp38 & 65280) == 3840) {
#line 2524
      goto case_3840;
    } else
#line 2528
    if ((__cil_tmp38 & 65280) == 768) {
#line 2528
      goto case_768;
    } else
#line 2529
    if ((__cil_tmp38 & 65280) == 1024) {
#line 2529
      goto case_1024;
    } else
#line 2530
    if ((__cil_tmp38 & 65280) == 2304) {
#line 2530
      goto case_2304;
    } else
#line 2531
    if ((__cil_tmp38 & 65280) == 3328) {
#line 2531
      goto case_3328;
    } else
#line 2532
    if ((__cil_tmp38 & 65280) == 4096) {
#line 2532
      goto case_4096;
    } else
#line 2533
    if ((__cil_tmp38 & 65280) == 4608) {
#line 2533
      goto case_4608;
    } else
#line 2534
    if ((__cil_tmp38 & 65280) == 4864) {
#line 2534
      goto case_4864;
    } else
#line 2535
    if ((__cil_tmp38 & 65280) == 5120) {
#line 2535
      goto case_5120;
    } else
#line 2536
    if ((__cil_tmp38 & 65280) == 5376) {
#line 2536
      goto case_5376;
    } else
#line 2537
    if ((__cil_tmp38 & 65280) == 5632) {
#line 2537
      goto case_5632;
    } else
#line 2538
    if ((__cil_tmp38 & 65280) == 6144) {
#line 2538
      goto case_6144;
    } else
#line 2539
    if ((__cil_tmp38 & 65280) == 13056) {
#line 2539
      goto case_13056;
    } else
#line 2540
    if ((__cil_tmp38 & 65280) == 13568) {
#line 2540
      goto case_13568;
    } else
#line 2541
    if ((__cil_tmp38 & 65280) == 13824) {
#line 2541
      goto case_13824;
    } else
#line 2542
    if ((__cil_tmp38 & 65280) == 14080) {
#line 2542
      goto case_14080;
    } else
#line 2543
    if ((__cil_tmp38 & 65280) == 14336) {
#line 2543
      goto case_14336;
    } else
#line 2544
    if ((__cil_tmp38 & 65280) == 14592) {
#line 2544
      goto case_14592;
    } else
#line 2545
    if ((__cil_tmp38 & 65280) == 14848) {
#line 2545
      goto case_14848;
    } else
#line 2546
    if ((__cil_tmp38 & 65280) == 15104) {
#line 2546
      goto case_15104;
    } else
#line 2547
    if ((__cil_tmp38 & 65280) == 15616) {
#line 2547
      goto case_15616;
    } else
#line 2548
    if ((__cil_tmp38 & 65280) == 15872) {
#line 2548
      goto case_15872;
    } else
#line 2549
    if ((__cil_tmp38 & 65280) == 16384) {
#line 2549
      goto case_16384;
    } else
#line 2550
    if ((__cil_tmp38 & 65280) == 1536) {
#line 2550
      goto case_1536;
    } else {
      {
#line 2551
      goto switch_default;
#line 2494
      if (0) {
        case_0: /* CIL Label */ 
        {
#line 2496
        __cil_tmp39 = (unsigned long )cmd;
#line 2496
        __cil_tmp40 = __cil_tmp39 + 224;
#line 2496
        *((int *)__cil_tmp40) = 0;
#line 2498
        __cil_tmp41 = (void  volatile   *)reply;
#line 2498
        __cil_tmp42 = __cil_tmp41 + 20U;
#line 2498
        tmp___3 = readl(__cil_tmp42);
        }
        {
#line 2498
        __cil_tmp43 = (unsigned long )cmd;
#line 2498
        __cil_tmp44 = __cil_tmp43 + 120;
#line 2498
        __cil_tmp45 = *((unsigned int *)__cil_tmp44);
#line 2498
        if (tmp___3 < __cil_tmp45) {
          {
#line 2499
          __cil_tmp46 = (unsigned long )cmd;
#line 2499
          __cil_tmp47 = __cil_tmp46 + 224;
#line 2499
          *((int *)__cil_tmp47) = 458752;
#line 2500
          __cil_tmp48 = (unsigned long )pHba;
#line 2500
          __cil_tmp49 = __cil_tmp48 + 114;
#line 2500
          __cil_tmp50 = (char (*)[32U])__cil_tmp49;
#line 2500
          __cil_tmp51 = (char *)__cil_tmp50;
#line 2500
          printk("<4>%s: SCSI CMD underflow\n", __cil_tmp51);
          }
        } else {

        }
        }
#line 2502
        goto ldv_32685;
        case_512: /* CIL Label */ 
#line 2504
        __cil_tmp52 = (unsigned long )cmd;
#line 2504
        __cil_tmp53 = __cil_tmp52 + 224;
#line 2504
        *((int *)__cil_tmp53) = 327680;
#line 2505
        goto ldv_32685;
        case_1792: /* CIL Label */ ;
        case_2048: /* CIL Label */ ;
        case_2560: /* CIL Label */ ;
        case_2816: /* CIL Label */ ;
        case_4352: /* CIL Label */ ;
        case_13312: /* CIL Label */ 
        {
#line 2512
        __cil_tmp54 = (unsigned long )pHba;
#line 2512
        __cil_tmp55 = __cil_tmp54 + 114;
#line 2512
        __cil_tmp56 = (char (*)[32U])__cil_tmp55;
#line 2512
        __cil_tmp57 = (char *)__cil_tmp56;
#line 2512
        __cil_tmp58 = *((struct scsi_device **)cmd);
#line 2512
        __cil_tmp59 = (unsigned long )__cil_tmp58;
#line 2512
        __cil_tmp60 = __cil_tmp59 + 208;
#line 2512
        __cil_tmp61 = *((unsigned int *)__cil_tmp60);
#line 2512
        __cil_tmp62 = *((struct scsi_device **)cmd);
#line 2512
        __cil_tmp63 = (unsigned long )__cil_tmp62;
#line 2512
        __cil_tmp64 = __cil_tmp63 + 200;
#line 2512
        __cil_tmp65 = *((unsigned int *)__cil_tmp64);
#line 2512
        __cil_tmp66 = *((struct scsi_device **)cmd);
#line 2512
        __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 2512
        __cil_tmp68 = __cil_tmp67 + 204;
#line 2512
        __cil_tmp69 = *((unsigned int *)__cil_tmp68);
#line 2512
        __cil_tmp70 = (unsigned long )cmd;
#line 2512
        __cil_tmp71 = __cil_tmp70 + 80;
#line 2512
        __cil_tmp72 = *((unsigned char **)__cil_tmp71);
#line 2512
        __cil_tmp73 = *__cil_tmp72;
#line 2512
        __cil_tmp74 = (int )__cil_tmp73;
#line 2512
        printk("<4>%s: SCSI Timeout-Device (%d,%d,%d) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",
               __cil_tmp57, __cil_tmp61, __cil_tmp65, __cil_tmp69, hba_status, dev_status,
               __cil_tmp74);
#line 2514
        __cil_tmp75 = (unsigned long )cmd;
#line 2514
        __cil_tmp76 = __cil_tmp75 + 224;
#line 2514
        *((int *)__cil_tmp76) = 196608;
        }
#line 2515
        goto ldv_32685;
        case_1280: /* CIL Label */ ;
        case_16128: /* CIL Label */ 
#line 2518
        __cil_tmp77 = (unsigned long )cmd;
#line 2518
        __cil_tmp78 = __cil_tmp77 + 224;
#line 2518
        *((int *)__cil_tmp78) = 131072;
#line 2519
        goto ldv_32685;
        case_3584: /* CIL Label */ ;
        case_5888: /* CIL Label */ 
#line 2522
        __cil_tmp79 = (unsigned long )cmd;
#line 2522
        __cil_tmp80 = __cil_tmp79 + 224;
#line 2522
        *((int *)__cil_tmp80) = 524288;
#line 2523
        goto ldv_32685;
        case_3840: /* CIL Label */ 
        {
#line 2525
        __cil_tmp81 = (unsigned long )pHba;
#line 2525
        __cil_tmp82 = __cil_tmp81 + 114;
#line 2525
        __cil_tmp83 = (char (*)[32U])__cil_tmp82;
#line 2525
        __cil_tmp84 = (char *)__cil_tmp83;
#line 2525
        printk("<4>%s: SCSI CMD parity error\n", __cil_tmp84);
#line 2526
        __cil_tmp85 = (unsigned long )cmd;
#line 2526
        __cil_tmp86 = __cil_tmp85 + 224;
#line 2526
        *((int *)__cil_tmp86) = 393216;
        }
#line 2527
        goto ldv_32685;
        case_768: /* CIL Label */ ;
        case_1024: /* CIL Label */ ;
        case_2304: /* CIL Label */ ;
        case_3328: /* CIL Label */ ;
        case_4096: /* CIL Label */ ;
        case_4608: /* CIL Label */ ;
        case_4864: /* CIL Label */ ;
        case_5120: /* CIL Label */ ;
        case_5376: /* CIL Label */ ;
        case_5632: /* CIL Label */ ;
        case_6144: /* CIL Label */ ;
        case_13056: /* CIL Label */ ;
        case_13568: /* CIL Label */ ;
        case_13824: /* CIL Label */ ;
        case_14080: /* CIL Label */ ;
        case_14336: /* CIL Label */ ;
        case_14592: /* CIL Label */ ;
        case_14848: /* CIL Label */ ;
        case_15104: /* CIL Label */ ;
        case_15616: /* CIL Label */ ;
        case_15872: /* CIL Label */ ;
        case_16384: /* CIL Label */ ;
        case_1536: /* CIL Label */ ;
        switch_default: /* CIL Label */ 
        {
#line 2552
        __cil_tmp87 = (unsigned long )pHba;
#line 2552
        __cil_tmp88 = __cil_tmp87 + 114;
#line 2552
        __cil_tmp89 = (char (*)[32U])__cil_tmp88;
#line 2552
        __cil_tmp90 = (char *)__cil_tmp89;
#line 2552
        __cil_tmp91 = (int )detailed_status;
#line 2552
        __cil_tmp92 = __cil_tmp91 & 65280;
#line 2552
        __cil_tmp93 = *((struct scsi_device **)cmd);
#line 2552
        __cil_tmp94 = (unsigned long )__cil_tmp93;
#line 2552
        __cil_tmp95 = __cil_tmp94 + 208;
#line 2552
        __cil_tmp96 = *((unsigned int *)__cil_tmp95);
#line 2552
        __cil_tmp97 = *((struct scsi_device **)cmd);
#line 2552
        __cil_tmp98 = (unsigned long )__cil_tmp97;
#line 2552
        __cil_tmp99 = __cil_tmp98 + 200;
#line 2552
        __cil_tmp100 = *((unsigned int *)__cil_tmp99);
#line 2552
        __cil_tmp101 = *((struct scsi_device **)cmd);
#line 2552
        __cil_tmp102 = (unsigned long )__cil_tmp101;
#line 2552
        __cil_tmp103 = __cil_tmp102 + 204;
#line 2552
        __cil_tmp104 = *((unsigned int *)__cil_tmp103);
#line 2552
        __cil_tmp105 = (unsigned long )cmd;
#line 2552
        __cil_tmp106 = __cil_tmp105 + 80;
#line 2552
        __cil_tmp107 = *((unsigned char **)__cil_tmp106);
#line 2552
        __cil_tmp108 = *__cil_tmp107;
#line 2552
        __cil_tmp109 = (int )__cil_tmp108;
#line 2552
        printk("<4>%s: SCSI error %0x-Device(%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
               __cil_tmp90, __cil_tmp92, __cil_tmp96, __cil_tmp100, __cil_tmp104,
               hba_status, dev_status, __cil_tmp109);
#line 2555
        __cil_tmp110 = (unsigned long )cmd;
#line 2555
        __cil_tmp111 = __cil_tmp110 + 224;
#line 2555
        *((int *)__cil_tmp111) = 458752;
        }
#line 2556
        goto ldv_32685;
      } else {
        switch_break: /* CIL Label */ ;
      }
      }
    }
    }
    ldv_32685: ;
#line 2561
    if (dev_status == 2U) {
#line 2562
      _min1 = 96;
#line 2562
      _min2 = 40;
#line 2562
      if (_min1 < _min2) {
#line 2562
        tmp___4 = _min1;
      } else {
#line 2562
        tmp___4 = _min2;
      }
      {
#line 2562
      len = (u32 )tmp___4;
#line 2564
      __cil_tmp112 = (unsigned long )cmd;
#line 2564
      __cil_tmp113 = __cil_tmp112 + 136;
#line 2564
      __cil_tmp114 = *((unsigned char **)__cil_tmp113);
#line 2564
      __cil_tmp115 = (void *)__cil_tmp114;
#line 2564
      __cil_tmp116 = (void  volatile   *)reply;
#line 2564
      __cil_tmp117 = __cil_tmp116 + 28U;
#line 2564
      __cil_tmp118 = (size_t )len;
#line 2564
      memcpy_fromio(__cil_tmp115, __cil_tmp117, __cil_tmp118);
      }
      {
#line 2565
      __cil_tmp119 = (unsigned long )cmd;
#line 2565
      __cil_tmp120 = __cil_tmp119 + 136;
#line 2565
      __cil_tmp121 = *((unsigned char **)__cil_tmp120);
#line 2565
      __cil_tmp122 = *__cil_tmp121;
#line 2565
      __cil_tmp123 = (unsigned int )__cil_tmp122;
#line 2565
      if (__cil_tmp123 == 112U) {
        {
#line 2565
        __cil_tmp124 = (unsigned long )cmd;
#line 2565
        __cil_tmp125 = __cil_tmp124 + 136;
#line 2565
        __cil_tmp126 = *((unsigned char **)__cil_tmp125);
#line 2565
        __cil_tmp127 = __cil_tmp126 + 2UL;
#line 2565
        __cil_tmp128 = *__cil_tmp127;
#line 2565
        __cil_tmp129 = (unsigned int )__cil_tmp128;
#line 2565
        if (__cil_tmp129 == 7U) {
          {
#line 2568
          __cil_tmp130 = (unsigned long )cmd;
#line 2568
          __cil_tmp131 = __cil_tmp130 + 224;
#line 2568
          *((int *)__cil_tmp131) = 196608;
#line 2569
          __cil_tmp132 = (unsigned long )pHba;
#line 2569
          __cil_tmp133 = __cil_tmp132 + 114;
#line 2569
          __cil_tmp134 = (char (*)[32U])__cil_tmp133;
#line 2569
          __cil_tmp135 = (char *)__cil_tmp134;
#line 2569
          __cil_tmp136 = *((struct scsi_device **)cmd);
#line 2569
          __cil_tmp137 = (unsigned long )__cil_tmp136;
#line 2569
          __cil_tmp138 = __cil_tmp137 + 208;
#line 2569
          __cil_tmp139 = *((unsigned int *)__cil_tmp138);
#line 2569
          __cil_tmp140 = *((struct scsi_device **)cmd);
#line 2569
          __cil_tmp141 = (unsigned long )__cil_tmp140;
#line 2569
          __cil_tmp142 = __cil_tmp141 + 200;
#line 2569
          __cil_tmp143 = *((unsigned int *)__cil_tmp142);
#line 2569
          __cil_tmp144 = *((struct scsi_device **)cmd);
#line 2569
          __cil_tmp145 = (unsigned long )__cil_tmp144;
#line 2569
          __cil_tmp146 = __cil_tmp145 + 204;
#line 2569
          __cil_tmp147 = *((unsigned int *)__cil_tmp146);
#line 2569
          __cil_tmp148 = (unsigned long )cmd;
#line 2569
          __cil_tmp149 = __cil_tmp148 + 80;
#line 2569
          __cil_tmp150 = *((unsigned char **)__cil_tmp149);
#line 2569
          __cil_tmp151 = *__cil_tmp150;
#line 2569
          __cil_tmp152 = (int )__cil_tmp151;
#line 2569
          printk("<4>%s: SCSI Data Protect-Device (%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
                 __cil_tmp135, __cil_tmp139, __cil_tmp143, __cil_tmp147, hba_status,
                 dev_status, __cil_tmp152);
          }
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
  } else {
    {
#line 2580
    __cil_tmp153 = (unsigned long )cmd;
#line 2580
    __cil_tmp154 = __cil_tmp153 + 224;
#line 2580
    *((int *)__cil_tmp154) = 196608;
#line 2581
    __cil_tmp155 = (unsigned long )pHba;
#line 2581
    __cil_tmp156 = __cil_tmp155 + 114;
#line 2581
    __cil_tmp157 = (char (*)[32U])__cil_tmp156;
#line 2581
    __cil_tmp158 = (char *)__cil_tmp157;
#line 2581
    __cil_tmp159 = *((struct scsi_device **)cmd);
#line 2581
    __cil_tmp160 = (unsigned long )__cil_tmp159;
#line 2581
    __cil_tmp161 = __cil_tmp160 + 208;
#line 2581
    __cil_tmp162 = *((unsigned int *)__cil_tmp161);
#line 2581
    __cil_tmp163 = *((struct scsi_device **)cmd);
#line 2581
    __cil_tmp164 = (unsigned long )__cil_tmp163;
#line 2581
    __cil_tmp165 = __cil_tmp164 + 200;
#line 2581
    __cil_tmp166 = *((unsigned int *)__cil_tmp165);
#line 2581
    __cil_tmp167 = *((struct scsi_device **)cmd);
#line 2581
    __cil_tmp168 = (unsigned long )__cil_tmp167;
#line 2581
    __cil_tmp169 = __cil_tmp168 + 204;
#line 2581
    __cil_tmp170 = *((unsigned int *)__cil_tmp169);
#line 2581
    __cil_tmp171 = *((struct scsi_device **)cmd);
#line 2581
    __cil_tmp172 = (unsigned long )__cil_tmp171;
#line 2581
    __cil_tmp173 = __cil_tmp172 + 224;
#line 2581
    __cil_tmp174 = *((void **)__cil_tmp173);
#line 2581
    __cil_tmp175 = (struct adpt_device *)__cil_tmp174;
#line 2581
    __cil_tmp176 = (unsigned long )__cil_tmp175;
#line 2581
    __cil_tmp177 = __cil_tmp176 + 28;
#line 2581
    __cil_tmp178 = *((u16 *)__cil_tmp177);
#line 2581
    __cil_tmp179 = (int )__cil_tmp178;
#line 2581
    __cil_tmp180 = (unsigned long )cmd;
#line 2581
    __cil_tmp181 = __cil_tmp180 + 80;
#line 2581
    __cil_tmp182 = *((unsigned char **)__cil_tmp181);
#line 2581
    __cil_tmp183 = *__cil_tmp182;
#line 2581
    __cil_tmp184 = (int )__cil_tmp183;
#line 2581
    printk("<4>%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d, cmd=0x%x\n", __cil_tmp158,
           __cil_tmp162, __cil_tmp166, __cil_tmp170, __cil_tmp179, __cil_tmp184);
    }
  }
  }
#line 2586
  __cil_tmp185 = (unsigned long )cmd;
#line 2586
  __cil_tmp186 = __cil_tmp185 + 224;
#line 2586
  __cil_tmp187 = (unsigned long )cmd;
#line 2586
  __cil_tmp188 = __cil_tmp187 + 224;
#line 2586
  __cil_tmp189 = *((int *)__cil_tmp188);
#line 2586
  __cil_tmp190 = (u32 )__cil_tmp189;
#line 2586
  __cil_tmp191 = __cil_tmp190 | dev_status;
#line 2586
  *((int *)__cil_tmp186) = (int )__cil_tmp191;
  {
#line 2588
  __cil_tmp192 = (void (*)(struct scsi_cmnd * ))0;
#line 2588
  __cil_tmp193 = (unsigned long )__cil_tmp192;
#line 2588
  __cil_tmp194 = (unsigned long )cmd;
#line 2588
  __cil_tmp195 = __cil_tmp194 + 144;
#line 2588
  __cil_tmp196 = *((void (**)(struct scsi_cmnd * ))__cil_tmp195);
#line 2588
  __cil_tmp197 = (unsigned long )__cil_tmp196;
#line 2588
  if (__cil_tmp197 != __cil_tmp193) {
    {
#line 2589
    __cil_tmp198 = (unsigned long )cmd;
#line 2589
    __cil_tmp199 = __cil_tmp198 + 144;
#line 2589
    __cil_tmp200 = *((void (**)(struct scsi_cmnd * ))__cil_tmp199);
#line 2589
    (*__cil_tmp200)(cmd);
    }
  } else {

  }
  }
  {
#line 2591
  __cil_tmp201 = (unsigned long )cmd;
#line 2591
  __cil_tmp202 = __cil_tmp201 + 224;
#line 2591
  return (*((int *)__cil_tmp202));
  }
}
}
#line 2595 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_rescan(adpt_hba *pHba ) 
{ s32 rcode ;
  ulong flags ;
  struct Scsi_Host *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  struct Scsi_Host *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  struct Scsi_Host *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  struct Scsi_Host *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct Scsi_Host *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  spinlock_t *__cil_tmp21 ;

  {
#line 2598
  flags = 0UL;
  {
#line 2600
  __cil_tmp4 = (struct Scsi_Host *)0;
#line 2600
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 2600
  __cil_tmp6 = (unsigned long )pHba;
#line 2600
  __cil_tmp7 = __cil_tmp6 + 16;
#line 2600
  __cil_tmp8 = *((struct Scsi_Host **)__cil_tmp7);
#line 2600
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 2600
  if (__cil_tmp9 != __cil_tmp5) {
    {
#line 2601
    ldv_spin_lock();
    }
  } else {

  }
  }
  {
#line 2602
  rcode = adpt_i2o_lct_get(pHba);
  }
#line 2602
  if (rcode < 0) {
#line 2603
    goto out;
  } else {

  }
  {
#line 2604
  rcode = adpt_i2o_reparse_lct(pHba);
  }
#line 2604
  if (rcode < 0) {
#line 2605
    goto out;
  } else {

  }
#line 2606
  rcode = 0;
  out: ;
  {
#line 2607
  __cil_tmp10 = (struct Scsi_Host *)0;
#line 2607
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 2607
  __cil_tmp12 = (unsigned long )pHba;
#line 2607
  __cil_tmp13 = __cil_tmp12 + 16;
#line 2607
  __cil_tmp14 = *((struct Scsi_Host **)__cil_tmp13);
#line 2607
  __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 2607
  if (__cil_tmp15 != __cil_tmp11) {
    {
#line 2608
    __cil_tmp16 = (unsigned long )pHba;
#line 2608
    __cil_tmp17 = __cil_tmp16 + 16;
#line 2608
    __cil_tmp18 = *((struct Scsi_Host **)__cil_tmp17);
#line 2608
    __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 2608
    __cil_tmp20 = __cil_tmp19 + 216;
#line 2608
    __cil_tmp21 = *((spinlock_t **)__cil_tmp20);
#line 2608
    spin_unlock_irqrestore(__cil_tmp21, flags);
    }
  } else {

  }
  }
#line 2609
  return (rcode);
}
}
#line 2613 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_reparse_lct(adpt_hba *pHba ) 
{ int i ;
  int max ;
  int tid ;
  struct i2o_device *d ;
  i2o_lct *lct ;
  u8 bus_no ;
  s16 scsi_id ;
  s16 scsi_lun ;
  u32 buf[10U] ;
  struct adpt_device *pDev ;
  struct i2o_device *pI2o_dev ;
  int tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  void *tmp___1 ;
  struct adpt_device *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  i2o_lct *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  char (*__cil_tmp30)[32U] ;
  char *__cil_tmp31 ;
  unsigned short __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct adpt_device *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  u8 __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  struct i2o_device *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  char (*__cil_tmp52)[32U] ;
  char *__cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned short __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned short __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned short __cil_tmp73 ;
  unsigned int __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned short __cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned short __cil_tmp87 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  char (*__cil_tmp91)[32U] ;
  char *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  u32 __cil_tmp95 ;
  u32 __cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  char (*__cil_tmp100)[32U] ;
  char *__cil_tmp101 ;
  int __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  u32 __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  u32 __cil_tmp108 ;
  u32 __cil_tmp109 ;
  s16 __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  int __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  int __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  u8 __cil_tmp125 ;
  int __cil_tmp126 ;
  struct adpt_device *__cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  struct adpt_device *__cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  struct i2o_device *__cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  i2o_lct_entry *__cil_tmp140 ;
  void *__cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  i2o_lct_entry (*__cil_tmp145)[1U] ;
  void    *__cil_tmp146 ;
  void    *__cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  i2o_lct_entry *__cil_tmp150 ;
  void *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  i2o_lct_entry (*__cil_tmp155)[1U] ;
  void    *__cil_tmp156 ;
  void    *__cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  int __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  int __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  struct adpt_device *__cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  unsigned long __cil_tmp171 ;
  struct adpt_device *__cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  int __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  int __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  unsigned long __cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  struct adpt_device *__cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  struct adpt_device *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  struct adpt_device *__cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  unsigned long __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  unsigned long __cil_tmp199 ;
  unsigned long __cil_tmp200 ;
  unsigned long __cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  unsigned long __cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  unsigned long __cil_tmp205 ;
  unsigned long __cil_tmp206 ;
  unsigned long __cil_tmp207 ;
  unsigned long __cil_tmp208 ;
  unsigned long __cil_tmp209 ;
  u32 __cil_tmp210 ;
  unsigned long __cil_tmp211 ;
  unsigned long __cil_tmp212 ;
  unsigned long __cil_tmp213 ;
  unsigned long __cil_tmp214 ;
  u32 __cil_tmp215 ;
  u32 __cil_tmp216 ;
  unsigned long __cil_tmp217 ;
  unsigned long __cil_tmp218 ;
  u8 __cil_tmp219 ;
  int __cil_tmp220 ;
  int __cil_tmp221 ;
  unsigned long __cil_tmp222 ;
  unsigned long __cil_tmp223 ;
  unsigned long __cil_tmp224 ;
  unsigned long __cil_tmp225 ;
  u8 __cil_tmp226 ;
  int __cil_tmp227 ;
  int __cil_tmp228 ;
  unsigned long __cil_tmp229 ;
  unsigned long __cil_tmp230 ;
  int __cil_tmp231 ;
  unsigned long __cil_tmp232 ;
  unsigned long __cil_tmp233 ;
  u8 __cil_tmp234 ;
  int __cil_tmp235 ;
  unsigned long __cil_tmp236 ;
  unsigned long __cil_tmp237 ;
  struct scsi_device *__cil_tmp238 ;
  unsigned long __cil_tmp239 ;
  unsigned long __cil_tmp240 ;
  char (*__cil_tmp241)[32U] ;
  char *__cil_tmp242 ;
  int __cil_tmp243 ;
  int __cil_tmp244 ;
  int __cil_tmp245 ;
  struct scsi_device *__cil_tmp246 ;
  unsigned long __cil_tmp247 ;
  unsigned long __cil_tmp248 ;
  unsigned long __cil_tmp249 ;
  struct scsi_device *__cil_tmp250 ;
  unsigned long __cil_tmp251 ;
  unsigned long __cil_tmp252 ;
  unsigned long __cil_tmp253 ;
  struct scsi_device *__cil_tmp254 ;
  enum scsi_device_state __cil_tmp255 ;
  unsigned long __cil_tmp256 ;
  unsigned long __cil_tmp257 ;
  unsigned long __cil_tmp258 ;
  unsigned long __cil_tmp259 ;
  unsigned long __cil_tmp260 ;
  unsigned short __cil_tmp261 ;
  int __cil_tmp262 ;
  unsigned long __cil_tmp263 ;
  unsigned long __cil_tmp264 ;
  unsigned long __cil_tmp265 ;
  unsigned long __cil_tmp266 ;
  i2o_lct_entry *__cil_tmp267 ;
  void *__cil_tmp268 ;
  unsigned long __cil_tmp269 ;
  unsigned long __cil_tmp270 ;
  unsigned long __cil_tmp271 ;
  i2o_lct_entry (*__cil_tmp272)[1U] ;
  void    *__cil_tmp273 ;
  void    *__cil_tmp274 ;
  unsigned long __cil_tmp275 ;
  unsigned long __cil_tmp276 ;
  i2o_lct_entry *__cil_tmp277 ;
  void *__cil_tmp278 ;
  unsigned long __cil_tmp279 ;
  unsigned long __cil_tmp280 ;
  unsigned long __cil_tmp281 ;
  i2o_lct_entry (*__cil_tmp282)[1U] ;
  void    *__cil_tmp283 ;
  void    *__cil_tmp284 ;
  struct scsi_device *__cil_tmp285 ;
  unsigned long __cil_tmp286 ;
  unsigned long __cil_tmp287 ;
  unsigned long __cil_tmp288 ;
  struct scsi_device *__cil_tmp289 ;
  unsigned long __cil_tmp290 ;
  unsigned long __cil_tmp291 ;
  unsigned long __cil_tmp292 ;
  struct scsi_device *__cil_tmp293 ;
  unsigned long __cil_tmp294 ;
  unsigned long __cil_tmp295 ;
  struct scsi_device *__cil_tmp296 ;
  unsigned long __cil_tmp297 ;
  unsigned long __cil_tmp298 ;
  struct adpt_device *__cil_tmp299 ;
  unsigned long __cil_tmp300 ;
  unsigned long __cil_tmp301 ;
  unsigned long __cil_tmp302 ;
  unsigned long __cil_tmp303 ;
  unsigned long __cil_tmp304 ;
  unsigned long __cil_tmp305 ;
  struct adpt_device *__cil_tmp306 ;
  unsigned long __cil_tmp307 ;
  unsigned long __cil_tmp308 ;
  unsigned long __cil_tmp309 ;
  unsigned long __cil_tmp310 ;
  u8 __cil_tmp311 ;
  int __cil_tmp312 ;
  unsigned long __cil_tmp313 ;
  unsigned long __cil_tmp314 ;
  unsigned long __cil_tmp315 ;
  unsigned long __cil_tmp316 ;
  char (*__cil_tmp317)[32U] ;
  char *__cil_tmp318 ;
  unsigned long __cil_tmp319 ;
  unsigned long __cil_tmp320 ;
  u8 __cil_tmp321 ;
  int __cil_tmp322 ;
  unsigned long __cil_tmp323 ;
  unsigned long __cil_tmp324 ;
  u8 __cil_tmp325 ;
  int __cil_tmp326 ;
  unsigned long __cil_tmp327 ;
  unsigned long __cil_tmp328 ;
  u8 __cil_tmp329 ;
  int __cil_tmp330 ;
  struct scsi_device *__cil_tmp331 ;
  unsigned long __cil_tmp332 ;
  unsigned long __cil_tmp333 ;
  unsigned long __cil_tmp334 ;
  struct scsi_device *__cil_tmp335 ;
  unsigned long __cil_tmp336 ;
  unsigned long __cil_tmp337 ;
  unsigned long __cil_tmp338 ;
  struct scsi_device *__cil_tmp339 ;
  enum scsi_device_state __cil_tmp340 ;
  struct i2o_device *__cil_tmp341 ;
  unsigned long __cil_tmp342 ;
  unsigned long __cil_tmp343 ;

  {
#line 2619
  __cil_tmp23 = (unsigned long )pHba;
#line 2619
  __cil_tmp24 = __cil_tmp23 + 328;
#line 2619
  lct = *((i2o_lct **)__cil_tmp24);
#line 2620
  bus_no = (u8 )0U;
#line 2624
  pDev = (struct adpt_device *)0;
#line 2625
  pI2o_dev = (struct i2o_device *)0;
  {
#line 2627
  __cil_tmp25 = (i2o_lct *)0;
#line 2627
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 2627
  __cil_tmp27 = (unsigned long )lct;
#line 2627
  if (__cil_tmp27 == __cil_tmp26) {
    {
#line 2628
    __cil_tmp28 = (unsigned long )pHba;
#line 2628
    __cil_tmp29 = __cil_tmp28 + 114;
#line 2628
    __cil_tmp30 = (char (*)[32U])__cil_tmp29;
#line 2628
    __cil_tmp31 = (char *)__cil_tmp30;
#line 2628
    printk("<3>%s: LCT is empty???\n", __cil_tmp31);
    }
#line 2629
    return (-1);
  } else {

  }
  }
#line 2632
  __cil_tmp32 = *((unsigned short *)lct);
#line 2632
  max = (int )__cil_tmp32;
#line 2633
  max = max + -3;
#line 2634
  max = max / 9;
#line 2637
  __cil_tmp33 = (unsigned long )pHba;
#line 2637
  __cil_tmp34 = __cil_tmp33 + 352;
#line 2637
  d = *((struct i2o_device **)__cil_tmp34);
#line 2637
  goto ldv_32748;
  ldv_32747: 
#line 2638
  __cil_tmp35 = (unsigned long )d;
#line 2638
  __cil_tmp36 = __cil_tmp35 + 80;
#line 2638
  pDev = *((struct adpt_device **)__cil_tmp36);
  {
#line 2639
  __cil_tmp37 = (struct adpt_device *)0;
#line 2639
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 2639
  __cil_tmp39 = (unsigned long )pDev;
#line 2639
  if (__cil_tmp39 == __cil_tmp38) {
#line 2640
    goto ldv_32746;
  } else {

  }
  }
#line 2642
  __cil_tmp40 = (unsigned long )pDev;
#line 2642
  __cil_tmp41 = __cil_tmp40 + 27;
#line 2642
  __cil_tmp42 = (unsigned long )pDev;
#line 2642
  __cil_tmp43 = __cil_tmp42 + 27;
#line 2642
  __cil_tmp44 = *((u8 *)__cil_tmp43);
#line 2642
  __cil_tmp45 = (unsigned int )__cil_tmp44;
#line 2642
  __cil_tmp46 = __cil_tmp45 | 1U;
#line 2642
  *((u8 *)__cil_tmp41) = (u8 )__cil_tmp46;
  ldv_32746: 
#line 2637
  d = *((struct i2o_device **)d);
  ldv_32748: ;
  {
#line 2637
  __cil_tmp47 = (struct i2o_device *)0;
#line 2637
  __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 2637
  __cil_tmp49 = (unsigned long )d;
#line 2637
  if (__cil_tmp49 != __cil_tmp48) {
#line 2638
    goto ldv_32747;
  } else {
#line 2640
    goto ldv_32749;
  }
  }
  ldv_32749: 
  {
#line 2645
  __cil_tmp50 = (unsigned long )pHba;
#line 2645
  __cil_tmp51 = __cil_tmp50 + 114;
#line 2645
  __cil_tmp52 = (char (*)[32U])__cil_tmp51;
#line 2645
  __cil_tmp53 = (char *)__cil_tmp52;
#line 2645
  printk("<6>%s: LCT has %d entries.\n", __cil_tmp53, max);
#line 2647
  i = 0;
  }
#line 2647
  goto ldv_32767;
  ldv_32766: ;
  {
#line 2648
  __cil_tmp54 = i * 40UL;
#line 2648
  __cil_tmp55 = __cil_tmp54 + 20;
#line 2648
  __cil_tmp56 = 12 + __cil_tmp55;
#line 2648
  __cil_tmp57 = (unsigned long )lct;
#line 2648
  __cil_tmp58 = __cil_tmp57 + __cil_tmp56;
#line 2648
  __cil_tmp59 = *((unsigned short *)__cil_tmp58);
#line 2648
  __cil_tmp60 = (unsigned int )__cil_tmp59;
#line 2648
  if (__cil_tmp60 != 4095U) {
#line 2649
    goto ldv_32750;
  } else {

  }
  }
  {
#line 2652
  __cil_tmp61 = i * 40UL;
#line 2652
  __cil_tmp62 = __cil_tmp61 + 12;
#line 2652
  __cil_tmp63 = 12 + __cil_tmp62;
#line 2652
  __cil_tmp64 = (unsigned long )lct;
#line 2652
  __cil_tmp65 = __cil_tmp64 + __cil_tmp63;
#line 2652
  __cil_tmp66 = *((unsigned short *)__cil_tmp65);
#line 2652
  __cil_tmp67 = (unsigned int )__cil_tmp66;
#line 2652
  if (__cil_tmp67 == 16U) {
#line 2652
    goto _L;
  } else {
    {
#line 2652
    __cil_tmp68 = i * 40UL;
#line 2652
    __cil_tmp69 = __cil_tmp68 + 12;
#line 2652
    __cil_tmp70 = 12 + __cil_tmp69;
#line 2652
    __cil_tmp71 = (unsigned long )lct;
#line 2652
    __cil_tmp72 = __cil_tmp71 + __cil_tmp70;
#line 2652
    __cil_tmp73 = *((unsigned short *)__cil_tmp72);
#line 2652
    __cil_tmp74 = (unsigned int )__cil_tmp73;
#line 2652
    if (__cil_tmp74 == 81U) {
#line 2652
      goto _L;
    } else {
      {
#line 2652
      __cil_tmp75 = i * 40UL;
#line 2652
      __cil_tmp76 = __cil_tmp75 + 12;
#line 2652
      __cil_tmp77 = 12 + __cil_tmp76;
#line 2652
      __cil_tmp78 = (unsigned long )lct;
#line 2652
      __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 2652
      __cil_tmp80 = *((unsigned short *)__cil_tmp79);
#line 2652
      __cil_tmp81 = (unsigned int )__cil_tmp80;
#line 2652
      if (__cil_tmp81 == 65U) {
        _L: /* CIL Label */ 
        {
#line 2655
        __cil_tmp82 = i * 40UL;
#line 2655
        __cil_tmp83 = __cil_tmp82 + 2;
#line 2655
        __cil_tmp84 = 12 + __cil_tmp83;
#line 2655
        __cil_tmp85 = (unsigned long )lct;
#line 2655
        __cil_tmp86 = __cil_tmp85 + __cil_tmp84;
#line 2655
        __cil_tmp87 = *((unsigned short *)__cil_tmp86);
#line 2655
        tid = (int )__cil_tmp87;
#line 2656
        __cil_tmp88 = (void *)(& buf);
#line 2656
        tmp = adpt_i2o_query_scalar(pHba, tid, 32768, -1, __cil_tmp88, 32);
        }
#line 2656
        if (tmp < 0) {
          {
#line 2657
          __cil_tmp89 = (unsigned long )pHba;
#line 2657
          __cil_tmp90 = __cil_tmp89 + 114;
#line 2657
          __cil_tmp91 = (char (*)[32U])__cil_tmp90;
#line 2657
          __cil_tmp92 = (char *)__cil_tmp91;
#line 2657
          printk("<3>%s: Could not query device\n", __cil_tmp92);
          }
#line 2658
          goto ldv_32750;
        } else {

        }
#line 2660
        __cil_tmp93 = 0 * 4UL;
#line 2660
        __cil_tmp94 = (unsigned long )(buf) + __cil_tmp93;
#line 2660
        __cil_tmp95 = *((u32 *)__cil_tmp94);
#line 2660
        __cil_tmp96 = __cil_tmp95 >> 16;
#line 2660
        bus_no = (u8 )__cil_tmp96;
        {
#line 2661
        __cil_tmp97 = (unsigned int )bus_no;
#line 2661
        if (__cil_tmp97 > 4U) {
          {
#line 2662
          __cil_tmp98 = (unsigned long )pHba;
#line 2662
          __cil_tmp99 = __cil_tmp98 + 114;
#line 2662
          __cil_tmp100 = (char (*)[32U])__cil_tmp99;
#line 2662
          __cil_tmp101 = (char *)__cil_tmp100;
#line 2662
          __cil_tmp102 = (int )bus_no;
#line 2662
          printk("<4>%s: Channel number %d out of range\n", __cil_tmp101, __cil_tmp102);
          }
#line 2665
          goto ldv_32750;
        } else {

        }
        }
#line 2668
        __cil_tmp103 = 1 * 4UL;
#line 2668
        __cil_tmp104 = (unsigned long )(buf) + __cil_tmp103;
#line 2668
        __cil_tmp105 = *((u32 *)__cil_tmp104);
#line 2668
        scsi_id = (s16 )__cil_tmp105;
#line 2669
        __cil_tmp106 = 2 * 4UL;
#line 2669
        __cil_tmp107 = (unsigned long )(buf) + __cil_tmp106;
#line 2669
        __cil_tmp108 = *((u32 *)__cil_tmp107);
#line 2669
        __cil_tmp109 = __cil_tmp108 >> 8;
#line 2669
        __cil_tmp110 = (s16 )__cil_tmp109;
#line 2669
        __cil_tmp111 = (int )__cil_tmp110;
#line 2669
        __cil_tmp112 = __cil_tmp111 & 255;
#line 2669
        scsi_lun = (s16 )__cil_tmp112;
#line 2670
        __cil_tmp113 = (int )scsi_id;
#line 2670
        __cil_tmp114 = __cil_tmp113 * 8UL;
#line 2670
        __cil_tmp115 = 0 + __cil_tmp114;
#line 2670
        __cil_tmp116 = (int )bus_no;
#line 2670
        __cil_tmp117 = __cil_tmp116 * 1040UL;
#line 2670
        __cil_tmp118 = __cil_tmp117 + __cil_tmp115;
#line 2670
        __cil_tmp119 = 360 + __cil_tmp118;
#line 2670
        __cil_tmp120 = (unsigned long )pHba;
#line 2670
        __cil_tmp121 = __cil_tmp120 + __cil_tmp119;
#line 2670
        pDev = *((struct adpt_device **)__cil_tmp121);
#line 2672
        goto ldv_32753;
        ldv_32752: ;
        {
#line 2673
        __cil_tmp122 = (int )scsi_lun;
#line 2673
        __cil_tmp123 = (unsigned long )pDev;
#line 2673
        __cil_tmp124 = __cil_tmp123 + 26;
#line 2673
        __cil_tmp125 = *((u8 *)__cil_tmp124);
#line 2673
        __cil_tmp126 = (int )__cil_tmp125;
#line 2673
        if (__cil_tmp126 == __cil_tmp122) {
#line 2674
          goto ldv_32751;
        } else {

        }
        }
#line 2676
        pDev = *((struct adpt_device **)pDev);
        ldv_32753: ;
        {
#line 2672
        __cil_tmp127 = (struct adpt_device *)0;
#line 2672
        __cil_tmp128 = (unsigned long )__cil_tmp127;
#line 2672
        __cil_tmp129 = (unsigned long )pDev;
#line 2672
        if (__cil_tmp129 != __cil_tmp128) {
#line 2673
          goto ldv_32752;
        } else {
#line 2675
          goto ldv_32751;
        }
        }
        ldv_32751: ;
        {
#line 2678
        __cil_tmp130 = (struct adpt_device *)0;
#line 2678
        __cil_tmp131 = (unsigned long )__cil_tmp130;
#line 2678
        __cil_tmp132 = (unsigned long )pDev;
#line 2678
        if (__cil_tmp132 == __cil_tmp131) {
          {
#line 2679
          tmp___0 = kmalloc(88UL, 32U);
#line 2679
          d = (struct i2o_device *)tmp___0;
          }
          {
#line 2681
          __cil_tmp133 = (struct i2o_device *)0;
#line 2681
          __cil_tmp134 = (unsigned long )__cil_tmp133;
#line 2681
          __cil_tmp135 = (unsigned long )d;
#line 2681
          if (__cil_tmp135 == __cil_tmp134) {
            {
#line 2683
            printk("<2>Out of memory for I2O device data.\n");
            }
#line 2684
            return (-12);
          } else {

          }
          }
#line 2687
          __cil_tmp136 = (unsigned long )d;
#line 2687
          __cil_tmp137 = __cil_tmp136 + 88;
#line 2687
          *((struct _adpt_hba **)__cil_tmp137) = pHba;
#line 2688
          *((struct i2o_device **)d) = (struct i2o_device *)0;
#line 2690
          __len = 36UL;
#line 2690
          if (__len > 63UL) {
            {
#line 2690
            __cil_tmp138 = (unsigned long )d;
#line 2690
            __cil_tmp139 = __cil_tmp138 + 24;
#line 2690
            __cil_tmp140 = (i2o_lct_entry *)__cil_tmp139;
#line 2690
            __cil_tmp141 = (void *)__cil_tmp140;
#line 2690
            __cil_tmp142 = (unsigned long )i;
#line 2690
            __cil_tmp143 = (unsigned long )lct;
#line 2690
            __cil_tmp144 = __cil_tmp143 + 12;
#line 2690
            __cil_tmp145 = (i2o_lct_entry (*)[1U])__cil_tmp144;
#line 2690
            __cil_tmp146 = (void    *)__cil_tmp145;
#line 2690
            __cil_tmp147 = __cil_tmp146 + __cil_tmp142;
#line 2690
            __ret = __memcpy(__cil_tmp141, __cil_tmp147, __len);
            }
          } else {
            {
#line 2690
            __cil_tmp148 = (unsigned long )d;
#line 2690
            __cil_tmp149 = __cil_tmp148 + 24;
#line 2690
            __cil_tmp150 = (i2o_lct_entry *)__cil_tmp149;
#line 2690
            __cil_tmp151 = (void *)__cil_tmp150;
#line 2690
            __cil_tmp152 = (unsigned long )i;
#line 2690
            __cil_tmp153 = (unsigned long )lct;
#line 2690
            __cil_tmp154 = __cil_tmp153 + 12;
#line 2690
            __cil_tmp155 = (i2o_lct_entry (*)[1U])__cil_tmp154;
#line 2690
            __cil_tmp156 = (void    *)__cil_tmp155;
#line 2690
            __cil_tmp157 = __cil_tmp156 + __cil_tmp152;
#line 2690
            __ret = __builtin_memcpy(__cil_tmp151, __cil_tmp157, __len);
            }
          }
          {
#line 2692
          __cil_tmp158 = (unsigned long )d;
#line 2692
          __cil_tmp159 = __cil_tmp158 + 64;
#line 2692
          *((u32 *)__cil_tmp159) = 0U;
#line 2693
          adpt_i2o_report_hba_unit(pHba, d);
#line 2694
          adpt_i2o_install_device(pHba, d);
#line 2696
          __cil_tmp160 = (int )scsi_id;
#line 2696
          __cil_tmp161 = __cil_tmp160 * 8UL;
#line 2696
          __cil_tmp162 = 0 + __cil_tmp161;
#line 2696
          __cil_tmp163 = (int )bus_no;
#line 2696
          __cil_tmp164 = __cil_tmp163 * 1040UL;
#line 2696
          __cil_tmp165 = __cil_tmp164 + __cil_tmp162;
#line 2696
          __cil_tmp166 = 360 + __cil_tmp165;
#line 2696
          __cil_tmp167 = (unsigned long )pHba;
#line 2696
          __cil_tmp168 = __cil_tmp167 + __cil_tmp166;
#line 2696
          pDev = *((struct adpt_device **)__cil_tmp168);
          }
          {
#line 2697
          __cil_tmp169 = (struct adpt_device *)0;
#line 2697
          __cil_tmp170 = (unsigned long )__cil_tmp169;
#line 2697
          __cil_tmp171 = (unsigned long )pDev;
#line 2697
          if (__cil_tmp171 == __cil_tmp170) {
            {
#line 2698
            tmp___1 = kzalloc(48UL, 32U);
#line 2698
            pDev = (struct adpt_device *)tmp___1;
            }
            {
#line 2701
            __cil_tmp172 = (struct adpt_device *)0;
#line 2701
            __cil_tmp173 = (unsigned long )__cil_tmp172;
#line 2701
            __cil_tmp174 = (unsigned long )pDev;
#line 2701
            if (__cil_tmp174 == __cil_tmp173) {
#line 2702
              return (-12);
            } else {

            }
            }
#line 2704
            __cil_tmp175 = (int )scsi_id;
#line 2704
            __cil_tmp176 = __cil_tmp175 * 8UL;
#line 2704
            __cil_tmp177 = 0 + __cil_tmp176;
#line 2704
            __cil_tmp178 = (int )bus_no;
#line 2704
            __cil_tmp179 = __cil_tmp178 * 1040UL;
#line 2704
            __cil_tmp180 = __cil_tmp179 + __cil_tmp177;
#line 2704
            __cil_tmp181 = 360 + __cil_tmp180;
#line 2704
            __cil_tmp182 = (unsigned long )pHba;
#line 2704
            __cil_tmp183 = __cil_tmp182 + __cil_tmp181;
#line 2704
            *((struct adpt_device **)__cil_tmp183) = pDev;
          } else {
#line 2706
            goto ldv_32758;
            ldv_32757: 
#line 2707
            pDev = *((struct adpt_device **)pDev);
            ldv_32758: ;
            {
#line 2706
            __cil_tmp184 = (struct adpt_device *)0;
#line 2706
            __cil_tmp185 = (unsigned long )__cil_tmp184;
#line 2706
            __cil_tmp186 = *((struct adpt_device **)pDev);
#line 2706
            __cil_tmp187 = (unsigned long )__cil_tmp186;
#line 2706
            if (__cil_tmp187 != __cil_tmp185) {
#line 2707
              goto ldv_32757;
            } else {
#line 2709
              goto ldv_32759;
            }
            }
            ldv_32759: 
            {
#line 2709
            tmp___3 = kzalloc(48UL, 32U);
#line 2709
            tmp___2 = (struct adpt_device *)tmp___3;
#line 2709
            *((struct adpt_device **)pDev) = tmp___2;
#line 2709
            pDev = tmp___2;
            }
            {
#line 2712
            __cil_tmp188 = (struct adpt_device *)0;
#line 2712
            __cil_tmp189 = (unsigned long )__cil_tmp188;
#line 2712
            __cil_tmp190 = (unsigned long )pDev;
#line 2712
            if (__cil_tmp190 == __cil_tmp189) {
#line 2713
              return (-12);
            } else {

            }
            }
          }
          }
#line 2716
          __cil_tmp191 = (unsigned long )pDev;
#line 2716
          __cil_tmp192 = __cil_tmp191 + 28;
#line 2716
          __cil_tmp193 = 24 + 2;
#line 2716
          __cil_tmp194 = (unsigned long )d;
#line 2716
          __cil_tmp195 = __cil_tmp194 + __cil_tmp193;
#line 2716
          *((u16 *)__cil_tmp192) = *((unsigned short *)__cil_tmp195);
#line 2717
          __cil_tmp196 = (unsigned long )pDev;
#line 2717
          __cil_tmp197 = __cil_tmp196 + 24;
#line 2717
          *((u8 *)__cil_tmp197) = bus_no;
#line 2718
          __cil_tmp198 = (unsigned long )pDev;
#line 2718
          __cil_tmp199 = __cil_tmp198 + 25;
#line 2718
          *((u8 *)__cil_tmp199) = (u8 )scsi_id;
#line 2719
          __cil_tmp200 = (unsigned long )pDev;
#line 2719
          __cil_tmp201 = __cil_tmp200 + 26;
#line 2719
          *((u8 *)__cil_tmp201) = (u8 )scsi_lun;
#line 2720
          __cil_tmp202 = (unsigned long )pDev;
#line 2720
          __cil_tmp203 = __cil_tmp202 + 32;
#line 2720
          *((struct i2o_device **)__cil_tmp203) = d;
#line 2721
          __cil_tmp204 = (unsigned long )d;
#line 2721
          __cil_tmp205 = __cil_tmp204 + 80;
#line 2721
          *((struct adpt_device **)__cil_tmp205) = pDev;
#line 2722
          __cil_tmp206 = (unsigned long )pDev;
#line 2722
          __cil_tmp207 = __cil_tmp206 + 12;
#line 2722
          __cil_tmp208 = 0 * 4UL;
#line 2722
          __cil_tmp209 = (unsigned long )(buf) + __cil_tmp208;
#line 2722
          __cil_tmp210 = *((u32 *)__cil_tmp209);
#line 2722
          *((u32 *)__cil_tmp207) = __cil_tmp210 & 255U;
#line 2723
          __cil_tmp211 = (unsigned long )pDev;
#line 2723
          __cil_tmp212 = __cil_tmp211 + 8;
#line 2723
          __cil_tmp213 = 0 * 4UL;
#line 2723
          __cil_tmp214 = (unsigned long )(buf) + __cil_tmp213;
#line 2723
          __cil_tmp215 = *((u32 *)__cil_tmp214);
#line 2723
          __cil_tmp216 = __cil_tmp215 >> 8;
#line 2723
          *((u32 *)__cil_tmp212) = __cil_tmp216 & 255U;
          {
#line 2725
          __cil_tmp217 = (unsigned long )pHba;
#line 2725
          __cil_tmp218 = __cil_tmp217 + 293;
#line 2725
          __cil_tmp219 = *((u8 *)__cil_tmp218);
#line 2725
          __cil_tmp220 = (int )__cil_tmp219;
#line 2725
          __cil_tmp221 = (int )scsi_id;
#line 2725
          if (__cil_tmp221 > __cil_tmp220) {
#line 2726
            __cil_tmp222 = (unsigned long )pHba;
#line 2726
            __cil_tmp223 = __cil_tmp222 + 293;
#line 2726
            *((u8 *)__cil_tmp223) = (u8 )scsi_id;
          } else {

          }
          }
          {
#line 2728
          __cil_tmp224 = (unsigned long )pHba;
#line 2728
          __cil_tmp225 = __cil_tmp224 + 294;
#line 2728
          __cil_tmp226 = *((u8 *)__cil_tmp225);
#line 2728
          __cil_tmp227 = (int )__cil_tmp226;
#line 2728
          __cil_tmp228 = (int )scsi_lun;
#line 2728
          if (__cil_tmp228 > __cil_tmp227) {
#line 2729
            __cil_tmp229 = (unsigned long )pHba;
#line 2729
            __cil_tmp230 = __cil_tmp229 + 294;
#line 2729
            *((u8 *)__cil_tmp230) = (u8 )scsi_lun;
          } else {

          }
          }
#line 2731
          goto ldv_32750;
        } else {

        }
        }
#line 2735
        goto ldv_32765;
        ldv_32764: ;
        {
#line 2736
        __cil_tmp231 = (int )scsi_lun;
#line 2736
        __cil_tmp232 = (unsigned long )pDev;
#line 2736
        __cil_tmp233 = __cil_tmp232 + 26;
#line 2736
        __cil_tmp234 = *((u8 *)__cil_tmp233);
#line 2736
        __cil_tmp235 = (int )__cil_tmp234;
#line 2736
        if (__cil_tmp235 == __cil_tmp231) {
          {
#line 2737
          __cil_tmp236 = (unsigned long )pDev;
#line 2737
          __cil_tmp237 = __cil_tmp236 + 40;
#line 2737
          __cil_tmp238 = *((struct scsi_device **)__cil_tmp237);
#line 2737
          tmp___4 = scsi_device_online(__cil_tmp238);
          }
#line 2737
          if (tmp___4 == 0) {
            {
#line 2738
            __cil_tmp239 = (unsigned long )pHba;
#line 2738
            __cil_tmp240 = __cil_tmp239 + 114;
#line 2738
            __cil_tmp241 = (char (*)[32U])__cil_tmp240;
#line 2738
            __cil_tmp242 = (char *)__cil_tmp241;
#line 2738
            __cil_tmp243 = (int )bus_no;
#line 2738
            __cil_tmp244 = (int )scsi_id;
#line 2738
            __cil_tmp245 = (int )scsi_lun;
#line 2738
            printk("<4>%s: Setting device (%d,%d,%d) back online\n", __cil_tmp242,
                   __cil_tmp243, __cil_tmp244, __cil_tmp245);
            }
            {
#line 2740
            __cil_tmp246 = (struct scsi_device *)0;
#line 2740
            __cil_tmp247 = (unsigned long )__cil_tmp246;
#line 2740
            __cil_tmp248 = (unsigned long )pDev;
#line 2740
            __cil_tmp249 = __cil_tmp248 + 40;
#line 2740
            __cil_tmp250 = *((struct scsi_device **)__cil_tmp249);
#line 2740
            __cil_tmp251 = (unsigned long )__cil_tmp250;
#line 2740
            if (__cil_tmp251 != __cil_tmp247) {
              {
#line 2741
              __cil_tmp252 = (unsigned long )pDev;
#line 2741
              __cil_tmp253 = __cil_tmp252 + 40;
#line 2741
              __cil_tmp254 = *((struct scsi_device **)__cil_tmp253);
#line 2741
              __cil_tmp255 = (enum scsi_device_state )2;
#line 2741
              scsi_device_set_state(__cil_tmp254, __cil_tmp255);
              }
            } else {

            }
            }
          } else {

          }
#line 2744
          __cil_tmp256 = (unsigned long )pDev;
#line 2744
          __cil_tmp257 = __cil_tmp256 + 32;
#line 2744
          d = *((struct i2o_device **)__cil_tmp257);
          {
#line 2745
          __cil_tmp258 = 24 + 2;
#line 2745
          __cil_tmp259 = (unsigned long )d;
#line 2745
          __cil_tmp260 = __cil_tmp259 + __cil_tmp258;
#line 2745
          __cil_tmp261 = *((unsigned short *)__cil_tmp260);
#line 2745
          __cil_tmp262 = (int )__cil_tmp261;
#line 2745
          if (__cil_tmp262 != tid) {
#line 2746
            __cil_tmp263 = (unsigned long )pDev;
#line 2746
            __cil_tmp264 = __cil_tmp263 + 28;
#line 2746
            *((u16 *)__cil_tmp264) = (u16 )tid;
#line 2747
            __len___0 = 36UL;
#line 2747
            if (__len___0 > 63UL) {
              {
#line 2747
              __cil_tmp265 = (unsigned long )d;
#line 2747
              __cil_tmp266 = __cil_tmp265 + 24;
#line 2747
              __cil_tmp267 = (i2o_lct_entry *)__cil_tmp266;
#line 2747
              __cil_tmp268 = (void *)__cil_tmp267;
#line 2747
              __cil_tmp269 = (unsigned long )i;
#line 2747
              __cil_tmp270 = (unsigned long )lct;
#line 2747
              __cil_tmp271 = __cil_tmp270 + 12;
#line 2747
              __cil_tmp272 = (i2o_lct_entry (*)[1U])__cil_tmp271;
#line 2747
              __cil_tmp273 = (void    *)__cil_tmp272;
#line 2747
              __cil_tmp274 = __cil_tmp273 + __cil_tmp269;
#line 2747
              __ret___0 = __memcpy(__cil_tmp268, __cil_tmp274, __len___0);
              }
            } else {
              {
#line 2747
              __cil_tmp275 = (unsigned long )d;
#line 2747
              __cil_tmp276 = __cil_tmp275 + 24;
#line 2747
              __cil_tmp277 = (i2o_lct_entry *)__cil_tmp276;
#line 2747
              __cil_tmp278 = (void *)__cil_tmp277;
#line 2747
              __cil_tmp279 = (unsigned long )i;
#line 2747
              __cil_tmp280 = (unsigned long )lct;
#line 2747
              __cil_tmp281 = __cil_tmp280 + 12;
#line 2747
              __cil_tmp282 = (i2o_lct_entry (*)[1U])__cil_tmp281;
#line 2747
              __cil_tmp283 = (void    *)__cil_tmp282;
#line 2747
              __cil_tmp284 = __cil_tmp283 + __cil_tmp279;
#line 2747
              __ret___0 = __builtin_memcpy(__cil_tmp278, __cil_tmp284, __len___0);
              }
            }
            {
#line 2748
            __cil_tmp285 = (struct scsi_device *)0;
#line 2748
            __cil_tmp286 = (unsigned long )__cil_tmp285;
#line 2748
            __cil_tmp287 = (unsigned long )pDev;
#line 2748
            __cil_tmp288 = __cil_tmp287 + 40;
#line 2748
            __cil_tmp289 = *((struct scsi_device **)__cil_tmp288);
#line 2748
            __cil_tmp290 = (unsigned long )__cil_tmp289;
#line 2748
            if (__cil_tmp290 != __cil_tmp286) {
#line 2749
              __cil_tmp291 = (unsigned long )pDev;
#line 2749
              __cil_tmp292 = __cil_tmp291 + 40;
#line 2749
              __cil_tmp293 = *((struct scsi_device **)__cil_tmp292);
#line 2749
              __cil_tmp293->changed = (unsigned char)1;
#line 2750
              __cil_tmp294 = (unsigned long )pDev;
#line 2750
              __cil_tmp295 = __cil_tmp294 + 40;
#line 2750
              __cil_tmp296 = *((struct scsi_device **)__cil_tmp295);
#line 2750
              __cil_tmp296->removable = (unsigned char)1;
            } else {

            }
            }
          } else {

          }
          }
#line 2754
          __cil_tmp297 = (unsigned long )pDev;
#line 2754
          __cil_tmp298 = __cil_tmp297 + 27;
#line 2754
          *((u8 *)__cil_tmp298) = (u8 )0U;
#line 2755
          goto ldv_32763;
        } else {

        }
        }
#line 2757
        pDev = *((struct adpt_device **)pDev);
        ldv_32765: ;
        {
#line 2735
        __cil_tmp299 = (struct adpt_device *)0;
#line 2735
        __cil_tmp300 = (unsigned long )__cil_tmp299;
#line 2735
        __cil_tmp301 = (unsigned long )pDev;
#line 2735
        if (__cil_tmp301 != __cil_tmp300) {
#line 2736
          goto ldv_32764;
        } else {
#line 2738
          goto ldv_32763;
        }
        }
        ldv_32763: ;
      } else {

      }
      }
    }
    }
  }
  }
  ldv_32750: 
#line 2647
  i = i + 1;
  ldv_32767: ;
#line 2647
  if (i < max) {
#line 2648
    goto ldv_32766;
  } else {
#line 2650
    goto ldv_32768;
  }
  ldv_32768: 
#line 2761
  __cil_tmp302 = (unsigned long )pHba;
#line 2761
  __cil_tmp303 = __cil_tmp302 + 352;
#line 2761
  pI2o_dev = *((struct i2o_device **)__cil_tmp303);
#line 2761
  goto ldv_32771;
  ldv_32770: 
#line 2762
  __cil_tmp304 = (unsigned long )pI2o_dev;
#line 2762
  __cil_tmp305 = __cil_tmp304 + 80;
#line 2762
  pDev = *((struct adpt_device **)__cil_tmp305);
  {
#line 2763
  __cil_tmp306 = (struct adpt_device *)0;
#line 2763
  __cil_tmp307 = (unsigned long )__cil_tmp306;
#line 2763
  __cil_tmp308 = (unsigned long )pDev;
#line 2763
  if (__cil_tmp308 == __cil_tmp307) {
#line 2764
    goto ldv_32769;
  } else {

  }
  }
  {
#line 2768
  __cil_tmp309 = (unsigned long )pDev;
#line 2768
  __cil_tmp310 = __cil_tmp309 + 27;
#line 2768
  __cil_tmp311 = *((u8 *)__cil_tmp310);
#line 2768
  __cil_tmp312 = (int )__cil_tmp311;
#line 2768
  if (__cil_tmp312 & 1) {
    {
#line 2769
    __cil_tmp313 = (unsigned long )pDev;
#line 2769
    __cil_tmp314 = __cil_tmp313 + 27;
#line 2769
    *((u8 *)__cil_tmp314) = (u8 )4U;
#line 2770
    __cil_tmp315 = (unsigned long )pHba;
#line 2770
    __cil_tmp316 = __cil_tmp315 + 114;
#line 2770
    __cil_tmp317 = (char (*)[32U])__cil_tmp316;
#line 2770
    __cil_tmp318 = (char *)__cil_tmp317;
#line 2770
    __cil_tmp319 = (unsigned long )pDev;
#line 2770
    __cil_tmp320 = __cil_tmp319 + 24;
#line 2770
    __cil_tmp321 = *((u8 *)__cil_tmp320);
#line 2770
    __cil_tmp322 = (int )__cil_tmp321;
#line 2770
    __cil_tmp323 = (unsigned long )pDev;
#line 2770
    __cil_tmp324 = __cil_tmp323 + 25;
#line 2770
    __cil_tmp325 = *((u8 *)__cil_tmp324);
#line 2770
    __cil_tmp326 = (int )__cil_tmp325;
#line 2770
    __cil_tmp327 = (unsigned long )pDev;
#line 2770
    __cil_tmp328 = __cil_tmp327 + 26;
#line 2770
    __cil_tmp329 = *((u8 *)__cil_tmp328);
#line 2770
    __cil_tmp330 = (int )__cil_tmp329;
#line 2770
    printk("<4>%s: Device (%d,%d,%d) offline\n", __cil_tmp318, __cil_tmp322, __cil_tmp326,
           __cil_tmp330);
    }
    {
#line 2771
    __cil_tmp331 = (struct scsi_device *)0;
#line 2771
    __cil_tmp332 = (unsigned long )__cil_tmp331;
#line 2771
    __cil_tmp333 = (unsigned long )pDev;
#line 2771
    __cil_tmp334 = __cil_tmp333 + 40;
#line 2771
    __cil_tmp335 = *((struct scsi_device **)__cil_tmp334);
#line 2771
    __cil_tmp336 = (unsigned long )__cil_tmp335;
#line 2771
    if (__cil_tmp336 != __cil_tmp332) {
      {
#line 2772
      __cil_tmp337 = (unsigned long )pDev;
#line 2772
      __cil_tmp338 = __cil_tmp337 + 40;
#line 2772
      __cil_tmp339 = *((struct scsi_device **)__cil_tmp338);
#line 2772
      __cil_tmp340 = (enum scsi_device_state )6;
#line 2772
      scsi_device_set_state(__cil_tmp339, __cil_tmp340);
      }
    } else {

    }
    }
  } else {

  }
  }
  ldv_32769: 
#line 2761
  pI2o_dev = *((struct i2o_device **)pI2o_dev);
  ldv_32771: ;
  {
#line 2761
  __cil_tmp341 = (struct i2o_device *)0;
#line 2761
  __cil_tmp342 = (unsigned long )__cil_tmp341;
#line 2761
  __cil_tmp343 = (unsigned long )pI2o_dev;
#line 2761
  if (__cil_tmp343 != __cil_tmp342) {
#line 2762
    goto ldv_32770;
  } else {
#line 2764
    goto ldv_32772;
  }
  }
  ldv_32772: ;
#line 2776
  return (0);
}
}
#line 2779 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_fail_posted_scbs(adpt_hba *pHba ) 
{ struct scsi_cmnd *cmd ;
  struct scsi_device *d ;
  unsigned long flags ;
  struct list_head    *__mptr ;
  struct list_head    *__mptr___0 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct Scsi_Host *__cil_tmp9 ;
  struct scsi_device *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct list_head *__cil_tmp13 ;
  struct scsi_cmnd *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  void (*__cil_tmp22)(struct scsi_cmnd * ) ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  struct scsi_cmnd *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  spinlock_t *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct Scsi_Host *__cil_tmp40 ;
  struct scsi_device *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;

  {
  {
#line 2781
  cmd = (struct scsi_cmnd *)0;
#line 2782
  d = (struct scsi_device *)0;
#line 2784
  __cil_tmp7 = (unsigned long )pHba;
#line 2784
  __cil_tmp8 = __cil_tmp7 + 16;
#line 2784
  __cil_tmp9 = *((struct Scsi_Host **)__cil_tmp8);
#line 2784
  __cil_tmp10 = (struct scsi_device *)0;
#line 2784
  d = __scsi_iterate_devices(__cil_tmp9, __cil_tmp10);
  }
#line 2784
  goto ldv_32788;
  ldv_32787: 
  {
#line 2786
  ldv_spin_lock();
#line 2787
  __cil_tmp11 = (unsigned long )d;
#line 2787
  __cil_tmp12 = __cil_tmp11 + 128;
#line 2787
  __cil_tmp13 = *((struct list_head **)__cil_tmp12);
#line 2787
  __mptr = (struct list_head    *)__cil_tmp13;
#line 2787
  __cil_tmp14 = (struct scsi_cmnd *)__mptr;
#line 2787
  cmd = __cil_tmp14 + 0xfffffffffffffff8UL;
  }
#line 2787
  goto ldv_32785;
  ldv_32784: ;
  {
#line 2788
  __cil_tmp15 = (unsigned long )cmd;
#line 2788
  __cil_tmp16 = __cil_tmp15 + 48;
#line 2788
  __cil_tmp17 = *((unsigned long *)__cil_tmp16);
#line 2788
  if (__cil_tmp17 == 0UL) {
#line 2789
    goto ldv_32783;
  } else {

  }
  }
  {
#line 2791
  __cil_tmp18 = (unsigned long )cmd;
#line 2791
  __cil_tmp19 = __cil_tmp18 + 224;
#line 2791
  *((int *)__cil_tmp19) = 40;
#line 2792
  __cil_tmp20 = (unsigned long )cmd;
#line 2792
  __cil_tmp21 = __cil_tmp20 + 144;
#line 2792
  __cil_tmp22 = *((void (**)(struct scsi_cmnd * ))__cil_tmp21);
#line 2792
  (*__cil_tmp22)(cmd);
  }
  ldv_32783: 
#line 2787
  __cil_tmp23 = (unsigned long )cmd;
#line 2787
  __cil_tmp24 = __cil_tmp23 + 8;
#line 2787
  __cil_tmp25 = *((struct list_head **)__cil_tmp24);
#line 2787
  __mptr___0 = (struct list_head    *)__cil_tmp25;
#line 2787
  __cil_tmp26 = (struct scsi_cmnd *)__mptr___0;
#line 2787
  cmd = __cil_tmp26 + 0xfffffffffffffff8UL;
  ldv_32785: ;
  {
#line 2787
  __cil_tmp27 = (unsigned long )d;
#line 2787
  __cil_tmp28 = __cil_tmp27 + 128;
#line 2787
  __cil_tmp29 = (struct list_head *)__cil_tmp28;
#line 2787
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 2787
  __cil_tmp31 = (unsigned long )cmd;
#line 2787
  __cil_tmp32 = __cil_tmp31 + 8;
#line 2787
  __cil_tmp33 = (struct list_head *)__cil_tmp32;
#line 2787
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 2787
  if (__cil_tmp34 != __cil_tmp30) {
#line 2788
    goto ldv_32784;
  } else {
#line 2790
    goto ldv_32786;
  }
  }
  ldv_32786: 
  {
#line 2794
  __cil_tmp35 = (unsigned long )d;
#line 2794
  __cil_tmp36 = __cil_tmp35 + 56;
#line 2794
  __cil_tmp37 = (spinlock_t *)__cil_tmp36;
#line 2794
  spin_unlock_irqrestore(__cil_tmp37, flags);
#line 2784
  __cil_tmp38 = (unsigned long )pHba;
#line 2784
  __cil_tmp39 = __cil_tmp38 + 16;
#line 2784
  __cil_tmp40 = *((struct Scsi_Host **)__cil_tmp39);
#line 2784
  d = __scsi_iterate_devices(__cil_tmp40, d);
  }
  ldv_32788: ;
  {
#line 2784
  __cil_tmp41 = (struct scsi_device *)0;
#line 2784
  __cil_tmp42 = (unsigned long )__cil_tmp41;
#line 2784
  __cil_tmp43 = (unsigned long )d;
#line 2784
  if (__cil_tmp43 != __cil_tmp42) {
#line 2785
    goto ldv_32787;
  } else {
#line 2787
    goto ldv_32789;
  }
  }
  ldv_32789: ;
#line 2789
  return;
}
}
#line 2809 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_activate_hba(adpt_hba *pHba ) 
{ int rcode ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  s32 tmp___3 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  u8 __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  char (*__cil_tmp14)[32U] ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  i2o_status_block *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  __u8 __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  char (*__cil_tmp25)[32U] ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  i2o_status_block *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  __u8 __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  i2o_status_block *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  __u8 __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  i2o_status_block *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  __u8 __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  i2o_status_block *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  __u8 __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  char (*__cil_tmp57)[32U] ;
  char *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  i2o_status_block *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  __u8 __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  char (*__cil_tmp68)[32U] ;
  char *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  char (*__cil_tmp72)[32U] ;
  char *__cil_tmp73 ;

  {
  {
#line 2813
  __cil_tmp8 = (unsigned long )pHba;
#line 2813
  __cil_tmp9 = __cil_tmp8 + 112;
#line 2813
  __cil_tmp10 = *((u8 *)__cil_tmp9);
#line 2813
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 2813
  if (__cil_tmp11 != 0U) {
    {
#line 2814
    tmp___0 = adpt_i2o_status_get(pHba);
    }
#line 2814
    if (tmp___0 < 0) {
      {
#line 2815
      rcode = adpt_i2o_reset_hba(pHba);
      }
#line 2815
      if (rcode != 0) {
        {
#line 2816
        __cil_tmp12 = (unsigned long )pHba;
#line 2816
        __cil_tmp13 = __cil_tmp12 + 114;
#line 2816
        __cil_tmp14 = (char (*)[32U])__cil_tmp13;
#line 2816
        __cil_tmp15 = (char *)__cil_tmp14;
#line 2816
        printk("<4>%s: Could NOT reset.\n", __cil_tmp15);
        }
#line 2817
        return (rcode);
      } else {

      }
      {
#line 2819
      tmp = adpt_i2o_status_get(pHba);
      }
#line 2819
      if (tmp < 0) {
        {
#line 2820
        printk("<6>HBA not responding.\n");
        }
#line 2821
        return (-1);
      } else {

      }
    } else {

    }
    {
#line 2825
    __cil_tmp16 = (unsigned long )pHba;
#line 2825
    __cil_tmp17 = __cil_tmp16 + 296;
#line 2825
    __cil_tmp18 = *((i2o_status_block **)__cil_tmp17);
#line 2825
    __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 2825
    __cil_tmp20 = __cil_tmp19 + 10;
#line 2825
    __cil_tmp21 = *((__u8 *)__cil_tmp20);
#line 2825
    __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 2825
    if (__cil_tmp22 == 17U) {
      {
#line 2826
      __cil_tmp23 = (unsigned long )pHba;
#line 2826
      __cil_tmp24 = __cil_tmp23 + 114;
#line 2826
      __cil_tmp25 = (char (*)[32U])__cil_tmp24;
#line 2826
      __cil_tmp26 = (char *)__cil_tmp25;
#line 2826
      printk("<2>%s: hardware fault\n", __cil_tmp26);
      }
#line 2827
      return (-1);
    } else {

    }
    }
    {
#line 2830
    __cil_tmp27 = (unsigned long )pHba;
#line 2830
    __cil_tmp28 = __cil_tmp27 + 296;
#line 2830
    __cil_tmp29 = *((i2o_status_block **)__cil_tmp28);
#line 2830
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 2830
    __cil_tmp31 = __cil_tmp30 + 10;
#line 2830
    __cil_tmp32 = *((__u8 *)__cil_tmp31);
#line 2830
    __cil_tmp33 = (unsigned int )__cil_tmp32;
#line 2830
    if (__cil_tmp33 == 5U) {
#line 2830
      goto _L;
    } else {
      {
#line 2830
      __cil_tmp34 = (unsigned long )pHba;
#line 2830
      __cil_tmp35 = __cil_tmp34 + 296;
#line 2830
      __cil_tmp36 = *((i2o_status_block **)__cil_tmp35);
#line 2830
      __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 2830
      __cil_tmp38 = __cil_tmp37 + 10;
#line 2830
      __cil_tmp39 = *((__u8 *)__cil_tmp38);
#line 2830
      __cil_tmp40 = (unsigned int )__cil_tmp39;
#line 2830
      if (__cil_tmp40 == 8U) {
#line 2830
        goto _L;
      } else {
        {
#line 2830
        __cil_tmp41 = (unsigned long )pHba;
#line 2830
        __cil_tmp42 = __cil_tmp41 + 296;
#line 2830
        __cil_tmp43 = *((i2o_status_block **)__cil_tmp42);
#line 2830
        __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 2830
        __cil_tmp45 = __cil_tmp44 + 10;
#line 2830
        __cil_tmp46 = *((__u8 *)__cil_tmp45);
#line 2830
        __cil_tmp47 = (unsigned int )__cil_tmp46;
#line 2830
        if (__cil_tmp47 == 4U) {
#line 2830
          goto _L;
        } else {
          {
#line 2830
          __cil_tmp48 = (unsigned long )pHba;
#line 2830
          __cil_tmp49 = __cil_tmp48 + 296;
#line 2830
          __cil_tmp50 = *((i2o_status_block **)__cil_tmp49);
#line 2830
          __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 2830
          __cil_tmp52 = __cil_tmp51 + 10;
#line 2830
          __cil_tmp53 = *((__u8 *)__cil_tmp52);
#line 2830
          __cil_tmp54 = (unsigned int )__cil_tmp53;
#line 2830
          if (__cil_tmp54 == 16U) {
            _L: /* CIL Label */ 
            {
#line 2834
            adpt_i2o_reset_hba(pHba);
#line 2835
            tmp___1 = adpt_i2o_status_get(pHba);
            }
#line 2835
            if (tmp___1 < 0) {
              {
#line 2836
              __cil_tmp55 = (unsigned long )pHba;
#line 2836
              __cil_tmp56 = __cil_tmp55 + 114;
#line 2836
              __cil_tmp57 = (char (*)[32U])__cil_tmp56;
#line 2836
              __cil_tmp58 = (char *)__cil_tmp57;
#line 2836
              printk("<3>%s: Failed to initialize.\n", __cil_tmp58);
              }
#line 2837
              return (-1);
            } else {
              {
#line 2835
              __cil_tmp59 = (unsigned long )pHba;
#line 2835
              __cil_tmp60 = __cil_tmp59 + 296;
#line 2835
              __cil_tmp61 = *((i2o_status_block **)__cil_tmp60);
#line 2835
              __cil_tmp62 = (unsigned long )__cil_tmp61;
#line 2835
              __cil_tmp63 = __cil_tmp62 + 10;
#line 2835
              __cil_tmp64 = *((__u8 *)__cil_tmp63);
#line 2835
              __cil_tmp65 = (unsigned int )__cil_tmp64;
#line 2835
              if (__cil_tmp65 != 2U) {
                {
#line 2836
                __cil_tmp66 = (unsigned long )pHba;
#line 2836
                __cil_tmp67 = __cil_tmp66 + 114;
#line 2836
                __cil_tmp68 = (char (*)[32U])__cil_tmp67;
#line 2836
                __cil_tmp69 = (char *)__cil_tmp68;
#line 2836
                printk("<3>%s: Failed to initialize.\n", __cil_tmp69);
                }
#line 2837
                return (-1);
              } else {

              }
              }
            }
          } else {

          }
          }
        }
        }
      }
      }
    }
    }
  } else {
    {
#line 2841
    rcode = adpt_i2o_reset_hba(pHba);
    }
#line 2841
    if (rcode != 0) {
      {
#line 2842
      __cil_tmp70 = (unsigned long )pHba;
#line 2842
      __cil_tmp71 = __cil_tmp70 + 114;
#line 2842
      __cil_tmp72 = (char (*)[32U])__cil_tmp71;
#line 2842
      __cil_tmp73 = (char *)__cil_tmp72;
#line 2842
      printk("<4>%s: Could NOT reset.\n", __cil_tmp73);
      }
#line 2843
      return (rcode);
    } else {

    }
  }
  }
  {
#line 2848
  tmp___2 = adpt_i2o_init_outbound_q(pHba);
  }
#line 2848
  if (tmp___2 < 0) {
#line 2849
    return (-1);
  } else {

  }
  {
#line 2854
  tmp___3 = adpt_i2o_hrt_get(pHba);
  }
#line 2854
  if (tmp___3 < 0) {
#line 2855
    return (-1);
  } else {

  }
#line 2858
  return (0);
}
}
#line 2865 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_online_hba(adpt_hba *pHba ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 2867
  tmp = adpt_i2o_systab_send(pHba);
  }
#line 2867
  if (tmp < 0) {
    {
#line 2868
    adpt_i2o_delete_hba(pHba);
    }
#line 2869
    return (-1);
  } else {

  }
  {
#line 2873
  tmp___0 = adpt_i2o_enable_hba(pHba);
  }
#line 2873
  if (tmp___0 < 0) {
    {
#line 2874
    adpt_i2o_delete_hba(pHba);
    }
#line 2875
    return (-1);
  } else {

  }
#line 2879
  return (0);
}
}
#line 2882 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_send_nop(adpt_hba *pHba , u32 m ) 
{ u32 *msg ;
  ulong timeout ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  void  volatile   *__cil_tmp13 ;
  long __cil_tmp14 ;
  long __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  char (*__cil_tmp19)[32U] ;
  char *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  u32 *__cil_tmp25 ;
  void volatile   *__cil_tmp26 ;
  void volatile   *__cil_tmp27 ;
  void volatile   *__cil_tmp28 ;
  void volatile   *__cil_tmp29 ;
  void volatile   *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  void volatile   *__cil_tmp34 ;

  {
#line 2885
  __cil_tmp9 = (unsigned long )jiffies;
#line 2885
  timeout = __cil_tmp9 + 1250UL;
#line 2887
  goto ldv_32811;
  ldv_32810: 
  {
#line 2888
  __asm__  volatile   ("lfence": : : "memory");
#line 2889
  __cil_tmp10 = (unsigned long )pHba;
#line 2889
  __cil_tmp11 = __cil_tmp10 + 232;
#line 2889
  __cil_tmp12 = *((void **)__cil_tmp11);
#line 2889
  __cil_tmp13 = (void  volatile   *)__cil_tmp12;
#line 2889
  m = readl(__cil_tmp13);
  }
#line 2890
  if (m != 4294967295U) {
#line 2891
    goto ldv_32803;
  } else {

  }
  {
#line 2893
  __cil_tmp14 = (long )jiffies;
#line 2893
  __cil_tmp15 = (long )timeout;
#line 2893
  __cil_tmp16 = __cil_tmp15 - __cil_tmp14;
#line 2893
  if (__cil_tmp16 < 0L) {
    {
#line 2894
    __cil_tmp17 = (unsigned long )pHba;
#line 2894
    __cil_tmp18 = __cil_tmp17 + 114;
#line 2894
    __cil_tmp19 = (char (*)[32U])__cil_tmp18;
#line 2894
    __cil_tmp20 = (char *)__cil_tmp19;
#line 2894
    printk("<3>%s: Timeout waiting for message frame!\n", __cil_tmp20);
    }
#line 2895
    return (2);
  } else {

  }
  }
  {
#line 2897
  schedule_timeout_uninterruptible(1L);
  }
  ldv_32811: ;
#line 2887
  if (m == 4294967295U) {
#line 2888
    goto ldv_32810;
  } else {
#line 2890
    goto ldv_32803;
  }
  ldv_32803: 
  {
#line 2899
  __cil_tmp21 = (unsigned long )m;
#line 2899
  __cil_tmp22 = (unsigned long )pHba;
#line 2899
  __cil_tmp23 = __cil_tmp22 + 216;
#line 2899
  __cil_tmp24 = *((void **)__cil_tmp23);
#line 2899
  __cil_tmp25 = (u32 *)__cil_tmp24;
#line 2899
  msg = __cil_tmp25 + __cil_tmp21;
#line 2900
  __cil_tmp26 = (void volatile   *)msg;
#line 2900
  writel(196609U, __cil_tmp26);
#line 2901
  __cil_tmp27 = (void volatile   *)msg;
#line 2901
  __cil_tmp28 = __cil_tmp27 + 1U;
#line 2901
  writel(4096U, __cil_tmp28);
#line 2902
  __cil_tmp29 = (void volatile   *)msg;
#line 2902
  __cil_tmp30 = __cil_tmp29 + 2U;
#line 2902
  writel(0U, __cil_tmp30);
#line 2903
  __asm__  volatile   ("sfence": : : "memory");
#line 2905
  __cil_tmp31 = (unsigned long )pHba;
#line 2905
  __cil_tmp32 = __cil_tmp31 + 232;
#line 2905
  __cil_tmp33 = *((void **)__cil_tmp32);
#line 2905
  __cil_tmp34 = (void volatile   *)__cil_tmp33;
#line 2905
  writel(m, __cil_tmp34);
#line 2906
  __asm__  volatile   ("sfence": : : "memory");
  }
#line 2907
  return (0);
}
}
#line 2910 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_init_outbound_q(adpt_hba *pHba ) 
{ u8 *status ;
  dma_addr_t addr ;
  u32 *msg ;
  int i ;
  ulong timeout ;
  u32 m ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  void *__cil_tmp21 ;
  void  volatile   *__cil_tmp22 ;
  long __cil_tmp23 ;
  long __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  char (*__cil_tmp28)[32U] ;
  char *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  void *__cil_tmp33 ;
  u32 *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  struct pci_dev *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct device *__cil_tmp40 ;
  struct dma_attrs *__cil_tmp41 ;
  u8 *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  char (*__cil_tmp47)[32U] ;
  char *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void volatile   *__cil_tmp50 ;
  void volatile   *__cil_tmp51 ;
  void volatile   *__cil_tmp52 ;
  void volatile   *__cil_tmp53 ;
  void volatile   *__cil_tmp54 ;
  void volatile   *__cil_tmp55 ;
  void volatile   *__cil_tmp56 ;
  void volatile   *__cil_tmp57 ;
  void volatile   *__cil_tmp58 ;
  void volatile   *__cil_tmp59 ;
  void volatile   *__cil_tmp60 ;
  void volatile   *__cil_tmp61 ;
  void volatile   *__cil_tmp62 ;
  dma_addr_t *__cil_tmp63 ;
  dma_addr_t __cil_tmp64 ;
  unsigned int __cil_tmp65 ;
  void volatile   *__cil_tmp66 ;
  void volatile   *__cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  void *__cil_tmp70 ;
  void volatile   *__cil_tmp71 ;
  u8 __cil_tmp72 ;
  unsigned int __cil_tmp73 ;
  u8 __cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  long __cil_tmp76 ;
  long __cil_tmp77 ;
  long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  char (*__cil_tmp81)[32U] ;
  char *__cil_tmp82 ;
  u8 __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  struct pci_dev *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  struct device *__cil_tmp90 ;
  void *__cil_tmp91 ;
  dma_addr_t *__cil_tmp92 ;
  dma_addr_t __cil_tmp93 ;
  struct dma_attrs *__cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  struct pci_dev *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  struct device *__cil_tmp100 ;
  void *__cil_tmp101 ;
  dma_addr_t *__cil_tmp102 ;
  dma_addr_t __cil_tmp103 ;
  struct dma_attrs *__cil_tmp104 ;
  u32 *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  u32 *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  struct pci_dev *__cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  struct device *__cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  u32 __cil_tmp119 ;
  u32 __cil_tmp120 ;
  size_t __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  u32 *__cil_tmp124 ;
  void *__cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  dma_addr_t __cil_tmp128 ;
  struct dma_attrs *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  struct pci_dev *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  struct device *__cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  u32 __cil_tmp138 ;
  u32 __cil_tmp139 ;
  size_t __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  dma_addr_t *__cil_tmp143 ;
  struct dma_attrs *__cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  u32 *__cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  u32 *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  char (*__cil_tmp155)[32U] ;
  char *__cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  u32 *__cil_tmp159 ;
  void *__cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  u32 __cil_tmp163 ;
  u32 __cil_tmp164 ;
  size_t __cil_tmp165 ;
  int __cil_tmp166 ;
  unsigned int __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  dma_addr_t __cil_tmp170 ;
  unsigned int __cil_tmp171 ;
  unsigned int __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  void *__cil_tmp175 ;
  void volatile   *__cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  u32 __cil_tmp179 ;
  u32 __cil_tmp180 ;

  {
#line 2914
  msg = (u32 *)0;
#line 2916
  __cil_tmp18 = (unsigned long )jiffies;
#line 2916
  timeout = __cil_tmp18 + 3750UL;
  ldv_32828: 
  {
#line 2920
  __asm__  volatile   ("lfence": : : "memory");
#line 2921
  __cil_tmp19 = (unsigned long )pHba;
#line 2921
  __cil_tmp20 = __cil_tmp19 + 232;
#line 2921
  __cil_tmp21 = *((void **)__cil_tmp20);
#line 2921
  __cil_tmp22 = (void  volatile   *)__cil_tmp21;
#line 2921
  m = readl(__cil_tmp22);
  }
#line 2922
  if (m != 4294967295U) {
#line 2923
    goto ldv_32821;
  } else {

  }
  {
#line 2926
  __cil_tmp23 = (long )jiffies;
#line 2926
  __cil_tmp24 = (long )timeout;
#line 2926
  __cil_tmp25 = __cil_tmp24 - __cil_tmp23;
#line 2926
  if (__cil_tmp25 < 0L) {
    {
#line 2927
    __cil_tmp26 = (unsigned long )pHba;
#line 2927
    __cil_tmp27 = __cil_tmp26 + 114;
#line 2927
    __cil_tmp28 = (char (*)[32U])__cil_tmp27;
#line 2927
    __cil_tmp29 = (char *)__cil_tmp28;
#line 2927
    printk("<4>%s: Timeout waiting for message frame\n", __cil_tmp29);
    }
#line 2928
    return (-110);
  } else {

  }
  }
  {
#line 2930
  schedule_timeout_uninterruptible(1L);
  }
#line 2931
  if (m == 4294967295U) {
#line 2932
    goto ldv_32828;
  } else {
#line 2934
    goto ldv_32821;
  }
  ldv_32821: 
  {
#line 2933
  __cil_tmp30 = (unsigned long )m;
#line 2933
  __cil_tmp31 = (unsigned long )pHba;
#line 2933
  __cil_tmp32 = __cil_tmp31 + 216;
#line 2933
  __cil_tmp33 = *((void **)__cil_tmp32);
#line 2933
  __cil_tmp34 = (u32 *)__cil_tmp33;
#line 2933
  msg = __cil_tmp34 + __cil_tmp30;
#line 2935
  __cil_tmp35 = (unsigned long )pHba;
#line 2935
  __cil_tmp36 = __cil_tmp35 + 8;
#line 2935
  __cil_tmp37 = *((struct pci_dev **)__cil_tmp36);
#line 2935
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 2935
  __cil_tmp39 = __cil_tmp38 + 144;
#line 2935
  __cil_tmp40 = (struct device *)__cil_tmp39;
#line 2935
  __cil_tmp41 = (struct dma_attrs *)0;
#line 2935
  tmp = dma_alloc_attrs(__cil_tmp40, 4UL, & addr, 208U, __cil_tmp41);
#line 2935
  status = (u8 *)tmp;
  }
  {
#line 2936
  __cil_tmp42 = (u8 *)0;
#line 2936
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 2936
  __cil_tmp44 = (unsigned long )status;
#line 2936
  if (__cil_tmp44 == __cil_tmp43) {
    {
#line 2937
    adpt_send_nop(pHba, m);
#line 2938
    __cil_tmp45 = (unsigned long )pHba;
#line 2938
    __cil_tmp46 = __cil_tmp45 + 114;
#line 2938
    __cil_tmp47 = (char (*)[32U])__cil_tmp46;
#line 2938
    __cil_tmp48 = (char *)__cil_tmp47;
#line 2938
    printk("<4>%s: IOP reset failed - no free memory.\n", __cil_tmp48);
    }
#line 2940
    return (-12);
  } else {

  }
  }
  {
#line 2942
  __cil_tmp49 = (void *)status;
#line 2942
  memset(__cil_tmp49, 0, 4UL);
#line 2944
  __cil_tmp50 = (void volatile   *)msg;
#line 2944
  writel(524385U, __cil_tmp50);
#line 2945
  __cil_tmp51 = (void volatile   *)msg;
#line 2945
  __cil_tmp52 = __cil_tmp51 + 1U;
#line 2945
  writel(2701135872U, __cil_tmp52);
#line 2946
  __cil_tmp53 = (void volatile   *)msg;
#line 2946
  __cil_tmp54 = __cil_tmp53 + 2U;
#line 2946
  writel(0U, __cil_tmp54);
#line 2947
  __cil_tmp55 = (void volatile   *)msg;
#line 2947
  __cil_tmp56 = __cil_tmp55 + 3U;
#line 2947
  writel(262U, __cil_tmp56);
#line 2948
  __cil_tmp57 = (void volatile   *)msg;
#line 2948
  __cil_tmp58 = __cil_tmp57 + 4U;
#line 2948
  writel(4096U, __cil_tmp58);
#line 2949
  __cil_tmp59 = (void volatile   *)msg;
#line 2949
  __cil_tmp60 = __cil_tmp59 + 5U;
#line 2949
  writel(1114240U, __cil_tmp60);
#line 2950
  __cil_tmp61 = (void volatile   *)msg;
#line 2950
  __cil_tmp62 = __cil_tmp61 + 6U;
#line 2950
  writel(3489660932U, __cil_tmp62);
#line 2951
  __cil_tmp63 = & addr;
#line 2951
  __cil_tmp64 = *__cil_tmp63;
#line 2951
  __cil_tmp65 = (unsigned int )__cil_tmp64;
#line 2951
  __cil_tmp66 = (void volatile   *)msg;
#line 2951
  __cil_tmp67 = __cil_tmp66 + 7U;
#line 2951
  writel(__cil_tmp65, __cil_tmp67);
#line 2953
  __cil_tmp68 = (unsigned long )pHba;
#line 2953
  __cil_tmp69 = __cil_tmp68 + 232;
#line 2953
  __cil_tmp70 = *((void **)__cil_tmp69);
#line 2953
  __cil_tmp71 = (void volatile   *)__cil_tmp70;
#line 2953
  writel(m, __cil_tmp71);
#line 2954
  __asm__  volatile   ("sfence": : : "memory");
  }
  ldv_32836: ;
  {
#line 2958
  __cil_tmp72 = *status;
#line 2958
  __cil_tmp73 = (unsigned int )__cil_tmp72;
#line 2958
  if (__cil_tmp73 != 0U) {
    {
#line 2959
    __cil_tmp74 = *status;
#line 2959
    __cil_tmp75 = (unsigned int )__cil_tmp74;
#line 2959
    if (__cil_tmp75 != 1U) {
#line 2960
      goto ldv_32829;
    } else {

    }
    }
  } else {

  }
  }
#line 2963
  __asm__  volatile   ("lfence": : : "memory");
  {
#line 2964
  __cil_tmp76 = (long )jiffies;
#line 2964
  __cil_tmp77 = (long )timeout;
#line 2964
  __cil_tmp78 = __cil_tmp77 - __cil_tmp76;
#line 2964
  if (__cil_tmp78 < 0L) {
    {
#line 2965
    __cil_tmp79 = (unsigned long )pHba;
#line 2965
    __cil_tmp80 = __cil_tmp79 + 114;
#line 2965
    __cil_tmp81 = (char (*)[32U])__cil_tmp80;
#line 2965
    __cil_tmp82 = (char *)__cil_tmp81;
#line 2965
    printk("<4>%s: Timeout Initializing\n", __cil_tmp82);
    }
#line 2970
    return (-110);
  } else {

  }
  }
  {
#line 2972
  schedule_timeout_uninterruptible(1L);
  }
#line 2973
  goto ldv_32836;
  ldv_32829: ;
  {
#line 2977
  __cil_tmp83 = *status;
#line 2977
  __cil_tmp84 = (unsigned int )__cil_tmp83;
#line 2977
  if (__cil_tmp84 != 4U) {
    {
#line 2978
    __cil_tmp85 = (unsigned long )pHba;
#line 2978
    __cil_tmp86 = __cil_tmp85 + 8;
#line 2978
    __cil_tmp87 = *((struct pci_dev **)__cil_tmp86);
#line 2978
    __cil_tmp88 = (unsigned long )__cil_tmp87;
#line 2978
    __cil_tmp89 = __cil_tmp88 + 144;
#line 2978
    __cil_tmp90 = (struct device *)__cil_tmp89;
#line 2978
    __cil_tmp91 = (void *)status;
#line 2978
    __cil_tmp92 = & addr;
#line 2978
    __cil_tmp93 = *__cil_tmp92;
#line 2978
    __cil_tmp94 = (struct dma_attrs *)0;
#line 2978
    dma_free_attrs(__cil_tmp90, 4UL, __cil_tmp91, __cil_tmp93, __cil_tmp94);
    }
#line 2979
    return (-2);
  } else {

  }
  }
  {
#line 2981
  __cil_tmp95 = (unsigned long )pHba;
#line 2981
  __cil_tmp96 = __cil_tmp95 + 8;
#line 2981
  __cil_tmp97 = *((struct pci_dev **)__cil_tmp96);
#line 2981
  __cil_tmp98 = (unsigned long )__cil_tmp97;
#line 2981
  __cil_tmp99 = __cil_tmp98 + 144;
#line 2981
  __cil_tmp100 = (struct device *)__cil_tmp99;
#line 2981
  __cil_tmp101 = (void *)status;
#line 2981
  __cil_tmp102 = & addr;
#line 2981
  __cil_tmp103 = *__cil_tmp102;
#line 2981
  __cil_tmp104 = (struct dma_attrs *)0;
#line 2981
  dma_free_attrs(__cil_tmp100, 4UL, __cil_tmp101, __cil_tmp103, __cil_tmp104);
  }
  {
#line 2983
  __cil_tmp105 = (u32 *)0;
#line 2983
  __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 2983
  __cil_tmp107 = (unsigned long )pHba;
#line 2983
  __cil_tmp108 = __cil_tmp107 + 272;
#line 2983
  __cil_tmp109 = *((u32 **)__cil_tmp108);
#line 2983
  __cil_tmp110 = (unsigned long )__cil_tmp109;
#line 2983
  if (__cil_tmp110 != __cil_tmp106) {
    {
#line 2984
    __cil_tmp111 = (unsigned long )pHba;
#line 2984
    __cil_tmp112 = __cil_tmp111 + 8;
#line 2984
    __cil_tmp113 = *((struct pci_dev **)__cil_tmp112);
#line 2984
    __cil_tmp114 = (unsigned long )__cil_tmp113;
#line 2984
    __cil_tmp115 = __cil_tmp114 + 144;
#line 2984
    __cil_tmp116 = (struct device *)__cil_tmp115;
#line 2984
    __cil_tmp117 = (unsigned long )pHba;
#line 2984
    __cil_tmp118 = __cil_tmp117 + 264;
#line 2984
    __cil_tmp119 = *((u32 *)__cil_tmp118);
#line 2984
    __cil_tmp120 = __cil_tmp119 * 68U;
#line 2984
    __cil_tmp121 = (size_t )__cil_tmp120;
#line 2984
    __cil_tmp122 = (unsigned long )pHba;
#line 2984
    __cil_tmp123 = __cil_tmp122 + 272;
#line 2984
    __cil_tmp124 = *((u32 **)__cil_tmp123);
#line 2984
    __cil_tmp125 = (void *)__cil_tmp124;
#line 2984
    __cil_tmp126 = (unsigned long )pHba;
#line 2984
    __cil_tmp127 = __cil_tmp126 + 280;
#line 2984
    __cil_tmp128 = *((dma_addr_t *)__cil_tmp127);
#line 2984
    __cil_tmp129 = (struct dma_attrs *)0;
#line 2984
    dma_free_attrs(__cil_tmp116, __cil_tmp121, __cil_tmp125, __cil_tmp128, __cil_tmp129);
    }
  } else {

  }
  }
  {
#line 2989
  __cil_tmp130 = (unsigned long )pHba;
#line 2989
  __cil_tmp131 = __cil_tmp130 + 8;
#line 2989
  __cil_tmp132 = *((struct pci_dev **)__cil_tmp131);
#line 2989
  __cil_tmp133 = (unsigned long )__cil_tmp132;
#line 2989
  __cil_tmp134 = __cil_tmp133 + 144;
#line 2989
  __cil_tmp135 = (struct device *)__cil_tmp134;
#line 2989
  __cil_tmp136 = (unsigned long )pHba;
#line 2989
  __cil_tmp137 = __cil_tmp136 + 264;
#line 2989
  __cil_tmp138 = *((u32 *)__cil_tmp137);
#line 2989
  __cil_tmp139 = __cil_tmp138 * 68U;
#line 2989
  __cil_tmp140 = (size_t )__cil_tmp139;
#line 2989
  __cil_tmp141 = (unsigned long )pHba;
#line 2989
  __cil_tmp142 = __cil_tmp141 + 280;
#line 2989
  __cil_tmp143 = (dma_addr_t *)__cil_tmp142;
#line 2989
  __cil_tmp144 = (struct dma_attrs *)0;
#line 2989
  tmp___0 = dma_alloc_attrs(__cil_tmp135, __cil_tmp140, __cil_tmp143, 208U, __cil_tmp144);
#line 2989
  __cil_tmp145 = (unsigned long )pHba;
#line 2989
  __cil_tmp146 = __cil_tmp145 + 272;
#line 2989
  *((u32 **)__cil_tmp146) = (u32 *)tmp___0;
  }
  {
#line 2992
  __cil_tmp147 = (u32 *)0;
#line 2992
  __cil_tmp148 = (unsigned long )__cil_tmp147;
#line 2992
  __cil_tmp149 = (unsigned long )pHba;
#line 2992
  __cil_tmp150 = __cil_tmp149 + 272;
#line 2992
  __cil_tmp151 = *((u32 **)__cil_tmp150);
#line 2992
  __cil_tmp152 = (unsigned long )__cil_tmp151;
#line 2992
  if (__cil_tmp152 == __cil_tmp148) {
    {
#line 2993
    __cil_tmp153 = (unsigned long )pHba;
#line 2993
    __cil_tmp154 = __cil_tmp153 + 114;
#line 2993
    __cil_tmp155 = (char (*)[32U])__cil_tmp154;
#line 2993
    __cil_tmp156 = (char *)__cil_tmp155;
#line 2993
    printk("<3>%s: Could not allocate reply pool\n", __cil_tmp156);
    }
#line 2994
    return (-12);
  } else {

  }
  }
  {
#line 2996
  __cil_tmp157 = (unsigned long )pHba;
#line 2996
  __cil_tmp158 = __cil_tmp157 + 272;
#line 2996
  __cil_tmp159 = *((u32 **)__cil_tmp158);
#line 2996
  __cil_tmp160 = (void *)__cil_tmp159;
#line 2996
  __cil_tmp161 = (unsigned long )pHba;
#line 2996
  __cil_tmp162 = __cil_tmp161 + 264;
#line 2996
  __cil_tmp163 = *((u32 *)__cil_tmp162);
#line 2996
  __cil_tmp164 = __cil_tmp163 * 68U;
#line 2996
  __cil_tmp165 = (size_t )__cil_tmp164;
#line 2996
  memset(__cil_tmp160, 0, __cil_tmp165);
#line 2998
  i = 0;
  }
#line 2998
  goto ldv_32838;
  ldv_32837: 
  {
#line 2999
  __cil_tmp166 = i * 68;
#line 2999
  __cil_tmp167 = (unsigned int )__cil_tmp166;
#line 2999
  __cil_tmp168 = (unsigned long )pHba;
#line 2999
  __cil_tmp169 = __cil_tmp168 + 280;
#line 2999
  __cil_tmp170 = *((dma_addr_t *)__cil_tmp169);
#line 2999
  __cil_tmp171 = (unsigned int )__cil_tmp170;
#line 2999
  __cil_tmp172 = __cil_tmp171 + __cil_tmp167;
#line 2999
  __cil_tmp173 = (unsigned long )pHba;
#line 2999
  __cil_tmp174 = __cil_tmp173 + 240;
#line 2999
  __cil_tmp175 = *((void **)__cil_tmp174);
#line 2999
  __cil_tmp176 = (void volatile   *)__cil_tmp175;
#line 2999
  writel(__cil_tmp172, __cil_tmp176);
#line 3001
  __asm__  volatile   ("sfence": : : "memory");
#line 2998
  i = i + 1;
  }
  ldv_32838: ;
  {
#line 2998
  __cil_tmp177 = (unsigned long )pHba;
#line 2998
  __cil_tmp178 = __cil_tmp177 + 264;
#line 2998
  __cil_tmp179 = *((u32 *)__cil_tmp178);
#line 2998
  __cil_tmp180 = (u32 )i;
#line 2998
  if (__cil_tmp180 < __cil_tmp179) {
#line 2999
    goto ldv_32837;
  } else {
#line 3001
    goto ldv_32839;
  }
  }
  ldv_32839: 
  {
#line 3003
  adpt_i2o_status_get(pHba);
  }
#line 3004
  return (0);
}
}
#line 3019 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_status_get(adpt_hba *pHba ) 
{ ulong timeout ;
  u32 m ;
  u32 *msg ;
  u8 *status_block ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  i2o_status_block *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  i2o_status_block *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct pci_dev *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct device *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  dma_addr_t *__cil_tmp32 ;
  struct dma_attrs *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  i2o_status_block *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  i2o_status_block *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  i2o_status_block *__cil_tmp47 ;
  void *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  i2o_status_block *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  void *__cil_tmp55 ;
  void  volatile   *__cil_tmp56 ;
  long __cil_tmp57 ;
  long __cil_tmp58 ;
  long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  char (*__cil_tmp62)[32U] ;
  char *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  void *__cil_tmp67 ;
  u32 *__cil_tmp68 ;
  void volatile   *__cil_tmp69 ;
  void volatile   *__cil_tmp70 ;
  void volatile   *__cil_tmp71 ;
  void volatile   *__cil_tmp72 ;
  void volatile   *__cil_tmp73 ;
  void volatile   *__cil_tmp74 ;
  void volatile   *__cil_tmp75 ;
  void volatile   *__cil_tmp76 ;
  void volatile   *__cil_tmp77 ;
  void volatile   *__cil_tmp78 ;
  void volatile   *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  dma_addr_t __cil_tmp82 ;
  void volatile   *__cil_tmp83 ;
  void volatile   *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  dma_addr_t __cil_tmp87 ;
  void volatile   *__cil_tmp88 ;
  void volatile   *__cil_tmp89 ;
  void volatile   *__cil_tmp90 ;
  void volatile   *__cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  void *__cil_tmp94 ;
  void volatile   *__cil_tmp95 ;
  long __cil_tmp96 ;
  long __cil_tmp97 ;
  long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  u8 *__cil_tmp102 ;
  u8 __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  i2o_status_block *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  u32 __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  i2o_status_block *__cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  u32 __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  i2o_status_block *__cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  __u16 __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  i2o_status_block *__cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  __u16 __cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  unsigned long __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  u32 __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;

  {
#line 3024
  status_block = (u8 *)0;
  {
#line 3026
  __cil_tmp18 = (i2o_status_block *)0;
#line 3026
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 3026
  __cil_tmp20 = (unsigned long )pHba;
#line 3026
  __cil_tmp21 = __cil_tmp20 + 296;
#line 3026
  __cil_tmp22 = *((i2o_status_block **)__cil_tmp21);
#line 3026
  __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 3026
  if (__cil_tmp23 == __cil_tmp19) {
    {
#line 3027
    __cil_tmp24 = (unsigned long )pHba;
#line 3027
    __cil_tmp25 = __cil_tmp24 + 8;
#line 3027
    __cil_tmp26 = *((struct pci_dev **)__cil_tmp25);
#line 3027
    __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 3027
    __cil_tmp28 = __cil_tmp27 + 144;
#line 3027
    __cil_tmp29 = (struct device *)__cil_tmp28;
#line 3027
    __cil_tmp30 = (unsigned long )pHba;
#line 3027
    __cil_tmp31 = __cil_tmp30 + 304;
#line 3027
    __cil_tmp32 = (dma_addr_t *)__cil_tmp31;
#line 3027
    __cil_tmp33 = (struct dma_attrs *)0;
#line 3027
    tmp = dma_alloc_attrs(__cil_tmp29, 88UL, __cil_tmp32, 208U, __cil_tmp33);
#line 3027
    __cil_tmp34 = (unsigned long )pHba;
#line 3027
    __cil_tmp35 = __cil_tmp34 + 296;
#line 3027
    *((i2o_status_block **)__cil_tmp35) = (i2o_status_block *)tmp;
    }
    {
#line 3030
    __cil_tmp36 = (i2o_status_block *)0;
#line 3030
    __cil_tmp37 = (unsigned long )__cil_tmp36;
#line 3030
    __cil_tmp38 = (unsigned long )pHba;
#line 3030
    __cil_tmp39 = __cil_tmp38 + 296;
#line 3030
    __cil_tmp40 = *((i2o_status_block **)__cil_tmp39);
#line 3030
    __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 3030
    if (__cil_tmp41 == __cil_tmp37) {
      {
#line 3031
      __cil_tmp42 = (unsigned long )pHba;
#line 3031
      __cil_tmp43 = __cil_tmp42 + 104;
#line 3031
      __cil_tmp44 = *((int *)__cil_tmp43);
#line 3031
      printk("<3>dpti%d: Get Status Block failed; Out of memory. \n", __cil_tmp44);
      }
#line 3034
      return (-12);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 3037
  __cil_tmp45 = (unsigned long )pHba;
#line 3037
  __cil_tmp46 = __cil_tmp45 + 296;
#line 3037
  __cil_tmp47 = *((i2o_status_block **)__cil_tmp46);
#line 3037
  __cil_tmp48 = (void *)__cil_tmp47;
#line 3037
  memset(__cil_tmp48, 0, 88UL);
#line 3038
  __cil_tmp49 = (unsigned long )pHba;
#line 3038
  __cil_tmp50 = __cil_tmp49 + 296;
#line 3038
  __cil_tmp51 = *((i2o_status_block **)__cil_tmp50);
#line 3038
  status_block = (u8 *)__cil_tmp51;
#line 3039
  __cil_tmp52 = (unsigned long )jiffies;
#line 3039
  timeout = __cil_tmp52 + 3750UL;
  }
  ldv_32854: 
  {
#line 3041
  __asm__  volatile   ("lfence": : : "memory");
#line 3042
  __cil_tmp53 = (unsigned long )pHba;
#line 3042
  __cil_tmp54 = __cil_tmp53 + 232;
#line 3042
  __cil_tmp55 = *((void **)__cil_tmp54);
#line 3042
  __cil_tmp56 = (void  volatile   *)__cil_tmp55;
#line 3042
  m = readl(__cil_tmp56);
  }
#line 3043
  if (m != 4294967295U) {
#line 3044
    goto ldv_32847;
  } else {

  }
  {
#line 3046
  __cil_tmp57 = (long )jiffies;
#line 3046
  __cil_tmp58 = (long )timeout;
#line 3046
  __cil_tmp59 = __cil_tmp58 - __cil_tmp57;
#line 3046
  if (__cil_tmp59 < 0L) {
    {
#line 3047
    __cil_tmp60 = (unsigned long )pHba;
#line 3047
    __cil_tmp61 = __cil_tmp60 + 114;
#line 3047
    __cil_tmp62 = (char (*)[32U])__cil_tmp61;
#line 3047
    __cil_tmp63 = (char *)__cil_tmp62;
#line 3047
    printk("<3>%s: Timeout waiting for message !\n", __cil_tmp63);
    }
#line 3049
    return (-110);
  } else {

  }
  }
  {
#line 3051
  schedule_timeout_uninterruptible(1L);
  }
#line 3052
  if (m == 4294967295U) {
#line 3053
    goto ldv_32854;
  } else {
#line 3055
    goto ldv_32847;
  }
  ldv_32847: 
  {
#line 3055
  __cil_tmp64 = (unsigned long )m;
#line 3055
  __cil_tmp65 = (unsigned long )pHba;
#line 3055
  __cil_tmp66 = __cil_tmp65 + 216;
#line 3055
  __cil_tmp67 = *((void **)__cil_tmp66);
#line 3055
  __cil_tmp68 = (u32 *)__cil_tmp67;
#line 3055
  msg = __cil_tmp68 + __cil_tmp64;
#line 3057
  __cil_tmp69 = (void volatile   *)msg;
#line 3057
  writel(589825U, __cil_tmp69);
#line 3058
  __cil_tmp70 = (void volatile   *)msg;
#line 3058
  __cil_tmp71 = __cil_tmp70 + 1U;
#line 3058
  writel(2684358656U, __cil_tmp71);
#line 3059
  __cil_tmp72 = (void volatile   *)msg;
#line 3059
  __cil_tmp73 = __cil_tmp72 + 2U;
#line 3059
  writel(1U, __cil_tmp73);
#line 3060
  __cil_tmp74 = (void volatile   *)msg;
#line 3060
  __cil_tmp75 = __cil_tmp74 + 3U;
#line 3060
  writel(0U, __cil_tmp75);
#line 3061
  __cil_tmp76 = (void volatile   *)msg;
#line 3061
  __cil_tmp77 = __cil_tmp76 + 4U;
#line 3061
  writel(0U, __cil_tmp77);
#line 3062
  __cil_tmp78 = (void volatile   *)msg;
#line 3062
  __cil_tmp79 = __cil_tmp78 + 5U;
#line 3062
  writel(0U, __cil_tmp79);
#line 3063
  __cil_tmp80 = (unsigned long )pHba;
#line 3063
  __cil_tmp81 = __cil_tmp80 + 304;
#line 3063
  __cil_tmp82 = *((dma_addr_t *)__cil_tmp81);
#line 3063
  tmp___0 = dma_low(__cil_tmp82);
#line 3063
  __cil_tmp83 = (void volatile   *)msg;
#line 3063
  __cil_tmp84 = __cil_tmp83 + 6U;
#line 3063
  writel(tmp___0, __cil_tmp84);
#line 3064
  __cil_tmp85 = (unsigned long )pHba;
#line 3064
  __cil_tmp86 = __cil_tmp85 + 304;
#line 3064
  __cil_tmp87 = *((dma_addr_t *)__cil_tmp86);
#line 3064
  tmp___1 = dma_high(__cil_tmp87);
#line 3064
  __cil_tmp88 = (void volatile   *)msg;
#line 3064
  __cil_tmp89 = __cil_tmp88 + 7U;
#line 3064
  writel(tmp___1, __cil_tmp89);
#line 3065
  __cil_tmp90 = (void volatile   *)msg;
#line 3065
  __cil_tmp91 = __cil_tmp90 + 8U;
#line 3065
  writel(88U, __cil_tmp91);
#line 3068
  __cil_tmp92 = (unsigned long )pHba;
#line 3068
  __cil_tmp93 = __cil_tmp92 + 232;
#line 3068
  __cil_tmp94 = *((void **)__cil_tmp93);
#line 3068
  __cil_tmp95 = (void volatile   *)__cil_tmp94;
#line 3068
  writel(m, __cil_tmp95);
#line 3069
  __asm__  volatile   ("sfence": : : "memory");
  }
#line 3071
  goto ldv_32862;
  ldv_32861: ;
  {
#line 3072
  __cil_tmp96 = (long )jiffies;
#line 3072
  __cil_tmp97 = (long )timeout;
#line 3072
  __cil_tmp98 = __cil_tmp97 - __cil_tmp96;
#line 3072
  if (__cil_tmp98 < 0L) {
    {
#line 3073
    __cil_tmp99 = (unsigned long )pHba;
#line 3073
    __cil_tmp100 = __cil_tmp99 + 104;
#line 3073
    __cil_tmp101 = *((int *)__cil_tmp100);
#line 3073
    printk("<3>dpti%d: Get status timeout.\n", __cil_tmp101);
    }
#line 3075
    return (-110);
  } else {

  }
  }
  {
#line 3077
  __asm__  volatile   ("lfence": : : "memory");
#line 3078
  schedule_timeout_uninterruptible(1L);
  }
  ldv_32862: ;
  {
#line 3071
  __cil_tmp102 = status_block + 87UL;
#line 3071
  __cil_tmp103 = *__cil_tmp102;
#line 3071
  __cil_tmp104 = (unsigned int )__cil_tmp103;
#line 3071
  if (__cil_tmp104 != 255U) {
#line 3072
    goto ldv_32861;
  } else {
#line 3074
    goto ldv_32863;
  }
  }
  ldv_32863: 
#line 3082
  __cil_tmp105 = (unsigned long )pHba;
#line 3082
  __cil_tmp106 = __cil_tmp105 + 260;
#line 3082
  __cil_tmp107 = (unsigned long )pHba;
#line 3082
  __cil_tmp108 = __cil_tmp107 + 296;
#line 3082
  __cil_tmp109 = *((i2o_status_block **)__cil_tmp108);
#line 3082
  __cil_tmp110 = (unsigned long )__cil_tmp109;
#line 3082
  __cil_tmp111 = __cil_tmp110 + 16;
#line 3082
  *((u32 *)__cil_tmp106) = *((__u32 *)__cil_tmp111);
  {
#line 3083
  __cil_tmp112 = (unsigned long )pHba;
#line 3083
  __cil_tmp113 = __cil_tmp112 + 260;
#line 3083
  __cil_tmp114 = *((u32 *)__cil_tmp113);
#line 3083
  if (__cil_tmp114 > 255U) {
#line 3084
    __cil_tmp115 = (unsigned long )pHba;
#line 3084
    __cil_tmp116 = __cil_tmp115 + 260;
#line 3084
    *((u32 *)__cil_tmp116) = 255U;
  } else {

  }
  }
#line 3087
  __cil_tmp117 = (unsigned long )pHba;
#line 3087
  __cil_tmp118 = __cil_tmp117 + 264;
#line 3087
  __cil_tmp119 = (unsigned long )pHba;
#line 3087
  __cil_tmp120 = __cil_tmp119 + 296;
#line 3087
  __cil_tmp121 = *((i2o_status_block **)__cil_tmp120);
#line 3087
  __cil_tmp122 = (unsigned long )__cil_tmp121;
#line 3087
  __cil_tmp123 = __cil_tmp122 + 24;
#line 3087
  *((u32 *)__cil_tmp118) = *((__u32 *)__cil_tmp123);
  {
#line 3088
  __cil_tmp124 = (unsigned long )pHba;
#line 3088
  __cil_tmp125 = __cil_tmp124 + 264;
#line 3088
  __cil_tmp126 = *((u32 *)__cil_tmp125);
#line 3088
  if (__cil_tmp126 > 255U) {
#line 3089
    __cil_tmp127 = (unsigned long )pHba;
#line 3089
    __cil_tmp128 = __cil_tmp127 + 264;
#line 3089
    *((u32 *)__cil_tmp128) = 255U;
  } else {

  }
  }
  {
#line 3093
  tmp___2 = dpt_dma64(pHba);
  }
#line 3093
  if (tmp___2 != 0) {
#line 3094
    __cil_tmp129 = (unsigned long )pHba;
#line 3094
    __cil_tmp130 = __cil_tmp129 + 288;
#line 3094
    __cil_tmp131 = (unsigned long )pHba;
#line 3094
    __cil_tmp132 = __cil_tmp131 + 296;
#line 3094
    __cil_tmp133 = *((i2o_status_block **)__cil_tmp132);
#line 3094
    __cil_tmp134 = (unsigned long )__cil_tmp133;
#line 3094
    __cil_tmp135 = __cil_tmp134 + 12;
#line 3094
    __cil_tmp136 = *((__u16 *)__cil_tmp135);
#line 3094
    __cil_tmp137 = (int )__cil_tmp136;
#line 3094
    __cil_tmp138 = __cil_tmp137 * 4;
#line 3094
    __cil_tmp139 = (unsigned long )__cil_tmp138;
#line 3094
    __cil_tmp140 = __cil_tmp139 - 56UL;
#line 3094
    __cil_tmp141 = __cil_tmp140 / 12UL;
#line 3094
    *((u32 *)__cil_tmp130) = (u32 )__cil_tmp141;
  } else {
#line 3099
    __cil_tmp142 = (unsigned long )pHba;
#line 3099
    __cil_tmp143 = __cil_tmp142 + 288;
#line 3099
    __cil_tmp144 = (unsigned long )pHba;
#line 3099
    __cil_tmp145 = __cil_tmp144 + 296;
#line 3099
    __cil_tmp146 = *((i2o_status_block **)__cil_tmp145);
#line 3099
    __cil_tmp147 = (unsigned long )__cil_tmp146;
#line 3099
    __cil_tmp148 = __cil_tmp147 + 12;
#line 3099
    __cil_tmp149 = *((__u16 *)__cil_tmp148);
#line 3099
    __cil_tmp150 = (int )__cil_tmp149;
#line 3099
    __cil_tmp151 = __cil_tmp150 * 4;
#line 3099
    __cil_tmp152 = (unsigned long )__cil_tmp151;
#line 3099
    __cil_tmp153 = __cil_tmp152 - 48UL;
#line 3099
    __cil_tmp154 = __cil_tmp153 / 8UL;
#line 3099
    *((u32 *)__cil_tmp143) = (u32 )__cil_tmp154;
  }
  {
#line 3104
  __cil_tmp155 = (unsigned long )pHba;
#line 3104
  __cil_tmp156 = __cil_tmp155 + 288;
#line 3104
  __cil_tmp157 = *((u32 *)__cil_tmp156);
#line 3104
  if (__cil_tmp157 > 56U) {
#line 3105
    __cil_tmp158 = (unsigned long )pHba;
#line 3105
    __cil_tmp159 = __cil_tmp158 + 288;
#line 3105
    *((u32 *)__cil_tmp159) = 56U;
  } else {

  }
  }
#line 3137
  return (0);
}
}
#line 3143 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_lct_get(adpt_hba *pHba ) 
{ u32 msg[8U] ;
  int ret ;
  u32 buf[16U] ;
  void *tmp ;
  int tmp___0 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  uint __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  i2o_status_block *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  i2o_lct *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  i2o_lct *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  i2o_status_block *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  i2o_lct *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  i2o_lct *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct pci_dev *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  struct device *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  uint __cil_tmp44 ;
  size_t __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  dma_addr_t *__cil_tmp48 ;
  struct dma_attrs *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  i2o_lct *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  i2o_lct *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  char (*__cil_tmp60)[32U] ;
  char *__cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  i2o_lct *__cil_tmp64 ;
  void *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  uint __cil_tmp68 ;
  size_t __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  uint __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  dma_addr_t __cil_tmp91 ;
  u32 *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  char (*__cil_tmp95)[32U] ;
  char *__cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  uint __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  i2o_lct *__cil_tmp102 ;
  unsigned short __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  uint __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  i2o_lct *__cil_tmp111 ;
  unsigned short __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  struct pci_dev *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  struct device *__cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  uint __cil_tmp123 ;
  size_t __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  i2o_lct *__cil_tmp127 ;
  void *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  dma_addr_t __cil_tmp131 ;
  struct dma_attrs *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  i2o_lct *__cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  i2o_lct *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  void *__cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  u32 __cil_tmp150 ;
  ulong __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  ulong __cil_tmp154 ;
  ulong __cil_tmp155 ;
  resource_size_t __cil_tmp156 ;
  unsigned long __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  u32 __cil_tmp159 ;
  unsigned long __cil_tmp160 ;
  void *__cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  unsigned long __cil_tmp164 ;
  void *__cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  unsigned long __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  void *__cil_tmp171 ;
  unsigned long __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  unsigned long __cil_tmp175 ;
  void *__cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  unsigned long __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  void *__cil_tmp181 ;
  unsigned long __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  unsigned long __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  unsigned long __cil_tmp189 ;
  u32 __cil_tmp190 ;
  unsigned long __cil_tmp191 ;
  unsigned long __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  void *__cil_tmp194 ;
  unsigned long __cil_tmp195 ;
  unsigned long __cil_tmp196 ;

  {
  {
#line 3149
  __cil_tmp7 = (unsigned long )pHba;
#line 3149
  __cil_tmp8 = __cil_tmp7 + 344;
#line 3149
  __cil_tmp9 = *((uint *)__cil_tmp8);
#line 3149
  if (__cil_tmp9 == 0U) {
#line 3150
    __cil_tmp10 = (unsigned long )pHba;
#line 3150
    __cil_tmp11 = __cil_tmp10 + 344;
#line 3150
    __cil_tmp12 = (unsigned long )pHba;
#line 3150
    __cil_tmp13 = __cil_tmp12 + 296;
#line 3150
    __cil_tmp14 = *((i2o_status_block **)__cil_tmp13);
#line 3150
    __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 3150
    __cil_tmp16 = __cil_tmp15 + 52;
#line 3150
    *((uint *)__cil_tmp11) = *((__u32 *)__cil_tmp16);
  } else {
    {
#line 3149
    __cil_tmp17 = (i2o_lct *)0;
#line 3149
    __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 3149
    __cil_tmp19 = (unsigned long )pHba;
#line 3149
    __cil_tmp20 = __cil_tmp19 + 328;
#line 3149
    __cil_tmp21 = *((i2o_lct **)__cil_tmp20);
#line 3149
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 3149
    if (__cil_tmp22 == __cil_tmp18) {
#line 3150
      __cil_tmp23 = (unsigned long )pHba;
#line 3150
      __cil_tmp24 = __cil_tmp23 + 344;
#line 3150
      __cil_tmp25 = (unsigned long )pHba;
#line 3150
      __cil_tmp26 = __cil_tmp25 + 296;
#line 3150
      __cil_tmp27 = *((i2o_status_block **)__cil_tmp26);
#line 3150
      __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 3150
      __cil_tmp29 = __cil_tmp28 + 52;
#line 3150
      *((uint *)__cil_tmp24) = *((__u32 *)__cil_tmp29);
    } else {

    }
    }
  }
  }
  ldv_32870: ;
  {
#line 3153
  __cil_tmp30 = (i2o_lct *)0;
#line 3153
  __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 3153
  __cil_tmp32 = (unsigned long )pHba;
#line 3153
  __cil_tmp33 = __cil_tmp32 + 328;
#line 3153
  __cil_tmp34 = *((i2o_lct **)__cil_tmp33);
#line 3153
  __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 3153
  if (__cil_tmp35 == __cil_tmp31) {
    {
#line 3154
    __cil_tmp36 = (unsigned long )pHba;
#line 3154
    __cil_tmp37 = __cil_tmp36 + 8;
#line 3154
    __cil_tmp38 = *((struct pci_dev **)__cil_tmp37);
#line 3154
    __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 3154
    __cil_tmp40 = __cil_tmp39 + 144;
#line 3154
    __cil_tmp41 = (struct device *)__cil_tmp40;
#line 3154
    __cil_tmp42 = (unsigned long )pHba;
#line 3154
    __cil_tmp43 = __cil_tmp42 + 344;
#line 3154
    __cil_tmp44 = *((uint *)__cil_tmp43);
#line 3154
    __cil_tmp45 = (size_t )__cil_tmp44;
#line 3154
    __cil_tmp46 = (unsigned long )pHba;
#line 3154
    __cil_tmp47 = __cil_tmp46 + 336;
#line 3154
    __cil_tmp48 = (dma_addr_t *)__cil_tmp47;
#line 3154
    __cil_tmp49 = (struct dma_attrs *)0;
#line 3154
    tmp = dma_alloc_attrs(__cil_tmp41, __cil_tmp45, __cil_tmp48, 32U, __cil_tmp49);
#line 3154
    __cil_tmp50 = (unsigned long )pHba;
#line 3154
    __cil_tmp51 = __cil_tmp50 + 328;
#line 3154
    *((i2o_lct **)__cil_tmp51) = (i2o_lct *)tmp;
    }
    {
#line 3157
    __cil_tmp52 = (i2o_lct *)0;
#line 3157
    __cil_tmp53 = (unsigned long )__cil_tmp52;
#line 3157
    __cil_tmp54 = (unsigned long )pHba;
#line 3157
    __cil_tmp55 = __cil_tmp54 + 328;
#line 3157
    __cil_tmp56 = *((i2o_lct **)__cil_tmp55);
#line 3157
    __cil_tmp57 = (unsigned long )__cil_tmp56;
#line 3157
    if (__cil_tmp57 == __cil_tmp53) {
      {
#line 3158
      __cil_tmp58 = (unsigned long )pHba;
#line 3158
      __cil_tmp59 = __cil_tmp58 + 114;
#line 3158
      __cil_tmp60 = (char (*)[32U])__cil_tmp59;
#line 3158
      __cil_tmp61 = (char *)__cil_tmp60;
#line 3158
      printk("<2>%s: Lct Get failed. Out of memory.\n", __cil_tmp61);
      }
#line 3160
      return (-12);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 3163
  __cil_tmp62 = (unsigned long )pHba;
#line 3163
  __cil_tmp63 = __cil_tmp62 + 328;
#line 3163
  __cil_tmp64 = *((i2o_lct **)__cil_tmp63);
#line 3163
  __cil_tmp65 = (void *)__cil_tmp64;
#line 3163
  __cil_tmp66 = (unsigned long )pHba;
#line 3163
  __cil_tmp67 = __cil_tmp66 + 344;
#line 3163
  __cil_tmp68 = *((uint *)__cil_tmp67);
#line 3163
  __cil_tmp69 = (size_t )__cil_tmp68;
#line 3163
  memset(__cil_tmp65, 0, __cil_tmp69);
#line 3165
  __cil_tmp70 = 0 * 4UL;
#line 3165
  __cil_tmp71 = (unsigned long )(msg) + __cil_tmp70;
#line 3165
  *((u32 *)__cil_tmp71) = 524385U;
#line 3166
  __cil_tmp72 = 1 * 4UL;
#line 3166
  __cil_tmp73 = (unsigned long )(msg) + __cil_tmp72;
#line 3166
  *((u32 *)__cil_tmp73) = 2717913088U;
#line 3167
  __cil_tmp74 = 2 * 4UL;
#line 3167
  __cil_tmp75 = (unsigned long )(msg) + __cil_tmp74;
#line 3167
  *((u32 *)__cil_tmp75) = 0U;
#line 3168
  __cil_tmp76 = 3 * 4UL;
#line 3168
  __cil_tmp77 = (unsigned long )(msg) + __cil_tmp76;
#line 3168
  *((u32 *)__cil_tmp77) = 0U;
#line 3169
  __cil_tmp78 = 4 * 4UL;
#line 3169
  __cil_tmp79 = (unsigned long )(msg) + __cil_tmp78;
#line 3169
  *((u32 *)__cil_tmp79) = 4294967295U;
#line 3170
  __cil_tmp80 = 5 * 4UL;
#line 3170
  __cil_tmp81 = (unsigned long )(msg) + __cil_tmp80;
#line 3170
  *((u32 *)__cil_tmp81) = 0U;
#line 3171
  __cil_tmp82 = 6 * 4UL;
#line 3171
  __cil_tmp83 = (unsigned long )(msg) + __cil_tmp82;
#line 3171
  __cil_tmp84 = (unsigned long )pHba;
#line 3171
  __cil_tmp85 = __cil_tmp84 + 344;
#line 3171
  __cil_tmp86 = *((uint *)__cil_tmp85);
#line 3171
  *((u32 *)__cil_tmp83) = __cil_tmp86 | 3489660928U;
#line 3172
  __cil_tmp87 = 7 * 4UL;
#line 3172
  __cil_tmp88 = (unsigned long )(msg) + __cil_tmp87;
#line 3172
  __cil_tmp89 = (unsigned long )pHba;
#line 3172
  __cil_tmp90 = __cil_tmp89 + 336;
#line 3172
  __cil_tmp91 = *((dma_addr_t *)__cil_tmp90);
#line 3172
  *((u32 *)__cil_tmp88) = (unsigned int )__cil_tmp91;
#line 3174
  __cil_tmp92 = (u32 *)(& msg);
#line 3174
  ret = adpt_i2o_post_wait(pHba, __cil_tmp92, 32, 360);
  }
#line 3174
  if (ret != 0) {
    {
#line 3175
    __cil_tmp93 = (unsigned long )pHba;
#line 3175
    __cil_tmp94 = __cil_tmp93 + 114;
#line 3175
    __cil_tmp95 = (char (*)[32U])__cil_tmp94;
#line 3175
    __cil_tmp96 = (char *)__cil_tmp95;
#line 3175
    printk("<3>%s: LCT Get failed (status=%#10x.\n", __cil_tmp96, ret);
#line 3177
    printk("<3>Adaptec: Error Reading Hardware.\n");
    }
#line 3178
    return (ret);
  } else {

  }
  {
#line 3181
  __cil_tmp97 = (unsigned long )pHba;
#line 3181
  __cil_tmp98 = __cil_tmp97 + 344;
#line 3181
  __cil_tmp99 = *((uint *)__cil_tmp98);
#line 3181
  __cil_tmp100 = (unsigned long )pHba;
#line 3181
  __cil_tmp101 = __cil_tmp100 + 328;
#line 3181
  __cil_tmp102 = *((i2o_lct **)__cil_tmp101);
#line 3181
  __cil_tmp103 = *((unsigned short *)__cil_tmp102);
#line 3181
  __cil_tmp104 = (int )__cil_tmp103;
#line 3181
  __cil_tmp105 = __cil_tmp104 << 2;
#line 3181
  __cil_tmp106 = (uint )__cil_tmp105;
#line 3181
  if (__cil_tmp106 > __cil_tmp99) {
    {
#line 3182
    __cil_tmp107 = (unsigned long )pHba;
#line 3182
    __cil_tmp108 = __cil_tmp107 + 344;
#line 3182
    __cil_tmp109 = (unsigned long )pHba;
#line 3182
    __cil_tmp110 = __cil_tmp109 + 328;
#line 3182
    __cil_tmp111 = *((i2o_lct **)__cil_tmp110);
#line 3182
    __cil_tmp112 = *((unsigned short *)__cil_tmp111);
#line 3182
    __cil_tmp113 = (int )__cil_tmp112;
#line 3182
    __cil_tmp114 = __cil_tmp113 << 2;
#line 3182
    *((uint *)__cil_tmp108) = (uint )__cil_tmp114;
#line 3183
    __cil_tmp115 = (unsigned long )pHba;
#line 3183
    __cil_tmp116 = __cil_tmp115 + 8;
#line 3183
    __cil_tmp117 = *((struct pci_dev **)__cil_tmp116);
#line 3183
    __cil_tmp118 = (unsigned long )__cil_tmp117;
#line 3183
    __cil_tmp119 = __cil_tmp118 + 144;
#line 3183
    __cil_tmp120 = (struct device *)__cil_tmp119;
#line 3183
    __cil_tmp121 = (unsigned long )pHba;
#line 3183
    __cil_tmp122 = __cil_tmp121 + 344;
#line 3183
    __cil_tmp123 = *((uint *)__cil_tmp122);
#line 3183
    __cil_tmp124 = (size_t )__cil_tmp123;
#line 3183
    __cil_tmp125 = (unsigned long )pHba;
#line 3183
    __cil_tmp126 = __cil_tmp125 + 328;
#line 3183
    __cil_tmp127 = *((i2o_lct **)__cil_tmp126);
#line 3183
    __cil_tmp128 = (void *)__cil_tmp127;
#line 3183
    __cil_tmp129 = (unsigned long )pHba;
#line 3183
    __cil_tmp130 = __cil_tmp129 + 336;
#line 3183
    __cil_tmp131 = *((dma_addr_t *)__cil_tmp130);
#line 3183
    __cil_tmp132 = (struct dma_attrs *)0;
#line 3183
    dma_free_attrs(__cil_tmp120, __cil_tmp124, __cil_tmp128, __cil_tmp131, __cil_tmp132);
#line 3185
    __cil_tmp133 = (unsigned long )pHba;
#line 3185
    __cil_tmp134 = __cil_tmp133 + 328;
#line 3185
    *((i2o_lct **)__cil_tmp134) = (i2o_lct *)0;
    }
  } else {

  }
  }
  {
#line 3187
  __cil_tmp135 = (i2o_lct *)0;
#line 3187
  __cil_tmp136 = (unsigned long )__cil_tmp135;
#line 3187
  __cil_tmp137 = (unsigned long )pHba;
#line 3187
  __cil_tmp138 = __cil_tmp137 + 328;
#line 3187
  __cil_tmp139 = *((i2o_lct **)__cil_tmp138);
#line 3187
  __cil_tmp140 = (unsigned long )__cil_tmp139;
#line 3187
  if (__cil_tmp140 == __cil_tmp136) {
#line 3188
    goto ldv_32870;
  } else {
#line 3190
    goto ldv_32871;
  }
  }
  ldv_32871: 
  {
#line 3193
  __cil_tmp141 = (void *)(& buf);
#line 3193
  tmp___0 = adpt_i2o_query_scalar(pHba, 0, 32768, -1, __cil_tmp141, 64);
  }
#line 3193
  if (tmp___0 >= 0) {
    {
#line 3194
    __cil_tmp142 = (unsigned long )pHba;
#line 3194
    __cil_tmp143 = __cil_tmp142 + 5576;
#line 3194
    __cil_tmp144 = 1 * 4UL;
#line 3194
    __cil_tmp145 = (unsigned long )(buf) + __cil_tmp144;
#line 3194
    *((u32 *)__cil_tmp143) = *((u32 *)__cil_tmp145);
#line 3195
    __cil_tmp146 = (unsigned long )pHba;
#line 3195
    __cil_tmp147 = __cil_tmp146 + 5568;
#line 3195
    __cil_tmp148 = 0 * 4UL;
#line 3195
    __cil_tmp149 = (unsigned long )(buf) + __cil_tmp148;
#line 3195
    __cil_tmp150 = *((u32 *)__cil_tmp149);
#line 3195
    __cil_tmp151 = (ulong )__cil_tmp150;
#line 3195
    __cil_tmp152 = (unsigned long )pHba;
#line 3195
    __cil_tmp153 = __cil_tmp152 + 224;
#line 3195
    __cil_tmp154 = *((ulong *)__cil_tmp153);
#line 3195
    __cil_tmp155 = __cil_tmp154 + __cil_tmp151;
#line 3195
    __cil_tmp156 = (resource_size_t )__cil_tmp155;
#line 3195
    __cil_tmp157 = (unsigned long )pHba;
#line 3195
    __cil_tmp158 = __cil_tmp157 + 5576;
#line 3195
    __cil_tmp159 = *((u32 *)__cil_tmp158);
#line 3195
    __cil_tmp160 = (unsigned long )__cil_tmp159;
#line 3195
    *((void **)__cil_tmp147) = ioremap(__cil_tmp156, __cil_tmp160);
    }
    {
#line 3197
    __cil_tmp161 = (void *)0;
#line 3197
    __cil_tmp162 = (unsigned long )__cil_tmp161;
#line 3197
    __cil_tmp163 = (unsigned long )pHba;
#line 3197
    __cil_tmp164 = __cil_tmp163 + 5568;
#line 3197
    __cil_tmp165 = *((void **)__cil_tmp164);
#line 3197
    __cil_tmp166 = (unsigned long )__cil_tmp165;
#line 3197
    if (__cil_tmp166 != __cil_tmp162) {
#line 3198
      __cil_tmp167 = (unsigned long )pHba;
#line 3198
      __cil_tmp168 = __cil_tmp167 + 5592;
#line 3198
      __cil_tmp169 = (unsigned long )pHba;
#line 3198
      __cil_tmp170 = __cil_tmp169 + 5568;
#line 3198
      __cil_tmp171 = *((void **)__cil_tmp170);
#line 3198
      *((void **)__cil_tmp168) = __cil_tmp171 + 4UL;
#line 3200
      __cil_tmp172 = (unsigned long )pHba;
#line 3200
      __cil_tmp173 = __cil_tmp172 + 5608;
#line 3200
      __cil_tmp174 = (unsigned long )pHba;
#line 3200
      __cil_tmp175 = __cil_tmp174 + 5568;
#line 3200
      __cil_tmp176 = *((void **)__cil_tmp175);
#line 3200
      *((void **)__cil_tmp173) = __cil_tmp176 + 8UL;
#line 3202
      __cil_tmp177 = (unsigned long )pHba;
#line 3202
      __cil_tmp178 = __cil_tmp177 + 5600;
#line 3202
      __cil_tmp179 = (unsigned long )pHba;
#line 3202
      __cil_tmp180 = __cil_tmp179 + 5608;
#line 3202
      __cil_tmp181 = *((void **)__cil_tmp180);
#line 3202
      *((void **)__cil_tmp178) = __cil_tmp181 + 1UL;
#line 3203
      __cil_tmp182 = (unsigned long )pHba;
#line 3203
      __cil_tmp183 = __cil_tmp182 + 5584;
#line 3203
      __cil_tmp184 = (unsigned long )pHba;
#line 3203
      __cil_tmp185 = __cil_tmp184 + 5568;
#line 3203
      *((void **)__cil_tmp183) = *((void **)__cil_tmp185);
#line 3205
      __cil_tmp186 = (unsigned long )pHba;
#line 3205
      __cil_tmp187 = __cil_tmp186 + 5568;
#line 3205
      __cil_tmp188 = 2 * 4UL;
#line 3205
      __cil_tmp189 = (unsigned long )(buf) + __cil_tmp188;
#line 3205
      __cil_tmp190 = *((u32 *)__cil_tmp189);
#line 3205
      __cil_tmp191 = (unsigned long )__cil_tmp190;
#line 3205
      __cil_tmp192 = (unsigned long )pHba;
#line 3205
      __cil_tmp193 = __cil_tmp192 + 5568;
#line 3205
      __cil_tmp194 = *((void **)__cil_tmp193);
#line 3205
      *((void **)__cil_tmp187) = __cil_tmp194 + __cil_tmp191;
#line 3206
      __cil_tmp195 = (unsigned long )pHba;
#line 3206
      __cil_tmp196 = __cil_tmp195 + 5616;
#line 3206
      *((u32 *)__cil_tmp196) = 0U;
    } else {

    }
    }
  } else {

  }
#line 3210
  return (0);
}
}
#line 3213 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_build_sys_table(void) 
{ adpt_hba *pHba ;
  int count ;
  void *tmp ;
  int tmp___0 ;
  u64 addr ;
  s32 tmp___1 ;
  struct i2o_sys_tbl *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct pci_dev *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct device *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  void *__cil_tmp17 ;
  dma_addr_t *__cil_tmp18 ;
  dma_addr_t __cil_tmp19 ;
  struct dma_attrs *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  struct pci_dev *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct device *__cil_tmp30 ;
  size_t __cil_tmp31 ;
  struct dma_attrs *__cil_tmp32 ;
  struct i2o_sys_tbl *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  void *__cil_tmp36 ;
  size_t __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  u8 __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  i2o_status_block *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  unsigned short __cil_tmp60 ;
  unsigned int __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  i2o_status_block *__cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  i2o_status_block *__cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  i2o_status_block *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  i2o_status_block *__cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  unsigned long __cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  int __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  i2o_status_block *__cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  ulong __cil_tmp123 ;
  ulong __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  adpt_hba *__cil_tmp135 ;
  unsigned long __cil_tmp136 ;
  unsigned long __cil_tmp137 ;

  {
#line 3215
  pHba = hba_chain;
#line 3216
  count = 0;
  {
#line 3218
  __cil_tmp7 = (struct i2o_sys_tbl *)0;
#line 3218
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 3218
  __cil_tmp9 = (unsigned long )sys_tbl;
#line 3218
  if (__cil_tmp9 != __cil_tmp8) {
    {
#line 3219
    __cil_tmp10 = (unsigned long )pHba;
#line 3219
    __cil_tmp11 = __cil_tmp10 + 8;
#line 3219
    __cil_tmp12 = *((struct pci_dev **)__cil_tmp11);
#line 3219
    __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 3219
    __cil_tmp14 = __cil_tmp13 + 144;
#line 3219
    __cil_tmp15 = (struct device *)__cil_tmp14;
#line 3219
    __cil_tmp16 = (size_t )sys_tbl_len;
#line 3219
    __cil_tmp17 = (void *)sys_tbl;
#line 3219
    __cil_tmp18 = & sys_tbl_pa;
#line 3219
    __cil_tmp19 = *__cil_tmp18;
#line 3219
    __cil_tmp20 = (struct dma_attrs *)0;
#line 3219
    dma_free_attrs(__cil_tmp15, __cil_tmp16, __cil_tmp17, __cil_tmp19, __cil_tmp20);
    }
  } else {

  }
  }
  {
#line 3222
  __cil_tmp21 = (unsigned long )hba_count;
#line 3222
  __cil_tmp22 = (unsigned int )__cil_tmp21;
#line 3222
  __cil_tmp23 = __cil_tmp22 * 32U;
#line 3222
  __cil_tmp24 = __cil_tmp23 + 16U;
#line 3222
  sys_tbl_len = (int )__cil_tmp24;
#line 3225
  __cil_tmp25 = (unsigned long )pHba;
#line 3225
  __cil_tmp26 = __cil_tmp25 + 8;
#line 3225
  __cil_tmp27 = *((struct pci_dev **)__cil_tmp26);
#line 3225
  __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 3225
  __cil_tmp29 = __cil_tmp28 + 144;
#line 3225
  __cil_tmp30 = (struct device *)__cil_tmp29;
#line 3225
  __cil_tmp31 = (size_t )sys_tbl_len;
#line 3225
  __cil_tmp32 = (struct dma_attrs *)0;
#line 3225
  tmp = dma_alloc_attrs(__cil_tmp30, __cil_tmp31, & sys_tbl_pa, 208U, __cil_tmp32);
#line 3225
  sys_tbl = (struct i2o_sys_tbl *)tmp;
  }
  {
#line 3227
  __cil_tmp33 = (struct i2o_sys_tbl *)0;
#line 3227
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 3227
  __cil_tmp35 = (unsigned long )sys_tbl;
#line 3227
  if (__cil_tmp35 == __cil_tmp34) {
    {
#line 3228
    printk("<4>SysTab Set failed. Out of memory.\n");
    }
#line 3229
    return (-12);
  } else {

  }
  }
  {
#line 3231
  __cil_tmp36 = (void *)sys_tbl;
#line 3231
  __cil_tmp37 = (size_t )sys_tbl_len;
#line 3231
  memset(__cil_tmp36, 0, __cil_tmp37);
#line 3233
  *((u8 *)sys_tbl) = (u8 )hba_count;
#line 3234
  __cil_tmp38 = (unsigned long )sys_tbl;
#line 3234
  __cil_tmp39 = __cil_tmp38 + 1;
#line 3234
  *((u8 *)__cil_tmp39) = (u8 )1U;
#line 3235
  tmp___0 = sys_tbl_ind;
#line 3235
  sys_tbl_ind = sys_tbl_ind + 1;
#line 3235
  __cil_tmp40 = (unsigned long )sys_tbl;
#line 3235
  __cil_tmp41 = __cil_tmp40 + 4;
#line 3235
  *((u32 *)__cil_tmp41) = (u32 )tmp___0;
#line 3237
  pHba = hba_chain;
  }
#line 3237
  goto ldv_32880;
  ldv_32879: 
  {
#line 3240
  tmp___1 = adpt_i2o_status_get(pHba);
  }
#line 3240
  if (tmp___1 != 0) {
#line 3241
    __cil_tmp42 = *((u8 *)sys_tbl);
#line 3241
    __cil_tmp43 = (int )__cil_tmp42;
#line 3241
    __cil_tmp44 = __cil_tmp43 - 1;
#line 3241
    *((u8 *)sys_tbl) = (u8 )__cil_tmp44;
#line 3242
    goto ldv_32878;
  } else {

  }
  {
#line 3245
  __cil_tmp45 = count * 32UL;
#line 3245
  __cil_tmp46 = 16 + __cil_tmp45;
#line 3245
  __cil_tmp47 = (unsigned long )sys_tbl;
#line 3245
  __cil_tmp48 = __cil_tmp47 + __cil_tmp46;
#line 3245
  __cil_tmp49 = (unsigned long )pHba;
#line 3245
  __cil_tmp50 = __cil_tmp49 + 296;
#line 3245
  __cil_tmp51 = *((i2o_status_block **)__cil_tmp50);
#line 3245
  *((u16 *)__cil_tmp48) = *((__u16 *)__cil_tmp51);
#line 3246
  __cil_tmp52 = count * 32UL;
#line 3246
  __cil_tmp53 = __cil_tmp52 + 4;
#line 3246
  __cil_tmp54 = 16 + __cil_tmp53;
#line 3246
  __cil_tmp55 = (unsigned long )sys_tbl;
#line 3246
  __cil_tmp56 = __cil_tmp55 + __cil_tmp54;
#line 3246
  __cil_tmp57 = (unsigned long )pHba;
#line 3246
  __cil_tmp58 = __cil_tmp57 + 104;
#line 3246
  __cil_tmp59 = *((int *)__cil_tmp58);
#line 3246
  __cil_tmp60 = (unsigned short )__cil_tmp59;
#line 3246
  __cil_tmp61 = (unsigned int )__cil_tmp60;
#line 3246
  __cil_tmp62 = __cil_tmp61 + 2U;
#line 3246
  *((unsigned short *)__cil_tmp56) = (unsigned short )__cil_tmp62;
#line 3247
  __cil_tmp63 = count * 32UL;
#line 3247
  __cil_tmp64 = __cil_tmp63 + 8;
#line 3247
  __cil_tmp65 = 16 + __cil_tmp64;
#line 3247
  __cil_tmp66 = (unsigned long )sys_tbl;
#line 3247
  __cil_tmp67 = __cil_tmp66 + __cil_tmp65;
#line 3247
  *((unsigned short *)__cil_tmp67) = (unsigned short)0;
#line 3248
  __cil_tmp68 = count * 32UL;
#line 3248
  __cil_tmp69 = 16 + __cil_tmp68;
#line 3248
  __cil_tmp70 = (unsigned long )sys_tbl;
#line 3248
  __cil_tmp71 = __cil_tmp70 + __cil_tmp69;
#line 3248
  __cil_tmp72 = (unsigned long )pHba;
#line 3248
  __cil_tmp73 = __cil_tmp72 + 296;
#line 3248
  __cil_tmp74 = *((i2o_status_block **)__cil_tmp73);
#line 3248
  ((struct i2o_sys_tbl_entry *)__cil_tmp71)->i2o_version = __cil_tmp74->i2o_version;
#line 3249
  __cil_tmp75 = count * 32UL;
#line 3249
  __cil_tmp76 = __cil_tmp75 + 10;
#line 3249
  __cil_tmp77 = 16 + __cil_tmp76;
#line 3249
  __cil_tmp78 = (unsigned long )sys_tbl;
#line 3249
  __cil_tmp79 = __cil_tmp78 + __cil_tmp77;
#line 3249
  __cil_tmp80 = (unsigned long )pHba;
#line 3249
  __cil_tmp81 = __cil_tmp80 + 296;
#line 3249
  __cil_tmp82 = *((i2o_status_block **)__cil_tmp81);
#line 3249
  __cil_tmp83 = (unsigned long )__cil_tmp82;
#line 3249
  __cil_tmp84 = __cil_tmp83 + 10;
#line 3249
  *((u8 *)__cil_tmp79) = *((__u8 *)__cil_tmp84);
#line 3250
  __cil_tmp85 = count * 32UL;
#line 3250
  __cil_tmp86 = __cil_tmp85 + 11;
#line 3250
  __cil_tmp87 = 16 + __cil_tmp86;
#line 3250
  __cil_tmp88 = (unsigned long )sys_tbl;
#line 3250
  __cil_tmp89 = __cil_tmp88 + __cil_tmp87;
#line 3250
  __cil_tmp90 = (unsigned long )pHba;
#line 3250
  __cil_tmp91 = __cil_tmp90 + 296;
#line 3250
  __cil_tmp92 = *((i2o_status_block **)__cil_tmp91);
#line 3250
  __cil_tmp93 = (unsigned long )__cil_tmp92;
#line 3250
  __cil_tmp94 = __cil_tmp93 + 11;
#line 3250
  *((u8 *)__cil_tmp89) = *((__u8 *)__cil_tmp94);
#line 3251
  __cil_tmp95 = count * 32UL;
#line 3251
  __cil_tmp96 = __cil_tmp95 + 12;
#line 3251
  __cil_tmp97 = 16 + __cil_tmp96;
#line 3251
  __cil_tmp98 = (unsigned long )sys_tbl;
#line 3251
  __cil_tmp99 = __cil_tmp98 + __cil_tmp97;
#line 3251
  __cil_tmp100 = (unsigned long )pHba;
#line 3251
  __cil_tmp101 = __cil_tmp100 + 296;
#line 3251
  __cil_tmp102 = *((i2o_status_block **)__cil_tmp101);
#line 3251
  __cil_tmp103 = (unsigned long )__cil_tmp102;
#line 3251
  __cil_tmp104 = __cil_tmp103 + 12;
#line 3251
  *((u16 *)__cil_tmp99) = *((__u16 *)__cil_tmp104);
#line 3252
  __cil_tmp105 = count * 32UL;
#line 3252
  __cil_tmp106 = __cil_tmp105 + 16;
#line 3252
  __cil_tmp107 = 16 + __cil_tmp106;
#line 3252
  __cil_tmp108 = (unsigned long )sys_tbl;
#line 3252
  __cil_tmp109 = __cil_tmp108 + __cil_tmp107;
#line 3252
  __cil_tmp110 = sys_tbl_ind + -1;
#line 3252
  *((u32 *)__cil_tmp109) = (u32 )__cil_tmp110;
#line 3253
  __cil_tmp111 = count * 32UL;
#line 3253
  __cil_tmp112 = __cil_tmp111 + 20;
#line 3253
  __cil_tmp113 = 16 + __cil_tmp112;
#line 3253
  __cil_tmp114 = (unsigned long )sys_tbl;
#line 3253
  __cil_tmp115 = __cil_tmp114 + __cil_tmp113;
#line 3253
  __cil_tmp116 = (unsigned long )pHba;
#line 3253
  __cil_tmp117 = __cil_tmp116 + 296;
#line 3253
  __cil_tmp118 = *((i2o_status_block **)__cil_tmp117);
#line 3253
  __cil_tmp119 = (unsigned long )__cil_tmp118;
#line 3253
  __cil_tmp120 = __cil_tmp119 + 56;
#line 3253
  *((u32 *)__cil_tmp115) = *((__u32 *)__cil_tmp120);
#line 3254
  __cil_tmp121 = (unsigned long )pHba;
#line 3254
  __cil_tmp122 = __cil_tmp121 + 224;
#line 3254
  __cil_tmp123 = *((ulong *)__cil_tmp122);
#line 3254
  __cil_tmp124 = __cil_tmp123 + 64UL;
#line 3254
  addr = (u64 )__cil_tmp124;
#line 3255
  __cil_tmp125 = count * 32UL;
#line 3255
  __cil_tmp126 = __cil_tmp125 + 24;
#line 3255
  __cil_tmp127 = 16 + __cil_tmp126;
#line 3255
  __cil_tmp128 = (unsigned long )sys_tbl;
#line 3255
  __cil_tmp129 = __cil_tmp128 + __cil_tmp127;
#line 3255
  *((u32 *)__cil_tmp129) = dma_low(addr);
#line 3256
  __cil_tmp130 = count * 32UL;
#line 3256
  __cil_tmp131 = __cil_tmp130 + 28;
#line 3256
  __cil_tmp132 = 16 + __cil_tmp131;
#line 3256
  __cil_tmp133 = (unsigned long )sys_tbl;
#line 3256
  __cil_tmp134 = __cil_tmp133 + __cil_tmp132;
#line 3256
  *((u32 *)__cil_tmp134) = dma_high(addr);
#line 3258
  count = count + 1;
  }
  ldv_32878: 
#line 3237
  pHba = *((struct _adpt_hba **)pHba);
  ldv_32880: ;
  {
#line 3237
  __cil_tmp135 = (adpt_hba *)0;
#line 3237
  __cil_tmp136 = (unsigned long )__cil_tmp135;
#line 3237
  __cil_tmp137 = (unsigned long )pHba;
#line 3237
  if (__cil_tmp137 != __cil_tmp136) {
#line 3238
    goto ldv_32879;
  } else {
#line 3240
    goto ldv_32881;
  }
  }
  ldv_32881: ;
#line 3272
  return (0);
}
}
#line 3280 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_i2o_report_hba_unit(adpt_hba *pHba , struct i2o_device *d ) 
{ char buf[64U] ;
  int unit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned short __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  char *__cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 3283
  __cil_tmp8 = 24 + 2;
#line 3283
  __cil_tmp9 = (unsigned long )d;
#line 3283
  __cil_tmp10 = __cil_tmp9 + __cil_tmp8;
#line 3283
  __cil_tmp11 = *((unsigned short *)__cil_tmp10);
#line 3283
  unit = (int )__cil_tmp11;
#line 3285
  printk("<6>TID %3.3d ", unit);
#line 3287
  __cil_tmp12 = (void *)(& buf);
#line 3287
  tmp = adpt_i2o_query_scalar(pHba, unit, 61696, 3, __cil_tmp12, 16);
  }
#line 3287
  if (tmp >= 0) {
    {
#line 3289
    __cil_tmp13 = 16 * 1UL;
#line 3289
    __cil_tmp14 = (unsigned long )(buf) + __cil_tmp13;
#line 3289
    *((char *)__cil_tmp14) = (char)0;
#line 3290
    __cil_tmp15 = (char *)(& buf);
#line 3290
    printk(" Vendor: %-12.12s", __cil_tmp15);
    }
  } else {

  }
  {
#line 3292
  __cil_tmp16 = (void *)(& buf);
#line 3292
  tmp___0 = adpt_i2o_query_scalar(pHba, unit, 61696, 4, __cil_tmp16, 16);
  }
#line 3292
  if (tmp___0 >= 0) {
    {
#line 3294
    __cil_tmp17 = 16 * 1UL;
#line 3294
    __cil_tmp18 = (unsigned long )(buf) + __cil_tmp17;
#line 3294
    *((char *)__cil_tmp18) = (char)0;
#line 3295
    __cil_tmp19 = (char *)(& buf);
#line 3295
    printk(" Device: %-12.12s", __cil_tmp19);
    }
  } else {

  }
  {
#line 3297
  __cil_tmp20 = (void *)(& buf);
#line 3297
  tmp___1 = adpt_i2o_query_scalar(pHba, unit, 61696, 6, __cil_tmp20, 8);
  }
#line 3297
  if (tmp___1 >= 0) {
    {
#line 3299
    __cil_tmp21 = 8 * 1UL;
#line 3299
    __cil_tmp22 = (unsigned long )(buf) + __cil_tmp21;
#line 3299
    *((char *)__cil_tmp22) = (char)0;
#line 3300
    __cil_tmp23 = (char *)(& buf);
#line 3300
    printk(" Rev: %-12.12s\n", __cil_tmp23);
    }
  } else {

  }
#line 3302
  return;
}
}
#line 3385 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_hrt_get(adpt_hba *pHba ) 
{ u32 msg[6U] ;
  int ret ;
  int size ;
  void *tmp ;
  int newsize ;
  i2o_hrt *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  i2o_hrt *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct pci_dev *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct device *__cil_tmp18 ;
  size_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  dma_addr_t *__cil_tmp22 ;
  struct dma_attrs *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  i2o_hrt *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  i2o_hrt *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  char (*__cil_tmp34)[32U] ;
  char *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  dma_addr_t __cil_tmp51 ;
  u32 *__cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  char (*__cil_tmp55)[32U] ;
  char *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  i2o_hrt *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  __u8 __cil_tmp62 ;
  int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  i2o_hrt *__cil_tmp66 ;
  __u16 __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  i2o_hrt *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  __u8 __cil_tmp76 ;
  int __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  i2o_hrt *__cil_tmp80 ;
  __u16 __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct pci_dev *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  struct device *__cil_tmp89 ;
  size_t __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  i2o_hrt *__cil_tmp93 ;
  void *__cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  dma_addr_t __cil_tmp97 ;
  struct dma_attrs *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  i2o_hrt *__cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  unsigned long __cil_tmp104 ;
  i2o_hrt *__cil_tmp105 ;
  unsigned long __cil_tmp106 ;

  {
#line 3388
  size = 24;
  ldv_32895: ;
  {
#line 3391
  __cil_tmp7 = (i2o_hrt *)0;
#line 3391
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 3391
  __cil_tmp9 = (unsigned long )pHba;
#line 3391
  __cil_tmp10 = __cil_tmp9 + 312;
#line 3391
  __cil_tmp11 = *((i2o_hrt **)__cil_tmp10);
#line 3391
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 3391
  if (__cil_tmp12 == __cil_tmp8) {
    {
#line 3392
    __cil_tmp13 = (unsigned long )pHba;
#line 3392
    __cil_tmp14 = __cil_tmp13 + 8;
#line 3392
    __cil_tmp15 = *((struct pci_dev **)__cil_tmp14);
#line 3392
    __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 3392
    __cil_tmp17 = __cil_tmp16 + 144;
#line 3392
    __cil_tmp18 = (struct device *)__cil_tmp17;
#line 3392
    __cil_tmp19 = (size_t )size;
#line 3392
    __cil_tmp20 = (unsigned long )pHba;
#line 3392
    __cil_tmp21 = __cil_tmp20 + 320;
#line 3392
    __cil_tmp22 = (dma_addr_t *)__cil_tmp21;
#line 3392
    __cil_tmp23 = (struct dma_attrs *)0;
#line 3392
    tmp = dma_alloc_attrs(__cil_tmp18, __cil_tmp19, __cil_tmp22, 208U, __cil_tmp23);
#line 3392
    __cil_tmp24 = (unsigned long )pHba;
#line 3392
    __cil_tmp25 = __cil_tmp24 + 312;
#line 3392
    *((i2o_hrt **)__cil_tmp25) = (i2o_hrt *)tmp;
    }
    {
#line 3394
    __cil_tmp26 = (i2o_hrt *)0;
#line 3394
    __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 3394
    __cil_tmp28 = (unsigned long )pHba;
#line 3394
    __cil_tmp29 = __cil_tmp28 + 312;
#line 3394
    __cil_tmp30 = *((i2o_hrt **)__cil_tmp29);
#line 3394
    __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 3394
    if (__cil_tmp31 == __cil_tmp27) {
      {
#line 3395
      __cil_tmp32 = (unsigned long )pHba;
#line 3395
      __cil_tmp33 = __cil_tmp32 + 114;
#line 3395
      __cil_tmp34 = (char (*)[32U])__cil_tmp33;
#line 3395
      __cil_tmp35 = (char *)__cil_tmp34;
#line 3395
      printk("<2>%s: Hrt Get failed; Out of memory.\n", __cil_tmp35);
      }
#line 3396
      return (-12);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 3400
  __cil_tmp36 = 0 * 4UL;
#line 3400
  __cil_tmp37 = (unsigned long )(msg) + __cil_tmp36;
#line 3400
  *((u32 *)__cil_tmp37) = 393281U;
#line 3401
  __cil_tmp38 = 1 * 4UL;
#line 3401
  __cil_tmp39 = (unsigned long )(msg) + __cil_tmp38;
#line 3401
  *((u32 *)__cil_tmp39) = 2818576384U;
#line 3402
  __cil_tmp40 = 2 * 4UL;
#line 3402
  __cil_tmp41 = (unsigned long )(msg) + __cil_tmp40;
#line 3402
  *((u32 *)__cil_tmp41) = 0U;
#line 3403
  __cil_tmp42 = 3 * 4UL;
#line 3403
  __cil_tmp43 = (unsigned long )(msg) + __cil_tmp42;
#line 3403
  *((u32 *)__cil_tmp43) = 0U;
#line 3404
  __cil_tmp44 = 4 * 4UL;
#line 3404
  __cil_tmp45 = (unsigned long )(msg) + __cil_tmp44;
#line 3404
  __cil_tmp46 = (unsigned int )size;
#line 3404
  *((u32 *)__cil_tmp45) = __cil_tmp46 | 3489660928U;
#line 3405
  __cil_tmp47 = 5 * 4UL;
#line 3405
  __cil_tmp48 = (unsigned long )(msg) + __cil_tmp47;
#line 3405
  __cil_tmp49 = (unsigned long )pHba;
#line 3405
  __cil_tmp50 = __cil_tmp49 + 320;
#line 3405
  __cil_tmp51 = *((dma_addr_t *)__cil_tmp50);
#line 3405
  *((u32 *)__cil_tmp48) = (unsigned int )__cil_tmp51;
#line 3407
  __cil_tmp52 = (u32 *)(& msg);
#line 3407
  ret = adpt_i2o_post_wait(pHba, __cil_tmp52, 24, 20);
  }
#line 3407
  if (ret != 0) {
    {
#line 3408
    __cil_tmp53 = (unsigned long )pHba;
#line 3408
    __cil_tmp54 = __cil_tmp53 + 114;
#line 3408
    __cil_tmp55 = (char (*)[32U])__cil_tmp54;
#line 3408
    __cil_tmp56 = (char *)__cil_tmp55;
#line 3408
    printk("<3>%s: Unable to get HRT (status=%#10x)\n", __cil_tmp56, ret);
    }
#line 3409
    return (ret);
  } else {

  }
  {
#line 3412
  __cil_tmp57 = (unsigned long )pHba;
#line 3412
  __cil_tmp58 = __cil_tmp57 + 312;
#line 3412
  __cil_tmp59 = *((i2o_hrt **)__cil_tmp58);
#line 3412
  __cil_tmp60 = (unsigned long )__cil_tmp59;
#line 3412
  __cil_tmp61 = __cil_tmp60 + 2;
#line 3412
  __cil_tmp62 = *((__u8 *)__cil_tmp61);
#line 3412
  __cil_tmp63 = (int )__cil_tmp62;
#line 3412
  __cil_tmp64 = (unsigned long )pHba;
#line 3412
  __cil_tmp65 = __cil_tmp64 + 312;
#line 3412
  __cil_tmp66 = *((i2o_hrt **)__cil_tmp65);
#line 3412
  __cil_tmp67 = *((__u16 *)__cil_tmp66);
#line 3412
  __cil_tmp68 = (int )__cil_tmp67;
#line 3412
  __cil_tmp69 = __cil_tmp68 * __cil_tmp63;
#line 3412
  __cil_tmp70 = __cil_tmp69 << 2;
#line 3412
  if (__cil_tmp70 > size) {
    {
#line 3413
    __cil_tmp71 = (unsigned long )pHba;
#line 3413
    __cil_tmp72 = __cil_tmp71 + 312;
#line 3413
    __cil_tmp73 = *((i2o_hrt **)__cil_tmp72);
#line 3413
    __cil_tmp74 = (unsigned long )__cil_tmp73;
#line 3413
    __cil_tmp75 = __cil_tmp74 + 2;
#line 3413
    __cil_tmp76 = *((__u8 *)__cil_tmp75);
#line 3413
    __cil_tmp77 = (int )__cil_tmp76;
#line 3413
    __cil_tmp78 = (unsigned long )pHba;
#line 3413
    __cil_tmp79 = __cil_tmp78 + 312;
#line 3413
    __cil_tmp80 = *((i2o_hrt **)__cil_tmp79);
#line 3413
    __cil_tmp81 = *((__u16 *)__cil_tmp80);
#line 3413
    __cil_tmp82 = (int )__cil_tmp81;
#line 3413
    __cil_tmp83 = __cil_tmp82 * __cil_tmp77;
#line 3413
    newsize = __cil_tmp83 << 2;
#line 3414
    __cil_tmp84 = (unsigned long )pHba;
#line 3414
    __cil_tmp85 = __cil_tmp84 + 8;
#line 3414
    __cil_tmp86 = *((struct pci_dev **)__cil_tmp85);
#line 3414
    __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 3414
    __cil_tmp88 = __cil_tmp87 + 144;
#line 3414
    __cil_tmp89 = (struct device *)__cil_tmp88;
#line 3414
    __cil_tmp90 = (size_t )size;
#line 3414
    __cil_tmp91 = (unsigned long )pHba;
#line 3414
    __cil_tmp92 = __cil_tmp91 + 312;
#line 3414
    __cil_tmp93 = *((i2o_hrt **)__cil_tmp92);
#line 3414
    __cil_tmp94 = (void *)__cil_tmp93;
#line 3414
    __cil_tmp95 = (unsigned long )pHba;
#line 3414
    __cil_tmp96 = __cil_tmp95 + 320;
#line 3414
    __cil_tmp97 = *((dma_addr_t *)__cil_tmp96);
#line 3414
    __cil_tmp98 = (struct dma_attrs *)0;
#line 3414
    dma_free_attrs(__cil_tmp89, __cil_tmp90, __cil_tmp94, __cil_tmp97, __cil_tmp98);
#line 3416
    size = newsize;
#line 3417
    __cil_tmp99 = (unsigned long )pHba;
#line 3417
    __cil_tmp100 = __cil_tmp99 + 312;
#line 3417
    *((i2o_hrt **)__cil_tmp100) = (i2o_hrt *)0;
    }
  } else {

  }
  }
  {
#line 3419
  __cil_tmp101 = (i2o_hrt *)0;
#line 3419
  __cil_tmp102 = (unsigned long )__cil_tmp101;
#line 3419
  __cil_tmp103 = (unsigned long )pHba;
#line 3419
  __cil_tmp104 = __cil_tmp103 + 312;
#line 3419
  __cil_tmp105 = *((i2o_hrt **)__cil_tmp104);
#line 3419
  __cil_tmp106 = (unsigned long )__cil_tmp105;
#line 3419
  if (__cil_tmp106 == __cil_tmp102) {
#line 3420
    goto ldv_32895;
  } else {
#line 3422
    goto ldv_32896;
  }
  }
  ldv_32896: ;
#line 3420
  return (0);
}
}
#line 3426 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_query_scalar(adpt_hba *pHba , int tid , int group , int field ,
                                 void *buf , int buflen ) 
{ u16 opblk[6U] ;
  u8 *opblk_va ;
  dma_addr_t opblk_pa ;
  u8 *resblk_va ;
  dma_addr_t resblk_pa ;
  int size ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct pci_dev *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct device *__cil_tmp36 ;
  int __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  struct dma_attrs *__cil_tmp39 ;
  u8 *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  char (*__cil_tmp45)[32U] ;
  char *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  struct pci_dev *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  struct device *__cil_tmp52 ;
  struct dma_attrs *__cil_tmp53 ;
  u8 *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  struct pci_dev *__cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  struct device *__cil_tmp62 ;
  int __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  void *__cil_tmp65 ;
  dma_addr_t *__cil_tmp66 ;
  dma_addr_t __cil_tmp67 ;
  struct dma_attrs *__cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  char (*__cil_tmp71)[32U] ;
  char *__cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  void *__cil_tmp75 ;
  void    *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void    *__cil_tmp78 ;
  void *__cil_tmp79 ;
  dma_addr_t *__cil_tmp80 ;
  dma_addr_t __cil_tmp81 ;
  void *__cil_tmp82 ;
  dma_addr_t *__cil_tmp83 ;
  dma_addr_t __cil_tmp84 ;
  int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  struct pci_dev *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  struct device *__cil_tmp91 ;
  void *__cil_tmp92 ;
  dma_addr_t *__cil_tmp93 ;
  dma_addr_t __cil_tmp94 ;
  struct dma_attrs *__cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  struct pci_dev *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  struct device *__cil_tmp101 ;
  int __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  void *__cil_tmp104 ;
  dma_addr_t *__cil_tmp105 ;
  dma_addr_t __cil_tmp106 ;
  struct dma_attrs *__cil_tmp107 ;
  unsigned long __cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  char (*__cil_tmp110)[32U] ;
  char *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  struct pci_dev *__cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  struct device *__cil_tmp117 ;
  int __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  void *__cil_tmp120 ;
  dma_addr_t *__cil_tmp121 ;
  dma_addr_t __cil_tmp122 ;
  struct dma_attrs *__cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  char (*__cil_tmp126)[32U] ;
  char *__cil_tmp127 ;
  void    *__cil_tmp128 ;
  void    *__cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  struct pci_dev *__cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  struct device *__cil_tmp135 ;
  int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  void *__cil_tmp138 ;
  dma_addr_t *__cil_tmp139 ;
  dma_addr_t __cil_tmp140 ;
  struct dma_attrs *__cil_tmp141 ;

  {
  {
#line 3429
  __cil_tmp19 = 0 * 2UL;
#line 3429
  __cil_tmp20 = (unsigned long )(opblk) + __cil_tmp19;
#line 3429
  *((u16 *)__cil_tmp20) = (u16 )1U;
#line 3429
  __cil_tmp21 = 1 * 2UL;
#line 3429
  __cil_tmp22 = (unsigned long )(opblk) + __cil_tmp21;
#line 3429
  *((u16 *)__cil_tmp22) = (u16 )0U;
#line 3429
  __cil_tmp23 = 2 * 2UL;
#line 3429
  __cil_tmp24 = (unsigned long )(opblk) + __cil_tmp23;
#line 3429
  *((u16 *)__cil_tmp24) = (u16 )1U;
#line 3429
  __cil_tmp25 = 3 * 2UL;
#line 3429
  __cil_tmp26 = (unsigned long )(opblk) + __cil_tmp25;
#line 3429
  *((u16 *)__cil_tmp26) = (unsigned short )group;
#line 3429
  __cil_tmp27 = 4 * 2UL;
#line 3429
  __cil_tmp28 = (unsigned long )(opblk) + __cil_tmp27;
#line 3429
  *((u16 *)__cil_tmp28) = (u16 )1U;
#line 3429
  __cil_tmp29 = 5 * 2UL;
#line 3429
  __cil_tmp30 = (unsigned long )(opblk) + __cil_tmp29;
#line 3429
  *((u16 *)__cil_tmp30) = (unsigned short )field;
#line 3438
  __cil_tmp31 = (unsigned long )pHba;
#line 3438
  __cil_tmp32 = __cil_tmp31 + 8;
#line 3438
  __cil_tmp33 = *((struct pci_dev **)__cil_tmp32);
#line 3438
  __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 3438
  __cil_tmp35 = __cil_tmp34 + 144;
#line 3438
  __cil_tmp36 = (struct device *)__cil_tmp35;
#line 3438
  __cil_tmp37 = buflen + 8;
#line 3438
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 3438
  __cil_tmp39 = (struct dma_attrs *)0;
#line 3438
  tmp = dma_alloc_attrs(__cil_tmp36, __cil_tmp38, & resblk_pa, 208U, __cil_tmp39);
#line 3438
  resblk_va = (u8 *)tmp;
  }
  {
#line 3440
  __cil_tmp40 = (u8 *)0;
#line 3440
  __cil_tmp41 = (unsigned long )__cil_tmp40;
#line 3440
  __cil_tmp42 = (unsigned long )resblk_va;
#line 3440
  if (__cil_tmp42 == __cil_tmp41) {
    {
#line 3441
    __cil_tmp43 = (unsigned long )pHba;
#line 3441
    __cil_tmp44 = __cil_tmp43 + 114;
#line 3441
    __cil_tmp45 = (char (*)[32U])__cil_tmp44;
#line 3441
    __cil_tmp46 = (char *)__cil_tmp45;
#line 3441
    printk("<2>%s: query scalar failed; Out of memory.\n", __cil_tmp46);
    }
#line 3442
    return (-12);
  } else {

  }
  }
  {
#line 3445
  __cil_tmp47 = (unsigned long )pHba;
#line 3445
  __cil_tmp48 = __cil_tmp47 + 8;
#line 3445
  __cil_tmp49 = *((struct pci_dev **)__cil_tmp48);
#line 3445
  __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 3445
  __cil_tmp51 = __cil_tmp50 + 144;
#line 3445
  __cil_tmp52 = (struct device *)__cil_tmp51;
#line 3445
  __cil_tmp53 = (struct dma_attrs *)0;
#line 3445
  tmp___0 = dma_alloc_attrs(__cil_tmp52, 12UL, & opblk_pa, 208U, __cil_tmp53);
#line 3445
  opblk_va = (u8 *)tmp___0;
  }
  {
#line 3447
  __cil_tmp54 = (u8 *)0;
#line 3447
  __cil_tmp55 = (unsigned long )__cil_tmp54;
#line 3447
  __cil_tmp56 = (unsigned long )opblk_va;
#line 3447
  if (__cil_tmp56 == __cil_tmp55) {
    {
#line 3448
    __cil_tmp57 = (unsigned long )pHba;
#line 3448
    __cil_tmp58 = __cil_tmp57 + 8;
#line 3448
    __cil_tmp59 = *((struct pci_dev **)__cil_tmp58);
#line 3448
    __cil_tmp60 = (unsigned long )__cil_tmp59;
#line 3448
    __cil_tmp61 = __cil_tmp60 + 144;
#line 3448
    __cil_tmp62 = (struct device *)__cil_tmp61;
#line 3448
    __cil_tmp63 = buflen + 8;
#line 3448
    __cil_tmp64 = (unsigned long )__cil_tmp63;
#line 3448
    __cil_tmp65 = (void *)resblk_va;
#line 3448
    __cil_tmp66 = & resblk_pa;
#line 3448
    __cil_tmp67 = *__cil_tmp66;
#line 3448
    __cil_tmp68 = (struct dma_attrs *)0;
#line 3448
    dma_free_attrs(__cil_tmp62, __cil_tmp64, __cil_tmp65, __cil_tmp67, __cil_tmp68);
#line 3450
    __cil_tmp69 = (unsigned long )pHba;
#line 3450
    __cil_tmp70 = __cil_tmp69 + 114;
#line 3450
    __cil_tmp71 = (char (*)[32U])__cil_tmp70;
#line 3450
    __cil_tmp72 = (char *)__cil_tmp71;
#line 3450
    printk("<2>%s: query operatio failed; Out of memory.\n", __cil_tmp72);
    }
#line 3452
    return (-12);
  } else {

  }
  }
#line 3454
  if (field == -1) {
#line 3455
    __cil_tmp73 = 4 * 2UL;
#line 3455
    __cil_tmp74 = (unsigned long )(opblk) + __cil_tmp73;
#line 3455
    *((u16 *)__cil_tmp74) = (u16 )65535U;
  } else {

  }
#line 3457
  __len = 12UL;
#line 3457
  if (__len > 63UL) {
    {
#line 3457
    __cil_tmp75 = (void *)opblk_va;
#line 3457
    __cil_tmp76 = (void    *)(& opblk);
#line 3457
    __ret = __memcpy(__cil_tmp75, __cil_tmp76, __len);
    }
  } else {
    {
#line 3457
    __cil_tmp77 = (void *)opblk_va;
#line 3457
    __cil_tmp78 = (void    *)(& opblk);
#line 3457
    __ret = __builtin_memcpy(__cil_tmp77, __cil_tmp78, __len);
    }
  }
  {
#line 3458
  __cil_tmp79 = (void *)opblk_va;
#line 3458
  __cil_tmp80 = & opblk_pa;
#line 3458
  __cil_tmp81 = *__cil_tmp80;
#line 3458
  __cil_tmp82 = (void *)resblk_va;
#line 3458
  __cil_tmp83 = & resblk_pa;
#line 3458
  __cil_tmp84 = *__cil_tmp83;
#line 3458
  __cil_tmp85 = buflen + 8;
#line 3458
  size = adpt_i2o_issue_params(6, pHba, tid, __cil_tmp79, __cil_tmp81, 12, __cil_tmp82,
                               __cil_tmp84, __cil_tmp85);
#line 3461
  __cil_tmp86 = (unsigned long )pHba;
#line 3461
  __cil_tmp87 = __cil_tmp86 + 8;
#line 3461
  __cil_tmp88 = *((struct pci_dev **)__cil_tmp87);
#line 3461
  __cil_tmp89 = (unsigned long )__cil_tmp88;
#line 3461
  __cil_tmp90 = __cil_tmp89 + 144;
#line 3461
  __cil_tmp91 = (struct device *)__cil_tmp90;
#line 3461
  __cil_tmp92 = (void *)opblk_va;
#line 3461
  __cil_tmp93 = & opblk_pa;
#line 3461
  __cil_tmp94 = *__cil_tmp93;
#line 3461
  __cil_tmp95 = (struct dma_attrs *)0;
#line 3461
  dma_free_attrs(__cil_tmp91, 12UL, __cil_tmp92, __cil_tmp94, __cil_tmp95);
  }
#line 3462
  if (size == -62) {
    {
#line 3463
    __cil_tmp96 = (unsigned long )pHba;
#line 3463
    __cil_tmp97 = __cil_tmp96 + 8;
#line 3463
    __cil_tmp98 = *((struct pci_dev **)__cil_tmp97);
#line 3463
    __cil_tmp99 = (unsigned long )__cil_tmp98;
#line 3463
    __cil_tmp100 = __cil_tmp99 + 144;
#line 3463
    __cil_tmp101 = (struct device *)__cil_tmp100;
#line 3463
    __cil_tmp102 = buflen + 8;
#line 3463
    __cil_tmp103 = (unsigned long )__cil_tmp102;
#line 3463
    __cil_tmp104 = (void *)resblk_va;
#line 3463
    __cil_tmp105 = & resblk_pa;
#line 3463
    __cil_tmp106 = *__cil_tmp105;
#line 3463
    __cil_tmp107 = (struct dma_attrs *)0;
#line 3463
    dma_free_attrs(__cil_tmp101, __cil_tmp103, __cil_tmp104, __cil_tmp106, __cil_tmp107);
#line 3465
    __cil_tmp108 = (unsigned long )pHba;
#line 3465
    __cil_tmp109 = __cil_tmp108 + 114;
#line 3465
    __cil_tmp110 = (char (*)[32U])__cil_tmp109;
#line 3465
    __cil_tmp111 = (char *)__cil_tmp110;
#line 3465
    printk("<4>%s: issue params failed; Timed out.\n", __cil_tmp111);
    }
#line 3466
    return (-62);
  } else
#line 3467
  if (size == -4) {
    {
#line 3468
    __cil_tmp112 = (unsigned long )pHba;
#line 3468
    __cil_tmp113 = __cil_tmp112 + 8;
#line 3468
    __cil_tmp114 = *((struct pci_dev **)__cil_tmp113);
#line 3468
    __cil_tmp115 = (unsigned long )__cil_tmp114;
#line 3468
    __cil_tmp116 = __cil_tmp115 + 144;
#line 3468
    __cil_tmp117 = (struct device *)__cil_tmp116;
#line 3468
    __cil_tmp118 = buflen + 8;
#line 3468
    __cil_tmp119 = (unsigned long )__cil_tmp118;
#line 3468
    __cil_tmp120 = (void *)resblk_va;
#line 3468
    __cil_tmp121 = & resblk_pa;
#line 3468
    __cil_tmp122 = *__cil_tmp121;
#line 3468
    __cil_tmp123 = (struct dma_attrs *)0;
#line 3468
    dma_free_attrs(__cil_tmp117, __cil_tmp119, __cil_tmp120, __cil_tmp122, __cil_tmp123);
#line 3470
    __cil_tmp124 = (unsigned long )pHba;
#line 3470
    __cil_tmp125 = __cil_tmp124 + 114;
#line 3470
    __cil_tmp126 = (char (*)[32U])__cil_tmp125;
#line 3470
    __cil_tmp127 = (char *)__cil_tmp126;
#line 3470
    printk("<4>%s: issue params failed; Interrupted.\n", __cil_tmp127);
    }
#line 3471
    return (-4);
  } else {

  }
  {
#line 3474
  __len___0 = (size_t )buflen;
#line 3474
  __cil_tmp128 = (void    *)resblk_va;
#line 3474
  __cil_tmp129 = __cil_tmp128 + 8U;
#line 3474
  __ret___0 = __builtin_memcpy(buf, __cil_tmp129, __len___0);
#line 3476
  __cil_tmp130 = (unsigned long )pHba;
#line 3476
  __cil_tmp131 = __cil_tmp130 + 8;
#line 3476
  __cil_tmp132 = *((struct pci_dev **)__cil_tmp131);
#line 3476
  __cil_tmp133 = (unsigned long )__cil_tmp132;
#line 3476
  __cil_tmp134 = __cil_tmp133 + 144;
#line 3476
  __cil_tmp135 = (struct device *)__cil_tmp134;
#line 3476
  __cil_tmp136 = buflen + 8;
#line 3476
  __cil_tmp137 = (unsigned long )__cil_tmp136;
#line 3476
  __cil_tmp138 = (void *)resblk_va;
#line 3476
  __cil_tmp139 = & resblk_pa;
#line 3476
  __cil_tmp140 = *__cil_tmp139;
#line 3476
  __cil_tmp141 = (struct dma_attrs *)0;
#line 3476
  dma_free_attrs(__cil_tmp135, __cil_tmp137, __cil_tmp138, __cil_tmp140, __cil_tmp141);
  }
#line 3478
  if (size < 0) {
#line 3479
    return (size);
  } else {

  }
#line 3481
  return (buflen);
}
}
#line 3493 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_issue_params(int cmd , adpt_hba *pHba , int tid , void *opblk_va ,
                                 dma_addr_t opblk_pa , int oplen , void *resblk_va ,
                                 dma_addr_t resblk_pa , int reslen ) 
{ u32 msg[9U] ;
  u32 *res ;
  int wait_status ;
  char *tmp ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  u32 *__cil_tmp37 ;
  u32 *__cil_tmp38 ;
  u32 __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  char (*__cil_tmp43)[32U] ;
  char *__cil_tmp44 ;
  u32 *__cil_tmp45 ;
  u32 __cil_tmp46 ;
  u32 __cil_tmp47 ;
  u32 *__cil_tmp48 ;
  u32 __cil_tmp49 ;
  u32 __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  u32 *__cil_tmp52 ;
  u32 __cil_tmp53 ;
  unsigned int __cil_tmp54 ;
  u32 *__cil_tmp55 ;
  u32 __cil_tmp56 ;
  u32 __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  u32 *__cil_tmp60 ;
  u32 __cil_tmp61 ;
  unsigned int __cil_tmp62 ;
  unsigned int __cil_tmp63 ;
  unsigned int __cil_tmp64 ;

  {
  {
#line 3498
  res = (u32 *)resblk_va;
#line 3501
  __cil_tmp14 = 0 * 4UL;
#line 3501
  __cil_tmp15 = (unsigned long )(msg) + __cil_tmp14;
#line 3501
  *((u32 *)__cil_tmp15) = 589905U;
#line 3502
  __cil_tmp16 = 1 * 4UL;
#line 3502
  __cil_tmp17 = (unsigned long )(msg) + __cil_tmp16;
#line 3502
  __cil_tmp18 = cmd << 24;
#line 3502
  __cil_tmp19 = __cil_tmp18 | 4096;
#line 3502
  __cil_tmp20 = __cil_tmp19 | tid;
#line 3502
  *((u32 *)__cil_tmp17) = (u32 )__cil_tmp20;
#line 3503
  __cil_tmp21 = 2 * 4UL;
#line 3503
  __cil_tmp22 = (unsigned long )(msg) + __cil_tmp21;
#line 3503
  *((u32 *)__cil_tmp22) = 0U;
#line 3504
  __cil_tmp23 = 3 * 4UL;
#line 3504
  __cil_tmp24 = (unsigned long )(msg) + __cil_tmp23;
#line 3504
  *((u32 *)__cil_tmp24) = 0U;
#line 3505
  __cil_tmp25 = 4 * 4UL;
#line 3505
  __cil_tmp26 = (unsigned long )(msg) + __cil_tmp25;
#line 3505
  *((u32 *)__cil_tmp26) = 0U;
#line 3506
  __cil_tmp27 = 5 * 4UL;
#line 3506
  __cil_tmp28 = (unsigned long )(msg) + __cil_tmp27;
#line 3506
  __cil_tmp29 = oplen | 1409286144;
#line 3506
  *((u32 *)__cil_tmp28) = (u32 )__cil_tmp29;
#line 3507
  __cil_tmp30 = 6 * 4UL;
#line 3507
  __cil_tmp31 = (unsigned long )(msg) + __cil_tmp30;
#line 3507
  *((u32 *)__cil_tmp31) = (unsigned int )opblk_pa;
#line 3508
  __cil_tmp32 = 7 * 4UL;
#line 3508
  __cil_tmp33 = (unsigned long )(msg) + __cil_tmp32;
#line 3508
  __cil_tmp34 = (unsigned int )reslen;
#line 3508
  *((u32 *)__cil_tmp33) = __cil_tmp34 | 3489660928U;
#line 3509
  __cil_tmp35 = 8 * 4UL;
#line 3509
  __cil_tmp36 = (unsigned long )(msg) + __cil_tmp35;
#line 3509
  *((u32 *)__cil_tmp36) = (unsigned int )resblk_pa;
#line 3511
  __cil_tmp37 = (u32 *)(& msg);
#line 3511
  wait_status = adpt_i2o_post_wait(pHba, __cil_tmp37, 36, 20);
  }
#line 3511
  if (wait_status != 0) {
    {
#line 3512
    printk("adpt_i2o_issue_params: post_wait failed (%p)\n", resblk_va);
    }
#line 3513
    return (wait_status);
  } else {

  }
  {
#line 3516
  __cil_tmp38 = res + 1UL;
#line 3516
  __cil_tmp39 = *__cil_tmp38;
#line 3516
  __cil_tmp40 = __cil_tmp39 & 16711680U;
#line 3516
  if (__cil_tmp40 != 0U) {
#line 3517
    if (cmd == 5) {
#line 3517
      tmp = (char *)"PARAMS_SET";
    } else {
#line 3517
      tmp = (char *)"PARAMS_GET";
    }
    {
#line 3517
    __cil_tmp41 = (unsigned long )pHba;
#line 3517
    __cil_tmp42 = __cil_tmp41 + 114;
#line 3517
    __cil_tmp43 = (char (*)[32U])__cil_tmp42;
#line 3517
    __cil_tmp44 = (char *)__cil_tmp43;
#line 3517
    __cil_tmp45 = res + 1UL;
#line 3517
    __cil_tmp46 = *__cil_tmp45;
#line 3517
    __cil_tmp47 = __cil_tmp46 >> 24;
#line 3517
    __cil_tmp48 = res + 1UL;
#line 3517
    __cil_tmp49 = *__cil_tmp48;
#line 3517
    __cil_tmp50 = __cil_tmp49 >> 16;
#line 3517
    __cil_tmp51 = __cil_tmp50 & 255U;
#line 3517
    __cil_tmp52 = res + 1UL;
#line 3517
    __cil_tmp53 = *__cil_tmp52;
#line 3517
    __cil_tmp54 = __cil_tmp53 & 65535U;
#line 3517
    printk("<4>%s: %s - Error:\n  ErrorInfoSize = 0x%02x, BlockStatus = 0x%02x, BlockSize = 0x%04x\n",
           __cil_tmp44, tmp, __cil_tmp47, __cil_tmp51, __cil_tmp54);
    }
    {
#line 3523
    __cil_tmp55 = res + 1UL;
#line 3523
    __cil_tmp56 = *__cil_tmp55;
#line 3523
    __cil_tmp57 = __cil_tmp56 >> 16;
#line 3523
    __cil_tmp58 = __cil_tmp57 & 255U;
#line 3523
    __cil_tmp59 = - __cil_tmp58;
#line 3523
    return ((int )__cil_tmp59);
    }
  } else {

  }
  }
  {
#line 3526
  __cil_tmp60 = res + 1UL;
#line 3526
  __cil_tmp61 = *__cil_tmp60;
#line 3526
  __cil_tmp62 = __cil_tmp61 & 65535U;
#line 3526
  __cil_tmp63 = __cil_tmp62 << 2;
#line 3526
  __cil_tmp64 = __cil_tmp63 + 4U;
#line 3526
  return ((int )__cil_tmp64);
  }
}
}
#line 3530 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static s32 adpt_i2o_quiesce_hba(adpt_hba *pHba ) 
{ u32 msg[4U] ;
  int ret ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  i2o_status_block *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  __u8 __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  i2o_status_block *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  __u8 __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  u32 *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;

  {
  {
#line 3535
  adpt_i2o_status_get(pHba);
  }
  {
#line 3539
  __cil_tmp4 = (unsigned long )pHba;
#line 3539
  __cil_tmp5 = __cil_tmp4 + 296;
#line 3539
  __cil_tmp6 = *((i2o_status_block **)__cil_tmp5);
#line 3539
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 3539
  __cil_tmp8 = __cil_tmp7 + 10;
#line 3539
  __cil_tmp9 = *((__u8 *)__cil_tmp8);
#line 3539
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 3539
  if (__cil_tmp10 != 5U) {
    {
#line 3539
    __cil_tmp11 = (unsigned long )pHba;
#line 3539
    __cil_tmp12 = __cil_tmp11 + 296;
#line 3539
    __cil_tmp13 = *((i2o_status_block **)__cil_tmp12);
#line 3539
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 3539
    __cil_tmp15 = __cil_tmp14 + 10;
#line 3539
    __cil_tmp16 = *((__u8 *)__cil_tmp15);
#line 3539
    __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 3539
    if (__cil_tmp17 != 8U) {
#line 3541
      return (0);
    } else {

    }
    }
  } else {

  }
  }
  {
#line 3544
  __cil_tmp18 = 0 * 4UL;
#line 3544
  __cil_tmp19 = (unsigned long )(msg) + __cil_tmp18;
#line 3544
  *((u32 *)__cil_tmp19) = 262145U;
#line 3545
  __cil_tmp20 = 1 * 4UL;
#line 3545
  __cil_tmp21 = (unsigned long )(msg) + __cil_tmp20;
#line 3545
  *((u32 *)__cil_tmp21) = 3271561216U;
#line 3546
  __cil_tmp22 = 2 * 4UL;
#line 3546
  __cil_tmp23 = (unsigned long )(msg) + __cil_tmp22;
#line 3546
  *((u32 *)__cil_tmp23) = 0U;
#line 3547
  __cil_tmp24 = 3 * 4UL;
#line 3547
  __cil_tmp25 = (unsigned long )(msg) + __cil_tmp24;
#line 3547
  *((u32 *)__cil_tmp25) = 0U;
#line 3549
  __cil_tmp26 = (u32 *)(& msg);
#line 3549
  ret = adpt_i2o_post_wait(pHba, __cil_tmp26, 16, 240);
  }
#line 3549
  if (ret != 0) {
    {
#line 3550
    __cil_tmp27 = (unsigned long )pHba;
#line 3550
    __cil_tmp28 = __cil_tmp27 + 104;
#line 3550
    __cil_tmp29 = *((int *)__cil_tmp28);
#line 3550
    __cil_tmp30 = - ret;
#line 3550
    printk("<6>dpti%d: Unable to quiesce (status=%#x).\n", __cil_tmp29, __cil_tmp30);
    }
  } else {
    {
#line 3553
    __cil_tmp31 = (unsigned long )pHba;
#line 3553
    __cil_tmp32 = __cil_tmp31 + 104;
#line 3553
    __cil_tmp33 = *((int *)__cil_tmp32);
#line 3553
    printk("<6>dpti%d: Quiesced.\n", __cil_tmp33);
    }
  }
  {
#line 3556
  adpt_i2o_status_get(pHba);
  }
#line 3557
  return (ret);
}
}
#line 3564 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_enable_hba(adpt_hba *pHba ) 
{ u32 msg[4U] ;
  int ret ;
  i2o_status_block *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  i2o_status_block *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  i2o_status_block *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  __u8 __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  i2o_status_block *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  __u8 __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  u32 *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  char (*__cil_tmp35)[32U] ;
  char *__cil_tmp36 ;

  {
  {
#line 3569
  adpt_i2o_status_get(pHba);
  }
  {
#line 3570
  __cil_tmp4 = (i2o_status_block *)0;
#line 3570
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 3570
  __cil_tmp6 = (unsigned long )pHba;
#line 3570
  __cil_tmp7 = __cil_tmp6 + 296;
#line 3570
  __cil_tmp8 = *((i2o_status_block **)__cil_tmp7);
#line 3570
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 3570
  if (__cil_tmp9 == __cil_tmp5) {
#line 3571
    return (-12);
  } else {

  }
  }
  {
#line 3574
  __cil_tmp10 = (unsigned long )pHba;
#line 3574
  __cil_tmp11 = __cil_tmp10 + 296;
#line 3574
  __cil_tmp12 = *((i2o_status_block **)__cil_tmp11);
#line 3574
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 3574
  __cil_tmp14 = __cil_tmp13 + 10;
#line 3574
  __cil_tmp15 = *((__u8 *)__cil_tmp14);
#line 3574
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 3574
  if (__cil_tmp16 == 8U) {
#line 3575
    return (0);
  } else {

  }
  }
  {
#line 3577
  __cil_tmp17 = (unsigned long )pHba;
#line 3577
  __cil_tmp18 = __cil_tmp17 + 296;
#line 3577
  __cil_tmp19 = *((i2o_status_block **)__cil_tmp18);
#line 3577
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 3577
  __cil_tmp21 = __cil_tmp20 + 10;
#line 3577
  __cil_tmp22 = *((__u8 *)__cil_tmp21);
#line 3577
  __cil_tmp23 = (unsigned int )__cil_tmp22;
#line 3577
  if (__cil_tmp23 != 5U) {
#line 3578
    return (-22);
  } else {

  }
  }
  {
#line 3580
  __cil_tmp24 = 0 * 4UL;
#line 3580
  __cil_tmp25 = (unsigned long )(msg) + __cil_tmp24;
#line 3580
  *((u32 *)__cil_tmp25) = 262145U;
#line 3581
  __cil_tmp26 = 1 * 4UL;
#line 3581
  __cil_tmp27 = (unsigned long )(msg) + __cil_tmp26;
#line 3581
  *((u32 *)__cil_tmp27) = 3506442240U;
#line 3582
  __cil_tmp28 = 2 * 4UL;
#line 3582
  __cil_tmp29 = (unsigned long )(msg) + __cil_tmp28;
#line 3582
  *((u32 *)__cil_tmp29) = 0U;
#line 3583
  __cil_tmp30 = 3 * 4UL;
#line 3583
  __cil_tmp31 = (unsigned long )(msg) + __cil_tmp30;
#line 3583
  *((u32 *)__cil_tmp31) = 0U;
#line 3585
  __cil_tmp32 = (u32 *)(& msg);
#line 3585
  ret = adpt_i2o_post_wait(pHba, __cil_tmp32, 16, 240);
  }
#line 3585
  if (ret != 0) {
    {
#line 3586
    __cil_tmp33 = (unsigned long )pHba;
#line 3586
    __cil_tmp34 = __cil_tmp33 + 114;
#line 3586
    __cil_tmp35 = (char (*)[32U])__cil_tmp34;
#line 3586
    __cil_tmp36 = (char *)__cil_tmp35;
#line 3586
    printk("<4>%s: Could not enable (status=%#10x).\n", __cil_tmp36, ret);
    }
  } else {

  }
  {
#line 3592
  adpt_i2o_status_get(pHba);
  }
#line 3593
  return (ret);
}
}
#line 3597 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_i2o_systab_send(adpt_hba *pHba ) 
{ u32 msg[12U] ;
  int ret ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  dma_addr_t *__cil_tmp26 ;
  dma_addr_t __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  u32 *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  char (*__cil_tmp39)[32U] ;
  char *__cil_tmp40 ;

  {
  {
#line 3602
  __cil_tmp4 = 0 * 4UL;
#line 3602
  __cil_tmp5 = (unsigned long )(msg) + __cil_tmp4;
#line 3602
  *((u32 *)__cil_tmp5) = 786529U;
#line 3603
  __cil_tmp6 = 1 * 4UL;
#line 3603
  __cil_tmp7 = (unsigned long )(msg) + __cil_tmp6;
#line 3603
  *((u32 *)__cil_tmp7) = 2734690304U;
#line 3604
  __cil_tmp8 = 2 * 4UL;
#line 3604
  __cil_tmp9 = (unsigned long )(msg) + __cil_tmp8;
#line 3604
  *((u32 *)__cil_tmp9) = 0U;
#line 3605
  __cil_tmp10 = 3 * 4UL;
#line 3605
  __cil_tmp11 = (unsigned long )(msg) + __cil_tmp10;
#line 3605
  *((u32 *)__cil_tmp11) = 0U;
#line 3606
  __cil_tmp12 = 4 * 4UL;
#line 3606
  __cil_tmp13 = (unsigned long )(msg) + __cil_tmp12;
#line 3606
  __cil_tmp14 = (unsigned long )pHba;
#line 3606
  __cil_tmp15 = __cil_tmp14 + 104;
#line 3606
  __cil_tmp16 = *((int *)__cil_tmp15);
#line 3606
  __cil_tmp17 = __cil_tmp16 + 2;
#line 3606
  __cil_tmp18 = __cil_tmp17 << 12;
#line 3606
  *((u32 *)__cil_tmp13) = (u32 )__cil_tmp18;
#line 3607
  __cil_tmp19 = 5 * 4UL;
#line 3607
  __cil_tmp20 = (unsigned long )(msg) + __cil_tmp19;
#line 3607
  *((u32 *)__cil_tmp20) = 0U;
#line 3614
  __cil_tmp21 = 6 * 4UL;
#line 3614
  __cil_tmp22 = (unsigned long )(msg) + __cil_tmp21;
#line 3614
  __cil_tmp23 = sys_tbl_len | 1409286144;
#line 3614
  *((u32 *)__cil_tmp22) = (u32 )__cil_tmp23;
#line 3615
  __cil_tmp24 = 7 * 4UL;
#line 3615
  __cil_tmp25 = (unsigned long )(msg) + __cil_tmp24;
#line 3615
  __cil_tmp26 = & sys_tbl_pa;
#line 3615
  __cil_tmp27 = *__cil_tmp26;
#line 3615
  *((u32 *)__cil_tmp25) = (unsigned int )__cil_tmp27;
#line 3616
  __cil_tmp28 = 8 * 4UL;
#line 3616
  __cil_tmp29 = (unsigned long )(msg) + __cil_tmp28;
#line 3616
  *((u32 *)__cil_tmp29) = 1409286144U;
#line 3617
  __cil_tmp30 = 9 * 4UL;
#line 3617
  __cil_tmp31 = (unsigned long )(msg) + __cil_tmp30;
#line 3617
  *((u32 *)__cil_tmp31) = 0U;
#line 3618
  __cil_tmp32 = 10 * 4UL;
#line 3618
  __cil_tmp33 = (unsigned long )(msg) + __cil_tmp32;
#line 3618
  *((u32 *)__cil_tmp33) = 3556769792U;
#line 3619
  __cil_tmp34 = 11 * 4UL;
#line 3619
  __cil_tmp35 = (unsigned long )(msg) + __cil_tmp34;
#line 3619
  *((u32 *)__cil_tmp35) = 0U;
#line 3621
  __cil_tmp36 = (u32 *)(& msg);
#line 3621
  ret = adpt_i2o_post_wait(pHba, __cil_tmp36, 48, 120);
  }
#line 3621
  if (ret != 0) {
    {
#line 3622
    __cil_tmp37 = (unsigned long )pHba;
#line 3622
    __cil_tmp38 = __cil_tmp37 + 114;
#line 3622
    __cil_tmp39 = (char (*)[32U])__cil_tmp38;
#line 3622
    __cil_tmp40 = (char *)__cil_tmp39;
#line 3622
    printk("<6>%s: Unable to set SysTab (status=%#10x).\n", __cil_tmp40, ret);
    }
  } else {

  }
#line 3631
  return (ret);
}
}
#line 3653 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static struct scsi_host_template driver_template  = 
#line 3653
     {& __this_module, "dpt_i2o", (int (*)(struct scsi_host_template * ))0, (int (*)(struct Scsi_Host * ))0,
    & adpt_info, (int (*)(struct scsi_device * , int  , void * ))0, (int (*)(struct scsi_device * ,
                                                                             int  ,
                                                                             void * ))0,
    & adpt_queue, (int (*)(struct scsi_cmnd * , void (*)(struct scsi_cmnd * ) ))0,
    & adpt_abort, & adpt_device_reset, (int (*)(struct scsi_cmnd * ))0, & adpt_bus_reset,
    & adpt_reset, (int (*)(struct scsi_device * ))0, & adpt_slave_configure, (void (*)(struct scsi_device * ))0,
    (int (*)(struct scsi_target * ))0, (void (*)(struct scsi_target * ))0, (int (*)(struct Scsi_Host * ,
                                                                                    unsigned long  ))0,
    (void (*)(struct Scsi_Host * ))0, (int (*)(struct scsi_device * , int  , int  ))0,
    (int (*)(struct scsi_device * , int  ))0, & adpt_bios_param, (void (*)(struct scsi_device * ))0,
    & adpt_proc_info, (enum blk_eh_timer_return (*)(struct scsi_cmnd * ))0, (int (*)(struct Scsi_Host * ,
                                                                                     int  ))0,
    "dpt_i2o", (struct proc_dir_entry *)0, 255, 7, (unsigned short)0, (unsigned short)0,
    (unsigned short)0, 0UL, (short)1, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (struct device_attribute **)0,
    (struct device_attribute **)0, {(struct list_head *)0, (struct list_head *)0},
    0ULL};
#line 3672 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static int adpt_init(void) 
{ int error ;
  adpt_hba *pHba ;
  adpt_hba *next ;
  adpt_hba *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  struct Scsi_Host *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  struct pci_dev *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct device *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct Scsi_Host *__cil_tmp18 ;
  adpt_hba *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  struct Scsi_Host *__cil_tmp24 ;
  adpt_hba *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;

  {
  {
#line 3677
  printk("Loading Adaptec I2O RAID: Version 2.4 Build 5go\n");
#line 3679
  error = adpt_detect(& driver_template);
  }
#line 3680
  if (error < 0) {
#line 3681
    return (error);
  } else {

  }
  {
#line 3682
  __cil_tmp4 = (adpt_hba *)0;
#line 3682
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 3682
  __cil_tmp6 = (unsigned long )hba_chain;
#line 3682
  if (__cil_tmp6 == __cil_tmp5) {
#line 3683
    return (-19);
  } else {

  }
  }
#line 3685
  pHba = hba_chain;
#line 3685
  goto ldv_32955;
  ldv_32954: 
  {
#line 3686
  __cil_tmp7 = (unsigned long )pHba;
#line 3686
  __cil_tmp8 = __cil_tmp7 + 16;
#line 3686
  __cil_tmp9 = *((struct Scsi_Host **)__cil_tmp8);
#line 3686
  __cil_tmp10 = (unsigned long )pHba;
#line 3686
  __cil_tmp11 = __cil_tmp10 + 8;
#line 3686
  __cil_tmp12 = *((struct pci_dev **)__cil_tmp11);
#line 3686
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 3686
  __cil_tmp14 = __cil_tmp13 + 144;
#line 3686
  __cil_tmp15 = (struct device *)__cil_tmp14;
#line 3686
  error = scsi_add_host(__cil_tmp9, __cil_tmp15);
  }
#line 3687
  if (error != 0) {
#line 3688
    goto fail;
  } else {

  }
  {
#line 3689
  __cil_tmp16 = (unsigned long )pHba;
#line 3689
  __cil_tmp17 = __cil_tmp16 + 16;
#line 3689
  __cil_tmp18 = *((struct Scsi_Host **)__cil_tmp17);
#line 3689
  scsi_scan_host(__cil_tmp18);
#line 3685
  pHba = *((struct _adpt_hba **)pHba);
  }
  ldv_32955: ;
  {
#line 3685
  __cil_tmp19 = (adpt_hba *)0;
#line 3685
  __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 3685
  __cil_tmp21 = (unsigned long )pHba;
#line 3685
  if (__cil_tmp21 != __cil_tmp20) {
#line 3686
    goto ldv_32954;
  } else {
#line 3688
    goto ldv_32956;
  }
  }
  ldv_32956: ;
#line 3691
  return (0);
  fail: 
#line 3693
  pHba = hba_chain;
#line 3693
  goto ldv_32958;
  ldv_32957: 
  {
#line 3694
  next = *((struct _adpt_hba **)pHba);
#line 3695
  __cil_tmp22 = (unsigned long )pHba;
#line 3695
  __cil_tmp23 = __cil_tmp22 + 16;
#line 3695
  __cil_tmp24 = *((struct Scsi_Host **)__cil_tmp23);
#line 3695
  scsi_remove_host(__cil_tmp24);
#line 3693
  pHba = next;
  }
  ldv_32958: ;
  {
#line 3693
  __cil_tmp25 = (adpt_hba *)0;
#line 3693
  __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 3693
  __cil_tmp27 = (unsigned long )pHba;
#line 3693
  if (__cil_tmp27 != __cil_tmp26) {
#line 3694
    goto ldv_32957;
  } else {
#line 3696
    goto ldv_32959;
  }
  }
  ldv_32959: ;
#line 3697
  return (error);
}
}
#line 3700 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
static void adpt_exit(void) 
{ adpt_hba *pHba ;
  adpt_hba *next ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  struct Scsi_Host *__cil_tmp5 ;
  adpt_hba *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  struct Scsi_Host *__cil_tmp11 ;
  adpt_hba *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;

  {
#line 3704
  pHba = hba_chain;
#line 3704
  goto ldv_32966;
  ldv_32965: 
  {
#line 3705
  __cil_tmp3 = (unsigned long )pHba;
#line 3705
  __cil_tmp4 = __cil_tmp3 + 16;
#line 3705
  __cil_tmp5 = *((struct Scsi_Host **)__cil_tmp4);
#line 3705
  scsi_remove_host(__cil_tmp5);
#line 3704
  pHba = *((struct _adpt_hba **)pHba);
  }
  ldv_32966: ;
  {
#line 3704
  __cil_tmp6 = (adpt_hba *)0;
#line 3704
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 3704
  __cil_tmp8 = (unsigned long )pHba;
#line 3704
  if (__cil_tmp8 != __cil_tmp7) {
#line 3705
    goto ldv_32965;
  } else {
#line 3707
    goto ldv_32967;
  }
  }
  ldv_32967: 
#line 3706
  pHba = hba_chain;
#line 3706
  goto ldv_32969;
  ldv_32968: 
  {
#line 3707
  next = *((struct _adpt_hba **)pHba);
#line 3708
  __cil_tmp9 = (unsigned long )pHba;
#line 3708
  __cil_tmp10 = __cil_tmp9 + 16;
#line 3708
  __cil_tmp11 = *((struct Scsi_Host **)__cil_tmp10);
#line 3708
  adpt_release(__cil_tmp11);
#line 3706
  pHba = next;
  }
  ldv_32969: ;
  {
#line 3706
  __cil_tmp12 = (adpt_hba *)0;
#line 3706
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 3706
  __cil_tmp14 = (unsigned long )pHba;
#line 3706
  if (__cil_tmp14 != __cil_tmp13) {
#line 3707
    goto ldv_32968;
  } else {
#line 3709
    goto ldv_32970;
  }
  }
  ldv_32970: ;
#line 3711
  return;
}
}
#line 3733
extern void ldv_check_final_state(void) ;
#line 3736
extern void ldv_check_return_value(int  ) ;
#line 3739
extern void ldv_initialize(void) ;
#line 3742
extern int __VERIFIER_nondet_int(void) ;
#line 3745 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
int LDV_IN_INTERRUPT  ;
#line 3748 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void main(void) 
{ struct file *var_group1 ;
  uint var_adpt_unlocked_ioctl_39_p1 ;
  ulong var_adpt_unlocked_ioctl_39_p2 ;
  struct inode *var_group2 ;
  int res_adpt_open_30 ;
  unsigned int var_compat_adpt_ioctl_40_p1 ;
  unsigned long var_compat_adpt_ioctl_40_p2 ;
  struct Scsi_Host *var_group3 ;
  char *var_adpt_proc_info_9_p1 ;
  char **var_adpt_proc_info_9_p2 ;
  off_t var_adpt_proc_info_9_p3 ;
  int var_adpt_proc_info_9_p4 ;
  int var_adpt_proc_info_9_p5 ;
  struct scsi_cmnd *var_group4 ;
  struct scsi_cmnd *var_group5 ;
  struct scsi_device *var_group6 ;
  int var_adpt_isr_41_p0 ;
  void *var_adpt_isr_41_p1 ;
  int ldv_s_adpt_fops_file_operations ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4569
  ldv_s_adpt_fops_file_operations = 0;
#line 4498
  LDV_IN_INTERRUPT = 1;
#line 4507
  ldv_initialize();
#line 4567
  tmp = adpt_init();
  }
#line 4567
  if (tmp != 0) {
#line 4568
    goto ldv_final;
  } else {

  }
#line 4577
  goto ldv_33030;
  ldv_33029: 
  {
#line 4581
  tmp___0 = __VERIFIER_nondet_int();
  }
#line 4583
  if (tmp___0 == 0) {
#line 4583
    goto case_0;
  } else
#line 4658
  if (tmp___0 == 1) {
#line 4658
    goto case_1;
  } else
#line 4730
  if (tmp___0 == 2) {
#line 4730
    goto case_2;
  } else
#line 4802
  if (tmp___0 == 3) {
#line 4802
    goto case_3;
  } else
#line 4874
  if (tmp___0 == 4) {
#line 4874
    goto case_4;
  } else
#line 4946
  if (tmp___0 == 5) {
#line 4946
    goto case_5;
  } else
#line 5018
  if (tmp___0 == 6) {
#line 5018
    goto case_6;
  } else
#line 5090
  if (tmp___0 == 7) {
#line 5090
    goto case_7;
  } else
#line 5162
  if (tmp___0 == 8) {
#line 5162
    goto case_8;
  } else
#line 5234
  if (tmp___0 == 9) {
#line 5234
    goto case_9;
  } else
#line 5306
  if (tmp___0 == 10) {
#line 5306
    goto case_10;
  } else
#line 5378
  if (tmp___0 == 11) {
#line 5378
    goto case_11;
  } else {
    {
#line 5450
    goto switch_default;
#line 4581
    if (0) {
      case_0: /* CIL Label */ ;
#line 4586
      if (ldv_s_adpt_fops_file_operations == 0) {
        {
#line 4614
        res_adpt_open_30 = adpt_open(var_group2, var_group1);
#line 4615
        ldv_check_return_value(res_adpt_open_30);
        }
#line 4616
        if (res_adpt_open_30 != 0) {
#line 4617
          goto ldv_module_exit;
        } else {

        }
#line 4651
        ldv_s_adpt_fops_file_operations = ldv_s_adpt_fops_file_operations + 1;
      } else {

      }
#line 4657
      goto ldv_33016;
      case_1: /* CIL Label */ ;
#line 4661
      if (ldv_s_adpt_fops_file_operations == 1) {
        {
#line 4689
        adpt_close(var_group2, var_group1);
#line 4723
        ldv_s_adpt_fops_file_operations = 0;
        }
      } else {

      }
#line 4729
      goto ldv_33016;
      case_2: /* CIL Label */ 
      {
#line 4778
      adpt_unlocked_ioctl(var_group1, var_adpt_unlocked_ioctl_39_p1, var_adpt_unlocked_ioctl_39_p2);
      }
#line 4801
      goto ldv_33016;
      case_3: /* CIL Label */ 
      {
#line 4851
      compat_adpt_ioctl(var_group1, var_compat_adpt_ioctl_40_p1, var_compat_adpt_ioctl_40_p2);
      }
#line 4873
      goto ldv_33016;
      case_4: /* CIL Label */ 
      {
#line 4893
      adpt_proc_info(var_group3, var_adpt_proc_info_9_p1, var_adpt_proc_info_9_p2,
                     var_adpt_proc_info_9_p3, var_adpt_proc_info_9_p4, var_adpt_proc_info_9_p5);
      }
#line 4945
      goto ldv_33016;
      case_5: /* CIL Label */ 
      {
#line 4965
      adpt_info(var_group3);
      }
#line 5017
      goto ldv_33016;
      case_6: /* CIL Label */ 
      {
#line 5043
      adpt_abort(var_group4);
      }
#line 5089
      goto ldv_33016;
      case_7: /* CIL Label */ 
      {
#line 5116
      adpt_device_reset(var_group5);
      }
#line 5161
      goto ldv_33016;
      case_8: /* CIL Label */ 
      {
#line 5189
      adpt_bus_reset(var_group5);
      }
#line 5233
      goto ldv_33016;
      case_9: /* CIL Label */ 
      {
#line 5261
      adpt_reset(var_group5);
      }
#line 5305
      goto ldv_33016;
      case_10: /* CIL Label */ 
      {
#line 5325
      adpt_slave_configure(var_group6);
      }
#line 5377
      goto ldv_33016;
      case_11: /* CIL Label */ 
      {
#line 5381
      LDV_IN_INTERRUPT = 2;
#line 5428
      adpt_isr(var_adpt_isr_41_p0, var_adpt_isr_41_p1);
#line 5443
      LDV_IN_INTERRUPT = 1;
      }
#line 5449
      goto ldv_33016;
      switch_default: /* CIL Label */ ;
#line 5450
      goto ldv_33016;
    } else {
      switch_break: /* CIL Label */ ;
    }
    }
  }
  ldv_33016: ;
  ldv_33030: 
  {
#line 4577
  tmp___1 = __VERIFIER_nondet_int();
  }
#line 4577
  if (tmp___1 != 0) {
#line 4579
    goto ldv_33029;
  } else
#line 4577
  if (ldv_s_adpt_fops_file_operations != 0) {
#line 4579
    goto ldv_33029;
  } else {
#line 4581
    goto ldv_33031;
  }
  ldv_33031: ;
  ldv_module_exit: 
  {
#line 5516
  adpt_exit();
  }
  ldv_final: 
  {
#line 5519
  ldv_check_final_state();
  }
#line 5522
  return;
}
}
#line 5 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/kernel-rules/files/engine-blast-assert.h"
void ldv_blast_assert(void) 
{ 

  {
  ERROR: ;
#line 6
  goto ERROR;
}
}
#line 6 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/kernel-rules/files/engine-blast.h"
extern int __VERIFIER_nondet_int(void) ;
#line 5543 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
int ldv_spin  =    0;
#line 5547 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 

  {
#line 5550
  if (ldv_spin != 0) {
#line 5550
    if (flags != 32U) {
      {
#line 5550
      ldv_blast_assert();
      }
    } else {

    }
  } else {

  }
#line 5553
  return;
}
}
#line 5553
extern struct page *ldv_some_page(void) ;
#line 5556 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ struct page *tmp ;

  {
#line 5559
  if (ldv_spin != 0) {
#line 5559
    if (flags != 32U) {
      {
#line 5559
      ldv_blast_assert();
      }
    } else {

    }
  } else {

  }
  {
#line 5561
  tmp = ldv_some_page();
  }
#line 5561
  return (tmp);
}
}
#line 5565 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void ldv_check_alloc_nonatomic(void) 
{ 

  {
#line 5568
  if (ldv_spin != 0) {
    {
#line 5568
    ldv_blast_assert();
    }
  } else {

  }
#line 5571
  return;
}
}
#line 5572 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void ldv_spin_lock(void) 
{ 

  {
#line 5575
  ldv_spin = 1;
#line 5576
  return;
}
}
#line 5579 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void ldv_spin_unlock(void) 
{ 

  {
#line 5582
  ldv_spin = 0;
#line 5583
  return;
}
}
#line 5586 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
int ldv_spin_trylock(void) 
{ int is_lock ;

  {
  {
#line 5591
  is_lock = __VERIFIER_nondet_int();
  }
#line 5593
  if (is_lock != 0) {
#line 5596
    return (0);
  } else {
#line 5601
    ldv_spin = 1;
#line 5603
    return (1);
  }
}
}
#line 5607 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void spin_lock(spinlock_t *lock ) 
{ 

  {
  {
#line 5612
  ldv_spin_lock();
#line 5614
  ldv_spin_lock_1(lock);
  }
#line 5615
  return;
}
}
#line 5639 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
  {
#line 5644
  ldv_spin_lock();
#line 5646
  ldv_spin_lock_irq_4(lock);
  }
#line 5647
  return;
}
}
#line 5649 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 

  {
  {
#line 5654
  ldv_spin_unlock();
#line 5656
  ldv_spin_unlock_5(lock);
  }
#line 5657
  return;
}
}
#line 5669 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
  {
#line 5674
  ldv_spin_unlock();
#line 5676
  ldv_spin_unlock_irq_7(lock);
  }
#line 5677
  return;
}
}
#line 5679 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
#line 5685
  ldv_spin_unlock();
#line 5687
  ldv_spin_unlock_irqrestore_8(lock, flags);
  }
#line 5688
  return;
}
}
#line 5725 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 

  {
  {
#line 5731
  ldv_check_alloc_flags(flags);
#line 5733
  ldv_kmalloc_12(size, flags);
  }
#line 5734
  return ((void *)0);
}
}
#line 5770 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t ldv_func_arg2 ) 
{ 

  {
  {
#line 5776
  ldv_check_alloc_flags(ldv_func_arg2);
#line 5778
  kmem_cache_alloc(ldv_func_arg1, ldv_func_arg2);
  }
#line 5779
  return ((void *)0);
}
}
#line 5781 "/home/zakharov/launch/work/current--X--drivers/--X--defaultlinux-3.4--X--43_1a--X--cpachecker/linux-3.4/csd_deg_dscv/3986/dscv_tempdir/dscv/ri/43_1a/drivers/scsi/dpt_i2o.c.p"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 5787
  ldv_check_alloc_flags(flags);
#line 5788
  tmp = __VERIFIER_nondet_pointer();
  }
#line 5788
  return (tmp);
}
}
